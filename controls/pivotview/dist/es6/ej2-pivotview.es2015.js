import { Ajax, Browser, ChildProperty, Collection, Complex, Component, Draggable, Droppable, Event, EventHandler, Internationalization, KeyboardEvents, L10n, NotifyPropertyChanges, Property, SanitizeHtmlHelper, Touch, addClass, append, closest, compile, createElement, extend, formatUnit, getElement, getInstance, isBlazor, isNullOrUndefined, prepend, remove, removeClass, resetBlazorTemplate, setStyleAttribute, setValue, updateBlazorTemplate } from '@syncfusion/ej2-base';
import { DataManager, Deferred, Query } from '@syncfusion/ej2-data';
import { Dialog, Tooltip, createSpinner, hideSpinner, showSpinner } from '@syncfusion/ej2-popups';
import { ColumnChooser, CommandColumn, ContextMenu, Edit, ExcelExport, Freeze, Grid, Page, PdfExport, Reorder, Resize, Selection, Toolbar, VirtualScroll, getObject, headerRefreshed, setStyleAndAttributes } from '@syncfusion/ej2-grids';
import { Accordion, ContextMenu as ContextMenu$1, Menu, Tab, Toolbar as Toolbar$1, TreeView } from '@syncfusion/ej2-navigations';
import { ColorPicker, MaskedTextBox, NumericTextBox } from '@syncfusion/ej2-inputs';
import { CheckBoxSelection, DropDownList, MultiSelect } from '@syncfusion/ej2-dropdowns';
import { Workbook } from '@syncfusion/ej2-excel-export';
import { PdfBorders, PdfColor, PdfDocument, PdfFontFamily, PdfFontStyle, PdfGrid, PdfPageTemplateElement, PdfPen, PdfSolidBrush, PdfStandardFont, PdfStringFormat, PdfTextAlignment, PdfVerticalAlignment, PointF, RectangleF } from '@syncfusion/ej2-pdf-export';
import { AreaSeries, BarSeries, BubbleSeries, Category, Chart, ChartLocation, ColumnSeries, Crosshair, Export, Legend, LineSeries, MultiColoredAreaSeries, MultiColoredLineSeries, MultiLevelLabel, ParetoSeries, PolarSeries, RadarSeries, RangeAreaSeries, RangeColumnSeries, ScatterSeries, ScrollBar, SplineAreaSeries, SplineSeries, StackingAreaSeries, StackingBarSeries, StackingColumnSeries, StepAreaSeries, StepLineSeries, Tooltip as Tooltip$1, Zoom } from '@syncfusion/ej2-charts';
import { DateTimePicker } from '@syncfusion/ej2-calendars';
import { DropDownButton } from '@syncfusion/ej2-splitbuttons';
import { Button, CheckBox, RadioButton } from '@syncfusion/ej2-buttons';

/**
 * This is a file to perform common utility for OLAP and Relational datasource
 * @hidden
 */
class PivotUtil {
    static getType(value) {
        let val;
        val = (value && value.getDay) ? (value.getHours() > 0 || value.getMinutes() > 0 ||
            value.getSeconds() > 0 || value.getMilliseconds() > 0 ? 'datetime' : 'date') : typeof (value);
        return val;
    }
    static resetTime(date) {
        date.setHours(0, 0, 0, 0);
        return date;
    }
    static getClonedData(data) {
        let clonedData = [];
        if (data) {
            for (let item of data) {
                let fields = Object.keys(item);
                let keyPos = 0;
                /* tslint:disable */
                let framedSet = {};
                /* tslint:enable */
                while (keyPos < fields.length) {
                    framedSet[fields[keyPos]] = item[fields[keyPos]];
                    keyPos++;
                }
                clonedData.push(framedSet);
            }
        }
        return clonedData;
    }
    static getClonedPivotValues(pivotValues) {
        let clonedSets = [];
        for (let i = 0; i < pivotValues.length; i++) {
            if (pivotValues[i]) {
                clonedSets[i] = [];
                for (let j = 0; j < pivotValues[i].length; j++) {
                    if (pivotValues[i][j]) {
                        clonedSets[i][j] = this.getClonedObj(pivotValues[i][j]);
                    }
                }
            }
        }
        return clonedSets;
    }
    static getClonedObj(data) {
        let keyPos = 0;
        /* tslint:disable */
        let framedSet = {};
        /* tslint:enable */
        if (!(data === null || data === undefined)) {
            let fields = Object.keys(data);
            while (keyPos < fields.length) {
                framedSet[fields[keyPos]] = data[fields[keyPos]];
                keyPos++;
            }
        }
        else {
            framedSet = data;
        }
        return framedSet;
    }
    static inArray(value, collection) {
        if (collection) {
            for (let i = 0, cnt = collection.length; i < cnt; i++) {
                if (collection[i] === value) {
                    return i;
                }
            }
        }
        return -1;
    }
    static isContainCommonElements(collection1, collection2) {
        for (let i = 0, cnt = collection1.length; i < cnt; i++) {
            for (let j = 0, lnt = collection2.length; j < lnt; j++) {
                if (collection2[j] === collection1[i]) {
                    return true;
                }
            }
        }
        return false;
    }
    /* tslint:disable */
    static setPivotProperties(control, properties) {
        control.allowServerDataBinding = false;
        if (control.pivotGridModule) {
            control.pivotGridModule.allowServerDataBinding = false;
        }
        control.setProperties(properties, true);
        control.allowServerDataBinding = true;
        if (control.pivotGridModule) {
            control.pivotGridModule.allowServerDataBinding = true;
        }
    }
    /* tslint:enable */
    static getClonedDataSourceSettings(dataSourceSettings) {
        let clonesDataSource = {
            catalog: dataSourceSettings.catalog,
            cube: dataSourceSettings.cube,
            providerType: dataSourceSettings.providerType,
            url: dataSourceSettings.url,
            localeIdentifier: dataSourceSettings.localeIdentifier,
            excludeFields: isNullOrUndefined(dataSourceSettings.excludeFields) ? [] : [...dataSourceSettings.excludeFields],
            expandAll: dataSourceSettings.expandAll,
            allowLabelFilter: dataSourceSettings.allowLabelFilter,
            allowValueFilter: dataSourceSettings.allowValueFilter,
            allowMemberFilter: dataSourceSettings.allowMemberFilter,
            enableSorting: dataSourceSettings.enableSorting ? true : false,
            rows: this.cloneFieldSettings(dataSourceSettings.rows),
            columns: this.cloneFieldSettings(dataSourceSettings.columns),
            filters: this.cloneFieldSettings(dataSourceSettings.filters),
            values: this.cloneFieldSettings(dataSourceSettings.values),
            filterSettings: this.cloneFilterSettings(dataSourceSettings.filterSettings),
            sortSettings: this.cloneSortSettings(dataSourceSettings.sortSettings),
            drilledMembers: this.cloneDrillMemberSettings(dataSourceSettings.drilledMembers),
            valueSortSettings: this.CloneValueSortObject(dataSourceSettings.valueSortSettings),
            valueAxis: dataSourceSettings.valueAxis,
            formatSettings: this.cloneFormatSettings(dataSourceSettings.formatSettings),
            calculatedFieldSettings: this.cloneCalculatedFieldSettings(dataSourceSettings.calculatedFieldSettings),
            showSubTotals: dataSourceSettings.showSubTotals,
            showRowSubTotals: dataSourceSettings.showRowSubTotals,
            showColumnSubTotals: dataSourceSettings.showColumnSubTotals,
            showGrandTotals: dataSourceSettings.showGrandTotals,
            showRowGrandTotals: dataSourceSettings.showRowGrandTotals,
            showColumnGrandTotals: dataSourceSettings.showColumnGrandTotals,
            showHeaderWhenEmpty: dataSourceSettings.showHeaderWhenEmpty,
            alwaysShowValueHeader: dataSourceSettings.alwaysShowValueHeader,
            conditionalFormatSettings: this.cloneConditionalFormattingSettings(dataSourceSettings.conditionalFormatSettings),
            emptyCellsTextContent: dataSourceSettings.emptyCellsTextContent,
            groupSettings: this.cloneGroupSettings(dataSourceSettings.groupSettings)
        };
        return clonesDataSource;
    }
    static updateDataSourceSettings(control, dataSourceSettings) {
        if (control) {
            /* tslint:disable */
            this.setPivotProperties(control, {
                dataSourceSettings: {
                    catalog: dataSourceSettings.catalog,
                    cube: dataSourceSettings.cube,
                    providerType: dataSourceSettings.providerType,
                    url: dataSourceSettings.url,
                    localeIdentifier: dataSourceSettings.localeIdentifier,
                    excludeFields: isNullOrUndefined(dataSourceSettings.excludeFields) ? [] : dataSourceSettings.excludeFields,
                    expandAll: dataSourceSettings.expandAll,
                    allowLabelFilter: dataSourceSettings.allowLabelFilter,
                    allowValueFilter: dataSourceSettings.allowValueFilter,
                    allowMemberFilter: dataSourceSettings.allowMemberFilter,
                    enableSorting: dataSourceSettings.enableSorting ? true : false,
                    rows: dataSourceSettings.rows,
                    columns: dataSourceSettings.columns,
                    filters: dataSourceSettings.filters,
                    values: dataSourceSettings.values,
                    filterSettings: dataSourceSettings.filterSettings,
                    sortSettings: dataSourceSettings.sortSettings,
                    drilledMembers: dataSourceSettings.drilledMembers,
                    valueSortSettings: dataSourceSettings.valueSortSettings,
                    valueAxis: dataSourceSettings.valueAxis,
                    formatSettings: dataSourceSettings.formatSettings,
                    calculatedFieldSettings: dataSourceSettings.calculatedFieldSettings,
                    showSubTotals: dataSourceSettings.showSubTotals,
                    showRowSubTotals: dataSourceSettings.showRowSubTotals,
                    showColumnSubTotals: dataSourceSettings.showColumnSubTotals,
                    showGrandTotals: dataSourceSettings.showGrandTotals,
                    showRowGrandTotals: dataSourceSettings.showRowGrandTotals,
                    showColumnGrandTotals: dataSourceSettings.showColumnGrandTotals,
                    showHeaderWhenEmpty: dataSourceSettings.showHeaderWhenEmpty,
                    alwaysShowValueHeader: dataSourceSettings.alwaysShowValueHeader,
                    conditionalFormatSettings: dataSourceSettings.conditionalFormatSettings,
                    emptyCellsTextContent: dataSourceSettings.emptyCellsTextContent,
                    groupSettings: dataSourceSettings.groupSettings
                }
            });
        }
    }
    static cloneFieldSettings(collection) {
        if (collection) {
            let clonedCollection = [];
            for (let set of collection) {
                clonedCollection.push({
                    name: set.name,
                    caption: set.caption,
                    axis: set.axis,
                    baseField: set.baseField,
                    baseItem: set.baseItem,
                    isCalculatedField: set.isCalculatedField,
                    isNamedSet: set.isNamedSet,
                    showNoDataItems: set.showNoDataItems,
                    showSubTotals: set.showSubTotals,
                    type: set.type
                });
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneFilterSettings(collection) {
        if (collection) {
            let clonedCollection = [];
            for (let set of collection) {
                clonedCollection.push({
                    name: set.name,
                    type: set.type,
                    condition: set.condition,
                    items: set.items ? [...set.items] : set.items,
                    levelCount: set.levelCount,
                    measure: set.measure,
                    selectedField: set.selectedField,
                    showDateFilter: set.showDateFilter,
                    showLabelFilter: set.showLabelFilter,
                    showNumberFilter: set.showNumberFilter,
                    value1: set.value1,
                    value2: set.value2
                });
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneSortSettings(collection) {
        if (collection) {
            let clonedCollection = [];
            for (let set of collection) {
                clonedCollection.push({
                    name: set.name,
                    order: set.order
                });
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneDrillMemberSettings(collection) {
        if (collection) {
            let clonedCollection = [];
            for (let set of collection) {
                clonedCollection.push({
                    name: set.name,
                    delimiter: set.delimiter,
                    items: set.items ? [...set.items] : set.items
                });
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneFormatSettings(collection) {
        if (collection) {
            let clonedCollection = [];
            for (let set of collection) {
                clonedCollection.push({
                    name: set.name,
                    calendar: set.calendar,
                    currency: set.currency,
                    format: set.format,
                    maximumFractionDigits: set.maximumFractionDigits,
                    maximumSignificantDigits: set.maximumSignificantDigits,
                    minimumFractionDigits: set.minimumFractionDigits,
                    minimumIntegerDigits: set.minimumIntegerDigits,
                    minimumSignificantDigits: set.minimumSignificantDigits,
                    skeleton: set.skeleton,
                    type: set.type,
                    useGrouping: set.useGrouping
                });
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static CloneValueSortObject(collection) {
        if (collection) {
            let clonedCollection = {
                columnIndex: collection.columnIndex,
                headerDelimiter: collection.headerDelimiter,
                headerText: collection.headerText,
                measure: collection.measure,
                sortOrder: collection.sortOrder
            };
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneCalculatedFieldSettings(collection) {
        if (collection) {
            let clonedCollection = [];
            for (let set of collection) {
                clonedCollection.push({
                    name: set.name,
                    formatString: set.formatString,
                    formula: set.formula,
                    hierarchyUniqueName: set.hierarchyUniqueName
                });
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneConditionalFormattingSettings(collection) {
        if (collection) {
            let clonedCollection = [];
            for (let set of collection) {
                clonedCollection.push({
                    applyGrandTotals: set.applyGrandTotals,
                    conditions: set.conditions,
                    label: set.label,
                    measure: set.measure,
                    style: set.style ? {
                        backgroundColor: set.style.backgroundColor,
                        color: set.style.color,
                        fontFamily: set.style.fontFamily,
                        fontSize: set.style.fontSize
                    } : set.style,
                    value1: set.value1,
                    value2: set.value2
                });
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneGroupSettings(collection) {
        if (collection) {
            let clonedCollection = [];
            for (let set of collection) {
                clonedCollection.push({
                    name: set.name,
                    caption: set.caption,
                    customGroups: this.cloneCustomGroups(set.customGroups),
                    endingAt: set.endingAt,
                    startingAt: set.startingAt,
                    groupInterval: set.groupInterval,
                    rangeInterval: set.rangeInterval,
                    type: set.type
                });
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneCustomGroups(collection) {
        if (collection) {
            let clonedCollection = [];
            for (let set of collection) {
                clonedCollection.push({
                    groupName: set.groupName,
                    items: set.items ? [...set.items] : set.items
                });
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static getFilterItemByName(fieldName, fields) {
        let filterItems = new DataManager({ json: fields }).executeLocal(new Query().where('name', 'equal', fieldName));
        if (filterItems && filterItems.length > 0) {
            return filterItems[filterItems.length - 1];
        }
        return undefined;
    }
    /* tslint:disable-next-line:max-line-length */
    static getFieldByName(fieldName, fields) {
        return new DataManager({ json: fields }).executeLocal(new Query().where('name', 'equal', fieldName))[0];
    }
}

/**
 * PivotEngine is used to manipulate the relational or Multi-Dimensional data as pivoting values.
 */
/** @hidden */
class PivotEngine {
    constructor() {
        /** @hidden */
        this.aggregatedValueMatrix = [];
        /** @hidden */
        this.valueContent = [];
        /** @hidden */
        this.formatFields = {};
        /** @hidden */
        this.dateFormatFunction = {};
        /** @hidden */
        this.calculatedFields = {};
        /** @hidden */
        this.calculatedFormulas = {};
        /** @hidden */
        this.valueAxis = 0;
        /** @hidden */
        this.saveDataHeaders = {};
        /** @hidden */
        this.columnCount = 0;
        /** @hidden */
        this.rowCount = 0;
        /** @hidden */
        this.colFirstLvl = 0;
        /** @hidden */
        this.rowFirstLvl = 0;
        /** @hidden */
        this.rowStartPos = 0;
        /** @hidden */
        this.colStartPos = 0;
        /** @hidden */
        this.enableValueSorting = false;
        /** @hidden */
        this.headerCollection = { rowHeaders: [], columnHeaders: [], rowHeadersCount: 0, columnHeadersCount: 0 };
        /** @hidden */
        this.rMembers = [];
        /** @hidden */
        this.cMembers = [];
        /** @hidden */
        this.groupingFields = {};
        this.valueMatrix = [];
        this.indexMatrix = [];
        this.memberCnt = -1;
        this.pageInLimit = false;
        this.endPos = 0;
        this.removeCount = 0;
        this.colHdrBufferCalculated = false;
        this.colValuesLength = 1;
        this.rowValuesLength = 1;
        this.slicedHeaders = [];
        this.fieldFilterMem = {};
        this.filterPosObj = {};
        this.selectedHeaders = { selectedHeader: [], values: [] };
        this.rawIndexObject = {};
        this.isEditing = false;
        /** @hidden */
        this.data = [];
        /** @hidden */
        this.actualData = [];
        /** @hidden */
        this.groupRawIndex = {};
        this.allowDataCompression = false;
        this.dataSourceSettings = {};
        this.frameHeaderObjectsCollection = false;
        this.headerObjectsCollection = {};
        this.columnKeys = {};
        this.fieldDrillCollection = {};
        /* tslint:disable-next-line:max-line-length */
        this.customRegex = /^(('[^']+'|''|[^*#@0,.])*)(\*.)?((([0#,]*[0,]*[0#]*)(\.[0#]*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;
        this.formatRegex = /(^[ncpae]{1})([0-1]?[0-9]|20)?$/i;
        /* private makeMirrorObject(elements: number[], obj: NumberIndex): void {
             for (let lp: number = 0, end: number = elements.length; lp < end; lp++) {
                 obj[elements[lp]] = elements[lp];
             }
         } */
    }
    /* tslint:disable */
    renderEngine(dataSource, customProperties, fn) {
        this.getValueCellInfo = fn;
        this.formatFields = {};
        this.dateFormatFunction = {};
        this.calculatedFields = {};
        this.calculatedFormulas = {};
        this.valueAxis = 0;
        this.saveDataHeaders = {};
        this.columnCount = 0;
        this.rowCount = 0;
        this.colFirstLvl = 0;
        this.rowFirstLvl = 0;
        this.rowStartPos = 0;
        this.colStartPos = 0;
        this.excludeFields = isNullOrUndefined(dataSource.excludeFields) ? [] : dataSource.excludeFields;
        this.enableValueSorting = false;
        this.headerCollection = { rowHeaders: [], columnHeaders: [], rowHeadersCount: 0, columnHeadersCount: 0 };
        this.valueMatrix = [];
        this.indexMatrix = [];
        this.aggregatedValueMatrix = [];
        this.rMembers = [];
        this.cMembers = [];
        this.memberCnt = -1;
        this.pageInLimit = false;
        this.endPos = 0;
        this.removeCount = 0;
        this.colHdrBufferCalculated = false;
        this.colValuesLength = 1;
        this.rowValuesLength = 1;
        this.slicedHeaders = [];
        this.fieldFilterMem = {};
        this.filterPosObj = {};
        this.selectedHeaders = { selectedHeader: [], values: [] };
        this.rawIndexObject = {};
        this.isEditing = false;
        let fields;
        this.globalize = new Internationalization();
        this.localeObj = customProperties ? customProperties.localeObj : undefined;
        this.fieldsType = customProperties ? customProperties.fieldsType : {};
        this.enableSort = dataSource.enableSorting;
        this.alwaysShowValueHeader = dataSource.alwaysShowValueHeader;
        this.showHeaderWhenEmpty = isNullOrUndefined(dataSource.showHeaderWhenEmpty) ? true : dataSource.showHeaderWhenEmpty;
        this.showSubTotals = isNullOrUndefined(dataSource.showSubTotals) ? true : dataSource.showSubTotals;
        this.showRowSubTotals = isNullOrUndefined(dataSource.showRowSubTotals) ? true : dataSource.showRowSubTotals;
        this.showColumnSubTotals = isNullOrUndefined(dataSource.showColumnSubTotals) ? true : dataSource.showColumnSubTotals;
        this.showGrandTotals = isNullOrUndefined(dataSource.showGrandTotals) ? true : dataSource.showGrandTotals;
        this.showRowGrandTotals = isNullOrUndefined(dataSource.showRowGrandTotals) ? true : dataSource.showRowGrandTotals;
        this.showColumnGrandTotals = isNullOrUndefined(dataSource.showColumnGrandTotals) ? true : dataSource.showColumnGrandTotals;
        this.allowValueFilter = dataSource.allowValueFilter;
        this.isValueFilterEnabled = false;
        this.enableValueSorting = customProperties ? customProperties.enableValueSorting : false;
        this.isDrillThrough = customProperties ? (customProperties.isDrillThrough ? customProperties.isDrillThrough : false) : false;
        this.valueContent = [];
        this.dataSourceSettings = dataSource;
        if (!(dataSource.dataSource instanceof DataManager)) {
            this.data = dataSource.dataSource;
        }
        if (customProperties && customProperties.pageSettings && customProperties.pageSettings.allowDataCompression) {
            this.actualData = this.data;
            this.data = this.getGroupedRawData(dataSource);
        }
        if (this.data && this.data[0]) {
            this.fields = Object.keys(this.data[0]);
            this.rows = dataSource.rows ? dataSource.rows : [];
            this.columns = dataSource.columns ? dataSource.columns : [];
            this.filters = dataSource.filters ? dataSource.filters : [];
            this.values = dataSource.values ? dataSource.values : [];
            this.formats = dataSource.formatSettings ? dataSource.formatSettings : [];
            this.groups = dataSource.groupSettings ? dataSource.groupSettings : [];
            this.calculatedFieldSettings = dataSource.calculatedFieldSettings ? dataSource.calculatedFieldSettings : [];
            this.enableSort = dataSource.enableSorting === undefined ? true : dataSource.enableSorting;
            fields = this.getGroupData(this.data);
            this.validateFilters(dataSource);
            this.isExpandAll = (this.isValueFiltersAvail && dataSource.allowValueFilter) ? true : dataSource.expandAll;
            this.drilledMembers =
                dataSource.drilledMembers ? (this.isValueFiltersAvail && dataSource.allowValueFilter) ? [] : dataSource.drilledMembers : [];
            this.isMutiMeasures = this.values.length > 1 ? true : false;
            this.valueAxis = dataSource.valueAxis === 'row' ? 1 : 0;
            this.emptyCellTextContent = dataSource.emptyCellsTextContent ? dataSource.emptyCellsTextContent : '';
            this.rowValuesLength = this.valueAxis === 1 ? this.values.length : 1;
            this.colValuesLength = this.valueAxis === 0 ? this.values.length : 1;
            this.valueSortSettings = dataSource.valueSortSettings ||
                { sortOrder: 'None', headerDelimiter: '.', headerText: '', columnIndex: undefined };
            this.valueSortData = [];
            this.pageSettings = customProperties ? (customProperties.pageSettings ? customProperties.pageSettings : this.pageSettings)
                : undefined;
            this.allowDataCompression = this.pageSettings && this.pageSettings.allowDataCompression;
            this.savedFieldList = customProperties ? customProperties.savedFieldList : undefined;
            this.getFieldList(fields, this.enableSort, dataSource.allowValueFilter);
            this.removeIrrelevantFields(dataSource, Object.keys(this.fieldList));
            this.fillFieldMembers(this.data, this.indexMatrix);
            this.updateSortSettings(dataSource.sortSettings, this.enableSort);
            this.valueMatrix = this.generateValueMatrix(this.data);
            this.filterMembers = [];
            let columnLength = this.columns.length - 1;
            this.columnKeys = {};
            while (columnLength > -1) {
                this.columnKeys[this.columns[columnLength].name] = this.columns[columnLength];
                columnLength--;
            }
            this.updateFilterMembers(dataSource);
            this.generateGridData(dataSource);
        }
    }
    removeIrrelevantFields(dataSource, fields) {
        let report = {};
        report[0] = dataSource.rows;
        report[1] = dataSource.columns;
        report[2] = dataSource.values;
        report[3] = dataSource.filters;
        let pos = 0;
        while (pos < 4) {
            if (report[pos]) {
                for (let cnt = 0; cnt < report[pos].length; cnt++) {
                    if ((this.excludeFields.indexOf(report[pos][cnt].name) > -1) || (!isNullOrUndefined(fields) && fields.indexOf(report[pos][cnt].name) === -1)) {
                        report[pos].splice(cnt, 1);
                        cnt--;
                    }
                }
            }
            pos++;
        }
    }
    getGroupedRawData(dataSourceSettings) {
        this.data = [];
        for (let data of this.actualData) {
            this.data[this.data.length] = this.frameHeaderWithKeys(data);
        }
        let countFields = dataSourceSettings.values.filter((item) => {
            return item.type === 'Count' || item.type === 'DistinctCount';
        }).map((item) => { return item.name; });
        let hasCountField = countFields.length > 0;
        let realData = this.data;
        let headerFields = dataSourceSettings.rows.concat(dataSourceSettings.columns.concat(dataSourceSettings.filters)).map((item) => {
            return item.name;
        });
        let groupRawData = {};
        let finalData = [];
        this.groupRawIndex = {};
        let groupKeys = {};
        let indexLength = 0;
        for (let i = 0; i < realData.length; i++) {
            let currData = realData[i];
            let members = [];
            if (hasCountField) {
                for (let vPos = 0; vPos < countFields.length; vPos++) {
                    currData[countFields[vPos]] = isNullOrUndefined(currData[countFields[vPos]]) ? currData[countFields[vPos]] : 1;
                }
            }
            for (let hPos = 0; hPos < headerFields.length; hPos++) {
                members.push(currData[headerFields[hPos]]);
            }
            let memberJoin = members.join('-');
            if (groupRawData[memberJoin]) {
                for (let vPos = 0; vPos < dataSourceSettings.values.length; vPos++) {
                    let currFieldName = dataSourceSettings.values[vPos].name;
                    let currValue = currData[currFieldName];
                    let savedData = groupRawData[memberJoin];
                    let summType = dataSourceSettings.values[vPos].type;
                    if (!isNullOrUndefined(currValue)) {
                        if (typeof currValue !== 'number' || summType === 'DistinctCount') {
                            summType = 'Count';
                        }
                        if (isNullOrUndefined(savedData[currFieldName])) {
                            savedData[currFieldName] = summType === 'Product' ? 1 : ((summType === 'Min' || summType === 'Max')
                                ? undefined : 0);
                        }
                        else if (typeof savedData[currFieldName] !== 'number') {
                            savedData[currFieldName] = 1;
                        }
                        if (summType === 'Count') {
                            savedData[currFieldName] += 1;
                        }
                        else if (summType === 'Min') {
                            if (!isNullOrUndefined(savedData[currFieldName])) {
                                savedData[currFieldName] = savedData[currFieldName] > currValue ?
                                    currValue : savedData[currFieldName];
                            }
                        }
                        else if (summType === 'Max') {
                            if (!isNullOrUndefined(savedData[currFieldName])) {
                                savedData[currFieldName] = savedData[currFieldName] < currValue ?
                                    currValue : savedData[currFieldName];
                            }
                        }
                        else if (summType === 'Product') {
                            savedData[currFieldName] *= currValue;
                        }
                        else {
                            savedData[currFieldName] += currValue;
                        }
                    }
                }
                if (this.isDrillThrough) {
                    this.groupRawIndex[groupKeys[memberJoin]].push(i);
                }
            }
            else {
                groupRawData[memberJoin] = currData;
                finalData.push(currData);
                if (this.isDrillThrough) {
                    this.groupRawIndex[indexLength] = [i];
                    groupKeys[memberJoin] = indexLength;
                    indexLength++;
                }
            }
        }
        return finalData;
    }
    /* tslint:disable */
    getGroupData(data) {
        let fieldkeySet = data[0];
        for (let group of this.groups) {
            let fieldName = group.name;
            let caption = group.caption;
            if (this.fields.indexOf(fieldName) > -1) {
                let groupFields = {};
                let customGroupFieldName;
                if (group.type === 'Date' && this.groupingFields[fieldName]) {
                    return fieldkeySet;
                }
                else if (group.type === 'Number') {
                    if (PivotUtil.getType(fieldkeySet[fieldName]) === 'number' || !this.groupingFields[fieldName]) {
                        if (group.rangeInterval) {
                            data.sort((a, b) => (a[fieldName] > b[fieldName]) ? 1 : ((b[fieldName] > a[fieldName]) ? -1 : 0));
                        }
                    }
                    else {
                        return fieldkeySet;
                    }
                }
                else if (group.type === 'Custom' && this.fields.indexOf(fieldName + '_custom_group') > -1) {
                    return fieldkeySet;
                }
                let len = data.length;
                while (len--) {
                    let item = data[len];
                    if (item[fieldName] && group.type === 'Date') {
                        let date = new Date(item[fieldName].toString());
                        if (!isNullOrUndefined(date) && group.groupInterval.length > 0) {
                            for (let i = 0, len = group.groupInterval.length; i < len; i++) {
                                let interval = group.groupInterval[i];
                                let isInRangeAvail = this.getRange(group, date.getTime());
                                let newDate = PivotUtil.resetTime(new Date());
                                switch (interval) {
                                    case 'Years':
                                        {
                                            let newFieldName = (i === group.groupInterval.length - 1) ? fieldName : fieldName + '_date_group_years';
                                            groupFields[newFieldName] = interval;
                                            item[newFieldName] = (isInRangeAvail ? undefined : new Date(newDate.setFullYear(date.getFullYear())).toString());
                                        }
                                        break;
                                    case 'Quarters':
                                        {
                                            let newFieldName = (i === group.groupInterval.length - 1) ? fieldName : fieldName + '_date_group_quarters';
                                            groupFields[newFieldName] = interval;
                                            let month = Math.ceil((date.getMonth() + 1) / 3);
                                            item[newFieldName] = (isInRangeAvail ? undefined : ((this.localeObj ? this.localeObj.getConstant('qtr') : 'Qtr') + month.toString()));
                                        }
                                        break;
                                    case 'QuarterYear':
                                        {
                                            let newFieldName = (i === group.groupInterval.length - 1) ? fieldName : fieldName + '_date_group_quarterYear';
                                            groupFields[newFieldName] = interval;
                                            let month = Math.ceil((date.getMonth() + 1) / 3);
                                            item[newFieldName] = (isInRangeAvail ? undefined :
                                                ((this.localeObj ? this.localeObj.getConstant('qtr') : 'Qtr') + month.toString() + ' '
                                                    + (this.localeObj ? this.localeObj.getConstant('of') : 'of') + ' '
                                                    + date.getFullYear().toString()));
                                        }
                                        break;
                                    case 'Months':
                                        {
                                            let newFieldName = (i === group.groupInterval.length - 1) ? fieldName : fieldName + '_date_group_months';
                                            groupFields[newFieldName] = interval;
                                            item[newFieldName] = (isInRangeAvail ? undefined : new Date(newDate.setMonth(date.getMonth(), newDate.getDate())).toString());
                                        }
                                        break;
                                    case 'Days':
                                        {
                                            let newFieldName = (i === group.groupInterval.length - 1) ? fieldName : fieldName + '_date_group_days';
                                            groupFields[newFieldName] = interval;
                                            item[newFieldName] = (isInRangeAvail ? undefined : new Date(newDate.setMonth(date.getMonth(), date.getDate())).toString());
                                        }
                                        break;
                                    case 'Hours':
                                        {
                                            let newFieldName = (i === group.groupInterval.length - 1) ? fieldName : fieldName + '_date_group_hours';
                                            groupFields[newFieldName] = interval;
                                            item[newFieldName] = (isInRangeAvail ? undefined : new Date(newDate.setHours(date.getHours())).toString());
                                        }
                                        break;
                                    case 'Minutes':
                                        {
                                            let newFieldName = (i === group.groupInterval.length - 1) ? fieldName : fieldName + '_date_group_minutes';
                                            groupFields[newFieldName] = interval;
                                            item[newFieldName] = (isInRangeAvail ? undefined : new Date(newDate.setMinutes(date.getMinutes())).toString());
                                        }
                                        break;
                                    case 'Seconds':
                                        {
                                            let newFieldName = (i === group.groupInterval.length - 1) ? fieldName : fieldName + '_date_group_seconds';
                                            groupFields[newFieldName] = interval;
                                            item[newFieldName] = (isInRangeAvail ? undefined : new Date(newDate.setSeconds(date.getSeconds())).toString());
                                        }
                                        break;
                                }
                            }
                        }
                    }
                    else if (item[fieldName] && group.type === 'Number') {
                        let isInRangeAvail = this.getRange(group, item[fieldName]);
                        item[fieldName] = isInRangeAvail ? undefined : item[fieldName];
                    }
                    else if (item[fieldName] && group.type === 'Custom' && group.customGroups && group.customGroups.length > 0) {
                        let newFieldName = fieldName + '_custom_group';
                        let customGroups = group.customGroups;
                        let groupValue;
                        for (let i = 0, len = customGroups.length; i < len; i++) {
                            {
                                let cGroup = customGroups[i];
                                if (cGroup.items && cGroup.items.length > 1) {
                                    customGroupFieldName = newFieldName;
                                    let isDataMatch = PivotUtil.inArray(item[fieldName].toString(), cGroup.items) == -1 ? false : true;
                                    item[newFieldName] = (isDataMatch ? (cGroup.groupName && cGroup.groupName != '') ? cGroup.groupName :
                                        this.localeObj.getConstant('group') + ' ' + i : (groupValue && groupValue !== item[fieldName].toString()) ?
                                        groupValue : item[fieldName].toString());
                                    groupValue = item[newFieldName];
                                }
                            }
                        }
                    }
                    let keys = Object.keys(item);
                    let isCompleteSet = [];
                    for (let key of keys) {
                        isCompleteSet.push((item[key]) ? true : false);
                    }
                    
                    fieldkeySet = (((isCompleteSet.indexOf(false) === -1) && keys.length === Object.keys(data[0]).length) ? item : fieldkeySet);
                    this.fields = Object.keys(fieldkeySet);
                }
                if (group.type === 'Date') {
                    let isDataSource = false;
                    let axisFields = [this.rows, this.columns, this.values, this.filters];
                    let groupKeys = Object.keys(groupFields);
                    let gCnt = Object.keys(groupKeys).length;
                    let groupField;
                    for (let axis of axisFields) {
                        if (!isDataSource && axis) {
                            let cnt = axis.length;
                            let i = 0;
                            while (i < cnt) {
                                if (axis[i].name === fieldName) {
                                    isDataSource = true;
                                    let actualField = axis[i];
                                    axis.splice(i, 1);
                                    let dataFields = this.rows;
                                    dataFields = dataFields.concat(this.columns, this.values, this.filters);
                                    while (gCnt--) {
                                        if (!PivotUtil.getFieldByName(groupKeys[gCnt], dataFields)) {
                                            groupField = groupFields[groupKeys[gCnt]];
                                            let newField = {
                                                name: groupKeys[gCnt],
                                                caption: (this.localeObj ? this.localeObj.getConstant(groupField) : groupField) + ' (' + (actualField.caption ? actualField.caption : actualField.name) + ')',
                                                type: 'Count',
                                                showNoDataItems: actualField.showNoDataItems,
                                                baseField: actualField.baseField,
                                                baseItem: actualField.baseItem,
                                            };
                                            axis.splice(i, 0, newField);
                                        }
                                    }
                                    break;
                                }
                                i++;
                            }
                            if (isDataSource) {
                                break;
                            }
                        }
                    }
                    gCnt = Object.keys(groupKeys).length;
                    while (gCnt--) {
                        groupField = groupFields[groupKeys[gCnt]];
                        for (let i = 0, len = this.formats.length; i < len; i++) {
                            if (this.formats[i].name === groupKeys[gCnt]) {
                                this.formats.splice(i, 1);
                                break;
                            }
                        }
                        if (groupField !== 'Quarters' && groupField !== 'QuarterYear') {
                            let formatSettings = {
                                name: groupKeys[gCnt],
                                type: ['Years', 'Months', 'Days'].indexOf(groupField) > -1 ? 'date' : 'time',
                                format: ((groupField === 'Years') ? 'yyyy' : (groupField === 'Months') ? 'MMM' :
                                    (groupField === 'Days') ? 'd-MMM' : (groupField === 'Hours') ? 'hh a' :
                                        (groupField === 'Minutes') ? ':mm' : (groupField === 'Seconds') ? ':ss' : undefined)
                            };
                            this.formats.push(formatSettings);
                        }
                    }
                }
                else if (group.type === 'Number' && group.rangeInterval) {
                    let startValue;
                    let endValue;
                    let cStartValue;
                    let cEndValue;
                    let framedSet = [];
                    let unframedSet = [];
                    let dataLength = data.length;
                    let cnt = 0;
                    this.groupingFields[fieldName] = fieldName;
                    while (cnt < dataLength) {
                        unframedSet.push(data[cnt][fieldName]);
                        if (data[cnt][fieldName] && framedSet.indexOf(data[cnt][fieldName]) === -1) {
                            framedSet.push(data[cnt][fieldName]);
                        }
                        cnt++;
                    }
                    let framedSetLength = Math.max.apply(Math, framedSet);
                    for (let i = framedSet[0], len = framedSetLength; i < len; i++) {
                        if (unframedSet.indexOf(i) < 0) {
                            let duplicateData = this.frameData(data[0]);
                            duplicateData[fieldName] = i;
                            let index = unframedSet.lastIndexOf(i - 1);
                            unframedSet.splice(index + 1, 0, i);
                            data.splice(index + 1, 0, duplicateData);
                        }
                    }
                    dataLength = data.length;
                    cnt = 0;
                    while (cnt < dataLength) {
                        if (data[cnt] && data[cnt][fieldName]) {
                            cStartValue = data[cnt][fieldName];
                            cEndValue = cStartValue + (group.rangeInterval - 1);
                            startValue = (!startValue) ? cStartValue : startValue;
                            endValue = ((!endValue) ? ((cEndValue > framedSetLength) ? framedSetLength : cEndValue) : ((endValue > framedSetLength) ? framedSetLength : endValue));
                            if (cStartValue >= startValue && cStartValue <= endValue) {
                                data[cnt][fieldName] = ((startValue === endValue) ? startValue.toString() : startValue.toString() + '-' + endValue.toString());
                            }
                            else if (cStartValue > endValue && cStartValue === endValue + 1) {
                                startValue = endValue + 1;
                                endValue = ((startValue + (group.rangeInterval - 1) > framedSetLength) ? framedSetLength : startValue + (group.rangeInterval - 1));
                                data[cnt][fieldName] = ((startValue === endValue) ? startValue.toString() : startValue.toString() + '-' + endValue.toString());
                            }
                            let keys = Object.keys(data[cnt]);
                            let isCompleteSet = [];
                            for (let key of keys) {
                                isCompleteSet.push((data[cnt][key]) ? true : false);
                            }
                            
                            fieldkeySet = (((isCompleteSet.indexOf(false) === -1) && keys.length === Object.keys(data[0]).length) ? data[cnt] : fieldkeySet);
                        }
                        cnt++;
                    }
                    let axisFields = [this.rows, this.columns, this.values, this.filters];
                    for (let fields of axisFields) {
                        let field = PivotUtil.getFieldByName(fieldName, fields);
                        if (field) {
                            field = field.properties ? field.properties : field;
                            field.type = 'Count';
                        }
                    }
                    for (let i = 0, len = this.formats.length; i < len; i++) {
                        if (this.formats[i].name === fieldName) {
                            this.formats.splice(i, 1);
                            break;
                        }
                    }
                }
                else if (group.type === 'Custom' && customGroupFieldName) {
                    let customFieldName = customGroupFieldName;
                    // this.groupingFields[customFieldName] = customFieldName;
                    let isDataSource = false;
                    let axisFields = [this.rows, this.columns, this.values, this.filters];
                    let dataFields = this.rows;
                    dataFields = dataFields.concat(this.columns, this.values, this.filters);
                    let pattern = [];
                    if (!caption || caption == '') {
                        pattern = customFieldName.match(/_custom_group/g);
                    }
                    // let actualFieldName: string = fieldName.replace(/_custom_group/g, '');
                    let parentField = PivotUtil.getFieldByName(fieldName.replace(/_custom_group/g, ''), dataFields);
                    let customGroupField = PivotUtil.getFieldByName(customFieldName, dataFields);
                    for (let axis of axisFields) {
                        if (!isDataSource && axis) {
                            let cnt = axis.length;
                            let i = 0;
                            while (i < cnt) {
                                if (axis[i].name === group.name && !customGroupField) {
                                    isDataSource = true;
                                    let actualField = axis[i];
                                    let newField = {
                                        name: customFieldName,
                                        caption: (!caption || caption == '') ? (parentField.caption ? parentField.caption : parentField.name) + (pattern.length + 1) : caption,
                                        type: 'Count',
                                        showNoDataItems: actualField.showNoDataItems,
                                        baseField: actualField.baseField,
                                        baseItem: actualField.baseItem,
                                    };
                                    axis.splice(i, 0, newField);
                                    break;
                                }
                                else if (axis[i].name === customFieldName && customGroupField) {
                                    let newField = {
                                        name: customGroupField.name,
                                        caption: (!caption || caption == '') ? customGroupField.caption : caption,
                                        type: customGroupField.type,
                                        showNoDataItems: customGroupField.showNoDataItems,
                                        baseField: customGroupField.baseField,
                                        baseItem: customGroupField.baseItem,
                                    };
                                    axis.splice(i, 1, newField);
                                    break;
                                }
                                i++;
                            }
                            if (isDataSource) {
                                break;
                            }
                        }
                    }
                    let formatfield = PivotUtil.getFieldByName(fieldName, PivotUtil.cloneFormatSettings(this.formats));
                    if (formatfield) {
                        formatfield.name = customFieldName;
                        this.formats.push(formatfield);
                    }
                }
                this.groupingFields = extend(this.groupingFields, groupFields);
            }
            else {
                return fieldkeySet;
            }
        }
        this.fields = Object.keys(fieldkeySet);
        return fieldkeySet;
    }
    frameData(data) {
        let fields = Object.keys(data);
        let keyPos = 0;
        let framedSet = {};
        while (keyPos < fields.length) {
            framedSet[fields[keyPos]] = undefined;
            keyPos++;
        }
        return framedSet;
    }
    /* tslint:enable */
    getRange(group, cValue) {
        let isRangeAvail;
        if (group.type === 'Date') {
            let cDate = new Date(cValue);
            let startDate = typeof (group.startingAt) === 'string' ? new Date(group.startingAt) : group.startingAt;
            let endDate = typeof (group.endingAt) === 'string' ? new Date(group.endingAt) : group.endingAt;
            if (startDate && cDate.getTime() < startDate.getTime() ||
                endDate && cDate.getTime() > endDate.getTime()) {
                isRangeAvail = true;
            }
            else {
                isRangeAvail = false;
            }
        }
        else {
            let startValue = typeof (group.startingAt) === 'string' ? parseInt(group.startingAt, 10) : group.startingAt;
            let endValue = typeof (group.endingAt) === 'string' ? parseInt(group.endingAt, 10) : group.endingAt;
            if (startValue && cValue < startValue || endValue && cValue > endValue) {
                isRangeAvail = true;
            }
            else {
                isRangeAvail = false;
            }
        }
        return isRangeAvail;
    }
    getFormattedFields(fields) {
        let cnt = this.formats.length;
        while (cnt--) {
            this.formatFields[this.formats[cnt].name] = this.formats[cnt];
            if (this.formats[cnt].type) {
                this.dateFormatFunction[this.formats[cnt].name] = {
                    exactFormat: this.globalize.getDateFormat(this.formats[cnt]),
                    fullFormat: this.globalize.getDateFormat({
                        format: 'yyyy/MM/dd/HH/mm/ss', type: this.formats[cnt].type
                    })
                };
            }
            // for (let len: number = 0, lnt: number = fields.length; len < lnt; len++) {
            // if (fields[len] && fields[len].name === this.formats[cnt].name) {
            //     this.formatFields[fields[len].name] = this.formats[cnt];
            // }
            // }
        }
    }
    getFieldList(fields, isSort, isValueFilteringEnabled) {
        let type;
        let keys = this.fields;
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns, this.values, this.filters);
        this.getFormattedFields(dataFields);
        this.getCalculatedField(keys);
        keys = this.fields;
        let lenE = this.excludeFields.length;
        lenE = lenE - 1;
        while (lenE > -1) {
            let index = this.fields.indexOf(this.excludeFields[lenE]);
            this.fields.splice(index, 1);
            if (this.fieldList) {
                delete this.fieldList[this.excludeFields[lenE]];
            }
            lenE--;
        }
        let len = keys.length;
        if (this.savedFieldList) {
            this.fieldList = this.savedFieldList;
            while (len--) { /** while is used for better performance than for */
                let key = keys[len];
                if (this.fieldList[key]) {
                    this.fieldList[key].isSelected = false;
                    this.fieldList[key].index = len;
                    this.fieldList[key].filter = [];
                    this.fieldList[key].sort = isSort ? 'Ascending' : 'None';
                    this.fieldList[key].isExcelFilter = false;
                    this.fieldList[key].filterType = '';
                    if (this.isValueFiltersAvail && isValueFilteringEnabled) {
                        this.fieldList[key].dateMember = [];
                        this.fieldList[key].formattedMembers = {};
                        this.fieldList[key].members = {};
                    }
                }
                else {
                    this.fieldList[key] = {
                        id: key,
                        caption: key,
                        type: ((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1)) ?
                            'string' : (type === undefined || type === 'undefined') ? 'number' : type,
                        sort: isSort ? 'Ascending' : 'None',
                        isSelected: false,
                        filterType: '',
                        index: len,
                        filter: [],
                        isCustomField: ((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1))
                    };
                }
            }
        }
        else {
            this.fieldList = {};
            while (len--) { /** while is used for better performance than for */
                let key = keys[len];
                type = (this.fieldsType && this.fieldsType[key]) ? this.fieldsType[key] : PivotUtil.getType(fields[key]);
                this.fieldList[key] = {
                    id: key,
                    caption: key,
                    type: ((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1)) ?
                        'string' : (type === undefined || type === 'undefined') ? 'number' : type,
                    filterType: '',
                    index: len,
                    filter: [],
                    sort: isSort ? 'Ascending' : 'None',
                    isSelected: false,
                    isCustomField: ((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1))
                };
            }
        }
        this.updateTreeViewData(dataFields);
    }
    updateFieldList(savedFieldList) {
        let keys = this.fields;
        let len = keys.length;
        while (len--) { /** while is used for better performance than for */
            this.fieldList[keys[len]].isExcelFilter = savedFieldList[keys[len]].isExcelFilter;
        }
    }
    updateTreeViewData(fields) {
        let cnt = fields.length;
        let lnt = this.calculatedFieldSettings.length;
        while (cnt--) {
            if (this.fieldList[fields[cnt].name]) {
                let field = this.fieldList[fields[cnt].name];
                field.caption = fields[cnt].caption ? fields[cnt].caption : fields[cnt].name;
                field.isSelected = true;
                field.showNoDataItems = fields[cnt].showNoDataItems;
                field.aggregateType = fields[cnt].type;
                field.baseField = fields[cnt].baseField;
                field.baseItem = fields[cnt].baseItem;
            }
        }
        while (lnt--) {
            if (this.fieldList[this.calculatedFieldSettings[lnt].name]) {
                this.fieldList[this.calculatedFieldSettings[lnt].name].aggregateType = 'CalculatedField';
                this.fieldList[this.calculatedFieldSettings[lnt].name].formula = this.calculatedFieldSettings[lnt].formula;
            }
        }
    }
    /* tslint:disable:typedef */
    getCalculatedField(keys) {
        for (let field of this.calculatedFieldSettings) {
            this.calculatedFields[field.name] = extend({}, field, null, true);
            this.calculatedFields[field.name].actualFormula = field.formula;
        }
        let fieldKeys = Object.keys(this.calculatedFields);
        for (let calc = 0, cnt = fieldKeys.length; calc < cnt; calc++) {
            let field = this.calculatedFields[fieldKeys[calc]];
            let calcProperties = field.properties;
            let actualFormula = (calcProperties ? calcProperties.formula : field.formula).replace(/ +/g, '');
            let formula = actualFormula.replace(/"/g, '');
            field.formula = formula.indexOf('^') > -1 ? this.powerFunction(formula) : formula;
            if (field.formula.indexOf('Math.min(') === -1 && field.formula.indexOf('min(') > -1) {
                field.formula = field.formula.replace(/min\(/g, 'Math.min(');
            }
            if (field.formula.indexOf('Math.max(') === -1 && field.formula.indexOf('max(') > -1) {
                field.formula = field.formula.replace(/max\(/g, 'Math.max(');
            }
            if (field.formula.indexOf('Math.abs(') === -1 && field.formula.indexOf('abs(') > -1) {
                field.formula = field.formula.replace(/abs\(/g, 'Math.abs(');
            }
            field.name = calcProperties ? calcProperties.name : field.name;
            keys = keys.filter((key) => { return key !== field.name; });
            keys.push(field.name);
            let formulaType = actualFormula.split('\"');
            for (let len = 0, lmt = formulaType.length; len < lmt; len++) {
                let type = formulaType[len];
                let aggregateValue = type.split(/[ .:;?!~,`"&|()<>{}\[\]\r\n/\\]+/);
                let selectedString = (aggregateValue[0] === 'DistinctCount' ?
                    'DistinctCount' : aggregateValue[0] === 'PopulationStDev' ?
                    'PopulationStDev' : aggregateValue[0] === 'SampleStDev' ? 'SampleStDev' : aggregateValue[0] === 'PopulationVar' ?
                    'PopulationVar' : aggregateValue[0] === 'SampleVar' ? 'SampleVar' : aggregateValue[0]);
                if (['Sum', 'Count', 'Min', 'Max', 'Avg', 'Product', 'DistinctCount',
                    'PopulationStDev', 'SampleStDev', 'PopulationVar', 'SampleVar'].indexOf(selectedString) !== -1) {
                    let index = keys.indexOf(aggregateValue[1]);
                    if (!this.calculatedFormulas[field.name]) {
                        this.calculatedFormulas[field.name] = [{
                                index: index,
                                type: selectedString,
                                formula: type,
                            }];
                    }
                    else {
                        this.calculatedFormulas[field.name].push({
                            index: index,
                            type: selectedString,
                            formula: type,
                        });
                    }
                }
            }
        }
        this.fields = keys;
    }
    validateFilters(data) {
        this.isValueFiltersAvail = false;
        let filterElements = data.filterSettings ? data.filterSettings : [];
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns);
        for (let filter of filterElements) {
            for (let field of dataFields) {
                if (filter.name === field.name && filter.type === 'Value') {
                    this.isValueFiltersAvail = true;
                    break;
                }
            }
            if (this.isValueFiltersAvail) {
                break;
            }
        }
    }
    fillFieldMembers(data, indMat) {
        let keys = this.fields;
        let dlen = data.length;
        let fList = this.fieldList;
        let kLn = keys.length;
        for (let kl = 0; kl < kLn; kl++) {
            let key = keys[kl];
            if (!fList[key].members || this.allowDataCompression) {
                fList[key].members = {};
            }
            if (!fList[key].formattedMembers || this.allowDataCompression) {
                fList[key].formattedMembers = {};
            }
            if (!fList[key].dateMember || this.allowDataCompression) {
                fList[key].dateMember = [];
            }
            let members = fList[key].members;
            let isDataAvail = Object.keys(members).length > 0 ? true : false;
            let formattedMembers = fList[key].formattedMembers;
            let dateMember = fList[key].dateMember;
            let membersCnt = 0;
            let fmembersCnt = 0;
            //let sort: string[] = [];
            for (let dl = 0; dl < dlen; dl++) {
                let mkey = data[dl][key];
                // if (!isNullOrUndefined(mkey)) {
                if (!isDataAvail) {
                    let fKey = mkey;
                    let formattedValue = (this.pageSettings && !(this.formatFields[key] &&
                        (['date', 'dateTime', 'time'].indexOf(this.formatFields[key].type) > -1))) ? ({
                        formattedText: mkey === null ? (this.localeObj ? this.localeObj.getConstant('null') : String(mkey)) :
                            mkey === undefined ? (this.localeObj ? (key in this.groupingFields) ?
                                this.localeObj.getConstant('groupOutOfRange') : this.localeObj.getConstant('undefined') :
                                String(mkey)) : mkey.toString(), actualText: mkey === null ? (this.localeObj ?
                            this.localeObj.getConstant('null') : String(mkey)) : mkey === undefined ? (this.localeObj ?
                            (key in this.groupingFields) ? this.localeObj.getConstant('groupOutOfRange') :
                                this.localeObj.getConstant('undefined') : String(mkey)) : mkey
                    }) : this.getFormattedValue(mkey, key);
                    if (formattedValue.formattedText) {
                        fKey = formattedValue.formattedText;
                    }
                    if (!members.hasOwnProperty(mkey)) {
                        membersCnt++;
                        members[mkey] = {
                            index: [dl], ordinal: membersCnt,
                            isDrilled: this.isExpandAll ? true : false
                        };
                        /* tslint:disable-next-line:max-line-length */
                        dateMember.push({ formattedText: formattedValue.formattedText, actualText: (formattedValue.dateText ? formattedValue.dateText : formattedValue.actualText) });
                        //sort.push(mkey);
                    }
                    else {
                        members[mkey].index.push(dl);
                    }
                    if (!formattedMembers.hasOwnProperty(fKey)) {
                        fmembersCnt++;
                        formattedMembers[fKey] = {
                            index: [dl], ordinal: fmembersCnt,
                            isDrilled: this.isExpandAll ? true : false
                        };
                    }
                    else {
                        formattedMembers[fKey].index.push(dl);
                    }
                }
                if (!(indMat[dl])) {
                    indMat[dl] = [];
                    indMat[dl][kl] = members[mkey].ordinal;
                }
                else {
                    indMat[dl][kl] = members[mkey].ordinal;
                }
                // }
            }
            /*sort = Object.keys(members).sort();
            let sortedMembers: Members = {};
            for (let sln: number = 0, slt: number = sort.length; sln < slt; sln++) {
                sortedMembers[sort[sln]] = members[sort[sln]];
            }
            fList[key].members = sortedMembers; */
        }
    }
    generateValueMatrix(data) {
        let keys = this.fields;
        let len = data.length;
        let vMat = [];
        let keyLen = keys.length;
        let flList = this.fieldList;
        while (len--) {
            let record = data[len];
            let tkln = keyLen;
            //if (isNullOrUndefined(vMat[len])) {
            vMat[len] = [];
            //}
            while (tkln--) {
                let key = keys[tkln];
                vMat[len][tkln] = (flList[key].type === 'number' || isNullOrUndefined(data[len][key])) ? data[len][key] : 1;
            }
        }
        return vMat;
    }
    updateSortSettings(sortSettings, isSort) {
        for (let sln = 0, slt = sortSettings ? sortSettings.length : 0; sln < slt && isSort; sln++) {
            if (this.fieldList[sortSettings[sln].name]) {
                this.fieldList[sortSettings[sln].name].sort = sortSettings[sln].order;
            }
        }
    }
    updateFilterMembers(source) {
        let filterRw = this.filterMembers;
        let list = {};
        //let eList: {[key: string] : number} = {};
        let isInclude = this.getFilters(source, list);
        //this.getFilterExcludeList(source.rows, flist);
        //this.getFilterExcludeList(source.columns, flist);
        //this.getFilterExcludeList(source.filters, flist);
        // let filters: Iterator = isInclude ? iList : eList;
        let dln = this.indexMatrix.length;
        if (isInclude) {
            let keys = list.include.index;
            for (let ln = 0; ln < keys.length; ln++) {
                if (list.exclude === undefined || list.exclude.indexObject[keys[ln]] === undefined) {
                    filterRw.push(keys[ln]);
                }
            }
        }
        else {
            for (let ln = 0; ln < dln; ln++) {
                if (list.exclude === undefined || list.exclude.indexObject[ln] === undefined) {
                    filterRw.push(ln);
                }
            }
        }
    }
    getFilters(source, ilist) {
        let filterElements = source.filterSettings ? source.filterSettings : [];
        let filters = this.filters;
        let isInclude = false;
        let filter = [];
        //let type: string;
        for (let rln = 0, rlt = filterElements.length; rln < rlt; rln++) {
            let filterElement = filterElements[rln].properties ?
                filterElements[rln].properties : filterElements[rln];
            if (this.fieldList[filterElement.name] &&
                this.fieldList[filterElement.name].isSelected &&
                this.isValidFilterField(filterElement, source.allowMemberFilter, source.allowLabelFilter)) {
                this.applyLabelFilter(filterElement);
                if (filterElement) {
                    filter = filterElement.items;
                }
                if (filterElement.type && filterElement.type === 'Include') {
                    /* tslint:disable-next-line:max-line-length */
                    this.frameFilterList(filter, filterElement.name, ilist, 'include', filterElement.showLabelFilter, isInclude);
                    isInclude = true;
                }
                else {
                    this.frameFilterList(filter, filterElement.name, ilist, 'exclude', filterElement.showLabelFilter);
                }
                if (filterElement.showLabelFilter) {
                    filterElement.items = [];
                    filterElement.type = filterElement.showDateFilter ? 'Date' : filterElement.showNumberFilter ? 'Number' : 'Label';
                }
            }
        }
        /* for (let cln: number = 0, clt: number = cols.length; cln < clt; cln ++) {
             filter = cols[cln].filter ? cols[cln].filter.items : [];
             if (filter.length && cols[cln].filter.type && cols[cln].filter.type === 'include') {
                 //type = cols[cln].filter.type;
                 this.frameFilterList(filter, cols[cln].name, ilist, 'include', isInclude);
                 isInclude = true;
             } else {
                 this.frameFilterList(filter, cols[cln].name, ilist, 'exclude');
             }
         }
         for (let vln: number = 0, vlt: number = filters.length; vln < vlt; vln ++) {
             filter = filters[vln].filter ? filters[vln].filter.items : [];
             if (filter.length && filters[vln].filter.type && filters[vln].filter.type === 'include') {
                 this.frameFilterList(filter, filters[vln].name, ilist, 'include', isInclude);
                 isInclude = true;
             } else {
                 this.frameFilterList(filter, filters[vln].name, ilist, 'exclude');
             }
         } */
        return isInclude;
    }
    isValidFilterField(filterElement, allowMemberFiltering, allowLabelFiltering) {
        let fieldName = filterElement.name;
        let isValidFilterElement = false;
        let filterTypes = ['Include', 'Exclude'];
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns);
        if (this.fieldList[fieldName].isSelected && allowMemberFiltering && filterTypes.indexOf(filterElement.type) >= 0) {
            let field = this.fieldList[fieldName];
            let members = (this.formatFields[fieldName] &&
                (['date', 'dateTime', 'time'].indexOf(this.formatFields[fieldName].type) > -1)) ?
                field.formattedMembers : field.members;
            let isNotValidFilterElement = false;
            for (let field of this.values) {
                if (fieldName === field.name) {
                    isNotValidFilterElement = true;
                    break;
                }
            }
            let isItemAvail = false;
            for (let item of filterElement.items) {
                if (members[item]) {
                    isItemAvail = true;
                    break;
                }
            }
            if (!isNotValidFilterElement && isItemAvail) {
                isValidFilterElement = true;
            }
        }
        else if (allowLabelFiltering) {
            for (let field of dataFields) {
                if (fieldName === field.name &&
                    (['Label', 'Date', 'Number'].indexOf(filterElement.type) >= 0)) {
                    isValidFilterElement = true;
                    break;
                }
            }
        }
        return isValidFilterElement;
    }
    applyLabelFilter(filterElement) {
        if (['Label', 'Date', 'Number'].indexOf(filterElement.type) >= 0) {
            let members = Object.keys(this.fieldList[filterElement.name].members);
            filterElement.showLabelFilter = true;
            if (filterElement.type === 'Label') {
                /* tslint:disable-next-line:max-line-length */
                filterElement.items = this.getLabelFilterMembers(members, filterElement.condition, filterElement.value1, filterElement.value2);
            }
            else if (filterElement.type === 'Date') {
                filterElement.showDateFilter = true;
                let date1 = typeof (filterElement.value1) === 'string' ? new Date(filterElement.value1) : filterElement.value1;
                let date2 = typeof (filterElement.value2) === 'string' ? new Date(filterElement.value2) : filterElement.value2;
                /* tslint:disable-next-line:max-line-length */
                filterElement.items = this.getDateFilterMembers(members, filterElement.name, filterElement.condition, date1, date2);
            }
            else {
                filterElement.showNumberFilter = true;
                filterElement.items = [];
                for (let member of members) {
                    let operand1 = this.getParsedValue(filterElement.name, filterElement.value1);
                    let operand2 = this.getParsedValue(filterElement.name, filterElement.value2);
                    let cValue = this.getParsedValue(filterElement.name, member);
                    /* tslint:disable-next-line:max-line-length */
                    if (this.validateFilterValue(cValue, filterElement.condition, operand1, operand2)) {
                        filterElement.items.push(member);
                    }
                }
            }
            let excludeOperators = ['DoesNotBeginWith', 'DoesNotContains', 'DoesNotEndsWith', 'DoesNotEquals', 'NotBetween'];
            filterElement.type = (filterElement.condition ? (excludeOperators.indexOf(filterElement.condition) > -1 &&
                !filterElement.showNumberFilter) ? 'Exclude' : 'Include' : 'Exclude');
        }
        else {
            filterElement.showLabelFilter = false;
        }
    }
    getLabelFilterMembers(members, operator, value1, value2) {
        let items = [];
        for (let member of members) {
            let filterValue = member.toLowerCase();
            if (value1.toString()) {
                switch (operator) {
                    case 'Equals':
                    case 'DoesNotEquals':
                        if (filterValue === value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                    case 'BeginWith':
                    case 'DoesNotBeginWith':
                        if (filterValue.indexOf(value1.toLowerCase()) === 0) {
                            items.push(member);
                        }
                        break;
                    case 'EndsWith':
                    case 'DoesNotEndsWith':
                        if (filterValue.match(value1.toLowerCase() + '$') !== null) {
                            items.push(member);
                        }
                        break;
                    case 'Contains':
                    case 'DoesNotContains':
                        if (filterValue.indexOf(value1.toLowerCase()) > -1) {
                            items.push(member);
                        }
                        break;
                    case 'GreaterThan':
                        if (filterValue > value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                    case 'GreaterThanOrEqualTo':
                        if (filterValue >= value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                    case 'LessThan':
                        if (filterValue < value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                    case 'LessThanOrEqualTo':
                        if (filterValue <= value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                    case 'Between':
                    case 'NotBetween':
                        if ((filterValue >= value1.toLowerCase()) && (filterValue <= value2.toLowerCase())) {
                            items.push(member);
                        }
                        break;
                    default:
                        if (filterValue === value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                }
            }
        }
        return items;
    }
    /* tslint:disable */
    getDateFilterMembers(members, name, operator, value1, value2) {
        let items = [];
        for (let member of members) {
            let filterValue = new Date(member);
            if (value1) {
                switch (operator) {
                    case 'Equals':
                    case 'DoesNotEquals':
                        if (this.getFormattedValue(filterValue.toString(), name).formattedText === this.getFormattedValue(value1.toString(), name).formattedText) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    case 'After':
                        if (filterValue.getTime() > value1.getTime()) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    case 'AfterOrEqualTo':
                        if (filterValue.getTime() >= value1.getTime()) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    case 'Before':
                        if (filterValue.getTime() < value1.getTime()) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    case 'BeforeOrEqualTo':
                        if (filterValue.getTime() <= value1.getTime()) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    case 'Between':
                    case 'NotBetween':
                        if ((filterValue.getTime() >= value1.getTime()) &&
                            (filterValue.getTime() <= value2.getTime())) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    default:
                        if (this.getFormattedValue(filterValue.toString(), name).formattedText === this.getFormattedValue(value1.toString(), name).formattedText) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                }
            }
        }
        return items;
    }
    /* tslint:enable */
    validateFilterValue(val, operator, value1, value2) {
        let isMemberInclude = false;
        if (typeof (value1) === 'number') {
            switch (operator) {
                case 'Equals':
                    if (val === value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'DoesNotEquals':
                    if (val !== value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'GreaterThan':
                    if (val > value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'GreaterThanOrEqualTo':
                    if (val >= value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'LessThan':
                    if (val < value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'LessThanOrEqualTo':
                    if (val <= value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'Between':
                    if ((val >= value1) && (val <= value2)) {
                        isMemberInclude = true;
                    }
                    break;
                case 'NotBetween':
                    if (!((val >= value1) && (val <= value2))) {
                        isMemberInclude = true;
                    }
                    break;
                default:
                    if (val !== value1) {
                        isMemberInclude = true;
                    }
                    break;
            }
        }
        return isMemberInclude;
    }
    /* tslint:disable-next-line:max-line-length */
    frameFilterList(filter, name, list, type, isLabelFilter, isInclude) {
        if (!list[type]) {
            list[type] = { indexObject: {}, index: [] };
            this.updateFilter(filter, name, list, type, isLabelFilter, isInclude);
        }
        else {
            this.updateFilter(filter, name, list, type, isLabelFilter, isInclude);
        }
        // }
    }
    updateFilter(filter, name, list, type, isLabelFilter, isInclude) {
        let fln = 0;
        let field = this.fieldList[name];
        field.filter = filter;
        field.filterType = type;
        field.isExcelFilter = isLabelFilter;
        let members = (this.formatFields[name] &&
            (['date', 'dateTime', 'time'].indexOf(this.formatFields[name].type) > -1)) ?
            field.formattedMembers : field.members;
        let allowFil = isInclude;
        let final = {};
        let filterObj = {};
        final[type] = { indexObject: {}, index: [] };
        this.fieldFilterMem[name] = { memberObj: {} };
        while (filter[fln]) {
            if (members[filter[fln]]) {
                let indx = members[filter[fln]].index;
                if (type === 'include') {
                    for (let iln = 0, ilt = indx.length; iln < ilt; iln++) {
                        if (!allowFil || list[type].indexObject[indx[iln]] !== undefined) {
                            final[type].indexObject[indx[iln]] = indx[iln];
                            final[type].index.push(indx[iln]);
                        }
                    }
                }
                else {
                    for (let iln = 0, ilt = indx.length; iln < ilt; iln++) {
                        if (list[type].indexObject[indx[iln]] === undefined) {
                            list[type].indexObject[indx[iln]] = indx[iln];
                            list[type].index.push(indx[iln]);
                        }
                    }
                    this.fieldFilterMem[name].memberObj[filter[fln]] = filter[fln];
                }
            }
            fln++;
        }
        if (type === 'include') {
            list[type] = final[type];
            for (let iln = 0; iln < filter.length; iln++) {
                if (members[filter[iln]]) {
                    filterObj[filter[iln]] = filter[iln];
                }
            }
            let items = Object.keys(members);
            for (let iln = 0, ilt = items.length; iln < ilt; iln++) {
                if (filterObj[items[iln]] === undefined) {
                    this.fieldFilterMem[name].memberObj[items[iln]] = items[iln];
                }
            }
        }
    }
    /* tslint:disable-next-line:max-line-length */
    applyValueFiltering(rowData, level, rows, columns, valueFilter, rowFilterData, type) {
        this.isValueFiltered = false;
        let allMember = extend({}, rows[rows.length - 1], null, true);
        this.getFilteredData(rows, columns, valueFilter, rowFilterData, level, rowData.name, allMember, type);
        if (this.isValueFiltered) {
            rowFilterData.push(allMember);
            rows = rowFilterData;
        }
        return rows;
    }
    /* tslint:disable-next-line:max-line-length */
    getFilteredData(rows, columns, filterSettings, rowFilterData, level, fieldName, allMember, type) {
        let rLen = rows.length;
        for (let i = 0; i < rLen; i++) {
            if (filterSettings[fieldName]) {
                if (rows[i].level === level) {
                    this.isValueFiltered = true;
                    this.fieldList[fieldName].isExcelFilter = true;
                    let value = 0;
                    let measure = filterSettings[fieldName].measure;
                    let mPos = this.fieldList[measure].index;
                    let aggregate = this.fieldList[measure].aggregateType;
                    this.rawIndexObject = {};
                    value = (type === 'row' ? this.getAggregateValue(rows[i].index, columns.indexObject, mPos, aggregate) :
                        this.getAggregateValue(columns.index, rows[i].indexObject, mPos, aggregate));
                    let cellDetails = {
                        fieldName: measure,
                        row: rows[i],
                        column: columns,
                        value: value,
                        cellSets: this.getCellSet(this.rawIndexObject),
                        /* tslint:disable-next-line:max-line-length */
                        rowCellType: (rows[i].hasChild && rows[i].isDrilled ? 'subTotal' : rows[i].type === 'grand sum' ? 'grandTotal' : 'value'),
                        /* tslint:disable-next-line:max-line-length */
                        columnCellType: (columns.hasChild && columns.isDrilled ? 'subTotal' : columns.type === 'grand sum' ? 'grandTotal' : 'value'),
                        aggregateType: aggregate,
                        skipFormatting: false
                    };
                    if (this.getValueCellInfo) {
                        this.getValueCellInfo(cellDetails);
                    }
                    value = cellDetails.value;
                    this.rawIndexObject = {};
                    let operand1 = this.getParsedValue(measure, filterSettings[fieldName].value1);
                    let operand2 = this.getParsedValue(measure, filterSettings[fieldName].value2);
                    /* tslint:disable-next-line:max-line-length */
                    if (!this.validateFilterValue(value, filterSettings[fieldName].condition, operand1, operand2) && rows[i].type !== 'grand sum') {
                        let data = this.removefilteredData(rows[i], this.valueFilteredData);
                        let row = data ? data : rows[i];
                        this.validateFilteredParentData(row, this.valueFilteredData, allMember, 0, level, type);
                    }
                    else if (rows[i].type !== 'grand sum') {
                        rowFilterData.push(extend({}, rows[i], null, true));
                        rowFilterData[rowFilterData.length - 1].isLevelFiltered = true;
                    }
                }
                else if (rows[i].hasChild && rows[i].members.length > 0 && rows[i].type !== 'grand sum') {
                    rowFilterData.push(extend({}, rows[i], null, true));
                    rowFilterData[rowFilterData.length - 1].members = [];
                    rowFilterData[rowFilterData.length - 1].isLevelFiltered = true;
                    /* tslint:disable-next-line:max-line-length */
                    this.getFilteredData(rows[i].members, columns, filterSettings, rowFilterData[rowFilterData.length - 1].members, level, fieldName, allMember, type);
                }
            }
        }
    }
    getParsedValue(measure, value) {
        let cValue = value ? value.toString() : '';
        if (this.formatFields[measure] && value) {
            let formatSetting = extend({}, this.formatFields[measure], null, true);
            delete formatSetting.name;
            return this.globalize.parseNumber(cValue, formatSetting);
        }
        else {
            return this.globalize.parseNumber(cValue, { format: 'N' });
        }
    }
    removefilteredData(row, rowFilterData) {
        let rows = extend([], rowFilterData, null, true);
        let filteredData;
        for (let i = 0; i < rows.length; i++) {
            if (row.isLevelFiltered && row.axis === rows[i].axis &&
                row.valueSort.levelName === rows[i].valueSort.levelName &&
                row.actualText === rows[i].actualText && row.axis === rows[i].axis &&
                row.level === rows[i].level && row.ordinal === rows[i].ordinal) {
                filteredData = rows[i];
                rowFilterData.splice(i, 1);
                break;
            }
            else if (rowFilterData[i].hasChild && rowFilterData[i].members.length > 0) {
                this.removefilteredData(row, rowFilterData[i].members);
            }
        }
        return filteredData;
    }
    /* tslint:disable-next-line:max-line-length */
    validateFilteredParentData(row, rows, allMemberData, i, level, type) {
        if (rows.length > 0) {
            for (let rowFilteredData of rows) {
                if (rowFilteredData.level === i) {
                    if (type === 'row') {
                        let index = row.index;
                        for (let key of index) {
                            if (allMemberData.index.indexOf(key) >= 0) {
                                allMemberData.index.splice(allMemberData.index.indexOf(key), 1);
                            }
                            if (((row.valueSort.levelName.toString()).indexOf(rowFilteredData.valueSort.levelName.toString()) >= 0) &&
                                rowFilteredData.level !== level && rowFilteredData.index.indexOf(key) >= 0) {
                                rowFilteredData.index.splice(rowFilteredData.index.indexOf(key), 1);
                            }
                        }
                    }
                    else {
                        let index = row.indexObject;
                        for (let key of Object.keys(index)) {
                            if (index.hasOwnProperty(key)) {
                                delete allMemberData.indexObject[key];
                                if (((row.valueSort.levelName.toString()).indexOf(rowFilteredData.valueSort.levelName.toString()) >= 0) &&
                                    rowFilteredData.level !== level) {
                                    delete rowFilteredData.indexObject[key];
                                }
                            }
                        }
                    }
                    if (rowFilteredData && rowFilteredData.members.length > 0 &&
                        rowFilteredData.members[0].level === i + 1 && rowFilteredData.members[0].level !== level) {
                        this.validateFilteredParentData(row, rowFilteredData.members, allMemberData, i + 1, level, type);
                    }
                }
            }
        }
        else {
            if (type === 'row') {
                let index = row.index;
                for (let key of index) {
                    if (allMemberData.index.indexOf(key) >= 0) {
                        allMemberData.index.splice(allMemberData.index.indexOf(key), 1);
                    }
                }
            }
            else {
                let index = row.indexObject;
                for (let key of Object.keys(index)) {
                    if (index.hasOwnProperty(key)) {
                        delete allMemberData.indexObject[key];
                    }
                }
            }
        }
    }
    /* tslint:disable-next-line:max-line-length */
    updateFramedHeaders(framedHeaders, dataHeaders, filteredHeaders, headers, type) {
        for (let dHeader of framedHeaders) {
            this.isHeaderAvail = false;
            if (this.validateFilteredHeaders(dHeader, filteredHeaders, type) || dHeader.type === 'grand sum') {
                if (type === 'row') {
                    this.rowCount += this.rowValuesLength;
                }
                else {
                    this.columnCount += this.colValuesLength;
                }
                headers.push(extend({}, dHeader, null, true));
                headers[headers.length - 1].members = [];
                if (dHeader.hasChild && dHeader.isDrilled && dHeader.members.length > 0) {
                    this.updateFramedHeaders(dHeader.members, dataHeaders, filteredHeaders, headers[headers.length - 1].members, type);
                }
            }
        }
        return this.filterFramedHeaders;
    }
    validateFilteredHeaders(dHeader, filteredHeaders, type) {
        for (let vHeader of filteredHeaders) {
            if (!this.isHeaderAvail) {
                if (dHeader.actualText === vHeader.actualText &&
                    dHeader.level === vHeader.level &&
                    dHeader.valueSort.levelName === vHeader.valueSort.levelName) {
                    if (type === 'row') {
                        if (vHeader.index.length > 0) {
                            this.isHeaderAvail = true;
                            dHeader.index = vHeader.index;
                            return true;
                        }
                        else {
                            this.isHeaderAvail = false;
                            dHeader.index = vHeader.index;
                            return false;
                        }
                    }
                    else {
                        if (Object.keys(vHeader.indexObject).length > 0) {
                            this.isHeaderAvail = true;
                            dHeader.indexObject = vHeader.indexObject;
                            return true;
                        }
                        else {
                            this.isHeaderAvail = false;
                            dHeader.indexObject = vHeader.indexObject;
                            return false;
                        }
                    }
                }
                else if (vHeader.hasChild && vHeader.members.length > 0 && vHeader.type !== 'grand sum') {
                    this.validateFilteredHeaders(dHeader, vHeader.members, type);
                }
            }
        }
        return this.isHeaderAvail;
    }
    isEmptyDataAvail(rowHeaders, columnHeaders) {
        this.isEmptyData = false;
        if (rowHeaders.length > 0 && rowHeaders[rowHeaders.length - 1].type === 'grand sum' &&
            rowHeaders[rowHeaders.length - 1].index.length === 0) {
            this.isEmptyData = true;
        }
        if (columnHeaders.length > 0 && columnHeaders[columnHeaders.length - 1].type === 'grand sum' &&
            Object.keys(columnHeaders[columnHeaders.length - 1].indexObject).length === 0) {
            this.isEmptyData = true;
        }
        if (rowHeaders.length === 0 || columnHeaders.length === 0) {
            this.isEmptyData = true;
        }
    }
    /** @hidden */
    updateGridData(dataSource) {
        this.data = dataSource.dataSource;
        if (this.pageSettings && this.pageSettings.allowDataCompression) {
            this.actualData = this.data;
            this.data = this.getGroupedRawData(dataSource);
        }
        this.indexMatrix = [];
        for (let field of this.fields) {
            this.fieldList[field].members = {};
            this.fieldList[field].formattedMembers = {};
            this.fieldList[field].dateMember = [];
        }
        this.fillFieldMembers(this.data, this.indexMatrix);
        this.valueMatrix = this.generateValueMatrix(this.data);
        this.filterMembers = [];
        this.cMembers = [];
        this.rMembers = [];
        this.updateFilterMembers(dataSource);
        this.isEditing = true;
        this.isDrillThrough = true;
        this.generateGridData(dataSource);
        this.isEditing = false;
    }
    /* tslint:disable */
    generateGridData(dataSource, headerCollection) {
        let keys = this.fields;
        let columns = dataSource.columns ? dataSource.columns : [];
        let data = this.data;
        let rows = dataSource.rows ? dataSource.rows : [];
        let filterSettings = dataSource.filterSettings;
        let values = dataSource.values ? dataSource.values : [];
        this.removeCount = 0;
        this.isExpandAll = dataSource.expandAll;
        this.drilledMembers = dataSource.drilledMembers ? dataSource.drilledMembers : [];
        this.isEmptyData = false;
        let filterMembers = [];
        let showNoDataItems = (rows[0] && rows[0].showNoDataItems) || (columns[0] && columns[0].showNoDataItems);
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns, this.values, this.filters);
        if (showNoDataItems) {
            for (let ln = 0; ln < this.indexMatrix.length; ln++) {
                filterMembers.push(ln);
            }
        }
        for (let ln = 0; ln < this.filterMembers.length; ln++) {
            this.filterPosObj[this.filterMembers[ln]] = this.filterMembers[ln];
        }
        //let childrens: Field = this.fieldList[rows[0].name + ''];
        this.valueSortSettings.columnIndex = undefined;
        let st1 = new Date().getTime();
        this.frameDrillObject();
        if (!this.isValueFilterEnabled || this.isEditing) {
            if (!headerCollection) {
                this.columnCount = 0;
                this.rowCount = 0;
                this.cMembers = [];
                this.rMembers = [];
                if (rows.length !== 0) {
                    this.rMembers =
                        this.getIndexedHeaders(rows, data, 0, rows[0].showNoDataItems ? filterMembers : this.filterMembers, 'row', '', this.allowValueFilter);
                }
                if (columns.length !== 0) {
                    this.cMembers = this.getIndexedHeaders(columns, data, 0, columns[0].showNoDataItems ?
                        filterMembers : this.filterMembers, 'column', '', this.allowValueFilter);
                }
                this.insertAllMembersCommon();
                this.saveDataHeaders = (this.isValueFiltersAvail && dataSource.allowValueFilter) ? {
                    rowHeaders: extend([], this.rMembers, null, true),
                    columnHeaders: extend([], this.cMembers, null, true)
                } : {};
            }
        }
        this.pivotValues = [];
        this.headerContent = [];
        this.valueContent = [];
        this.valueFilteredData = [];
        this.filterFramedHeaders = [];
        let rowheads = [];
        let colheads = [];
        let rowFilteredData = [];
        let columnFilteredData = [];
        let valuesCount = (this.values.length);
        if (this.isValueFiltersAvail && dataSource.allowValueFilter && !headerCollection) {
            this.valueFilteredData = [];
            let rowHeaders = this.saveDataHeaders.rowHeaders;
            let columnHeaders = this.saveDataHeaders.columnHeaders;
            if (filterSettings.length > 0) {
                let valueFilters = {};
                let valueFields = {};
                for (let value of values) {
                    valueFields[value.name] = value;
                }
                for (let filter of filterSettings) {
                    rowHeaders = (rowFilteredData.length > 0 ? rowFilteredData : rowHeaders);
                    columnHeaders = (columnFilteredData.length > 0 ? columnFilteredData : columnHeaders);
                    this.valueFilteredData = [];
                    let filterElement = filter.properties ?
                        filter.properties : filter;
                    if (filterElement.type === 'Value' && this.fieldList[filter.name] && this.fieldList[filter.name].isSelected) {
                        valueFilters[filter.name] = filter;
                        filterElement.items = [];
                        let isAvail = false;
                        let rLen = rows.length;
                        let cLen = columns.length;
                        for (let i = 0; i < rLen; i++) {
                            if (filterElement.name === rows[i].name && valueFields[filterElement.measure] && !isAvail) {
                                isAvail = true;
                                /* tslint:disable-next-line:max-line-length */
                                rowFilteredData = this.applyValueFiltering(rows[i], i, rowHeaders, columnHeaders[columnHeaders.length - 1], valueFilters, this.valueFilteredData, 'row');
                                break;
                            }
                        }
                        for (let j = 0; j < cLen; j++) {
                            if (filterElement.name === columns[j].name && valueFields[filterElement.measure] && !isAvail) {
                                isAvail = true;
                                /* tslint:disable-next-line:max-line-length */
                                columnFilteredData = this.applyValueFiltering(columns[j], j, columnHeaders, rowHeaders[rowHeaders.length - 1], valueFilters, this.valueFilteredData, 'column');
                                break;
                            }
                        }
                    }
                }
            }
            rowFilteredData = (rowFilteredData.length > 0 ? rowFilteredData : rowHeaders);
            columnFilteredData = (columnFilteredData.length > 0 ? columnFilteredData : columnHeaders);
            this.isEmptyDataAvail(rowFilteredData, columnFilteredData);
            let savedFieldList = extend({}, this.fieldList, null, true);
            this.indexMatrix = [];
            let fields = this.data[0];
            this.getFieldList(fields, this.enableSort, dataSource.allowValueFilter);
            this.fillFieldMembers(this.data, this.indexMatrix);
            this.updateSortSettings(dataSource.sortSettings, this.enableSort);
            this.valueMatrix = this.generateValueMatrix(this.data);
            this.filterMembers = [];
            this.updateFilterMembers(dataSource);
            this.rMembers = rows.length !== 0 ?
                this.getIndexedHeaders(rows, data, 0, rows[0].showNoDataItems ?
                    filterMembers : this.filterMembers, 'row', '') : [];
            this.cMembers = columns.length !== 0 ?
                this.getIndexedHeaders(columns, data, 0, columns[0].showNoDataItems ?
                    filterMembers : this.filterMembers, 'column', '') : [];
            this.insertAllMembersCommon();
            this.updateFieldList(savedFieldList);
            this.rowCount = 0;
            this.columnCount = 0;
            this.rMembers = this.updateFramedHeaders(this.rMembers, this.rMembers, rowFilteredData, this.filterFramedHeaders, 'row');
            this.filterFramedHeaders = [];
            this.cMembers = this.updateFramedHeaders(this.cMembers, this.cMembers, columnFilteredData, this.filterFramedHeaders, 'column');
            this.isValueFilterEnabled = true;
        }
        if (!headerCollection) {
            this.applyValueSorting();
        }
        if (this.pageSettings) {
            if (!headerCollection) {
                this.headerCollection.rowHeaders = this.rMembers;
                this.headerCollection.columnHeaders = this.cMembers;
                this.headerCollection.rowHeadersCount = this.rowCount;
                this.headerCollection.columnHeadersCount = this.columnCount;
            }
            else {
                this.rMembers = headerCollection.rowHeaders;
                this.cMembers = headerCollection.columnHeaders;
                this.rowCount = headerCollection.rowHeadersCount;
                this.columnCount = headerCollection.columnHeadersCount;
            }
            this.calculatePagingValues();
        }
        this.getAggregatedHeaders(rows, columns, this.rMembers, this.cMembers, values);
        this.getHeaderData(this.cMembers, colheads, this.pivotValues, 0, this.valueAxis ? 1 : valuesCount);
        this.insertSubTotals();
        //this.getHeaderData(rmembers, rowheads, gridData, 0);              
        /* tslint:disable-next-line:max-line-length */
        this.getTableData(this.rMembers, rowheads, colheads, 0, this.pivotValues, valuesCount, this.rMembers[this.rMembers.length - 1], this.cMembers[this.cMembers.length - 1]);
        this.applyAdvancedAggregate(rowheads, colheads, this.pivotValues);
        this.isEngineUpdated = true;
        let st2 = new Date().getTime();
        this.isEmptyDataAvail(this.rMembers, this.cMembers);
        //  console.log(st1 - st2);
    }
    /* tslint:enable */
    /* tslint:disable:no-string-literal */
    /* tslint:disable:typedef */
    /** @hidden */
    onDrill(drilledItem) {
        this.frameDrillObject();
        let headersInfo = this.getHeadersInfo(drilledItem.fieldName, drilledItem.axis);
        this.performDrillOperation(headersInfo.headers, drilledItem, headersInfo.fields, headersInfo.position, 0);
        this.headerCollection.rowHeadersCount = this.rowCount;
        this.headerCollection.columnHeadersCount = this.columnCount;
        if (headersInfo.axis === 'row') {
            this.headerCollection.rowHeaders = headersInfo.headers;
        }
        else {
            this.headerCollection.columnHeaders = headersInfo.headers;
        }
        this.updateEngine();
    }
    /** @hidden */
    onSort(sortItem) {
        let headersInfo = this.getHeadersInfo(sortItem.name, '');
        this.fieldList[sortItem.name].sort = sortItem.order;
        this.performSortOperation(headersInfo.headers, sortItem, headersInfo, 0);
        this.updateEngine();
    }
    /** @hidden */
    onFilter(filterItem, dataSource) {
        let headersInfo = this.getHeadersInfo(filterItem.name, '');
        if (filterItem.type === 'Include' && filterItem.items.length === this.fieldList[filterItem.name].dateMember.length) {
            this.fieldList[filterItem.name].filter = [];
            this.fieldList[filterItem.name].filterType = '';
        }
        else {
            this.fieldList[filterItem.name].filter = filterItem.items;
            this.fieldList[filterItem.name].filterType = filterItem.type;
        }
        let posObj = {};
        for (let pos of this.filterMembers) {
            posObj[pos] = pos;
        }
        this.filterMembers = [];
        this.fieldFilterMem = {};
        this.updateFilterMembers(dataSource);
        let addPos = this.filterMembers.filter((pos) => { return posObj[pos] === undefined; });
        for (let item of filterItem.items) {
            
        }
        let showNoDataItems = (this.rows[0] && this.rows[0].showNoDataItems) || (this.columns[0] && this.columns[0].showNoDataItems);
        if (showNoDataItems) {
            let filterMembers = [];
            this.filterPosObj = {};
            for (let ln = 0; ln < addPos.length; ln++) {
                this.filterPosObj[addPos[ln]] = addPos[ln];
            }
            for (let ln = 0; ln < this.indexMatrix.length; ln++) {
                filterMembers.push(ln);
            }
            addPos = filterMembers;
        }
        this.performFilterCommonUpdate(filterItem, headersInfo, addPos);
        this.frameHeaderObjectsCollection = false;
        this.headerObjectsCollection = {};
        this.updateEngine();
    }
    /** @hidden */
    onAggregation(field) {
        this.fieldList[field.name].aggregateType = field.type;
        this.rMembers = this.headerCollection.rowHeaders;
        this.cMembers = this.headerCollection.columnHeaders;
        if (this.allowDataCompression) {
            this.data = this.getGroupedRawData(this.dataSourceSettings);
            this.valueMatrix = this.generateValueMatrix(this.data);
        }
        this.updateEngine();
    }
    /** @hidden */
    onCalcOperation(field) {
        this.rMembers = this.headerCollection.rowHeaders;
        this.cMembers = this.headerCollection.columnHeaders;
        this.getCalculatedField(this.fields);
        if (this.fieldList[field.name]) {
            this.fieldList[field.name].formula = field.formula;
        }
        else {
            this.fieldList[field.name] = {
                id: field.name,
                caption: field.name,
                type: 'number',
                aggregateType: 'CalculatedField',
                filterType: '',
                index: this.fields.length - 1,
                filter: [],
                sort: this.enableSort ? 'Ascending' : 'None',
                isSelected: true,
                isExcelFilter: false,
                formula: field.formula
            };
            if (this.valueAxis === 1) {
                this.headerCollection.rowHeadersCount = this.rowCount = (this.rowCount / (this.values.length - 1)) * this.values.length;
            }
            else {
                this.headerCollection.columnHeadersCount = this.columnCount = (this.columnCount / (this.values.length - 1)) * this.values.length;
            }
        }
        this.updateEngine();
    }
    performDrillOperation(headers, drilledItem, fields, position, currentPosition) {
        let count = 0;
        while (count < headers.length) {
            if (position === currentPosition) {
                if (drilledItem.memberName === headers[count].valueSort.levelName.split(this.valueSortSettings.headerDelimiter)
                    .join(drilledItem.delimiter ? drilledItem.delimiter : '**')) {
                    if (drilledItem.action === 'down') {
                        headers[count].isDrilled = true;
                        headers[count].members = this.getIndexedHeaders(fields, this.data, position + 1, headers[count].index, drilledItem.axis, drilledItem.memberName.
                            split(drilledItem.delimiter ? drilledItem.delimiter : '**').join(this.valueSortSettings.headerDelimiter));
                        let sortedHeaders;
                        if (drilledItem.axis === 'row') {
                            sortedHeaders = this.applyValueSorting(headers[count].members, this.cMembers);
                            headers[count].members = sortedHeaders.rMembers;
                        }
                        else {
                            let showSubTotals = this.showSubTotals && this.showColumnSubTotals && fields[position].showSubTotals;
                            this.columnCount -= !showSubTotals ? this.colValuesLength : 0;
                            sortedHeaders = this.applyValueSorting(this.rMembers, headers[count].members);
                            headers[count].members = sortedHeaders.cMembers;
                        }
                    }
                    else {
                        headers[count].isDrilled = false;
                        this.updateHeadersCount(headers[count].members, drilledItem.axis, position, fields, 'minus', true);
                        headers[count].members = [];
                    }
                    break;
                }
            }
            else if (headers[count].members.length > 0) {
                headers[count].members = this.performDrillOperation(headers[count].members, drilledItem, fields, position, currentPosition + 1);
            }
            count++;
        }
        return headers;
    }
    performSortOperation(headers, sortItem, headersInfo, currentPosition) {
        let count = 0;
        while (count < headers.length) {
            if (headersInfo.position === currentPosition) {
                headers = this.getSortedHeaders(headers, sortItem.order.toString());
                break;
            }
            else if (headers[count].members.length > 0) {
                headers[count].members = this.performSortOperation(headers[count].members, sortItem, headersInfo, currentPosition + 1);
            }
            count++;
        }
        return headers;
    }
    performFilterDeletion(headers, filterItem, headersInfo, filterObjects, currentPosition) {
        let count = 0;
        let loopIn = true;
        while (count < headers.length && loopIn) {
            if (headersInfo.position === currentPosition) {
                let engine = this;
                headers = headers.filter((item) => {
                    return !engine.fieldFilterMem[filterItem.name].memberObj[item.formattedText] || item.type === 'grand sum';
                });
                loopIn = false;
            }
            else if (headers[count].members.length > 0) {
                headers[count].members = this.performFilterDeletion(headers[count].members, filterItem, headersInfo, filterObjects, currentPosition + 1);
            }
            count++;
        }
        let engine = this;
        return headers.filter((item) => {
            return item.members.length > 0 ? item.members.length > 0 : engine.matchIndexes(item.indexObject, filterObjects);
        });
    }
    matchIndexes(index, filterObjects) {
        let keys = Object.keys(index);
        let len = keys.length;
        if (len === 0) {
            return true;
        }
        while (len > -1) {
            if (filterObjects[index[keys[len]]] !== undefined) {
                return true;
            }
            len--;
        }
        return false;
    }
    performFilterAddition(headers, fields, headersInfo) {
        let count = 0;
        while (count < headers.length) {
            let levelName = headers[count].valueSort.levelName;
            if (this.headerObjectsCollection[levelName]) {
                let memberNameObj = {};
                for (let member of headers[count].members) {
                    memberNameObj[member.valueSort.levelName.toString()] = member.valueSort.levelName.toString();
                }
                let excessHeaders = this.headerObjectsCollection[levelName].filter((member) => {
                    return !memberNameObj[member.valueSort.levelName.toString()];
                });
                headers[count].members = headers[count].members.concat(excessHeaders);
                headers[count].members = this.getSortedHeaders(headers[count].members, this.fieldList[headersInfo.fields[headers[count].members[0].level].name].sort);
                delete this.headerObjectsCollection[levelName];
            }
            if (headers[count].members.length > 0) {
                headers[count].members = this.performFilterAddition(headers[count].members, fields, headersInfo);
            }
            count++;
        }
        return headers;
    }
    performFilterCommonUpdate(filterItem, headersInfo, addPos) {
        let rawHeaders = headersInfo.axis === 'row' ? this.rMembers : this.cMembers;
        let filterObjects = {};
        for (let item of this.filterMembers) {
            filterObjects[item] = item;
        }
        if (this.fieldFilterMem[filterItem.name]) {
            rawHeaders = this.performFilterDeletion(headersInfo.headers, filterItem, headersInfo, filterObjects, 0);
        }
        if (addPos.length > 0) {
            this.frameHeaderObjectsCollection = true;
            if (headersInfo.fields.filter((item) => { return item.showNoDataItems; }).length > 0) {
                addPos = this.data.map((item, pos) => { return pos; });
            }
            this.headerObjectsCollection['parent'] = this.getIndexedHeaders(headersInfo.fields, this.data, 0, addPos, headersInfo.axis, '');
            rawHeaders = this.performFilterAddition(rawHeaders, headersInfo.fields, headersInfo);
            let headerNames = {};
            for (let header of rawHeaders) {
                headerNames[header.valueSort.levelName.toString()] = header.valueSort.levelName.toString();
            }
            let excessHeaders = this.headerObjectsCollection['parent'].filter((header) => {
                return !headerNames[header.valueSort.levelName.toString()];
            });
            let grandHeader = rawHeaders.filter((item) => { return item.type === 'grand sum'; });
            if (grandHeader.length > 0) {
                rawHeaders.pop();
            }
            rawHeaders = this.getSortedHeaders(rawHeaders.concat(excessHeaders), this.fieldList[headersInfo.fields[0].name].sort).concat(grandHeader);
        }
        if (headersInfo.axis === 'row') {
            this.rowCount = 0;
        }
        else {
            this.columnCount = 0;
        }
        this.updateHeadersCount(rawHeaders, headersInfo.axis, 0, headersInfo.fields, 'plus', false);
        if (headersInfo.axis === 'row') {
            if (headersInfo.position > 0) {
                this.insertPosition(this.rows, this.data, 0, this.filterMembers, 'row', '', rawHeaders);
            }
            this.insertTotalPosition(rawHeaders);
            this.rMembers = this.headerCollection.rowHeaders = rawHeaders;
            this.headerCollection.rowHeadersCount = this.rowCount;
        }
        else {
            if (headersInfo.position > 0) {
                this.insertPosition(this.columns, this.data, 0, this.filterMembers, 'column', '', rawHeaders);
            }
            this.insertTotalPosition(rawHeaders);
            this.cMembers = this.headerCollection.columnHeaders = rawHeaders;
            this.headerCollection.columnHeadersCount = this.columnCount;
        }
        this.applyValueSorting();
    }
    getHeadersInfo(fieldName, axis) {
        this.rMembers = this.headerCollection.rowHeaders;
        this.cMembers = this.headerCollection.columnHeaders;
        axis = axis === '' ? this.getAxisByFieldName(fieldName) : axis;
        let headers = axis === 'row' ? this.rMembers : this.cMembers;
        let fields = axis === 'row' ? this.rows : this.columns;
        let position = 0;
        for (let field of fields) {
            if (field.name === fieldName) {
                break;
            }
            position++;
        }
        return { axis: axis, fields: fields, headers: headers, position: position };
    }
    /** @hidden */
    updateEngine() {
        this.removeCount = 0;
        this.calculatePagingValues();
        this.pivotValues = [];
        this.headerContent = [];
        this.valueContent = [];
        let rowheads = [];
        let colheads = [];
        let valuesCount = (this.values.length);
        this.getAggregatedHeaders(this.rows, this.columns, this.rMembers, this.cMembers, this.values);
        this.getHeaderData(this.cMembers, colheads, this.pivotValues, 0, this.valueAxis ? 1 : valuesCount);
        this.insertSubTotals();
        /* tslint:disable-next-line:max-line-length */
        this.getTableData(this.rMembers, rowheads, colheads, 0, this.pivotValues, valuesCount, this.rMembers[this.rMembers.length - 1], this.cMembers[this.cMembers.length - 1]);
        this.applyAdvancedAggregate(rowheads, colheads, this.pivotValues);
        this.isEngineUpdated = true;
        this.isEmptyDataAvail(this.rMembers, this.cMembers);
    }
    getAxisByFieldName(fieldName) {
        let axisCount = 0;
        let axis = '';
        while (axisCount < 4 && axis === '') {
            switch (axisCount) {
                case 0:
                    axis = this.getFieldByName(fieldName, this.rows) ? 'row' : '';
                    break;
                case 1:
                    axis = this.getFieldByName(fieldName, this.columns) ? 'column' : '';
                    break;
            }
            axisCount++;
        }
        return axis;
    }
    getFieldByName(fieldName, fields) {
        return new DataManager({ json: fields }).executeLocal(new Query().where('name', 'equal', fieldName))[0];
    }
    /* tslint:disable:no-any */
    updateHeadersCount(headers, axis, position, fields, action, isDrill) {
        let lenCnt = 0;
        let field = fields[position];
        let showSubTotals = true;
        if (axis === 'column') {
            showSubTotals = this.showSubTotals && this.showColumnSubTotals && field.showSubTotals;
        }
        else {
            showSubTotals = this.showSubTotals && this.showRowSubTotals && field.showSubTotals;
        }
        while (lenCnt < headers.length) {
            if (axis === 'row') {
                this.rowCount = this.rowCount - (action === 'plus' ? -(this.valueAxis === 1 ? this.values.length : 1) :
                    (this.valueAxis === 1 ? this.values.length : 1));
            }
            else {
                this.columnCount = this.columnCount - (action === 'plus' ? -(this.valueAxis === 1 ? 1 : this.values.length) :
                    (this.valueAxis === 1 ? 1 : this.values.length));
            }
            if (headers[lenCnt].members.length > 0) {
                this.updateHeadersCount(headers[lenCnt].members, axis, position + 1, fields, action, true);
            }
            lenCnt++;
        }
        if (axis === 'column' && !showSubTotals && isDrill) {
            this.columnCount += action === 'plus' ? -this.colValuesLength : this.colValuesLength;
        }
    }
    /** @hidden */
    frameHeaderWithKeys(header) {
        let keys = Object.keys(header);
        let keyPos = 0;
        let framedHeader = {};
        while (keyPos < keys.length) {
            framedHeader[keys[keyPos]] = header[keys[keyPos]];
            keyPos++;
        }
        return framedHeader;
    }
    getSortedHeaders(headers, sortOrder) {
        let isNotDateType = !(this.formatFields && this.formatFields[headers[0].valueSort.axis] &&
            this.formatFields[headers[0].valueSort.axis].type);
        if (isNotDateType) {
            return sortOrder === 'Ascending' ?
                (headers.sort((a, b) => (a.actualText > b.actualText) ? 1 : ((b.actualText > a.actualText) ? -1 : 0))) :
                sortOrder === 'Descending' ?
                    (headers.sort((a, b) => (a.actualText < b.actualText) ? 1 : ((b.actualText < a.actualText) ? -1 : 0))) :
                    headers;
        }
        else {
            return sortOrder === 'Ascending' ?
                (headers.sort((a, b) => (a.dateText > b.dateText) ? 1 : ((b.dateText > a.dateText) ? -1 : 0))) :
                sortOrder === 'Descending' ?
                    (headers.sort((a, b) => (a.dateText < b.dateText) ? 1 : ((b.dateText < a.dateText) ? -1 : 0))) :
                    headers;
        }
    }
    /** @hidden */
    applyValueSorting(rMembers, cMembers) {
        let isNullArgument = false;
        if (rMembers === undefined || cMembers === undefined) {
            rMembers = this.rMembers;
            cMembers = this.cMembers;
            isNullArgument = true;
        }
        if (this.enableValueSorting && this.valueSortSettings.headerText &&
            this.valueSortSettings.headerText !== '' && this.values.length > 0) {
            let textArray = this.valueSortSettings.headerText.split(this.valueSortSettings.headerDelimiter);
            let hText = '';
            let mIndex;
            let mType;
            let caption;
            for (let i = 0; i < this.values.length; i++) {
                if (this.values[i].caption === textArray[textArray.length - 1]) {
                    caption = this.values[i].name;
                    break;
                }
                else {
                    caption = textArray[textArray.length - 1];
                }
            }
            if (((this.values.length === 1 && this.columns.length === 0) || this.values.length > 1) && caption && this.fieldList[caption]) {
                for (let i = 0; i < textArray.length - 1; i++) {
                    hText = hText === '' ? textArray[i] : (hText + this.valueSortSettings.headerDelimiter + textArray[i]);
                }
                mIndex = this.fieldList[caption].index;
                mType = this.fieldList[caption].aggregateType;
            }
            else {
                if (!this.alwaysShowValueHeader || textArray.length === 1) {
                    hText = this.valueSortSettings.headerText;
                }
                else {
                    for (let i = 0; i < textArray.length - 1; i++) {
                        hText = hText === '' ? textArray[i] : (hText + this.valueSortSettings.headerDelimiter + textArray[i]);
                    }
                }
                mIndex = this.fieldList[this.values[0].name].index;
                mType = this.fieldList[this.values[0].name].aggregateType;
            }
            let member;
            if (this.valueAxis === 0) {
                member = this.getMember(cMembers, hText);
                if (member) {
                    rMembers = this.sortByValueRow(rMembers, member, this.valueSortSettings.sortOrder, mIndex, mType);
                }
            }
            else {
                member = this.getMember(rMembers, hText);
                if (member) {
                    cMembers = this.sortByValueRow(cMembers, member, this.valueSortSettings.sortOrder, mIndex, mType);
                }
            }
            if (isNullArgument) {
                this.rMembers = rMembers;
                this.cMembers = cMembers;
                if (this.pageSettings) {
                    this.headerCollection.rowHeaders = this.rMembers;
                    this.headerCollection.columnHeaders = this.cMembers;
                }
            }
        }
        return { rMembers: rMembers, cMembers: cMembers };
    }
    getMember(cMembers, headerText) {
        let vlen = cMembers.length;
        let member;
        for (let j = 0; j < vlen; j++) {
            if (cMembers[j].valueSort.levelName === headerText) {
                member = cMembers[j];
                break;
            }
            else if (cMembers[j].members.length > 0) {
                member = this.getMember(cMembers[j].members, headerText);
            }
            if (member) {
                return member;
            }
        }
        return member;
    }
    sortByValueRow(rMembers, member, sortOrder, mIndex, mType) {
        let aggreColl = [];
        for (let header of rMembers) {
            if (header.type === 'grand sum') {
                aggreColl.push({ 'header': header });
            }
            else {
                this.rawIndexObject = {};
                let value = this.getAggregateValue(header.index, member.indexObject, mIndex, mType);
                let cellDetails = {
                    fieldName: this.fields[mIndex],
                    row: header,
                    column: member,
                    value: value,
                    cellSets: this.getCellSet(this.rawIndexObject),
                    /* tslint:disable-next-line:max-line-length */
                    rowCellType: (header.hasChild && header.isDrilled ? 'subTotal' : header.type === 'grand sum' ? 'grandTotal' : 'value'),
                    /* tslint:disable-next-line:max-line-length */
                    columnCellType: (member.hasChild && member.isDrilled ? 'subTotal' : member.type === 'grand sum' ? 'grandTotal' : 'value'),
                    aggregateType: mType,
                    skipFormatting: false
                };
                if (this.getValueCellInfo) {
                    this.getValueCellInfo(cellDetails);
                }
                value = cellDetails.value;
                this.rawIndexObject = {};
                aggreColl.push({ 'header': header, 'value': value });
            }
        }
        aggreColl.sort((a, b) => {
            return sortOrder === 'Descending' ?
                ((b['value'] || b['header']['type'] === 'grand sum' ?
                    b['value'] : 0) - (a['value'] || a['header']['type'] === 'grand sum' ? a['value'] : 0)) :
                ((a['value'] || a['header']['type'] === 'grand sum' ?
                    a['value'] : 0) - (b['value'] || b['header']['type'] === 'grand sum' ? b['value'] : 0));
        });
        rMembers = aggreColl.map((item) => { return item['header']; });
        for (let header of rMembers) {
            if (header.members.length > 0) {
                header.members = this.sortByValueRow(header.members, member, sortOrder, mIndex, mType);
            }
        }
        return rMembers;
    }
    insertAllMembersCommon() {
        /* inserting the row grant-total members */
        let rowFlag = (this.showGrandTotals && this.showRowGrandTotals) ? true : (this.rows.length > 0) ? false : true;
        if (rowFlag) {
            this.insertAllMember(this.rMembers, this.filterMembers, '', 'row');
        }
        /* inserting the column gran-total members */
        let columnFlag = (this.showGrandTotals && this.showColumnGrandTotals) ? true : (this.columns.length > 0) ? false : true;
        if (columnFlag) {
            this.insertAllMember(this.cMembers, this.filterMembers, '', 'column');
        }
    }
    insertSubTotals() {
        let rowLength = this.pivotValues.length;
        for (let rowCnt = 0; rowCnt < rowLength; rowCnt++) {
            let rowCells = this.pivotValues[rowCnt];
            if (rowCells) {
                let savedCell;
                let spanCnt = 1;
                let colLength = rowCells.length;
                let indexObj;
                for (let colCnt = colLength - 1; colCnt > 0; colCnt--) {
                    let cell = rowCells[colCnt];
                    if (cell) {
                        // if (cell.rowSpan > 1) {
                        //     cell.rowSpan = 1;
                        // }
                        if (savedCell) {
                            savedCell.colSpan = spanCnt;
                            savedCell.colIndex = savedCell.colIndex - (spanCnt - 1);
                        }
                        indexObj = { index: cell.index, indexObject: cell.indexObject };
                        cell.index = [];
                        cell.indexObject = {};
                        savedCell = extend({}, cell, null, true);
                        cell.index = indexObj.index;
                        cell.indexObject = indexObj.indexObject;
                        let rowPos = rowCnt + 1;
                        while (this.pivotValues[rowPos] && !this.pivotValues[rowPos][colCnt]) {
                            if (!this.pivotValues[rowCnt][colCnt].isDrilled) {
                                this.pivotValues[rowCnt][colCnt].rowSpan = (rowPos - rowCnt) + 1;
                                savedCell.rowSpan = (rowPos - rowCnt) + 1;
                            }
                            let cellType = (cell.type === 'sum' || cell.type === 'grand sum') ? cell.type : 'sum';
                            this.pivotValues[rowPos][colCnt] = this.headerContent[rowPos][colCnt] = {
                                type: cellType, formattedText: ((cell.type === 'sum' || cell.type === 'grand sum') ? cell.formattedText :
                                    (cell.formattedText + ' Total')),
                                axis: 'column', level: -1, colIndex: colCnt, rowIndex: rowPos, valueSort: cell.valueSort
                            };
                            if (cell.valueSort && cell.valueSort[this.valueSortSettings.headerText]) {
                                this.valueSortSettings.columnIndex = colCnt;
                            }
                            let isSpanned = false;
                            if (cellType === 'grand sum') {
                                this.pivotValues[rowCnt][colCnt].rowSpan = (rowPos - rowCnt) + 1;
                                savedCell.rowSpan = (rowPos - rowCnt) + 1;
                            }
                            else if (this.pivotValues[rowCnt][colCnt].type !== 'sum' &&
                                this.pivotValues[rowCnt][colCnt].isDrilled) {
                                this.pivotValues[rowCnt + 1][colCnt].rowSpan = rowPos - rowCnt;
                                isSpanned = true;
                            }
                            else {
                                this.pivotValues[rowPos][colCnt].rowSpan = -1;
                            }
                            if (rowPos > (rowCnt + 1) && (this.pivotValues[rowCnt][colCnt].type === 'sum' ||
                                isSpanned)) {
                                this.pivotValues[rowPos][colCnt].rowSpan = -1;
                            }
                            rowPos++;
                        }
                        spanCnt = 1;
                    }
                    else {
                        rowCells[colCnt] = this.headerContent[rowCnt][colCnt] = extend({}, savedCell, null, true);
                        rowCells[colCnt].index = this.headerContent[rowCnt][colCnt].index = indexObj.index;
                        rowCells[colCnt].indexObject = this.headerContent[rowCnt][colCnt].indexObject = indexObj.indexObject;
                        spanCnt++;
                        rowCells[colCnt].colSpan = spanCnt;
                        rowCells[colCnt].colIndex = rowCells[colCnt].colIndex - (spanCnt - 1);
                    }
                    if (colCnt === 1 && savedCell) {
                        savedCell.colSpan = spanCnt;
                        savedCell.colIndex = savedCell.colIndex - (spanCnt - 1);
                    }
                }
            }
        }
    }
    frameDrillObject() {
        this.fieldDrillCollection = {};
        for (let fieldCnt = 0; fieldCnt < this.drilledMembers.length; fieldCnt++) {
            let drillOption = this.drilledMembers[fieldCnt];
            for (let memberCnt = 0; memberCnt < drillOption.items.length; memberCnt++) {
                let memberString = drillOption.name + this.valueSortSettings.headerDelimiter +
                    drillOption.items[memberCnt].split(drillOption.delimiter).join(this.valueSortSettings.headerDelimiter);
                this.fieldDrillCollection[memberString] = memberString;
            }
        }
    }
    /* tslint:disable:max-func-body-length */
    getIndexedHeaders(keys, data, keyInd, position, axis, parentMember, valueFil) {
        let hierarchy = [];
        if (keys) {
            let rlen = keys.length;
            let decisionObj = {};
            let fieldName = keys[keyInd].name;
            let field = keys[keyInd];
            // let members: string[] = Object.keys(this.fieldList[field].members);
            let childrens = this.fieldList[fieldName];
            let isNoData = false;
            let isDateType = (this.formatFields[fieldName] &&
                (['date', 'dateTime', 'time'].indexOf(this.formatFields[fieldName].type) > -1));
            let showNoDataItems = (position.length < 1 && keyInd > 0) || field.showNoDataItems;
            let savedMembers = {};
            if (showNoDataItems) {
                let members = Object.keys(childrens.members);
                for (let pos = 0, lt = members.length; pos < lt; pos++) {
                    if (this.showHeaderWhenEmpty || (this.localeObj && members[pos] !== this.localeObj.getConstant('undefined'))) {
                        savedMembers[members[pos]] = members[pos];
                    }
                }
                if (position.length < 1) {
                    isNoData = true;
                    position.length = members.length;
                }
            }
            for (let pos = 0, lt = position.length; pos < lt; pos++) {
                let member = {};
                if (!isNullOrUndefined(keys[keyInd].showSubTotals) && !keys[keyInd].showSubTotals) {
                    member.showSubTotals = false;
                }
                member.hasChild = keyInd < rlen - 1;
                member.level = keyInd;
                member.axis = axis;
                member.colSpan = 1;
                let memInd = isNoData ? childrens.members[Object.keys(savedMembers)[0]].ordinal :
                    this.indexMatrix[position[pos]][childrens.index];
                let headerValue = isNoData ? Object.keys(savedMembers)[0] :
                    data[position[pos]][fieldName];
                if ((isNullOrUndefined(headerValue) || (this.localeObj && headerValue === this.localeObj.getConstant('undefined')))
                    && !this.showHeaderWhenEmpty) {
                    if (showNoDataItems && !isNoData && keyInd > 0 && pos + 1 === position.length &&
                        Object.keys(savedMembers).length > 0) {
                        lt = Object.keys(savedMembers).length;
                        isNoData = true;
                        pos = -1;
                    }
                    continue;
                }
                delete savedMembers[headerValue];
                if (showNoDataItems && this.fieldFilterMem[fieldName] &&
                    this.fieldFilterMem[fieldName].memberObj[headerValue] === headerValue) {
                    continue;
                }
                let formattedValue = isDateType ? {
                    actualText: headerValue,
                    formattedText: childrens.dateMember[memInd - 1].formattedText,
                    dateText: childrens.dateMember[memInd - 1].actualText
                } :
                    {
                        formattedText: headerValue === null ? (this.localeObj ? this.localeObj.getConstant('null') : String(headerValue)) :
                            headerValue === undefined ? (this.localeObj ? (fieldName in this.groupingFields) ?
                                this.localeObj.getConstant('groupOutOfRange') : this.localeObj.getConstant('undefined') :
                                String(headerValue)) : String(headerValue), actualText: headerValue === null ? (this.localeObj ?
                            this.localeObj.getConstant('null') : String(headerValue)) : headerValue === undefined ?
                            (this.localeObj ? (fieldName in this.groupingFields) ?
                                this.localeObj.getConstant('groupOutOfRange') : this.localeObj.getConstant('undefined') :
                                String(headerValue)) : headerValue
                    };
                member.actualText = formattedValue.actualText;
                member.formattedText = formattedValue.formattedText;
                if (isDateType) {
                    member.dateText = formattedValue.dateText;
                }
                let availData = showNoDataItems ? (this.filterPosObj[position[pos]] !== undefined &&
                    !isNoData ? true : false) : true;
                //member.name = members[memInd];
                // member.type = member.hasChild ? 'All' : 'Single';
                if (!(decisionObj && decisionObj[memInd])) {
                    decisionObj[memInd] = { index: [], indexObject: {} };
                    member.index = decisionObj[memInd].index;
                    member.indexObject = decisionObj[memInd].indexObject;
                    if (availData) {
                        member.index = decisionObj[memInd].index = [position[pos]];
                        decisionObj[memInd].indexObject[position[pos]] = position[pos];
                        member.indexObject = decisionObj[memInd].indexObject;
                    }
                    member.ordinal = memInd;
                    member.valueSort = {};
                    member.valueSort.axis = fieldName;
                    if (keyInd !== 0) {
                        member.valueSort.levelName = parentMember + this.valueSortSettings.headerDelimiter + member.formattedText;
                        member.valueSort[parentMember + this.valueSortSettings.headerDelimiter + member.formattedText] = 1;
                    }
                    else {
                        member.valueSort[member.formattedText] = 1;
                        member.valueSort.levelName = member.formattedText;
                    }
                    let memberString = member.valueSort.axis + this.valueSortSettings.headerDelimiter + member.valueSort.levelName;
                    member.isDrilled = (valueFil && this.isValueFiltersAvail) ?
                        true : (member.hasChild && this.fieldDrillCollection[memberString]) ?
                        this.isExpandAll ? false : true : childrens.members[headerValue].isDrilled;
                    //if (!member.members) {
                    member.members = [];
                    //}
                    //let copyObj: AxisSet = Object.create(member);
                    hierarchy.push(member);
                }
                else if (availData) {
                    decisionObj[memInd].index.push(position[pos]);
                    decisionObj[memInd].indexObject[position[pos]] = position[pos];
                }
                if (showNoDataItems && !isNoData && keyInd > 0 && pos + 1 === position.length &&
                    Object.keys(savedMembers).length > 0) {
                    isNoData = true;
                    lt = Object.keys(savedMembers).length;
                    pos = -1;
                }
            }
            for (let iln = 0, ilt = hierarchy.length; iln < ilt; iln++) {
                if (!this.frameHeaderObjectsCollection) {
                    if (axis === 'row') {
                        this.rowCount += this.rowValuesLength;
                    }
                    else {
                        this.columnCount += this.colValuesLength;
                    }
                }
                let level = null;
                if (hierarchy[iln].valueSort && hierarchy[iln].valueSort.levelName) {
                    level = hierarchy[iln].valueSort.levelName;
                }
                parentMember = (level || hierarchy[iln].formattedText);
                if (!this.showHeaderWhenEmpty && rlen - 1 > keyInd && hierarchy[iln].index &&
                    hierarchy[iln].index.length > 0 && !showNoDataItems) {
                    let headerValue = data[hierarchy[iln].index[0]][keys[keyInd + 1].name];
                    let hasChild = (isNullOrUndefined(headerValue) || (this.localeObj &&
                        headerValue === this.localeObj.getConstant('undefined'))) && hierarchy[iln].index.length === 1 ? false : true;
                    hierarchy[iln].hasChild = hasChild;
                }
                else if (!this.showHeaderWhenEmpty && showNoDataItems && keys[keyInd + 1] && keys[keyInd + 1].name &&
                    Object.keys(this.fieldList[keys[keyInd + 1].name].members).length) {
                    hierarchy[iln].hasChild = true;
                }
                if (rlen - 1 > keyInd && hierarchy[iln].isDrilled) {
                    this.columnCount -= (!(this.showSubTotals && this.showColumnSubTotals && field.showSubTotals) && axis === 'column') ?
                        this.colValuesLength : 0;
                    let filterPosition = hierarchy[iln].index;
                    /* tslint:disable:align */
                    hierarchy[iln].members = this.getIndexedHeaders(keys, data, keyInd + 1, (filterPosition === undefined ? [] : filterPosition), axis, parentMember);
                    /* tslint:enable:align */
                    if (this.frameHeaderObjectsCollection) {
                        this.headerObjectsCollection[parentMember] = hierarchy[iln].members;
                    }
                }
            }
            /* tslint:disable:typedef */
            if (this.enableSort) {
                // return new DataManager(hierarchy as JSON[]).executeLocal(new Query().sortBy('actualText', childrens.sort.toLowerCase()));
                if (isDateType) {
                    return childrens.sort === 'Ascending' ?
                        (hierarchy.sort((a, b) => (a.dateText > b.dateText) ? 1 : ((b.dateText > a.dateText) ? -1 : 0))) :
                        childrens.sort === 'Descending' ?
                            (hierarchy.sort((a, b) => (a.dateText < b.dateText) ? 1 : ((b.dateText < a.dateText) ? -1 : 0))) :
                            hierarchy;
                }
                else {
                    return childrens.sort === 'Ascending' ?
                        (hierarchy.sort((a, b) => (a.actualText > b.actualText) ? 1 : ((b.actualText > a.actualText) ? -1 : 0))) :
                        childrens.sort === 'Descending' ?
                            (hierarchy.sort((a, b) => (a.actualText < b.actualText) ? 1 : ((b.actualText < a.actualText) ? -1 : 0))) :
                            hierarchy;
                }
            }
            else {
                return hierarchy;
            }
            /* tslint:enable:typedef */
        }
        else {
            return hierarchy;
        }
    }
    getOrderedIndex(headers) {
        let orderedIndex = {};
        for (let i = 0; i < headers.length; i++) {
            if (headers[i].type !== 'grand sum') {
                orderedIndex[headers[i].ordinal] = i;
            }
        }
        return orderedIndex;
    }
    insertPosition(keys, data, keyInd, position, axis, parentMember, slicedHeaders) {
        let hierarchy = [];
        let orderedIndex = this.getOrderedIndex(slicedHeaders);
        if (keys) {
            let decisionObj = {};
            let field = keys[keyInd].name;
            let childrens = this.fieldList[field];
            for (let pos = 0, lt = position.length; pos < lt; pos++) {
                let member = {};
                let memInd = this.indexMatrix[position[pos]][childrens.index];
                let slicedHeader = slicedHeaders[orderedIndex[memInd]];
                let formattedValue = (this.formatFields[field] &&
                    (['date', 'dateTime', 'time'].indexOf(this.formatFields[field].type) > -1)) ?
                    this.getFormattedValue(data[position[pos]][field], field) :
                    { formattedText: data[position[pos]][field].toString(), actualText: data[position[pos]][field].toString() };
                if (!(slicedHeader && slicedHeader.formattedText === formattedValue.formattedText)) {
                    continue;
                }
                if (!(decisionObj && decisionObj[memInd])) {
                    decisionObj[memInd] = { index: [], indexObject: {} };
                    slicedHeader.index = decisionObj[memInd].index = [position[pos]];
                    decisionObj[memInd].indexObject[position[pos]] = position[pos];
                    slicedHeader.indexObject = decisionObj[memInd].indexObject;
                    slicedHeader.valueSort = {};
                    slicedHeader.valueSort.axis = field;
                    if (keyInd !== 0) {
                        slicedHeader.valueSort.levelName = parentMember + this.valueSortSettings.headerDelimiter +
                            slicedHeader.formattedText;
                        slicedHeader.valueSort[parentMember + this.valueSortSettings.headerDelimiter +
                            slicedHeader.formattedText] = 1;
                    }
                    else {
                        slicedHeader.valueSort[slicedHeader.formattedText] = 1;
                        slicedHeader.valueSort.levelName = slicedHeader.formattedText;
                    }
                    member.members = [];
                    hierarchy.push(member);
                }
                else {
                    decisionObj[memInd].index.push(position[pos]);
                    decisionObj[memInd].indexObject[position[pos]] = position[pos];
                }
            }
            let diff = slicedHeaders.length - hierarchy.length;
            while (diff > 0) {
                hierarchy.push({ members: [] });
                diff--;
            }
            for (let iln = 0, ilt = hierarchy.length; iln < ilt; iln++) {
                if (slicedHeaders[iln].members.length > 0) {
                    let level = null;
                    if (slicedHeaders[iln].valueSort && slicedHeaders[iln].valueSort.levelName) {
                        level = slicedHeaders[iln].valueSort.levelName;
                    }
                    parentMember = (level || slicedHeaders[iln].formattedText);
                    /* tslint:disable:align */
                    hierarchy[iln].members =
                        this.insertPosition(keys, data, keyInd + 1, slicedHeaders[iln].index, axis, parentMember, slicedHeaders[iln].members);
                    /* tslint:enable:align */
                }
            }
            return hierarchy;
        }
        else {
            return hierarchy;
        }
    }
    insertTotalPosition(headers) {
        let summCell = headers[headers.length - 1];
        if (summCell && summCell.type === 'grand sum') {
            summCell.index = this.filterMembers;
            /* tslint:disable:typedef */
            for (let ln = 0, lt = this.filterMembers.length; ln < lt; ln++) {
                summCell.indexObject[this.filterMembers[ln]] = this.filterMembers[ln];
            }
            /* tslint:enable:typedef */
        }
        return headers;
    }
    calculatePagingValues() {
        if (this.pageSettings) {
            if (this.valueAxis === 1) {
                this.rowValuesLength = this.values.length;
            }
            else {
                this.colValuesLength = this.values.length;
            }
            this.memberCnt = -this.rowValuesLength;
            this.rowStartPos = ((this.pageSettings.rowCurrentPage * this.pageSettings.rowSize) -
                (this.pageSettings.rowSize)) * this.rowValuesLength;
            let exactStartPos = (this.rowStartPos + (this.pageSettings.rowSize * 3 * this.rowValuesLength)) > this.rowCount ?
                (this.rowCount - (this.pageSettings.rowSize * 3 * this.rowValuesLength)) : this.rowStartPos;
            if (exactStartPos < 0) {
                exactStartPos = this.rowStartPos = 0;
                this.pageSettings.rowCurrentPage = 1;
            }
            this.rowFirstLvl = (this.rowStartPos - exactStartPos) % this.pageSettings.rowSize;
            this.rowStartPos = exactStartPos;
            this.endPos = this.rowStartPos + (this.pageSettings.rowSize * 3 * this.rowValuesLength);
            this.endPos = this.endPos > this.rowCount ? this.rowCount : this.endPos;
            this.rMembers = this.performSlicing(this.rMembers, [], this.rowStartPos, 'row');
            this.memberCnt = -this.colValuesLength;
            this.pageInLimit = false;
            this.colHdrBufferCalculated = false;
            this.colStartPos = ((this.pageSettings.columnCurrentPage * this.pageSettings.columnSize) -
                (this.pageSettings.columnSize)) * this.colValuesLength;
            exactStartPos = (this.colStartPos + (this.pageSettings.columnSize * 3 * this.colValuesLength)) >
                this.columnCount ?
                (this.columnCount - (this.pageSettings.columnSize * 3 * this.colValuesLength)) : this.colStartPos;
            if (exactStartPos < 0) {
                exactStartPos = this.colStartPos = 0;
                this.pageSettings.columnCurrentPage = 1;
            }
            this.colFirstLvl = (this.colStartPos - exactStartPos) % this.pageSettings.columnSize;
            this.colStartPos = exactStartPos;
            this.endPos = this.colStartPos + (this.pageSettings.columnSize * 3 * this.colValuesLength);
            this.endPos = this.endPos > this.columnCount ? this.columnCount : this.endPos;
            this.cMembers = this.performSlicing(this.cMembers, [], this.colStartPos, 'column');
            this.memberCnt = -1;
            this.pageInLimit = false;
        }
    }
    performSlicing(headers, slicedHeaders, startPos, axis) {
        let pos = 0;
        while (headers[pos]) {
            this.memberCnt += axis === 'column' ? this.colValuesLength : this.rowValuesLength;
            if (startPos <= this.memberCnt && this.endPos >= this.memberCnt && !this.pageInLimit) {
                if (axis === 'column') {
                    this.colFirstLvl = this.colFirstLvl + headers[pos].level;
                }
                else {
                    this.rowFirstLvl = this.rowFirstLvl + headers[pos].level;
                }
                this.pageInLimit = true;
            }
            if (this.pageInLimit) {
                if (this.endPos <= this.memberCnt) {
                    if (axis === 'column') {
                        if (headers[pos].members.length === 0) {
                            if (this.colHdrBufferCalculated) {
                                break;
                            }
                            this.colHdrBufferCalculated = true;
                            this.endPos += (headers[pos].level * this.colValuesLength);
                        }
                        else if (this.colHdrBufferCalculated) {
                            break;
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            slicedHeaders.push(headers[pos].members.length > 0 ? this.removeChildMembers(headers[pos]) : headers[pos]);
            if (headers[pos].members.length > 0) {
                if (axis === 'column') {
                    this.memberCnt -= !(this.showSubTotals && this.showColumnSubTotals &&
                        this.columnKeys[headers[pos].valueSort.axis].showSubTotals) ? this.colValuesLength : 0;
                }
                slicedHeaders[slicedHeaders.length - 1].members =
                    this.performSlicing(headers[pos].members, [], startPos, axis);
            }
            if (!this.pageInLimit) {
                slicedHeaders.pop();
            }
            if (headers[pos].level === 0 && this.pageInLimit && this.endPos <= this.memberCnt) {
                break;
            }
            pos++;
        }
        return slicedHeaders;
    }
    removeChildMembers(member) {
        let keys = Object.keys(member);
        let keyPos = 0;
        let framedMember = {};
        while (keyPos < keys.length) {
            framedMember[keys[keyPos]] = member[keys[keyPos]];
            if (keys[keyPos] === 'members') {
                framedMember['members'] = [];
            }
            keyPos++;
        }
        return framedMember;
    }
    insertAllMember(set, filter, customText, axis) {
        let len = set.length;
        customText = ' Total';
        set[len] = {
            hasChild: false,
            index: filter,
            level: 0,
            axis: axis,
            isDrilled: false,
            indexObject: {},
            members: [],
            formattedText: 'Grand' + customText,
            ordinal: len,
            type: 'grand sum',
            valueSort: {}
        };
        set[len].valueSort[set[len].formattedText] = 1;
        set[len].valueSort.levelName = set[len].formattedText;
        for (let ln = 0, lt = filter.length; ln < lt; ln++) {
            set[len].indexObject[filter[ln]] = filter[ln];
        }
        if (axis === 'row') {
            this.rowCount += this.rowValuesLength;
        }
        else {
            this.columnCount += this.colValuesLength;
        }
    }
    /* tslint:disable-next-line:max-line-length */
    getTableData(rows, reformAxis, columns, tnum, data, vlt, rTotal, cTotal) {
        for (let rlt = rows.length, rln = 0; rln < rlt; rln++) {
            tnum = data.length;
            reformAxis[tnum] = rows[rln];
            let actCnt = tnum - Number(Object.keys(reformAxis)[0]);
            //let rplus: number = rln + 1;
            //let lvl: number = rows[rln].level;
            let isLeastNode = !reformAxis[tnum].members.length;
            rows[rln].colIndex = 0;
            rows[rln].rowIndex = tnum;
            if (!data[tnum]) {
                data[tnum] = [];
                this.valueContent[actCnt] = {};
                //data[tnum][0] = rows[rln].name;
                data[tnum][0] = this.valueContent[actCnt][0] = this.frameHeaderWithKeys(rows[rln]);
            }
            else {
                // data[tnum][0] = rows[rln].name;
                data[tnum][0] = this.valueContent[actCnt][0] = this.frameHeaderWithKeys(rows[rln]);
            }
            if (this.valueAxis && (this.isMutiMeasures || this.alwaysShowValueHeader) && !(rows[rln].hasChild &&
                ((!isNullOrUndefined(rows[rln].showSubTotals) && !rows[rln].showSubTotals) ||
                    !this.showSubTotals || !this.showRowSubTotals))) {
                let hpos = tnum;
                let actpos = actCnt;
                for (let vln = 0; vln < vlt; vln++) {
                    tnum++;
                    actCnt++;
                    let name = this.values[vln].caption ? this.values[vln].caption : this.values[vln].name;
                    let calObj = {
                        axis: 'row',
                        actualText: this.values[vln].name,
                        formattedText: name,
                        level: 0,
                        valueSort: {},
                        colIndex: 0,
                        rowIndex: tnum,
                        type: 'value'
                    };
                    if (!data[tnum]) {
                        data[tnum] = [];
                        this.valueContent[actCnt] = {};
                        data[tnum][0] = this.valueContent[actCnt][0] = calObj;
                    }
                    let vData = data[tnum][0].valueSort;
                    vData[data[tnum - vln - 1][0].valueSort.levelName + this.valueSortSettings.headerDelimiter + name] = 1;
                    vData.levelName = data[tnum - vln - 1][0].valueSort.levelName + this.valueSortSettings.headerDelimiter
                        + name;
                    for (let cln = 0, dln = 1, clt = columns.length; cln < clt; ++cln) {
                        //for (let vln: number = 0; (!this.valueAxis && vln < vlt); vln++) {
                        this.updateRowData(rows, columns, tnum, data, vln, rln, cln, dln, actCnt, rTotal, cTotal);
                        dln = data[tnum].length;
                        data[hpos][dln - 1] = this.valueContent[actpos][dln - 1] = {
                            axis: 'value', actualText: '', colSpan: 1,
                            colIndex: dln, formattedText: '', hasChild: false
                        };
                        // }
                    }
                }
                this.recursiveRowData(rows, reformAxis, columns, tnum, data, vlt, isLeastNode, rln, vlt, rTotal, cTotal);
            }
            else {
                for (let cln = 0, dln = 1, clt = columns.length; cln < clt; ++cln) {
                    for (let vln = 0; vln < vlt; vln++) {
                        this.updateRowData(rows, columns, tnum, data, vln, rln, cln, dln, actCnt, rTotal, cTotal);
                        dln = data[tnum].length;
                    }
                }
                this.recursiveRowData(rows, reformAxis, columns, tnum, data, vlt, isLeastNode, rln, 0, rTotal, cTotal);
            }
        }
        /* for (let rlt: number = rows.length, rln: number = 0; rln < rlt; rln++) {
            if (!data[rln]) {
                data[rln] = [];
                data[rln][0] = rows[rln].name;
            } else {
                data[rln][0] = rows[rln].name;
            }
            for (let cln: number = 0, dln: number = 1, clt: number = columns.length; cln < clt; dln = ++cln) {
                data[rln][dln] = this.getAggregateValue(rows[rln].index, columns[cln].index, 11);
            }
        } */
    }
    /* tslint:disable-next-line:max-line-length */
    getAggregatedHeaders(rows, columns, rMembers, cMembers, values) {
        this.selectedHeaders = { selectedHeader: [], values: [] };
        for (let vlt = values.length, vln = 0; vln < vlt; vln++) {
            switch (values[vln].type) {
                case 'DifferenceFrom':
                case 'PercentageOfDifferenceFrom':
                    {
                        let baseField;
                        let baseItem;
                        this.selectedHeaders.values.push(values[vln].name);
                        if (values[vln].baseField && values[vln].baseItem) {
                            baseField = values[vln].baseField;
                            baseItem = values[vln].baseItem;
                        }
                        else if (this.valueAxis && (this.isMutiMeasures || this.alwaysShowValueHeader) && columns.length > 0) {
                            baseField = columns[0].name;
                            baseItem = Object.keys(this.fieldList[columns[0].name].members)[0];
                        }
                        else if (rows.length > 0) {
                            baseField = rows[0].name;
                            baseItem = Object.keys(this.fieldList[rows[0].name].members)[0];
                        }
                        let isHeaderSelected = false;
                        for (let row of rows) {
                            if (row.name === baseField) {
                                /* tslint:disable-next-line:max-line-length */
                                this.getAggregatedHeaderData(rMembers, values[vln].name, baseItem, false, 'row', values[vln].type, this.selectedHeaders.selectedHeader, vln);
                                isHeaderSelected = true;
                                break;
                            }
                        }
                        if (!isHeaderSelected) {
                            for (let column of columns) {
                                if (column.name === baseField) {
                                    /* tslint:disable-next-line:max-line-length */
                                    this.getAggregatedHeaderData(cMembers, values[vln].name, baseItem, false, 'column', values[vln].type, this.selectedHeaders.selectedHeader, vln);
                                    break;
                                }
                            }
                        }
                    }
                    break;
                case 'PercentageOfParentRowTotal':
                case 'PercentageOfParentColumnTotal':
                    {
                        this.selectedHeaders.values.push(values[vln].name);
                        /* tslint:disable-next-line:max-line-length */
                        this.getAggregatedHeaderData((values[vln].type === 'PercentageOfParentRowTotal' ? rMembers : cMembers), values[vln].name, undefined, false, (values[vln].type === 'PercentageOfParentRowTotal' ? 'row' : 'column'), values[vln].type, this.selectedHeaders.selectedHeader, vln);
                    }
                    break;
                case 'RunningTotals':
                    {
                        this.selectedHeaders.values.push(values[vln].name);
                        /* tslint:disable-next-line:max-line-length */
                        this.getAggregatedHeaderData((this.valueAxis && (this.isMutiMeasures || this.alwaysShowValueHeader) ? cMembers : rMembers), values[vln].name, undefined, false, (this.valueAxis && (this.isMutiMeasures || this.alwaysShowValueHeader) ? 'column' : 'row'), values[vln].type, this.selectedHeaders.selectedHeader, vln);
                    }
                    break;
                case 'PercentageOfParentTotal':
                    {
                        let baseField;
                        this.selectedHeaders.values.push(values[vln].name);
                        if (values[vln].baseField) {
                            baseField = values[vln].baseField;
                        }
                        else if (this.valueAxis && (this.isMutiMeasures || this.alwaysShowValueHeader) && columns.length > 0) {
                            baseField = columns[0].name;
                        }
                        else if (rows.length > 0) {
                            baseField = rows[0].name;
                        }
                        let isHeaderSelected = false;
                        for (let len = rows.length, i = 0; i < len; i++) {
                            if (rows[i].name === baseField) {
                                /* tslint:disable-next-line:max-line-length */
                                this.getAggregatedHeaderData(rMembers, values[vln].name, undefined, false, 'row', values[vln].type, this.selectedHeaders.selectedHeader, vln, i);
                                isHeaderSelected = true;
                                break;
                            }
                        }
                        if (!isHeaderSelected) {
                            for (let len = columns.length, i = 0; i < len; i++) {
                                if (columns[i].name === baseField) {
                                    /* tslint:disable-next-line:max-line-length */
                                    this.getAggregatedHeaderData(cMembers, values[vln].name, undefined, false, 'column', values[vln].type, this.selectedHeaders.selectedHeader, vln, i);
                                    break;
                                }
                            }
                        }
                    }
                    break;
            }
        }
    }
    /* tslint:disable-next-line:max-line-length */
    getAggregatedHeaderData(headers, name, baseItem, isChildren, type, aggregateType, selectedHeaders, vln, level) {
        for (let rln of headers) {
            switch (aggregateType) {
                case 'DifferenceFrom':
                case 'PercentageOfDifferenceFrom':
                    {
                        let levelName = rln.valueSort.levelName.toString().split('.');
                        if (levelName.indexOf(baseItem) !== -1) {
                            /* tslint:disable-next-line:max-line-length */
                            selectedHeaders.push(this.updateSelectedHeaders(baseItem, rln.level, type, isChildren, name, aggregateType, rln.valueSort.levelName, (isChildren ? [rln] : headers), vln + 1));
                            if (rln.members.length > 0) {
                                /* tslint:disable-next-line:max-line-length */
                                this.getAggregatedHeaderData(rln.members, name, baseItem, true, type, aggregateType, selectedHeaders[selectedHeaders.length - 1].childMembers, vln);
                            }
                        }
                        else if (rln.members.length > 0) {
                            this.getAggregatedHeaderData(rln.members, name, baseItem, false, type, aggregateType, selectedHeaders, vln);
                        }
                    }
                    break;
                case 'RunningTotals':
                case 'PercentageOfParentRowTotal':
                case 'PercentageOfParentColumnTotal':
                    {
                        if (rln.type === 'grand sum') {
                            /* tslint:disable-next-line:max-line-length */
                            selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, headers, vln + 1));
                        }
                        else {
                            if (rln.members.length > 0) {
                                /* tslint:disable-next-line:max-line-length */
                                selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, rln.members, vln + 1));
                                /* tslint:disable-next-line:max-line-length */
                                this.getAggregatedHeaderData(rln.members, name, undefined, false, type, aggregateType, selectedHeaders, vln);
                            }
                        }
                    }
                    break;
                case 'PercentageOfParentTotal':
                    {
                        if (rln.type !== 'grand sum') {
                            if (rln.level === level) {
                                if (rln.members.length > 0) {
                                    if (isChildren) {
                                        let aggregateHeaders = selectedHeaders[selectedHeaders.length - 1].aggregateHeaders;
                                        for (let member of rln.members) {
                                            aggregateHeaders.push(member);
                                        }
                                    }
                                    else {
                                        let children = extend([], rln.members, null, true);
                                        /* tslint:disable-next-line:max-line-length */
                                        selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, children, vln + 1));
                                        let aggregateHeaders = selectedHeaders[selectedHeaders.length - 1].aggregateHeaders;
                                        aggregateHeaders.push(rln);
                                    }
                                    /* tslint:disable-next-line:max-line-length */
                                    this.getAggregatedHeaderData(rln.members, name, undefined, true, type, aggregateType, selectedHeaders, vln, level + 1);
                                }
                                else {
                                    if (!isChildren) {
                                        /* tslint:disable-next-line:max-line-length */
                                        selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, [rln], vln + 1));
                                    }
                                }
                            }
                            else if (rln.members.length > 0) {
                                /* tslint:disable-next-line:max-line-length */
                                this.getAggregatedHeaderData(rln.members, name, undefined, false, type, aggregateType, selectedHeaders, vln, level);
                            }
                        }
                    }
                    break;
            }
        }
    }
    /* tslint:disable-next-line:max-line-length */
    updateSelectedHeaders(baseItem, level, type, isChildren, name, aggregateType, levelName, headers, vCount) {
        let headerData = {
            name: baseItem,
            level: level,
            axis: type,
            isChild: isChildren,
            value: name,
            type: aggregateType,
            uniqueName: levelName,
            aggregateHeaders: headers,
            childMembers: [],
            valueCount: vCount
        };
        return headerData;
    }
    applyAdvancedAggregate(rowheads, colheads, data) {
        this.aggregatedValueMatrix = [];
        if (this.selectedHeaders.values.length > 0) {
            let pivotIndex = {};
            let colIndex = [];
            let isIndexFilled = false;
            for (let rlt = data.length, rln = 0; rln < rlt; rln++) {
                if (data[rln] !== undefined && data[rln][0] !== undefined) {
                    if (!isIndexFilled) {
                        for (let clt = data[rln].length, cln = 0; cln < clt; cln++) {
                            if (data[rln][cln].axis === 'value' &&
                                this.selectedHeaders.values.indexOf(data[rln][cln].actualText) !== -1) {
                                colIndex.push(cln);
                                isIndexFilled = true;
                            }
                        }
                    }
                    if (colIndex.length > 0 && data[rln][colIndex[0]].axis === 'value' &&
                        this.selectedHeaders.values.indexOf(data[rln][colIndex[0]].actualText) !== -1) {
                        for (let index of colIndex) {
                            pivotIndex[rln + ',' + index] = [rln, index];
                        }
                    }
                }
            }
            this.updateAggregates(rowheads, colheads, data, this.selectedHeaders.selectedHeader, colIndex, pivotIndex);
            let indexCollection = Object.keys(pivotIndex);
            for (let index of indexCollection) {
                let currentSet = data[pivotIndex[index][0]][pivotIndex[index][1]];
                // currentSet.formattedText = '0';
                currentSet.formattedText = (this.selectedHeaders.selectedHeader.length > 0 ? this.emptyCellTextContent : '#N/A');
                if (!this.aggregatedValueMatrix[pivotIndex[index][0]]) {
                    this.aggregatedValueMatrix[pivotIndex[index][0]] = [];
                }
                this.aggregatedValueMatrix[pivotIndex[index][0]][pivotIndex[index][1]] = 0;
            }
        }
        else {
            return;
        }
    }
    /* tslint:disable:all */
    updateAggregates(rowheads, colheads, data, selectedHeaders, colIndex, pivotIndex) {
        for (let headers of selectedHeaders) {
            let selectedHeaderCollection = headers.aggregateHeaders;
            let name = headers.value;
            let valueCount = (this.valueAxis && (this.isMutiMeasures || this.alwaysShowValueHeader) ? headers.valueCount : 0);
            let aggregateType = headers.type;
            let uniqueName = headers.uniqueName;
            let axis = headers.axis;
            let isRowBaseField = axis === 'row' ? true : false;
            let activeValues;
            let indexCollection = [];
            let activeColumn = [];
            let columnHeaders = [];
            let rowindexCollection = [];
            let selectedRowValues = [];
            let selectedColumnValues = [];
            if ((['DifferenceFrom', 'PercentageOfDifferenceFrom', 'PercentageOfParentRowTotal', 'PercentageOfParentColumnTotal', 'PercentageOfParentTotal', 'RunningTotals']).indexOf(headers.type) !== -1) {
                if (isRowBaseField) {
                    if (headers.type !== 'RunningTotals') {
                        for (let rlt = rowheads.length, rln = 0; rln < rlt; rln++) {
                            if (rowheads[rln] !== undefined) {
                                if (rowheads[rln].valueSort[uniqueName]) {
                                    activeValues = rowheads[rln];
                                    selectedRowValues = data[rln + valueCount];
                                    break;
                                }
                            }
                        }
                    }
                }
                else {
                    for (let len = data.length, i = 0; i < len; i++) {
                        if (data[i] !== undefined && data[i][0] === undefined) {
                            columnHeaders.push(data[i]);
                        }
                        else {
                            break;
                        }
                    }
                    let len = columnHeaders.length;
                    while (len--) {
                        let axisObj = columnHeaders[len][colIndex[0]];
                        let cLevelName = axisObj.actualText;
                        if (this.selectedHeaders.values.indexOf(cLevelName) === -1) {
                            activeColumn = columnHeaders[len];
                            len = 0;
                        }
                    }
                    if (headers.type !== 'RunningTotals') {
                        for (let clt = activeColumn.length, cln = 0; cln < clt; cln++) {
                            let isSelectedColumn = false;
                            if (activeColumn[cln] !== undefined && activeColumn[cln].valueSort[uniqueName]) {
                                activeValues = activeColumn[cln];
                                for (let len = data.length, i = 0; i < len; i++) {
                                    let axisObj = data[i];
                                    if (axisObj !== undefined && axisObj[0] !== undefined &&
                                        axisObj[cln].axis === 'value' &&
                                        this.selectedHeaders.values.indexOf(axisObj[cln].actualText) !== -1) {
                                        isSelectedColumn = true;
                                        selectedColumnValues[i] = axisObj[cln];
                                        rowindexCollection.push(i);
                                    }
                                }
                                if (isSelectedColumn) {
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            switch (headers.type) {
                case 'DifferenceFrom':
                case 'PercentageOfDifferenceFrom':
                    {
                        let isChildren = headers.isChild;
                        if (isRowBaseField) {
                            if (!isChildren) {
                                for (let item of selectedHeaderCollection) {
                                    for (let rlt = rowheads.length, rln = 0; rln < rlt; rln++) {
                                        if (rowheads[rln] !== undefined) {
                                            if (rowheads[rln].valueSort[item.valueSort.levelName] &&
                                                rowheads[rln].level === activeValues.level && rowheads[rln].type !== 'grand sum') {
                                                for (let index of colIndex) {
                                                    let currentSet = data[rln + valueCount][index];
                                                    if (currentSet.axis === 'value' && currentSet.actualText === name) {
                                                        indexCollection.push([rln + valueCount, index]);
                                                        if (pivotIndex[rln + valueCount + ',' + index]) {
                                                            delete pivotIndex[rln + valueCount + ',' + index];
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                let uniqueLevelName = uniqueName.split('.');
                                for (let rlt = rowheads.length, rlen = 0; rlen < rlt; rlen++) {
                                    if (rowheads[rlen] !== undefined) {
                                        let levelName = rowheads[rlen].valueSort.levelName.toString().split('.');
                                        if (levelName.indexOf(uniqueLevelName[uniqueLevelName.length - 1]) !== -1 &&
                                            rowheads[rlen].level === activeValues.level) {
                                            for (let index of colIndex) {
                                                let currentSet = data[rlen + valueCount][index];
                                                if (currentSet.axis === 'value' && currentSet.actualText === name) {
                                                    indexCollection.push([rlen + valueCount, index]);
                                                    if (pivotIndex[rlen + valueCount + ',' + index]) {
                                                        delete pivotIndex[rlen + valueCount + ',' + index];
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            for (let index of indexCollection) {
                                let currentSet = data[index[0]][index[1]];
                                let cVal = currentSet.value - selectedRowValues[index[1]].value;
                                cVal = isNaN(cVal) ? 0 : cVal;
                                if (!this.aggregatedValueMatrix[index[0]]) {
                                    this.aggregatedValueMatrix[index[0]] = [];
                                }
                                if (aggregateType === 'DifferenceFrom') {
                                    this.aggregatedValueMatrix[index[0]][index[1]] = cVal;
                                    currentSet.formattedText = cVal === 0 ? this.emptyCellTextContent : this.getFormattedValue(cVal, name).formattedText;
                                }
                                else {
                                    cVal = (selectedRowValues[index[1]].value === 0 ?
                                        0 : (cVal / selectedRowValues[index[1]].value));
                                    this.aggregatedValueMatrix[index[0]][index[1]] = cVal;
                                    currentSet.formattedText = (cVal !== 0 ? this.globalize.formatNumber(cVal, { format: 'P', maximumFractionDigits: 2 }) : this.emptyCellTextContent);
                                }
                            }
                        }
                        else {
                            if (!isChildren) {
                                for (let item of selectedHeaderCollection) {
                                    for (let clt = activeColumn.length, cln = 0; cln < clt; cln++) {
                                        let isSelectedColumn = false;
                                        if (activeColumn[cln] !== undefined &&
                                            activeColumn[cln].valueSort[item.valueSort.levelName] &&
                                            activeColumn[cln].level === activeValues.level && activeColumn[cln].type !== 'grand sum') {
                                            for (let index of rowindexCollection) {
                                                let currentSet = data[index][cln];
                                                if (currentSet.axis === 'value' && currentSet.actualText === name) {
                                                    isSelectedColumn = true;
                                                    indexCollection.push([index, cln]);
                                                    if (pivotIndex[index + ',' + cln]) {
                                                        delete pivotIndex[index + ',' + cln];
                                                    }
                                                }
                                            }
                                            if (isSelectedColumn) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                let uniqueLevelName = uniqueName.split('.');
                                for (let clt = activeColumn.length, clen = 0; clen < clt; clen++) {
                                    let isSelectedColumn = false;
                                    if (activeColumn[clen] !== undefined) {
                                        let levelName = activeColumn[clen].valueSort.levelName.toString().split('.');
                                        if (levelName.indexOf(uniqueLevelName[uniqueLevelName.length - 1]) !== -1 &&
                                            activeColumn[clen].level === activeValues.level) {
                                            for (let index of rowindexCollection) {
                                                let currentSet = data[index][clen];
                                                if (currentSet.axis === 'value' && currentSet.actualText === name) {
                                                    isSelectedColumn = true;
                                                    indexCollection.push([index, clen]);
                                                    if (pivotIndex[index + ',' + clen]) {
                                                        delete pivotIndex[index + ',' + clen];
                                                    }
                                                }
                                            }
                                            if (isSelectedColumn) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            for (let index of indexCollection) {
                                let currentSet = data[index[0]][index[1]];
                                let cVal = currentSet.value - selectedColumnValues[index[0]].value;
                                cVal = isNaN(cVal) ? 0 : cVal;
                                if (!this.aggregatedValueMatrix[index[0]]) {
                                    this.aggregatedValueMatrix[index[0]] = [];
                                }
                                if (aggregateType === 'DifferenceFrom') {
                                    currentSet.formattedText = cVal === 0 ? this.emptyCellTextContent : this.getFormattedValue(cVal, name).formattedText;
                                    this.aggregatedValueMatrix[index[0]][index[1]] = cVal;
                                }
                                else {
                                    cVal = (selectedColumnValues[index[0]].value === 0 ?
                                        0 : (cVal / selectedColumnValues[index[0]].value));
                                    currentSet.formattedText = (cVal !== 0 ? this.globalize.formatNumber(cVal, { format: 'P', maximumFractionDigits: 2 }) : this.emptyCellTextContent);
                                    this.aggregatedValueMatrix[index[0]][index[1]] = cVal;
                                }
                            }
                        }
                        if (headers.childMembers.length > 0) {
                            this.updateAggregates(rowheads, colheads, data, headers.childMembers, colIndex, pivotIndex);
                        }
                    }
                    break;
                case 'PercentageOfParentRowTotal':
                case 'PercentageOfParentColumnTotal':
                case 'PercentageOfParentTotal':
                    {
                        if (isRowBaseField) {
                            for (let item of selectedHeaderCollection) {
                                for (let rlt = rowheads.length, i = 0; i < rlt; i++) {
                                    if (rowheads[i] !== undefined) {
                                        if (rowheads[i].valueSort[item.valueSort.levelName] &&
                                            rowheads[i].level === item.level) {
                                            for (let index of colIndex) {
                                                let currentSet = data[i + valueCount][index];
                                                if (currentSet.axis === 'value' && currentSet.actualText === name) {
                                                    indexCollection.push([i + valueCount, index]);
                                                    if (pivotIndex[i + valueCount + ',' + index]) {
                                                        delete pivotIndex[i + valueCount + ',' + index];
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            for (let i of indexCollection) {
                                let currentSet = data[i[0]][i[1]];
                                let cVal = currentSet.value / selectedRowValues[i[1]].value;
                                cVal = isNaN(cVal) ? 0 : cVal;
                                currentSet.formattedText = (cVal !== 0 ? this.globalize.formatNumber(cVal, { format: 'P', maximumFractionDigits: 2 }) : this.emptyCellTextContent);
                                if (!this.aggregatedValueMatrix[i[0]]) {
                                    this.aggregatedValueMatrix[i[0]] = [];
                                }
                                this.aggregatedValueMatrix[i[0]][i[1]] = cVal;
                            }
                        }
                        else {
                            for (let item of selectedHeaderCollection) {
                                for (let clt = activeColumn.length, j = 0; j < clt; j++) {
                                    let isSelectedColumn = false;
                                    if (activeColumn[j] !== undefined &&
                                        activeColumn[j].valueSort[item.valueSort.levelName]) {
                                        for (let index of rowindexCollection) {
                                            let currentSet = data[index][j];
                                            if (currentSet.axis === 'value' && currentSet.actualText === name) {
                                                isSelectedColumn = true;
                                                indexCollection.push([index, j]);
                                                if (pivotIndex[index + ',' + j]) {
                                                    delete pivotIndex[index + ',' + j];
                                                }
                                            }
                                        }
                                        if (isSelectedColumn) {
                                            break;
                                        }
                                    }
                                }
                            }
                            for (let i of indexCollection) {
                                let currentSet = data[i[0]][i[1]];
                                let val = currentSet.value / selectedColumnValues[i[0]].value;
                                val = isNaN(val) ? 0 : val;
                                currentSet.formattedText = (val !== 0 ? this.globalize.formatNumber(val, { format: 'P', maximumFractionDigits: 2 }) : this.emptyCellTextContent);
                                if (!this.aggregatedValueMatrix[i[0]]) {
                                    this.aggregatedValueMatrix[i[0]] = [];
                                }
                                this.aggregatedValueMatrix[i[0]][i[1]] = val;
                            }
                        }
                    }
                    break;
                case 'RunningTotals':
                    {
                        if (isRowBaseField) {
                            for (let index of colIndex) {
                                let cVal = 0;
                                for (let item of selectedHeaderCollection) {
                                    for (let rlt = rowheads.length, rlen = 0; rlen < rlt; rlen++) {
                                        if (rowheads[rlen] !== undefined) {
                                            let currentSet = data[rlen + valueCount][index];
                                            if (rowheads[rlen] !== undefined && rowheads[rlen].valueSort[item.valueSort.levelName] &&
                                                rowheads[rlen].level === item.level && currentSet.axis === 'value' &&
                                                currentSet.actualText === name) {
                                                if (rowheads[rlen].type !== 'grand sum') {
                                                    cVal += currentSet.value;
                                                    currentSet.formattedText = this.getFormattedValue(cVal, name).formattedText;
                                                    if (!this.aggregatedValueMatrix[rlen + valueCount]) {
                                                        this.aggregatedValueMatrix[rlen + valueCount] = [];
                                                    }
                                                    this.aggregatedValueMatrix[rlen + valueCount][index] = cVal;
                                                }
                                                if (pivotIndex[rlen + valueCount + ',' + index]) {
                                                    delete pivotIndex[rlen + valueCount + ',' + index];
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            for (let rlt = rowheads.length, rln = 0; rln < rlt; rln++) {
                                if (rowheads[rln] !== undefined) {
                                    let cVal = 0;
                                    for (let item of selectedHeaderCollection) {
                                        for (let clt = activeColumn.length, cln = 0; cln < clt; cln++) {
                                            let currentSet = data[rln + valueCount][cln];
                                            if (activeColumn[cln] !== undefined &&
                                                activeColumn[cln].valueSort[item.valueSort.levelName] &&
                                                currentSet.axis === 'value' && currentSet.actualText === name) {
                                                if (activeColumn[cln].type !== 'grand sum') {
                                                    cVal += currentSet.value;
                                                    currentSet.formattedText = this.getFormattedValue(cVal, name).formattedText;
                                                    if (!this.aggregatedValueMatrix[rln + valueCount]) {
                                                        this.aggregatedValueMatrix[rln + valueCount] = [];
                                                    }
                                                    this.aggregatedValueMatrix[rln + valueCount][cln] = cVal;
                                                }
                                                if (pivotIndex[rln + valueCount + ',' + cln]) {
                                                    delete pivotIndex[rln + valueCount + ',' + cln];
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    break;
            }
        }
    }
    /* tslint:enable:all */
    recursiveRowData(rows, reformAxis, columns, tnum, data, vlt, isLeastNode, rln, vln, rTotal, cTotal) {
        if (!isLeastNode) {
            this.getTableData(reformAxis[tnum - vln].members, reformAxis, columns, tnum, data, vlt, rTotal, cTotal);
        }
        if (!this.pageSettings) {
            reformAxis[tnum - vln].members = [];
        }
    }
    updateRowData(rows, columns, tnum, data, vln, rln, cln, dln, actCnt, rTotal, cTotal) {
        let mPos = this.fieldList[this.values[vln].name].index;
        let aggregate = this.fieldList[this.values[vln].name].aggregateType;
        let field = this.values[vln].name;
        let gTotalIndex = [];
        let totalValues = {};
        let value = 0;
        // let isLeast: boolean = isLeastNode && (vln === vlt - 1);
        switch (aggregate) {
            case 'Index':
                {
                    gTotalIndex = [[rows[rln], columns[cln]], [rows[rln], cTotal], [rTotal, columns[cln]], [rTotal, cTotal]];
                    let valueContent = ['cVal', 'rTotalVal', 'cTotalVal', 'gTotalVal'];
                    let i = 0;
                    for (let rIndex of gTotalIndex) {
                        totalValues[valueContent[i]] = this.getAggregateValue((rIndex[0]).index, (rIndex[1]).indexObject, mPos, aggregate);
                        i++;
                    }
                    let val = ((totalValues.cVal) * (totalValues.gTotalVal)) / ((totalValues.rTotalVal) * (totalValues.cTotalVal));
                    value = (rows[rln].members.length > 0 && ((!isNullOrUndefined(rows[rln].showSubTotals) && !rows[rln].showSubTotals) ||
                        !this.showRowSubTotals || !this.showSubTotals)) ? undefined :
                        (isNullOrUndefined(totalValues.cVal) ? totalValues.cVal : (isNaN(val) ? 0 : val));
                }
                break;
            case 'PercentageOfGrandTotal':
            case 'PercentageOfColumnTotal':
            case 'PercentageOfRowTotal':
                {
                    gTotalIndex = [[rows[rln], columns[cln]]];
                    gTotalIndex.push((aggregate === 'PercentageOfGrandTotal' ?
                        [rTotal, cTotal] : (aggregate === 'PercentageOfColumnTotal' ? [rTotal, columns[cln]] : [rows[rln], cTotal])));
                    let valueContent = ['cVal', 'gTotalVal'];
                    let i = 0;
                    for (let rIndex of gTotalIndex) {
                        totalValues[valueContent[i]] = this.getAggregateValue((rIndex[0]).index, (rIndex[1]).indexObject, mPos, aggregate);
                        i++;
                    }
                    let val = ((totalValues.cVal) / (totalValues.gTotalVal));
                    value = (rows[rln].members.length > 0 && ((!isNullOrUndefined(rows[rln].showSubTotals) && !rows[rln].showSubTotals) ||
                        !this.showSubTotals || !this.showRowSubTotals)) ? undefined :
                        (isNullOrUndefined(totalValues.cVal) ? totalValues.cVal : (isNaN(val) ? 0 : val));
                }
                break;
            default:
                value = (rows[rln].members.length > 0 && ((!isNullOrUndefined(rows[rln].showSubTotals) && !rows[rln].showSubTotals) ||
                    !this.showSubTotals || !this.showRowSubTotals)) ? undefined :
                    this.getAggregateValue(rows[rln].index, columns[cln].indexObject, mPos, aggregate);
                break;
        }
        let cellDetails = {
            fieldName: this.values[vln].name,
            row: rows[rln],
            column: columns[cln],
            value: value,
            cellSets: this.getCellSet(this.rawIndexObject),
            /* tslint:disable-next-line:max-line-length */
            rowCellType: (rows[rln].hasChild && rows[rln].isDrilled ? 'subTotal' : rows[rln].type === 'grand sum' ? 'grandTotal' : 'value'),
            /* tslint:disable-next-line:max-line-length */
            columnCellType: (columns[cln].hasChild && columns[cln].isDrilled ? 'subTotal' : columns[cln].type === 'grand sum' ? 'grandTotal' : 'value'),
            aggregateType: aggregate,
            skipFormatting: false
        };
        if (this.getValueCellInfo) {
            this.getValueCellInfo(cellDetails);
        }
        value = cellDetails.value;
        let isSum = rows[rln].hasChild || columns[cln].hasChild ||
            rows[rln].type === 'grand sum' || columns[cln].type === 'grand sum';
        let subTotal = (rows[rln].members.length > 0 && ((!isNullOrUndefined(rows[rln].showSubTotals) &&
            !rows[rln].showSubTotals) || !this.showSubTotals || !this.showRowSubTotals));
        let formattedText = subTotal ?
            '' : (value === undefined) ? this.emptyCellTextContent :
            (aggregate === 'Count' || aggregate === 'DistinctCount') ? value.toLocaleString() :
                this.getFormattedValue(value, field).formattedText;
        if (!isNaN(value) && !isNullOrUndefined(value) &&
            (['PercentageOfGrandTotal', 'PercentageOfColumnTotal', 'PercentageOfRowTotal']).indexOf(aggregate) >= 0) {
            formattedText = this.globalize.formatNumber(value, { format: 'P', maximumFractionDigits: 2 });
        }
        else if (!subTotal &&
            isNaN(value) && !isNullOrUndefined(value) &&
            (['PopulationStDev', 'SampleStDev', 'PopulationVar', 'SampleVar']).indexOf(aggregate) !== -1) {
            formattedText = '#DIV/0!';
        }
        //dln = data[tnum].length;
        /* tslint:disable-next-line:max-line-length */
        formattedText = (cellDetails.skipFormatting ? isNullOrUndefined(value) ? this.emptyCellTextContent : value.toString() : formattedText);
        data[tnum][dln] = this.valueContent[actCnt][dln] = {
            axis: 'value', actualText: field, indexObject: this.isDrillThrough ? this.rawIndexObject : {},
            rowHeaders: rows[rln].type === 'grand sum' ? '' : rows[rln].valueSort.levelName,
            columnHeaders: columns[cln].type === 'grand sum' ? '' : columns[cln].valueSort.levelName,
            formattedText: formattedText, value: isNullOrUndefined(value) ? 0 : value, rowIndex: tnum, colIndex: dln, isSum: isSum
        };
        this.rawIndexObject = {};
    }
    getCellSet(rawIndexObject) {
        let currentCellSets = [];
        let keys = Object.keys(rawIndexObject);
        for (let index of keys) {
            if (this.data[parseInt(index, 10)]) {
                currentCellSets.push(this.data[parseInt(index, 10)]);
            }
        }
        return currentCellSets;
    }
    getHeaderData(axis, reformAxis, data, tnum, vcnt) {
        let rlt = axis.length;
        let colItmLn = this.columns.length;
        let sortText = this.valueSortSettings.headerText;
        //let valueLn: number = this.values.length;
        for (let rln = 0; rln < rlt; rln++) {
            if (axis[rln].members.length) {
                this.getHeaderData(axis[rln].members, reformAxis, data, tnum, vcnt);
            }
            let isTotalHide = true;
            if ((!isNullOrUndefined(axis[rln].showSubTotals) && !axis[rln].showSubTotals) ||
                !this.showSubTotals || !this.showColumnSubTotals) {
                if (!(axis[rln].members.length > 0)) {
                    reformAxis[reformAxis.length] = this.frameHeaderWithKeys(axis[rln]);
                }
                else {
                    this.removeCount++;
                    isTotalHide = false;
                }
                tnum = reformAxis.length - 1;
            }
            else {
                tnum = reformAxis.length;
                reformAxis[tnum] = this.frameHeaderWithKeys(axis[rln]);
            }
            //  let rplus: number = rln + 1;
            let lvl = axis[rln].level;
            axis[rln].rowIndex = lvl;
            axis[rln].colIndex = (tnum * vcnt) + vcnt;
            if (!data[lvl]) {
                data[lvl] = [];
                this.headerContent[lvl] = {};
                data[lvl][(tnum * vcnt) + vcnt] = this.headerContent[lvl][(tnum * vcnt) + vcnt] = this.frameHeaderWithKeys(axis[rln]);
            }
            else {
                data[lvl][(tnum * vcnt) + vcnt] = this.headerContent[lvl][(tnum * vcnt) + vcnt] = this.frameHeaderWithKeys(axis[rln]);
            }
            let isSingleMeasure = (this.columns.length === 0 && this.values.length === 1) ? true : false;
            if ((this.isMutiMeasures || this.alwaysShowValueHeader || isSingleMeasure) && !this.valueAxis && isTotalHide) {
                for (let vln = 0; vln < vcnt; vln++) {
                    let name = this.values[vln].caption ? this.values[vln].caption : this.values[vln].name;
                    let calObj = {
                        axis: 'column',
                        actualText: this.values[vln].name,
                        formattedText: name,
                        level: 0,
                        valueSort: {},
                        colIndex: (tnum * vcnt) + 1 + vln,
                        rowIndex: colItmLn
                    };
                    if (!data[colItmLn]) {
                        data[colItmLn] = [];
                        this.headerContent[colItmLn] = {};
                        data[colItmLn][(tnum * vcnt) + 1 + vln] = this.headerContent[colItmLn][(tnum * vcnt) + 1 + vln] = calObj;
                    }
                    else {
                        data[colItmLn][(tnum * vcnt) + 1 + vln] = this.headerContent[colItmLn][(tnum * vcnt) + 1 + vln] = calObj;
                    }
                    let vData = data[colItmLn][(tnum * vcnt) + 1 + vln].valueSort;
                    vData[axis[rln].valueSort.levelName + this.valueSortSettings.headerDelimiter + name] = 1;
                    vData.levelName = axis[rln].valueSort.levelName + this.valueSortSettings.headerDelimiter + name;
                    if (vData && vData[sortText]) {
                        this.valueSortSettings.columnIndex = (tnum * vcnt) + 1 + vln;
                    }
                }
            }
            else if (axis[rln].valueSort && axis[rln].valueSort[sortText]) {
                this.valueSortSettings.columnIndex = (tnum * vcnt) + 1;
            }
            if (!this.pageSettings) {
                reformAxis[tnum].members = [];
            }
        }
    }
    /* tslint:disable */
    getAggregateValue(rowIndex, columnIndex, value, type) {
        //rowIndex = rowIndex.sort();
        //columnIndex = columnIndex.sort();
        let rlt = rowIndex.length;
        //let clt: number = columnIndex.length;
        let ri = 0;
        let cellValue = 0;
        let avgCnt = 0;
        let isInit = true;
        let isValueExist = false;
        if (type && type.toLowerCase() === 'count') {
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined) {
                    isValueExist = true;
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    cellValue += (isNullOrUndefined(this.valueMatrix[rowIndex[ri]][value]) ?
                        0 : (this.allowDataCompression ? this.valueMatrix[rowIndex[ri]][value] : 1));
                }
                ri++;
            }
        }
        else if (type && type.toLowerCase() === 'distinctcount') {
            let duplicateValues = [];
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined) {
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    isValueExist = true;
                    let val = (this.data[rowIndex[ri]][this.fields[value]]);
                    let currentVal;
                    // let currentVal: number = this.valueMatrix[rowIndex[ri]][value];
                    if (!isNullOrUndefined(val)) {
                        currentVal = val.toString();
                        if (duplicateValues.length === 0 || (duplicateValues.length > 0 && duplicateValues.indexOf(currentVal) === -1)) {
                            cellValue += (this.allowDataCompression && typeof val === 'number') ? val : 1;
                            duplicateValues.push(currentVal);
                        }
                    }
                }
                ri++;
            }
        }
        else if (type && type.toLowerCase() === 'product') {
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined) {
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    isValueExist = true;
                    let currentVal = this.valueMatrix[rowIndex[ri]][value];
                    if (!isNullOrUndefined(currentVal)) {
                        cellValue = ((isInit || isNullOrUndefined(cellValue)) ? 1 : cellValue);
                        cellValue *= currentVal;
                    }
                    else if (isInit) {
                        cellValue = currentVal;
                    }
                    isInit = false;
                }
                ri++;
            }
        }
        else if (type && (['populationstdev', 'samplestdev', 'populationvar', 'samplevar']).indexOf(type.toLowerCase()) !== -1) {
            let i = 0;
            let val = 0;
            let indexVal = [];
            let avgVal = 0;
            let cVal = 0;
            let avgDifferenceVal = 0;
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined) {
                    isValueExist = true;
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    let currentVal = this.valueMatrix[rowIndex[ri]][value];
                    if (!isNullOrUndefined(currentVal)) {
                        val += currentVal;
                        indexVal.push(currentVal);
                        i++;
                    }
                }
                ri++;
            }
            if (i > 0) {
                avgVal = val / i;
                for (let index of indexVal) {
                    avgDifferenceVal += Math.pow((index - avgVal), 2);
                }
                if ((['populationstdev', 'samplestdev']).indexOf(type.toLowerCase()) !== -1) {
                    cVal = Math.sqrt(avgDifferenceVal / (type.toLowerCase() === 'populationstdev' ? i : (i - 1)));
                }
                else {
                    cVal = avgDifferenceVal / (type.toLowerCase() === 'populationvar' ? i : (i - 1));
                }
                cellValue = (cVal === 0 ? NaN : cVal);
            }
            else {
                cellValue = val;
            }
        }
        else if (type && type.toLowerCase() === 'min') {
            let isFirst = true;
            cellValue = undefined;
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined && this.valueMatrix[rowIndex[ri]][value] !== undefined) {
                    isValueExist = true;
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    if (isNullOrUndefined(cellValue) && isNullOrUndefined(this.valueMatrix[rowIndex[ri]][value])) {
                        cellValue = this.valueMatrix[rowIndex[ri]][value];
                    }
                    else {
                        if (isFirst) {
                            cellValue = this.valueMatrix[rowIndex[ri]][value];
                            isFirst = false;
                        }
                        else {
                            cellValue = this.valueMatrix[rowIndex[ri]][value] < cellValue ? this.valueMatrix[rowIndex[ri]][value] : cellValue;
                        }
                    }
                }
                ri++;
            }
        }
        else if (type && type.toLowerCase() === 'max') {
            let isMaxFirst = true;
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined && this.valueMatrix[rowIndex[ri]][value] !== undefined) {
                    isValueExist = true;
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    if (isMaxFirst) {
                        cellValue = this.valueMatrix[rowIndex[ri]][value];
                        isMaxFirst = false;
                    }
                    else {
                        cellValue = this.valueMatrix[rowIndex[ri]][value] > cellValue ? this.valueMatrix[rowIndex[ri]][value] : cellValue;
                    }
                }
                ri++;
            }
        }
        else if (type && type.toLowerCase() === 'calculatedfield') {
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined) {
                    isValueExist = true;
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    let calcField = this.calculatedFields[this.fields[value]];
                    let actualFormula = calcField.formula;
                    let aggregateField = {};
                    if (this.calculatedFormulas[calcField.name]) {
                        let calculatedFormulas = this.calculatedFormulas[calcField.name];
                        for (let len = 0, lmt = calculatedFormulas.length; len < lmt; len++) {
                            let aggregatedValue = calculatedFormulas[len];
                            let value = aggregateField[aggregatedValue.formula];
                            if (value === undefined) {
                                let type = aggregatedValue.type;
                                value = this.getAggregateValue(rowIndex, columnIndex, aggregatedValue.index, type);
                                aggregateField[aggregatedValue.formula] = value;
                            }
                            actualFormula = (actualFormula).replace(aggregatedValue.formula, String(value));
                        }
                    }
                    /* tslint:disable */
                    cellValue = this.evaluate(actualFormula);
                    (cellValue === Infinity ? Infinity : (cellValue === undefined || isNaN(cellValue)) ? undefined : JSON.parse(String(cellValue)));
                    /* tslint:enable */
                }
                ri++;
            }
        }
        else {
            cellValue = undefined;
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined) {
                    isValueExist = true;
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    //let cIndx: number = isLeastLevel ? columnIndex.splice(columnIndex.indexOf(rowIndex[ri]), 1)[0] : rowIndex[ri];
                    let currentVal = this.valueMatrix[rowIndex[ri]][value];
                    if (isNullOrUndefined(cellValue) && isNullOrUndefined(currentVal)) {
                        cellValue = currentVal;
                    }
                    else {
                        if (isNullOrUndefined(cellValue)) {
                            cellValue = 0;
                        }
                        cellValue += (isNullOrUndefined(currentVal) ? 0 : currentVal);
                    }
                    if (!isNullOrUndefined(currentVal)) {
                        avgCnt++;
                    }
                }
                ri++;
            }
        }
        /* if (rlt > clt) {
             this.makeMirrorObject(rowIndex, mirror);
             while (columnIndex[ci] !== undefined) {
                 if (mirror[columnIndex[ci]]) {
                     let cIndx: number = isLeastLevel ? columnIndex.splice(ci, 1)[0] : columnIndex[ci];
                     //rowIndex.splice
                     sum += this.valueMatrix[cIndx][value];
                 }
                 ci++;
             }
         } else {
             this.makeMirrorObject(columnIndex, mirror);
             while (rowIndex[ri] !== undefined) {
                 if (mirror[rowIndex[ri]]) {
                     let cIndx: number = isLeastLevel ? columnIndex.splice(columnIndex.indexOf(rowIndex[ri]), 1)[0] : rowIndex[ri];
                     sum += this.valueMatrix[rowIndex[ri]][value];
                 }
                 ri++;
             }
         } */
        return ((type && type.toLowerCase() === 'avg' && cellValue !== 0 &&
            !isNullOrUndefined(cellValue)) ? (cellValue / avgCnt) : isValueExist ? cellValue : undefined);
    }
    evaluate(obj) {
        return Function('"use strict";return (' + obj + ')')();
    }
    ;
    /* tslint:enable */
    /** hidden */
    getFormattedValue(value, fieldName) {
        let commonValue = value === null ? (this.localeObj ? this.localeObj.getConstant('null') :
            String(value)) : value === undefined ?
            (this.localeObj ? (fieldName in this.groupingFields) ? this.localeObj.getConstant('groupOutOfRange') :
                this.localeObj.getConstant('undefined') : String(value)) : value;
        let formattedValue = {
            formattedText: commonValue.toString(),
            actualText: commonValue,
            dateText: commonValue
        };
        if (this.formatFields[fieldName] && value) {
            try {
                let formatField = (this.formatFields[fieldName].properties ?
                    this.formatFields[fieldName].properties : this.formatFields[fieldName]);
                let formatSetting = extend({}, formatField, null, true);
                delete formatSetting.name;
                if (!formatSetting.minimumSignificantDigits && formatSetting.minimumSignificantDigits < 1) {
                    delete formatSetting.minimumSignificantDigits;
                }
                if (!formatSetting.maximumSignificantDigits && formatSetting.maximumSignificantDigits < 1) {
                    delete formatSetting.maximumSignificantDigits;
                }
                if (formatSetting.type) {
                    formattedValue.formattedText = this.dateFormatFunction[fieldName].exactFormat(new Date(value));
                }
                else {
                    delete formatSetting.type;
                    if ((formatSetting.format) && !(this.formatRegex.test(formatSetting.format))) {
                        let pattern = formatSetting.format.match(this.customRegex);
                        let integerPart = pattern[6];
                        formatSetting.useGrouping = integerPart.indexOf(',') !== -1;
                    }
                    formattedValue.formattedText = this.globalize.formatNumber(value, formatSetting);
                }
                formattedValue.actualText = value;
                if (this.fieldList[fieldName].sort !== 'None' && formatSetting.type &&
                    ['date', 'dateTime', 'time'].indexOf(this.formatFields[fieldName].type) > -1) {
                    formattedValue.dateText = this.dateFormatFunction[fieldName].fullFormat(new Date(value));
                }
                if (this.fieldList[fieldName].isCustomField) {
                    formattedValue.formattedText = formattedValue.formattedText === 'NaN' ?
                        commonValue.toString() : formattedValue.formattedText;
                    formattedValue.dateText = formattedValue.dateText === 'NaN' ?
                        commonValue.toString() : formattedValue.dateText;
                }
            }
            catch (exception) {
                if (!this.fieldList[fieldName].isCustomField) {
                    throw exception;
                }
            }
            finally {
                if (this.fieldList[fieldName].isCustomField) {
                    formattedValue.formattedText =
                        (isNullOrUndefined(formattedValue.formattedText) || formattedValue.formattedText === 'NaN') ?
                            commonValue.toString() : formattedValue.formattedText;
                    formattedValue.dateText = (isNullOrUndefined(formattedValue.dateText) || formattedValue.dateText === 'NaN') ?
                        commonValue.toString() : formattedValue.dateText;
                }
            }
        }
        return formattedValue;
    }
    powerFunction(formula) {
        if (formula.indexOf('^') > -1) {
            let items = [];
            while (formula.indexOf('(') > -1) {
                formula = formula.replace(/(\([^\(\)]*\))/g, (text, item) => {
                    items.push(item);
                    return ('~' + (items.length - 1));
                });
            }
            items.push(formula);
            formula = '~' + (items.length - 1);
            while (formula.indexOf('~') > -1) {
                formula = formula.replace(new RegExp('~' + '(\\d+)', 'g'), (text, index) => {
                    return items[index].replace(/(\w*)\^(\w*)/g, 'Math.pow' + '($1,$2)');
                });
            }
        }
        return formula;
    }
}

/**
 * Specifies pivot external events
 * @hidden
 */
/** @hidden */
const load = 'load';
/** @hidden */
const enginePopulating = 'enginePopulating';
/** @hidden */
const enginePopulated = 'enginePopulated';
/** @hidden */
const onFieldDropped = 'onFieldDropped';
/** @hidden */
const fieldDrop = 'fieldDrop';
/** @hidden */
const beforePivotTableRender = 'beforePivotTableRender';
/** @hidden */
const afterPivotTableRender = 'afterPivotTableRender';
/** @hidden */
const beforeExport = 'beforeExport';
/** @hidden */
const excelHeaderQueryCellInfo = 'excelHeaderQueryCellInfo';
/** @hidden */
const pdfHeaderQueryCellInfo = 'pdfHeaderQueryCellInfo';
/** @hidden */
const excelQueryCellInfo = 'excelQueryCellInfo';
/** @hidden */
const pdfQueryCellInfo = 'pdfQueryCellInfo';
/** @hidden */
const onPdfCellRender = 'onPdfCellRender';
/** @hidden */
const dataBound = 'dataBound';
/** @hidden */
const queryCellInfo = 'queryCellInfo';
/** @hidden */
const headerCellInfo = 'headerCellInfo';
/** @hidden */
const hyperlinkCellClick = 'hyperlinkCellClick';
/** @hidden */
const resizing = 'resizing';
/** @hidden */
const resizeStop = 'resizeStop';
/** @hidden */
const cellClick = 'cellClick';
/** @hidden */
const drillThrough = 'drillThrough';
/** @hidden */
const beforeColumnsRender = 'beforeColumnsRender';
/** @hidden */
const selected = 'selected';
/** @hidden */
const cellSelecting = 'cellSelecting';
/** @hidden */
const drill = 'drill';
/** @hidden */
const cellSelected = 'cellSelected';
/** @hidden */
const cellDeselected = 'cellDeselected';
/** @hidden */
const rowSelected = 'rowSelected';
/** @hidden */
const rowDeselected = 'rowDeselected';
/** @hidden */
const beginDrillThrough = 'beginDrillThrough';
/** @hidden */
const saveReport = 'saveReport';
/** @hidden */
const fetchReport = 'fetchReport';
/** @hidden */
const loadReport = 'loadReport';
/** @hidden */
const renameReport = 'renameReport';
/** @hidden */
const removeReport = 'removeReport';
/** @hidden */
const newReport = 'newReport';
/** @hidden */
const toolbarRender = 'toolbarRender';
/** @hidden */
const toolbarClick = 'toolbarClick';
/** @hidden */
const chartTooltipRender = 'chartTooltipRender';
/** @hidden */
const chartLoaded = 'chartLoaded';
/** @hidden */
const chartLoad = 'chartLoad';
/** @hidden */
const chartResized = 'chartResized';
/** @hidden */
const chartAxisLabelRender = 'chartAxisLabelRender';
/** @hidden */
const chartSeriesCreated = 'chartSeriesCreated';
/** @hidden */
const aggregateCellInfo = 'aggregateCellInfo';
/** @hidden */
const contextMenuClick = 'contextMenuClick';
/** @hidden */
const contextMenuOpen = 'contextMenuOpen';
/** @hidden */
const fieldListRefreshed = 'fieldListRefreshed';
/** @hidden */
const conditionalFormatting = 'conditionalFormatting';
/** @hidden */
const beforePdfExport = 'beforePdfExport';
/** @hidden */
const beforeExcelExport = 'beforeExcelExport';
/** @hidden */
const memberFiltering = 'memberFiltering';
/**
 * Specifies pivot internal events
 */
/** @hidden */
const initialLoad = 'initial-load';
/** @hidden */
const uiUpdate = 'ui-update';
/** @hidden */
const scroll = 'scroll';
/** @hidden */
const contentReady = 'content-ready';
/** @hidden */
const dataReady = 'data-ready';
/** @hidden */
const initSubComponent = 'init-groupingbar';
/** @hidden */
const treeViewUpdate = 'tree-view-update';
/** @hidden */
const pivotButtonUpdate = 'pivot-button-update';
/** @hidden */
const initCalculatedField = 'init-calculatedfield';
/** @hidden */
const click = 'click';
/** @hidden */
const initToolbar = 'init-toolbar';
/** @hidden */
const initFormatting = 'init-formatting';
/** @hidden */
const initGrouping = 'init-grouping';

/**
 * CSS Constants
 * @hidden
 */
/** @hidden */
const ROOT = 'e-pivotfieldlist';
/** @hidden */
const RTL = 'e-rtl';
/** @hidden */
const PIVOTCHART_LTR = 'e-ltr';
/** @hidden */
const DEVICE = 'e-device';
/** @hidden */
const ICON = 'e-icons';
/** @hidden */
const ICON_DISABLE = 'e-disable';
/** @hidden */
const ICON_HIDDEN = 'e-hide';
/** @hidden */
const AXISFIELD_ICON_CLASS = 'e-dropdown-icon';
/** @hidden */
const WRAPPER_CLASS = 'e-pivotfieldlist-wrapper';
/** @hidden */
const OLAP_WRAPPER_CLASS = 'e-olapfieldlist-wrapper';
/** @hidden */
const CONTAINER_CLASS = 'e-field-list-container';
/** @hidden */
const TOGGLE_FIELD_LIST_CLASS = 'e-toggle-field-list';
/** @hidden */
const STATIC_FIELD_LIST_CLASS = 'e-static';
/** @hidden */
const TOGGLE_SELECT_CLASS = 'e-select-table';
/** @hidden */
const FIELD_TABLE_CLASS = 'e-field-table';
/** @hidden */
const OLAP_FIELD_TABLE_CLASS = 'e-olap-field-table';
/** @hidden */
const FIELD_LIST_CLASS = 'e-field-list';
/** @hidden */
const OLAP_FIELD_LIST_CLASS = 'e-olap-field-list-tree';
/** @hidden */
const FIELD_LIST_TREE_CLASS = 'e-field-list-tree';
/** @hidden */
const FIELD_HEADER_CLASS = 'e-field-header';
/** @hidden */
const FIELD_LIST_TITLE_CLASS = 'e-field-list-title';
/** @hidden */
const FIELD_LIST_TITLE_CONTENT_CLASS = 'e-title-content';
/** @hidden */
const FIELD_LIST_FOOTER_CLASS = 'e-field-list-footer';
/** @hidden */
const CALCULATED_FIELD_CLASS = 'e-calculated-field';
/** @hidden */
const FLAT_CLASS = 'e-flat e-primary';
/** @hidden */
const OUTLINE_CLASS = 'e-outline';
/** @hidden */
const AXIS_TABLE_CLASS = 'e-axis-table';
/** @hidden */
const OLAP_AXIS_TABLE_CLASS = 'e-olap-axis-table';
/** @hidden */
const LEFT_AXIS_PANEL_CLASS = 'e-left-axis-fields';
/** @hidden */
const RIGHT_AXIS_PANEL_CLASS = 'e-right-axis-fields';
/** @hidden */
const AXIS_HEADER_CLASS = 'e-axis-header';
/** @hidden */
const AXIS_CONTENT_CLASS = 'e-axis-content';
/** @hidden */
const AXIS_PROMPT_CLASS = 'e-draggable-prompt';
/** @hidden */
const PIVOT_BUTTON_WRAPPER_CLASS = 'e-pvt-btn-div';
/** @hidden */
const PIVOT_BUTTON_CLASS = 'e-pivot-button';
/** @hidden */
const PIVOT_BUTTON_CONTENT_CLASS = 'e-content';
/** @hidden */
const DRAG_CLONE_CLASS = 'e-button-drag-clone';
/** @hidden */
const SORT_CLASS = 'e-sort';
/** @hidden */
const SORT_DESCEND_CLASS = 'e-descend';
/** @hidden */
const FILTER_COMMON_CLASS = 'e-btn-filter';
/** @hidden */
const FILTER_CLASS = 'e-pv-filter';
/** @hidden */
const FILTERED_CLASS = 'e-pv-filtered';
/** @hidden */
const REMOVE_CLASS = 'e-remove';
/** @hidden */
const DRAG_CLASS = 'e-drag';
/** @hidden */
const DROP_INDICATOR_CLASS = 'e-drop-indicator';
/** @hidden */
const INDICATOR_HOVER_CLASS = 'e-drop-hover';
/** @hidden */
const MEMBER_EDITOR_DIALOG_CLASS = 'e-member-editor-dialog';
/** @hidden */
const EDITOR_TREE_WRAPPER_CLASS = 'e-member-editor-wrapper';
/** @hidden */
const EDITOR_TREE_CONTAINER_CLASS = 'e-member-editor-container';
/** @hidden */
const DRILLTHROUGH_GRID_CLASS = 'e-drillthrough-grid';
/** @hidden */
const DRILLTHROUGH_BODY_CLASS = 'e-drillthrough-body';
/** @hidden */
const DRILLTHROUGH_BODY_HEADER_CONTAINER_CLASS = 'e-drillthrough-body-header-container';
/** @hidden */
const DRILLTHROUGH_BODY_HEADER_CLASS = 'e-drillthrough-body-header';
/** @hidden */
const DRILLTHROUGH_BODY_HEADER_COMMON_CLASS = 'e-drillthrough-body-header-common';
/** @hidden */
const DRILLTHROUGH_BODY_HEADER_VALUE_CLASS = 'e-drillthrough-body-header-value';
/** @hidden */
const DRILLTHROUGH_DIALOG = 'e-drillthrough-dialog';
/** @hidden */
const EDITOR_LABEL_WRAPPER_CLASS = 'e-editor-label-wrapper';
/** @hidden */
const EDITOR_LABEL_CLASS = 'e-editor-label';
/** @hidden */
const CHECK_BOX_FRAME_CLASS = 'e-frame';
/** @hidden */
const NODE_CHECK_CLASS = 'e-check';
/** @hidden */
const NODE_STOP_CLASS = 'e-stop';
/** @hidden */
const OK_BUTTON_CLASS = 'e-ok-btn';
/** @hidden */
const CANCEL_BUTTON_CLASS = 'e-cancel-btn';
/** @hidden */
const ERROR_DIALOG_CLASS = 'e-pivot-error-dialog';
/** @hidden */
const DROPPABLE_CLASS = 'e-droppable';
/** @hidden */
const ROW_AXIS_CLASS = 'e-rows';
/** @hidden */
const COLUMN_AXIS_CLASS = 'e-columns';
/** @hidden */
const VALUE_AXIS_CLASS = 'e-values';
/** @hidden */
const FILTER_AXIS_CLASS = 'e-filters';
/** @hidden */
const GROUPING_BAR_CLASS = 'e-grouping-bar';
/** @hidden */

/** @hidden */
const GROUP_ROW_CLASS = 'e-group-rows';
/** @hidden */
const GROUP_COLUMN_CLASS = 'e-group-columns';
/** @hidden */

/** @hidden */
const GROUP_VALUE_CLASS = 'e-group-values';
/** @hidden */
const GROUP_FILTER_CLASS = 'e-group-filters';
/** @hidden */

/** @hidden */
const NO_DRAG_CLASS = 'e-drag-restrict';
/** @hidden */
const SELECTED_NODE_CLASS = 'e-list-selected';
/** @hidden */
const TITLE_HEADER_CLASS = 'e-title-header';
/** @hidden */
const TITLE_CONTENT_CLASS = 'e-title-content';
/** @hidden */
const TEXT_CONTENT_CLASS = 'e-text-content';
/** @hidden */
const FOOTER_CONTENT_CLASS = 'e-footer-content';
/** @hidden */
const ADAPTIVE_CONTAINER_CLASS = 'e-adaptive-container';
/** @hidden */
const ADAPTIVE_FIELD_LIST_BUTTON_CLASS = 'e-field-list-btn';
/** @hidden */
const ADAPTIVE_CALCULATED_FIELD_BUTTON_CLASS = 'e-calculated-field-btn';
/** @hidden */
const BUTTON_SMALL_CLASS = 'e-small';
/** @hidden */
const BUTTON_ROUND_CLASS = 'e-round';
/** @hidden */
const ADD_ICON_CLASS = 'e-add-icon';
/** @hidden */
const BUTTON_FLAT_CLASS = 'e-flat';
/** @hidden */
const STATIC_CENTER_DIV_CLASS = 'e-center-div';
/** @hidden */
const STATIC_CENTER_HEADER_CLASS = 'e-center-title';
/** @hidden */
const ADAPTIVE_FIELD_LIST_DIALOG_CLASS = 'e-adaptive-field-list-dialog';
/** @hidden */
const LIST_TEXT_CLASS = 'e-list-text';
/** @hidden */
const LIST_SELECT_CLASS = 'e-selected-node';
/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */
const SELECTED_OPTION_ICON_CLASS = 'e-selected-option-icon';
/** @hidden */
const SELECTED_LEVEL_ICON_CLASS = 'e-selected-level-icon';
/** @hidden */
const FILTER_DIV_CONTENT_CLASS = 'e-filter-div-content';
/** @hidden */
const FILTER_TEXT_DIV_CLASS = 'e-filter-text-div';
/** @hidden */
const BETWEEN_TEXT_DIV_CLASS = 'e-between-text-div';
/** @hidden */
const SEPARATOR_DIV_CLASS = 'e-separator-div';
/** @hidden */
const FILTER_OPTION_WRAPPER_1_CLASS = 'e-filter-option-wrapper-1';
/** @hidden */
const FILTER_OPTION_WRAPPER_2_CLASS = 'e-filter-option-wrapper-2';
/** @hidden */
const FILTER_INPUT_DIV_1_CLASS = 'e-filter-input-div-1';
/** @hidden */
const FILTER_INPUT_DIV_2_CLASS = 'e-filter-input-div-2';
/** @hidden */
const VALUE_OPTIONS_CLASS = 'e-value-options';
/** @hidden */
const LEVEL_OPTIONS_CLASS = 'e-level-options';
/** @hidden */
const FILTER_OPERATOR_CLASS = 'e-filter-operator';
/** @hidden */
const COLLAPSE = 'e-collapse';
/** @hidden */
const EXPAND = 'e-expand';
/** @hidden */
const TABLE = 'e-table';
/** @hidden */

/** @hidden */

/** @hidden */
const COLUMNSHEADER = 'e-columnsheader';
/** @hidden */
const ROWSHEADER = 'e-rowsheader';
/** @hidden */
const VALUESCONTENT = 'e-valuescontent';
/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */
const SUMMARY = 'e-summary';
/** @hidden */
const CELLVALUE = 'e-cellvalue';
/** @hidden */

/** @hidden */
const PIVOTTOOLTIP = 'e-pivottooltip';
/** @hidden */
const TOOLTIP_HEADER = 'e-tooltipheader';
/** @hidden */
const TOOLTIP_CONTENT = 'e-tooltipcontent';
/** @hidden */
const NEXTSPAN = 'e-nextspan';
/** @hidden */
const LASTSPAN = 'e-lastspan';
/** @hidden */
const EDITOR_SEARCH_WRAPPER_CLASS = 'e-editor-search-wrapper';
/** @hidden */
const EDITOR_SEARCH_CLASS = 'e-editor-search';
/** @hidden */
const SELECT_ALL_WRAPPER_CLASS = 'e-select-all-wrapper';
/** @hidden */
const SELECT_ALL_CLASS = 'e-select-all';
/** @hidden */
const PIVOTCALC = 'e-pivot-calc';
/** @hidden */
const CALCDIALOG = 'e-pivot-calc-dialog-div';
/** @hidden */
const OLAP_CALCDIALOG = 'e-olap-calc-dialog-div';
/** @hidden */
const CALCRADIO = 'e-pivot-calc-radio';
/** @hidden */
const CALCCHECK = 'e-pivot-calc-check';
/** @hidden */
const CALCINPUT = 'e-pivot-calc-input';
/** @hidden */
const CALC_FORMAT_INPUT = 'e-custom-format-input';
/** @hidden */
const CALCINPUTDIV = 'e-pivot-calc-input-div';
/** @hidden */
const CALC_CUSTOM_FORMAT_INPUTDIV = 'e-olap-calc-custom-format-div';
/** @hidden */
const CALC_HIERARCHY_LIST_DIV = 'e-olap-calc-hierarchy-list-div';
/** @hidden */
const CALC_FORMAT_TYPE_DIV = 'e-olap-calc-format-type-div';
/** @hidden */
const CALC_MEMBER_TYPE_DIV = 'e-olap-calc-member-type-div';
/** @hidden */
const MEMBER_OPTIONS_CLASS = 'e-member-options';
/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */
const CALCOUTERDIV = 'e-pivot-calc-outer-div';
/** @hidden */
const OLAP_CALCOUTERDIV = 'e-olap-calc-outer-div';
/** @hidden */
const FLAT = 'e-flat';
/** @hidden */
const FORMAT = 'e-format';
/** @hidden */
const FORMULA = 'e-pivot-formula';
/** @hidden */
const TREEVIEW = 'e-pivot-treeview';
/** @hidden */
const TREEVIEWOUTER = 'e-pivot-treeview-outer';
/** @hidden */
const CALCCANCELBTN = 'e-pivot-cancel-button';
/** @hidden */
const CALCADDBTN = 'e-pivot-add-button';
/** @hidden */
const CALCOKBTN = 'e-pivot-ok-button';
/** @hidden */
const CALCACCORD = 'e-pivot-accord';
/** @hidden */
const CALCBUTTONDIV = 'e-pivot-button-div';
/** @hidden */
const AXIS_ICON_CLASS = 'e-axis';
/** @hidden */
const AXIS_ROW_CLASS = 'e-axis-row';
/** @hidden */
const AXIS_COLUMN_CLASS = 'e-axis-column';
/** @hidden */
const AXIS_VALUE_CLASS = 'e-axis-value';
/** @hidden */
const AXIS_FILTER_CLASS = 'e-axis-filter';
/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */
const GRID_CLASS = 'e-grid';
/** @hidden */
const PIVOT_VIEW_CLASS = 'e-pivotview';
/** @hidden */
const PIVOT_ALL_FIELD_TITLE_CLASS = 'e-pivot-all-field-title';
/** @hidden */
const PIVOT_FIELD_TITLE_CLASS = 'e-pivot-field-name-title';
/** @hidden */
const PIVOT_FORMULA_TITLE_CLASS = 'e-pivot-formula-title';
/** @hidden */
const OLAP_HIERARCHY_TITLE_CLASS = 'e-olap-hierarchy-title';
/** @hidden */
const OLAP_FORMAT_TITLE_CLASS = 'e-olap-format-title';
/** @hidden */
const OLAP_MEMBER_TITLE_CLASS = 'e-olap-member-title';
/** @hidden */
const PIVOT_CONTEXT_MENU_CLASS = 'e-pivot-context-menu';
/** @hidden */
const MENU_DISABLE = 'e-disabled';
/** @hidden */
const MENU_HIDE = 'e-menu-hide';
/** @hidden */
const EMPTY_MEMBER_CLASS = 'e-member-prompt';
/** @hidden */
const CALC_EDIT = 'e-edit';
/** @hidden */
const CALC_EDITED = 'e-edited';
/** @hidden */
const CALC_INFO = 'e-info';
/** @hidden */
const EMPTY_FIELD = 'e-empty-field';
/** @hidden */
const FORMAT_DIALOG = 'e-pivot-formatting-dialog';
/** @hidden */
const FORMAT_CONDITION_BUTTON = 'e-format-condition-button';
/** @hidden */
const FORMAT_NEW = 'e-new-format';
/** @hidden */
const FORMAT_OUTER = 'e-format-outer-div';
/** @hidden */
const FORMAT_INNER = 'e-format-inner-div';
/** @hidden */
const FORMAT_TABLE = 'e-format-table';
/** @hidden */
const FORMAT_VALUE_LABEL = 'e-format-value-label';
/** @hidden */
const FORMAT_LABEL = 'e-format-label';
/** @hidden */
const INPUT = 'e-input';
/** @hidden */
const FORMAT_VALUE1 = 'e-format-value1';
/** @hidden */
const FORMAT_VALUE2 = 'e-format-value2';
/** @hidden */
const FORMAT_VALUE_SPAN = 'e-format-value-span';
/** @hidden */
const FORMAT_FONT_COLOR = 'e-format-font-color';
/** @hidden */
const FORMAT_BACK_COLOR = 'e-format-back-color';
/** @hidden */
const FORMAT_VALUE_PREVIEW = 'e-format-value-preview';
/** @hidden */
const FORMAT_COLOR_PICKER = 'e-format-color-picker';
/** @hidden */
const FORMAT_DELETE_ICON = 'e-format-delete-icon';
/** @hidden */
const FORMAT_DELETE_BUTTON = 'e-format-delete-button';
/** @hidden */
const SELECTED_COLOR = 'e-selected-color';
/** @hidden */
const DIALOG_HEADER = 'e-dlg-header';
/** @hidden */
const FORMAT_APPLY_BUTTON = 'e-format-apply-button';
/** @hidden */
const FORMAT_CANCEL_BUTTON = 'e-format-cancel-button';
/** @hidden */
const FORMAT_ROUND_BUTTON = 'e-small e-round';
/** @hidden */
const VIRTUALTRACK_DIV = 'e-virtualtrack';
/** @hidden */
const MOVABLECONTENT_DIV = 'e-movablecontent';
/** @hidden */
const FROZENCONTENT_DIV = 'e-frozencontent';
/** @hidden */
const MOVABLEHEADER_DIV = 'e-movableheader';
/** @hidden */

/** @hidden */
const DEFER_APPLY_BUTTON = 'e-defer-apply-button';
/** @hidden */
const DEFER_CANCEL_BUTTON = 'e-defer-cancel-button';
/** @hidden */
const LAYOUT_FOOTER = 'e-layout-footer';
/** @hidden */
const CELL_SELECTED_BGCOLOR = 'e-cellselectionbackground';
/** @hidden */
const SELECTED_BGCOLOR = 'e-selectionbackground';
/** @hidden */
const BUTTON_LAYOUT = 'e-button-layout';
/** @hidden */
const CHECKBOX_LAYOUT = 'e-checkbox-layout';
/** @hidden */
const DEFER_UPDATE_BUTTON = 'e-defer-update-btn';
/** @hidden */
const HEADERCONTENT = 'e-headercontent';
/** @hidden */
const BACK_ICON = 'e-field-list-back-icon';
/** @hidden */
const TITLE_MOBILE_HEADER = 'e-title-mobile-header';
/** @hidden */
const TITLE_MOBILE_CONTENT = 'e-title-mobile-content';
/** @hidden */
const ROW_CELL_CLASS = 'e-rowcell';
/** @hidden */
const CELL_ACTIVE_BGCOLOR = 'e-active';
/** @hidden */
const SPAN_CLICKED = 'e-spanclicked';
/** @hidden */
const ROW_SELECT = 'e-rowselect';
/** @hidden */
const GRID_HEADER = 'e-gridheader';
/** @hidden */

/** @hidden */
const GRID_EXPORT = 'e-export';
/** @hidden */
const PIVOTVIEW_EXPORT = 'e-pivotview-export';
/** @hidden */
const PIVOTVIEW_GRID = 'e-pivotview-grid';
/** @hidden */
const PIVOTVIEW_EXPAND = 'e-pivotview-expand';
/** @hidden */
const PIVOTVIEW_COLLAPSE = 'e-pivotview-collapse';
/** @hidden */
const PIVOTVIEW_GROUP = 'e-pivotview-group';
/** @hidden */
const PIVOTVIEW_UN_GROUP = 'e-pivotview-ungroup';
/** @hidden */
const GRID_PDF_EXPORT = 'e-pivotview-pdf-export';
/** @hidden */
const GRID_EXCEL_EXPORT = 'e-pivotview-excel-export';
/** @hidden */
const GRID_CSV_EXPORT = 'e-pivotview-csv-export';
/** @hidden */
const GRID_PNG_EXPORT = 'e-pivotview-png-export';
/** @hidden */
const GRID_JPEG_EXPORT = 'e-pivotview-jpeg-export';
/** @hidden */
const GRID_SVG_EXPORT = 'e-pivotview-svg-export';
/** @hidden */
const GRID_LOAD = 'e-load-report';
/** @hidden */
const GRID_NEW = 'e-new-report';
/** @hidden */
const GRID_RENAME = 'e-rename-report';
/** @hidden */
const GRID_REMOVE = 'e-remove-report';
/** @hidden */
const GRID_SAVEAS = 'e-saveas-report';
/** @hidden */
const GRID_SAVE = 'e-save-report';
/** @hidden */
const GRID_SUB_TOTAL = 'e-sub-total';
/** @hidden */
const GRID_GRAND_TOTAL = 'e-grand-total';
/** @hidden */
const GRID_FORMATTING = 'e-toolbar-formatting';
/** @hidden */
const GRID_TOOLBAR = 'e-pivot-toolbar';
/** @hidden */
const GRID_REPORT_LABEL = 'e-pivotview-report-label';
/** @hidden */
const GRID_REPORT_INPUT = 'e-pivotview-report-input';
/** @hidden */
const GRID_REPORT_OUTER = 'e-report-outer';
/** @hidden */
const GRID_REPORT_DIALOG = 'e-pivotview-report-dialog';
/** @hidden */
const TOOLBAR_FIELDLIST = 'e-toolbar-fieldlist';
/** @hidden */
const TOOLBAR_GRID = 'e-toolbar-grid';
/** @hidden */
const TOOLBAR_CHART = 'e-toolbar-chart';
/** @hidden */
const REPORT_LIST_DROP = 'e-reportlist-drop';
/** @hidden */
const PIVOTCHART = 'e-pivotchart';
/** @hidden */
const GROUP_CHART_ROW = 'e-group-chart-rows';
/** @hidden */
const GROUP_CHART_COLUMN = 'e-group-chart-columns';
/** @hidden */
const GROUP_CHART_VALUE = 'e-group-chart-values';
/** @hidden */
const GROUP_CHART_MULTI_VALUE = 'e-group-chart-multi-values';
/** @hidden */
const GROUP_CHART_FILTER = 'e-group-chart-filters';
/** @hidden */
const GROUP_CHART_VALUE_DROPDOWN_DIV = 'e-group-chart-values-drodown-div';
/** @hidden */
const GROUP_CHART_VALUE_DROPDOWN = 'e-group-chart-values-drodown';
/** @hidden */
const CHART_GROUPING_BAR_CLASS = 'e-chart-grouping-bar';
/** @hidden */
const PIVOT_DISABLE_ICON = 'e-pivotview-disable-icon';
/** @hidden */
const PIVOT_SELECT_ICON = 'e-pivotview-select-icon';
/** @hidden */
const VALUESHEADER = 'e-valuesheader';
/** @hidden */
const ICON_ASC = 'e-icon-ascending';
/** @hidden */
const ICON_DESC = 'e-icon-descending';
/** @hidden */
const GRID_GROUPING_BAR_CLASS = 'e-pivot-grouping-bar';
/** @hidden */
const MDX_QUERY = 'e-mdx-query';
/** @hidden */
const MDX_QUERY_CONTENT = 'e-mdx-query-content';
/** @hidden */
const GRID_MDX_DIALOG = 'e-pivotview-mdx-dialog';
/** @hidden */
const GRID_MDX = 'e-mdx';
/** @hidden */
const FORMATTING_DIALOG = 'e-pivot-format-dialog';
/** @hidden */
const FORMATTING_DIALOG_OUTER = 'e-pivot-format-dialog-outer';
/** @hidden */
const FORMATTING_VALUE_LABLE = 'e-pivot-format-value-lable';
/** @hidden */
const FORMATTING_VALUE_DROP = 'e-pivot-format-value-drop';
/** @hidden */
const FORMATTING_FORMAT_LABLE = 'e-pivot-format-lable';
/** @hidden */
const FORMATTING_FORMAT_DROP = 'e-pivot-format-drop';
/** @hidden */
const FORMATTING_CUSTOM_LABLE = 'e-pivot-format-custom-lable';
/** @hidden */
const FORMATTING_CUSTOM_TEXT = 'e-pivot-format-custom-text';
/** @hidden */

/** @hidden */

/** @hidden */
const FORMATTING_GROUPING_LABLE = 'e-pivot-format-grouping-lable';
/** @hidden */
const FORMATTING_GROUPING_DROP = 'e-pivot-format-grouping-drop';
/** @hidden */
const FORMATTING_DECIMAL_LABLE = 'e-pivot-format-decimal-lable';
/** @hidden */
const FORMATTING_DECIMAL_DROP = 'e-pivot-format-decimal-drop';
/** @hidden */
const FORMATTING_TOOLBAR = 'e-pivot-format-toolbar';
/** @hidden */
const FORMATTING_TABLE = 'e-pivot-format-table';
/** @hidden */
const FORMATTING_MENU = 'e-pivot-format-menu';
/** @hidden */
const NUMBER_FORMATTING_MENU = 'e-pivot-number-format-menu';
/** @hidden */
const CONDITIONAL_FORMATTING_MENU = 'e-pivot-conditional-format-menu';

/**
 * `AggregateMenu` module to create aggregate type popup.
 */
/** @hidden */
class AggregateMenu {
    /**
     * Constructor for the rener action.
     * @hidden
     */
    constructor(parent) {
        this.menuInfo = [];
        this.parent = parent;
    }
    /**
     * Initialize the pivot table rendering
     * @returns void
     * @private
     */
    render(args, parentElement) {
        this.parentElement = parentElement;
        this.openContextMenu(args);
    }
    openContextMenu(args) {
        let fieldName = args.target.parentElement.id;
        let isStringField = this.parent.engineModule.fieldList[fieldName].type !== 'number' ? 1 : 0;
        if (isNullOrUndefined(this.menuInfo[isStringField])) {
            this.createContextMenu(isStringField);
        }
        this.currentMenu = args.currentTarget;
        let pos = this.currentMenu.getBoundingClientRect();
        if (this.parent.enableRtl) {
            this.menuInfo[isStringField].open(pos.top + (isStringField ? window.scrollY || document.documentElement.scrollTop : 0), pos.left - 105);
        }
        else {
            this.menuInfo[isStringField].open(pos.top + (isStringField ? window.scrollY || document.documentElement.scrollTop : 0), pos.left);
        }
    }
    createContextMenu(isStringField) {
        let menuItems = [];
        if (isStringField) {
            menuItems[isStringField] = [
                { text: this.parent.localeObj.getConstant('Count'), id: this.parent.element.id + 'StringMenu_Count' },
                { text: this.parent.localeObj.getConstant('DistinctCount'),
                    id: this.parent.element.id + 'StringMenu_DistinctCount'
                }
            ];
        }
        else {
            menuItems[isStringField] = [
                { text: this.parent.localeObj.getConstant('Sum'), id: this.parent.element.id + '_Sum' },
                { text: this.parent.localeObj.getConstant('Count'), id: this.parent.element.id + '_Count' },
                { text: this.parent.localeObj.getConstant('DistinctCount'), id: this.parent.element.id + '_DistinctCount' },
                { text: this.parent.localeObj.getConstant('Product'), id: this.parent.element.id + '_Product' },
                { text: this.parent.localeObj.getConstant('Avg'), id: this.parent.element.id + '_Avg' },
                { text: this.parent.localeObj.getConstant('Min'), id: this.parent.element.id + '_Min' },
                { text: this.parent.localeObj.getConstant('Max'), id: this.parent.element.id + '_Max' },
                { text: this.parent.localeObj.getConstant('MoreOption'), id: this.parent.element.id + '_MoreOption' }
            ];
        }
        let menuOptions;
        menuOptions = {
            items: menuItems[isStringField],
            enableRtl: this.parent.enableRtl,
            beforeOpen: this.beforeMenuOpen.bind(this, isStringField),
            select: this.selectOptionInContextMenu.bind(this)
        };
        let removeContextMenu = document.getElementById(this.parent.element.id + isStringField ? 'valueFieldStringContextMenu' : 'valueFieldContextMenu');
        if (removeContextMenu !== null) {
            removeContextMenu.innerHTML = '';
        }
        let contextMenu = createElement('ul', {
            id: this.parent.element.id + (isStringField ? 'valueFieldStringContextMenu' : 'valueFieldContextMenu')
        });
        this.parent.element.appendChild(contextMenu);
        this.menuInfo[isStringField] = new ContextMenu$1(menuOptions);
        this.menuInfo[isStringField].isStringTemplate = true;
        this.menuInfo[isStringField].appendTo(contextMenu);
    }
    beforeMenuOpen(isString, args) {
        args.element.style.zIndex = (this.menuInfo[isString].element.style.zIndex + 3).toString();
        args.element.style.display = 'inline';
    }
    /** @hidden */
    createValueSettingsDialog(target, parentElement) {
        this.parentElement = parentElement;
        let valueDialog = createElement('div', {
            id: this.parentElement.id + '_ValueDialog',
            className: 'e-value-field-settings',
            attrs: { 'data-field': target.id }
        });
        this.parentElement.appendChild(valueDialog);
        this.valueDialog = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: true,
            header: this.parent.localeObj.getConstant('valueFieldSettings'),
            content: this.createFieldOptions(target),
            isModal: true,
            visible: true,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            width: 'auto',
            height: 'auto',
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    click: this.updateValueSettings.bind(this),
                    buttonModel: { cssClass: OK_BUTTON_CLASS, content: this.parent.localeObj.getConstant('ok'), isPrimary: true }
                },
                {
                    click: () => { this.valueDialog.hide(); },
                    buttonModel: { cssClass: CANCEL_BUTTON_CLASS, content: this.parent.localeObj.getConstant('cancel') }
                }
            ],
            closeOnEscape: true,
            target: this.parentElement,
            overlayClick: () => { this.removeDialog(); },
            close: this.removeDialog.bind(this)
        });
        this.valueDialog.isStringTemplate = true;
        this.valueDialog.appendTo(valueDialog);
        // this.valueDialog.element.querySelector('.e-dlg-header').innerHTML = this.parent.localeObj.getConstant('valueFieldSettings');
    }
    /* tslint:disable:all */
    createFieldOptions(buttonElement) {
        let fieldCaption = buttonElement.getAttribute('data-caption');
        let summaryType = buttonElement.getAttribute('data-type');
        let baseField = buttonElement.getAttribute('data-basefield');
        let baseItem = buttonElement.getAttribute('data-baseitem');
        summaryType = (summaryType.toString() !== 'undefined' ? summaryType : 'Sum');
        let summaryDataSource = [
            { value: 'Sum', text: this.parent.localeObj.getConstant('Sum') },
            { value: 'Count', text: this.parent.localeObj.getConstant('Count') },
            { value: 'DistinctCount', text: this.parent.localeObj.getConstant('DistinctCount') },
            { value: 'Product', text: this.parent.localeObj.getConstant('Product') },
            { value: 'Avg', text: this.parent.localeObj.getConstant('Avg') },
            { value: 'Min', text: this.parent.localeObj.getConstant('Min') },
            { value: 'Max', text: this.parent.localeObj.getConstant('Max') },
            { value: 'Index', text: this.parent.localeObj.getConstant('Index') },
            { value: 'SampleStDev', text: this.parent.localeObj.getConstant('SampleStDev') },
            { value: 'PopulationStDev', text: this.parent.localeObj.getConstant('PopulationStDev') },
            { value: 'SampleVar', text: this.parent.localeObj.getConstant('SampleVar') },
            { value: 'PopulationVar', text: this.parent.localeObj.getConstant('PopulationVar') },
            { value: 'RunningTotals', text: this.parent.localeObj.getConstant('RunningTotals') },
            { value: 'DifferenceFrom', text: this.parent.localeObj.getConstant('DifferenceFrom') },
            { value: 'PercentageOfDifferenceFrom', text: this.parent.localeObj.getConstant('PercentageOfDifferenceFrom') },
            { value: 'PercentageOfGrandTotal', text: this.parent.localeObj.getConstant('PercentageOfGrandTotal') },
            { value: 'PercentageOfColumnTotal', text: this.parent.localeObj.getConstant('PercentageOfColumnTotal') },
            { value: 'PercentageOfRowTotal', text: this.parent.localeObj.getConstant('PercentageOfRowTotal') },
            { value: 'PercentageOfParentTotal', text: this.parent.localeObj.getConstant('PercentageOfParentTotal') },
            { value: 'PercentageOfParentColumnTotal', text: this.parent.localeObj.getConstant('PercentageOfParentColumnTotal') },
            { value: 'PercentageOfParentRowTotal', text: this.parent.localeObj.getConstant('PercentageOfParentRowTotal') }
        ];
        let baseItemTypes = ['DifferenceFrom', 'PercentageOfDifferenceFrom'];
        let baseFieldTypes = ['DifferenceFrom', 'PercentageOfDifferenceFrom', 'PercentageOfParentTotal'];
        let dataFields = extend([], this.parent.dataSourceSettings.rows, null, true);
        dataFields = dataFields.concat(this.parent.dataSourceSettings.columns);
        let fieldDataSource = [];
        let fieldItemDataSource = [];
        // let summaryDataSource: { [key: string]: Object }[] = [];
        // for (let type of summaryTypes) {
        //     summaryDataSource.push({ value: type, text: type });
        // }
        for (let field of dataFields) {
            let value = field.name;
            let text = (field.caption ? field.caption : field.name);
            fieldDataSource.push({ value: value, text: text });
        }
        baseField = (baseField && (baseField.toString() !== 'undefined' && baseField.toString() !== 'null') ? baseField : fieldDataSource[0].value);
        fieldItemDataSource = Object.keys(this.parent.engineModule.fieldList[(baseField.toString() !== 'undefined' ?
            baseField : fieldDataSource[0].value)].formattedMembers);
        baseItem = (baseItem.toString() !== 'undefined' ? baseItem : fieldItemDataSource[0]);
        let mainDiv = createElement('div', {
            className: 'e-value-field-div-content', id: this.parentElement.id + '_field_div_content',
            attrs: { 'data-type': summaryType, 'data-caption': fieldCaption, 'data-basefield': baseField, 'data-baseitem': baseItem }
        });
        let textWrappper = createElement('div', { className: 'e-field-name-text-wrapper', });
        let filterWrapperDiv1 = createElement('div', { className: 'e-field-option-wrapper' });
        let optionWrapperDiv1 = createElement('div', { className: 'e-type-option-wrapper' });
        let optionWrapperDiv2 = createElement('div', { className: 'e-base-field-option-wrapper' });
        let optionWrapperDiv3 = createElement('div', { className: 'e-base-item-option-wrapper' });
        let texttitle = createElement('div', { className: 'e-field-name-title', innerHTML: this.parent.localeObj.getConstant('sourceName') + '&nbsp;' });
        let textContent = createElement('div', { className: 'e-field-name-content', innerHTML: buttonElement.id.toString() });
        let inputTextDiv1 = createElement('div', {
            className: 'e-type-option-text', innerHTML: this.parent.localeObj.getConstant('sourceCaption')
        });
        let optionTextDiv1 = createElement('div', {
            className: 'e-base-field-option-text', innerHTML: this.parent.localeObj.getConstant('summarizeValuesBy')
        });
        let optionTextDiv2 = createElement('div', {
            className: 'e-base-item-option-text', innerHTML: this.parent.localeObj.getConstant('baseField')
        });
        let optionTextDiv3 = createElement('div', {
            className: 'e-type-option-text', innerHTML: this.parent.localeObj.getConstant('baseItem')
        });
        let inputDiv1 = createElement('div', { className: 'e-caption-input-wrapper' });
        let dropOptionDiv1 = createElement('div', { id: this.parentElement.id + '_type_option' });
        let dropOptionDiv2 = createElement('div', { id: this.parentElement.id + '_base_field_option' });
        let dropOptionDiv3 = createElement('div', { id: this.parentElement.id + '_base_item_option' });
        let inputField1 = createElement('input', {
            id: this.parentElement.id + 'type_input_option',
            className: 'e-caption-input-text',
            attrs: { 'type': 'text' }
        });
        textWrappper.appendChild(texttitle);
        textWrappper.appendChild(textContent);
        inputDiv1.appendChild(inputTextDiv1);
        inputDiv1.appendChild(inputField1);
        optionWrapperDiv1.appendChild(optionTextDiv1);
        optionWrapperDiv2.appendChild(optionTextDiv2);
        optionWrapperDiv3.appendChild(optionTextDiv3);
        optionWrapperDiv1.appendChild(dropOptionDiv1);
        optionWrapperDiv2.appendChild(dropOptionDiv2);
        optionWrapperDiv3.appendChild(dropOptionDiv3);
        filterWrapperDiv1.appendChild(textWrappper);
        filterWrapperDiv1.appendChild(inputDiv1);
        filterWrapperDiv1.appendChild(optionWrapperDiv1);
        filterWrapperDiv1.appendChild(optionWrapperDiv2);
        filterWrapperDiv1.appendChild(optionWrapperDiv3);
        mainDiv.appendChild(filterWrapperDiv1);
        let popupInstance = this;
        let optionWrapper1 = new DropDownList({
            dataSource: summaryDataSource, enableRtl: this.parent.enableRtl,
            fields: { value: 'value', text: 'text' },
            value: summaryType,
            // popupWidth: 'auto',
            cssClass: VALUE_OPTIONS_CLASS, width: '100%',
            change(args) {
                optionWrapper2.enabled = baseFieldTypes.indexOf(args.value) !== -1 ? true : false;
                optionWrapper3.enabled = baseItemTypes.indexOf(args.value) !== -1 ? true : false;
                if (optionWrapper3.enabled && optionWrapper3.dataSource.length === 1) {
                    optionWrapper3.dataSource = fieldItemDataSource;
                    optionWrapper3.refresh();
                }
            }
        });
        optionWrapper1.isStringTemplate = true;
        optionWrapper1.appendTo(dropOptionDiv1);
        let optionWrapper2 = new DropDownList({
            dataSource: fieldDataSource, enableRtl: this.parent.enableRtl,
            fields: { value: 'value', text: 'text' },
            value: baseField,
            // popupWidth: 'auto',
            enabled: (baseFieldTypes.indexOf(summaryType) !== -1 ? true : false),
            cssClass: VALUE_OPTIONS_CLASS, width: '100%',
            change(args) {
                fieldItemDataSource = Object.keys(popupInstance.parent.engineModule.fieldList[args.value].formattedMembers);
                optionWrapper3.dataSource = fieldItemDataSource;
                optionWrapper3.value = fieldItemDataSource[0];
                optionWrapper3.filterBarPlaceholder = popupInstance.parent.localeObj.getConstant('example') + ' ' + fieldItemDataSource[0];
                optionWrapper3.refresh();
            }
        });
        optionWrapper2.isStringTemplate = true;
        optionWrapper2.appendTo(dropOptionDiv2);
        let optionWrapper3 = new DropDownList({
            dataSource: [fieldItemDataSource[0]], enableRtl: this.parent.enableRtl,
            value: baseItem,
            // popupWidth: 'auto',
            allowFiltering: true,
            filterBarPlaceholder: this.parent.localeObj.getConstant('example') + ' ' + fieldItemDataSource[0],
            enabled: (baseItemTypes.indexOf(summaryType) !== -1 ? true : false),
            cssClass: FILTER_OPERATOR_CLASS, width: '100%',
        });
        optionWrapper3.isStringTemplate = true;
        optionWrapper3.appendTo(dropOptionDiv3);
        let inputObj1 = new MaskedTextBox({
            placeholder: 'Enter field caption',
            // floatLabelType: 'Auto',
            enableRtl: this.parent.enableRtl,
            value: fieldCaption, width: '100%'
        });
        inputObj1.isStringTemplate = true;
        inputObj1.appendTo(inputField1);
        return mainDiv;
    }
    /* tslint:enable:all */
    selectOptionInContextMenu(menu) {
        if (menu.item.text !== null) {
            let buttonElement = this.currentMenu.parentElement;
            let type = menu.item.id.split('_').pop();
            if (type === 'MoreOption') {
                this.createValueSettingsDialog(buttonElement, this.parentElement);
            }
            else {
                let field = buttonElement.getAttribute('data-uid');
                let valuefields = this.parent.dataSourceSettings.values;
                let contentElement = buttonElement.querySelector('.e-content');
                let captionName = menu.item.text + ' ' + this.parent.localeObj.getConstant('of') + ' ' +
                    this.parent.engineModule.fieldList[field].caption;
                contentElement.innerHTML = captionName;
                contentElement.setAttribute('title', captionName);
                buttonElement.setAttribute('data-type', type);
                for (let vCnt = 0; vCnt < this.parent.dataSourceSettings.values.length; vCnt++) {
                    if (this.parent.dataSourceSettings.values[vCnt].name === field) {
                        /* tslint:disable:align */
                        let dataSourceItem = extend({}, valuefields[vCnt].properties ?
                            valuefields[vCnt].properties : valuefields[vCnt], null, true);
                        /* tslint:enable:align */
                        dataSourceItem.type = type;
                        this.parent.engineModule.fieldList[field].aggregateType = type;
                        valuefields.splice(vCnt, 1, dataSourceItem);
                        this.parent.lastAggregationInfo = dataSourceItem;
                    }
                }
                this.updateDataSource();
            }
        }
    }
    updateDataSource(isRefreshed) {
        if (!this.parent.allowDeferLayoutUpdate || this.parent.getModuleName() === 'pivotview') {
            this.parent.updateDataSource(isRefreshed);
        }
        else {
            if (this.parent.getModuleName() === 'pivotfieldlist' && this.parent.renderMode === 'Popup') {
                /* tslint:disable:align */
                this.parent.pivotGridModule.setProperties({
                    dataSourceSettings: this.parent.dataSourceSettings.properties
                }, true);
                this.parent.pivotGridModule.notify(uiUpdate, this);
                this.parent.pivotGridModule.engineModule = this.parent.engineModule;
            }
            else {
                this.parent.triggerPopulateEvent();
            }
        }
    }
    updateValueSettings() {
        let dialogElement = this.valueDialog.element;
        let captionInstance = getInstance('#' + this.parentElement.id + 'type_input_option', MaskedTextBox);
        let summaryInstance = getInstance('#' + this.parentElement.id + '_type_option', DropDownList);
        let baseFieldInstance = getInstance('#' + this.parentElement.id + '_base_field_option', DropDownList);
        let baseItemInstance = getInstance('#' + this.parentElement.id + '_base_item_option', DropDownList);
        let fieldName = dialogElement.getAttribute('data-field');
        let buttonElement;
        if (this.parentElement.querySelector('.' + PIVOT_BUTTON_CLASS)) {
            buttonElement = this.parentElement.
                querySelector('.' + PIVOT_BUTTON_CLASS + '.' + fieldName.replace(/[^A-Z0-9]/ig, ''));
        }
        if (buttonElement) {
            let contentElement = buttonElement.querySelector('.e-content');
            let captionName = this.parent.localeObj.getConstant(summaryInstance.value) + ' ' +
                this.parent.localeObj.getConstant('of') + ' ' + captionInstance.value;
            contentElement.innerHTML = captionName;
            contentElement.setAttribute('title', captionName);
            buttonElement.setAttribute('data-type', summaryInstance.value);
            buttonElement.setAttribute('data-caption', captionInstance.value);
            buttonElement.setAttribute('data-basefield', baseFieldInstance.value);
            buttonElement.setAttribute('data-baseitem', baseItemInstance.value);
        }
        let selectedField = PivotUtil.getFieldByName(fieldName, this.parent.dataSourceSettings.values);
        selectedField = selectedField.properties ?
            selectedField.properties : selectedField;
        selectedField.caption = captionInstance.value;
        selectedField.type = summaryInstance.value;
        selectedField.baseField = baseFieldInstance.value;
        selectedField.baseItem = baseItemInstance.value;
        this.valueDialog.close();
        // this.parent.axisFieldModule.render();
        this.parent.lastAggregationInfo = selectedField;
        this.updateDataSource(true);
    }
    removeDialog() {
        if (this.valueDialog && !this.valueDialog.isDestroyed) {
            this.valueDialog.destroy();
        }
        if (document.getElementById(this.parentElement.id + '_ValueDialog')) {
            remove(document.getElementById(this.parentElement.id + '_ValueDialog'));
        }
    }
    /**
     * To destroy the pivot button event listener
     * @return {void}
     * @hidden
     */
    destroy() {
        if (this.parent.isDestroyed) {
            return;
        }
        if (this.menuInfo) {
            if (this.menuInfo[1] !== undefined && !this.menuInfo[1].isDestroyed) {
                this.menuInfo[1].destroy();
            }
            if (this.menuInfo[0] !== undefined && !this.menuInfo[0].isDestroyed) {
                this.menuInfo[0].destroy();
            }
        }
        else {
            return;
        }
    }
}

/**
 * Module to render PivotGrid control
 */
/** @hidden */
class Render {
    /** Constructor for render module */
    constructor(parent) {
        /** @hidden */
        this.indentCollection = {};
        this.colPos = 0;
        this.lastSpan = 0;
        this.lvlCollection = {};
        this.hierarchyCollection = {};
        this.lvlPosCollection = {};
        this.hierarchyPosCollection = {};
        this.position = 0;
        this.measurePos = 0;
        this.maxMeasurePos = 0;
        this.hierarchyCount = 0;
        this.actualText = '';
        this.parent = parent;
        this.resColWidth = (this.parent.showGroupingBar && this.parent.groupingBarModule) ? (this.parent.isAdaptive ? 180 : 250) :
            (this.parent.isAdaptive ? 140 : 200);
        this.engine = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
        this.gridSettings = parent.gridSettings;
        this.formatList = this.getFormatList();
        this.aggMenu = new AggregateMenu(this.parent);
    }
    /** @hidden */
    /* tslint:disable */
    render() {
        let parent = this.parent;
        let engine = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
        this.parent.gridHeaderCellInfo = [];
        this.parent.gridCellCollection = {};
        this.injectGridModules(parent);
        this.rowStartPos = this.getRowStartPos();
        if (this.parent.grid && this.parent.grid.element && this.parent.element.querySelector('.e-grid')) {
            if (!engine.isEngineUpdated) {
                engine.headerContent = this.frameDataSource('header');
                engine.valueContent = this.frameDataSource('value');
            }
            else {
                if (this.parent.enableValueSorting) {
                    engine.valueContent = this.frameDataSource('value');
                }
                engine.isEngineUpdated = false;
            }
            /* tslint:disable */
            this.parent.grid.setProperties({
                columns: this.frameStackedHeaders(), dataSource: (this.parent.dataType === 'olap' ? true :
                    parent.dataSourceSettings.values.length > 0) && !this.engine.isEmptyData ? engine.valueContent :
                    this.frameDataSource('value')
            }, true);
            /* tslint:enable */
            this.parent.grid.notify('datasource-modified', {});
            if (this.parent.isScrolling) {
                this.parent.resizeInfo = {};
            }
            this.parent.grid.refreshColumns();
            if (this.parent.showGroupingBar && this.parent.groupingBarModule &&
                this.parent.element.querySelector('.' + GROUPING_BAR_CLASS)) {
                this.parent.groupingBarModule.setGridRowWidth();
            }
            let e = this.parent.element.querySelector('.e-movablecontent');
            e.querySelector('colGroup').innerHTML =
                this.parent.grid.getHeaderContent().querySelector('.e-movableheader').querySelector('colgroup').innerHTML;
            this.parent.grid.width = this.calculateGridWidth();
            if (!this.parent.isScrolling) {
                this.calculateGridHeight(true);
            }
            //this.parent.isScrolling = false;
        }
        else {
            this.parent.element.innerHTML = '';
            this.bindGrid(this.parent, (this.engine.isEmptyData ? true : false));
            this.parent.element.appendChild(createElement('div', { id: this.parent.element.id + '_grid' }));
            this.parent.grid.isStringTemplate = true;
            this.parent.grid.appendTo('#' + this.parent.element.id + '_grid');
        }
        /* tslint:disable */
        this.parent.grid.on(headerRefreshed, this.refreshHeader, this);
    }
    refreshHeader() {
        if (this.parent.enableVirtualization) {
            let mHdr = this.parent.element.querySelector('.' + MOVABLEHEADER_DIV);
            let mCont = this.parent.element.querySelector('.' + MOVABLECONTENT_DIV);
            let vtr = mCont.querySelector('.' + VIRTUALTRACK_DIV);
            this.parent.virtualHeaderDiv = mHdr.querySelector('.' + VIRTUALTRACK_DIV);
            if (mHdr.querySelector('.' + VIRTUALTRACK_DIV)) {
                remove(mHdr.querySelector('.' + VIRTUALTRACK_DIV));
            }
            else {
                this.parent.virtualHeaderDiv = createElement('div', { className: VIRTUALTRACK_DIV });
            }
            mHdr.appendChild(this.parent.virtualHeaderDiv);
            if (vtr) {
                setStyleAttribute(this.parent.virtualHeaderDiv, { height: 0, width: vtr.style.width });
            }
            setStyleAttribute(mHdr.querySelector('.e-table'), {
                transform: (mCont.querySelector('.e-table').style.transform).split(',')[0] + ',' + 0 + 'px)'
            });
            mHdr.scrollLeft = mCont.scrollLeft;
        }
    }
    /** @hidden */
    bindGrid(parent, isEmpty) {
        this.injectGridModules(parent);
        this.parent.grid = new Grid({
            frozenColumns: 1,
            frozenRows: 0,
            dataSource: isEmpty ? this.frameEmptyData() : this.frameDataSource('value'),
            columns: isEmpty ? this.frameEmptyColumns() : this.frameStackedHeaders(),
            height: isEmpty ? 'auto' : this.calculateGridHeight(),
            width: isEmpty ? this.parent.width : this.calculateGridWidth(),
            locale: parent.locale,
            enableRtl: parent.enableRtl,
            allowExcelExport: parent.allowExcelExport,
            allowPdfExport: parent.allowPdfExport,
            allowResizing: this.gridSettings.allowResizing,
            allowTextWrap: this.gridSettings.allowTextWrap,
            allowReordering: (this.parent.showGroupingBar ? false : this.gridSettings.allowReordering),
            allowSelection: this.gridSettings.allowSelection,
            /* tslint:disable-next-line */
            contextMenuItems: this.gridSettings.contextMenuItems,
            selectedRowIndex: this.gridSettings.selectedRowIndex,
            /* tslint:disable-next-line */
            selectionSettings: this.gridSettings.selectionSettings,
            textWrapSettings: this.gridSettings.textWrapSettings,
            printMode: this.gridSettings.printMode,
            rowHeight: this.gridSettings.rowHeight,
            gridLines: this.gridSettings.gridLines,
            contextMenuClick: this.contextMenuClick.bind(this),
            contextMenuOpen: this.contextMenuOpen.bind(this),
            beforeCopy: this.gridSettings.beforeCopy ? this.gridSettings.beforeCopy.bind(this.parent) : undefined,
            beforePrint: this.gridSettings.beforePrint ? this.gridSettings.beforePrint.bind(this.parent) : undefined,
            printComplete: this.gridSettings.printComplete ? this.gridSettings.printComplete.bind(this.parent) : undefined,
            rowSelecting: this.gridSettings.rowSelecting ? this.gridSettings.rowSelecting.bind(this.parent) : undefined,
            rowSelected: this.rowSelected.bind(this),
            rowDeselecting: this.gridSettings.rowDeselecting ? this.gridSettings.rowDeselecting.bind(this.parent) : undefined,
            rowDeselected: this.rowDeselected.bind(this),
            cellSelecting: this.gridSettings.cellSelecting ? this.gridSettings.cellSelecting.bind(this.parent) : undefined,
            cellSelected: this.cellSelected.bind(this),
            cellDeselecting: this.gridSettings.cellDeselecting ? this.gridSettings.cellDeselecting.bind(this.parent) : undefined,
            cellDeselected: this.cellDeselected.bind(this),
            resizeStart: this.gridSettings.resizeStart ? this.gridSettings.resizeStart.bind(this.parent) : undefined,
            columnDragStart: this.gridSettings.columnDragStart ? this.gridSettings.columnDragStart.bind(this) : undefined,
            columnDrag: this.gridSettings.columnDrag ? this.gridSettings.columnDrag.bind(this) : undefined,
            columnDrop: this.gridSettings.columnDrop ? this.gridSettings.columnDrop.bind(this) : undefined,
            beforeExcelExport: this.beforeExcelExport.bind(this),
            resizing: this.setGroupWidth.bind(this),
            resizeStop: this.onResizeStop.bind(this),
            queryCellInfo: this.queryCellInfo.bind(this),
            dataBound: this.dataBound.bind(this),
            headerCellInfo: this.headerCellInfo.bind(this),
            excelHeaderQueryCellInfo: this.excelHeaderQueryCellInfo.bind(this),
            pdfHeaderQueryCellInfo: this.pdfHeaderQueryCellInfo.bind(this),
            excelQueryCellInfo: this.excelQueryCellInfo.bind(this),
            pdfQueryCellInfo: this.pdfQueryCellInfo.bind(this),
            beforePdfExport: this.gridSettings.beforePdfExport ? this.gridSettings.beforePdfExport.bind(this) : undefined
        });
        if (isBlazor()) {
            let isJsComponent = 'isJsComponent';
            /* tslint:disable-next-line */
            this.parent.grid[isJsComponent] = true;
        }
        this.parent.grid.on('header-refreshed', this.headerRefreshed.bind(this));
    }
    /* tslint:disable-next-line */
    headerRefreshed(args) {
        if (this.parent.lastGridSettings && Object.keys(this.parent.lastGridSettings).indexOf('allowResizing') > -1) {
            this.parent.lastGridSettings = undefined;
            if (this.parent.showGroupingBar && this.parent.groupingBarModule &&
                this.parent.element.querySelector('.' + GROUPING_BAR_CLASS)) {
                this.parent.groupingBarModule.setGridRowWidth();
            }
        }
    }
    /* tslint:disable-next-line */
    beforeExcelExport(args) {
        if (!isNullOrUndefined(args.gridObject.columns) && !isNullOrUndefined(this.parent.pivotColumns)) {
            args.gridObject.columns[args.gridObject.columns.length - 1].width =
                this.parent.pivotColumns[this.parent.pivotColumns.length - 1].width;
        }
        this.parent.trigger(beforeExcelExport, args);
    }
    rowSelected(args) {
        this.parent.renderModule.selected();
        this.parent.trigger(rowSelected, args);
    }
    rowDeselected(args) {
        this.parent.renderModule.selected();
        this.parent.trigger(rowDeselected, args);
    }
    cellSelected(args) {
        if (this.parent.rowRangeSelection.enable) {
            this.parent.grid.selectionModule.selectRowsByRange(this.parent.rowRangeSelection.startIndex, this.parent.rowRangeSelection.endIndex);
            this.parent.rowRangeSelection.enable = false;
        }
        else {
            this.parent.renderModule.selected();
            this.parent.trigger(selected, args);
        }
    }
    cellSelecting(args) {
        this.parent.trigger(cellSelecting, args);
    }
    cellDeselected(args) {
        this.parent.renderModule.selected();
        this.parent.trigger(cellDeselected, args);
    }
    queryCellInfo(args) {
        this.parent.renderModule.rowCellBoundEvent(args);
    }
    headerCellInfo(args) {
        this.parent.renderModule.columnCellBoundEvent(args);
    }
    excelHeaderQueryCellInfo(args) {
        this.parent.renderModule.excelColumnEvent(args);
    }
    pdfQueryCellInfo(args) {
        this.parent.renderModule.pdfRowEvent(args);
    }
    excelQueryCellInfo(args) {
        this.parent.renderModule.excelRowEvent(args);
    }
    pdfHeaderQueryCellInfo(args) {
        this.parent.renderModule.pdfColumnEvent(args);
    }
    dataBound(args) {
        if (this.parent.cellTemplate && !isBlazor()) {
            for (let cell of this.parent.gridHeaderCellInfo) {
                if (this.parent.cellTemplate) {
                    /* tslint:disable-next-line */
                    let element = this.parent.getCellTemplate()(cell, this.parent, 'cellTemplate', this.parent.element.id + '_cellTemplate');
                    if (element && element !== '' && element.length > 0) {
                        if (this.parent.enableHtmlSanitizer) {
                            this.parent.appendHtml(cell.targetCell, SanitizeHtmlHelper.sanitize(element[0].outerHTML));
                        }
                        else {
                            this.parent.appendHtml(cell.targetCell, element[0].outerHTML);
                        }
                    }
                }
            }
            this.parent.gridHeaderCellInfo = [];
        }
        if (this.parent.element.querySelector('.e-firstcell')) {
            if (this.parent.enableRtl) {
                this.parent.element.querySelector('.e-firstcell').style.borderRight = 'none';
            }
            else {
                this.parent.element.querySelector('.e-firstcell').style.borderLeft = 'none';
            }
        }
        this.parent.grid.widthService.setWidthToTable();
        /* tslint:disable-next-line */
        if (!this.parent.isEmptyGrid) {
            this.calculateGridHeight(true);
        }
        if (this.parent.currentView !== 'Chart') {
            this.parent.grid.hideScroll();
        }
        this.parent.isScrolling = false;
        this.parent.notify(contentReady, {});
    }
    /* tslint:disable */
    /* tslint:disable:typedef */
    contextMenuOpen(args) {
        for (let item of args.items) {
            let cellTarget = this.parent.lastCellClicked;
            let elem = null;
            let bool;
            let isGroupElement;
            if (cellTarget.classList.contains('e-stackedheadercelldiv') || cellTarget.classList.contains('e-cellvalue') ||
                cellTarget.classList.contains('e-headercelldiv') || cellTarget.classList.contains('e-icons') || cellTarget.classList.contains('e-rhandler')) {
                elem = cellTarget.parentElement;
            }
            else if (cellTarget.classList.contains('e-headercell') || cellTarget.classList.contains('e-rowcell') || cellTarget.classList.contains('e-columnsheader') ||
                cellTarget.classList.contains('e-rowsheader') || cellTarget.classList.contains('e-valuescontent') || cellTarget.classList.contains('e-valuesheader')) {
                elem = cellTarget;
            }
            else if (cellTarget.classList.contains('e-headertext')) {
                elem = cellTarget.parentElement.parentElement;
            }
            if (!elem) {
                args.cancel = true;
                return;
            }
            if (elem.classList.contains('e-valuesheader') || elem.classList.contains('e-stot')) {
                bool = true;
            }
            if (this.parent.allowGrouping && this.parent.groupingModule && !this.validateField(elem)) {
                isGroupElement = true;
            }
            let rowIndex = Number(elem.getAttribute('index'));
            let colIndex = Number(elem.getAttribute('aria-colindex'));
            let pivotValue1 = this.parent.pivotValues[rowIndex][colIndex];
            let select = item.id;
            switch (select) {
                case this.parent.element.id + '_expand':
                    if (elem.querySelectorAll('.' + EXPAND).length > 0) {
                        if (args.element.querySelectorAll('#' + this.parent.element.id + '_expand')) {
                            args.element.querySelector('#' + this.parent.element.id + '_expand').classList.add(MENU_DISABLE);
                        }
                        if (args.element.querySelector('#' + this.parent.element.id + '_expand').classList.contains(MENU_DISABLE)) {
                            args.element.querySelector('#' + this.parent.element.id + '_expand').classList.remove(MENU_DISABLE);
                        }
                        if (args.element.querySelector('#' + this.parent.element.id + '_expand').classList.contains(MENU_HIDE)) {
                            args.element.querySelector('#' + this.parent.element.id + '_expand').classList.remove(MENU_HIDE);
                            args.element.querySelector('#' + this.parent.element.id + '_collapse').classList.remove(MENU_HIDE);
                        }
                    }
                    else {
                        if (bool) {
                            args.element.querySelector('#' + this.parent.element.id + '_expand').classList.add(MENU_HIDE);
                        }
                        else {
                            args.element.querySelector('#' + this.parent.element.id + '_expand').classList.add(MENU_DISABLE);
                        }
                    }
                    break;
                case this.parent.element.id + '_collapse':
                    if (elem.querySelectorAll('.' + COLLAPSE).length > 0) {
                        if (args.element.querySelector('#' + this.parent.element.id + '_expand')) {
                            args.element.querySelector('#' + this.parent.element.id + '_expand').classList.add(MENU_DISABLE);
                        }
                        if (args.element.querySelector('#' + this.parent.element.id + '_collapse').classList.contains(MENU_DISABLE)) {
                            args.element.querySelector('#' + this.parent.element.id + '_collapse').classList.remove(MENU_DISABLE);
                        }
                        if (args.element.querySelector('#' + this.parent.element.id + '_collapse').classList.contains(MENU_HIDE)) {
                            args.element.querySelector('#' + this.parent.element.id + '_collapse').classList.remove(MENU_HIDE);
                            args.element.querySelector('#' + this.parent.element.id + '_expand').classList.remove(MENU_HIDE);
                        }
                    }
                    else {
                        if (bool) {
                            args.element.querySelector('#' + this.parent.element.id + '_collapse').classList.add(MENU_HIDE);
                        }
                        else {
                            args.element.querySelector('#' + this.parent.element.id + '_collapse').classList.add(MENU_DISABLE);
                        }
                    }
                    break;
                case this.parent.element.id + '_custom_group':
                    if (!isGroupElement && args.items.length == 2) {
                        args.cancel = true;
                    }
                    if (args.element.querySelectorAll('#' + this.parent.element.id + '_custom_group')) {
                        addClass([args.element.querySelector('#' + this.parent.element.id + '_custom_group')], MENU_HIDE);
                    }
                    if (isGroupElement) {
                        if (args.element.querySelectorAll('#' + this.parent.element.id + '_custom_group')) {
                            removeClass([args.element.querySelector('#' + this.parent.element.id + '_custom_group')], MENU_HIDE);
                        }
                    }
                    break;
                case this.parent.element.id + '_custom_ungroup':
                    if (args.element.querySelectorAll('#' + this.parent.element.id + '_custom_ungroup')) {
                        addClass([args.element.querySelector('#' + this.parent.element.id + '_custom_ungroup')], MENU_HIDE);
                    }
                    if (isGroupElement) {
                        let isUngroupOption = false;
                        let fieldName = elem.getAttribute('fieldname');
                        let groupField = PivotUtil.getFieldByName(fieldName, this.parent.dataSourceSettings.groupSettings);
                        if (groupField && groupField.type === 'Custom' || (this.parent.engineModule.fieldList[fieldName].isCustomField && fieldName.indexOf('_custom_group') > -1)) {
                            groupField = PivotUtil.getFieldByName(fieldName.replace('_custom_group', ''), this.parent.dataSourceSettings.groupSettings);
                            if (groupField) {
                                let cell = this.parent.engineModule.pivotValues[Number(elem.getAttribute('index'))][Number(elem.getAttribute('aria-colindex'))];
                                let selectedCellsInfo = this.parent.groupingModule.getSelectedCells(cell.axis, fieldName, cell.actualText.toString());
                                selectedCellsInfo.push({ axis: cell.axis, fieldName: fieldName, name: cell.actualText.toString(), cellInfo: cell });
                                let selectedOptions = this.parent.groupingModule.getSelectedOptions(selectedCellsInfo);
                                for (let customGroup of groupField.customGroups) {
                                    if (selectedOptions.indexOf(customGroup.groupName) > -1) {
                                        isUngroupOption = true;
                                        break;
                                    }
                                }
                            }
                        }
                        else if (groupField && (groupField.type === 'Date' || groupField.type === 'Number') ||
                            (this.parent.engineModule.fieldList[fieldName].isCustomField && fieldName.indexOf('_date_group') > -1)) {
                            isUngroupOption = true;
                        }
                        if (args.element.querySelectorAll('#' + this.parent.element.id + '_custom_ungroup') && isUngroupOption) {
                            removeClass([args.element.querySelector('#' + this.parent.element.id + '_custom_ungroup')], MENU_HIDE);
                        }
                    }
                    break;
                case this.parent.element.id + '_drillthrough':
                    if (!this.parent.allowDrillThrough) {
                        if (args.element.querySelector('#' + this.parent.element.id + '_drillthrough')) {
                            args.element.querySelector('#' + this.parent.element.id + '_drillthrough').classList.add(MENU_DISABLE);
                        }
                    }
                    else if (!(elem.classList.contains('e-summary'))) {
                        if (elem.innerText === "") {
                            if (args.element.querySelector('#' + this.parent.element.id + '_drillthrough')) {
                                args.element.querySelector('#' + this.parent.element.id + '_drillthrough').classList.add(MENU_DISABLE);
                            }
                        }
                    }
                    else {
                        if (args.element.querySelector('#' + this.parent.element.id + '_drillthrough').classList.contains(MENU_DISABLE)) {
                            args.element.querySelector('#' + this.parent.element.id + '_drillthrough').classList.remove(MENU_DISABLE);
                        }
                    }
                    break;
                case this.parent.element.id + '_sortasc':
                    if (!this.parent.enableValueSorting) {
                        if (args.element.querySelector('#' + this.parent.element.id + '_sortasc')) {
                            args.element.querySelector('#' + this.parent.element.id + '_sortasc').classList.add(MENU_DISABLE);
                        }
                    }
                    else if (elem.querySelectorAll('.e-icon-descending').length > 0) {
                        if (args.element.querySelector('#' + this.parent.element.id + '_sortdesc')) {
                            args.element.querySelector('#' + this.parent.element.id + '_sortdesc').classList.add(MENU_DISABLE);
                        }
                        else {
                            args.element.querySelector('#' + this.parent.element.id + '_sortdesc').classList.remove(MENU_DISABLE);
                        }
                        if (args.element.querySelector('#' + this.parent.element.id + '_sortasc').classList.contains(MENU_DISABLE)) {
                            args.element.querySelector('#' + this.parent.element.id + '_sortasc').classList.remove(MENU_DISABLE);
                        }
                    }
                    else if (args.element.querySelector('#' + this.parent.element.id + '_sortdesc').classList.contains(MENU_DISABLE)) {
                        args.element.querySelector('#' + this.parent.element.id + '_sortdesc').classList.remove(MENU_DISABLE);
                    }
                    break;
                case this.parent.element.id + '_sortdesc':
                    if (!this.parent.enableValueSorting) {
                        if (args.element.querySelector('#' + this.parent.element.id + '_sortdesc')) {
                            args.element.querySelector('#' + this.parent.element.id + '_sortdesc').classList.add(MENU_DISABLE);
                        }
                    }
                    else if (elem.querySelectorAll('.e-icon-ascending').length > 0) {
                        if (args.element.querySelector('#' + this.parent.element.id + '_sortasc')) {
                            args.element.querySelector('#' + this.parent.element.id + '_sortasc').classList.add(MENU_DISABLE);
                        }
                        else {
                            args.element.querySelector('#' + this.parent.element.id + '_sortasc').classList.remove(MENU_DISABLE);
                        }
                        if (args.element.querySelector('#' + this.parent.element.id + '_sortdesc').classList.contains(MENU_DISABLE)) {
                            args.element.querySelector('#' + this.parent.element.id + '_sortdesc').classList.remove(MENU_DISABLE);
                        }
                    }
                    else if (args.element.querySelector('#' + this.parent.element.id + '_sortasc').classList.contains(MENU_DISABLE)) {
                        args.element.querySelector('#' + this.parent.element.id + '_sortasc').classList.remove(MENU_DISABLE);
                    }
                    break;
                case this.parent.element.id + '_CalculatedField':
                    if (!this.parent.allowCalculatedField) {
                        args.element.querySelector('#' + this.parent.element.id + '_CalculatedField').classList.add(MENU_DISABLE);
                    }
                    break;
                case this.parent.element.id + '_pdf':
                    if (!this.parent.allowPdfExport) {
                        args.element.querySelector('#' + this.parent.element.id + '_pdf').classList.add(MENU_DISABLE);
                    }
                    break;
                case this.parent.element.id + '_excel':
                    if (!this.parent.allowExcelExport) {
                        args.element.querySelector('#' + this.parent.element.id + '_excel').classList.add(MENU_DISABLE);
                    }
                    break;
                case this.parent.element.id + '_csv':
                    if (!this.parent.allowExcelExport) {
                        args.element.querySelector('#' + this.parent.element.id + '_csv').classList.add(MENU_DISABLE);
                    }
                    break;
                case this.parent.element.id + '_exporting':
                    if ((!this.parent.allowExcelExport) && (!this.parent.allowPdfExport)) {
                        args.element.querySelector('#' + this.parent.element.id + '_exporting').classList.add(MENU_DISABLE);
                    }
                    break;
                case this.parent.element.id + '_aggregate':
                    if (elem.innerText === "") {
                        if (args.element.querySelector('#' + this.parent.element.id + '_aggregate')) {
                            args.element.querySelector('#' + this.parent.element.id + '_aggregate').classList.add(MENU_DISABLE);
                        }
                    }
                    else {
                        if (args.element.querySelector('#' + this.parent.element.id + '_aggregate').classList.contains(MENU_DISABLE)) {
                            args.element.querySelector('#' + this.parent.element.id + '_aggregate').classList.remove(MENU_DISABLE);
                        }
                    }
                    break;
            }
        }
        this.parent.trigger(contextMenuOpen, args);
    }
    contextMenuClick(args) {
        // this.parent.gridSettings.contextMenuClick();
        let target = this.parent.lastCellClicked;
        let selected$$1 = args.item.id;
        let event = new MouseEvent('dblclick', {
            'view': window,
            'bubbles': true,
            'cancelable': true
        });
        let ele = null;
        if (target.classList.contains('e-stackedheadercelldiv') || target.classList.contains('e-cellvalue') ||
            target.classList.contains('e-headercelldiv') || target.classList.contains('e-icons') || target.classList.contains('e-rhandler')) {
            ele = target.parentElement;
        }
        else if (target.classList.contains('e-headercell') || target.classList.contains('e-rowcell')) {
            ele = target;
        }
        else if (target.classList.contains('e-headertext')) {
            ele = target.parentElement.parentElement;
        }
        let rowIndx = Number(ele.getAttribute('index'));
        let colIndx = Number(ele.getAttribute('aria-colindex'));
        let pivotValue = this.parent.pivotValues[rowIndx][colIndx];
        if (args.item.id === this.parent.element.id + '_AggSum' || args.item.id === this.parent.element.id + '_AggProduct' ||
            args.item.id === this.parent.element.id + '_AggCount' || args.item.id === this.parent.element.id + '_AggDistinctCount' ||
            args.item.id === this.parent.element.id + '_AggAvg' || args.item.id === this.parent.element.id + '_AggMin' ||
            args.item.id === this.parent.element.id + '_AggMax' || args.item.id === this.parent.element.id + '_AggMoreOption') {
            this.field = this.parent.engineModule.fieldList[pivotValue.actualText.toString()].id;
            this.fieldCaption = this.parent.engineModule.fieldList[pivotValue.actualText.toString()].caption;
        }
        switch (selected$$1) {
            case this.parent.element.id + '_pdf':
                this.parent.pdfExport();
                break;
            case this.parent.element.id + '_excel':
                this.parent.excelExport();
                break;
            case this.parent.element.id + '_csv':
                this.parent.csvExport();
                break;
            case this.parent.element.id + '_drillthrough_menu':
                ele.dispatchEvent(event);
                break;
            case this.parent.element.id + '_sortasc':
                this.parent.setProperties({
                    dataSourceSettings: {
                        valueSortSettings: {
                            headerText: pivotValue.valueSort.levelName,
                            headerDelimiter: this.parent.dataSourceSettings.valueSortSettings.headerDelimiter
                        }
                    }
                });
                this.parent.dataSourceSettings.valueSortSettings.sortOrder = 'Ascending';
                break;
            case this.parent.element.id + '_sortdesc':
                this.parent.setProperties({
                    dataSourceSettings: {
                        valueSortSettings: {
                            headerText: pivotValue.valueSort.levelName,
                            headerDelimiter: this.parent.dataSourceSettings.valueSortSettings.headerDelimiter
                        }
                    }
                });
                this.parent.dataSourceSettings.valueSortSettings.sortOrder = 'Descending';
                break;
            case this.parent.element.id + '_expand':
                if (ele.querySelectorAll('.' + EXPAND)) {
                    let exp = ele.querySelectorAll('.' + EXPAND)[0];
                    this.parent.onDrill(exp);
                }
                break;
            case this.parent.element.id + '_collapse':
                if (ele.querySelectorAll('.' + COLLAPSE)) {
                    let colp = ele.querySelectorAll('.' + COLLAPSE)[0];
                    this.parent.onDrill(colp);
                }
                break;
            case this.parent.element.id + '_CalculatedField':
                this.parent.calculatedFieldModule.createCalculatedFieldDialog();
                break;
            case this.parent.element.id + '_AggSum':
                this.updateAggregate('Sum');
                break;
            case this.parent.element.id + '_AggProduct':
                this.updateAggregate('Product');
                break;
            case this.parent.element.id + '_AggCount':
                this.updateAggregate('Count');
                break;
            case this.parent.element.id + '_AggDistinctCount':
                this.updateAggregate('DistinctCount');
                break;
            case this.parent.element.id + '_AggAvg':
                this.updateAggregate('Avg');
                break;
            case this.parent.element.id + '_AggMin':
                this.updateAggregate('Min');
                break;
            case this.parent.element.id + '_AggMax':
                this.updateAggregate('Max');
                break;
            case this.parent.element.id + '_AggMoreOption':
                ele.setAttribute('id', this.field);
                ele.setAttribute('data-caption', this.fieldCaption);
                ele.setAttribute('data-field', this.field);
                ele.setAttribute('data-type', this.engine.fieldList[pivotValue.actualText.toString()].aggregateType);
                ele.setAttribute('data-basefield', this.engine.fieldList[pivotValue.actualText.toString()].baseField);
                ele.setAttribute('data-baseItem', this.engine.fieldList[pivotValue.actualText.toString()].baseItem);
                this.aggMenu.createValueSettingsDialog(ele, this.parent.element);
                break;
            case this.parent.element.id + '_custom_group':
            case this.parent.element.id + '_custom_ungroup':
                if (this.parent.groupingModule) {
                    let args = {
                        target: ele,
                        option: selected$$1,
                        parentElement: this.parent.element
                    };
                    this.parent.notify(initGrouping, args);
                    this.parent.grid.contextMenuModule.contextMenu.close();
                }
                break;
        }
        this.parent.trigger(contextMenuClick, args);
    }
    validateField(target) {
        let isValueField = false;
        if (target.classList.contains('e-stot') || target.classList.contains('e-gtot') || target.classList.contains('e-valuescontent') || target.classList.contains('e-valuesheader')) {
            isValueField = true;
        }
        else {
            let fieldName = target.getAttribute('fieldName');
            if (!fieldName || fieldName == '') {
                let rowIndx = Number(target.getAttribute('index'));
                let colIndx = Number(target.getAttribute('aria-colindex'));
                fieldName = this.engine.pivotValues[rowIndx][colIndx].actualText;
            }
            let valuefields = this.parent.dataSourceSettings.values;
            for (let valueCnt = 0; valueCnt < valuefields.length; valueCnt++) {
                if (this.parent.dataSourceSettings.values[valueCnt].name === fieldName) {
                    isValueField = true;
                    break;
                }
            }
        }
        return isValueField;
    }
    /* tslint:enable */
    updateAggregate(aggregate) {
        let valuefields = this.parent.dataSourceSettings.values;
        for (let valueCnt = 0; valueCnt < this.parent.dataSourceSettings.values.length; valueCnt++) {
            if (this.parent.dataSourceSettings.values[valueCnt].name === this.field) {
                let dataSourceItem = valuefields[valueCnt];
                dataSourceItem.type = aggregate;
            }
        }
    }
    injectGridModules(parent) {
        Grid.Inject(Freeze);
        if (parent.allowExcelExport) {
            Grid.Inject(ExcelExport);
        }
        if (parent.allowPdfExport) {
            Grid.Inject(PdfExport);
        }
        Grid.Inject(Selection, Reorder, Resize);
        if (this.gridSettings.contextMenuItems) {
            Grid.Inject(ContextMenu);
        }
    }
    /** @hidden */
    updateGridSettings() {
        this.injectGridModules(this.parent);
        this.parent.grid.allowResizing = this.gridSettings.allowResizing;
        this.parent.grid.allowTextWrap = this.gridSettings.allowTextWrap;
        this.parent.grid.allowReordering = (this.parent.showGroupingBar ? false : this.gridSettings.allowReordering);
        this.parent.grid.allowSelection = this.gridSettings.allowSelection;
        /* tslint:disable-next-line */
        this.parent.grid.contextMenuItems = this.gridSettings.contextMenuItems;
        this.parent.grid.selectedRowIndex = this.gridSettings.selectedRowIndex;
        /* tslint:disable-next-line */
        this.parent.grid.selectionSettings = this.gridSettings.selectionSettings;
        this.parent.grid.textWrapSettings = this.gridSettings.textWrapSettings;
        this.parent.grid.printMode = this.gridSettings.printMode;
        this.parent.grid.rowHeight = this.gridSettings.rowHeight;
        this.parent.grid.gridLines = this.gridSettings.gridLines;
        if (this.parent.lastGridSettings) {
            let keys = Object.keys(this.parent.lastGridSettings);
            if (keys.indexOf('height') > -1) {
                this.parent.grid.height = this.gridSettings.height;
            }
            if (keys.indexOf('width') > -1) {
                this.parent.grid.width = this.gridSettings.width;
            }
            this.updatePivotColumns();
            if (keys.indexOf('allowTextWrap') > -1) {
                this.parent.layoutRefresh();
            }
        }
        this.clearColumnSelection();
    }
    updatePivotColumns() {
        let keys = Object.keys(this.parent.lastGridSettings);
        for (let colPos = 0; colPos < this.parent.pivotColumns.length; colPos++) {
            let pivotColumn = this.parent.pivotColumns[colPos];
            for (let keyPos = 0; keyPos < keys.length; keyPos++) {
                let key = keys[keyPos];
                /* tslint:disable-next-line */
                if (!isNullOrUndefined(this.parent.pivotColumns[colPos][key])) {
                    /* tslint:disable-next-line */
                    pivotColumn[key] = this.parent.lastGridSettings[key];
                }
            }
        }
        this.parent.fillGridColumns(this.parent.grid.columns);
    }
    clearColumnSelection() {
        removeClass(this.parent.element.querySelectorAll('.' + CELL_ACTIVE_BGCOLOR), [CELL_ACTIVE_BGCOLOR, SELECTED_BGCOLOR]);
    }
    appendValueSortIcon(cell, tCell, rCnt, cCnt) {
        if (this.parent.enableValueSorting && this.parent.dataType === 'pivot') {
            let vSort = this.parent.dataSourceSettings.valueSortSettings;
            let len = (cell.type === 'grand sum' &&
                this.parent.dataSourceSettings.values.length === 1 && !this.parent.dataSourceSettings.alwaysShowValueHeader) ? 0 :
                (this.parent.dataSourceSettings.values.length > 1 || this.parent.dataSourceSettings.alwaysShowValueHeader) ?
                    (this.parent.engineModule.headerContent.length - 1) :
                    this.parent.dataSourceSettings.columns.length === 0 ? 0 : (this.parent.engineModule.headerContent.length - 1);
            let lock = (vSort && vSort.headerText) ? cell.valueSort.levelName === vSort.headerText : cCnt === vSort.columnIndex;
            if (vSort !== undefined && lock && rCnt === len && this.parent.dataSourceSettings.valueAxis === 'column') {
                if (tCell.querySelector('.e-sortfilterdiv')) {
                    tCell.querySelector('.e-sortfilterdiv').classList.add(vSort.sortOrder === 'Descending' ?
                        'e-descending' : 'e-ascending');
                    tCell.querySelector('.e-sortfilterdiv').classList.add(vSort.sortOrder === 'Descending' ?
                        'e-icon-descending' : 'e-icon-ascending');
                }
                else {
                    tCell.appendChild(createElement('div', {
                        className: (vSort.sortOrder === 'Descending' ?
                            'e-icon-descending e-icons e-descending e-sortfilterdiv' :
                            'e-icon-ascending e-icons e-ascending e-sortfilterdiv'),
                    }));
                }
                if (!isNullOrUndefined(cell.hasChild) && cell.type !== 'grand sum' && tCell.querySelector('.e-expand') &&
                    (tCell.querySelector('.e-icon-descending') || tCell.querySelector('.e-icon-ascending'))) {
                    let element = (tCell.querySelector('.e-icon-descending') || tCell.querySelector('.e-icon-ascending'));
                    setStyleAttribute(element, { 'padding-top': '12px' });
                }
            }
            // return tCell;
        }
        return tCell;
    }
    onResizeStop(args) {
        /* tslint:disable-next-line */
        let column = args.column.field === '0.formattedText' ? '0.formattedText' : args.column.customAttributes.cell.valueSort.levelName;
        this.parent.resizeInfo[column] = Number(args.column.width.toString().split('px')[0]);
        this.setGroupWidth(args);
        this.calculateGridHeight(true);
        this.parent.grid.hideScroll();
    }
    setGroupWidth(args) {
        if (this.parent.showGroupingBar && this.parent.groupingBarModule &&
            this.parent.element.querySelector('.' + GROUPING_BAR_CLASS)) {
            this.parent.groupingBarModule.refreshUI();
            if (this.parent.element.querySelector('.e-group-row').offsetWidth < 245 && !this.parent.firstColWidth) {
                args.cancel = true;
                let gridColumn = this.parent.grid.columns;
                if (gridColumn && gridColumn.length > 0) {
                    gridColumn[0].width = this.resColWidth;
                }
                this.parent.element.querySelector('.e-frozenheader').querySelector('col').style.width = (this.resColWidth + 'px');
                this.parent.element.querySelector('.e-frozencontent').querySelector('col').style.width = (this.resColWidth + 'px');
            }
            this.parent.element.querySelector('.e-group-rows').style.height = 'auto';
            this.parent.element.querySelector('.e-group-values').style.width =
                this.parent.element.querySelector('.e-group-row').offsetWidth + 'px';
            let firstRowHeight = this.parent.element.querySelector('.e-headercontent').offsetHeight;
            this.parent.element.querySelector('.e-group-rows').style.height = firstRowHeight + 'px';
        }
        this.parent.trigger(args.e.type === 'touchend' || args.e.type === 'mouseup' ? resizeStop : resizing, args);
    }
    /* tslint:disable */
    /** @hidden */
    selected() {
        clearTimeout(this.timeOutObj);
        this.timeOutObj = setTimeout(this.onSelect.bind(this), 300);
    }
    onSelect() {
        let pivotArgs = { selectedCellsInfo: [], pivotValues: this.parent.pivotValues, currentCell: null };
        /* tslint:disable-next-line */
        let selectedElements = this.parent.element.querySelectorAll('.' + CELL_SELECTED_BGCOLOR + ',.' + SELECTED_BGCOLOR);
        for (let element of selectedElements) {
            let colIndex = Number(element.getAttribute('aria-colindex'));
            let rowIndex = Number(element.getAttribute('index'));
            let cell = this.engine.pivotValues[rowIndex][colIndex];
            if (cell) {
                if (cell.axis === 'value') {
                    pivotArgs.selectedCellsInfo.push({
                        currentCell: cell,
                        value: cell.value,
                        columnHeaders: cell.columnHeaders,
                        rowHeaders: cell.rowHeaders,
                        measure: cell.actualText.toString()
                    });
                }
                else if (cell.axis === 'column') {
                    pivotArgs.selectedCellsInfo.push({
                        currentCell: cell,
                        value: cell.formattedText,
                        columnHeaders: cell.valueSort.levelName,
                        rowHeaders: '',
                        measure: ''
                    });
                }
                else {
                    pivotArgs.selectedCellsInfo.push({
                        currentCell: cell,
                        value: cell.formattedText,
                        columnHeaders: '',
                        rowHeaders: cell.valueSort.levelName,
                        measure: ''
                    });
                }
            }
        }
        this.parent.trigger(cellSelected, pivotArgs);
    }
    rowCellBoundEvent(args) {
        let tCell = args.cell;
        /* tslint:disable-next-line */
        if (tCell && !this.parent.isEmptyGrid) {
            let customClass = this.parent.hyperlinkSettings.cssClass;
            tCell.setAttribute('index', (Number(tCell.getAttribute('index')) + this.engine.headerContent.length).toString());
            let cell = args.data[0];
            if (tCell.getAttribute('aria-colindex') === '0') {
                if (this.parent.dataType === 'pivot') {
                    let isValueCell = cell.type && cell.type === 'value';
                    tCell.innerText = '';
                    let level = cell.level ? cell.level : (isValueCell ? (this.lastSpan + 1) : 0);
                    do {
                        if (level > 0) {
                            tCell.appendChild(createElement('span', {
                                className: level === 0 ? '' : NEXTSPAN,
                            }));
                        }
                        level--;
                    } while (level > -1);
                    level = cell.level ? cell.level : 0;
                    this.lastSpan = !isValueCell ? level : this.lastSpan;
                    if (!cell.hasChild && level > 0) {
                        tCell.appendChild(createElement('span', {
                            className: LASTSPAN,
                        }));
                    }
                    let fieldName;
                    if ((this.parent.dataSourceSettings.rows.length > 0 &&
                        (cell.valueSort ? Object.keys(cell.valueSort).length > 0 : true))) {
                        fieldName = level > -1 ? this.parent.dataSourceSettings.rows[level].name : '';
                        tCell.setAttribute('fieldname', fieldName);
                    }
                }
                else {
                    tCell = this.onOlapRowCellBoundEvent(tCell, cell);
                }
                let localizedText = cell.formattedText;
                if (cell.type) {
                    if (cell.type === 'grand sum') {
                        tCell.classList.add('e-gtot');
                        localizedText = this.parent.localeObj.getConstant('grandTotal');
                    }
                    else {
                        tCell.classList.add('e-stot');
                    }
                }
                tCell.classList.add(ROWSHEADER);
                if (cell.hasChild === true && !cell.isNamedSet) {
                    tCell.appendChild(createElement('div', {
                        className: (cell.isDrilled === true ? COLLAPSE : EXPAND) + ' ' + ICON,
                        attrs: {
                            'title': cell.isDrilled === true ? this.parent.localeObj.getConstant('collapse') :
                                this.parent.localeObj.getConstant('expand')
                        }
                    }));
                }
                tCell.appendChild(createElement('span', {
                    className: CELLVALUE,
                    /* tslint:disable-next-line */
                    innerHTML: (this.parent.isRowCellHyperlink || cell.enableHyperlink ? '<a  data-url="' + localizedText + '" class="e-hyperlinkcell ' + customClass + '">' + localizedText + '</a>' : localizedText)
                }));
                let vSort = this.parent.pivotView.dataSourceSettings.valueSortSettings;
                if (this.parent.enableValueSorting) {
                    if (vSort && vSort.headerText && this.parent.dataSourceSettings.valueAxis === 'row'
                        && this.parent.pivotValues[Number(tCell.getAttribute('index'))][0].valueSort.levelName) {
                        if (this.parent.pivotValues[Number(tCell.getAttribute('index'))][0].valueSort.levelName
                            === vSort.headerText) {
                            let style = (tCell.querySelector('.e-expand') || tCell.querySelector('.e-collapse')) ?
                                'padding-top: 18px' : 'padding-top: 12px';
                            tCell.appendChild(createElement('div', {
                                className: (vSort.sortOrder === 'Descending' ?
                                    'e-icon-descending e-icons e-descending e-sortfilterdiv' :
                                    'e-icon-ascending e-icons e-ascending e-sortfilterdiv'),
                                styles: style
                            }));
                        }
                    }
                }
            }
            else {
                let innerText = tCell.innerText;
                tCell.innerText = '';
                tCell.classList.add(VALUESCONTENT);
                cell = args.data[Number(tCell.getAttribute('aria-colindex'))];
                if (cell.isSum) {
                    tCell.classList.add(SUMMARY);
                }
                if (cell.cssClass) {
                    tCell.classList.add(cell.cssClass);
                }
                tCell.appendChild(createElement('span', {
                    className: CELLVALUE,
                    innerHTML: ((tCell.className.indexOf('e-summary') !== -1 && this.parent.isSummaryCellHyperlink) ||
                        (tCell.className.indexOf('e-summary') === -1 && this.parent.isValueCellHyperlink) || cell.enableHyperlink ?
                        '<a data-url="' + innerText + '" class="e-hyperlinkcell ' + customClass + '">' + innerText + '</a>' : innerText)
                }));
                if (this.parent.gridSettings.allowReordering && !this.parent.showGroupingBar) {
                    tCell.setAttribute('aria-colindex', args.column.customAttributes.cell.colIndex.toString());
                }
            }
            if (this.parent.cellTemplate) {
                let index = tCell.getAttribute('index');
                let colindex = tCell.getAttribute('aria-colindex');
                let templateID = index + '_' + colindex;
                /* tslint:disable-next-line */
                if (!(window && isBlazor())) {
                    /* tslint:disable-next-line */
                    let element = this.parent.getCellTemplate()({ targetCell: tCell }, this.parent, 'cellTemplate', this.parent.element.id + '_cellTemplate');
                    if (element && element !== '' && element.length > 0) {
                        if (this.parent.enableHtmlSanitizer) {
                            this.parent.appendHtml(tCell, SanitizeHtmlHelper.sanitize(element[0].outerHTML));
                        }
                        else {
                            this.parent.appendHtml(tCell, element[0].outerHTML);
                        }
                    }
                }
                else if (index && colindex) {
                    this.parent.gridCellCollection[templateID] = tCell;
                }
            }
            this.unWireEvents(tCell);
            this.wireEvents(tCell);
        }
        args.pivotview = this.parent;
        this.parent.trigger(queryCellInfo, args);
    }
    /* tslint:disable */
    onOlapRowCellBoundEvent(tCell, cell) {
        tCell.innerText = '';
        let rowMeasurePos = this.engine.rowMeasurePos;
        if (this.parent.enableVirtualization) {
            if (cell.ordinal > -1 && this.parent.olapEngineModule.tupRowInfo.length > 0) {
                let tupInfo = this.parent.olapEngineModule.tupRowInfo[cell.ordinal];
                let memberPosition = tupInfo.uNameCollection.indexOf(cell.actualText.toString());
                let cropUName = tupInfo.uNameCollection.substring(0, memberPosition) +
                    (cell.memberType === 3 ? '' : cell.actualText.toString());
                let fieldSep = cropUName.split('::[').map((item) => {
                    return item[0] === '[' ? item : ('[' + item);
                });
                if (cell.memberType === 3 && rowMeasurePos === fieldSep.length) {
                    fieldSep.push(cell.actualText.toString());
                }
                let nxtIndextCount = -1;
                let lastIndextCount = 0;
                let prevHasChild = false;
                for (let fPos = 0; fPos < fieldSep.length; fPos++) {
                    let fieldMembers = fieldSep[fPos];
                    let membersCount = fieldMembers.split('~~').length;
                    nxtIndextCount += membersCount;
                    let hasChild = Number(tupInfo.members[fPos].querySelector('CHILDREN_CARDINALITY').textContent) > 0;
                    lastIndextCount += (fPos > 0 && prevHasChild && !hasChild) ? 1 : 0;
                    prevHasChild = hasChild;
                }
                let indent = 0;
                for (let iPos = 0; iPos < nxtIndextCount; iPos++) {
                    tCell.appendChild(createElement('span', {
                        className: NEXTSPAN,
                    }));
                    indent++;
                }
                for (let iPos = 0; iPos < lastIndextCount && nxtIndextCount > 0; iPos++) {
                    tCell.appendChild(createElement('span', {
                        className: LASTSPAN,
                    }));
                }
                this.indentCollection[cell.rowIndex] = indent;
                this.maxIndent = this.maxIndent > indent ? this.maxIndent : indent;
            }
        }
        else {
            let hierarchyName = cell.hierarchy;
            let levelName = cell.memberType === 3 ? (this.measurePos + '.' + cell.levelUniqueName) : cell.levelUniqueName;
            let hasChild = cell.hasChild;
            if (!this.lvlCollection[levelName] && levelName) {
                this.lvlPosCollection[this.position] = levelName;
                this.lvlCollection[levelName] = { position: this.position, hasChild: hasChild };
                this.position++;
            }
            else if (levelName) {
                let currPos = this.lvlCollection[levelName].position;
                for (let pos = currPos + 1; pos < this.position; pos++) {
                    delete this.lvlCollection[this.lvlPosCollection[pos]];
                    delete this.lvlPosCollection[pos];
                }
                this.position = this.position > (currPos + 1) ? (currPos + 1) : this.position;
            }
            if (!this.hierarchyCollection[hierarchyName] && hierarchyName) {
                this.hierarchyPosCollection[this.hierarchyCount] = hierarchyName;
                this.hierarchyCollection[hierarchyName] = {
                    lvlPosition: this.position - 1,
                    hierarchyPOs: this.hierarchyCount
                };
                this.hierarchyCount++;
            }
            else if (hierarchyName) {
                let currPos = this.hierarchyCollection[hierarchyName].hierarchyPOs;
                for (let pos = currPos + 1; pos < this.hierarchyCount; pos++) {
                    delete this.hierarchyCollection[this.hierarchyPosCollection[pos]];
                    delete this.hierarchyPosCollection[pos];
                }
                this.hierarchyCount = this.hierarchyCount > (currPos + 1) ? (currPos + 1) : this.hierarchyCount;
            }
            if (cell.memberType !== 3 && levelName && this.lvlCollection[levelName]) {
                let currHierarchyPos = this.hierarchyCollection[hierarchyName] ?
                    this.hierarchyCollection[hierarchyName].hierarchyPOs : -1;
                this.measurePos = rowMeasurePos <= currHierarchyPos && this.hierarchyPosCollection[rowMeasurePos + 1] ?
                    this.measurePos : this.lvlCollection[levelName].position;
            }
            let currPos = this.lvlCollection[levelName] ? this.lvlCollection[levelName].position : -1;
            let lvlPos = 0;
            let indent = 0;
            while (lvlPos <= currPos && currPos > 0 && cell.level > -1) {
                let hasChild = this.lvlCollection[this.lvlPosCollection[lvlPos]].hasChild;
                let prevHasChild = lvlPos > 0 ? this.lvlCollection[this.lvlPosCollection[lvlPos - 1]].hasChild : false;
                if (prevHasChild && !hasChild) {
                    tCell.appendChild(createElement('span', {
                        className: LASTSPAN,
                    }));
                }
                if (lvlPos !== currPos) {
                    tCell.appendChild(createElement('span', {
                        className: NEXTSPAN,
                    }));
                    indent++;
                }
                lvlPos++;
            }
            if (cell.memberType === 3 && cell.level === -1 && Object.keys(this.lvlCollection).length > 1) {
                tCell.appendChild(createElement('span', {
                    className: NEXTSPAN,
                }));
                indent++;
            }
            this.indentCollection[cell.rowIndex] = indent;
            this.maxIndent = this.maxIndent > indent ? this.maxIndent : indent;
        }
        tCell.setAttribute('fieldname', cell.hierarchy);
        return tCell;
    }
    /* tslint:enable */
    columnCellBoundEvent(args) {
        if (args.cell.column && args.cell.column.customAttributes) {
            let cell = args.cell.column.customAttributes.cell;
            let tCell = args.node;
            if (cell) {
                let customClass = this.parent.hyperlinkSettings.cssClass;
                let level = cell.level ? cell.level : 0;
                if ((cell.level === -1 && !cell.rowSpan) || cell.rowSpan === -1) {
                    args.node.style.display = 'none';
                }
                else if (cell.rowSpan > 1) {
                    args.node.setAttribute('rowspan', cell.rowSpan.toString());
                    args.node.setAttribute('aria-rowspan', cell.rowSpan.toString());
                    if ((cell.rowIndex + cell.rowSpan) === this.engine.headerContent.length) {
                        args.node.style.borderBottomWidth = '0px';
                    }
                }
                args.node.setAttribute('aria-colindex', cell.colIndex.toString());
                args.node.setAttribute('index', cell.rowIndex.toString());
                let fieldName;
                if (this.parent.dataType === 'pivot') {
                    if (!(this.parent.dataSourceSettings.values && this.parent.dataSourceSettings.valueAxis === 'column' &&
                        this.parent.dataSourceSettings.values.length > 1 &&
                        (cell.rowIndex === this.engine.headerContent.length - 1)) && this.parent.dataSourceSettings.columns &&
                        this.parent.dataSourceSettings.columns.length > 0) {
                        fieldName = level > -1 && this.parent.dataSourceSettings.columns[level] ?
                            this.parent.dataSourceSettings.columns[level].name : '';
                        tCell.setAttribute('fieldname', fieldName);
                    }
                }
                else {
                    tCell = this.onOlapColumnCellBoundEvent(tCell, cell);
                }
                if (cell.type) {
                    tCell.classList.add(cell.type === 'grand sum' ? 'e-gtot' : 'e-stot');
                    let localizedText = cell.type === 'grand sum' ? this.parent.localeObj.getConstant('grandTotal') :
                        cell.formattedText.split('Total')[0] + this.parent.localeObj.getConstant('total');
                    if (tCell.querySelector('.e-headertext') !== null) {
                        tCell.querySelector('.e-headertext').innerText = localizedText;
                    }
                    else {
                        tCell.querySelector('.e-stackedheadercelldiv').innerText = localizedText;
                    }
                }
                tCell.classList.add(COLUMNSHEADER);
                if (this.parent.isColumnCellHyperlink || cell.enableHyperlink) {
                    if (tCell.querySelector('.e-stackedheadercelldiv')) {
                        let innerText = tCell.querySelector('.e-stackedheadercelldiv').innerText;
                        tCell.querySelector('.e-stackedheadercelldiv').innerHTML =
                            '<a data-url="' + innerText + '" class="e-hyperlinkcell ' + customClass + '">' + innerText + '</a>';
                    }
                    else if (tCell.querySelector('.e-headertext')) {
                        let innerText = tCell.querySelector('.e-headertext').innerText;
                        tCell.querySelector('.e-headertext').innerHTML =
                            '<a data-url="' + innerText + '" class="e-hyperlinkcell ' + customClass + '">' + innerText + '</a>';
                    }
                }
                if (cell.hasChild === true && !cell.isNamedSet) {
                    let hdrdiv = tCell.querySelector('.e-headercelldiv');
                    if (hdrdiv) {
                        hdrdiv.style.height = 'auto';
                        hdrdiv.style.lineHeight = 'normal';
                    }
                    let div = createElement('div', {
                        className: (cell.isDrilled === true ? COLLAPSE : EXPAND) + ' ' + ICON,
                        attrs: {
                            'title': cell.isDrilled === true ? this.parent.localeObj.getConstant('collapse') :
                                this.parent.localeObj.getConstant('expand')
                        }
                    });
                    tCell.children[0].classList.add(CELLVALUE);
                    if (window.navigator.userAgent.indexOf('Edge') > -1 || window.navigator.userAgent.indexOf('Trident') > -1) {
                        tCell.children[0].style.display = 'table';
                    }
                    else {
                        tCell.children[0].style.display = 'block';
                    }
                    tCell.insertBefore(div, tCell.children[0]);
                }
                tCell = this.appendValueSortIcon(cell, tCell, cell.rowIndex, cell.colIndex);
                if (this.parent.cellTemplate) {
                    let index = tCell.getAttribute('index');
                    let colindex = tCell.getAttribute('aria-colindex');
                    let templateID = index + '_' + colindex;
                    /* tslint:disable-next-line */
                    if (!(window && isBlazor())) {
                        this.parent.gridHeaderCellInfo.push({ targetCell: tCell });
                    }
                    else if (index && colindex) {
                        this.parent.gridCellCollection[templateID] = tCell;
                    }
                }
                let len = this.parent.dataSourceSettings.values.length;
                for (let vCnt = 0; vCnt < len; vCnt++) {
                    if (this.parent.dataSourceSettings.values[vCnt].name === cell.actualText) {
                        tCell.classList.add(VALUESHEADER);
                    }
                }
                this.unWireEvents(tCell);
                this.wireEvents(tCell);
            }
        }
        this.parent.trigger(headerCellInfo, args);
    }
    onOlapColumnCellBoundEvent(tCell, cell) {
        tCell.setAttribute('fieldname', cell.memberType === 3 ? cell.actualText.toString() : cell.hierarchy);
        let prevCell = this.engine.headerContent[cell.rowIndex] ?
            this.engine.headerContent[cell.rowIndex][cell.colIndex - 1] : undefined;
        if (prevCell && prevCell.actualText === cell.actualText && prevCell.type === cell.type &&
            (cell.memberType === 3 ? true : prevCell.colSpan > 1)) {
            tCell.style.display = 'none';
        }
        else {
            tCell.setAttribute('colspan', cell.colSpan.toString());
            tCell.setAttribute('aria-colspan', cell.colSpan.toString());
        }
        if (cell.rowIndex === (this.engine.headerContent.length - 1) && cell.memberType === 2) {
            tCell.style.display = this.isSpannedCell(this.engine.headerContent.length, cell) ? 'none' : tCell.style.display;
        }
        return tCell;
    }
    isSpannedCell(colLength, currCell) {
        let prevCell = this.engine.headerContent[currCell.rowIndex - 1] ?
            this.engine.headerContent[currCell.rowIndex - 1][currCell.colIndex] : undefined;
        let parentCellSpan;
        let parentCellPos;
        while (prevCell && ((prevCell.memberType === currCell.memberType) || (prevCell.type && currCell.type))) {
            if (prevCell.rowSpan > 0) {
                parentCellSpan = prevCell.rowSpan;
                parentCellPos = prevCell.rowIndex;
            }
            prevCell = this.engine.headerContent[prevCell.rowIndex - 1] ?
                this.engine.headerContent[prevCell.rowIndex - 1][currCell.colIndex] : undefined;
        }
        return (parentCellPos + parentCellSpan) >= colLength;
    }
    onHyperCellClick(e) {
        let cell = e.target.parentElement.parentElement;
        cell = (cell.className.indexOf('e-headercelldiv') > -1 ? cell.parentElement : cell);
        let args = {
            currentCell: cell,
            data: this.engine.pivotValues[Number(cell.getAttribute('index'))][Number(cell.getAttribute('aria-colindex'))],
            cancel: true
        };
        this.parent.trigger(hyperlinkCellClick, args, (observedArgs) => {
            if (!observedArgs.cancel) {
                args.currentCell = getElement(args.currentCell);
                let url = args.currentCell.getAttribute('data-url') ? (args.currentCell).getAttribute('data-url') :
                    args.currentCell.querySelector('a').getAttribute('data-url');
                window.open(url);
            }
        });
    }
    getRowStartPos() {
        let pivotValues = this.parent.pivotValues;
        let rowPos;
        for (let rCnt = 0; rCnt < pivotValues.length; rCnt++) {
            if (pivotValues[rCnt] && pivotValues[rCnt][0] && pivotValues[rCnt][0].axis === 'row') {
                rowPos = rCnt;
                break;
            }
        }
        return rowPos;
    }
    frameDataSource(type) {
        let dataContent = [];
        if (this.parent.dataSourceSettings.values.length > 0 && !this.engine.isEmptyData) {
            if ((this.parent.enableValueSorting) || !this.engine.isEngineUpdated) {
                let rowCnt = 0;
                let pivotValues = this.parent.pivotValues;
                let start = type === 'value' ? this.rowStartPos : 0;
                let end = type === 'value' ? pivotValues.length : this.rowStartPos;
                for (let rCnt = start; rCnt < end; rCnt++) {
                    if (pivotValues[rCnt]) {
                        rowCnt = type === 'header' ? rCnt : rowCnt;
                        dataContent[rowCnt] = {};
                        for (let cCnt = 0; cCnt < pivotValues[rCnt].length; cCnt++) {
                            if (pivotValues[rCnt][cCnt]) {
                                dataContent[rowCnt][cCnt] = pivotValues[rCnt][cCnt];
                            }
                        }
                        rowCnt++;
                    }
                }
            }
            else {
                dataContent = type === 'value' ? this.engine.valueContent : this.engine.headerContent;
            }
        }
        else {
            dataContent = this.frameEmptyData();
        }
        return dataContent;
    }
    /** @hidden */
    /* tslint:disable-next-line */
    frameEmptyData() {
        /* tslint:disable-next-line */
        let dataContent = [{
                0: { formattedText: this.parent.localeObj.getConstant('grandTotal') },
                1: { formattedText: this.parent.localeObj.getConstant('emptyData') }
            }];
        return dataContent;
    }
    calculateColWidth(colCount) {
        let parWidth = isNaN(this.parent.width) ? (this.parent.width.toString().indexOf('%') > -1 ?
            ((parseFloat(this.parent.width.toString()) / 100) * this.parent.element.offsetWidth) : this.parent.element.offsetWidth) :
            Number(this.parent.width);
        parWidth = parWidth - (this.gridSettings.columnWidth > this.resColWidth ? this.gridSettings.columnWidth : this.resColWidth) - 2;
        colCount = colCount - 1;
        let colWidth = (colCount * this.gridSettings.columnWidth) < parWidth ? (parWidth / colCount) : this.gridSettings.columnWidth;
        return Math.floor(colWidth);
    }
    resizeColWidth(colCount) {
        let parWidth = isNaN(this.parent.width) ? (this.parent.width.toString().indexOf('%') > -1 ?
            ((parseFloat(this.parent.width.toString()) / 100) * this.parent.element.offsetWidth) : this.parent.element.offsetWidth) :
            Number(this.parent.width);
        colCount = colCount - 1;
        parWidth = parWidth - (this.gridSettings.columnWidth > this.resColWidth ? this.gridSettings.columnWidth : this.resColWidth) - 2;
        let colWidth = (colCount * this.gridSettings.columnWidth) < parWidth ? (parWidth / colCount) : this.gridSettings.columnWidth;
        return Math.floor(colWidth);
    }
    calculateGridWidth() {
        let parWidth = this.parent.width;
        let eleWidth = this.parent.element.getBoundingClientRect().width ?
            this.parent.element.getBoundingClientRect().width : this.parent.element.offsetWidth;
        if (this.gridSettings.width === 'auto') {
            if (this.parent.width === 'auto') {
                parWidth = eleWidth;
            }
            else if (this.parent.width.toString().indexOf('%') > -1) {
                parWidth = ((parseFloat(this.parent.width.toString()) / 100) * eleWidth);
            }
        }
        else {
            parWidth = this.gridSettings.width;
        }
        return parWidth;
    }
    /** @hidden */
    calculateGridHeight(elementCreated) {
        let gridHeight = this.parent.height;
        let parHeight = this.parent.getHeightAsNumber();
        if (isNaN(parHeight)) {
            parHeight = this.parent.element.offsetHeight > 0 ? this.parent.element.offsetHeight : 1;
        }
        if (this.parent.currentView !== 'Chart') {
            if (this.gridSettings.height === 'auto' && parHeight && this.parent.element.querySelector('.' + GRID_HEADER)) {
                let rowColHeight = this.parent.element.querySelector('.' + GRID_HEADER).offsetHeight;
                let gBarHeight = rowColHeight + (this.parent.element.querySelector('.' + GROUPING_BAR_CLASS) ?
                    this.parent.element.querySelector('.' + GROUPING_BAR_CLASS).offsetHeight : 0);
                let toolBarHeight = this.parent.element.querySelector('.' + GRID_TOOLBAR) ? 42 : 0;
                gridHeight = parHeight - (gBarHeight + toolBarHeight) - 1;
                if (elementCreated) {
                    let tableHeight = this.parent.element.querySelector('.' + FROZENCONTENT_DIV + ' .' + TABLE).offsetHeight;
                    let contentHeight = this.parent.element.querySelector('.' + MOVABLECONTENT_DIV).offsetHeight;
                    let tableWidth = this.parent.element.querySelector('.' + MOVABLECONTENT_DIV + ' .' + TABLE).offsetWidth;
                    let contentWidth = this.parent.element.querySelector('.' + MOVABLECONTENT_DIV).offsetWidth;
                    let horizontalOverflow = contentWidth < tableWidth;
                    let verticalOverflow = contentHeight < tableHeight;
                    let commonOverflow = horizontalOverflow && ((gridHeight - tableHeight) < 18) ? true : false;
                    if (gridHeight >= tableHeight && (horizontalOverflow ? gridHeight >= contentHeight : true) &&
                        !verticalOverflow && !commonOverflow) {
                        this.parent.grid.height = 'auto';
                    }
                    else {
                        this.parent.grid.height = gridHeight;
                    }
                }
                else {
                    if (gridHeight > (this.engine.valueContent.length * this.gridSettings.rowHeight)) {
                        gridHeight = 'auto';
                    }
                }
            }
            else {
                gridHeight = this.gridSettings.height;
            }
        }
        return gridHeight < this.parent.gridSettings.rowHeight ? this.parent.gridSettings.rowHeight : gridHeight;
    }
    frameStackedHeaders() {
        let integrateModel = [];
        if ((this.parent.dataType === 'olap' ? true : this.parent.dataSourceSettings.values.length > 0) && !this.engine.isEmptyData) {
            let headerCnt = this.engine.headerContent.length;
            let headerSplit = [];
            let splitPos = [];
            let colWidth = this.calculateColWidth(this.engine.pivotValues[0].length);
            do {
                let columnModel = [];
                let actualCnt = 0;
                headerCnt--;
                let colField = this.engine.headerContent[headerCnt];
                if (colField) {
                    for (let cCnt = 0; cCnt < Object.keys(colField).length + (colField[0] ? 0 : 1); cCnt++) {
                        let colSpan = (colField[cCnt] && colField[cCnt].colSpan) ?
                            ((colField[cCnt].memberType !== 3 || headerCnt === 0) ?
                                colField[cCnt].colSpan : headerSplit[cCnt]) : 1;
                        colSpan = this.parent.dataType === 'olap' ? 1 : colSpan;
                        let rowSpan = (colField[cCnt] && colField[cCnt].rowSpan) ? colField[cCnt].rowSpan : 1;
                        let formattedText = colField[cCnt] ? (colField[cCnt].type === 'grand sum' ?
                            this.parent.localeObj.getConstant('grandTotal') : (colField[cCnt].type === 'sum' ?
                            colField[cCnt].formattedText.split('Total')[0] + this.parent.localeObj.getConstant('total') :
                            colField[cCnt].formattedText)) : '';
                        if (headerCnt === this.engine.headerContent.length - 1) {
                            colSpan = 1;
                            columnModel[actualCnt] = {
                                field: (cCnt + '.formattedText'),
                                headerText: formattedText,
                                customAttributes: { 'cell': colField[cCnt] },
                                /* tslint:disable-next-line */
                                width: colField[cCnt] ? this.setSavedWidth(colField[cCnt].valueSort.levelName, colWidth) : this.resColWidth,
                                minWidth: 30,
                                format: cCnt === 0 ? '' : this.formatList[colField[cCnt].actualText],
                                allowReordering: (this.parent.showGroupingBar ? false : this.parent.gridSettings.allowReordering),
                                allowResizing: this.parent.gridSettings.allowResizing,
                                visible: true
                            };
                        }
                        else if (headerSplit[cCnt]) {
                            colSpan = (colField[cCnt] && colField[cCnt].type === 'grand sum' &&
                                colField[cCnt].memberType === 2) ? 1 : colSpan;
                            let tmpSpan = colSpan;
                            let innerModel = [];
                            let innerPos = cCnt;
                            while (tmpSpan > 0) {
                                if (columnModel[actualCnt]) {
                                    if (!integrateModel[splitPos[innerPos]]) {
                                        break;
                                    }
                                    innerModel.push(integrateModel[splitPos[innerPos]]);
                                }
                                else {
                                    columnModel[actualCnt] = {
                                        headerText: formattedText,
                                        /* tslint:disable-next-line */
                                        field: colField[cCnt] ? colField[cCnt].valueSort.levelName : '',
                                        customAttributes: { 'cell': colField[cCnt] },
                                        /* tslint:disable-next-line */
                                        width: colField[cCnt] ? this.setSavedWidth(colField[cCnt].valueSort.levelName, colWidth) :
                                            this.resColWidth,
                                        minWidth: 30,
                                        allowReordering: (this.parent.showGroupingBar ? false : this.parent.gridSettings.allowReordering),
                                        allowResizing: this.parent.gridSettings.allowResizing,
                                        visible: true
                                    };
                                    innerModel = [integrateModel[splitPos[innerPos]]];
                                }
                                tmpSpan = tmpSpan - headerSplit[innerPos];
                                innerPos = innerPos + headerSplit[innerPos];
                            }
                            columnModel[actualCnt].columns = innerModel;
                        }
                        if (columnModel[actualCnt]) {
                            columnModel[actualCnt].clipMode = this.gridSettings.clipMode;
                        }
                        headerSplit[cCnt] = colSpan;
                        splitPos[cCnt] = actualCnt;
                        actualCnt++;
                        cCnt = cCnt + colSpan - 1;
                    }
                }
                integrateModel = columnModel.length > 0 ? columnModel : integrateModel;
            } while (headerCnt > 0);
            integrateModel[0] = {
                field: (0 + '.formattedText'),
                width: this.resColWidth,
                minWidth: 30,
                headerText: '',
                allowReordering: false,
                allowResizing: this.parent.gridSettings.allowResizing,
                visible: true
            };
        }
        else {
            integrateModel = this.frameEmptyColumns();
        }
        if (integrateModel.length > 1) {
            integrateModel[integrateModel.length - 1].minWidth = integrateModel[integrateModel.length - 1].width;
            integrateModel[integrateModel.length - 1].width = 'auto';
        }
        this.parent.triggerColumnRenderEvent(integrateModel);
        return integrateModel;
    }
    /** @hidden */
    setSavedWidth(column, width) {
        width = this.parent.resizeInfo[column] ? this.parent.resizeInfo[column] : width;
        return width;
    }
    /** @hidden */
    frameEmptyColumns() {
        let columns = [];
        let colWidth = this.calculateColWidth(2);
        columns.push({ field: '0.formattedText', headerText: '', minWidth: 30, width: this.resColWidth });
        /* tslint:disable-next-line */
        columns.push({ field: '1.formattedText', headerText: this.parent.localeObj.getConstant('grandTotal'), minWidth: 30, width: colWidth });
        return columns;
    }
    /** @hidden */
    getFormatList() {
        let formatArray = {};
        for (let vCnt = 0; vCnt < this.parent.dataSourceSettings.values.length; vCnt++) {
            let field = this.parent.dataSourceSettings.values[vCnt];
            let format = 'N';
            if (this.parent.dataType === 'olap') {
                if (this.parent.olapEngineModule.fieldList[field.name]) {
                    let fString = this.parent.olapEngineModule.fieldList[field.name].formatString;
                    format = fString.indexOf('#') > -1 ? fString : (fString[0] + '2');
                }
            }
            else {
                if (this.parent.dataSourceSettings.formatSettings.length > 0) {
                    for (let fCnt = 0; fCnt < this.parent.dataSourceSettings.formatSettings.length; fCnt++) {
                        let formatSettings = this.parent.dataSourceSettings.formatSettings[fCnt];
                        if (field.name === formatSettings.name) {
                            format = formatSettings.format;
                            break;
                        }
                        else {
                            continue;
                        }
                    }
                }
            }
            formatArray[field.name] = format;
        }
        return formatArray;
    }
    excelColumnEvent(args) {
        args = this.exportHeaderEvent(args);
        this.parent.trigger(excelHeaderQueryCellInfo, args);
    }
    pdfColumnEvent(args) {
        args = this.exportHeaderEvent(args);
        this.parent.trigger(pdfHeaderQueryCellInfo, args);
    }
    excelRowEvent(args) {
        if (args.column.field === '0.formattedText') {
            let isValueCell = args.data[0].type === 'value';
            let level = 0;
            if (this.parent.dataType === 'olap') {
                /* tslint:disable-next-line */
                level = this.indentCollection[args.data[0].rowIndex];
            }
            else {
                level = isValueCell ? (this.lastSpan + 1) : args.data[0].level;
            }
            this.colPos = 0;
            args.style = { hAlign: 'Left', indent: level * 2 };
            this.lastSpan = isValueCell ? this.lastSpan : level;
        }
        else {
            this.colPos++;
            /* tslint:disable-next-line */
            if (isNullOrUndefined(args.data[this.colPos].value) || isNullOrUndefined(args.data[this.colPos].formattedText)) {
                args.value = '';
            }
            else {
                /* tslint:disable-next-line */
                args.value = args.data[this.colPos].value || args.data[this.colPos].formattedText;
            }
        }
        args = this.exportContentEvent(args);
        this.parent.trigger(excelQueryCellInfo, args);
    }
    /* tslint:disable:no-any */
    pdfRowEvent(args) {
        args = this.exportContentEvent(args);
        if (args.column.field === '0.formattedText') {
            let level = 0;
            let isValueCell = args.data[0].type === 'value';
            if (this.parent.dataType === 'olap') {
                level = this.indentCollection[args.data[0].rowIndex];
            }
            else {
                level = isValueCell ? (this.lastSpan + 1) : args.data[0].level !== -1 ?
                    args.data[0].level : 0;
            }
            args.style = { paragraphIndent: level * 10 };
            this.lastSpan = isValueCell ? this.lastSpan : level;
        }
        this.parent.trigger(pdfQueryCellInfo, args);
    }
    exportHeaderEvent(args) {
        let rowSpan = 1;
        if (args.gridCell.column.customAttributes) {
            let cell = args.gridCell.column.customAttributes.cell;
            if (this.actualText !== cell.actualText && cell.colSpan > 1 && cell.level > -1) {
                args.gridCell.colSpan = args.cell.colSpan = cell.colSpan > -1 ? cell.colSpan : 1;
            }
            rowSpan = cell.rowSpan > -1 ? cell.rowSpan : 1;
            this.actualText = cell.actualText;
        }
        else {
            rowSpan = Object.keys(this.engine.headerContent).length;
        }
        if (args.cell.rowSpan !== rowSpan && rowSpan > -1) {
            args.cell.rowSpan = rowSpan;
        }
        return args;
    }
    exportContentEvent(args) {
        args.value = args.data[Number(args.column.field.split('.formattedText')[0])].type === 'grand sum' ?
            this.parent.localeObj.getConstant('grandTotal') : args.value;
        return args;
    }
    unWireEvents(cell) {
        if (cell.querySelector('.e-hyperlinkcell')) {
            /* tslint:disable-next-line */
            EventHandler.remove(cell.querySelector('.e-hyperlinkcell'), this.parent.isAdaptive ? 'touchend' : 'click', this.onHyperCellClick);
        }
        else {
            return;
        }
    }
    wireEvents(cell) {
        if (cell.querySelector('.e-hyperlinkcell')) {
            /* tslint:disable-next-line */
            EventHandler.add(cell.querySelector('.e-hyperlinkcell'), this.parent.isAdaptive ? 'touchend' : 'click', this.onHyperCellClick, this);
        }
        else {
            return;
        }
    }
}

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Configures the fields in dataSource.
 */
class FieldOptions extends ChildProperty {
}
__decorate$1([
    Property()
], FieldOptions.prototype, "name", void 0);
__decorate$1([
    Property()
], FieldOptions.prototype, "caption", void 0);
__decorate$1([
    Property('Sum')
], FieldOptions.prototype, "type", void 0);
__decorate$1([
    Property()
], FieldOptions.prototype, "axis", void 0);
__decorate$1([
    Property(false)
], FieldOptions.prototype, "showNoDataItems", void 0);
__decorate$1([
    Property()
], FieldOptions.prototype, "baseField", void 0);
__decorate$1([
    Property()
], FieldOptions.prototype, "baseItem", void 0);
__decorate$1([
    Property(true)
], FieldOptions.prototype, "showSubTotals", void 0);
__decorate$1([
    Property(false)
], FieldOptions.prototype, "isNamedSet", void 0);
__decorate$1([
    Property(false)
], FieldOptions.prototype, "isCalculatedField", void 0);

/**
 * Configures the style settings.
 */
class Style extends ChildProperty {
}
__decorate$1([
    Property()
], Style.prototype, "backgroundColor", void 0);
__decorate$1([
    Property()
], Style.prototype, "color", void 0);
__decorate$1([
    Property()
], Style.prototype, "fontFamily", void 0);
__decorate$1([
    Property()
], Style.prototype, "fontSize", void 0);
/**
 * Configures the filter settings.
 */
class Filter extends ChildProperty {
}
__decorate$1([
    Property()
], Filter.prototype, "name", void 0);
__decorate$1([
    Property('Include')
], Filter.prototype, "type", void 0);
__decorate$1([
    Property()
], Filter.prototype, "items", void 0);
__decorate$1([
    Property('DoesNotEquals')
], Filter.prototype, "condition", void 0);
__decorate$1([
    Property()
], Filter.prototype, "value1", void 0);
__decorate$1([
    Property()
], Filter.prototype, "value2", void 0);
__decorate$1([
    Property()
], Filter.prototype, "measure", void 0);
__decorate$1([
    Property(1)
], Filter.prototype, "levelCount", void 0);
__decorate$1([
    Property()
], Filter.prototype, "selectedField", void 0);
/**
 * Configures the conditional format settings.
 */
class ConditionalFormatSettings extends ChildProperty {
}
__decorate$1([
    Property()
], ConditionalFormatSettings.prototype, "measure", void 0);
__decorate$1([
    Property()
], ConditionalFormatSettings.prototype, "label", void 0);
__decorate$1([
    Property()
], ConditionalFormatSettings.prototype, "conditions", void 0);
__decorate$1([
    Property()
], ConditionalFormatSettings.prototype, "value1", void 0);
__decorate$1([
    Property()
], ConditionalFormatSettings.prototype, "value2", void 0);
__decorate$1([
    Property()
], ConditionalFormatSettings.prototype, "style", void 0);
__decorate$1([
    Property(true)
], ConditionalFormatSettings.prototype, "applyGrandTotals", void 0);
/**
 * Configures the sort settings.
 */
class Sort extends ChildProperty {
}
__decorate$1([
    Property()
], Sort.prototype, "name", void 0);
__decorate$1([
    Property('Ascending')
], Sort.prototype, "order", void 0);
/**
 * Configures the format settings of value fields.
 */
class FormatSettings extends ChildProperty {
}
__decorate$1([
    Property()
], FormatSettings.prototype, "name", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "minimumFractionDigits", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "maximumFractionDigits", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "minimumSignificantDigits", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "maximumSignificantDigits", void 0);
__decorate$1([
    Property(true)
], FormatSettings.prototype, "useGrouping", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "skeleton", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "type", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "currency", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "minimumIntegerDigits", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "format", void 0);
/**
 * Configures the group settings of fields.
 */
class GroupSettings extends ChildProperty {
}
__decorate$1([
    Property()
], GroupSettings.prototype, "name", void 0);
__decorate$1([
    Property()
], GroupSettings.prototype, "groupInterval", void 0);
__decorate$1([
    Property()
], GroupSettings.prototype, "startingAt", void 0);
__decorate$1([
    Property()
], GroupSettings.prototype, "endingAt", void 0);
__decorate$1([
    Property('Date')
], GroupSettings.prototype, "type", void 0);
__decorate$1([
    Property()
], GroupSettings.prototype, "rangeInterval", void 0);
__decorate$1([
    Property()
], GroupSettings.prototype, "caption", void 0);
__decorate$1([
    Property()
], GroupSettings.prototype, "customGroups", void 0);
/**
 * Configures the custom group settings of fields.
 */
class CustomGroups extends ChildProperty {
}
__decorate$1([
    Property()
], CustomGroups.prototype, "groupName", void 0);
__decorate$1([
    Property([])
], CustomGroups.prototype, "items", void 0);
/**
 * Configures the calculatedfields settings.
 */
class CalculatedFieldSettings extends ChildProperty {
}
__decorate$1([
    Property()
], CalculatedFieldSettings.prototype, "name", void 0);
__decorate$1([
    Property()
], CalculatedFieldSettings.prototype, "formula", void 0);
__decorate$1([
    Property()
], CalculatedFieldSettings.prototype, "hierarchyUniqueName", void 0);
__decorate$1([
    Property()
], CalculatedFieldSettings.prototype, "formatString", void 0);
/**
 * Configures drilled state of field members.
 */
class DrillOptions extends ChildProperty {
}
__decorate$1([
    Property()
], DrillOptions.prototype, "name", void 0);
__decorate$1([
    Property()
], DrillOptions.prototype, "items", void 0);
__decorate$1([
    Property()
], DrillOptions.prototype, "delimiter", void 0);
/**
 * Configures value sort settings.
 */
class ValueSortSettings extends ChildProperty {
}
__decorate$1([
    Property()
], ValueSortSettings.prototype, "headerText", void 0);
__decorate$1([
    Property('.')
], ValueSortSettings.prototype, "headerDelimiter", void 0);
__decorate$1([
    Property('None')
], ValueSortSettings.prototype, "sortOrder", void 0);
__decorate$1([
    Property()
], ValueSortSettings.prototype, "measure", void 0);
/**
 * Configures the settings of dataSource.
 */
class DataSourceSettings extends ChildProperty {
}
__decorate$1([
    Property()
], DataSourceSettings.prototype, "catalog", void 0);
__decorate$1([
    Property()
], DataSourceSettings.prototype, "cube", void 0);
__decorate$1([
    Property('Relational')
], DataSourceSettings.prototype, "providerType", void 0);
__decorate$1([
    Property()
], DataSourceSettings.prototype, "url", void 0);
__decorate$1([
    Property(1033)
], DataSourceSettings.prototype, "localeIdentifier", void 0);
__decorate$1([
    Property()
], DataSourceSettings.prototype, "dataSource", void 0);
__decorate$1([
    Collection([], FieldOptions)
], DataSourceSettings.prototype, "rows", void 0);
__decorate$1([
    Collection([], FieldOptions)
], DataSourceSettings.prototype, "columns", void 0);
__decorate$1([
    Collection([], FieldOptions)
], DataSourceSettings.prototype, "values", void 0);
__decorate$1([
    Collection([], FieldOptions)
], DataSourceSettings.prototype, "filters", void 0);
__decorate$1([
    Property([])
], DataSourceSettings.prototype, "excludeFields", void 0);
__decorate$1([
    Property(false)
], DataSourceSettings.prototype, "expandAll", void 0);
__decorate$1([
    Property('column')
], DataSourceSettings.prototype, "valueAxis", void 0);
__decorate$1([
    Collection([], Filter)
], DataSourceSettings.prototype, "filterSettings", void 0);
__decorate$1([
    Collection([], Sort)
], DataSourceSettings.prototype, "sortSettings", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "enableSorting", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "allowMemberFilter", void 0);
__decorate$1([
    Property(false)
], DataSourceSettings.prototype, "allowLabelFilter", void 0);
__decorate$1([
    Property(false)
], DataSourceSettings.prototype, "allowValueFilter", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showSubTotals", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showRowSubTotals", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showColumnSubTotals", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showGrandTotals", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showRowGrandTotals", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showColumnGrandTotals", void 0);
__decorate$1([
    Property(false)
], DataSourceSettings.prototype, "alwaysShowValueHeader", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showHeaderWhenEmpty", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showAggregationOnValueField", void 0);
__decorate$1([
    Collection([], FormatSettings)
], DataSourceSettings.prototype, "formatSettings", void 0);
__decorate$1([
    Collection([], DrillOptions)
], DataSourceSettings.prototype, "drilledMembers", void 0);
__decorate$1([
    Complex({}, ValueSortSettings)
], DataSourceSettings.prototype, "valueSortSettings", void 0);
__decorate$1([
    Collection([], CalculatedFieldSettings)
], DataSourceSettings.prototype, "calculatedFieldSettings", void 0);
__decorate$1([
    Collection([], ConditionalFormatSettings)
], DataSourceSettings.prototype, "conditionalFormatSettings", void 0);
__decorate$1([
    Property()
], DataSourceSettings.prototype, "emptyCellsTextContent", void 0);
__decorate$1([
    Collection([], GroupSettings)
], DataSourceSettings.prototype, "groupSettings", void 0);

var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Interface for a class SelectionSettings
 */
class PivotSelectionSettings extends ChildProperty {
}
__decorate$2([
    Property('Row')
], PivotSelectionSettings.prototype, "mode", void 0);
__decorate$2([
    Property('Flow')
], PivotSelectionSettings.prototype, "cellSelectionMode", void 0);
__decorate$2([
    Property('Single')
], PivotSelectionSettings.prototype, "type", void 0);
__decorate$2([
    Property(false)
], PivotSelectionSettings.prototype, "checkboxOnly", void 0);
__decorate$2([
    Property(false)
], PivotSelectionSettings.prototype, "persistSelection", void 0);
__decorate$2([
    Property('Default')
], PivotSelectionSettings.prototype, "checkboxMode", void 0);
__decorate$2([
    Property(false)
], PivotSelectionSettings.prototype, "enableSimpleMultiRowSelection", void 0);
/**
 *  Represents Pivot widget model class.
 */
class GridSettings extends ChildProperty {
}
__decorate$2([
    Property('auto')
], GridSettings.prototype, "height", void 0);
__decorate$2([
    Property('auto')
], GridSettings.prototype, "width", void 0);
__decorate$2([
    Property('Both')
], GridSettings.prototype, "gridLines", void 0);
__decorate$2([
    Property(false)
], GridSettings.prototype, "allowTextWrap", void 0);
__decorate$2([
    Property(false)
], GridSettings.prototype, "allowReordering", void 0);
__decorate$2([
    Property(true)
], GridSettings.prototype, "allowResizing", void 0);
__decorate$2([
    Property(null)
], GridSettings.prototype, "rowHeight", void 0);
__decorate$2([
    Property(110)
], GridSettings.prototype, "columnWidth", void 0);
__decorate$2([
    Property('Ellipsis')
], GridSettings.prototype, "clipMode", void 0);
__decorate$2([
    Property(false)
], GridSettings.prototype, "allowSelection", void 0);
__decorate$2([
    Property(-1)
], GridSettings.prototype, "selectedRowIndex", void 0);
__decorate$2([
    Property({ mode: 'Row', cellSelectionMode: 'Flow', type: 'Single' })
], GridSettings.prototype, "selectionSettings", void 0);
__decorate$2([
    Property({ WrapMode: 'Both' })
], GridSettings.prototype, "textWrapSettings", void 0);
__decorate$2([
    Property('AllPages')
], GridSettings.prototype, "printMode", void 0);
__decorate$2([
    Property()
], GridSettings.prototype, "contextMenuItems", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "beforeCopy", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "printComplete", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "beforePrint", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "beforePdfExport", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "beforeExcelExport", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "contextMenuOpen", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "contextMenuClick", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "queryCellInfo", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "headerCellInfo", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "rowSelecting", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "rowSelected", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "rowDeselecting", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "rowDeselected", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "cellSelecting", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "cellSelected", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "cellDeselecting", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "cellDeselected", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "resizeStart", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "resizing", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "resizeStop", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "pdfHeaderQueryCellInfo", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "pdfQueryCellInfo", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "excelHeaderQueryCellInfo", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "excelQueryCellInfo", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "columnDragStart", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "columnDrag", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "columnDrop", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "columnRender", void 0);

/**
 * @hidden
 * `ExcelExport` module is used to handle the Excel export action.
 */
class ExcelExport$1 {
    /**
     * Constructor for the PivotGrid Excel Export module.
     * @hidden
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * For internal use only - Get the module name.
     * @private
     */
    getModuleName() {
        return 'excelExport';
    }
    /* tslint:disable:max-func-body-length */
    /**
     * Method to perform excel export.
     * @hidden
     */
    exportToExcel(type) {
        this.engine = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
        /** Event trigerring */
        let clonedValues;
        let currentPivotValues = PivotUtil.getClonedPivotValues(this.engine.pivotValues);
        if (this.parent.enableVirtualization && this.parent.dataType !== 'olap') {
            let pageSettings = this.engine.pageSettings;
            this.engine.pageSettings = null;
            this.engine.generateGridData(this.parent.dataSourceSettings);
            this.parent.applyFormatting(this.engine.pivotValues);
            clonedValues = PivotUtil.getClonedPivotValues(this.engine.pivotValues);
            this.engine.pivotValues = currentPivotValues;
            this.engine.pageSettings = pageSettings;
        }
        else {
            clonedValues = currentPivotValues;
        }
        let args = {
            fileName: 'default', header: '', footer: '', dataCollections: [clonedValues]
        };
        this.parent.trigger(beforeExport, args);
        let fileName = args.fileName;
        let dataCollections = args.dataCollections;
        /** Fill data and export */
        /* tslint:disable-next-line:no-any */
        let workSheets = [];
        for (let dataColl = 0; dataColl < dataCollections.length; dataColl++) {
            let pivotValues = dataCollections[dataColl];
            let colLen = 0;
            let rowLen = pivotValues.length;
            let actualrCnt = 0;
            let formatList = this.parent.renderModule.getFormatList();
            let rows = [];
            let maxLevel = 0;
            for (let rCnt = 0; rCnt < rowLen; rCnt++) {
                if (pivotValues[rCnt]) {
                    actualrCnt++;
                    colLen = pivotValues[rCnt].length;
                    let cells = [];
                    for (let cCnt = 0; cCnt < colLen; cCnt++) {
                        if (pivotValues[rCnt][cCnt]) {
                            let pivotCell = pivotValues[rCnt][cCnt];
                            if (!(pivotCell.level === -1 && !pivotCell.rowSpan)) {
                                let cellValue = pivotCell.axis === 'value' ? pivotCell.value : pivotCell.formattedText;
                                if (pivotCell.type === 'grand sum') {
                                    cellValue = this.parent.localeObj.getConstant('grandTotal');
                                }
                                else if (pivotCell.type === 'sum') {
                                    cellValue = cellValue.toString().replace('Total', this.parent.localeObj.getConstant('total'));
                                }
                                else {
                                    cellValue = cellValue;
                                }
                                if (!(pivotCell.level === -1 && !pivotCell.rowSpan)) {
                                    cells.push({
                                        index: cCnt + 1, value: cellValue,
                                        colSpan: pivotCell.colSpan, rowSpan: (pivotCell.rowSpan === -1 ? 1 : pivotCell.rowSpan),
                                    });
                                    if (pivotCell.axis === 'value') {
                                        if (isNaN(pivotCell.value) || pivotCell.formattedText === '' ||
                                            pivotCell.formattedText === undefined || isNullOrUndefined(pivotCell.value)) {
                                            cells[cells.length - 1].value = '';
                                        }
                                        let field = (this.parent.dataSourceSettings.valueAxis === 'row' &&
                                            this.parent.dataType === 'olap' && pivotCell.rowOrdinal &&
                                            this.engine.tupRowInfo[pivotCell.rowOrdinal]) ?
                                            this.engine.tupRowInfo[pivotCell.rowOrdinal].measureName :
                                            pivotCell.actualText;
                                        cells[cells.length - 1].style = {
                                            numberFormat: formatList[field], bold: false, wrapText: true
                                        };
                                        if (pivotCell.style) {
                                            cells[cells.length - 1].style.backColor = pivotCell.style.backgroundColor;
                                            cells[cells.length - 1].style.fontColor = pivotCell.style.color;
                                            cells[cells.length - 1].style.fontName = pivotCell.style.fontFamily;
                                            cells[cells.length - 1].style.fontSize = Number(pivotCell.style.fontSize.split('px')[0]);
                                        }
                                    }
                                    else {
                                        cells[cells.length - 1].style = {
                                            bold: true, vAlign: 'Center', wrapText: true, indent: cCnt === 0 ? pivotCell.level * 10 : 0
                                        };
                                        if (pivotCell.axis === 'row' && cCnt === 0) {
                                            cells[cells.length - 1].style.hAlign = 'Left';
                                            if (this.parent.dataType === 'olap') {
                                                let indent = this.parent.renderModule.indentCollection[rCnt];
                                                cells[cells.length - 1].style.indent = indent * 2;
                                                maxLevel = maxLevel > indent ? maxLevel : indent;
                                            }
                                            else {
                                                cells[cells.length - 1].style.indent = pivotCell.level * 2;
                                                maxLevel = pivotCell.level > maxLevel ? pivotCell.level : maxLevel;
                                            }
                                        }
                                    }
                                    cells[cells.length - 1].style.borders = { color: '#000000', lineStyle: 'Thin' };
                                }
                            }
                            cCnt = cCnt + (pivotCell.colSpan ? (pivotCell.colSpan - 1) : 0);
                        }
                        else {
                            cells.push({
                                index: cCnt + 1, value: '', colSpan: 1, rowSpan: 1,
                            });
                        }
                    }
                    rows.push({ index: actualrCnt, cells: cells });
                }
            }
            let columns = [];
            for (let cCnt = 0; cCnt < colLen; cCnt++) {
                columns.push({ index: cCnt + 1, width: 100 });
            }
            if (maxLevel > 0) {
                columns[0].width = 100 + (maxLevel * 20);
            }
            workSheets.push({ columns: columns, rows: rows });
        }
        let book = new Workbook({ worksheets: workSheets }, type === 'Excel' ? 'xlsx' : 'csv');
        book.save(fileName + (type === 'Excel' ? '.xlsx' : '.csv'));
    }
    /**
     * To destroy the excel export module
     * @returns void
     * @hidden
     */
    /* tslint:disable:no-empty */
    destroy() {
    }
}

/**
 * @hidden
 * `PDFExport` module is used to handle the PDF export action.
 */
class PDFExport {
    /**
     * Constructor for the PivotGrid PDF Export module.
     * @hidden
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * For internal use only - Get the module name.
     * @private
     */
    getModuleName() {
        return 'pdfExport';
    }
    addPage(eventParams) {
        let page = eventParams.document.pages.add();
        let header = eventParams.args.header;
        let footer = eventParams.args.footer;
        let font = new PdfStandardFont(PdfFontFamily.TimesRoman, 15, PdfFontStyle.Regular);
        let brush = new PdfSolidBrush(new PdfColor(0, 0, 0));
        let pen = new PdfPen(new PdfColor(0, 0, 0), .5);
        /** Header and Footer to be set */
        let headerTemplate = new PdfPageTemplateElement(new RectangleF(0, 0, page.graphics.clientSize.width, 20));
        headerTemplate.graphics.drawString(header, font, pen, brush, 0, 0, new PdfStringFormat(PdfTextAlignment.Center));
        eventParams.document.template.top = headerTemplate;
        let footerTemplate = new PdfPageTemplateElement(new RectangleF(0, 0, page.graphics.clientSize.width, 20));
        footerTemplate.graphics.drawString(footer, font, pen, brush, 0, 0, new PdfStringFormat(PdfTextAlignment.Center));
        eventParams.document.template.bottom = footerTemplate;
        return page;
    }
    hexDecToRgb(hexDec) {
        if (hexDec === null || hexDec === '' || hexDec.length !== 7) {
            throw new Error('please set valid hex value for color..');
        }
        hexDec = hexDec.substring(1);
        let bigint = parseInt(hexDec, 16);
        let r = (bigint >> 16) & 255;
        let g = (bigint >> 8) & 255;
        let b = bigint & 255;
        return { r: r, g: g, b: b };
    }
    getFontStyle(theme) {
        let fontType = PdfFontStyle.Regular;
        if (!isNullOrUndefined(theme) && theme.bold) {
            fontType |= PdfFontStyle.Bold;
        }
        if (!isNullOrUndefined(theme) && theme.italic) {
            fontType |= PdfFontStyle.Italic;
        }
        if (!isNullOrUndefined(theme) && theme.underline) {
            fontType |= PdfFontStyle.Underline;
        }
        if (!isNullOrUndefined(theme) && theme.strikeout) {
            fontType |= PdfFontStyle.Strikeout;
        }
        return fontType;
    }
    getBorderStyle(borderStyle) {
        let borders = new PdfBorders();
        if (!isNullOrUndefined(borderStyle)) {
            let borderWidth = borderStyle.width;
            // set border width
            let width = (!isNullOrUndefined(borderWidth) && typeof borderWidth === 'number') ? borderWidth * 0.75 : undefined;
            // set border color
            let color = new PdfColor(196, 196, 196);
            if (!isNullOrUndefined(borderStyle.color)) {
                let borderColor = this.hexDecToRgb(borderStyle.color);
                color = new PdfColor(borderColor.r, borderColor.g, borderColor.b);
            }
            let pen = new PdfPen(color, width);
            // set border dashStyle 'Solid <default>, Dash, Dot, DashDot, DashDotDot'
            if (!isNullOrUndefined(borderStyle.dashStyle)) {
                pen.dashStyle = this.getDashStyle(borderStyle.dashStyle);
            }
            borders.all = pen;
        }
        else {
            let pdfColor = new PdfColor(234, 234, 234);
            borders.all = new PdfPen(pdfColor);
        }
        return borders;
    }
    getDashStyle(dashType) {
        switch (dashType) {
            case 'Dash':
                return 1;
            case 'Dot':
                return 2;
            case 'DashDot':
                return 3;
            case 'DashDotDot':
                return 4;
            default:
                return 0;
        }
    }
    getStyle() {
        let border = new PdfBorders();
        if (!isNullOrUndefined(this.gridStyle)) {
            let fontFamily = !isNullOrUndefined(this.gridStyle.header.fontName) ?
                this.getFontFamily(this.gridStyle.header.fontName) : PdfFontFamily.Helvetica;
            let fontStyle = this.getFontStyle(this.gridStyle.header);
            let fontSize = !isNullOrUndefined(this.gridStyle.header.fontSize) ? this.gridStyle.header.fontSize : 10.5;
            let pdfColor = new PdfColor();
            if (!isNullOrUndefined(this.gridStyle.header.fontColor)) {
                let penBrushColor = this.hexDecToRgb(this.gridStyle.header.fontColor);
                pdfColor = new PdfColor(penBrushColor.r, penBrushColor.g, penBrushColor.b);
            }
            let font = new PdfStandardFont(fontFamily, fontSize, fontStyle);
            if (!isNullOrUndefined(this.gridStyle.header.font)) {
                font = this.gridStyle.header.font;
            }
            return {
                border: this.getBorderStyle(this.gridStyle.header.border), font: font, brush: new PdfSolidBrush(pdfColor)
            };
        }
        else {
            return {
                brush: new PdfSolidBrush(new PdfColor()),
                border: border, font: undefined
            };
        }
    }
    setRecordThemeStyle(row, border) {
        if (!isNullOrUndefined(this.gridStyle) && !isNullOrUndefined(this.gridStyle.record)) {
            let fontFamily = !isNullOrUndefined(this.gridStyle.record.fontName) ?
                this.getFontFamily(this.gridStyle.record.fontName) : PdfFontFamily.Helvetica;
            let fontSize = !isNullOrUndefined(this.gridStyle.record.fontSize) ? this.gridStyle.record.fontSize : 9.75;
            let fontStyle = this.getFontStyle(this.gridStyle.record);
            let font = new PdfStandardFont(fontFamily, fontSize, fontStyle);
            if (!isNullOrUndefined(this.gridStyle.record.font)) {
                font = this.gridStyle.record.font;
            }
            row.style.setFont(font);
            let pdfColor = new PdfColor();
            if (!isNullOrUndefined(this.gridStyle.record.fontColor)) {
                let penBrushColor = this.hexDecToRgb(this.gridStyle.record.fontColor);
                pdfColor = new PdfColor(penBrushColor.r, penBrushColor.g, penBrushColor.b);
            }
            row.style.setTextBrush(new PdfSolidBrush(pdfColor));
        }
        let borderRecord = this.gridStyle && this.gridStyle.record &&
            this.gridStyle.record.border ? this.getBorderStyle(this.gridStyle.record.border) : border;
        row.style.setBorder(borderRecord);
        return row;
    }
    /**
     * Method to perform pdf export.
     * @hidden
     */
    /* tslint:disable:max-func-body-length */
    exportToPDF() {
        this.engine = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
        let eventParams = this.applyEvent();
        let headerStyle = this.getStyle();
        let indent = this.parent.renderModule.maxIndent ? this.parent.renderModule.maxIndent : 5;
        let firstColumnWidth = 100 + (indent * 20);
        let size = Math.floor((540 - firstColumnWidth) / 90) + 1;
        /** Fill data and export */
        let dataCollIndex = 0;
        let pivotValues = eventParams.args.dataCollections[dataCollIndex];
        for (let vLen = 0; eventParams.args.allowRepeatHeader && size > 1 && vLen < pivotValues.length; vLen++) {
            for (let vCnt = size; pivotValues[vLen] && vCnt < pivotValues[vLen].length; vCnt += size) {
                pivotValues[vLen].splice(vCnt, 0, pivotValues[vLen][0]);
            }
        }
        let colLength = pivotValues && pivotValues.length > 0 ? pivotValues[0].length : 0;
        let integratedCnt = 0;
        do {
            let page = this.addPage(eventParams);
            let pdfGrid = new PdfGrid();
            let pageSize = size > 1 ? size : 5;
            if (pivotValues && pivotValues.length > 0) {
                pdfGrid.columns.add(pivotValues[0].length - integratedCnt >= pageSize ? pageSize : pivotValues[0].length - integratedCnt);
                let rowLen = pivotValues.length;
                let actualrCnt = 0;
                let maxLevel = 0;
                for (let rCnt = 0; rCnt < rowLen; rCnt++) {
                    if (pivotValues[rCnt]) {
                        let isColHeader = !(pivotValues[rCnt][0] && pivotValues[rCnt][0].axis === 'row');
                        let colLen = pivotValues[rCnt].length > (integratedCnt + pageSize) ? (integratedCnt + pageSize) :
                            pivotValues[rCnt].length;
                        if (isColHeader) {
                            pdfGrid.headers.add(1);
                        }
                        let pdfGridRow = !isColHeader ? pdfGrid.rows.addRow() : pdfGrid.headers.getHeader(actualrCnt);
                        if (isColHeader) {
                            pdfGridRow.style.setBorder(headerStyle.border);
                            if (headerStyle.font) {
                                pdfGridRow.style.setFont(headerStyle.font);
                            }
                            pdfGridRow.style.setTextBrush(headerStyle.brush);
                        }
                        else {
                            this.setRecordThemeStyle(pdfGridRow, headerStyle.border);
                        }
                        let localCnt = 0;
                        let isEmptyRow = true;
                        for (let cCnt = integratedCnt; cCnt < colLen; cCnt++) {
                            let isValueCell = false;
                            if (pivotValues[rCnt][cCnt]) {
                                let pivotCell = pivotValues[rCnt][cCnt];
                                if (!(pivotCell.level === -1 && !pivotCell.rowSpan)) {
                                    let cellValue = pivotCell.formattedText;
                                    cellValue = pivotCell.type === 'grand sum' ? this.parent.localeObj.getConstant('grandTotal') :
                                        (pivotCell.type === 'sum' ?
                                            cellValue.toString().replace('Total', this.parent.localeObj.getConstant('total')) : cellValue);
                                    if (!(pivotCell.level === -1 && !pivotCell.rowSpan)) {
                                        pdfGridRow.cells.getCell(localCnt).columnSpan = pivotCell.colSpan ?
                                            (pageSize - localCnt < pivotCell.colSpan ? pageSize - localCnt : pivotCell.colSpan) : 1;
                                        if (isColHeader && pivotCell.rowSpan && pivotCell.rowSpan > 1) {
                                            pdfGridRow.cells.getCell(localCnt).rowSpan = pivotCell.rowSpan ? pivotCell.rowSpan : 1;
                                        }
                                        pdfGridRow.cells.getCell(localCnt).value = cellValue ? cellValue.toString() : '';
                                    }
                                    if (cellValue !== '') {
                                        isEmptyRow = false;
                                    }
                                }
                                maxLevel = pivotCell.level > maxLevel ? pivotCell.level : maxLevel;
                                isValueCell = pivotCell.axis === 'value';
                                cCnt = cCnt + (pdfGridRow.cells.getCell(localCnt).columnSpan ?
                                    (pdfGridRow.cells.getCell(localCnt).columnSpan - 1) : 0);
                                localCnt = localCnt + (pdfGridRow.cells.getCell(localCnt).columnSpan ?
                                    (pdfGridRow.cells.getCell(localCnt).columnSpan - 1) : 0);
                                if (pivotCell.style) {
                                    pdfGridRow = this.applyStyle(pdfGridRow, pivotCell, localCnt);
                                }
                                let args = {
                                    style: (pivotCell && pivotCell.isSum) ? { bold: true } : undefined,
                                    pivotCell: pivotCell,
                                    cell: pdfGridRow.cells.getCell(localCnt)
                                };
                                this.parent.trigger(onPdfCellRender, args);
                                if (args.style) {
                                    this.processCellStyle(pdfGridRow.cells.getCell(localCnt), args);
                                }
                            }
                            else {
                                let args = {
                                    style: undefined,
                                    pivotCell: undefined,
                                    cell: pdfGridRow.cells.getCell(localCnt)
                                };
                                this.parent.trigger(onPdfCellRender, args);
                                if (args.style) {
                                    this.processCellStyle(pdfGridRow.cells.getCell(localCnt), args);
                                }
                                pdfGridRow.cells.getCell(localCnt).value = '';
                                if (cCnt === 0 && isColHeader && this.parent.dataSourceSettings.columns &&
                                    this.parent.dataSourceSettings.columns.length > 0) {
                                    pdfGrid.headers.getHeader(0).cells.getCell(0).rowSpan++;
                                }
                                else if (cCnt !== 0 && isColHeader && this.parent.dataSourceSettings.columns &&
                                    this.parent.dataSourceSettings.columns.length > 0 &&
                                    pdfGrid.headers.getHeader(0).cells.getCell(0).rowSpan <
                                        Object.keys(this.engine.headerContent).length) {
                                    pdfGrid.headers.getHeader(0).cells.getCell(0).rowSpan++;
                                }
                            }
                            let stringFormat = new PdfStringFormat();
                            if (this.parent.dataType === 'olap') {
                                let indent = (!isColHeader && localCnt === 0 && pivotValues[rCnt][cCnt]) ?
                                    (this.parent.renderModule.indentCollection[pivotValues[rCnt][cCnt].rowIndex]) : 0;
                                stringFormat.paragraphIndent = indent * 15;
                                maxLevel = maxLevel > indent ? maxLevel : indent;
                            }
                            else {
                                stringFormat.paragraphIndent = (!isColHeader && localCnt === 0 && pivotValues[rCnt][cCnt] &&
                                    pivotValues[rCnt][cCnt].level !== -1) ?
                                    pivotValues[rCnt][cCnt].level * 15 : 0;
                            }
                            stringFormat.alignment = isValueCell ? PdfTextAlignment.Right : PdfTextAlignment.Left;
                            stringFormat.lineAlignment = PdfVerticalAlignment.Middle;
                            pdfGridRow.cells.getCell(localCnt).style.stringFormat = stringFormat;
                            localCnt++;
                        }
                        if (isEmptyRow) {
                            pdfGridRow.height = 16;
                        }
                        actualrCnt++;
                    }
                }
                pdfGrid.columns.getColumn(0).width = 100 + (maxLevel * 20);
            }
            if (integratedCnt === 0 && this.parent.dataSourceSettings.columns && this.parent.dataSourceSettings.columns.length > 0) {
                pdfGrid.headers.getHeader(0).cells.getCell(0).rowSpan--;
            }
            pdfGrid.draw(page, new PointF(10, 20));
            integratedCnt = integratedCnt + pageSize;
            if (integratedCnt >= colLength && eventParams.args.dataCollections.length > (dataCollIndex + 1)) {
                dataCollIndex++;
                pivotValues = eventParams.args.dataCollections[dataCollIndex];
                colLength = pivotValues && pivotValues.length > 0 ? pivotValues[0].length : 0;
                integratedCnt = 0;
            }
        } while (integratedCnt < colLength);
        eventParams.document.save(eventParams.args.fileName + '.pdf');
        eventParams.document.destroy();
    }
    applyStyle(pdfGridRow, pivotCell, localCnt) {
        let color = this.parent.conditionalFormattingModule.hexToRgb(pivotCell.style.backgroundColor);
        let brush = new PdfSolidBrush(new PdfColor(color.r, color.g, color.b));
        pdfGridRow.cells.getCell(localCnt).style.backgroundBrush = brush;
        let size = Number(pivotCell.style.fontSize.split('px')[0]);
        let font = new PdfStandardFont(PdfFontFamily.TimesRoman, size, PdfFontStyle.Regular);
        pdfGridRow.cells.getCell(localCnt).style.font = font;
        color = this.parent.conditionalFormattingModule.hexToRgb(pivotCell.style.color);
        brush = new PdfSolidBrush(new PdfColor(color.r, color.g, color.b));
        pdfGridRow.cells.getCell(localCnt).style.textBrush = brush;
        return pdfGridRow;
    }
    getFontFamily(family) {
        switch (family) {
            case 'TimesRoman':
                return 2;
            case 'Courier':
                return 1;
            case 'Symbol':
                return 3;
            case 'ZapfDingbats':
                return 4;
            default:
                return 0;
        }
    }
    /* tslint:disable-next-line:no-any */
    getFont(theme) {
        if (theme.style.font) {
            return theme.style.font;
        }
        let fontSize = (theme.cell.cellStyle.font && theme.cell.cellStyle.font.fontSize) ? theme.cell.cellStyle.font.fontSize :
            (!isNullOrUndefined(theme.style.fontSize)) ? (theme.style.fontSize * 0.75) : 9.75;
        let fontFamily = (!isNullOrUndefined(theme.style.fontFamily)) ?
            (this.getFontFamily(theme.style.fontFamily)) : PdfFontFamily.TimesRoman;
        let fontStyle = PdfFontStyle.Regular;
        if (!isNullOrUndefined(theme.style.bold) && theme.style.bold) {
            fontStyle |= PdfFontStyle.Bold;
        }
        if (!isNullOrUndefined(theme.style.italic) && theme.style.italic) {
            fontStyle |= PdfFontStyle.Italic;
        }
        if (!isNullOrUndefined(theme.style.underline) && theme.style.underline) {
            fontStyle |= PdfFontStyle.Underline;
        }
        if (!isNullOrUndefined(theme.style.strikeout) && theme.style.strikeout) {
            fontStyle |= PdfFontStyle.Strikeout;
        }
        return new PdfStandardFont(fontFamily, fontSize, fontStyle);
    }
    processCellStyle(gridCell, arg) {
        if (!isNullOrUndefined(arg.style.backgroundColor)) {
            let backColor = this.hexDecToRgb(arg.style.backgroundColor);
            gridCell.style.backgroundBrush = new PdfSolidBrush(new PdfColor(backColor.r, backColor.g, backColor.b));
        }
        if (!isNullOrUndefined(arg.style.textBrushColor)) {
            let textBrushColor = this.hexDecToRgb(arg.style.textBrushColor);
            gridCell.style.textBrush = new PdfSolidBrush(new PdfColor(textBrushColor.r, textBrushColor.g, textBrushColor.b));
        }
        if (!isNullOrUndefined(arg.style.textPenColor)) {
            let textColor = this.hexDecToRgb(arg.style.textPenColor);
            gridCell.style.textPen = new PdfPen(new PdfColor(textColor.r, textColor.g, textColor.b));
        }
        if (!isNullOrUndefined(arg.style.fontFamily) || !isNullOrUndefined(arg.style.fontSize) || !isNullOrUndefined(arg.style.bold) ||
            !isNullOrUndefined(arg.style.italic) || !isNullOrUndefined(arg.style.underline) || !isNullOrUndefined(arg.style.strikeout)) {
            gridCell.style.font = this.getFont(arg);
        }
        if (!isNullOrUndefined(arg.style.border)) {
            let border = new PdfBorders();
            let borderWidth = arg.style.border.width;
            // set border width
            let width = (!isNullOrUndefined(borderWidth) && typeof borderWidth === 'number') ? (borderWidth * 0.75) : (undefined);
            // set border color
            let color = new PdfColor(196, 196, 196);
            if (!isNullOrUndefined(arg.style.border.color)) {
                let borderColor = this.hexDecToRgb(arg.style.border.color);
                color = new PdfColor(borderColor.r, borderColor.g, borderColor.b);
            }
            let pen = new PdfPen(color, width);
            // set border dashStyle 'Solid <default>, Dash, Dot, DashDot, DashDotDot'
            if (!isNullOrUndefined(arg.style.border.dashStyle)) {
                pen.dashStyle = this.getDashStyle(arg.style.border.dashStyle);
            }
            border.all = pen;
            gridCell.style.borders = border;
        }
    }
    applyEvent() {
        /** Event trigerring */
        let clonedValues;
        let currentPivotValues = PivotUtil.getClonedPivotValues(this.engine.pivotValues);
        if (this.parent.enableVirtualization && this.parent.dataType !== 'olap') {
            let pageSettings = this.engine.pageSettings;
            this.engine.pageSettings = null;
            this.engine.generateGridData(this.parent.dataSourceSettings);
            this.parent.applyFormatting(this.engine.pivotValues);
            clonedValues = PivotUtil.getClonedPivotValues(this.engine.pivotValues);
            this.engine.pivotValues = currentPivotValues;
            this.engine.pageSettings = pageSettings;
        }
        else {
            clonedValues = currentPivotValues;
        }
        let style;
        let args = {
            fileName: 'default', header: '', footer: '', dataCollections: [clonedValues], allowRepeatHeader: true, style: style
        };
        this.parent.trigger(beforeExport, args);
        this.gridStyle = args.style;
        let document = new PdfDocument();
        return { document: document, args: args };
    }
    /**
     * To destroy the pdf export module
     * @returns void
     * @hidden
     */
    /* tslint:disable:no-empty */
    destroy() {
    }
}

/**
 * PivotView Keyboard interaction
 */
/** @hidden */
class KeyboardInteraction {
    /**
     * Constructor
     */
    constructor(parent) {
        this.keyConfigs = {
            tab: 'tab',
            enter: 'enter',
            shiftUp: 'shift+upArrow',
            shiftDown: 'shift+downArrow',
            shiftLeft: 'shift+leftArrow',
            shiftRight: 'shift+rightArrow',
            upArrow: 'upArrow',
            downArrow: 'downArrow',
            leftArrow: 'leftArrow',
            rightArrow: 'rightArrow',
            escape: 'escape'
        };
        this.parent = parent;
        this.parent.element.tabIndex = this.parent.element.tabIndex === -1 ? 0 : this.parent.element.tabIndex;
        this.pivotViewKeyboardModule = new KeyboardEvents(this.parent.element, {
            keyAction: this.keyActionHandler.bind(this),
            keyConfigs: this.keyConfigs,
            eventName: 'keydown'
        });
    }
    keyActionHandler(e) {
        switch (e.action) {
            case 'tab':
                this.processTab(e);
                break;
            case 'enter':
                this.processEnter(e);
                break;
            case 'shiftUp':
            case 'shiftDown':
            case 'shiftLeft':
            case 'shiftRight':
            case 'upArrow':
            case 'downArrow':
            case 'leftArrow':
            case 'rightArrow':
                this.processSelection(e);
                break;
            case 'escape':
                this.clearSelection();
                break;
        }
    }
    getNextButton(target) {
        let allPivotButtons = [].slice.call(this.parent.element.querySelectorAll('.' + PIVOT_BUTTON_CLASS));
        let nextElement = target;
        if (this.parent.grid.element.querySelector('.' + PIVOT_BUTTON_CLASS)) {
            let len = allPivotButtons.length;
            for (let i = 0; i < len; i++) {
                if (allPivotButtons[i].getAttribute('data-uid') === target.getAttribute('data-uid')) {
                    nextElement = allPivotButtons[i + 1] ? allPivotButtons[i + 1] : nextElement;
                    break;
                }
            }
        }
        return nextElement;
    }
    processTab(e) {
        let target = e.target;
        if (target && closest(target, '.' + PIVOT_BUTTON_CLASS)) {
            let gridFocus = this.parent.grid.serviceLocator.getService('focus');
            let nextButton = this.getNextButton(target);
            if (nextButton.getAttribute('data-uid') !== target.getAttribute('data-uid')) {
                gridFocus.currentInfo.skipAction = true;
                nextButton.focus();
            }
            else {
                gridFocus.focus();
                let element = gridFocus.getFocusedElement();
                addClass([element], ['e-focused', 'e-focus']);
                element.setAttribute('tabindex', '0');
            }
            e.preventDefault();
            return;
        }
        else if (!this.parent.showGroupingBar && this.parent.showFieldList) {
            if (target && closest(target, '.' + TOGGLE_FIELD_LIST_CLASS)) {
                let gridFocus = this.parent.grid.serviceLocator.getService('focus');
                gridFocus.focus();
                let element = gridFocus.getFocusedElement();
                addClass([element], ['e-focused', 'e-focus']);
                element.setAttribute('tabindex', '0');
            }
        }
        else if (!this.parent.showGroupingBar && !this.parent.showFieldList) {
            if (target && closest(target, '.' + PIVOT_VIEW_CLASS)) {
                let gridElement = closest(target, '.' + PIVOT_VIEW_CLASS);
                let gridFocus = this.parent.grid.serviceLocator.getService('focus');
                let rows = [].slice.call(gridElement.getElementsByTagName('tr'));
                if (target.innerHTML === (rows[rows.length - 1]).lastChild.innerHTML) {
                    gridFocus.currentInfo.skipAction = true;
                }
                else {
                    gridFocus.focus();
                    let element = gridFocus.getFocusedElement();
                    addClass([element], ['e-focused', 'e-focus']);
                    element.setAttribute('tabindex', '0');
                }
            }
        }
    }
    processEnter(e) {
        let target = e.target;
        if (target && closest(target, '.' + GRID_CLASS)) {
            if (target.querySelector('.' + ICON)) {
                target.querySelector('.' + ICON).click();
            }
            else if (target.classList.contains('e-valuescontent')) {
                target.dispatchEvent(new MouseEvent('dblclick', {
                    'view': window,
                    'bubbles': true,
                    'cancelable': true
                }));
            }
            e.preventDefault();
            return;
        }
    }
    clearSelection() {
        let control = this.parent;
        /* tslint:disable */
        removeClass(control.element.querySelectorAll('.' + CELL_SELECTED_BGCOLOR + ',.' + SELECTED_BGCOLOR), [SELECTED_BGCOLOR, CELL_SELECTED_BGCOLOR, CELL_ACTIVE_BGCOLOR]);
        this.parent.renderModule.selected();
        /* tslint:enable */
    }
    processSelection(e) {
        if (this.parent.gridSettings.allowSelection && this.parent.gridSettings.selectionSettings.mode !== 'Row') {
            let target = e.target;
            let control = this.parent;
            let colIndex = Number(e.target.getAttribute('aria-colIndex'));
            let rowIndex = Number(e.target.getAttribute('index'));
            let ele;
            /* tslint:disable */
            if (target.nodeName === 'TH' || target.nodeName === 'TD') {
                if (e.action === 'shiftUp' || e.action === 'upArrow') {
                    ele = (rowIndex === 0 || colIndex === 0 || (target.nodeName !== 'TH' &&
                        control.renderModule.rowStartPos !== rowIndex)) ? null : this.getParentElement(control, ele, colIndex, rowIndex - 1);
                }
                else if (e.action === 'shiftDown' || e.action === 'downArrow') {
                    ele = control.element.querySelector('th[aria-colindex="' + colIndex + '"][index="' + (rowIndex + 1) + '"]');
                }
                else if (e.action === 'shiftLeft' || e.action === 'leftArrow') {
                    ele = e.target.previousSibling;
                }
                else {
                    ele = e.target.nextSibling;
                }
            }
            if (!isNullOrUndefined(ele)) {
                if (control.gridSettings.selectionSettings.mode === 'Both' ? !ele.classList.contains(ROW_CELL_CLASS) : true) {
                    colIndex = Number(ele.getAttribute('aria-colindex'));
                    rowIndex = Number(ele.getAttribute('index'));
                    let colSpan = Number(ele.getAttribute('aria-colspan'));
                    control.clearSelection(ele, e, colIndex, rowIndex);
                    let selectArgs = {
                        cancel: false,
                        isCellClick: true,
                        currentCell: ele,
                        data: control.pivotValues[rowIndex][colIndex]
                    };
                    control.trigger(cellSelecting, selectArgs, (observedArgs) => {
                        if (!observedArgs.cancel) {
                            control.applyColumnSelection(e, ele, colIndex, colIndex + (colSpan > 0 ? (colSpan - 1) : 0), rowIndex);
                        }
                    });
                }
                else {
                    control.clearSelection(ele, e, colIndex, rowIndex);
                }
            }
            else {
                if (e.action === 'upArrow') {
                    ele = control.element.querySelector('[aria-colindex="' + colIndex + '"][index="' + (rowIndex - 1) + '"]');
                    rowIndex--;
                }
                else if (e.action === 'downArrow') {
                    ele = control.element.querySelector('[aria-colindex="' + colIndex + '"][index="' + (rowIndex + 1) + '"]');
                    rowIndex++;
                }
                if (!isNullOrUndefined(ele)) {
                    control.clearSelection(ele, e, colIndex, rowIndex);
                }
            }
        }
        /* tslint:enable */
    }
    getParentElement(control, ele, colIndex, rowIndex) {
        while (!ele) {
            ele = control.element.querySelector('[aria-colindex="' + colIndex + '"][index="' + rowIndex + '"]');
            colIndex--;
        }
        return ele;
    }
    /**
     * To destroy the keyboard module.
     * @return {void}
     * @private
     */
    destroy() {
        if (this.pivotViewKeyboardModule) {
            this.pivotViewKeyboardModule.destroy();
        }
        else {
            return;
        }
    }
}

/**
 * Module to render Pivot button
 */
/** @hidden */
class PivotContextMenu {
    /** Constructor for render module */
    constructor(parent) {
        this.parent = parent;
        this.parent.contextMenuModule = this;
    }
    /**
     * Initialize the pivot table rendering
     * @returns void
     * @private
     */
    render() {
        this.renderContextMenu();
    }
    renderContextMenu() {
        let menuItems = [
            { text: this.parent.localeObj.getConstant('addToFilter'), id: this.parent.element.id + '_Filters' },
            { text: this.parent.localeObj.getConstant('addToRow'), id: this.parent.element.id + '_Rows' },
            { text: this.parent.localeObj.getConstant('addToColumn'), id: this.parent.element.id + '_Columns' },
            { text: this.parent.localeObj.getConstant('addToValue'), id: this.parent.element.id + '_Values' }
        ];
        let menuOptions = {
            cssClass: PIVOT_CONTEXT_MENU_CLASS,
            items: menuItems,
            enableRtl: this.parent.enableRtl,
            beforeOpen: this.onBeforeMenuOpen.bind(this),
            select: this.onSelectContextMenu.bind(this)
        };
        let cMenu = createElement('ul', {
            id: this.parent.element.id + '_PivotContextMenu'
        });
        this.parent.element.appendChild(cMenu);
        this.menuObj = new ContextMenu$1(menuOptions);
        this.menuObj.isStringTemplate = true;
        this.menuObj.appendTo(cMenu);
    }
    onBeforeMenuOpen(args) {
        let items = [].slice.call(args.element.querySelectorAll('li'));
        let fieldType = this.parent.dataType === 'olap' ? this.fieldElement.getAttribute('data-type') :
            this.fieldElement.querySelector('.' + PIVOT_BUTTON_CONTENT_CLASS).getAttribute('data-type');
        removeClass(items, MENU_DISABLE);
        if (fieldType === 'CalculatedField' || fieldType === 'isMeasureFieldsAvail') {
            for (let item of items) {
                if (item.textContent !== this.parent.localeObj.getConstant('addToValue')) {
                    addClass([item], MENU_DISABLE);
                }
            }
        }
        else if (fieldType === 'isMeasureAvail') {
            for (let item of items) {
                if (item.textContent !== this.parent.localeObj.getConstant('addToRow') &&
                    item.textContent !== this.parent.localeObj.getConstant('addToColumn')) {
                    addClass([item], MENU_DISABLE);
                }
            }
        }
        else if (this.parent.dataType === 'olap') {
            for (let item of items) {
                if (item.textContent === this.parent.localeObj.getConstant('addToValue')) {
                    addClass([item], MENU_DISABLE);
                    break;
                }
            }
        }
    }
    onSelectContextMenu(menu) {
        if (menu.element.textContent !== null) {
            let fieldName = this.fieldElement.getAttribute('data-uid');
            let dropClass = menu.item.id.replace(this.parent.element.id + '_', '').toLowerCase();
            this.parent.pivotCommon.dataSourceUpdate.control = this.parent.getModuleName() === 'pivotview' ? this.parent :
                (this.parent.pivotGridModule ? this.parent.pivotGridModule : this.parent);
            this.parent.pivotCommon.dataSourceUpdate.btnElement = this.fieldElement;
            this.parent.pivotCommon.dataSourceUpdate.updateDataSource(fieldName, dropClass, -1);
            this.parent.updateDataSource(true);
            this.fieldElement = undefined;
        }
    }
    /**
     * To destroy the pivot button event listener
     * @return {void}
     * @hidden
     */
    destroy() {
        if (!this.parent.isDestroyed) {
            return;
        }
        if (this.menuObj && !this.menuObj.isDestroyed) {
            this.menuObj.destroy();
        }
        else {
            return;
        }
    }
}

/**
 * `VirtualScroll` module is used to handle scrolling behavior.
 */
class VirtualScroll$1 {
    /**
     * Constructor for PivotView scrolling.
     * @hidden
     */
    constructor(parent) {
        this.previousValues = { top: 0, left: 0 };
        this.frozenPreviousValues = { top: 0, left: 0 };
        this.eventType = '';
        this.parent = parent;
        this.engineModule = this.parent.dataType === 'pivot' ? this.parent.engineModule : this.parent.olapEngineModule;
        this.addInternalEvents();
    }
    /**
     * It returns the Module name.
     * @returns string
     * @hidden
     */
    getModuleName() {
        return 'virtualscroll';
    }
    addInternalEvents() {
        this.parent.on(contentReady, this.wireEvents, this);
    }
    wireEvents() {
        let mCont = this.parent.element.querySelector('.' + MOVABLECONTENT_DIV);
        let fCont = this.parent.element.querySelector('.' + FROZENCONTENT_DIV);
        let mHdr = this.parent.element.querySelector('.' + MOVABLEHEADER_DIV);
        EventHandler.clearEvents(mCont);
        EventHandler.clearEvents(fCont);
        if (this.engineModule) {
            EventHandler.add(mCont, 'scroll touchmove pointermove', this.onHorizondalScroll(mHdr, mCont, fCont), this);
            EventHandler.add(mCont, 'scroll wheel touchmove pointermove', this.onVerticalScroll(fCont, mCont), this);
            EventHandler.add(mCont, 'mouseup touchend', this.common(mHdr, mCont, fCont), this);
            EventHandler.add(fCont, 'wheel', this.onWheelScroll(mCont, fCont), this);
            EventHandler.add(fCont, 'touchstart pointerdown', this.setPageXY(), this);
            EventHandler.add(fCont, 'touchmove pointermove', this.onTouchScroll(mHdr, mCont, fCont), this);
            EventHandler.add(mHdr, 'touchstart pointerdown', this.setPageXY(), this);
            EventHandler.add(mHdr, 'touchmove pointermove', this.onTouchScroll(mHdr, mCont, fCont), this);
        }
        this.parent.grid.isPreventScrollEvent = true;
    }
    onWheelScroll(mCont, fCont) {
        let element = mCont;
        return (e) => {
            let top = element.scrollTop + (e.deltaMode === 1 ? e.deltaY * 30 : e.deltaY);
            if (this.frozenPreviousValues.top === top) {
                return;
            }
            e.preventDefault();
            fCont.scrollTop = top;
            element.scrollTop = top;
            this.frozenPreviousValues.top = top;
            this.eventType = e.type;
        };
    }
    getPointXY(e) {
        let pageXY = { x: 0, y: 0 };
        if (!(e.touches && e.touches.length)) {
            pageXY.x = e.pageX;
            pageXY.y = e.pageY;
        }
        else {
            pageXY.x = e.touches[0].pageX;
            pageXY.y = e.touches[0].pageY;
        }
        return pageXY;
    }
    onTouchScroll(mHdr, mCont, fCont) {
        let element = mCont;
        return (e) => {
            if (e.pointerType === 'mouse') {
                return;
            }
            let pageXY = this.getPointXY(e);
            let top = element.scrollTop + (this.pageXY.y - pageXY.y);
            let left = element.scrollLeft + (this.pageXY.x - pageXY.x);
            if (this.parent.element.querySelector('.' + HEADERCONTENT).contains(e.target)) {
                if (this.frozenPreviousValues.left === left || left < 0) {
                    return;
                }
                mHdr.scrollLeft = left;
                element.scrollLeft = left;
                this.pageXY.x = pageXY.x;
                this.frozenPreviousValues.left = left;
            }
            else {
                if (this.frozenPreviousValues.top === top || top < 0) {
                    return;
                }
                fCont.scrollTop = top;
                element.scrollTop = top;
                this.pageXY.y = pageXY.y;
                this.frozenPreviousValues.top = top;
            }
            this.eventType = e.type;
        };
    }
    update(mHdr, mCont, top, left, e) {
        this.parent.isScrolling = true;
        let engine = this.parent.dataType === 'pivot' ? this.parent.engineModule : this.parent.olapEngineModule;
        if (isBlazor()) {
            engine.pageSettings = this.parent.pageSettings;
        }
        if (this.parent.pageSettings && engine.pageSettings) {
            if (this.direction === 'vertical') {
                let rowValues = this.parent.dataType === 'pivot' ?
                    (this.parent.dataSourceSettings.valueAxis === 'row' ? this.parent.dataSourceSettings.values.length : 1) : 1;
                let exactSize = (this.parent.pageSettings.rowSize * rowValues * this.parent.gridSettings.rowHeight);
                let section = Math.ceil(top / exactSize);
                if ((this.parent.scrollPosObject.vertical === section ||
                    engine.pageSettings.rowSize >= engine.rowCount)) {
                    this.parent.hideWaitingPopup();
                    return;
                }
                this.parent.showWaitingPopup();
                this.parent.scrollPosObject.vertical = section;
                engine.pageSettings.rowCurrentPage = section > 1 ? section : 1;
                let rowStartPos = 0;
                if (this.parent.dataType === 'pivot') {
                    if (isBlazor()) {
                        let pivot = this.parent;
                        let ejsInterop = 'ejsInterop';
                        /* tslint:disable-next-line */
                        let dataSourceSettings = window[ejsInterop].
                            copyWithoutCircularReferences([pivot.dataSourceSettings], pivot.dataSourceSettings);
                        /* tslint:disable-next-line */
                        let pageSettings = window[ejsInterop].
                            copyWithoutCircularReferences([engine.pageSettings], engine.pageSettings);
                        /* tslint:disable-next-line */
                        pivot.interopAdaptor.invokeMethodAsync('PivotInteropMethod', 'generateGridData', {
                            'dataSourceSettings': dataSourceSettings,
                            'pageSettings': pageSettings, 'isScrolling': true
                        }).then(
                        /* tslint:disable-next-line */
                        (data) => {
                            pivot.updateBlazorData(data, pivot);
                            pivot.pivotValues = engine.pivotValues;
                            rowStartPos = this.parent.engineModule.rowStartPos;
                            let exactPage = Math.ceil(rowStartPos / (pivot.pageSettings.rowSize * rowValues));
                            let pos = exactSize * exactPage -
                                (engine.rowFirstLvl * rowValues * pivot.gridSettings.rowHeight);
                            pivot.scrollPosObject.verticalSection = pos;
                        });
                    }
                    else {
                        this.parent.engineModule.generateGridData(this.parent.dataSourceSettings, this.parent.engineModule.headerCollection);
                        rowStartPos = this.parent.engineModule.rowStartPos;
                    }
                }
                else {
                    this.parent.olapEngineModule.scrollPage('scroll');
                    rowStartPos = this.parent.olapEngineModule.pageRowStartPos;
                }
                if (!(isBlazor() && this.parent.dataType === 'pivot')) {
                    this.parent.pivotValues = engine.pivotValues;
                    let exactPage = Math.ceil(rowStartPos / (this.parent.pageSettings.rowSize * rowValues));
                    let pos = exactSize * exactPage -
                        (engine.rowFirstLvl * rowValues * this.parent.gridSettings.rowHeight);
                    this.parent.scrollPosObject.verticalSection = pos;
                }
            }
            else {
                let colValues = this.parent.dataType === 'pivot' ?
                    (this.parent.dataSourceSettings.valueAxis === 'column' ? this.parent.dataSourceSettings.values.length : 1) : 1;
                let exactSize = (this.parent.pageSettings.columnSize *
                    colValues * this.parent.gridSettings.columnWidth);
                let section = Math.ceil(left / exactSize);
                if (this.parent.scrollPosObject.horizontal === section) {
                    this.parent.hideWaitingPopup();
                    return;
                }
                this.parent.showWaitingPopup();
                let pivot = this.parent;
                pivot.scrollPosObject.horizontal = section;
                engine.pageSettings.columnCurrentPage = section > 1 ? section : 1;
                let colStartPos = 0;
                if (pivot.dataType === 'pivot') {
                    if (isBlazor()) {
                        let ejsInterop = 'ejsInterop';
                        let pivot = this.parent;
                        /* tslint:disable-next-line */
                        let pageSettings = window[ejsInterop].
                            copyWithoutCircularReferences([engine.pageSettings], engine.pageSettings);
                        /* tslint:disable-next-line */
                        let dataSourceSettings = window[ejsInterop].
                            copyWithoutCircularReferences([pivot.dataSourceSettings], pivot.dataSourceSettings);
                        /* tslint:disable-next-line */
                        pivot.interopAdaptor.invokeMethodAsync('PivotInteropMethod', 'generateGridData', {
                            'dataSourceSettings': dataSourceSettings,
                            'pageSettings': pageSettings, 'isScrolling': true
                        }).then(
                        /* tslint:disable-next-line */
                        (data) => {
                            pivot.updateBlazorData(data, pivot);
                            colStartPos = pivot.engineModule.colStartPos;
                            pivot.pivotValues = engine.pivotValues;
                            let exactPage = Math.ceil(colStartPos / (pivot.pageSettings.columnSize * colValues));
                            let pos = exactSize * exactPage - (engine.colFirstLvl *
                                colValues * pivot.gridSettings.columnWidth);
                            pivot.scrollPosObject.horizontalSection = pos;
                        });
                    }
                    else {
                        pivot.engineModule.generateGridData(pivot.dataSourceSettings, pivot.engineModule.headerCollection);
                        colStartPos = pivot.engineModule.colStartPos;
                    }
                }
                else {
                    pivot.olapEngineModule.scrollPage('scroll');
                    colStartPos = pivot.olapEngineModule.pageColStartPos;
                }
                if (!(isBlazor() && pivot.dataType === 'pivot')) {
                    pivot.pivotValues = engine.pivotValues;
                    let exactPage = Math.ceil(colStartPos / (pivot.pageSettings.columnSize * colValues));
                    let pos = exactSize * exactPage - (engine.colFirstLvl *
                        colValues * pivot.gridSettings.columnWidth);
                    pivot.scrollPosObject.horizontalSection = pos;
                }
            }
        }
    }
    setPageXY() {
        return (e) => {
            if (e.pointerType === 'mouse') {
                return;
            }
            this.pageXY = this.getPointXY(e);
        };
    }
    common(mHdr, mCont, fCont) {
        return (e) => {
            this.update(mHdr, mCont, mCont.scrollTop * this.parent.verticalScrollScale, mCont.scrollLeft * this.parent.horizontalScrollScale, e);
        };
    }
    onHorizondalScroll(mHdr, mCont, fCont) {
        /* tslint:disable-next-line */
        let timeOutObj;
        return (e) => {
            let left = mCont.scrollLeft * this.parent.horizontalScrollScale;
            if (e.type === 'wheel' || e.type === 'touchmove' || this.eventType === 'wheel' || this.eventType === 'touchmove') {
                clearTimeout(timeOutObj);
                /* tslint:disable */
                timeOutObj = setTimeout(() => {
                    left = e.type === 'touchmove' ? mCont.scrollLeft : left;
                    this.update(mHdr, mCont, mCont.scrollTop * this.parent.verticalScrollScale, left, e);
                }, 300);
            }
            if (this.previousValues.left === left) {
                fCont.scrollTop = mCont.scrollTop;
                return;
            }
            this.direction = 'horizondal';
            let horiOffset = -((left - this.parent.scrollPosObject.horizontalSection - mCont.scrollLeft));
            let vertiOffset = mCont.querySelector('.' + TABLE).style.transform.split(',')[1].trim();
            if (mCont.scrollLeft < this.parent.scrollerBrowserLimit) {
                setStyleAttribute(mCont.querySelector('.e-table'), {
                    transform: 'translate(' + horiOffset + 'px,' + vertiOffset
                });
                setStyleAttribute(mHdr.querySelector('.e-table'), {
                    transform: 'translate(' + horiOffset + 'px,' + 0 + 'px)'
                });
            }
            let excessMove = this.parent.scrollPosObject.horizontalSection > left ?
                -(this.parent.scrollPosObject.horizontalSection - left) : ((left + mHdr.offsetWidth) -
                (this.parent.scrollPosObject.horizontalSection + mCont.querySelector('.e-table').offsetWidth));
            let notLastPage = Math.ceil(this.parent.scrollPosObject.horizontalSection / this.parent.horizontalScrollScale) <
                this.parent.scrollerBrowserLimit;
            if (this.parent.scrollPosObject.horizontalSection > left ? true : (excessMove > 1 && notLastPage)) {
                //  showSpinner(this.parent.element);
                if (left > mHdr.clientWidth) {
                    if (this.parent.scrollPosObject.left < 1) {
                        this.parent.scrollPosObject.left = mHdr.clientWidth;
                    }
                    this.parent.scrollPosObject.left = this.parent.scrollPosObject.left - 50;
                    excessMove = this.parent.scrollPosObject.horizontalSection > left ?
                        (excessMove - this.parent.scrollPosObject.left) : (excessMove + this.parent.scrollPosObject.left);
                }
                else {
                    excessMove = -this.parent.scrollPosObject.horizontalSection;
                }
                horiOffset = -((left - (this.parent.scrollPosObject.horizontalSection + excessMove) - mCont.scrollLeft));
                let vWidth = (this.parent.gridSettings.columnWidth * this.engineModule.columnCount
                    - this.parent.grid.columns[0].width);
                if (vWidth > this.parent.scrollerBrowserLimit) {
                    this.parent.horizontalScrollScale = vWidth / this.parent.scrollerBrowserLimit;
                    vWidth = this.parent.scrollerBrowserLimit;
                }
                if (horiOffset > vWidth && horiOffset > left) {
                    horiOffset = left;
                    excessMove = 0;
                }
                setStyleAttribute(mCont.querySelector('.e-table'), {
                    transform: 'translate(' + horiOffset + 'px,' + vertiOffset
                });
                setStyleAttribute(mHdr.querySelector('.e-table'), {
                    transform: 'translate(' + horiOffset + 'px,' + 0 + 'px)'
                });
                this.parent.scrollPosObject.horizontalSection = this.parent.scrollPosObject.horizontalSection + excessMove;
            }
            this.previousValues.left = left;
            this.frozenPreviousValues.left = left;
            this.eventType = '';
            mHdr.scrollLeft = mCont.scrollLeft;
        };
    }
    onVerticalScroll(fCont, mCont) {
        /* tslint:disable-next-line */
        let timeOutObj;
        return (e) => {
            let top = mCont.scrollTop * this.parent.verticalScrollScale;
            if (e.type === 'wheel' || e.type === 'touchmove' || this.eventType === 'wheel' || this.eventType === 'touchmove') {
                clearTimeout(timeOutObj);
                /* tslint:disable */
                timeOutObj = setTimeout(() => {
                    this.update(null, mCont, mCont.scrollTop * this.parent.verticalScrollScale, mCont.scrollLeft * this.parent.horizontalScrollScale, e);
                }, 300);
            }
            if (this.previousValues.top === top) {
                return;
            }
            this.direction = 'vertical';
            let vertiOffset = -((top - this.parent.scrollPosObject.verticalSection - mCont.scrollTop));
            let horiOffset = mCont.querySelector('.' + TABLE).style.transform.split(',')[0].trim();
            if (mCont.scrollTop < this.parent.scrollerBrowserLimit) {
                setStyleAttribute(fCont.querySelector('.e-table'), {
                    transform: 'translate(' + 0 + 'px,' + vertiOffset + 'px)'
                });
                setStyleAttribute(mCont.querySelector('.e-table'), {
                    transform: horiOffset + ',' + vertiOffset + 'px)'
                });
            }
            let excessMove = this.parent.scrollPosObject.verticalSection > top ?
                -(this.parent.scrollPosObject.verticalSection - top) : ((top + fCont.clientHeight) -
                (this.parent.scrollPosObject.verticalSection + fCont.querySelector('.e-table').offsetHeight));
            let notLastPage = Math.ceil(this.parent.scrollPosObject.verticalSection / this.parent.verticalScrollScale) <
                this.parent.scrollerBrowserLimit;
            if (this.parent.scrollPosObject.verticalSection > top ? true : (excessMove > 1 && notLastPage)) {
                //  showSpinner(this.parent.element);
                if (top > fCont.clientHeight) {
                    if (this.parent.scrollPosObject.top < 1) {
                        this.parent.scrollPosObject.top = fCont.clientHeight;
                    }
                    this.parent.scrollPosObject.top = this.parent.scrollPosObject.top - 50;
                    excessMove = this.parent.scrollPosObject.verticalSection > top ?
                        (excessMove - this.parent.scrollPosObject.top) : (excessMove + this.parent.scrollPosObject.top);
                }
                else {
                    excessMove = -this.parent.scrollPosObject.verticalSection;
                }
                let movableTable = this.parent.element.querySelector('.' + MOVABLECONTENT_DIV).querySelector('.e-table');
                vertiOffset = -((top - (this.parent.scrollPosObject.verticalSection + excessMove) - mCont.scrollTop));
                let vHeight = (this.parent.gridSettings.rowHeight * this.engineModule.rowCount + 0.1
                    - movableTable.clientHeight);
                if (vHeight > this.parent.scrollerBrowserLimit) {
                    this.parent.verticalScrollScale = vHeight / this.parent.scrollerBrowserLimit;
                    vHeight = this.parent.scrollerBrowserLimit;
                }
                if (vertiOffset > vHeight && vertiOffset > top) {
                    vertiOffset = top;
                    excessMove = 0;
                }
                setStyleAttribute(fCont.querySelector('.e-table'), {
                    transform: 'translate(' + 0 + 'px,' + vertiOffset + 'px)'
                });
                setStyleAttribute(mCont.querySelector('.e-table'), {
                    transform: horiOffset + ',' + vertiOffset + 'px)'
                });
                this.parent.scrollPosObject.verticalSection = this.parent.scrollPosObject.verticalSection + excessMove;
            }
            this.previousValues.top = top;
            this.frozenPreviousValues.top = top;
            this.eventType = '';
            fCont.scrollTop = mCont.scrollTop;
            mCont.scrollTop = fCont.scrollTop;
        };
    }
    /**
     * @hidden
     */
    removeInternalEvents() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(contentReady, this.wireEvents);
    }
    /**
     * To destroy the virtualscrolling event listener
     * @return {void}
     * @hidden
     */
    destroy() {
        this.removeInternalEvents();
    }
}

/**
 * `DrillThroughDialog` module to create drill-through dialog.
 */
/** @hidden */
class DrillThroughDialog {
    /**
     * Constructor for the dialog action.
     * @hidden
     */
    constructor(parent) {
        /** @hidden */
        this.indexString = [];
        this.isUpdated = false;
        this.gridIndexObjects = {};
        this.gridData = [];
        this.parent = parent;
        this.engine = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
    }
    /** @hidden */
    showDrillThroughDialog(eventArgs) {
        this.gridData = eventArgs.rawData;
        this.removeDrillThroughDialog();
        let drillThroughDialog = createElement('div', {
            id: this.parent.element.id + '_drillthrough',
            className: DRILLTHROUGH_DIALOG,
            styles: 'visibility:hidden;'
        });
        this.parent.element.appendChild(drillThroughDialog);
        this.dialogPopUp = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: false,
            header: this.parent.localeObj.getConstant('details'),
            content: this.createDrillThroughGrid(eventArgs),
            beforeOpen: () => {
                /* tslint:disable:align */
                this.drillThroughGrid.setProperties({
                    dataSource: this.parent.editSettings.allowEditing ?
                        this.dataWithPrimarykey(eventArgs) : this.gridData,
                    height: !this.parent.editSettings.allowEditing ? 300 : 220
                }, true);
                /* tslint:enable:align */
                this.drillThroughGrid.enableVirtualization = !this.parent.editSettings.allowEditing;
            },
            beforeClose: () => {
                if (this.parent.editSettings.allowEditing && this.isUpdated) {
                    let count = Object.keys(this.gridIndexObjects).length;
                    let addItems = [];
                    /* tslint:disable:no-string-literal */
                    for (let item of this.drillThroughGrid.dataSource) {
                        if (isNullOrUndefined(item['__index']) || item['__index'] === '') {
                            for (let field of this.engine.fields) {
                                if (isNullOrUndefined(item[field])) {
                                    delete item[field];
                                }
                            }
                            delete item['__index'];
                            addItems.push(item);
                        }
                        else if (count > 0) {
                            delete this.gridIndexObjects[item['__index'].toString()];
                            count--;
                        }
                    }
                    count = 0;
                    if (isBlazor() && this.parent.enableVirtualization) {
                        let currModule = this;
                        /* tslint:disable:no-any */
                        currModule.parent.interopAdaptor.invokeMethodAsync('PivotInteropMethod', 'updateRawData', {
                            'AddItem': addItems, 'RemoveItem': currModule.gridIndexObjects, 'ModifiedItem': currModule.gridData
                        }).then((data) => {
                            currModule.parent.updateBlazorData(data, currModule.parent);
                            currModule.parent.setProperties({ pivotValues: currModule.parent.engineModule.pivotValues }, true);
                            currModule.isUpdated = false;
                            currModule.gridIndexObjects = {};
                        });
                    }
                    else {
                        let items = [];
                        let data = (this.parent.allowDataCompression && this.parent.enableVirtualization) ?
                            this.parent.engineModule.actualData : this.parent.engineModule.data;
                        for (let item of data) {
                            delete item['__index'];
                            if (this.gridIndexObjects[count.toString()] === undefined) {
                                items.push(item);
                            }
                            count++;
                        }
                        /* tslint:enable:no-string-literal */
                        items = items.concat(addItems);
                        this.parent.setProperties({ dataSourceSettings: { dataSource: items } }, true);
                        this.engine.updateGridData(this.parent.dataSourceSettings);
                        this.parent.pivotValues = this.engine.pivotValues;
                    }
                }
                if (!(isBlazor() && this.parent.enableVirtualization)) {
                    this.isUpdated = false;
                    this.gridIndexObjects = {};
                }
            },
            isModal: true,
            visible: true,
            showCloseIcon: true,
            locale: this.parent.locale,
            enableRtl: this.parent.enableRtl,
            width: this.parent.isAdaptive ? '100%' : '60%',
            position: { X: 'center', Y: 'center' },
            closeOnEscape: true,
            target: document.body,
            close: this.removeDrillThroughDialog.bind(this)
        });
        this.dialogPopUp.isStringTemplate = true;
        this.dialogPopUp.appendTo(drillThroughDialog);
        // this.dialogPopUp.element.querySelector('.e-dlg-header').innerHTML = this.parent.localeObj.getConstant('details');
        setStyleAttribute(this.dialogPopUp.element, { 'visibility': 'visible' });
    }
    removeDrillThroughDialog() {
        if (this.dialogPopUp && !this.dialogPopUp.isDestroyed) {
            this.dialogPopUp.destroy();
        }
        let dialogElement = document.getElementById(this.parent.element.id + '_drillthrough');
        if (dialogElement) {
            remove(dialogElement);
        }
        if (document.getElementById(this.parent.element.id + '_drillthroughgrid_ccdlg')) {
            remove(document.getElementById(this.parent.element.id + '_drillthroughgrid_ccdlg'));
        }
    }
    /* tslint:disable:max-func-body-length */
    createDrillThroughGrid(eventArgs) {
        let drillThroughBody = createElement('div', { id: this.parent.element.id + '_drillthroughbody', className: DRILLTHROUGH_BODY_CLASS });
        let drillThroughBodyHeader = createElement('div', {
            id: this.parent.element.id +
                '_drillthroughbodyheader', className: DRILLTHROUGH_BODY_HEADER_CONTAINER_CLASS
        });
        if (eventArgs.rowHeaders !== '') {
            drillThroughBodyHeader.innerHTML = '<span class=' +
                DRILLTHROUGH_BODY_HEADER_COMMON_CLASS + '><span class=' + DRILLTHROUGH_BODY_HEADER_CLASS + '>' +
                this.parent.localeObj.getConstant('row') + '</span> :<span class=' +
                DRILLTHROUGH_BODY_HEADER_VALUE_CLASS + '>' + eventArgs.rowHeaders + '</span></span>';
        }
        if (eventArgs.columnHeaders !== '') {
            drillThroughBodyHeader.innerHTML = drillThroughBodyHeader.innerHTML + '<span class=' +
                DRILLTHROUGH_BODY_HEADER_COMMON_CLASS + '><span class=' +
                DRILLTHROUGH_BODY_HEADER_CLASS + '>' + this.parent.localeObj.getConstant('column') +
                '</span> :<span class=' + DRILLTHROUGH_BODY_HEADER_VALUE_CLASS + '>' +
                eventArgs.columnHeaders + '</span></span>';
        }
        if (eventArgs.value !== '') {
            let measure = eventArgs.value.split('(')[0];
            let value = eventArgs.value.split('(')[1].split(')')[0];
            if (value !== '0') {
                drillThroughBodyHeader.innerHTML = drillThroughBodyHeader.innerHTML + '<span class=' +
                    DRILLTHROUGH_BODY_HEADER_COMMON_CLASS + '><span class=' +
                    DRILLTHROUGH_BODY_HEADER_CLASS + '>' +
                    measure + '</span> :<span class=' + DRILLTHROUGH_BODY_HEADER_VALUE_CLASS + '>' + value + '</span></span>';
            }
        }
        let toolbarItems = ['ColumnChooser'];
        if (this.parent.editSettings.allowEditing) {
            if (this.parent.editSettings.allowCommandColumns) {
                toolbarItems = ['ColumnChooser', 'Add'];
            }
            else if (this.parent.editSettings.mode === 'Batch') {
                toolbarItems = ['ColumnChooser', 'Add', 'Delete', 'Update', 'Cancel'];
            }
            else if (this.parent.editSettings.mode === 'Dialog') {
                toolbarItems = ['ColumnChooser', 'Add', 'Edit', 'Delete'];
            }
            else {
                toolbarItems = ['ColumnChooser', 'Add', 'Edit', 'Delete', 'Update', 'Cancel'];
            }
        }
        let drillThroughGrid = createElement('div', { id: this.parent.element.id + '_drillthroughgrid', className: DRILLTHROUGH_GRID_CLASS });
        Grid.Inject(Selection, Reorder, Resize, Toolbar, ColumnChooser);
        this.drillThroughGrid = new Grid({
            gridLines: 'Default',
            allowResizing: true,
            allowReordering: true,
            showColumnChooser: true,
            toolbar: toolbarItems,
            columns: eventArgs.gridColumns,
            locale: this.parent.locale,
            enableRtl: this.parent.enableRtl,
            enableVirtualization: this.parent.editSettings.allowEditing,
            allowPaging: this.parent.editSettings.allowEditing
        });
        if (this.parent.dataType === 'olap') {
            this.formatData();
        }
        let dialogModule = this;
        this.parent.trigger(beginDrillThrough, {
            cellInfo: eventArgs,
            gridObj: isBlazor() ? undefined : this.drillThroughGrid,
            type: 'editing'
        });
        if (this.parent.editSettings.allowEditing) {
            Grid.Inject(Edit, Page);
            this.drillThroughGrid.editSettings = this.parent.editSettings;
            if (this.parent.editSettings.allowCommandColumns) {
                this.drillThroughGrid.editSettings.mode = 'Normal';
                this.drillThroughGrid.editSettings.allowEditOnDblClick = false;
                Grid.Inject(CommandColumn);
                this.drillThroughGrid.columns.push({
                    headerText: this.parent.localeObj.getConstant('manageRecords'), width: 160, showInColumnChooser: false,
                    commands: [
                        { type: 'Edit', buttonOption: { iconCss: ' e-icons e-edit', cssClass: 'e-flat' } },
                        { type: 'Delete', buttonOption: { iconCss: 'e-icons e-delete', cssClass: 'e-flat' } },
                        { type: 'Save', buttonOption: { iconCss: 'e-icons e-update', cssClass: 'e-flat' } },
                        { type: 'Cancel', buttonOption: { iconCss: 'e-icons e-cancel-icon', cssClass: 'e-flat' } }
                    ]
                });
            }
            else {
                this.drillThroughGrid.editSettings.allowEditOnDblClick = this.parent.editSettings.allowEditOnDblClick;
            }
            /* tslint:disable:align */
            this.drillThroughGrid.columns.push({
                field: '__index', visible: false, isPrimaryKey: true, type: 'string', showInColumnChooser: false
            });
            /* tslint:disable-next-line:no-any */
            this.drillThroughGrid.actionComplete = (args) => {
                if (args.requestType === 'batchsave' || args.requestType === 'save' || args.requestType === 'delete') {
                    dialogModule.isUpdated = true;
                }
                if ((dialogModule.drillThroughGrid.editSettings.mode === 'Normal' && args.requestType === 'save' &&
                    dialogModule.drillThroughGrid.element.querySelectorAll('.e-tbar-btn:hover').length > 0 &&
                    !dialogModule.parent.editSettings.allowCommandColumns) || args.requestType === 'batchsave') {
                    dialogModule.dialogPopUp.hide();
                }
            };
            this.drillThroughGrid.beforeBatchSave = () => {
                dialogModule.isUpdated = true;
            };
            /* tslint:enable:align */
        }
        else {
            Grid.Inject(VirtualScroll);
        }
        document.body.appendChild(drillThroughGrid);
        this.drillThroughGrid.isStringTemplate = true;
        this.drillThroughGrid.appendTo(drillThroughGrid);
        drillThroughBody.appendChild(drillThroughBodyHeader);
        drillThroughBody.appendChild(drillThroughGrid);
        return drillThroughBody;
    }
    /** @hidden */
    frameGridColumns() {
        let keys = this.parent.dataType === 'olap' ? this.gridData[0] ? Object.keys(this.gridData[0]) : [] :
            Object.keys(this.engine.fieldList);
        let columns = [];
        if (this.parent.dataType === 'olap') {
            for (let key of keys) {
                columns.push({
                    field: key.replace(/_x005B_|_x0020_|_x005D_|_x0024_/g, '').replace('].[', '').split('.').reverse().join(''),
                    headerText: key.replace(/_x005B_|_x005D_|_x0024_/g, '').replace(/_x0020_/g, ' ').
                        replace('].[', '').split('.').reverse().join('.'),
                    width: 120,
                    visible: true,
                    validationRules: { required: true },
                    type: 'string'
                });
            }
        }
        else {
            for (let key of keys) {
                if (this.engine.fieldList[key].aggregateType !== 'CalculatedField') {
                    let editType = '';
                    if (this.engine.fieldList[key].type === 'number') {
                        editType = 'numericedit';
                    }
                    else if (this.engine.fieldList[key].type === 'date') {
                        editType = 'datepickeredit';
                    }
                    else {
                        editType = 'defaultedit';
                    }
                    columns.push({
                        field: key,
                        headerText: this.engine.fieldList[key].caption,
                        width: 120,
                        visible: this.engine.fieldList[key].isSelected,
                        validationRules: { required: true },
                        editType: editType,
                        type: 'string'
                    });
                }
            }
        }
        return columns;
    }
    formatData() {
        let index = 0;
        while (index < this.gridData.length) {
            let data = this.gridData[index];
            let keys = Object.keys(this.gridData[index]);
            let newData = {};
            let i = 0;
            while (i < keys.length) {
                let key = keys[i].replace(/_x005B_|_x0020_|_x005D_|_x0024_/g, '').replace('].[', '').split('.').reverse().join('');
                newData[key] = data[keys[i]];
                i++;
            }
            this.gridData[index] = newData;
            index++;
        }
    }
    dataWithPrimarykey(eventArgs) {
        let indexString = this.indexString.length > 0 ? this.indexString : Object.keys(eventArgs.currentCell.indexObject);
        let rawData = this.gridData;
        let count = 0;
        for (let item of rawData) {
            /* tslint:disable-next-line:no-string-literal */
            item['__index'] = indexString[count];
            this.gridIndexObjects[indexString[count].toString()] = Number(indexString[count]);
            count++;
        }
        return rawData;
    }
}

/**
 * `DrillThrough` module.
 */
class DrillThrough {
    /**
     * Constructor.
     * @hidden
     */
    constructor(parent) {
        this.parent = parent;
        this.drillThroughDialog = new DrillThroughDialog(this.parent);
        this.addInternalEvents();
    }
    /**
     * It returns the Module name.
     * @returns string
     * @hidden
     */
    getModuleName() {
        return 'drillthrough';
    }
    addInternalEvents() {
        this.parent.on(contentReady, this.wireEvents, this);
    }
    wireEvents() {
        this.unWireEvents();
        EventHandler.add(this.parent.element, 'dblclick', this.mouseClickHandler, this);
    }
    unWireEvents() {
        EventHandler.remove(this.parent.element, 'dblclick', this.mouseClickHandler);
    }
    mouseClickHandler(e) {
        let target = e.target;
        let ele = null;
        if (target.classList.contains('e-stackedheadercelldiv') || target.classList.contains('e-cellvalue') ||
            target.classList.contains('e-headercelldiv')) {
            ele = target.parentElement;
        }
        else if (target.classList.contains('e-headercell') || target.classList.contains('e-rowcell')) {
            ele = target;
        }
        else if (target.classList.contains('e-headertext')) {
            ele = target.parentElement.parentElement;
        }
        if (ele) {
            if (this.parent.allowDrillThrough && ele.classList.contains('e-valuescontent') || this.parent.editSettings.allowEditing) {
                this.executeDrillThrough(ele);
            }
        }
    }
    executeDrillThrough(ele) {
        let colIndex = Number(ele.getAttribute('aria-colindex'));
        let rowIndex = Number(ele.getAttribute('index'));
        let pivotValue = this.parent.pivotValues[rowIndex][colIndex];
        let engine = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
        let valueCaption = '';
        let aggType = '';
        let rawData = [];
        if (pivotValue.rowHeaders !== undefined && pivotValue.columnHeaders !== undefined && !isNullOrUndefined(pivotValue.value)) {
            if (this.parent.dataType === 'olap') {
                let tupleInfo;
                if (this.parent.dataSourceSettings.valueAxis === 'row') {
                    tupleInfo = engine.tupRowInfo[pivotValue.rowOrdinal];
                }
                else {
                    tupleInfo = engine.tupColumnInfo[pivotValue.colOrdinal];
                }
                let measureName = tupleInfo ?
                    engine.getUniqueName(tupleInfo.measureName) : pivotValue.actualText;
                if (engine.fieldList[measureName] && engine.fieldList[measureName].isCalculatedField) {
                    this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('error'), this.parent.localeObj.getConstant('drillError'));
                    return;
                }
                valueCaption = engine.fieldList[measureName].caption;
                aggType = engine.fieldList[measureName].aggregateType;
                this.parent.olapEngineModule.getDrillThroughData(pivotValue, this.parent.maxRowsInDrillThrough);
                try {
                    rawData = JSON.parse(engine.gridJSON);
                }
                catch (exception) {
                    this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('error'), engine.gridJSON);
                    return;
                }
            }
            else {
                valueCaption = engine.fieldList[pivotValue.actualText.toString()] ?
                    engine.fieldList[pivotValue.actualText.toString()].caption : pivotValue.actualText.toString();
                aggType = engine.fieldList[pivotValue.actualText] ? engine.fieldList[pivotValue.actualText].aggregateType : '';
                let currModule = this;
                if (isBlazor() && this.parent.enableVirtualization) {
                    /* tslint:disable:no-any */
                    currModule.parent.interopAdaptor.invokeMethodAsync('PivotInteropMethod', 'fetchRawData', { 'RowIndex': rowIndex, 'ColumnIndex': colIndex }).then((data) => {
                        rawData = JSON.parse(data.rawData);
                        let parsedObj = JSON.parse(data.indexObject);
                        let indexObject = {};
                        for (let len = 0; len < parsedObj.length; len++) {
                            indexObject[parsedObj[len].Key] = parsedObj[len].Value;
                        }
                        pivotValue.indexObject = indexObject;
                        currModule.triggerDialog(valueCaption, aggType, rawData, pivotValue, ele);
                    });
                }
                else {
                    if (this.parent.enableVirtualization && this.parent.allowDataCompression) {
                        let indexArray = Object.keys(pivotValue.indexObject);
                        this.drillThroughDialog.indexString = [];
                        for (let cIndex of indexArray) {
                            for (let aIndex of this.parent.engineModule.groupRawIndex[Number(cIndex)]) {
                                rawData.push(this.parent.engineModule.actualData[aIndex]);
                                this.drillThroughDialog.indexString.push(aIndex.toString());
                            }
                        }
                    }
                    else {
                        let indexArray = Object.keys(pivotValue.indexObject);
                        for (let index of indexArray) {
                            rawData.push(this.parent.engineModule.data[Number(index)]);
                        }
                    }
                }
            }
            if (!(isBlazor() && this.parent.enableVirtualization)) {
                this.triggerDialog(valueCaption, aggType, rawData, pivotValue, ele);
            }
        }
    }
    triggerDialog(valueCaption, aggType, rawData, pivotValue, ele) {
        let valuetText = aggType === 'CalculatedField' ? valueCaption.toString() : aggType !== '' ?
            (this.parent.localeObj.getConstant(aggType) + ' ' + this.parent.localeObj.getConstant('of') + ' ' + valueCaption) :
            valueCaption;
        let eventArgs = {
            currentTarget: ele,
            currentCell: pivotValue,
            rawData: rawData,
            rowHeaders: pivotValue.rowHeaders === '' ? '' : pivotValue.rowHeaders.toString().split('.').join(' - '),
            columnHeaders: pivotValue.columnHeaders === '' ? '' : pivotValue.columnHeaders.toString().split('.').join(' - '),
            value: valuetText + '(' + pivotValue.formattedText + ')',
            gridColumns: this.drillThroughDialog.frameGridColumns()
        };
        let drillThrough$$1 = this;
        let gridColumns = eventArgs.gridColumns;
        this.parent.trigger(drillThrough, eventArgs, (observedArgs) => {
            if (isBlazor()) {
                for (let i = 0; i < observedArgs.gridColumns.length; i++) {
                    if (gridColumns[i].field === observedArgs.gridColumns[i].field) {
                        gridColumns[i].field = observedArgs.gridColumns[i].field;
                        gridColumns[i].editType = observedArgs.gridColumns[i].editType;
                        gridColumns[i].headerText = observedArgs.gridColumns[i].headerText;
                        gridColumns[i].type = observedArgs.gridColumns[i].type;
                        gridColumns[i].validationRules = observedArgs.gridColumns[i].validationRules;
                        gridColumns[i].visible = observedArgs.gridColumns[i].visible;
                        gridColumns[i].width = observedArgs.gridColumns[i].width;
                    }
                }
                observedArgs.gridColumns = gridColumns;
            }
            drillThrough$$1.drillThroughDialog.showDrillThroughDialog(observedArgs);
        });
    }
}

class PivotChart {
    constructor() {
        this.headerColl = {};
        this.maxLevel = 0;
        this.columnGroupObject = {};
        this.fieldPosition = [];
        this.measurePos = -1;
        this.measuresNames = {};
    }
    /**
     * Get component name.
     * @returns string
     * @private
     */
    getModuleName() {
        return 'pivotchart';
    }
    /* tslint:disable */
    loadChart(parent, chartSettings) {
        this.parent = parent;
        this.measuresNames = {};
        this.engineModule = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
        this.dataSourceSettings = this.parent.dataSourceSettings;
        this.chartSettings = chartSettings;
        let isDataAvail = parent.dataType === 'olap' ?
            (parent.olapEngineModule.tupColumnInfo.length > 0 && parent.olapEngineModule.tupRowInfo.length > 0 &&
                (!isNullOrUndefined(parent.olapEngineModule.colMeasurePos) || !isNullOrUndefined(parent.olapEngineModule.rowMeasurePos)))
            : parent.dataSourceSettings.values.length > 0;
        if (isDataAvail) {
            if (this.chartSettings.enableMultiAxis) {
                this.measureList = this.dataSourceSettings.values.map(function (item) { return item.name; });
            }
            else {
                this.measureList = [chartSettings.value === '' ? this.dataSourceSettings.values[0].name : chartSettings.value];
            }
            for (let field of this.dataSourceSettings.values) {
                let fieldName = field.name.replace(/[^A-Z0-9]+/ig, '_');
                this.measuresNames[field.name] = fieldName;
                this.measuresNames[fieldName] = field.name;
            }
        }
        else if (this.parent.chart) {
            this.parent.chart.series = [];
            this.parent.chart.rows = [];
            this.parent.chart.primaryXAxis.title = '';
            this.parent.chart.primaryYAxis.title = '';
            this.parent.chart.primaryXAxis.multiLevelLabels = [];
            this.parent.chart.primaryYAxis.multiLevelLabels = [];
            if (this.parent.chart.axes.length > 0) {
                this.parent.chart.axes[0].title = '';
            }
            this.parent.chart.primaryXAxis.zoomFactor = 1;
            this.parent.chart.refresh();
            return;
        }
        else {
            this.parent.notify(contentReady, {});
            return;
        }
        this.columnGroupObject = {};
        let pivotValues = this.engineModule.pivotValues;
        this.currentMeasure = chartSettings.enableMultiAxis ? this.measureList[0] :
            (((chartSettings.value === '' || this.dataSourceSettings.values.filter((item) => {
                return item.name === chartSettings.value;
            }).length === 0) && this.dataSourceSettings.values.length > 0) ? this.dataSourceSettings.values[0].name : chartSettings.value);
        let totColIndex = this.getColumnTotalIndex(pivotValues);
        let rKeys = Object.keys(pivotValues);
        let prevLevel;
        let firstLevelUName;
        let levelCollection = {};
        let prevCell;
        let integratedLevel = 0;
        let indexCount = -0.5;
        this.headerColl = {};
        this.maxLevel = 0;
        let levelPos = {};
        let lastHierarchy = '';
        let lastDimension = '';
        let memberCell;
        if (this.parent.dataType === 'olap') {
            levelPos = this.groupHierarchyWithLevels(pivotValues);
            lastHierarchy = this.fieldPosition[this.fieldPosition.length - 1];
            lastDimension = (this.measurePos === (this.fieldPosition.length - 1) && this.fieldPosition.length > 1) ?
                this.fieldPosition[this.fieldPosition.length - 2] : lastHierarchy;
        }
        for (let rKey of rKeys) {
            let rowIndex = Number(rKey);
            if (pivotValues[rowIndex][0] && pivotValues[rowIndex][0].axis === 'row' &&
                (this.dataSourceSettings.rows.length === 0 ? true : pivotValues[rowIndex][0].type !== 'grand sum')) {
                let firstRowCell = pivotValues[rowIndex][0];
                let tupInfo = this.parent.dataType === 'olap' ?
                    this.engineModule.tupRowInfo[firstRowCell.ordinal] : undefined;
                let fieldPos = -1;
                let currrentLevel = firstRowCell.level;
                if (this.parent.dataType === 'olap') {
                    fieldPos = tupInfo.uNameCollection.split('::[').length - 1;
                    if (firstRowCell.memberType !== 3 && (tupInfo.measureName ?
                        tupInfo.measureName === this.dataSourceSettings.values[0].name : true)) {
                        firstLevelUName = firstLevelUName === undefined ? firstRowCell.levelUniqueName : firstLevelUName;
                        integratedLevel = firstLevelUName === firstRowCell.levelUniqueName ? 0 : integratedLevel;
                        levelCollection = integratedLevel === 0 ? {} : levelCollection;
                        integratedLevel = (prevCell && firstLevelUName !== firstRowCell.levelUniqueName) ?
                            (prevCell.hierarchy === firstRowCell.hierarchy ?
                                (integratedLevel + (firstRowCell.level - prevCell.level)) :
                                (isNullOrUndefined(levelCollection[firstRowCell.levelUniqueName]) ? (levelPos[firstRowCell.hierarchy].start) :
                                    levelCollection[firstRowCell.levelUniqueName])) : integratedLevel;
                        levelCollection[firstRowCell.levelUniqueName] = integratedLevel;
                        currrentLevel = integratedLevel;
                        indexCount += (prevCell && lastDimension === prevCell.hierarchy && !prevCell.isDrilled) ? 1 : 0;
                        prevLevel = integratedLevel;
                        prevCell = firstRowCell;
                    }
                }
                else if (firstRowCell.type !== 'value') {
                    if (!(prevLevel === undefined || prevLevel < currrentLevel)) {
                        indexCount++;
                    }
                    prevLevel = currrentLevel;
                }
                this.maxLevel = currrentLevel > this.maxLevel ? currrentLevel : this.maxLevel;
                let name = this.parent.dataType === 'olap' ? firstRowCell.formattedText :
                    (firstRowCell.actualText ? firstRowCell.actualText.toString() : firstRowCell.formattedText.toString());
                let text = firstRowCell.formattedText ? firstRowCell.formattedText.toString() : name;
                let caption = (firstRowCell.hasChild && !firstRowCell.isNamedSet) ?
                    ((firstRowCell.isDrilled ? ' - ' : ' + ') + text) : text;
                let levelName = tupInfo ? tupInfo.uNameCollection : firstRowCell.valueSort['levelName'].toString();
                let cellInfo = {
                    name: name,
                    text: caption,
                    hasChild: firstRowCell.hasChild,
                    isDrilled: firstRowCell.isDrilled,
                    levelName: levelName,
                    level: currrentLevel,
                    fieldName: firstRowCell.valueSort['axis'] ? firstRowCell.valueSort['axis'].toString() : '',
                    rowIndex: rowIndex,
                    colIndex: 0,
                    cell: firstRowCell
                };
                if (this.parent.dataType === 'olap' ? firstRowCell.memberType !== 3 : firstRowCell.type !== 'value') {
                    if (this.headerColl[indexCount]) {
                        this.headerColl[indexCount][currrentLevel] = cellInfo;
                    }
                    else {
                        this.headerColl[indexCount] = {};
                        this.headerColl[indexCount][currrentLevel] = cellInfo;
                    }
                }
                let rows = pivotValues[rowIndex];
                let cKeys = Object.keys(rows);
                let prevMemberCell;
                if (this.parent.dataType === 'olap') {
                    memberCell = firstRowCell.memberType !== 3 ? firstRowCell : memberCell;
                }
                else {
                    memberCell = firstRowCell.type !== 'value' ? firstRowCell : memberCell;
                }
                for (let cKey of cKeys) {
                    let cellIndex = Number(cKey);
                    let cell = pivotValues[rowIndex][cellIndex];
                    let measureAllow = cell.rowHeaders === '' ? this.dataSourceSettings.rows.length === 0 : true;
                    let actualText = (this.parent.dataType === 'olap' && tupInfo && tupInfo.measureName) ?
                        tupInfo.measureName : cell.actualText;
                    if (!totColIndex[cell.colIndex] && cell.axis === 'value' && firstRowCell.type !== 'header' &&
                        actualText !== '' && (chartSettings.enableMultiAxis ? true : actualText === this.currentMeasure)) {
                        if (this.parent.dataType === 'olap' ? (lastHierarchy === firstRowCell.hierarchy ?
                            ((firstRowCell.memberType === 3 && prevMemberCell) ?
                                (fieldPos === this.measurePos ? prevMemberCell.isDrilled : true) : firstRowCell.isDrilled) : true)
                            : (((firstRowCell.type === 'value' && prevMemberCell) ?
                                prevMemberCell.members.length > 0 : firstRowCell.members.length > 0) || !measureAllow)) {
                            break;
                        }
                        let colHeaders = this.parent.dataType === 'olap' ? cell.columnHeaders.toString().split(/~~|::/).join(' - ')
                            : cell.columnHeaders.toString().split('.').join(' - ');
                        let rowHeaders = this.parent.dataType === 'olap' ? cell.rowHeaders.toString().split(/~~|::/).join(' - ')
                            : cell.rowHeaders.toString().split('.').join(' - ');
                        let columnSeries = colHeaders + ' | ' + actualText;
                        let yValue = (this.parent.dataType === 'pivot' ? (this.engineModule.aggregatedValueMatrix[rowIndex] &&
                            !isNullOrUndefined(this.engineModule.aggregatedValueMatrix[rowIndex][cellIndex])) ?
                            Number(this.engineModule.aggregatedValueMatrix[rowIndex][cellIndex]) : Number(cell.value) : Number(cell.value));
                        if (this.columnGroupObject[columnSeries]) {
                            this.columnGroupObject[columnSeries].push({
                                x: this.dataSourceSettings.rows.length === 0 ? firstRowCell.formattedText : rowHeaders,
                                y: yValue
                            });
                        }
                        else {
                            this.columnGroupObject[columnSeries] = [{
                                    x: this.dataSourceSettings.rows.length === 0 ? firstRowCell.formattedText : rowHeaders,
                                    y: yValue
                                }];
                        }
                    }
                    prevMemberCell = memberCell;
                }
            }
        }
        this.refreshChart();
    }
    /**
     * Refreshing chart based on the updated chartSettings.
     * @returns void
     */
    refreshChart() {
        this.chartSeries = [];
        let columnKeys = Object.keys(this.columnGroupObject);
        this.persistSettings = JSON.parse(this.parent.getPersistData()).chartSettings;
        for (let key of columnKeys) {
            let currentSeries = {};
            currentSeries = this.persistSettings.chartSeries ? this.frameObjectWithKeys(this.persistSettings.chartSeries) : currentSeries;
            currentSeries.dataSource = this.columnGroupObject[key];
            currentSeries.xName = 'x';
            currentSeries.yName = 'y';
            currentSeries.name = this.chartSettings.enableMultiAxis ? key : key.split(' | ')[0];
            if (!(this.chartSettings.chartSeries.type === 'Polar' || this.chartSettings.chartSeries.type === 'Radar')) {
                let measure = key.split(' | ')[1];
                currentSeries.yAxisName = this.measuresNames[measure] ? this.measuresNames[measure] : measure;
            }
            this.chartSeries = this.chartSeries.concat(currentSeries);
        }
        let seriesEvent = { series: this.chartSeries, cancel: false };
        let pivotChart = this;
        this.parent.trigger(chartSeriesCreated, seriesEvent, (observedArgs) => {
            if (!observedArgs.cancel) {
                pivotChart.bindChart();
            }
            else {
                if (pivotChart.element) {
                    remove(pivotChart.element);
                }
                pivotChart.parent.notify(contentReady, {});
            }
        });
    }
    frameObjectWithKeys(series) {
        let keys = Object.keys(series);
        let keyPos = 0;
        let framedSeries = {};
        while (keyPos < keys.length) {
            framedSeries[keys[keyPos]] = series[keys[keyPos]];
            keyPos++;
        }
        return framedSeries;
    }
    bindChart() {
        let currentXAxis = this.configXAxis();
        let currentTooltipSettings = this.configTooltipSettings();
        let currentLegendSettings = this.configLegendSettings();
        let currentZoomSettings = this.configZoomSettings();
        let axesWithRows = this.frameAxesWithRows();
        let type = this.chartSettings.chartSeries.type;
        if (this.parent.displayOption.view === 'Both') {
            this.element = this.parent.displayOption.primary === 'Chart' ? (this.parent.element.insertBefore((!this.element ? (createElement('div', {
                className: PIVOTCHART, id: this.parent.element.id + '_chart'
            })) : this.element), this.parent.element.querySelector('.' + GRID_CLASS))) :
                (this.parent.element.appendChild(!this.element ? (createElement('div', {
                    className: PIVOTCHART, id: this.parent.element.id + '_chart'
                })) : this.element));
        }
        else if (!this.element) {
            this.element = this.parent.element.appendChild(createElement('div', {
                className: PIVOTCHART, id: this.parent.element.id + '_chart'
            }));
        }
        if (!(this.parent.chart && this.parent.chart.element && this.parent.element.querySelector('.e-chart'))) {
            if (this.parent.showGroupingBar) {
                this.element.style.minWidth = '400px !important';
            }
            else {
                this.element.style.minWidth = '310px !important';
            }
            let width = this.parent.width.toString();
            if (this.parent.showToolbar && this.parent.grid) {
                width = this.parent.getGridWidthAsNumber().toString();
            }
            let height = this.parent.getHeightAsNumber();
            if (isNullOrUndefined(height)) {
                height = "auto";
            }
            Chart.Inject(ColumnSeries, StackingColumnSeries, RangeColumnSeries, BarSeries, StackingBarSeries, ScatterSeries, BubbleSeries, LineSeries, StepLineSeries, SplineSeries, SplineAreaSeries, MultiColoredLineSeries, PolarSeries, RadarSeries, AreaSeries, RangeAreaSeries, StackingAreaSeries, StepAreaSeries, MultiColoredAreaSeries, ParetoSeries, Legend, Tooltip$1, Category, MultiLevelLabel, ScrollBar, Zoom, Export, Crosshair);
            this.parent.chart = new Chart({
                series: this.chartSeries.length > 0 ? this.chartSeries : [{}],
                legendSettings: currentLegendSettings,
                tooltip: currentTooltipSettings,
                zoomSettings: currentZoomSettings,
                axes: (type === 'Polar' || type === 'Radar') ? [] : axesWithRows.axes,
                rows: (type === 'Polar' || type === 'Radar') ? [{}] :
                    (type === 'Bar' || type === 'StackingBar' || type === 'StackingBar100' &&
                        this.chartSettings.enableMultiAxis) ? [{ height: '100%' }] : axesWithRows.rows,
                columns: (type === 'Polar' || type === 'Radar') ? [{}] :
                    (type === 'Bar' || type === 'StackingBar' || type === 'StackingBar100' &&
                        this.chartSettings.enableMultiAxis) ? axesWithRows.columns : [{ width: '100%' }],
                primaryYAxis: (type === 'Polar' || type === 'Radar') ? axesWithRows.axes[0] : { visible: false },
                primaryXAxis: currentXAxis,
                width: width,
                height: height.toString(),
                title: this.chartSettings.title,
                titleStyle: this.chartSettings.titleStyle,
                subTitle: this.chartSettings.subTitle,
                subTitleStyle: this.chartSettings.subTitleStyle,
                margin: this.chartSettings.margin,
                border: this.chartSettings.border,
                background: this.chartSettings.background,
                chartArea: this.chartSettings.chartArea,
                palettes: this.chartSettings.palettes,
                theme: this.chartSettings.theme,
                crosshair: this.chartSettings.crosshair,
                selectionMode: this.chartSettings.selectionMode,
                isMultiSelect: this.chartSettings.isMultiSelect,
                enableExport: this.chartSettings.enableExport,
                selectedDataIndexes: this.chartSettings.selectedDataIndexes,
                isTransposed: this.chartSettings.isTransposed,
                enableAnimation: this.chartSettings.enableAnimation,
                useGroupingSeparator: this.chartSettings.useGroupingSeparator,
                description: this.chartSettings.description,
                tabIndex: this.chartSettings.tabIndex,
                locale: this.parent.locale,
                enableSideBySidePlacement: this.chartSettings.enableSideBySidePlacement,
                beforePrint: this.chartSettings.beforePrint ? this.chartSettings.beforePrint.bind(this) : undefined,
                animationComplete: this.chartSettings.animationComplete ? this.chartSettings.animationComplete.bind(this) : undefined,
                legendRender: this.chartSettings.legendRender ? this.chartSettings.legendRender.bind(this) : undefined,
                textRender: this.chartSettings.textRender ? this.chartSettings.textRender.bind(this) : undefined,
                pointRender: this.chartSettings.pointRender ? this.chartSettings.pointRender.bind(this) : undefined,
                seriesRender: this.chartSettings.seriesRender ? this.chartSettings.seriesRender.bind(this) : undefined,
                chartMouseMove: this.chartSettings.chartMouseMove ? this.chartSettings.chartMouseMove.bind(this) : undefined,
                chartMouseClick: this.chartSettings.chartMouseClick ? this.chartSettings.chartMouseClick.bind(this) : undefined,
                pointMove: this.chartSettings.pointMove ? this.chartSettings.pointMove.bind(this) : undefined,
                pointClick: this.chartSettings.pointClick ? this.chartSettings.pointClick.bind(this) : undefined,
                chartMouseLeave: this.chartSettings.chartMouseLeave ? this.chartSettings.chartMouseLeave.bind(this) : undefined,
                chartMouseDown: this.chartSettings.chartMouseDown ? this.chartSettings.chartMouseDown.bind(this) : undefined,
                chartMouseUp: this.chartSettings.chartMouseUp ? this.chartSettings.chartMouseUp.bind(this) : undefined,
                dragComplete: this.chartSettings.dragComplete ? this.chartSettings.dragComplete.bind(this) : undefined,
                zoomComplete: this.chartSettings.zoomComplete ? this.chartSettings.zoomComplete.bind(this) : undefined,
                scrollStart: this.chartSettings.scrollStart ? this.chartSettings.scrollStart.bind(this) : undefined,
                scrollEnd: this.chartSettings.scrollEnd ? this.chartSettings.scrollEnd.bind(this) : undefined,
                scrollChanged: this.chartSettings.scrollChanged ? this.chartSettings.scrollChanged.bind(this) : undefined,
                tooltipRender: this.tooltipRender.bind(this),
                loaded: this.loaded.bind(this),
                load: this.load.bind(this),
                resized: this.resized.bind(this),
                axisLabelRender: this.axisLabelRender.bind(this),
                multiLevelLabelClick: this.multiLevelLabelClick.bind(this),
            });
            this.parent.chart.isStringTemplate = true;
            this.parent.chart.appendTo('#' + this.parent.element.id + '_chart');
        }
        else {
            this.parent.chart.series = this.chartSeries;
            this.parent.chart.primaryXAxis = currentXAxis;
            if (type === 'Polar' || type === 'Radar') {
                this.parent.chart.primaryYAxis.visible = true;
                this.parent.chart.primaryYAxis = axesWithRows.axes[0];
                this.parent.chart.axes = [];
                this.parent.chart.rows = [{}];
            }
            else {
                this.parent.chart.primaryYAxis.visible = false;
                this.parent.chart.axes = axesWithRows.axes;
                if (type === 'Bar' || type === 'StackingBar' || type === 'StackingBar100' &&
                    this.chartSettings.enableMultiAxis) {
                    this.parent.chart.rows = [{ height: '100%' }];
                    this.parent.chart.columns = axesWithRows.columns;
                }
                else {
                    this.parent.chart.rows = axesWithRows.rows;
                    this.parent.chart.columns = [{ width: '100%' }];
                }
            }
            this.parent.chart.refresh();
        }
    }
    frameAxesWithRows() {
        let axes = [];
        let rows = [];
        let columns = [];
        let percentChart = this.persistSettings.chartSeries && (this.persistSettings.chartSeries.type === 'StackingColumn100' ||
            this.persistSettings.chartSeries.type === 'StackingBar100' ||
            this.persistSettings.chartSeries.type === 'StackingArea100');
        let percentAggregateTypes = ['PercentageOfGrandTotal', 'PercentageOfColumnTotal', 'PercentageOfRowTotal',
            'PercentageOfDifferenceFrom', 'PercentageOfParentRowTotal', 'PercentageOfParentColumnTotal', 'PercentageOfParentTotal'];
        if (this.chartSettings.enableMultiAxis) {
            let valCnt = 0;
            let divider = (100 / this.dataSourceSettings.values.length) + '%';
            for (let item of this.dataSourceSettings.values) {
                let measureField = this.engineModule.fieldList[item.name];
                let measureAggregatedName = (this.parent.dataType === 'olap' ? '' : (this.parent.localeObj.getConstant(measureField.aggregateType) + ' ' +
                    this.parent.localeObj.getConstant('of') + ' ')) + measureField.caption;
                // let formatSetting: IFormatSettings = this.dataSourceSettings.formatSettings.filter((itm: IFormatSettings) => {
                //     return itm.name === item.name;
                // })[0];
                let formatSetting;
                for (let field of this.dataSourceSettings.formatSettings) {
                    if (field.name === item.name) {
                        formatSetting = field;
                        break;
                    }
                }
                let format = PivotUtil.inArray(measureField.aggregateType, percentAggregateTypes) !== -1 ? 'P2' : (formatSetting ?
                    (formatSetting.format.toLowerCase().match(/n|p|c/) === null ? 'N' : formatSetting.format) : this.parent.dataType === 'olap' ? this.getFormat(measureField.formatString) : 'N');
                let resFormat = (this.chartSettings.chartSeries.type === 'Polar' || this.chartSettings.chartSeries.type === 'Radar') ? true : false;
                let currentYAxis = {};
                currentYAxis = this.persistSettings.primaryYAxis ?
                    this.frameObjectWithKeys(this.persistSettings.primaryYAxis) : currentYAxis;
                currentYAxis.labelFormat = currentYAxis.labelFormat ?
                    currentYAxis.labelFormat : (percentChart ? '' : (!resFormat ? format : 'N'));
                currentYAxis.title = currentYAxis.title ? currentYAxis.title : measureAggregatedName;
                currentYAxis.plotOffset = currentYAxis.plotOffset ? currentYAxis.plotOffset : (valCnt % 2 !== 0 ?
                    this.chartSettings.chartSeries.type === 'Bar' || this.chartSettings.chartSeries.type === 'StackingBar' ||
                        this.chartSettings.chartSeries.type === 'StackingBar100' ? 50 : 30 : 0);
                currentYAxis.rowIndex = valCnt;
                currentYAxis.columnIndex = valCnt;
                if (!resFormat) {
                    currentYAxis.name = this.measuresNames[item.name] ? this.measuresNames[item.name] : item.name;
                }
                axes = axes.concat(currentYAxis);
                rows.push({ height: divider });
                columns.push({ width: divider });
                valCnt++;
            }
        }
        else {
            let measureField = this.engineModule.fieldList[this.currentMeasure];
            let measureAggregatedName = (this.parent.dataType === 'olap' ? '' :
                (this.parent.localeObj.getConstant(measureField.aggregateType) + ' ' +
                    this.parent.localeObj.getConstant('of') + ' ')) + measureField.caption;
            // let formatSetting: IFormatSettings = this.dataSourceSettings.formatSettings.filter((item: IFormatSettings) => {
            //     return item.name === this.currentMeasure;
            // })[0];
            let formatSetting;
            for (let item of this.dataSourceSettings.formatSettings) {
                if (item.name === this.currentMeasure) {
                    formatSetting = item;
                    break;
                }
            }
            let currentYAxis = {};
            let format = PivotUtil.inArray(measureField.aggregateType, percentAggregateTypes) !== -1 ? 'P2' : (formatSetting ?
                (formatSetting.format.toLowerCase().match(/n|p|c/) === null ? 'N' : formatSetting.format) :
                this.parent.dataType === 'olap' ? this.getFormat(measureField.formatString) : 'N');
            currentYAxis = this.persistSettings.primaryYAxis ? this.frameObjectWithKeys(this.persistSettings.primaryYAxis) : currentYAxis;
            currentYAxis.rowIndex = 0;
            currentYAxis.columnIndex = 0;
            if (!(this.chartSettings.chartSeries.type === 'Polar' || this.chartSettings.chartSeries.type === 'Radar')) {
                currentYAxis.name = this.measuresNames[this.currentMeasure] ? this.measuresNames[this.currentMeasure] : this.currentMeasure;
            }
            currentYAxis.labelFormat = currentYAxis.labelFormat ? currentYAxis.labelFormat : (percentChart ? '' : format);
            currentYAxis.title = currentYAxis.title ? currentYAxis.title : measureAggregatedName;
            axes = axes.concat(currentYAxis);
            rows.push({ height: '100%' });
            columns.push({ width: '100%' });
        }
        return { axes: axes, rows: rows, columns: columns };
    }
    getFormat(format) {
        if (format === 'Currency') {
            format = 'C';
        }
        else if (format === 'Percent') {
            format = 'P';
        }
        else {
            format = 'N';
        }
        return format;
    }
    getColumnTotalIndex(pivotValues) {
        let colIndexColl = {};
        let rKeys = Object.keys(pivotValues);
        for (let rowIndex of rKeys) {
            let rows = pivotValues[Number(rowIndex)];
            let cKeys = Object.keys(rows);
            for (let cellIndex of cKeys) {
                let cell = rows[Number(cellIndex)];
                if (cell.axis !== 'column') {
                    return colIndexColl;
                }
                else if ((cell.type === 'sum' || (this.dataSourceSettings.columns.length === 0 ? false : cell.type === 'grand sum'))
                    && cell.rowSpan !== -1) {
                    colIndexColl[cell.colIndex] = cell.colIndex;
                }
            }
        }
        return colIndexColl;
    }
    groupHierarchyWithLevels(pivotValues) {
        this.fieldPosition = [];
        let group = {};
        let fieldCount = 0;
        let levelPos = {};
        this.measurePos = this.engineModule.tupRowInfo[0].measurePosition;
        for (let rowPos = 0; rowPos < pivotValues.length; rowPos++) {
            let cell = pivotValues[rowPos][0];
            if (cell && cell.axis === 'row' && cell.type !== 'grand sum') {
                if (isNullOrUndefined(group[cell.hierarchy])) {
                    if (cell.memberType === 3) {
                        if (fieldCount === this.measurePos) {
                            this.fieldPosition[this.measurePos] = cell.hierarchy;
                            group[cell.hierarchy] = { [cell.levelUniqueName]: cell.levelUniqueName };
                        }
                        else {
                            fieldCount--;
                        }
                    }
                    else {
                        this.fieldPosition[fieldCount] = cell.hierarchy;
                        group[cell.hierarchy] = { [cell.levelUniqueName]: cell.levelUniqueName };
                    }
                    fieldCount++;
                }
                else {
                    group[cell.hierarchy][cell.levelUniqueName] = cell.levelUniqueName;
                }
            }
        }
        let lastEnd = -1;
        for (let pos = 0; pos < this.fieldPosition.length; pos++) {
            if (this.measurePos !== pos) {
                levelPos[this.fieldPosition[pos]] = { start: (lastEnd + 1), end: (lastEnd + Object.keys(group[this.fieldPosition[pos]]).length) };
                lastEnd = levelPos[this.fieldPosition[pos]].end;
            }
        }
        return levelPos;
    }
    frameMultiLevelLabels() {
        let startKeys = Object.keys(this.headerColl);
        let parentHeaders = this.headerColl[-0.5];
        for (let startKey of startKeys) {
            let sKey = Number(startKey);
            let headers = this.headerColl[sKey];
            let levelPos = 0;
            let isAvail = false;
            while (levelPos <= this.maxLevel) {
                if (!isAvail) {
                    if (!headers[levelPos]) {
                        headers[levelPos] = parentHeaders[levelPos];
                    }
                    else {
                        isAvail = true;
                    }
                }
                else if (!headers[levelPos]) {
                    headers[levelPos] = {
                        name: headers[levelPos - 1].name,
                        // text: headers[levelPos - 1].text,
                        text: '',
                        hasChild: headers[levelPos - 1].hasChild,
                        isDrilled: headers[levelPos - 1].isDrilled,
                        levelName: headers[levelPos - 1].levelName,
                        level: headers[levelPos - 1].level,
                        fieldName: headers[levelPos - 1].fieldName,
                        rowIndex: headers[levelPos - 1].rowIndex,
                        colIndex: headers[levelPos - 1].colIndex,
                        span: -1,
                    };
                    // headers[levelPos - 1].span = 0;
                }
                levelPos++;
            }
            parentHeaders = this.headerColl[sKey];
        }
        let gRows = {};
        for (let startKey of startKeys) {
            let sKey = Number(startKey);
            let headers = this.headerColl[sKey];
            let lKeys = Object.keys(headers);
            for (let levelKey of lKeys) {
                let lKey = Number(levelKey);
                if (gRows[lKey]) {
                    let len = gRows[lKey].length;
                    if (headers[lKey].levelName === parentHeaders[lKey].levelName) {
                        gRows[lKey][len - 1].end = gRows[lKey][len - 1].end + 1;
                    }
                    else {
                        gRows[lKey].push({
                            start: sKey, end: sKey + 1, text: headers[lKey].text,
                            type: (headers[lKey].span === -1 ? 'WithoutTopandBottomBorder' : 'WithoutTopBorder'), customAttributes: headers[lKey]
                        });
                    }
                }
                else {
                    gRows[lKey] = [{
                            start: sKey, end: sKey + 1, text: headers[lKey].text,
                            type: (headers[lKey].span === -1 ? 'WithoutTopandBottomBorder' : 'WithoutTopBorder'), customAttributes: headers[lKey]
                        }];
                }
            }
            parentHeaders = headers;
        }
        let levellength = Object.keys(gRows).length;
        let multiLevelLabels = [];
        for (let level = levellength - 1; level > -1; level--) {
            multiLevelLabels.push({ categories: gRows[level], border: { width: 1 }, overflow: 'Trim' });
        }
        return multiLevelLabels;
    }
    getZoomFactor() {
        if (!isNaN(Number(this.parent.width))) {
            this.calculatedWidth = Number(this.parent.width);
        }
        else if (this.parent.width.indexOf('%') > -1) {
            this.calculatedWidth = this.parent.element.clientWidth * (parseFloat(this.parent.width) / 100);
        }
        else if (this.parent.width.indexOf('px') > -1) {
            this.calculatedWidth = Number(this.parent.width.toString().split('px')[0]);
        }
        else {
            this.calculatedWidth = this.parent.element.clientWidth;
        }
        let seriesLength = (this.chartSeries.length * 10) > 120 ? (this.chartSeries.length * 10) : 120;
        let zoomFactor = this.chartSeries.length > 0 ?
            (this.calculatedWidth / (Object.keys(this.chartSeries[0].dataSource).length * seriesLength)) : 1;
        zoomFactor = (zoomFactor < 1 && zoomFactor > 0) ? zoomFactor : 1;
        return zoomFactor;
    }
    configTooltipSettings() {
        let tooltip = this.chartSettings.tooltip;
        tooltip.enable = tooltip.enable === undefined ? true : tooltip.enable;
        if (isBlazor()) {
            this.parent.allowServerDataBinding = false;
            this.parent.setProperties({ chartSettings: { tooltip: { header: tooltip.header ? tooltip.header : '' } } }, true);
            this.parent.allowServerDataBinding = true;
        }
        else {
            tooltip.header = tooltip.header ? tooltip.header : '';
        }
        tooltip.enableMarker = tooltip.enableMarker === undefined ? true : tooltip.enableMarker;
        return tooltip;
    }
    configLegendSettings() {
        let legendSettings = {};
        legendSettings = this.chartSettings.legendSettings ? this.chartSettings.legendSettings : legendSettings;
        legendSettings.padding = legendSettings.padding ? legendSettings.padding : 25;
        legendSettings.shapePadding = legendSettings.shapePadding ? legendSettings.shapePadding : 10;
        return legendSettings;
    }
    configXAxis() {
        let currentXAxis = {};
        currentXAxis = this.persistSettings.primaryXAxis ? this.frameObjectWithKeys(this.persistSettings.primaryXAxis) : currentXAxis;
        currentXAxis.valueType = 'Category';
        currentXAxis.labelIntersectAction = currentXAxis.labelIntersectAction ? currentXAxis.labelIntersectAction : 'Rotate45';
        currentXAxis.title = currentXAxis.title ? currentXAxis.title :
            this.dataSourceSettings.rows.map((args) => { return args.caption || args.name; }).join(' / ');
        currentXAxis.zoomFactor = this.getZoomFactor();
        if (!this.parent.chartSettings.zoomSettings.enableScrollbar) {
            currentXAxis.zoomFactor = 1;
        }
        if (this.chartSettings.showMultiLevelLabels) {
            currentXAxis.multiLevelLabels = this.frameMultiLevelLabels();
            currentXAxis.border = { width: 1, type: 'WithoutTopandBottomBorder' };
            currentXAxis.majorTickLines = { width: 0, height: -10 };
        }
        return currentXAxis;
    }
    configZoomSettings() {
        let zoomSettings = this.chartSettings.zoomSettings;
        zoomSettings.enableSelectionZooming = zoomSettings.enableSelectionZooming === undefined ? true : zoomSettings.enableSelectionZooming;
        zoomSettings.enableScrollbar = zoomSettings.enableScrollbar === undefined ? true : zoomSettings.enableScrollbar;
        return zoomSettings;
    }
    tooltipRender(args) {
        let measure = args.series.yAxisName ? (args.series.yAxisName.split('_CumulativeAxis')[0]) :
            (this.chartSettings.enableMultiAxis ? args.series.name.split(' | ')[1] : this.measuresNames[this.currentMeasure] ?
                this.measuresNames[this.currentMeasure] : this.currentMeasure);
        let measureField = this.engineModule.fieldList[this.measuresNames[measure] ? this.measuresNames[measure] : measure];
        let measureAggregatedName = (this.parent.dataType === 'olap' ? '' : (this.parent.localeObj.getConstant(measureField.aggregateType) + ' ' +
            this.parent.localeObj.getConstant('of') + ' ')) + measureField.caption;
        let formattedText = args.text.split('<b>')[1].split('</b>')[0];
        let formatField = this.engineModule.formatFields[measureField.id];
        let formattedValue = ((formatField && formatField.format && formatField.format.toLowerCase().match(/n|p|c/) !== null &&
            this.chartSettings.useGroupingSeparator) ? this.parent.dataType === 'olap' ?
            this.engineModule.getFormattedValue(args.point.y, measureField.id, formattedText) :
            this.parent.engineModule.getFormattedValue(args.point.y, measureField.id).formattedText :
            formattedText);
        args.text = measureAggregatedName + ': ' + formattedValue +
            (this.dataSourceSettings.columns.length === 0 ? '' :
                (' <br/>' + this.parent.localeObj.getConstant('column') + ': ' + (args.series.name ? args.series.name.split(' | ')[0] : args.data.seriesName.split(' | ')[0]))) +
            (this.dataSourceSettings.rows.length === 0 ? '' :
                (' <br/>' + this.parent.localeObj.getConstant('row') + ': ' + args.point.x));
        this.parent.trigger(chartTooltipRender, args);
    }
    loaded(args) {
        this.parent.isChartLoaded = true;
        if (this.parent.chart && this.parent.showGroupingBar && this.parent.groupingBarModule &&
            this.parent.showFieldList && this.parent.currentView === 'Chart') {
            this.parent.groupingBarModule.alignIcon();
        }
        if (this.chartSettings.showMultiLevelLabels) {
            let multilabelAxisName = PivotUtil.inArray(this.chartSettings.chartSeries.type, ['Bar', 'StackingBar', 'StackingBar100']) > -1 ?
                '_chartYAxisMultiLevelLabel0' : '_chartXAxisMultiLevelLabel0';
            if (!isNullOrUndefined(this.parent.element.querySelector("#" + this.parent.element.id + multilabelAxisName))) {
                this.parent.element.querySelector("#" + this.parent.element.id + multilabelAxisName).setAttribute('cursor', 'pointer');
            }
        }
        if (this.parent.chart && this.parent.showToolbar && this.parent.element.querySelector(".e-pivot-toolbar")
            && this.parent.showGroupingBar && this.parent.element.querySelector(".e-chart-grouping-bar")) {
            this.parent.chart.height = (this.parent.getHeightAsNumber() - this.parent.element.querySelector(".e-pivot-toolbar").clientHeight -
                this.parent.element.querySelector(".e-chart-grouping-bar").clientHeight).toString();
        }
        else if (this.parent.chart && this.parent.showToolbar && this.parent.element.querySelector(".e-pivot-toolbar")) {
            this.parent.chart.height = (this.parent.getHeightAsNumber() - this.parent.element.querySelector(".e-pivot-toolbar").clientHeight).toString();
        }
        else if (this.parent.chart && this.parent.showGroupingBar && this.parent.element.querySelector(".e-chart-grouping-bar")) {
            this.parent.chart.height = (this.parent.getHeightAsNumber() - this.parent.element.querySelector(".e-chart-grouping-bar").clientHeight).toString();
        }
        else if (parseInt(this.parent.chart.height) < 200) {
            this.parent.chart.height = "200";
        }
        if (this.parent.grid && this.parent.chart && this.parent.showToolbar) {
            if (this.parent.currentView === 'Table') {
                this.parent.grid.element.style.display = '';
                this.parent.chart.element.style.display = 'none';
            }
            else {
                this.parent.grid.element.style.display = 'none';
                this.parent.chart.element.style.display = '';
            }
        }
        this.parent.notify(contentReady, {});
        this.parent.trigger(chartLoaded, args);
    }
    axisLabelRender(args) {
        if (this.chartSettings.showMultiLevelLabels) {
            if (args.axis.name === 'primaryXAxis') {
                args.text = '';
            }
        }
        this.parent.trigger(chartAxisLabelRender, args);
    }
    multiLevelLabelClick(args) {
        if (args.customAttributes && args.customAttributes.hasChild && !args.customAttributes.cell.isNamedSet) {
            if (this.parent.dataType === 'olap') {
                this.parent.onDrill(undefined, args.customAttributes);
            }
            else {
                this.onDrill(args);
            }
        }
    }
    /** @hidden */
    onDrill(args) {
        let labelInfo = args.customAttributes;
        let delimiter = (this.dataSourceSettings.drilledMembers[0] && this.dataSourceSettings.drilledMembers[0].delimiter) ?
            this.dataSourceSettings.drilledMembers[0].delimiter : '**';
        let fieldName = labelInfo.fieldName;
        let currentCell = this.engineModule.pivotValues[labelInfo.rowIndex][labelInfo.colIndex];
        let memberUqName = currentCell.valueSort.levelName.
            split(this.engineModule.valueSortSettings.headerDelimiter).join(delimiter);
        let fieldAvail = false;
        if (this.dataSourceSettings.drilledMembers.length === 0) {
            this.parent.setProperties({ dataSourceSettings: { drilledMembers: [{ name: fieldName, items: [memberUqName], delimiter: delimiter }] } }, true);
        }
        else {
            for (let fCnt = 0; fCnt < this.dataSourceSettings.drilledMembers.length; fCnt++) {
                let field = this.dataSourceSettings.drilledMembers[fCnt];
                memberUqName = memberUqName.split(delimiter).join(field.delimiter ? field.delimiter : delimiter);
                delimiter = field.delimiter = field.delimiter ? field.delimiter : delimiter;
                if (field.name === fieldName) {
                    fieldAvail = true;
                    let memIndex = field.items.indexOf(memberUqName);
                    if (memIndex > -1) {
                        field.items.splice(memIndex, 1);
                    }
                    else {
                        field.items.push(memberUqName);
                    }
                }
                else {
                    continue;
                }
            }
            if (!fieldAvail) {
                this.dataSourceSettings.drilledMembers.push({ name: fieldName, items: [memberUqName], delimiter: delimiter });
            }
        }
        this.parent.showWaitingPopup();
        let pivot = this;
        //setTimeout(() => {
        let drilledItem = {
            fieldName: fieldName, memberName: memberUqName, delimiter: delimiter,
            axis: 'row',
            action: labelInfo.isDrilled ? 'up' : 'down',
            currentCell: currentCell
        };
        pivot.parent.trigger(drill, {
            drillInfo: drilledItem,
            pivotview: isBlazor() ? undefined : pivot
        });
        if (pivot.parent.enableVirtualization) {
            pivot.engineModule.drilledMembers = pivot.dataSourceSettings.drilledMembers;
            pivot.engineModule.onDrill(drilledItem);
        }
        else {
            pivot.engineModule.generateGridData(pivot.dataSourceSettings);
        }
        pivot.parent.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
        pivot.parent.renderPivotGrid();
        //});
    }
    load(args) {
        if (args.chart.zoomModule) {
            args.chart.zoomModule.isZoomed = true;
        }
        this.parent.trigger(chartLoad, args);
    }
    resized(args) {
        if (isBlazor()) {
            args.chart = this.parent.chart;
        }
        args.chart.primaryXAxis.zoomFactor = this.getZoomFactor();
        if (!this.parent.chartSettings.zoomSettings.enableScrollbar) {
            args.chart.primaryXAxis.zoomFactor = 1;
        }
        this.parent.trigger(chartResized, args);
    }
    /**
     * To destroy the chart module
     * @returns void
     * @hidden
     */
    /* tslint:disable:no-empty */
    destroy() {
        if (this.parent.isDestroyed) {
            return;
        }
        if (this.parent.chart && !this.parent.chart.isDestroyed) {
            this.parent.chart.destroy();
        }
        else {
            return;
        }
    }
}

/**
 * Base export
 */
/** @hidden */

/**
 * Specifies Chart Themes
 */
var Theme;
(function (Theme) {
    /** @private */
    Theme.axisLabelFont = {
        size: '12px',
        fontWeight: 'Normal',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.axisTitleFont = {
        size: '14px',
        fontWeight: 'Normal',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.chartTitleFont = {
        size: '15px',
        fontWeight: '500',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.chartSubTitleFont = {
        size: '11px',
        fontWeight: '500',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.crosshairLabelFont = {
        size: '13px',
        fontWeight: 'Normal',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.tooltipLabelFont = {
        size: '13px',
        fontWeight: 'Normal',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.legendLabelFont = {
        size: '13px',
        fontWeight: 'Normal',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.stripLineLabelFont = {
        size: '12px',
        fontWeight: 'Regular',
        color: '#353535',
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.stockEventFont = {
        size: '13px',
        fontWeight: 'Normal',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
})(Theme || (Theme = {}));

var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Configures the animation behavior for chart series.
 */
class Animation extends ChildProperty {
}
__decorate$3([
    Property(true)
], Animation.prototype, "enable", void 0);
__decorate$3([
    Property(1000)
], Animation.prototype, "duration", void 0);
__decorate$3([
    Property(0)
], Animation.prototype, "delay", void 0);
class ChartSegment extends ChildProperty {
}
__decorate$3([
    Property(null)
], ChartSegment.prototype, "value", void 0);
__decorate$3([
    Property(null)
], ChartSegment.prototype, "color", void 0);
__decorate$3([
    Property('0')
], ChartSegment.prototype, "dashArray", void 0);
/**
 * Configures the fonts in charts.
 */
class Font extends ChildProperty {
}
__decorate$3([
    Property('Normal')
], Font.prototype, "fontStyle", void 0);
__decorate$3([
    Property('16px')
], Font.prototype, "size", void 0);
__decorate$3([
    Property('Normal')
], Font.prototype, "fontWeight", void 0);
__decorate$3([
    Property('')
], Font.prototype, "color", void 0);
__decorate$3([
    Property('Center')
], Font.prototype, "textAlignment", void 0);
__decorate$3([
    Property('Segoe UI')
], Font.prototype, "fontFamily", void 0);
__decorate$3([
    Property(1)
], Font.prototype, "opacity", void 0);
__decorate$3([
    Property('Trim')
], Font.prototype, "textOverflow", void 0);
/**
 * Configures the chart margins.
 */
class Margin extends ChildProperty {
}
__decorate$3([
    Property(10)
], Margin.prototype, "left", void 0);
__decorate$3([
    Property(10)
], Margin.prototype, "right", void 0);
__decorate$3([
    Property(10)
], Margin.prototype, "top", void 0);
__decorate$3([
    Property(10)
], Margin.prototype, "bottom", void 0);
/**
 * Configures the borders in the chart.
 */
class Border extends ChildProperty {
}
__decorate$3([
    Property('')
], Border.prototype, "color", void 0);
__decorate$3([
    Property(1)
], Border.prototype, "width", void 0);
/**
 * Configures the marker position in the chart.
 */
class Offset extends ChildProperty {
}
__decorate$3([
    Property(0)
], Offset.prototype, "x", void 0);
__decorate$3([
    Property(0)
], Offset.prototype, "y", void 0);
/**
 * Series and point index
 * @public
 */
class Indexes extends ChildProperty {
}
__decorate$3([
    Property(0)
], Indexes.prototype, "series", void 0);
__decorate$3([
    Property(0)
], Indexes.prototype, "point", void 0);
/**
 * Configures the chart area.
 */
class ChartArea extends ChildProperty {
}
__decorate$3([
    Complex({}, Border)
], ChartArea.prototype, "border", void 0);
__decorate$3([
    Property('transparent')
], ChartArea.prototype, "background", void 0);
__decorate$3([
    Property(1)
], ChartArea.prototype, "opacity", void 0);
__decorate$3([
    Property(null)
], ChartArea.prototype, "backgroundImage", void 0);
/**
 * Configures the crosshair in the chart.
 */
class CrosshairSettings extends ChildProperty {
}
__decorate$3([
    Property(false)
], CrosshairSettings.prototype, "enable", void 0);
__decorate$3([
    Property('')
], CrosshairSettings.prototype, "dashArray", void 0);
__decorate$3([
    Complex({ color: null, width: 1 }, Border)
], CrosshairSettings.prototype, "line", void 0);
__decorate$3([
    Property('Both')
], CrosshairSettings.prototype, "lineType", void 0);
/**
 * Configures the data label in the series.
 */
class DataLabelSettings extends ChildProperty {
}
__decorate$3([
    Property(false)
], DataLabelSettings.prototype, "visible", void 0);
__decorate$3([
    Property(null)
], DataLabelSettings.prototype, "name", void 0);
__decorate$3([
    Property('transparent')
], DataLabelSettings.prototype, "fill", void 0);
__decorate$3([
    Property(1)
], DataLabelSettings.prototype, "opacity", void 0);
__decorate$3([
    Property(0)
], DataLabelSettings.prototype, "angle", void 0);
__decorate$3([
    Property(false)
], DataLabelSettings.prototype, "enableRotation", void 0);
__decorate$3([
    Property('Auto')
], DataLabelSettings.prototype, "position", void 0);
__decorate$3([
    Property(5)
], DataLabelSettings.prototype, "rx", void 0);
__decorate$3([
    Property(5)
], DataLabelSettings.prototype, "ry", void 0);
__decorate$3([
    Property('Center')
], DataLabelSettings.prototype, "alignment", void 0);
__decorate$3([
    Complex({ width: null, color: null }, Border)
], DataLabelSettings.prototype, "border", void 0);
__decorate$3([
    Complex({ left: 5, right: 5, top: 5, bottom: 5 }, Margin)
], DataLabelSettings.prototype, "margin", void 0);
__decorate$3([
    Complex({ size: '11px', color: '', fontStyle: 'Normal', fontWeight: 'Normal', fontFamily: 'Segoe UI' }, Font)
], DataLabelSettings.prototype, "font", void 0);
__decorate$3([
    Property(null)
], DataLabelSettings.prototype, "template", void 0);
/**
 *  Configures the marker in the series.
 */
class MarkerSettings extends ChildProperty {
}
__decorate$3([
    Property(false)
], MarkerSettings.prototype, "visible", void 0);
__decorate$3([
    Property('Circle')
], MarkerSettings.prototype, "shape", void 0);
__decorate$3([
    Property('')
], MarkerSettings.prototype, "imageUrl", void 0);
__decorate$3([
    Property(5)
], MarkerSettings.prototype, "width", void 0);
__decorate$3([
    Property(5)
], MarkerSettings.prototype, "height", void 0);
__decorate$3([
    Complex({ width: 2, color: null }, Border)
], MarkerSettings.prototype, "border", void 0);
__decorate$3([
    Complex({ x: 0, y: 0 }, Offset)
], MarkerSettings.prototype, "offset", void 0);
__decorate$3([
    Property(null)
], MarkerSettings.prototype, "fill", void 0);
__decorate$3([
    Property(1)
], MarkerSettings.prototype, "opacity", void 0);
__decorate$3([
    Complex({}, DataLabelSettings)
], MarkerSettings.prototype, "dataLabel", void 0);
/**
 * Configures Error bar in series.
 */
class ErrorBarCapSettings extends ChildProperty {
}
__decorate$3([
    Property(1)
], ErrorBarCapSettings.prototype, "width", void 0);
__decorate$3([
    Property(10)
], ErrorBarCapSettings.prototype, "length", void 0);
__decorate$3([
    Property(null)
], ErrorBarCapSettings.prototype, "color", void 0);
__decorate$3([
    Property(1)
], ErrorBarCapSettings.prototype, "opacity", void 0);
/**
 * Error bar settings
 * @public
 */
class ErrorBarSettings extends ChildProperty {
}
__decorate$3([
    Property(false)
], ErrorBarSettings.prototype, "visible", void 0);
__decorate$3([
    Property('Fixed')
], ErrorBarSettings.prototype, "type", void 0);
__decorate$3([
    Property('Both')
], ErrorBarSettings.prototype, "direction", void 0);
__decorate$3([
    Property('Vertical')
], ErrorBarSettings.prototype, "mode", void 0);
__decorate$3([
    Property(1)
], ErrorBarSettings.prototype, "verticalError", void 0);
__decorate$3([
    Property(null)
], ErrorBarSettings.prototype, "color", void 0);
__decorate$3([
    Property(1)
], ErrorBarSettings.prototype, "width", void 0);
__decorate$3([
    Property(1)
], ErrorBarSettings.prototype, "horizontalError", void 0);
__decorate$3([
    Property(3)
], ErrorBarSettings.prototype, "verticalNegativeError", void 0);
__decorate$3([
    Property(3)
], ErrorBarSettings.prototype, "verticalPositiveError", void 0);
__decorate$3([
    Property(1)
], ErrorBarSettings.prototype, "horizontalNegativeError", void 0);
__decorate$3([
    Property(1)
], ErrorBarSettings.prototype, "horizontalPositiveError", void 0);
__decorate$3([
    Complex(null, ErrorBarCapSettings)
], ErrorBarSettings.prototype, "errorBarCap", void 0);
/**
 * Defines the behavior of the Trendlines
 */
class Trendline extends ChildProperty {
}
__decorate$3([
    Property('')
], Trendline.prototype, "name", void 0);
__decorate$3([
    Property('0')
], Trendline.prototype, "dashArray", void 0);
__decorate$3([
    Property(true)
], Trendline.prototype, "visible", void 0);
__decorate$3([
    Property(2)
], Trendline.prototype, "period", void 0);
__decorate$3([
    Property('Linear')
], Trendline.prototype, "type", void 0);
__decorate$3([
    Property(0)
], Trendline.prototype, "backwardForecast", void 0);
__decorate$3([
    Property(0)
], Trendline.prototype, "forwardForecast", void 0);
__decorate$3([
    Property(2)
], Trendline.prototype, "polynomialOrder", void 0);
__decorate$3([
    Complex({}, MarkerSettings)
], Trendline.prototype, "marker", void 0);
__decorate$3([
    Property(true)
], Trendline.prototype, "enableTooltip", void 0);
__decorate$3([
    Complex({}, Animation)
], Trendline.prototype, "animation", void 0);
__decorate$3([
    Property('')
], Trendline.prototype, "fill", void 0);
__decorate$3([
    Property(1)
], Trendline.prototype, "width", void 0);
__decorate$3([
    Property(null)
], Trendline.prototype, "intercept", void 0);
__decorate$3([
    Property('SeriesType')
], Trendline.prototype, "legendShape", void 0);
/**
 * Configures the Empty Points of series
 */
class EmptyPointSettings extends ChildProperty {
}
__decorate$3([
    Property(null)
], EmptyPointSettings.prototype, "fill", void 0);
__decorate$3([
    Complex({ color: 'transparent', width: 0 }, Border)
], EmptyPointSettings.prototype, "border", void 0);
__decorate$3([
    Property('Gap')
], EmptyPointSettings.prototype, "mode", void 0);
/**
 * Column series rounded corner options
 */
class CornerRadius extends ChildProperty {
}
__decorate$3([
    Property(0)
], CornerRadius.prototype, "topLeft", void 0);
__decorate$3([
    Property(0)
], CornerRadius.prototype, "topRight", void 0);
__decorate$3([
    Property(0)
], CornerRadius.prototype, "bottomLeft", void 0);
__decorate$3([
    Property(0)
], CornerRadius.prototype, "bottomRight", void 0);
/**
 * Configures the crosshair ToolTip.
 */
class CrosshairTooltip extends ChildProperty {
}
__decorate$3([
    Property(false)
], CrosshairTooltip.prototype, "enable", void 0);
__decorate$3([
    Property(null)
], CrosshairTooltip.prototype, "fill", void 0);
__decorate$3([
    Complex(Theme.crosshairLabelFont, Font)
], CrosshairTooltip.prototype, "textStyle", void 0);
/**
 * Strip line properties
 */
class StripLineSettings extends ChildProperty {
}
__decorate$3([
    Property(true)
], StripLineSettings.prototype, "visible", void 0);
__decorate$3([
    Property(false)
], StripLineSettings.prototype, "startFromAxis", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "start", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "end", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "size", void 0);
__decorate$3([
    Property('#808080')
], StripLineSettings.prototype, "color", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "dashArray", void 0);
__decorate$3([
    Property('Auto')
], StripLineSettings.prototype, "sizeType", void 0);
__decorate$3([
    Property(false)
], StripLineSettings.prototype, "isRepeat", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "repeatEvery", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "repeatUntil", void 0);
__decorate$3([
    Property(false)
], StripLineSettings.prototype, "isSegmented", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "segmentStart", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "segmentEnd", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "segmentAxisName", void 0);
__decorate$3([
    Complex({ color: 'transparent', width: 1 }, Border)
], StripLineSettings.prototype, "border", void 0);
__decorate$3([
    Property('')
], StripLineSettings.prototype, "text", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "rotation", void 0);
__decorate$3([
    Property('Middle')
], StripLineSettings.prototype, "horizontalAlignment", void 0);
__decorate$3([
    Property('Middle')
], StripLineSettings.prototype, "verticalAlignment", void 0);
__decorate$3([
    Complex(Theme.stripLineLabelFont, Font)
], StripLineSettings.prototype, "textStyle", void 0);
__decorate$3([
    Property('Behind')
], StripLineSettings.prototype, "zIndex", void 0);
__decorate$3([
    Property(1)
], StripLineSettings.prototype, "opacity", void 0);
/**
 * label border properties.
 */
class LabelBorder extends ChildProperty {
}
__decorate$3([
    Property('')
], LabelBorder.prototype, "color", void 0);
__decorate$3([
    Property(1)
], LabelBorder.prototype, "width", void 0);
__decorate$3([
    Property('Rectangle')
], LabelBorder.prototype, "type", void 0);
/**
 * Configures the major grid lines in the `axis`.
 */
class MajorGridLines extends ChildProperty {
}
__decorate$3([
    Property(1)
], MajorGridLines.prototype, "width", void 0);
__decorate$3([
    Property('')
], MajorGridLines.prototype, "dashArray", void 0);
__decorate$3([
    Property(null)
], MajorGridLines.prototype, "color", void 0);
/**
 * Configures the minor grid lines in the `axis`.
 */
class MinorGridLines extends ChildProperty {
}
__decorate$3([
    Property(0.7)
], MinorGridLines.prototype, "width", void 0);
__decorate$3([
    Property('')
], MinorGridLines.prototype, "dashArray", void 0);
__decorate$3([
    Property(null)
], MinorGridLines.prototype, "color", void 0);
/**
 * Configures the axis line of a chart.
 */
class AxisLine extends ChildProperty {
}
__decorate$3([
    Property(1)
], AxisLine.prototype, "width", void 0);
__decorate$3([
    Property('')
], AxisLine.prototype, "dashArray", void 0);
__decorate$3([
    Property(null)
], AxisLine.prototype, "color", void 0);
/**
 * Configures the major tick lines.
 */
class MajorTickLines extends ChildProperty {
}
__decorate$3([
    Property(1)
], MajorTickLines.prototype, "width", void 0);
__decorate$3([
    Property(5)
], MajorTickLines.prototype, "height", void 0);
__decorate$3([
    Property(null)
], MajorTickLines.prototype, "color", void 0);
/**
 * Configures the minor tick lines.
 */
class MinorTickLines extends ChildProperty {
}
__decorate$3([
    Property(0.7)
], MinorTickLines.prototype, "width", void 0);
__decorate$3([
    Property(5)
], MinorTickLines.prototype, "height", void 0);
__decorate$3([
    Property(null)
], MinorTickLines.prototype, "color", void 0);
/**
 *  third party configures for chart series in chart settings.
 */
class PivotChartSeriesBorder {
}
__decorate$3([
    Property('')
], PivotChartSeriesBorder.prototype, "color", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesBorder.prototype, "width", void 0);
class PivotChartSeriesAnimation {
}
__decorate$3([
    Property(true)
], PivotChartSeriesAnimation.prototype, "enable", void 0);
__decorate$3([
    Property(1000)
], PivotChartSeriesAnimation.prototype, "duration", void 0);
__decorate$3([
    Property(0)
], PivotChartSeriesAnimation.prototype, "delay", void 0);
class PivotChartSeriesSegment {
}
__decorate$3([
    Property(null)
], PivotChartSeriesSegment.prototype, "value", void 0);
__decorate$3([
    Property(null)
], PivotChartSeriesSegment.prototype, "color", void 0);
__decorate$3([
    Property('0')
], PivotChartSeriesSegment.prototype, "dashArray", void 0);
class PivotChartSeriesMarkerSettings {
}
__decorate$3([
    Property(false)
], PivotChartSeriesMarkerSettings.prototype, "visible", void 0);
__decorate$3([
    Property('Circle')
], PivotChartSeriesMarkerSettings.prototype, "shape", void 0);
__decorate$3([
    Property('')
], PivotChartSeriesMarkerSettings.prototype, "imageUrl", void 0);
__decorate$3([
    Property(5)
], PivotChartSeriesMarkerSettings.prototype, "height", void 0);
__decorate$3([
    Property(5)
], PivotChartSeriesMarkerSettings.prototype, "width", void 0);
__decorate$3([
    Complex({ width: 2, color: null }, Border)
], PivotChartSeriesMarkerSettings.prototype, "border", void 0);
__decorate$3([
    Property(null)
], PivotChartSeriesMarkerSettings.prototype, "fill", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesMarkerSettings.prototype, "opacity", void 0);
__decorate$3([
    Complex({}, DataLabelSettings)
], PivotChartSeriesMarkerSettings.prototype, "dataLabel", void 0);
class PivotChartSeriesErrorSettings {
}
__decorate$3([
    Property(false)
], PivotChartSeriesErrorSettings.prototype, "visible", void 0);
__decorate$3([
    Property('Fixed')
], PivotChartSeriesErrorSettings.prototype, "type", void 0);
__decorate$3([
    Property('Both')
], PivotChartSeriesErrorSettings.prototype, "direction", void 0);
__decorate$3([
    Property('Vertical')
], PivotChartSeriesErrorSettings.prototype, "mode", void 0);
__decorate$3([
    Property(null)
], PivotChartSeriesErrorSettings.prototype, "color", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesErrorSettings.prototype, "verticalError", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesErrorSettings.prototype, "width", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesErrorSettings.prototype, "horizontalError", void 0);
__decorate$3([
    Property(3)
], PivotChartSeriesErrorSettings.prototype, "verticalPositiveError", void 0);
__decorate$3([
    Property(3)
], PivotChartSeriesErrorSettings.prototype, "verticalNegativeError", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesErrorSettings.prototype, "horizontalPositiveError", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesErrorSettings.prototype, "horizontalNegativeError", void 0);
__decorate$3([
    Complex(null, ErrorBarCapSettings)
], PivotChartSeriesErrorSettings.prototype, "errorBarCap", void 0);
class PivotChartSeriesTrendline {
}
__decorate$3([
    Property('')
], PivotChartSeriesTrendline.prototype, "name", void 0);
__decorate$3([
    Property('Linear')
], PivotChartSeriesTrendline.prototype, "type", void 0);
__decorate$3([
    Property(2)
], PivotChartSeriesTrendline.prototype, "period", void 0);
__decorate$3([
    Property(2)
], PivotChartSeriesTrendline.prototype, "polynomialOrder", void 0);
__decorate$3([
    Property(0)
], PivotChartSeriesTrendline.prototype, "backwardForecast", void 0);
__decorate$3([
    Property(0)
], PivotChartSeriesTrendline.prototype, "forwardForecast", void 0);
__decorate$3([
    Complex({}, Animation)
], PivotChartSeriesTrendline.prototype, "animation", void 0);
__decorate$3([
    Complex({}, MarkerSettings)
], PivotChartSeriesTrendline.prototype, "marker", void 0);
__decorate$3([
    Property(true)
], PivotChartSeriesTrendline.prototype, "enableTooltip", void 0);
__decorate$3([
    Property(null)
], PivotChartSeriesTrendline.prototype, "intercept", void 0);
__decorate$3([
    Property('')
], PivotChartSeriesTrendline.prototype, "fill", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesTrendline.prototype, "width", void 0);
__decorate$3([
    Property('SeriesType')
], PivotChartSeriesTrendline.prototype, "legendShape", void 0);
class PivotChartSeriesEmptyPointSettings {
}
__decorate$3([
    Property(null)
], PivotChartSeriesEmptyPointSettings.prototype, "fill", void 0);
__decorate$3([
    Complex({ color: 'transparent', width: 0 }, Border)
], PivotChartSeriesEmptyPointSettings.prototype, "border", void 0);
__decorate$3([
    Property('Gap')
], PivotChartSeriesEmptyPointSettings.prototype, "mode", void 0);
class PivotChartSeriesCornerRadius {
}
__decorate$3([
    Property(0)
], PivotChartSeriesCornerRadius.prototype, "topLeft", void 0);
__decorate$3([
    Property(0)
], PivotChartSeriesCornerRadius.prototype, "topRight", void 0);
__decorate$3([
    Property(0)
], PivotChartSeriesCornerRadius.prototype, "bottomLeft", void 0);
__decorate$3([
    Property(0)
], PivotChartSeriesCornerRadius.prototype, "bottomRight", void 0);
/**
 *  third party configures for chart axis in chart settings.
 */
class PivotChartAxisFont {
}
__decorate$3([
    Property('Normal')
], PivotChartAxisFont.prototype, "fontStyle", void 0);
__decorate$3([
    Property('16px')
], PivotChartAxisFont.prototype, "size", void 0);
__decorate$3([
    Property('Normal')
], PivotChartAxisFont.prototype, "fontWeight", void 0);
__decorate$3([
    Property('')
], PivotChartAxisFont.prototype, "color", void 0);
__decorate$3([
    Property('Center')
], PivotChartAxisFont.prototype, "textAlignment", void 0);
__decorate$3([
    Property('Segoe UI')
], PivotChartAxisFont.prototype, "fontFamily", void 0);
__decorate$3([
    Property(1)
], PivotChartAxisFont.prototype, "opacity", void 0);
__decorate$3([
    Property('Trim')
], PivotChartAxisFont.prototype, "textOverflow", void 0);
class PivotChartAxisCrosshairTooltip {
}
__decorate$3([
    Property(false)
], PivotChartAxisCrosshairTooltip.prototype, "enable", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisCrosshairTooltip.prototype, "fill", void 0);
__decorate$3([
    Complex(Theme.crosshairLabelFont, Font)
], PivotChartAxisCrosshairTooltip.prototype, "textStyle", void 0);
class PivotChartAxisMajorTickLines {
}
__decorate$3([
    Property(1)
], PivotChartAxisMajorTickLines.prototype, "width", void 0);
__decorate$3([
    Property(5)
], PivotChartAxisMajorTickLines.prototype, "height", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisMajorTickLines.prototype, "color", void 0);
class PivotChartAxisMajorGridLines {
}
__decorate$3([
    Property(1)
], PivotChartAxisMajorGridLines.prototype, "width", void 0);
__decorate$3([
    Property('')
], PivotChartAxisMajorGridLines.prototype, "dashArray", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisMajorGridLines.prototype, "color", void 0);
class PivotChartAxisMinorTickLines {
}
__decorate$3([
    Property(0.7)
], PivotChartAxisMinorTickLines.prototype, "width", void 0);
__decorate$3([
    Property(5)
], PivotChartAxisMinorTickLines.prototype, "height", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisMinorTickLines.prototype, "color", void 0);
class PivotChartAxisMinorGridLines {
}
__decorate$3([
    Property(0.7)
], PivotChartAxisMinorGridLines.prototype, "width", void 0);
__decorate$3([
    Property('')
], PivotChartAxisMinorGridLines.prototype, "dashArray", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisMinorGridLines.prototype, "color", void 0);
class PivotChartAxisAxisLine {
}
__decorate$3([
    Property(1)
], PivotChartAxisAxisLine.prototype, "width", void 0);
__decorate$3([
    Property('')
], PivotChartAxisAxisLine.prototype, "dashArray", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisAxisLine.prototype, "color", void 0);
class PivotChartAxisStripLineSettings {
}
__decorate$3([
    Property(true)
], PivotChartAxisStripLineSettings.prototype, "visible", void 0);
__decorate$3([
    Property(false)
], PivotChartAxisStripLineSettings.prototype, "startFromAxis", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "start", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "end", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "size", void 0);
__decorate$3([
    Property('#808080')
], PivotChartAxisStripLineSettings.prototype, "color", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "dashArray", void 0);
__decorate$3([
    Property('Auto')
], PivotChartAxisStripLineSettings.prototype, "sizeType", void 0);
__decorate$3([
    Property(false)
], PivotChartAxisStripLineSettings.prototype, "isRepeat", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "repeatEvery", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "repeatUntil", void 0);
__decorate$3([
    Property(false)
], PivotChartAxisStripLineSettings.prototype, "isSegmented", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "segmentStart", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "segmentEnd", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "segmentAxisName", void 0);
__decorate$3([
    Complex({ color: 'transparent', width: 1 }, Border)
], PivotChartAxisStripLineSettings.prototype, "border", void 0);
__decorate$3([
    Property('')
], PivotChartAxisStripLineSettings.prototype, "text", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "rotation", void 0);
__decorate$3([
    Property('Middle')
], PivotChartAxisStripLineSettings.prototype, "horizontalAlignment", void 0);
__decorate$3([
    Property('Middle')
], PivotChartAxisStripLineSettings.prototype, "verticalAlignment", void 0);
__decorate$3([
    Complex(Theme.stripLineLabelFont, Font)
], PivotChartAxisStripLineSettings.prototype, "textStyle", void 0);
__decorate$3([
    Property('Behind')
], PivotChartAxisStripLineSettings.prototype, "zIndex", void 0);
__decorate$3([
    Property(1)
], PivotChartAxisStripLineSettings.prototype, "opacity", void 0);
class PivotChartAxisLabelBorder {
}
__decorate$3([
    Property('')
], PivotChartAxisLabelBorder.prototype, "color", void 0);
__decorate$3([
    Property(1)
], PivotChartAxisLabelBorder.prototype, "width", void 0);
__decorate$3([
    Property('Rectangle')
], PivotChartAxisLabelBorder.prototype, "type", void 0);
/**
 *  third party configures in chart settings.
 */
class PivotChartSettingsChartArea {
}
__decorate$3([
    Complex({}, Border)
], PivotChartSettingsChartArea.prototype, "border", void 0);
__decorate$3([
    Property('transparent')
], PivotChartSettingsChartArea.prototype, "background", void 0);
__decorate$3([
    Property(1)
], PivotChartSettingsChartArea.prototype, "opacity", void 0);
class PivotChartSettingsCrosshairSettings {
}
__decorate$3([
    Property(false)
], PivotChartSettingsCrosshairSettings.prototype, "enable", void 0);
__decorate$3([
    Property('')
], PivotChartSettingsCrosshairSettings.prototype, "dashArray", void 0);
__decorate$3([
    Complex({ color: null, width: 1 }, Border)
], PivotChartSettingsCrosshairSettings.prototype, "line", void 0);
__decorate$3([
    Property('Both')
], PivotChartSettingsCrosshairSettings.prototype, "lineType", void 0);
class PivotChartSettingsLegendSettings {
}
__decorate$3([
    Property(true)
], PivotChartSettingsLegendSettings.prototype, "visible", void 0);
__decorate$3([
    Property(null)
], PivotChartSettingsLegendSettings.prototype, "height", void 0);
__decorate$3([
    Property(null)
], PivotChartSettingsLegendSettings.prototype, "width", void 0);
__decorate$3([
    Complex({ x: 0, y: 0 }, ChartLocation)
], PivotChartSettingsLegendSettings.prototype, "location", void 0);
__decorate$3([
    Property('Auto')
], PivotChartSettingsLegendSettings.prototype, "position", void 0);
__decorate$3([
    Property(8)
], PivotChartSettingsLegendSettings.prototype, "padding", void 0);
__decorate$3([
    Property('Center')
], PivotChartSettingsLegendSettings.prototype, "alignment", void 0);
__decorate$3([
    Complex(Theme.legendLabelFont, Font)
], PivotChartSettingsLegendSettings.prototype, "textStyle", void 0);
__decorate$3([
    Property(10)
], PivotChartSettingsLegendSettings.prototype, "shapeHeight", void 0);
__decorate$3([
    Property(10)
], PivotChartSettingsLegendSettings.prototype, "shapeWidth", void 0);
__decorate$3([
    Complex({}, Border)
], PivotChartSettingsLegendSettings.prototype, "border", void 0);
__decorate$3([
    Complex({ left: 0, right: 0, top: 0, bottom: 0 }, Margin)
], PivotChartSettingsLegendSettings.prototype, "margin", void 0);
__decorate$3([
    Property(5)
], PivotChartSettingsLegendSettings.prototype, "shapePadding", void 0);
__decorate$3([
    Property('transparent')
], PivotChartSettingsLegendSettings.prototype, "background", void 0);
__decorate$3([
    Property(1)
], PivotChartSettingsLegendSettings.prototype, "opacity", void 0);
__decorate$3([
    Property(true)
], PivotChartSettingsLegendSettings.prototype, "toggleVisibility", void 0);
__decorate$3([
    Property(null)
], PivotChartSettingsLegendSettings.prototype, "description", void 0);
__decorate$3([
    Property(3)
], PivotChartSettingsLegendSettings.prototype, "tabIndex", void 0);
class PivotChartSettingsIndexes {
}
__decorate$3([
    Property(0)
], PivotChartSettingsIndexes.prototype, "series", void 0);
__decorate$3([
    Property(0)
], PivotChartSettingsIndexes.prototype, "point", void 0);
class PivotChartSettingsMargin {
}
__decorate$3([
    Property(10)
], PivotChartSettingsMargin.prototype, "left", void 0);
__decorate$3([
    Property(10)
], PivotChartSettingsMargin.prototype, "right", void 0);
__decorate$3([
    Property(10)
], PivotChartSettingsMargin.prototype, "top", void 0);
__decorate$3([
    Property(10)
], PivotChartSettingsMargin.prototype, "bottom", void 0);
/**
 *  Configures the series in charts.
 */
class PivotSeries extends ChildProperty {
}
__decorate$3([
    Property(null)
], PivotSeries.prototype, "fill", void 0);
__decorate$3([
    Complex(null, Animation)
], PivotSeries.prototype, "animation", void 0);
__decorate$3([
    Property('0')
], PivotSeries.prototype, "dashArray", void 0);
__decorate$3([
    Property(1)
], PivotSeries.prototype, "width", void 0);
__decorate$3([
    Property('X')
], PivotSeries.prototype, "segmentAxis", void 0);
__decorate$3([
    Property('Line')
], PivotSeries.prototype, "drawType", void 0);
__decorate$3([
    Property(true)
], PivotSeries.prototype, "isClosed", void 0);
__decorate$3([
    Collection([], ChartSegment)
], PivotSeries.prototype, "segments", void 0);
__decorate$3([
    Property('')
], PivotSeries.prototype, "stackingGroup", void 0);
__decorate$3([
    Complex({ color: 'transparent', width: 0 }, Border)
], PivotSeries.prototype, "border", void 0);
__decorate$3([
    Property(true)
], PivotSeries.prototype, "visible", void 0);
__decorate$3([
    Property(1)
], PivotSeries.prototype, "opacity", void 0);
__decorate$3([
    Property('Line')
], PivotSeries.prototype, "type", void 0);
__decorate$3([
    Complex(null, MarkerSettings)
], PivotSeries.prototype, "marker", void 0);
__decorate$3([
    Complex(null, ErrorBarSettings)
], PivotSeries.prototype, "errorBar", void 0);
__decorate$3([
    Property(true)
], PivotSeries.prototype, "enableTooltip", void 0);
__decorate$3([
    Collection([], Trendline)
], PivotSeries.prototype, "trendlines", void 0);
__decorate$3([
    Property('')
], PivotSeries.prototype, "tooltipMappingName", void 0);
__decorate$3([
    Property('SeriesType')
], PivotSeries.prototype, "legendShape", void 0);
__decorate$3([
    Property(1)
], PivotSeries.prototype, "minRadius", void 0);
__decorate$3([
    Property(null)
], PivotSeries.prototype, "selectionStyle", void 0);
__decorate$3([
    Property('Natural')
], PivotSeries.prototype, "splineType", void 0);
__decorate$3([
    Property(3)
], PivotSeries.prototype, "maxRadius", void 0);
__decorate$3([
    Property(0.5)
], PivotSeries.prototype, "cardinalSplineTension", void 0);
__decorate$3([
    Property(null)
], PivotSeries.prototype, "columnWidth", void 0);
__decorate$3([
    Complex(null, EmptyPointSettings)
], PivotSeries.prototype, "emptyPointSettings", void 0);
__decorate$3([
    Complex(null, CornerRadius)
], PivotSeries.prototype, "cornerRadius", void 0);
__decorate$3([
    Property(0)
], PivotSeries.prototype, "columnSpacing", void 0);
/**
 * Configures the axes in charts.
 */
class PivotAxis extends ChildProperty {
}
__decorate$3([
    Property('Rotate45')
], PivotAxis.prototype, "labelIntersectAction", void 0);
__decorate$3([
    Complex(Theme.axisLabelFont, Font)
], PivotAxis.prototype, "labelStyle", void 0);
__decorate$3([
    Property('')
], PivotAxis.prototype, "title", void 0);
__decorate$3([
    Complex({}, CrosshairTooltip)
], PivotAxis.prototype, "crosshairTooltip", void 0);
__decorate$3([
    Property('')
], PivotAxis.prototype, "labelFormat", void 0);
__decorate$3([
    Complex(Theme.axisTitleFont, Font)
], PivotAxis.prototype, "titleStyle", void 0);
__decorate$3([
    Property(false)
], PivotAxis.prototype, "isIndexed", void 0);
__decorate$3([
    Property(0)
], PivotAxis.prototype, "plotOffset", void 0);
__decorate$3([
    Property('None')
], PivotAxis.prototype, "edgeLabelPlacement", void 0);
__decorate$3([
    Property('BetweenTicks')
], PivotAxis.prototype, "labelPlacement", void 0);
__decorate$3([
    Property('Outside')
], PivotAxis.prototype, "tickPosition", void 0);
__decorate$3([
    Property(false)
], PivotAxis.prototype, "opposedPosition", void 0);
__decorate$3([
    Property(true)
], PivotAxis.prototype, "visible", void 0);
__decorate$3([
    Property('Outside')
], PivotAxis.prototype, "labelPosition", void 0);
__decorate$3([
    Property(0)
], PivotAxis.prototype, "labelRotation", void 0);
__decorate$3([
    Property(0)
], PivotAxis.prototype, "minorTicksPerInterval", void 0);
__decorate$3([
    Property(null)
], PivotAxis.prototype, "maximum", void 0);
__decorate$3([
    Property(null)
], PivotAxis.prototype, "minimum", void 0);
__decorate$3([
    Property(34)
], PivotAxis.prototype, "maximumLabelWidth", void 0);
__decorate$3([
    Property(null)
], PivotAxis.prototype, "interval", void 0);
__decorate$3([
    Complex({}, MajorTickLines)
], PivotAxis.prototype, "majorTickLines", void 0);
__decorate$3([
    Property(false)
], PivotAxis.prototype, "enableTrim", void 0);
__decorate$3([
    Complex({}, MajorGridLines)
], PivotAxis.prototype, "majorGridLines", void 0);
__decorate$3([
    Complex({}, MinorTickLines)
], PivotAxis.prototype, "minorTickLines", void 0);
__decorate$3([
    Complex({}, AxisLine)
], PivotAxis.prototype, "lineStyle", void 0);
__decorate$3([
    Complex({}, MinorGridLines)
], PivotAxis.prototype, "minorGridLines", void 0);
__decorate$3([
    Property(false)
], PivotAxis.prototype, "isInversed", void 0);
__decorate$3([
    Property(null)
], PivotAxis.prototype, "description", void 0);
__decorate$3([
    Property(0)
], PivotAxis.prototype, "startAngle", void 0);
__decorate$3([
    Property(100)
], PivotAxis.prototype, "coefficient", void 0);
__decorate$3([
    Collection([], StripLineSettings)
], PivotAxis.prototype, "stripLines", void 0);
__decorate$3([
    Property(2)
], PivotAxis.prototype, "tabIndex", void 0);
__decorate$3([
    Complex({ color: null, width: 0, type: 'Rectangle' }, LabelBorder)
], PivotAxis.prototype, "border", void 0);
/**
 * Configures the ToolTips in the chart.
 */
class PivotTooltipSettings extends ChildProperty {
}
__decorate$3([
    Property(false)
], PivotTooltipSettings.prototype, "enableMarker", void 0);
__decorate$3([
    Property(true)
], PivotTooltipSettings.prototype, "enable", void 0);
__decorate$3([
    Property(null)
], PivotTooltipSettings.prototype, "fill", void 0);
__decorate$3([
    Property(false)
], PivotTooltipSettings.prototype, "shared", void 0);
__decorate$3([
    Property(0.75)
], PivotTooltipSettings.prototype, "opacity", void 0);
__decorate$3([
    Property(null)
], PivotTooltipSettings.prototype, "header", void 0);
__decorate$3([
    Property(null)
], PivotTooltipSettings.prototype, "format", void 0);
__decorate$3([
    Complex(Theme.tooltipLabelFont, Font)
], PivotTooltipSettings.prototype, "textStyle", void 0);
__decorate$3([
    Property(null)
], PivotTooltipSettings.prototype, "template", void 0);
__decorate$3([
    Complex({ color: '#cccccc', width: 0.5 }, Border)
], PivotTooltipSettings.prototype, "border", void 0);
__decorate$3([
    Property(true)
], PivotTooltipSettings.prototype, "enableAnimation", void 0);
/**
 * Configures the zooming behavior for the chart.
 */
class PivotZoomSettings extends ChildProperty {
}
__decorate$3([
    Property(false)
], PivotZoomSettings.prototype, "enablePinchZooming", void 0);
__decorate$3([
    Property(true)
], PivotZoomSettings.prototype, "enableSelectionZooming", void 0);
__decorate$3([
    Property(false)
], PivotZoomSettings.prototype, "enableDeferredZooming", void 0);
__decorate$3([
    Property(false)
], PivotZoomSettings.prototype, "enableMouseWheelZooming", void 0);
__decorate$3([
    Property('XY')
], PivotZoomSettings.prototype, "mode", void 0);
__decorate$3([
    Property(['Zoom', 'ZoomIn', 'ZoomOut', 'Pan', 'Reset'])
], PivotZoomSettings.prototype, "toolbarItems", void 0);
__decorate$3([
    Property(true)
], PivotZoomSettings.prototype, "enableScrollbar", void 0);
__decorate$3([
    Property(false)
], PivotZoomSettings.prototype, "enablePan", void 0);
/**
 *  Configures the chart settings.
 */
class ChartSettings extends ChildProperty {
}
__decorate$3([
    Complex({}, PivotSeries)
], ChartSettings.prototype, "chartSeries", void 0);
__decorate$3([
    Complex({}, PivotAxis)
], ChartSettings.prototype, "primaryXAxis", void 0);
__decorate$3([
    Complex({}, PivotAxis)
], ChartSettings.prototype, "primaryYAxis", void 0);
__decorate$3([
    Property('')
], ChartSettings.prototype, "value", void 0);
__decorate$3([
    Property(false)
], ChartSettings.prototype, "enableMultiAxis", void 0);
__decorate$3([
    Complex(Theme.chartTitleFont, Font)
], ChartSettings.prototype, "titleStyle", void 0);
__decorate$3([
    Property('')
], ChartSettings.prototype, "title", void 0);
__decorate$3([
    Complex(Theme.chartSubTitleFont, Font)
], ChartSettings.prototype, "subTitleStyle", void 0);
__decorate$3([
    Property('')
], ChartSettings.prototype, "subTitle", void 0);
__decorate$3([
    Complex({ color: '#DDDDDD', width: 0 }, Border)
], ChartSettings.prototype, "border", void 0);
__decorate$3([
    Complex({}, Margin)
], ChartSettings.prototype, "margin", void 0);
__decorate$3([
    Complex({ border: { color: null, width: 0.5 }, background: 'transparent' }, ChartArea)
], ChartSettings.prototype, "chartArea", void 0);
__decorate$3([
    Property(null)
], ChartSettings.prototype, "background", void 0);
__decorate$3([
    Property('Material')
], ChartSettings.prototype, "theme", void 0);
__decorate$3([
    Property([])
], ChartSettings.prototype, "palettes", void 0);
__decorate$3([
    Complex({}, CrosshairSettings)
], ChartSettings.prototype, "crosshair", void 0);
__decorate$3([
    Complex({}, PivotTooltipSettings)
], ChartSettings.prototype, "tooltip", void 0);
__decorate$3([
    Complex({}, PivotZoomSettings)
], ChartSettings.prototype, "zoomSettings", void 0);
__decorate$3([
    Property()
], ChartSettings.prototype, "legendSettings", void 0);
__decorate$3([
    Property('None')
], ChartSettings.prototype, "selectionMode", void 0);
__decorate$3([
    Property(true)
], ChartSettings.prototype, "enableExport", void 0);
__decorate$3([
    Property(false)
], ChartSettings.prototype, "isMultiSelect", void 0);
__decorate$3([
    Collection([], Indexes)
], ChartSettings.prototype, "selectedDataIndexes", void 0);
__decorate$3([
    Property(true)
], ChartSettings.prototype, "enableAnimation", void 0);
__decorate$3([
    Property(true)
], ChartSettings.prototype, "useGroupingSeparator", void 0);
__decorate$3([
    Property(false)
], ChartSettings.prototype, "isTransposed", void 0);
__decorate$3([
    Property(1)
], ChartSettings.prototype, "tabIndex", void 0);
__decorate$3([
    Property(null)
], ChartSettings.prototype, "description", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "resized", void 0);
__decorate$3([
    Property(true)
], ChartSettings.prototype, "enableSideBySidePlacement", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "loaded", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "beforePrint", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "animationComplete", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "load", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "textRender", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "legendRender", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "seriesRender", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "pointRender", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "tooltipRender", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "axisLabelRender", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "chartMouseClick", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "chartMouseMove", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "pointMove", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "pointClick", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "chartMouseDown", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "chartMouseLeave", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "dragComplete", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "chartMouseUp", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "scrollStart", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "zoomComplete", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "scrollChanged", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "scrollEnd", void 0);
__decorate$3([
    Property(true)
], ChartSettings.prototype, "showMultiLevelLabels", void 0);

/**
 * This is a file to create MDX query for the provided OLAP datasource
 * @hidden
 */
/* tslint:disable:all */
/** @hidden */
class MDXQuery {
    static getCellSets(dataSourceSettings, olapEngine, refPaging, drillInfo, isQueryUpdate) {
        this.engine = olapEngine;
        this.isMondrian = olapEngine.isMondrian;
        this.isMeasureAvail = olapEngine.isMeasureAvail;
        this.isPaging = olapEngine.isPaging;
        this.pageSettings = olapEngine.pageSettings;
        this.rows = olapEngine.rows;
        this.columns = olapEngine.columns;
        this.values = olapEngine.values;
        this.filters = olapEngine.filters;
        this.allowLabelFilter = olapEngine.allowLabelFilter;
        this.allowValueFilter = olapEngine.allowValueFilter;
        this.valueSortSettings = dataSourceSettings.valueSortSettings ? dataSourceSettings.valueSortSettings : undefined;
        this.drilledMembers = olapEngine.updateDrilledItems(dataSourceSettings.drilledMembers);
        this.calculatedFieldSettings = olapEngine.calculatedFieldSettings;
        this.valueAxis = dataSourceSettings.valueAxis === 'row' ? 'rows' : 'columns';
        if (drillInfo) {
            drillInfo.axis = drillInfo.axis === 'row' ? 'rows' : 'columns';
        }
        this.filterMembers = extend({}, olapEngine.filterMembers, null, true);
        this.fieldDataObj = olapEngine.fieldListObj;
        this.fieldList = olapEngine.fieldList;
        this.cellSetInfo = '\nDIMENSION PROPERTIES PARENT_UNIQUE_NAME, HIERARCHY_UNIQUE_NAME, CHILDREN_CARDINALITY, MEMBER_TYPE, MEMBER_VALUE';
        let measureQuery = this.getMeasuresQuery(this.values);
        let rowQuery = this.getDimensionsQuery(this.rows, measureQuery, 'rows', drillInfo).replace(/\&/g, '&amp;');
        let columnQuery = this.getDimensionsQuery(this.columns, measureQuery, 'columns', drillInfo).replace(/\&/g, '&amp;');
        if (this.isPaging && refPaging && this.pageSettings !== undefined) {
            let pagingQuery = this.getPagingQuery(rowQuery, columnQuery);
            rowQuery = pagingQuery.rowQuery;
            columnQuery = pagingQuery.columnQuery;
        }
        else if (this.isPaging && !refPaging && this.pageSettings !== undefined) {
            let pagingQuery = this.getPagingCountQuery(rowQuery, columnQuery);
            rowQuery = pagingQuery.rowQuery;
            columnQuery = pagingQuery.columnQuery;
        }
        rowQuery = (rowQuery.length > 0 ? rowQuery + (this.isPaging && !refPaging ? '' : this.cellSetInfo + ' ON ROWS') : '');
        columnQuery = (columnQuery.length > 0 ? columnQuery + (this.isPaging && !refPaging ? '' : this.cellSetInfo + ' ON COLUMNS') : '');
        let slicerQuery = this.getSlicersQuery(this.filters, 'filters').replace(/\&/g, '&amp;');
        let filterQuery = this.getfilterQuery(this.filterMembers, dataSourceSettings.cube).replace(/\&/g, '&amp;').replace(/\>/g, '&gt;').replace(/\</g, '&lt;');
        let caclQuery = this.getCalculatedFieldQuery(this.calculatedFieldSettings).replace(/\&/g, '&amp;');
        let query = this.frameMDXQuery(rowQuery, columnQuery, slicerQuery, filterQuery, caclQuery, refPaging);
        let args = {
            catalog: dataSourceSettings.catalog,
            cube: dataSourceSettings.cube,
            url: dataSourceSettings.url,
            request: query,
            LCID: dataSourceSettings.localeIdentifier.toString()
        };
        olapEngine.mdxQuery = query.replace(/\&amp;/g, '&').replace(/\&gt;/g, '>').replace(/\&lt;/g, '<').replace(/%280/g, '\"');
        // console.log(olapEngine.mdxQuery);
        if (drillInfo) {
            drillInfo.axis = drillInfo.axis === 'rows' ? 'row' : 'column';
        }
        if (!isQueryUpdate) {
            this.getTableCellData(args, (this.isPaging && !refPaging ? this.engine.generatePagingData.bind(this.engine) : this.engine.generateEngine.bind(this.engine)), drillInfo ? { action: drillInfo.action, drillInfo: drillInfo } : { dataSourceSettings: dataSourceSettings, action: 'loadTableElements' });
        }
    }
    static getTableCellData(args, successMethod, customArgs) {
        let connectionString = this.engine.getConnectionInfo(args.url, args.LCID);
        let soapMessage = '<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"> <Header></Header> <Body> <Execute xmlns="urn:schemas-microsoft-com:xml-analysis"> <Command> <Statement>' +
            args.request + '</Statement> </Command> <Properties> <PropertyList> <Catalog>' +
            args.catalog + '</Catalog> <LocaleIdentifier>' + connectionString.LCID +
            '</LocaleIdentifier> </PropertyList> </Properties></Execute> </Body> </Envelope>';
        this.engine.doAjaxPost('POST', connectionString.url, soapMessage, successMethod, customArgs);
    }
    static frameMDXQuery(rowQuery, columnQuery, slicerQuery, filterQuery, caclQuery, refPaging) {
        let query = ((this.isPaging && !refPaging) ? caclQuery !== '' ? '' : '\nWITH' : '\nSelect ');
        if (columnQuery.length > 0) {
            query = query + columnQuery;
        }
        if (rowQuery.length > 0) {
            query = query + (columnQuery.length > 0 ? this.isPaging && !refPaging ? '' : ', ' : '') + rowQuery;
        }
        query = caclQuery + query + (this.isPaging && !refPaging ? '\nMEMBER [Measures].[3d268ce0-664d-4092-b9cb-fece97175006] AS Count([e16a30d0-2174-4874-8dae-a5085a75a3e2]) ' +
            'MEMBER [Measures].[8d7fe8c1-f09f-410e-b9ba-eaab75a1fc3e] AS Count ([d1876d2b-e50e-4547-85fe-5b8ed9d629de])' +
            '\nSELECT { [Measures].[3d268ce0-664d-4092-b9cb-fece97175006] , [Measures].[8d7fe8c1-f09f-410e-b9ba-eaab75a1fc3e] } ON AXIS(0)' : '') +
            filterQuery + slicerQuery + '\nCELL PROPERTIES VALUE, FORMAT_STRING, FORMATTED_VALUE\n';
        return query;
    }
    static getPagingQuery(rowQuery, columnQuery) {
        // let colCurrentPage: number = (Math.ceil(this.engine.columnCount / this.pageSettings.columnSize) < this.pageSettings.columnCurrentPage || this.pageSettings.columnCurrentPage === 0) ? ((Math.ceil(this.engine.columnCount / this.pageSettings.columnSize) < this.pageSettings.columnCurrentPage && this.engine.columnCount > 0) ? Math.ceil(this.engine.columnCount / this.pageSettings.columnSize) : this.pageSettings.columnCurrentPage) : this.pageSettings.columnCurrentPage;
        // let rowCurrentPage: number = (Math.ceil(this.engine.rowCount / this.pageSettings.rowSize) < this.pageSettings.rowCurrentPage || this.pageSettings.rowCurrentPage === 0) ? ((Math.ceil(this.engine.rowCount / this.pageSettings.rowSize) < this.pageSettings.rowCurrentPage && this.engine.rowCount > 0) ? Math.ceil(this.engine.rowCount / this.pageSettings.rowSize) : this.pageSettings.rowSize) : this.pageSettings.rowCurrentPage;
        rowQuery = rowQuery.replace('NON EMPTY ( ', '').slice(0, -1);
        columnQuery = columnQuery.replace('NON EMPTY ( ', '').slice(0, -1);
        let rowQueryCpy = rowQuery;
        // let axisQuery: pagingQuery = {
        //     rowQuery: rowQuery !== '' ? ('\nSUBSET ({ ' + (this.isMondrian ? '' : 'NONEMPTY') + ' (' + rowQuery + (!this.isMondrian && columnQuery !== '' ? ',' + columnQuery : '') + ')},' + (((rowCurrentPage === 0 ? 1 : rowCurrentPage) - 1) * (this.pageSettings.rowSize)) + ',' + this.pageSettings.rowSize + ')') : '',
        //     columnQuery: columnQuery !== '' ? ('\nSUBSET ({ ' + (this.isMondrian ? '' : 'NONEMPTY') + ' (' + columnQuery + (!this.isMondrian && rowQueryCpy !== '' ? ',' + rowQueryCpy : '') + ')},' + (((colCurrentPage === 0 ? 1 : colCurrentPage) - 1) * (this.pageSettings.columnSize)) + ',' + this.pageSettings.columnSize + ')') : ''
        // }
        let calRowPage = (this.pageSettings.rowCurrentPage - 1) * this.pageSettings.rowSize;
        let calColPage = (this.pageSettings.columnCurrentPage - 1) * this.pageSettings.columnSize;
        let calRowSize = this.pageSettings.rowSize * 3;
        let calColumnSize = this.pageSettings.columnSize * 3;
        calRowPage = (this.engine.rowCount < (calRowPage + calRowSize)) ?
            (this.engine.rowCount > calRowSize ? (this.engine.rowCount - calRowSize) : 0) : calRowPage;
        this.engine.pageRowStartPos = calRowPage;
        calColPage = (this.engine.columnCount < (calColPage + calColumnSize)) ?
            (this.engine.columnCount > calColumnSize ? (this.engine.columnCount - calColumnSize) : 0) : calColPage;
        this.engine.pageColStartPos = calColPage;
        let axisQuery = {
            rowQuery: rowQuery !== '' ? ('\nSUBSET ({ ' + (this.isMondrian ? '' : 'NONEMPTY') + ' (' + rowQuery + (!this.isMondrian && columnQuery !== '' ? ',' + columnQuery : '') + ')},' + (calRowPage) + ',' + calRowSize + ')') : '',
            columnQuery: columnQuery !== '' ? ('\nSUBSET ({ ' + (this.isMondrian ? '' : 'NONEMPTY') + ' (' + columnQuery + (!this.isMondrian && rowQueryCpy !== '' ? ',' + rowQueryCpy : '') + ')},' + (calColPage) + ',' + calColumnSize + ')') : ''
        };
        return axisQuery;
    }
    static getPagingCountQuery(rowQuery, columnQuery) {
        rowQuery = rowQuery.replace('NON EMPTY ( ', '').slice(0, -1);
        columnQuery = columnQuery.replace('NON EMPTY ( ', '').slice(0, -1);
        let rowQueryCpy = rowQuery;
        let axisQuery = {
            rowQuery: rowQuery !== '' ? ('\SET [d1876d2b-e50e-4547-85fe-5b8ed9d629de] as ' + (this.isMondrian ? '' : 'NONEMPTY') + ' (' + rowQuery + (!this.isMondrian && columnQuery !== '' ? ',' + columnQuery : '') + ')\n') : '',
            columnQuery: columnQuery !== '' ? ('\nSET [e16a30d0-2174-4874-8dae-a5085a75a3e2] as ' + (this.isMondrian ? '' : 'NONEMPTY') + ' (' + columnQuery + (!this.isMondrian && rowQueryCpy !== '' ? ',' + rowQueryCpy : '') + ')\n') : ''
        };
        return axisQuery;
    }
    static getDimensionsQuery(dimensions, measureQuery, axis, drillInfo) {
        let query = '';
        if (dimensions.length > 0) {
            query = '\nNON EMPTY ( ' + (this.drilledMembers.length > 0 ? 'HIERARCHIZE ({' : '');
            let i = 0;
            while (i < dimensions.length) {
                let hierarchy = '';
                if (i === 0) {
                    if (dimensions[i].name.toLowerCase() === '[measures]') {
                        if (measureQuery !== '') {
                            query = query + measureQuery;
                        }
                    }
                    else {
                        hierarchy = '({' + this.getDimensionQuery(dimensions[i], axis) + '})';
                        query = query + hierarchy;
                    }
                }
                else {
                    if (dimensions[i].name.toLowerCase() === '[measures]') {
                        if (measureQuery !== '') {
                            query = query + ' * ' + measureQuery;
                        }
                    }
                    else {
                        hierarchy = '({' + this.getDimensionQuery(dimensions[i], axis) + '})';
                        query = query + ' * ' + hierarchy;
                    }
                }
                i++;
            }
            // if (!this.isMeasureAvail && measureQuery !== '' && this.valueAxis === axis) {
            //     query = query + ' * ' + measureQuery;
            // }
            let drillQueryObj = this.getDrillQuery(dimensions, measureQuery, axis, drillInfo);
            query = (drillInfo && drillInfo.axis === axis ? '\nNON EMPTY ( ' + (this.drilledMembers.length > 0 ? 'HIERARCHIZE ({' : '') + drillQueryObj.query : query + (drillQueryObj.query !== '' ? ',' : '') + drillQueryObj.query);
            query = (this.valueAxis !== axis ? this.updateValueSortQuery(query, this.valueSortSettings) : query) +
                (this.drilledMembers.length > 0 ? '})' : '') + (this.isPaging && axis === 'columns' && drillQueryObj.query !== '' ? '-' + drillQueryObj.collection.join('-') : '') + ')';
        }
        // else if (!this.isMeasureAvail && measureQuery !== '' && this.valueAxis === axis) {
        //     query = 'NON EMPTY (' + (this.drilledMembers.length > 0 ? 'HIERARCHIZE({' : '') + measureQuery;
        //     query = (this.valueAxis !== axis ? this.updateValueSortQuery(query, this.valueSortSettings) : query) +
        //         (this.drilledMembers.length > 0 ? '})' : '') + ') ' + this.cellSetInfo + ' ON ' + axis.toUpperCase();
        // }
        return query;
    }
    static getDrillQuery(dimensions, measureQuery, axis, drillInfo) {
        let query = '';
        let rawDrillQuery = [];
        let drilledMembers = [];
        let isOnDemandDrill = false;
        let onDemandDrillQuery = '';
        if (drillInfo && drillInfo.axis === axis && drillInfo.action.toLowerCase() === 'down') {
            isOnDemandDrill = true;
            drilledMembers = [{ name: drillInfo.fieldName, items: [drillInfo.memberName], delimiter: '~~' }];
        }
        else {
            drilledMembers = this.drilledMembers;
        }
        for (let field of drilledMembers) {
            for (let item of field.items) {
                let drillQuery = [];
                let rawQuery = [];
                let i = 0;
                let drillInfo = item.split(field.delimiter ? field.delimiter : '~~');
                while (i < dimensions.length) {
                    if (drillInfo[i] && drillInfo[i].indexOf(dimensions[i].name) !== -1) {
                        if (drillInfo[drillInfo.length - 1].indexOf(dimensions[i].name) !== -1) {
                            if (isOnDemandDrill) {
                                onDemandDrillQuery = onDemandDrillQuery + (onDemandDrillQuery !== '' ? ' * ' : '') + '({' + drillInfo[i] + '.CHILDREN})';
                            }
                            else {
                                drillQuery.push('(' + drillInfo[i] + '.CHILDREN)');
                                rawQuery.push('(' + drillInfo[i] + ')');
                            }
                        }
                        else {
                            if (drillInfo[i].toLowerCase() === '[measures]' && measureQuery !== '') {
                                if (isOnDemandDrill) {
                                    onDemandDrillQuery = onDemandDrillQuery + (onDemandDrillQuery !== '' ? ' * ' : '') + '(' + measureQuery + ')';
                                }
                                else {
                                    drillQuery.push('(' + measureQuery + ')');
                                    rawQuery.push('(' + measureQuery + ')');
                                }
                            }
                            else if (drillInfo[i].toLowerCase().indexOf('[measures]') !== -1) {
                                if (isOnDemandDrill) {
                                    onDemandDrillQuery = onDemandDrillQuery + (onDemandDrillQuery !== '' ? ' * ' : '') + '({' + drillInfo[i] + '})';
                                }
                                else {
                                    drillQuery.push('({' + drillInfo[i] + '})');
                                    rawQuery.push('({' + drillInfo[i] + '})');
                                }
                            }
                            else {
                                if (isOnDemandDrill) {
                                    onDemandDrillQuery = onDemandDrillQuery + (onDemandDrillQuery !== '' ? ' * ' : '') + '({' + drillInfo[i] + '})';
                                }
                                else {
                                    drillQuery.push('(' + drillInfo[i] + ')');
                                    rawQuery.push('(' + drillInfo[i] + ')');
                                }
                            }
                        }
                    }
                    else if (!drillInfo[i] && dimensions[i]) {
                        if (dimensions[i].name.toLowerCase() === '[measures]' && measureQuery !== '') {
                            if (isOnDemandDrill) {
                                onDemandDrillQuery = onDemandDrillQuery + (onDemandDrillQuery !== '' ? ' * ' : '') + '(' + measureQuery + ')';
                            }
                            else {
                                drillQuery.push('(' + measureQuery + ')');
                                rawQuery.push('(' + measureQuery + ')');
                            }
                        }
                        else {
                            if (isOnDemandDrill) {
                                onDemandDrillQuery = onDemandDrillQuery + (onDemandDrillQuery !== '' ? ' * ' : '') + '({' + this.getDimensionQuery(dimensions[i], axis) + '})';
                            }
                            else {
                                drillQuery.push('(' + this.getDimensionQuery(dimensions[i], axis) + ')');
                                rawQuery.push('(' + this.getDimensionQuery(dimensions[i], axis) + ')');
                            }
                        }
                    }
                    else {
                        drillQuery = [];
                        break;
                    }
                    i++;
                }
                if (drillQuery.length > 0 && drillQuery.length < drillInfo.length) {
                    drillQuery = [];
                    rawQuery = [];
                }
                // query = query + (query !== '' && drillQuery.length > 0 ? ',' : '') + (drillQuery.length > 0 ? '(' + drillQuery.toString().replace(/\&/g, "&amp;") + ')' : '');
                query = query + (query !== '' && drillQuery.length > 0 ? ',' : '') + (drillQuery.length > 0 ? '(' + drillQuery.toString() + ')' : '');
                if (rawQuery.length > 0) {
                    rawDrillQuery.push(('(' + rawQuery.toString() + ')'));
                }
            }
        }
        // return (isOnDemandDrill ? onDemandDrillQuery.replace(/\&/g, "&amp;") : query);
        let queryCollection = {
            query: (isOnDemandDrill ? onDemandDrillQuery : query),
            collection: (isOnDemandDrill ? [onDemandDrillQuery] : rawDrillQuery)
        };
        return queryCollection;
    }
    static updateValueSortQuery(query, valueSortSettings) {
        if (valueSortSettings && valueSortSettings.measure && valueSortSettings.measure !== '') {
            let heirarchize = (this.drilledMembers.length > 0 ? 'HIERARCHIZE ({' : '');
            let measure = (this.fieldList[valueSortSettings.measure].isCalculatedField ?
                this.fieldList[valueSortSettings.measure].tag : valueSortSettings.measure);
            switch (valueSortSettings.sortOrder) {
                case 'Ascending':
                    query = query.replace('NON EMPTY ( ' + heirarchize, 'NON EMPTY ( ' + heirarchize + ' ORDER ({');
                    query = query + '},(' + measure + '), ASC)';
                    // query = query + '},(' + valueSortSettings.measure + '), ' +
                    //     (valueSortSettings.preserveHierarchy ? 'BASC' : 'ASC') + ')';
                    break;
                case 'Descending':
                    query = query.replace('NON EMPTY ( ' + heirarchize, 'NON EMPTY ( ' + heirarchize + ' ORDER ({');
                    query = query + '},(' + measure + '), DESC)';
                    // query = query + '},(' + valueSortSettings.measure + '), ' +
                    //     (valueSortSettings.preserveHierarchy ? 'BDESC' : 'DESC') + ')';
                    break;
            }
        }
        return query;
    }
    static getSlicersQuery(slicers, axis) {
        let query = '';
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns);
        if (slicers.length > 0) {
            let i = 0;
            while (i < slicers.length) {
                let isCol = dataFields.filter((field) => {
                    let colUqName = this.getDimensionUniqueName(field.name);
                    let slicerUqName = this.getDimensionUniqueName(slicers[i].name);
                    let isMatch = false;
                    isMatch = colUqName === slicerUqName &&
                        !(this.isMondrian && slicerUqName === '' && colUqName === '');
                    return (isMatch);
                }).length > 0;
                if (!isCol) {
                    if (slicers[i].name !== undefined && !this.filterMembers[slicers[i].name]) {
                        query = query + (query !== '' ? ' * ' : '') + '{' + this.getDimensionQuery(slicers[i], axis) + '}';
                    }
                    else if (this.filterMembers[slicers[i].name]) {
                        query = query + (query !== '' ? ' * ' : '') + '{' + (this.filterMembers[slicers[i].name].toString()) + '}';
                    }
                }
                i++;
            }
            query = '\nWHERE (' + query.replace(/DrilldownLevel/g, '') + ')';
        }
        return query;
    }
    static getDimensionQuery(dimension, axis) {
        let query = '';
        let name = dimension.isCalculatedField ? this.fieldList[dimension.name].tag : dimension.name;
        let hasAllMember = this.fieldList[dimension.name].hasAllMember;
        if (!hasAllMember && !dimension.isNamedSet && !dimension.isCalculatedField) {
            query = '((' + name + ').levels(0).AllMembers)';
        }
        else {
            query = (dimension.isNamedSet ? '{' + name + '}' : this.isPaging ? name + '.CHILDREN' :
                'DrilldownLevel({' + name + '}' + ((axis === 'rows' || axis === 'columns') ? ',,,INCLUDE_CALC_MEMBERS' : '') + ')');
        }
        return query;
    }
    static getDimensionUniqueName(headerText) {
        let hierarchyNode = this.fieldDataObj.hierarchy;
        let curElement = [];
        if (hierarchyNode) {
            // let curElement: IOlapField[] = hierarchyNode.filter((item: IOlapField) => {
            //     return (item.id.toLowerCase() === headerText.toLowerCase());
            // });
            for (let item of hierarchyNode) {
                if (item.id.toLowerCase() === headerText.toLowerCase()) {
                    curElement.push(item);
                }
            }
            return (curElement.length > 0 ? curElement[0].pid : '');
        }
        else {
            return headerText.split('.')[0];
        }
    }
    static getMeasuresQuery(measures) {
        let query = '';
        if (measures.length > 0) {
            query = '{{';
            let values = '';
            for (let measure of measures) {
                let name = (measure.isCalculatedField ? this.fieldList[measure.name].tag : measure.name);
                if (values.length > 0) {
                    values = values + ', ' + name;
                }
                else {
                    values = name;
                }
            }
            query = query + values + '}}';
        }
        return query;
    }
    static getfilterQuery(filters, cube) {
        let query = '\nFROM [' + cube + ']';
        let filterQuery = '\nFROM( SELECT (';
        let advancedFilters = [];
        let advancedFilterQuery = [];
        let rowFilter = [];
        let columnFilter = [];
        for (let field of this.rows) {
            if (filters[field.name] && filters[field.name].length > 0) {
                if (typeof filters[field.name][0] === 'string') {
                    rowFilter.push(filters[field.name]);
                }
                else {
                    filters[field.name][1] = filters[field.name][0].type;
                    advancedFilters.push(filters[field.name]);
                    delete filters[field.name];
                }
            }
        }
        for (let field of this.columns) {
            if (filters[field.name] && filters[field.name].length > 0) {
                if (typeof filters[field.name][0] === 'string') {
                    columnFilter.push(filters[field.name]);
                }
                else {
                    /* tslint:disable */
                    let filter = filters[field.name];
                    filter[1] = filter[0].type;
                    advancedFilters.push(filters[field.name]);
                    delete filters[field.name];
                }
            }
        }
        for (let field of this.filters) {
            let isFound = false;
            for (let column of this.columns) {
                if (this.getDimensionUniqueName(column.name) === this.getDimensionUniqueName(field.name)) {
                    if (filters[field.name]) {
                        columnFilter.push(filters[field.name]);
                        isFound = true;
                    }
                }
            }
            if (isFound) {
                for (let row of this.rows) {
                    if (this.getDimensionUniqueName(row.name) === this.getDimensionUniqueName(field.name)) {
                        if (filters[field.name]) {
                            rowFilter.push(filters[field.name]);
                        }
                    }
                }
            }
        }
        if ((this.allowLabelFilter || this.allowValueFilter) && advancedFilters.length > 0) {
            let axes = ['Value', 'Label'];
            for (let axis of axes) {
                for (let filterItems of advancedFilters) {
                    if (filterItems && filterItems.length === 2 &&
                        typeof filterItems[1] === 'string' && filterItems[1] === axis) {
                        advancedFilterQuery.push(this.getAdvancedFilterQuery(filterItems[0], filterQuery, 'COLUMNS'));
                    }
                }
            }
        }
        for (let i = 0, cnt = columnFilter.length; i < cnt; i++) {
            filterQuery = i === 0 ? filterQuery + '{' + columnFilter[i].toString() + '}' : filterQuery + ',{' + columnFilter[i].toString() + '}';
        }
        if (columnFilter.length > 0) {
            filterQuery = (rowFilter.length > 0) ? filterQuery + ' ) ON COLUMNS ' + ',(' : filterQuery + ' ) ON COLUMNS';
        }
        for (let i = 0, cnt = rowFilter.length; i < cnt; i++) {
            filterQuery = (i > 0) ? filterQuery + ',{' + rowFilter[i].toString() + '}' : filterQuery + '{' + rowFilter[i].toString() + '}';
        }
        filterQuery = (columnFilter.length > 0 && rowFilter.length > 0) ?
            filterQuery = filterQuery + ') ON ROWS ' : (columnFilter.length == 0 && rowFilter.length > 0) ?
            filterQuery + ') ON COLUMNS ' : filterQuery;
        let updatedFilterQuery = '';
        if (advancedFilterQuery.length > 0) {
            updatedFilterQuery = advancedFilterQuery.join(' ') + ' ' +
                ((columnFilter.length > 0 || rowFilter.length > 0) ? filterQuery : '') + ' '
                + query + Array(advancedFilterQuery.length + 1 +
                ((columnFilter.length > 0 || rowFilter.length > 0) ? 1 : 0)).join(')');
        }
        query = (columnFilter.length === 0 && rowFilter.length === 0) ? query : filterQuery + query + ')';
        return (updatedFilterQuery.length > 0) ? updatedFilterQuery : query;
    }
    static getAdvancedFilterQuery(filterItem, query, currentAxis) {
        let filterQuery = '\nFROM (SELECT Filter(' + filterItem.selectedField + '.AllMembers, ' +
            this.getAdvancedFilterCondtions(filterItem.name, filterItem.condition, filterItem.value1, filterItem.value2, filterItem.type, filterItem.measure) +
            ")) on " + currentAxis;
        return filterQuery;
    }
    static getAdvancedFilterCondtions(fieldName, filterOperator, value1, value2, filterType, measures) {
        let advancedFilterQuery = '';
        switch (filterOperator) {
            case 'Equals':
                advancedFilterQuery = '(' + (filterType !== 'Value' ? (fieldName + '.CurrentMember.member_caption =\"' + value1 + '\"') : (measures + ' = ' + value1));
                break;
            case 'DoesNotEquals':
                advancedFilterQuery = '(' + (filterType != 'Value' ? (fieldName + '.CurrentMember.member_caption <>\"' + value1 + '\"') : (measures + ' <>' + value1));
                break;
            case 'Contains':
                advancedFilterQuery = '( InStr (1,' + fieldName + '.CurrentMember.member_caption,\"' + value1 + '\") >0';
                break;
            case 'DoesNotContains':
                advancedFilterQuery = '( InStr (1,' + fieldName + '.CurrentMember.member_caption,\"' + value1 + '\")=0';
                break;
            case 'BeginWith':
                advancedFilterQuery = '( Left (' + fieldName + '.CurrentMember.member_caption,' + value1.length + ')=\"' + value1 + '\"';
                break;
            case 'DoesNotBeginWith':
                advancedFilterQuery = '( Left (' + fieldName + '.CurrentMember.member_caption,' + value1.length + ') <>\"' + value1 + '\"';
                break;
            case 'EndsWith':
                advancedFilterQuery = '( Right (' + fieldName + '.CurrentMember.member_caption,' + value1.length + ')=\"' + value1 + '\"';
                break;
            case 'DoesNotEndsWith':
                advancedFilterQuery = '( Right (' + fieldName + '.CurrentMember.member_caption,' + value1.length + ') <>\"' + value1 + '\"';
                break;
            case 'GreaterThan':
                advancedFilterQuery = '(' + (filterType != 'Value' ? (fieldName + '.CurrentMember.member_caption >\"' + value1 + '\"') : (measures + ' >' + value1 + ''));
                break;
            case 'GreaterThanOrEqualTo':
                advancedFilterQuery = '(' + (filterType != 'Value' ? (fieldName + '.CurrentMember.member_caption >=\"' + value1 + '\"') : (measures + ' >=' + value1 + ''));
                break;
            case 'LessThan':
                advancedFilterQuery = '(' + (filterType != 'Value' ? (fieldName + '.CurrentMember.member_caption <\"' + value1 + '\"') : (measures + ' <' + value1 + ''));
                break;
            case 'LessThanOrEqualTo':
                advancedFilterQuery = '(' + (filterType != 'Value' ? (fieldName + '.CurrentMember.member_caption <=\"' + value1 + '\"') : (measures + ' <=' + value1 + ''));
                break;
            case 'Between':
                advancedFilterQuery = '(' + (filterType != 'Value' ? (fieldName + '.CurrentMember.member_caption >=\"' + value1 + '\"AND ' + fieldName + '.CurrentMember.member_caption <=\"' + value2 + '\"') : (measures + ' >=' + value1 + ' AND ' + measures + ' <=' + value2));
                break;
            case 'NotBetween':
                advancedFilterQuery = '(' + (filterType != 'Value' ? (fieldName + '.CurrentMember.member_caption >=\"' + value1 + '\"OR ' + fieldName + '.CurrentMember.member_caption <=\"' + value2 + '\"') : (measures + ' >=' + value1 + ' OR ' + measures + ' <=' + value2));
                break;
            default:
                advancedFilterQuery = '( InStr (1,' + fieldName + '.CurrentMember.member_caption,\"' + value1 + '\") >0';
                break;
        }
        return advancedFilterQuery;
    }
    static getCalculatedFieldQuery(calcMembers) {
        let calcQuery = '';
        if (calcMembers.length > 0) {
            calcQuery = '\nWITH';
            for (let member of calcMembers) {
                let prefixName = (member.formula.indexOf('Measure') > -1 ? '[Measures].' : member.hierarchyUniqueName + '.');
                let aliasName = prefixName + '[' + member.name + ']';
                let formatString = (!isNullOrUndefined(member.formatString) ? member.formatString : null);
                calcQuery += ('\nMEMBER ' + aliasName + 'as (' + member.formula + ') ' + (!isNullOrUndefined(formatString) ? ', FORMAT_STRING =\"' + formatString.trim() + '\"' : ''));
            }
        }
        return calcQuery;
    }
}

/**
 * OlapEngine is used to manipulate the olap or Multi-Dimensional data as pivoting values.
 */
/** @hidden */
class OlapEngine {
    constructor() {
        /** @hidden */
        this.fieldList = {};
        /** @hidden */
        this.columnCount = 0;
        /** @hidden */
        this.rowCount = 0;
        /** @hidden */
        this.colFirstLvl = 0;
        /** @hidden */
        this.rowFirstLvl = 0;
        /** @hidden */
        this.pageColStartPos = 0;
        /** @hidden */
        this.enableSort = false;
        /** @hidden */
        this.enableValueSorting = false;
        /** @hidden */
        this.dataFields = {};
        /** @hidden */
        this.formatFields = {};
        /** @hidden */
        this.filterMembers = {};
        /** @hidden */
        this.drilledSets = {};
        /** @hidden */
        this.aggregatedValueMatrix = [];
        /* tslint:disable-next-line:max-line-length */
        this.customRegex = /^(('[^']+'|''|[^*#@0,.])*)(\*.)?((([0#,]*[0,]*[0#]*)(\.[0#]*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;
        this.formatRegex = /(^[ncpae]{1})([0-1]?[0-9]|20)?$/i;
        /** @hidden */
        this.pivotValues = [];
        /** @hidden */
        this.valueContent = [];
        /** @hidden */
        this.headerContent = [];
        /** @hidden */
        this.rowStartPos = 0;
        /** @hidden */
        this.pageRowStartPos = 0;
        /** @hidden */
        this.tupColumnInfo = [];
        /** @hidden */
        this.tupRowInfo = [];
        /** @hidden */
        this.gridJSON = '';
        /** @hidden */
        this.namedSetsPosition = {};
        this.colDepth = 0;
        this.totalCollection = [];
        this.parentObjCollection = {};
        this.curDrillEndPos = -1;
        this.headerGrouping = {};
        this.lastLevel = [];
        this.showRowSubTotals = true;
        this.showColumnSubTotals = true;
        this.hideRowTotalsObject = {};
        this.hideColumnTotalsObject = {};
        this.sortObject = {};
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    renderEngine(dataSourceSettings, customProperties) {
        this.isEmptyData = false;
        this.mdxQuery = '';
        this.isMeasureAvail = false;
        this.allowMemberFilter = false;
        this.allowLabelFilter = false;
        this.allowValueFilter = false;
        this.isMondrian = false;
        this.aggregatedValueMatrix = [];
        this.measureReportItems = [];
        this.calcChildMembers = [];
        this.selectedItems = [];
        this.savedFieldList = undefined;
        this.savedFieldListData = undefined;
        this.formatFields = {};
        this.filterMembers = {};
        this.dataFields = {};
        this.valueAxis = '';
        this.columnCount = 0;
        this.rowCount = 0;
        this.colFirstLvl = 0;
        this.rowFirstLvl = 0;
        this.pageColStartPos = 0;
        this.enableValueSorting = false;
        this.sortObject = {};
        this.globalize = new Internationalization();
        /* tslint:disable */
        this.locale = this.globalize.getCulture();
        /* tslint:enable */
        this.localeObj = customProperties ? customProperties.localeObj : undefined;
        this.enableValueSorting = customProperties ? customProperties.enableValueSorting : false;
        if (dataSourceSettings.url) {
            // this.isMondrian = (dataSourceSettings.providerType === 'mondrian');
            this.dataSourceSettings = dataSourceSettings;
            this.valueAxis = dataSourceSettings.valueAxis === 'row' ? 'row' : 'column';
            this.getAxisFields();
            this.formats = dataSourceSettings.formatSettings ? dataSourceSettings.formatSettings : [];
            this.enableSort = dataSourceSettings.enableSorting === undefined ? true : dataSourceSettings.enableSorting;
            this.valueSortSettings = dataSourceSettings.valueSortSettings ? dataSourceSettings.valueSortSettings : undefined;
            this.filterSettings = dataSourceSettings.filterSettings ? dataSourceSettings.filterSettings : [];
            this.sortSettings = dataSourceSettings.sortSettings ? dataSourceSettings.sortSettings : [];
            this.allowMemberFilter = dataSourceSettings.allowMemberFilter ? true : false;
            this.allowLabelFilter = dataSourceSettings.allowLabelFilter ? true : false;
            this.allowValueFilter = dataSourceSettings.allowValueFilter ? true : false;
            this.drilledMembers = dataSourceSettings.drilledMembers ? this.updateDrilledItems(dataSourceSettings.drilledMembers) : [];
            this.calculatedFieldSettings = dataSourceSettings.calculatedFieldSettings ? dataSourceSettings.calculatedFieldSettings : [];
            this.emptyCellTextContent = dataSourceSettings.emptyCellsTextContent ? dataSourceSettings.emptyCellsTextContent : '';
            this.pageSettings = customProperties ? (customProperties.pageSettings ? customProperties.pageSettings : this.pageSettings)
                : undefined;
            this.isPaging = this.pageSettings ? true : false;
            this.frameSortObject();
            this.getFormattedFields(this.formats);
            this.savedFieldList = customProperties ? customProperties.savedFieldList : undefined;
            this.savedFieldListData = customProperties ? customProperties.savedFieldListData : undefined;
            this.fieldListData = [];
            this.fieldListObj = {};
            this.setNamedSetsPosition();
            if (!(this.savedFieldList && this.savedFieldListData)) {
                this.getFieldList(dataSourceSettings);
            }
            else {
                this.updateFieldlist(true);
            }
            this.loadCalculatedMemberElements(this.calculatedFieldSettings);
            this.measureReportItems = [];
            // this.updateAllMembers(dataSourceSettings, this.filters);
            this.updateFilterItems(this.filterSettings);
            this.generateGridData(dataSourceSettings);
        }
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    generateGridData(dataSourceSettings, action) {
        let refPaging = (action && action === 'navPaging' &&
            this.isPaging && this.pageSettings !== undefined ? true : false);
        if (this.rows.length > 0 || this.columns.length > 0 || this.values.length > 0 || this.filters.length > 0) {
            MDXQuery.getCellSets(dataSourceSettings, this, refPaging);
        }
        else {
            MDXQuery.getCellSets(dataSourceSettings, this, true, undefined, true);
            this.generateEngine(undefined, undefined, { dataSourceSettings: dataSourceSettings, action: 'loadTableElements' });
        }
    }
    generatePagingData(xmlDoc, request, customArgs) {
        let xmlaCellSet = [].slice.call(xmlDoc.querySelectorAll('Axes, CellData'));
        // this.rowCount =
        //     (xmlaCellSet.length > 0 && [].slice.call(xmlaCellSet[0].querySelectorAll('Axis[name|="Axis1"] Tuple')).length > 0 ?
        //         [].slice.call(xmlaCellSet[0].querySelectorAll('Axis[name|="Axis1"] Tuple')).length : 0);
        // this.columnCount =
        //     (xmlaCellSet.length > 0 && [].slice.call(xmlaCellSet[0].querySelectorAll('Axis[name|="Axis0"] Tuple')).length > 0 ?
        //         [].slice.call(xmlaCellSet[0].querySelectorAll('Axis[name|="Axis0"] Tuple')).length : 0);
        let countCells = xmlaCellSet[1] ? xmlaCellSet[1].querySelectorAll('FmtValue') : null;
        if (countCells && countCells.length > 0) {
            this.columnCount = Number(countCells[0].textContent);
            this.rowCount = Number(countCells[1].textContent);
        }
        let dataSourceSettings = customArgs.dataSourceSettings;
        MDXQuery.getCellSets(dataSourceSettings, this, true);
    }
    scrollPage(direction, newPage, prevPage) {
        MDXQuery.getCellSets(this.dataSourceSettings, this, true);
    }
    generateEngine(xmlDoc, request, customArgs) {
        if (customArgs.action !== 'down') {
            this.pivotValues = [];
            this.valueContent = [];
            this.headerContent = [];
            this.colDepth = 0;
            this.tupColumnInfo = [];
            this.tupRowInfo = [];
            this.colMeasures = {};
            this.colMeasurePos = undefined;
            this.rowMeasurePos = undefined;
            this.rowStartPos = -1;
        }
        this.xmlDoc = xmlDoc ? xmlDoc.cloneNode(true) : undefined;
        this.request = request;
        this.customArgs = customArgs;
        this.totalCollection = [];
        this.parentObjCollection = {};
        this.curDrillEndPos = -1;
        this.onDemandDrillEngine = [];
        this.getSubTotalsVisibility();
        this.xmlaCellSet = xmlDoc ? xmlDoc.querySelectorAll('Axes, CellData') : undefined;
        let columnTuples = this.xmlaCellSet && this.xmlaCellSet.length > 0 ?
            [].slice.call(this.xmlaCellSet[0].querySelectorAll('Axis[name|="Axis0"] Tuple')) : [];
        let rowTuples = this.xmlaCellSet && this.xmlaCellSet.length > 0 ?
            [].slice.call(this.xmlaCellSet[0].querySelectorAll('Axis[name|="Axis1"] Tuple')) : [];
        let valCollection = this.xmlaCellSet && this.xmlaCellSet.length > 1 ?
            [].slice.call(this.xmlaCellSet[1].querySelectorAll('Cell')) : [];
        if (this.drilledMembers.length > 0) {
            // let st1: number = new Date().getTime();
            let measureInfo = this.getMeasureInfo();
            let orderedInfo;
            orderedInfo = this.frameMeasureOrder(measureInfo, 'column', columnTuples, valCollection, columnTuples.length);
            columnTuples = orderedInfo.orderedHeaderTuples;
            valCollection = orderedInfo.orderedValueTuples;
            orderedInfo = this.frameMeasureOrder(measureInfo, 'row', rowTuples, valCollection, columnTuples.length);
            rowTuples = orderedInfo.orderedHeaderTuples;
            valCollection = orderedInfo.orderedValueTuples;
            // let st2: number = (new Date().getTime() - st1) / 1000;
            // console.log('over-all:' + st2);
        }
        if (customArgs.action === 'down') {
            this.updateTupCollection(customArgs.drillInfo.axis === 'row' ? rowTuples.length : columnTuples.length);
        }
        if (customArgs.action === 'down' ? customArgs.drillInfo.axis === 'column' : true) {
            this.frameColumnHeader(columnTuples);
            if (!this.isPaging) {
                this.performColumnSorting();
            }
        }
        if (customArgs.action === 'down' ? customArgs.drillInfo.axis === 'row' : true) {
            this.frameRowHeader(rowTuples);
            if (!this.isPaging) {
                this.performRowSorting();
            }
        }
        this.frameValues(valCollection, columnTuples.length);
        this.performColumnSpanning();
        if (!this.isPaging && this.enableSort) {
            for (let i = 0; i < this.headerContent.length; i++) {
                this.headerContent[i] = this.pivotValues[i];
            }
        }
        this.isEngineUpdated = true;
        this.isEmptyData = columnTuples.length === 0;
        //this.append(columnTuples.length);
    }
    getSubTotalsVisibility() {
        this.showRowSubTotals = this.dataSourceSettings.showRowSubTotals && this.dataSourceSettings.showSubTotals;
        this.showColumnSubTotals = this.dataSourceSettings.showColumnSubTotals && this.dataSourceSettings.showSubTotals;
        this.hideRowTotalsObject = {};
        this.hideColumnTotalsObject = {};
        let axisCount = 1;
        do {
            if (axisCount === 1) {
                if (this.showColumnSubTotals) {
                    for (let cCnt = 0; cCnt < this.dataSourceSettings.columns.length; cCnt++) {
                        if (this.dataSourceSettings.columns[cCnt].showSubTotals === false) {
                            this.hideColumnTotalsObject[this.dataSourceSettings.columns[cCnt].name] = cCnt;
                        }
                    }
                }
            }
            else {
                if (this.showRowSubTotals) {
                    for (let rCnt = 0; rCnt < this.dataSourceSettings.rows.length; rCnt++) {
                        if (this.dataSourceSettings.rows[rCnt].showSubTotals === false) {
                            this.hideRowTotalsObject[this.dataSourceSettings.rows[rCnt].name] = rCnt;
                        }
                    }
                }
            }
            axisCount++;
        } while (axisCount < 3);
    }
    /* tslint:disable:max-func-body-length */
    frameRowHeader(tuples) {
        this.headerGrouping = {};
        this.lastLevel = [];
        let position = this.pivotValues.length;
        let pivotValues = [];
        let valueContent = [];
        if (this.customArgs.action !== 'down') {
            pivotValues = this.pivotValues;
            valueContent = this.valueContent;
        }
        else {
            position = this.customArgs.drillInfo.currentCell.rowIndex + 1;
        }
        this.rowStartPos = this.rowStartPos > 0 ? this.rowStartPos : position;
        let tupPos = 0;
        let lastAllStartPos;
        let lastAllCount;
        let prevUNArray = [];
        let allType = {};
        let rowMembers = [];
        let availAllMember = false;
        let withoutAllStartPos = -1;
        let withoutAllEndPos = -1;
        let minLevel = [];
        let gTotals = [{
                axis: 'row',
                colIndex: 0,
                formattedText: 'Grand Total',
                hasChild: false,
                level: -1,
                rowIndex: 0,
                index: [],
                type: 'grand sum',
                ordinal: 0,
                colSpan: 1,
                rowSpan: 1,
                memberType: 2,
                isDrilled: false,
                valueSort: { 'Grand Total': 1, levelName: 'Grand Total' }
            }];
        let maxLevel = [];
        let measurePos;
        let newTupPosition = (this.customArgs.drillInfo && this.customArgs.drillInfo.axis === 'row') ?
            (this.customArgs.drillInfo.currentCell.ordinal + 1) : 0;
        while (tupPos < tuples.length) {
            let members = tuples[tupPos].querySelectorAll('Member');
            maxLevel = this.frameTupCollection(members, maxLevel, (tupPos + newTupPosition), this.tupRowInfo, this.showRowSubTotals, this.hideRowTotalsObject, 'row');
            tupPos++;
        }
        tupPos = 0;
        let prevTupInfo;
        let tuplesLength = tuples.length;
        if (this.customArgs.action === 'down') {
            let ordinal = this.customArgs.drillInfo.currentCell.ordinal + 1;
            tupPos = ordinal;
            tuplesLength += ordinal;
            lastAllCount = this.tupRowInfo[ordinal - 1].allCount;
            lastAllStartPos = this.tupRowInfo[ordinal - 1].allStartPos;
            prevTupInfo = this.tupRowInfo[ordinal - 1];
        }
        let startTupPos = tupPos;
        let pagingAllowFlag = true;
        while (tupPos < tuplesLength && pagingAllowFlag) {
            let members = tuples[this.customArgs.action === 'down' ?
                (tupPos - (this.customArgs.drillInfo.currentCell.ordinal + 1)) : tupPos].querySelectorAll('Member');
            let memPos = 0;
            let prevParent;
            let allCount = this.tupRowInfo[tupPos].allCount;
            let allStartPos = this.tupRowInfo[tupPos].allStartPos;
            let measure = this.tupRowInfo[tupPos].measure;
            let typeColl = this.tupRowInfo[tupPos].typeCollection;
            let drillInfo = this.tupRowInfo[tupPos].drillInfo;
            let drillStartPos = this.tupRowInfo[tupPos].drillStartPos;
            let startDrillUniquename = this.tupRowInfo[tupPos].startDrillUniquename;
            let drillEndPos = this.tupRowInfo[tupPos].drillEndPos;
            let levelColl = this.tupRowInfo[tupPos].levelCollection;
            if (tupPos === 0 || tupPos === startTupPos) {
                let firstTupMembers = this.customArgs.action === 'down' ? this.tupRowInfo[0].members : members;
                while (memPos < firstTupMembers.length) {
                    if (firstTupMembers[memPos].querySelector('MEMBER_TYPE').textContent === '1' &&
                        Number(firstTupMembers[memPos].querySelector('LNum').textContent) === 0) {
                        minLevel[memPos] = 0;
                    }
                    else {
                        minLevel[memPos] = Number(firstTupMembers[memPos].querySelector('LNum').textContent);
                    }
                    // if (firstTupMembers[memPos].querySelector('MEMBER_TYPE').textContent === '1' &&
                    //   (this.isPaging || Number(firstTupMembers[memPos].querySelector('LNum').textContent) === 0)) {
                    if (firstTupMembers[memPos].querySelector('MEMBER_TYPE').textContent === '1') {
                        allType[memPos] = 0;
                        withoutAllStartPos = withoutAllStartPos === -1 ? memPos : withoutAllStartPos;
                        withoutAllEndPos = memPos;
                    }
                    else {
                        allType[memPos] = 1;
                        availAllMember = firstTupMembers[memPos].querySelector('MEMBER_TYPE').textContent === '3' ? availAllMember : true;
                    }
                    memPos++;
                }
                measurePos = typeColl.indexOf('3');
            }
            memPos = 0;
            if (tupPos === 0 && (members.length > (allCount + (measure ? 1 : 0)) || (members.length === 1 && measure))) {
                gTotals.pop();
            }
            if ((tupPos === 0 && this.isPaging) ? gTotals.length === 0 :
                (!availAllMember || allCount === lastAllCount || allStartPos !== lastAllStartPos || (members.length === 1 && measure))) {
                let drillAllow = drillStartPos > -1 ? (allCount > 0 ? (allStartPos > drillStartPos) : true) : true;
                /* tslint:disable-next-line:max-line-length */
                drillAllow = (prevTupInfo && drillAllow && drillStartPos > -1) ?
                    (prevTupInfo.startDrillUniquename !== startDrillUniquename ? true :
                        ((withoutAllEndPos > prevTupInfo.measurePosition ? false :
                            prevTupInfo.measureName !== this.tupRowInfo[tupPos].measureName) &&
                            (allStartPos === (drillStartPos + 1) || this.tupRowInfo[tupPos].measurePosition === (drillStartPos + 1))))
                    : drillAllow;
                let withoutAllAllow = (withoutAllStartPos > -1 && allCount > 0) ? (allStartPos > withoutAllEndPos) : true;
                if (members.length === allCount + (measure ? 1 : 0) && measure) {
                    let levelName = 'Grand Total.' + members[measurePos].querySelector('Caption').textContent;
                    gTotals.push({
                        axis: 'row',
                        actualText: this.getUniqueName(members[measurePos].querySelector('UName').textContent),
                        colIndex: 0,
                        formattedText: members[measurePos].querySelector('Caption').textContent,
                        hasChild: false,
                        level: -1,
                        rowIndex: position,
                        index: [],
                        ordinal: tupPos,
                        colSpan: 1,
                        rowSpan: 1,
                        memberType: Number(typeColl[measurePos]),
                        isDrilled: false,
                        parentUniqueName: members[measurePos].querySelector('PARENT_UNIQUE_NAME') ?
                            members[measurePos].querySelector('PARENT_UNIQUE_NAME').textContent : undefined,
                        levelUniqueName: members[measurePos].querySelector('LName').textContent,
                        hierarchy: members[measurePos].getAttribute('Hierarchy'),
                        valueSort: { levelName: levelName, axis: members[measurePos].getAttribute('Hierarchy') }
                    });
                    gTotals[gTotals.length - 1].valueSort['Grand Total.' + members[measurePos].querySelector('Caption').textContent] = 1;
                }
                else if (!(allStartPos === 0 || (measurePos === 0 && allStartPos === 1)) && drillAllow && withoutAllAllow) {
                    prevTupInfo = this.tupRowInfo[tupPos];
                    let lastPos = position;
                    let lastMemPos = memPos;
                    prevParent = {};
                    let withoutAllDrilled = false;
                    while (memPos < members.length && pagingAllowFlag) {
                        let member = members[memPos];
                        if (member.querySelector('UName').textContent !== prevUNArray[memPos] && typeColl[memPos] !== '2'
                            && ((Object.keys(prevParent).length > 0 ? prevParent.isDrilled : withoutAllDrilled) ?
                                (typeColl[memPos] === '3' && (allType[memPos - 1] && allType[memPos + 1] !== 0)) : true)) {
                            /* tslint:disable-next-line:max-line-length */
                            let lvl = Number(member.querySelector('LNum').textContent) -
                                ((allType[memPos] && typeColl[memPos] !== '3') ? 1 : minLevel[memPos]);
                            /* tslint:disable-next-line:no-string-literal */
                            let isNamedSet = this.namedSetsPosition['row'][memPos] ? true : false;
                            pivotValues[position] = [{
                                    axis: 'row',
                                    actualText: this.getUniqueName(member.querySelector('UName').textContent),
                                    colIndex: 0,
                                    formattedText: member.querySelector('Caption').textContent,
                                    hasChild: Number(member.querySelector('CHILDREN_CARDINALITY').textContent) > 0 ? true : false,
                                    level: lvl,
                                    rowIndex: position,
                                    index: [],
                                    ordinal: tupPos,
                                    type: 'header',
                                    colSpan: 1,
                                    rowSpan: 1,
                                    memberType: Number(typeColl[memPos]),
                                    isDrilled: this.tupRowInfo[tupPos].drillInfo[memPos].isDrilled,
                                    parentUniqueName: member.querySelector('PARENT_UNIQUE_NAME') ?
                                        member.querySelector('PARENT_UNIQUE_NAME').textContent : undefined,
                                    levelUniqueName: member.querySelector('LName').textContent,
                                    hierarchy: member.getAttribute('Hierarchy'),
                                    isNamedSet: isNamedSet,
                                    valueSort: { levelName: '', axis: member.getAttribute('Hierarchy') }
                                }];
                            prevParent = typeColl[memPos] !== '3' ? pivotValues[position][0] : prevParent;
                            if (!prevParent) {
                                rowMembers.push(member.querySelector('Caption').textContent);
                            }
                            let levelName = this.getCaptionCollectionWithMeasure(this.tupRowInfo[tupPos]);
                            pivotValues[position][0].valueSort.levelName = levelName;
                            pivotValues[position][0].valueSort[levelName] = 1;
                            valueContent[position - this.rowStartPos] = {};
                            valueContent[position - this.rowStartPos][0] = pivotValues[position][0];
                            if (measure && measurePos > memPos) {
                                prevUNArray[measurePos] = '';
                            }
                            for (let pos = memPos + 1; pos < members.length; pos++) {
                                prevUNArray[pos] = '';
                            }
                            prevUNArray[memPos] = member.querySelector('UName').textContent;
                            position++;
                            lastMemPos = memPos;
                        }
                        else if (typeColl[memPos] === '2') {
                            lastMemPos = memPos;
                        }
                        else {
                            if (this.tupRowInfo[tupPos].drillInfo[memPos].isDrilled && allType[memPos] === 0) {
                                withoutAllDrilled = true;
                            }
                        }
                        if (this.tupRowInfo[tupPos].drillInfo[memPos].isDrilled && this.tupRowInfo[tupPos].showTotals) {
                            this.tupRowInfo[tupPos].showTotals = !this.showRowSubTotals ? false :
                                this.hideRowTotalsObject[this.tupRowInfo[tupPos].drillInfo[memPos].hierarchy] === undefined;
                        }
                        memPos++;
                    }
                    if (lastPos < position && lastMemPos >= (members.length - 1)) {
                        pivotValues[position - 1][0].ordinal = tupPos;
                        if (pivotValues[position - 1][0].type === 'header') {
                            delete pivotValues[position - 1][0].type;
                        }
                    }
                }
                lastAllCount = allCount;
                lastAllStartPos = allStartPos;
            }
            tupPos++;
        }
        if (gTotals.length > 1 && gTotals[0].memberType !== 3) {
            gTotals[0].ordinal = -1;
        }
        // if (!(this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals)) {
        //     for (let totPos: number = 0; totPos < gTotals.length; totPos++) {
        //         if (this.tupRowInfo[gTotals[totPos].ordinal]) {
        //             this.tupRowInfo[gTotals[totPos].ordinal].showTotals = false;
        //         }
        //     }
        // }
        if (this.customArgs.action !== 'down') {
            if (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals) {
                for (let totPos = 0; totPos < gTotals.length; totPos++) {
                    gTotals[totPos].rowIndex = position;
                    pivotValues[position] = [gTotals[totPos]];
                    valueContent[position - this.rowStartPos] = {};
                    valueContent[position - this.rowStartPos][0] = pivotValues[position][0];
                    position++;
                }
            }
        }
        else {
            this.updateRowEngine(pivotValues, valueContent, tuples.length);
            this.onDemandDrillEngine = pivotValues;
        }
    }
    /* tslint:disable-next-line:max-line-length */
    frameTupCollection(members, maxLevel, tupPos, tupInfo, showSubTotals, hideTotalsObject, axis) {
        let memPos = 0;
        let allCount = 0;
        let allStartPos;
        let measure;
        let measureName;
        let measurePosition;
        let typeColl = [];
        let levelColl = [];
        let drillState = [];
        let uNameCollection = '';
        let captionCollection = '';
        let showTotals = true;
        let hideFieldPos = -1;
        while (memPos < members.length) {
            let member = members[memPos];
            let memberlevel = Number(member.querySelector('LNum').textContent);
            let memberUName = member.querySelector('UName').textContent;
            /* tslint:disable */
            if (Number(member.querySelector('MEMBER_TYPE').textContent) > 3) {
                member.querySelector('MEMBER_TYPE').textContent = memberUName.startsWith('[Measures]') ? '3' : '1';
            }
            let memberType = memberUName.startsWith('[Measures]') ? '3' :
                (Number(member.querySelector('MEMBER_TYPE').textContent) > 3 ? '1' : member.querySelector('MEMBER_TYPE').textContent);
            /* tslint:enable */
            let memberCaption = member.querySelector('Caption').textContent;
            if (this.fieldList[memberCaption] && this.fieldList[memberCaption].type === 'CalculatedField') {
                memberCaption = this.fieldList[memberCaption].caption;
                member.querySelector('Caption').textContent = memberCaption;
            }
            let hierarchy = member.getAttribute('Hierarchy');
            /* tslint:disable-next-line:max-line-length */
            let parentUName = member.querySelector('PARENT_UNIQUE_NAME') ? member.querySelector('PARENT_UNIQUE_NAME').textContent : '';
            if (memberType === '2') {
                allCount++;
                allStartPos = isNullOrUndefined(allStartPos) ? memPos : allStartPos;
            }
            else if (memberType === '3') {
                measure = member;
                measureName = memberUName;
                measurePosition = memPos;
                if (axis === 'column') {
                    this.colMeasures[memberUName] = member;
                    this.colMeasurePos = memPos;
                }
                else {
                    this.rowMeasurePos = memPos;
                }
            }
            else {
                hideFieldPos = hideTotalsObject[hierarchy];
            }
            if (memberType !== '2') {
                if (this.headerGrouping[memPos]) {
                    if (memberlevel > this.lastLevel[memPos]) {
                        this.lastLevel[memPos] = memberlevel;
                    }
                    else if (memberlevel < this.lastLevel[memPos]) {
                        let levelPos = this.lastLevel[memPos];
                        while (levelPos >= memberlevel) {
                            delete this.headerGrouping[memPos].UName[levelPos];
                            delete this.headerGrouping[memPos].Caption[levelPos];
                            levelPos--;
                        }
                        this.lastLevel[memPos] = memberlevel;
                    }
                    this.headerGrouping[memPos].UName[memberlevel] = memberUName;
                    this.headerGrouping[memPos].Caption[memberlevel] = memberCaption;
                }
                else {
                    this.lastLevel[memPos] = memberlevel;
                    this.headerGrouping[memPos] = { UName: { [memberlevel]: memberUName }, Caption: { [memberlevel]: memberCaption } };
                }
                if (this.isPaging) {
                    let currUName = parentUName;
                    while (this.drilledSets[currUName]) {
                        let currCaption = this.drilledSets[currUName].querySelector('Caption').textContent;
                        let currLevel = Number(this.drilledSets[currUName].querySelector('LNum').textContent);
                        this.headerGrouping[memPos].UName[currLevel] = currUName;
                        this.headerGrouping[memPos].Caption[currLevel] = currCaption;
                        currUName = this.drilledSets[currUName].querySelector('PARENT_UNIQUE_NAME') === null ? '' :
                            this.drilledSets[currUName].querySelector('PARENT_UNIQUE_NAME').textContent;
                    }
                }
                /* tslint:disable */
                let uNames = Object.values(this.headerGrouping[memPos].UName).join('~~');
                uNameCollection = uNameCollection === '' ? uNames :
                    (uNameCollection + '::' + uNames);
                let captions = Object.values(this.headerGrouping[memPos].Caption).join('~~');
                /* tslint:enable */
                if (memPos !== measurePosition) {
                    captionCollection = captionCollection === '' ? captions :
                        (captionCollection + '::' + captions);
                }
            }
            typeColl.push(memberType);
            levelColl.push(memberlevel);
            if (isNullOrUndefined(maxLevel[memPos]) || maxLevel[memPos] < memberlevel) {
                maxLevel[memPos] = memberlevel;
            }
            drillState.push({ level: memberlevel, uName: memberUName, hierarchy: hierarchy, isDrilled: false });
            if (tupInfo[tupPos - 1] && tupInfo[tupPos - 1].typeCollection[memPos] === '1' &&
                drillState[memPos].level > tupInfo[tupPos - 1].drillInfo[memPos].level) {
                let uCollection = uNameCollection.split(/~~|::\[/).map((item) => {
                    return item[0] === '[' ? item : ('[' + item);
                });
                uCollection.pop();
                let parentLevel = uCollection.join('~~');
                this.setDrillInfo(parentUName, parentLevel, memPos, tupPos, tupInfo);
            }
            memPos++;
        }
        if (hideFieldPos > -1) {
            showTotals = typeColl[hideFieldPos + 1] !== '2';
        }
        tupInfo[tupPos] = {
            allCount: allCount,
            allStartPos: allStartPos,
            measure: measure,
            measureName: measureName,
            measurePosition: measurePosition,
            members: members,
            typeCollection: typeColl,
            uNameCollection: uNameCollection,
            captionCollection: captionCollection,
            levelCollection: levelColl,
            drillInfo: drillState,
            drillStartPos: -1,
            drillEndPos: -1,
            showTotals: (!showSubTotals && allCount > 0 && allStartPos > (measurePosition === 0 ? 1 : 0)) ? false : showTotals
        };
        return maxLevel;
    }
    getCaptionCollectionWithMeasure(tuple) {
        let captionColection = tuple.captionCollection;
        if (tuple.measure) {
            let measureName = tuple.measure.querySelector('Caption').textContent;
            let measurePosition = tuple.uNameCollection.split(/[~~,::]+/g).indexOf(tuple.measureName);
            let captionCollectionArray = tuple.captionCollection.split(/[~~,::]+/g);
            captionCollectionArray.splice(measurePosition, 0, measureName);
            captionColection = captionCollectionArray.join('.');
        }
        else {
            let captionCollectionArray = tuple.captionCollection.split(/[~~,::]+/g);
            captionColection = captionCollectionArray.join('.');
        }
        return captionColection;
    }
    /** hidden */
    setNamedSetsPosition() {
        this.namedSetsPosition = {};
        let axis = 0;
        do {
            let setsPositions = {};
            let axisFields = axis ? this.dataSourceSettings.rows : this.dataSourceSettings.columns;
            for (let fPos = 0; fPos < axisFields.length; fPos++) {
                if (axisFields[fPos].isNamedSet) {
                    setsPositions[fPos] = axisFields[fPos].name;
                }
            }
            this.namedSetsPosition[axis ? 'row' : 'column'] = setsPositions;
            axis++;
        } while (axis < 2);
    }
    updateRowEngine(pivotValues, valueContent, tuplesLength) {
        let currEngineCount = this.pivotValues.length - 1;
        let newEngineCount = Object.keys(pivotValues).length;
        while (currEngineCount > this.customArgs.drillInfo.currentCell.rowIndex) {
            this.pivotValues[currEngineCount + newEngineCount] = this.pivotValues[currEngineCount];
            this.pivotValues[currEngineCount + newEngineCount][0].ordinal += tuplesLength;
            this.pivotValues[currEngineCount + newEngineCount][0].rowIndex += newEngineCount;
            /* tslint:disable-next-line:max-line-length */
            this.valueContent[(currEngineCount + newEngineCount) - this.rowStartPos] = this.valueContent[currEngineCount - this.rowStartPos];
            currEngineCount--;
        }
        // for (let key in pivotValues) {
        for (let key = 0; key < pivotValues.length; key++) {
            this.pivotValues[key] = pivotValues[key];
            this.valueContent[Number(key) - this.rowStartPos] = valueContent[Number(key) - this.rowStartPos];
        }
        this.pivotValues[this.customArgs.drillInfo.currentCell.rowIndex][0].isDrilled = true;
    }
    updateTupCollection(newTuplesCount) {
        let tupCollection = this.customArgs.drillInfo.axis === 'row' ? this.tupRowInfo : this.tupColumnInfo;
        let currTupCount = tupCollection.length - 1;
        while (currTupCount > this.customArgs.drillInfo.currentCell.ordinal) {
            tupCollection[currTupCount + newTuplesCount] = tupCollection[currTupCount];
            currTupCount--;
        }
    }
    /* tslint:disable:max-func-body-length */
    frameColumnHeader(tuples) {
        this.headerGrouping = {};
        this.lastLevel = [];
        let tupPos = 0;
        let maxLevel = [];
        let allType = [];
        let minLevel = [];
        let withoutAllStartPos = -1;
        let withoutAllEndPos = -1;
        let newTupPosition = (this.customArgs.drillInfo && this.customArgs.drillInfo.axis === 'column') ?
            (this.customArgs.drillInfo.currentCell.ordinal + 1) : 0;
        while (tupPos < tuples.length) {
            let members = tuples[tupPos].querySelectorAll('Member');
            maxLevel = this.frameTupCollection(members, maxLevel, (tupPos + newTupPosition), this.tupColumnInfo, this.showColumnSubTotals, this.hideColumnTotalsObject, 'column');
            tupPos++;
        }
        if (tuples.length > 0) {
            let members = tuples[0].querySelectorAll('Member');
            let memPos = 0;
            while (memPos < members.length) {
                minLevel[memPos] = (members[memPos].querySelector('MEMBER_TYPE').textContent === '1' &&
                    Number(members[memPos].querySelector('LNum').textContent) === 0) ? 0 :
                    Number(members[memPos].querySelector('LNum').textContent);
                if (members[memPos].querySelector('MEMBER_TYPE').textContent === '1' &&
                    (this.isPaging || Number(members[memPos].querySelector('LNum').textContent) === 0)) {
                    allType[memPos] = 0;
                    withoutAllStartPos = withoutAllStartPos === -1 ? memPos : withoutAllStartPos;
                    withoutAllEndPos = memPos;
                }
                else {
                    allType[memPos] = 1;
                }
                memPos++;
            }
        }
        /* tslint:disable */
        let _this = this;
        /* tslint:enable */
        /* tslint:disable-next-line:max-line-length */
        maxLevel.map((item, pos) => { _this.colDepth = _this.colDepth + (allType[pos] === 0 ? (item + (1 - (minLevel[pos] > 1 ? 1 : minLevel[pos]))) : (item === 0 ? 1 : item)); });
        tupPos = 0;
        let position = 1;
        let lastSavedInfo = {};
        let isSubTotIncluded = true;
        let withoutAllAvail = false;
        let lastRealTup;
        while (tupPos < tuples.length) {
            let members = tuples[tupPos].querySelectorAll('Member');
            let allCount = this.tupColumnInfo[tupPos].allCount;
            let allStartPos = this.tupColumnInfo[tupPos].allStartPos;
            let measure = this.tupColumnInfo[tupPos].measure;
            let typeColl = this.tupColumnInfo[tupPos].typeCollection;
            let drillInfo = this.tupColumnInfo[tupPos].drillInfo;
            let drillStartPos = this.tupColumnInfo[tupPos].drillStartPos;
            let startDrillUniquename = this.tupColumnInfo[tupPos].startDrillUniquename;
            let endDrillUniquename = this.tupColumnInfo[tupPos].endDrillUniquename;
            let drillEndPos = this.tupColumnInfo[tupPos].drillEndPos;
            let levelColl = this.tupColumnInfo[tupPos].levelCollection;
            let isStartCol = typeColl[0] === '2' ? false : (typeColl[0] === '3' ? typeColl[1] !== '2' : true);
            if (tupPos === 0 && members.length > (allCount + (measure ? 1 : 0))) {
                withoutAllAvail = true;
                isStartCol = (allCount > 0 && isStartCol) ? (allStartPos > withoutAllStartPos) : isStartCol;
            }
            if (isStartCol) {
                if (allCount === 0) {
                    let levelComp = [-1, -1, -1];
                    if (this.tupColumnInfo[tupPos - 1] && this.tupColumnInfo[tupPos - 1].allCount === 0) {
                        levelComp = this.levelCompare(levelColl, this.tupColumnInfo[tupPos - 1].levelCollection);
                    }
                    else if (withoutAllAvail && lastRealTup) {
                        levelComp = this.levelCompare(levelColl, lastRealTup.levelCollection);
                    }
                    if (this.tupColumnInfo[tupPos].drillStartPos < 0) {
                        if (!isSubTotIncluded && levelComp[0] > -1 && levelComp[2] > -1) {
                            position = this.mergeTotCollection(position, allCount, maxLevel, minLevel, allType, allStartPos, drillInfo, levelComp);
                        }
                        this.setParentCollection(members);
                        this.frameCommonColumnLoop(members, tupPos, position, maxLevel, allType, minLevel);
                        if (!this.tupColumnInfo[tupPos].showTotals) {
                            position--;
                        }
                        if (!isSubTotIncluded && levelComp[0] > -1 && levelComp[2] > -1) {
                            position = this.mergeTotCollection(position, allCount, maxLevel, minLevel, allType, allStartPos, drillInfo, levelComp);
                        }
                        isSubTotIncluded = false;
                        position++;
                        /* tslint:disable-next-line:max-line-length */
                    }
                    else if (lastSavedInfo.drillStartPos === drillStartPos ?
                        (lastSavedInfo.startDrillUniquename !== startDrillUniquename ||
                            lastSavedInfo.allCount === allCount) : true) {
                        if (!isSubTotIncluded && levelComp[0] > -1 && levelComp[2] > -1) {
                            position = this.mergeTotCollection(position, allCount, maxLevel, minLevel, allType, allStartPos, drillInfo, levelComp);
                            isSubTotIncluded = true;
                        }
                        this.setParentCollection(members);
                        if (withoutAllAvail ? (withoutAllEndPos <= drillStartPos) : true) {
                            /* tslint:disable-next-line:max-line-length */
                            this.totalCollection[this.totalCollection.length] = ({ allCount: allCount, ordinal: tupPos, members: members, drillInfo: drillInfo });
                            lastSavedInfo.allCount = allCount;
                            lastSavedInfo.allStartPos = allStartPos;
                            lastSavedInfo.drillStartPos = drillStartPos;
                            lastSavedInfo.startDrillUniquename = startDrillUniquename;
                            lastSavedInfo.endDrillUniquename = endDrillUniquename;
                        }
                    }
                    lastRealTup = this.tupColumnInfo[tupPos];
                }
            }
            if (allCount > 0 && (withoutAllAvail ? (isStartCol && withoutAllEndPos < allStartPos) : true)) {
                if (allCount === lastSavedInfo.allCount || allStartPos !== lastSavedInfo.allStartPos) {
                    /* tslint:disable-next-line:max-line-length */
                    let endAllow = drillEndPos !== drillStartPos ? (lastSavedInfo.endDrillUniquename === endDrillUniquename) : true;
                    /* tslint:disable-next-line:max-line-length */
                    let allow = allStartPos !== lastSavedInfo.allStartPos ? (lastSavedInfo.startDrillUniquename !== startDrillUniquename) : endAllow;
                    if (drillStartPos > -1 ? (allow) : true) {
                        if (!isSubTotIncluded) {
                            position = this.mergeTotCollection(position, allCount, maxLevel, minLevel, allType, allStartPos, drillInfo);
                            isSubTotIncluded = true;
                        }
                        this.setParentCollection(members);
                        if ((withoutAllAvail && drillStartPos > -1) ? (withoutAllEndPos <= drillStartPos) : true) {
                            /* tslint:disable-next-line:max-line-length */
                            this.totalCollection[this.totalCollection.length] = ({ allCount: allCount, ordinal: tupPos, members: members, allStartPos: allStartPos, drillInfo: drillInfo });
                            lastSavedInfo.allCount = allCount;
                            lastSavedInfo.allStartPos = allStartPos;
                            lastSavedInfo.drillStartPos = drillStartPos;
                            lastSavedInfo.startDrillUniquename = startDrillUniquename;
                            lastSavedInfo.endDrillUniquename = endDrillUniquename;
                        }
                    }
                }
            }
            tupPos++;
        }
        if (this.totalCollection.length > 0) {
            if (Object.keys(this.colMeasures).length > 1) {
                this.orderTotals(position, maxLevel, allType, minLevel);
            }
            else {
                this.totalCollection = this.totalCollection.reverse();
                for (let coll of this.totalCollection) {
                    let isGrandTotal = this.tupColumnInfo[coll.ordinal].measurePosition === 0 ?
                        this.tupColumnInfo[coll.ordinal].allStartPos === 1 : this.tupColumnInfo[coll.ordinal].allStartPos === 0;
                    if (isGrandTotal ? (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showColumnGrandTotals) : true) {
                        this.frameCommonColumnLoop(coll.members, coll.ordinal, position, maxLevel, minLevel, allType);
                        if (this.tupColumnInfo[coll.ordinal].showTotals) {
                            position++;
                        }
                    }
                }
            }
        }
    }
    orderTotals(position, maxLevel, allType, minLevel) {
        let groupColl = {};
        let maxCnt = 1;
        for (let coll of this.totalCollection) {
            let isGrandTotal = this.tupColumnInfo[coll.ordinal].measurePosition === 0 ?
                this.tupColumnInfo[coll.ordinal].allStartPos === 1 : this.tupColumnInfo[coll.ordinal].allStartPos === 0;
            if (isGrandTotal ? (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showColumnGrandTotals) : true) {
                let measureName = this.tupColumnInfo[coll.ordinal].measure.querySelector('UName').textContent;
                if (groupColl[measureName]) {
                    groupColl[measureName].coll.push(coll);
                    groupColl[measureName].count++;
                    maxCnt = maxCnt < groupColl[measureName].count ? groupColl[measureName].count : maxCnt;
                }
                else {
                    groupColl[measureName] = { coll: [coll], count: 1 };
                }
            }
        }
        let keys = Object.keys(groupColl);
        let collLength = maxCnt - 1;
        while (collLength > -1) {
            for (let key of keys) {
                let coll = groupColl[key].coll[collLength];
                if (coll) {
                    this.frameCommonColumnLoop(coll.members, coll.ordinal, position, maxLevel, allType, minLevel);
                    if (this.tupColumnInfo[coll.ordinal].showTotals) {
                        position++;
                    }
                }
            }
            collLength--;
        }
    }
    setParentCollection(members) {
        let memPos = 0;
        while (members.length > memPos) {
            let member = members[memPos];
            let memberType = Number(member.querySelector('MEMBER_TYPE').textContent) > 2 ? '3' :
                member.querySelector('MEMBER_TYPE').textContent;
            let memberlevel = Number(member.querySelector('LNum').textContent);
            let memberUName = member.querySelector('UName').textContent;
            let parentUName = member.querySelector('PARENT_UNIQUE_NAME') ?
                member.querySelector('PARENT_UNIQUE_NAME').textContent : '';
            let isSameParent = true;
            let isWithoutAllMember = false;
            if (this.parentObjCollection[memPos]) {
                let levelCollection = Object.keys(this.parentObjCollection[memPos]);
                let parentMember = this.parentObjCollection[memPos][memberlevel - 1];
                isSameParent = parentMember ? parentUName === parentMember.querySelector('UName').textContent :
                    levelCollection.length === 0;
                isWithoutAllMember = this.tupColumnInfo[0].typeCollection[memPos] === '1';
            }
            if (memberType === '2') {
                delete this.parentObjCollection[memPos];
            }
            else {
                if ((this.isPaging || isWithoutAllMember) ? !isSameParent : false) {
                    delete this.parentObjCollection[memPos];
                }
                if (!this.parentObjCollection[memPos]) {
                    this.parentObjCollection[memPos] = {};
                    this.parentObjCollection[memPos][memberlevel] = member;
                }
                else if (!this.parentObjCollection[memPos][memberlevel] ||
                    this.parentObjCollection[memPos][memberlevel].querySelector('UName').textContent !== memberUName) {
                    this.parentObjCollection[memPos][memberlevel] = member;
                }
            }
            memPos++;
        }
    }
    setDrillInfo(pUName, parentLvlCollection, memPos, tupPos, tupInfo) {
        tupPos--;
        while (tupInfo[tupPos] && tupInfo[tupPos].drillInfo[memPos].uName === pUName) {
            let prevUcollection = tupInfo[tupPos].uNameCollection.split(/~~|::\[/).map((item) => {
                return item[0] === '[' ? item : ('[' + item);
            });
            if (prevUcollection.join('~~').indexOf(parentLvlCollection) < 0) {
                break;
            }
            tupInfo[tupPos].drillInfo[memPos].isDrilled = true;
            if (this.curDrillEndPos <= memPos) {
                tupInfo[tupPos].drillEndPos = this.curDrillEndPos = memPos;
                tupInfo[tupPos].endDrillUniquename = pUName;
            }
            if (tupInfo[tupPos].drillStartPos > memPos || tupInfo[tupPos].drillStartPos === -1) {
                tupInfo[tupPos].drillStartPos = memPos;
            }
            tupInfo[tupPos].startDrillUniquename = pUName;
            tupPos--;
        }
    }
    levelCompare(newLevels, oldLevels) {
        let changePos = [-1, 0];
        for (let lPos = 0; lPos < oldLevels.length; lPos++) {
            if (newLevels[lPos] !== oldLevels[lPos]) {
                changePos = [lPos, newLevels[lPos], (oldLevels[lPos] - newLevels[lPos])];
                break;
            }
        }
        return changePos;
    }
    /* tslint:disable-next-line:max-line-length */
    mergeTotCollection(position, allCount, maxLevel, allType, minLevel, allStartPos, drillInfo, levelComp) {
        /* tslint:disable-next-line:max-line-length */
        let prevHdrPos = isNullOrUndefined(allStartPos) ? levelComp[0] : (allStartPos - ((this.colMeasurePos === (allStartPos - 1)) ? 2 : 1));
        let flagLevel = drillInfo[prevHdrPos] && drillInfo[prevHdrPos].level;
        let flagLevelString = this.getLevelsAsString(prevHdrPos - 1, drillInfo);
        let groupColl = {};
        let maxCnt = 1;
        let enterFlag = false;
        for (let coll of this.totalCollection) {
            if (enterFlag || (coll.allCount <= allCount &&
                ((flagLevel > -1 && coll.drillInfo[prevHdrPos]) ? ((coll.drillInfo[prevHdrPos].level >= flagLevel) &&
                    (this.getLevelsAsString(prevHdrPos - 1, coll.drillInfo)) === flagLevelString) : true))) {
                /* tslint:disable-next-line:max-line-length */
                let measureName = this.tupColumnInfo[coll.ordinal].measure ? this.tupColumnInfo[coll.ordinal].measure.querySelector('UName').textContent : 'measure';
                if (groupColl[measureName]) {
                    groupColl[measureName].coll.push(coll);
                    groupColl[measureName].count++;
                    maxCnt = maxCnt < groupColl[measureName].count ? groupColl[measureName].count : maxCnt;
                }
                else {
                    groupColl[measureName] = { coll: [coll], count: 1 };
                }
                enterFlag = false;
            }
        }
        let keys = Object.keys(groupColl);
        let collLength = maxCnt - 1;
        while (collLength > -1) {
            for (let key of keys) {
                let coll1 = groupColl[key].coll[collLength];
                if (coll1) {
                    let isGrandTotal = this.tupColumnInfo[coll1.ordinal].measurePosition === 0 ?
                        this.tupColumnInfo[coll1.ordinal].allStartPos === 1 : this.tupColumnInfo[coll1.ordinal].allStartPos === 0;
                    if (isGrandTotal ? (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showColumnGrandTotals) : true) {
                        this.frameCommonColumnLoop(coll1.members, coll1.ordinal, position, maxLevel, minLevel, allType);
                        if (this.tupColumnInfo[coll1.ordinal].showTotals) {
                            position++;
                        }
                    }
                    this.totalCollection.pop();
                }
            }
            collLength--;
        }
        return position;
    }
    getLevelsAsString(prevHdrPos, drillInfo) {
        let lvlCollection = [];
        for (let pos = 0; pos < prevHdrPos; pos++) {
            lvlCollection[pos] = drillInfo[pos].level;
        }
        return lvlCollection.length > 0 ? lvlCollection.toString() : '';
    }
    /* tslint:disable-next-line:max-line-length */
    frameCommonColumnLoop(members, tupPos, position, maxLevel, minLevel, allType) {
        let drillMemberPosition = -1;
        if (this.tupColumnInfo[tupPos].showTotals) {
            let memberPos = 0;
            let memberDepth = 0;
            while (memberPos < members.length) {
                memberDepth += (allType[memberPos] > 0 && this.tupColumnInfo[tupPos].measurePosition !== memberPos) ?
                    maxLevel[memberPos] :
                    (maxLevel[memberPos] + (1 - minLevel[memberPos]));
                if (this.tupColumnInfo[tupPos].drillInfo[memberPos].isDrilled && this.tupColumnInfo[tupPos].showTotals) {
                    this.tupColumnInfo[tupPos].showTotals = !this.showColumnSubTotals ? false :
                        this.hideColumnTotalsObject[this.tupColumnInfo[tupPos].drillInfo[memberPos].hierarchy] === undefined;
                    memberDepth -= maxLevel[memberPos] -
                        this.tupColumnInfo[tupPos].levelCollection[memberPos];
                    drillMemberPosition = this.tupColumnInfo[tupPos].showTotals ? -1 : (memberDepth - 1);
                }
                memberPos++;
            }
        }
        if (this.tupColumnInfo[tupPos].showTotals) {
            let memPos = 0;
            let spanMemPos = 0;
            let colMembers = {};
            while (memPos < members.length) {
                let member = members[memPos];
                let memberType = Number(member.querySelector('MEMBER_TYPE').textContent) > 2 ? '3' :
                    member.querySelector('MEMBER_TYPE').textContent;
                let memDup = 0;
                for (let rowDepthPos = memberType !== '2' ? (allType[memPos] ? 1 : minLevel[memPos]) : 1; rowDepthPos <= (memberType === '3' ? 1 : maxLevel[memPos]); rowDepthPos++) {
                    let isDrilled = false;
                    if (!this.pivotValues[spanMemPos]) {
                        this.pivotValues[spanMemPos] = [];
                    }
                    if (Number(members[memPos].querySelector('LNum').textContent) > rowDepthPos && memberType !== '2') {
                        if (!this.parentObjCollection[memPos][rowDepthPos]) {
                            this.getDrilledParent(members[memPos], rowDepthPos, this.parentObjCollection[memPos]);
                        }
                        if (this.parentObjCollection[memPos][rowDepthPos]) {
                            member = this.parentObjCollection[memPos][rowDepthPos];
                        }
                        isDrilled = true;
                    }
                    else {
                        member = members[memPos];
                        memDup++;
                    }
                    if (memberType !== '2') {
                        colMembers[member.querySelector('UName').textContent] = member.querySelector('Caption').textContent;
                    }
                    /* tslint:disable */
                    let levelName = Object.values(colMembers).join('.');
                    let isNamedSet = this.namedSetsPosition['column'][memPos] ? true : false;
                    this.pivotValues[spanMemPos][position] = {
                        axis: 'column',
                        actualText: this.getUniqueName(member.querySelector('UName').textContent),
                        colIndex: position,
                        formattedText: member.querySelector('Caption').textContent,
                        hasChild: Number(member.querySelector('CHILDREN_CARDINALITY').textContent) > 0 ? true : false,
                        /* tslint:disable-next-line:max-line-length */
                        level: memDup > 1 ? -1 : (Number(member.querySelector('LNum').textContent) - ((allType[memPos] && memberType !== '3') ? 1 : 0)),
                        rowIndex: spanMemPos,
                        ordinal: tupPos,
                        memberType: Number(memberType),
                        isDrilled: isDrilled || this.tupColumnInfo[tupPos].drillInfo[memPos].isDrilled,
                        /* tslint:disable-next-line:max-line-length */
                        parentUniqueName: member.querySelector('PARENT_UNIQUE_NAME') ? member.querySelector('PARENT_UNIQUE_NAME').textContent : undefined,
                        levelUniqueName: member.querySelector('LName').textContent,
                        hierarchy: member.getAttribute('Hierarchy'),
                        isNamedSet: isNamedSet,
                        valueSort: { levelName: levelName, [levelName]: 1, axis: member.getAttribute('Hierarchy') }
                        /* tslint:enable */
                    };
                    if (!this.headerContent[spanMemPos]) {
                        this.headerContent[spanMemPos] = {};
                    }
                    this.headerContent[spanMemPos][position] = this.pivotValues[spanMemPos][position];
                    spanMemPos++;
                }
                memPos++;
            }
        }
        else {
            if (drillMemberPosition > -1) {
                this.pivotValues[drillMemberPosition][position - 1].ordinal = tupPos;
            }
            else if (this.tupColumnInfo[tupPos].allCount > 0) {
                let memberPos = 0;
                let memberDepth = 0;
                while (memberPos < this.tupColumnInfo[tupPos].allStartPos) {
                    memberDepth += (allType[memberPos] > 0 && this.tupColumnInfo[tupPos].measurePosition !== memberPos) ?
                        maxLevel[memberPos] :
                        (maxLevel[memberPos] + (1 - minLevel[memberPos]));
                    memberPos++;
                }
                if (this.tupColumnInfo[tupPos].allStartPos === (this.tupColumnInfo[tupPos].measurePosition + 1)) {
                    memberDepth -= maxLevel[this.tupColumnInfo[tupPos].allStartPos - 2] -
                        this.tupColumnInfo[tupPos].levelCollection[this.tupColumnInfo[tupPos].allStartPos - 2] + 1;
                }
                else {
                    memberDepth -= maxLevel[this.tupColumnInfo[tupPos].allStartPos - 1] -
                        this.tupColumnInfo[tupPos].levelCollection[this.tupColumnInfo[tupPos].allStartPos - 1];
                }
                this.pivotValues[memberDepth - 1][position - 1].ordinal = tupPos;
            }
        }
    }
    getDrilledParent(childMember, parentLevel, savedCollection) {
        let childlevel = Number(childMember.querySelector('LNum').textContent);
        let currentChild = childMember;
        for (let lvl = childlevel - 1; lvl >= parentLevel; lvl--) {
            let currentParent = this.drilledSets[currentChild.querySelector('PARENT_UNIQUE_NAME').textContent];
            if (currentParent) {
                savedCollection[lvl] = currentParent;
                currentChild = currentParent;
            }
            else {
                break;
            }
        }
    }
    /* tslint:disable */
    performRowSorting() {
        if (this.enableSort && this.tupRowInfo.length > 0) {
            let rowCount = this.pivotValues.length;
            let lvlGrouping = {};
            let measureObjects = {};
            let gSumGrouping = [];
            let gSumFlag = false;
            let withoutAllLastPos = this.tupRowInfo[0].typeCollection.lastIndexOf('1');
            for (let rPos = this.colDepth; rPos < rowCount; rPos++) {
                let currentCell = this.pivotValues[rPos][0];
                let currentTuple = this.tupRowInfo[currentCell.ordinal];
                let uniqueName = currentTuple ? currentTuple.uNameCollection : '';
                if (uniqueName !== '') {
                    if (withoutAllLastPos > -1) {
                        uniqueName = this.frameUniqueName(uniqueName, currentCell, currentTuple);
                    }
                    let level = uniqueName.split(/~~|::\[/).length;
                    if (currentCell.memberType === 3 && this.tupRowInfo[0].measurePosition > 0) {
                        let parentUName = this.getParentUname(uniqueName, currentCell, true, true);
                        if (measureObjects[parentUName]) {
                            measureObjects[parentUName].push(currentCell);
                        }
                        else {
                            measureObjects[parentUName] = [currentCell];
                        }
                    }
                    else if (lvlGrouping[level]) {
                        lvlGrouping[level][uniqueName] = [currentCell];
                    }
                    else {
                        lvlGrouping[level] = { [uniqueName]: [currentCell] };
                    }
                }
                if (gSumFlag) {
                    gSumGrouping.push(currentCell);
                }
                if (currentCell.type === 'grand sum') {
                    gSumFlag = true;
                }
            }
            let isMeasureAvail = Object.keys(measureObjects).length > 0 && this.tupRowInfo[0].measurePosition > 0;
            let levels = Object.keys(lvlGrouping).map((item) => {
                return Number(item);
            }).sort((a, b) => (a > b) ? 1 : ((b > a) ? -1 : 0));
            let sortLvlGrouping = {};
            for (let lPos = levels.length - 1; lPos >= 0; lPos--) {
                let parentGrouping = {};
                let objCollection = lvlGrouping[levels[lPos]];
                let objKeys = Object.keys(objCollection);
                for (let oPos = 0; oPos < objKeys.length; oPos++) {
                    let parentUName = lPos === 0 ? 'parent' :
                        this.getParentUname(objKeys[oPos], objCollection[objKeys[oPos]][0], isMeasureAvail, false);
                    if (parentGrouping[parentUName]) {
                        parentGrouping[parentUName].push(objCollection[objKeys[oPos]][0]);
                    }
                    else {
                        parentGrouping[parentUName] = [objCollection[objKeys[oPos]]][0];
                    }
                }
                let pKeys = Object.keys(parentGrouping);
                /* tslint:disable:typedef */
                for (let kPos = 0; kPos < pKeys.length; kPos++) {
                    parentGrouping[pKeys[kPos]] = this.sortRowHeaders(parentGrouping[pKeys[kPos]]);
                }
                /* tslint:enable:typedef */
                if (sortLvlGrouping[levels[lPos + 1]]) {
                    for (let kPos = 0; kPos < pKeys.length; kPos++) {
                        let groupSets = [];
                        let axisSets = parentGrouping[pKeys[kPos]];
                        for (let aPos = 0; aPos < axisSets.length; aPos++) {
                            let tupInfo = this.tupRowInfo[axisSets[aPos].ordinal];
                            let uName = tupInfo.uNameCollection;
                            groupSets.push(axisSets[aPos]);
                            if (withoutAllLastPos > -1) {
                                uName = this.frameUniqueName(uName, axisSets[aPos], tupInfo);
                            }
                            let isMembersIncluded = false;
                            if (isMeasureAvail) {
                                let parentUName = this.getParentUname(uName, axisSets[aPos], isMeasureAvail, true);
                                if (measureObjects[parentUName]) {
                                    measureObjects[parentUName] = this.sortRowHeaders(measureObjects[parentUName]);
                                    let isLastMeasure = uName.lastIndexOf('::[') === uName.indexOf('::[Measures]');
                                    let isFullLength = uName.split('::[').length - 1 === tupInfo.measurePosition;
                                    let isLastNotDrilledMember = !tupInfo.drillInfo[tupInfo.measurePosition - 1].isDrilled;
                                    let isActualLastMember = tupInfo.members.length > (tupInfo.measurePosition + 1);
                                    if (isLastMeasure && isFullLength && isLastNotDrilledMember && isActualLastMember) {
                                        isMembersIncluded = true;
                                        for (let mPos = 0; mPos < measureObjects[parentUName].length; mPos++) {
                                            groupSets.push(measureObjects[parentUName][mPos]);
                                            let matchParent = (uName.substring(0, uName.indexOf('::[Measures]')) + '::' + measureObjects[parentUName][mPos].actualText);
                                            if (sortLvlGrouping[levels[lPos + 1]][matchParent]) {
                                                groupSets = groupSets.concat(sortLvlGrouping[levels[lPos + 1]][matchParent]);
                                            }
                                        }
                                    }
                                    else {
                                        groupSets = groupSets.concat(measureObjects[parentUName]);
                                    }
                                }
                            }
                            if (!isMembersIncluded &&
                                sortLvlGrouping[levels[lPos + 1]][uName]) {
                                /* tslint:disable-next-line:max-line-length */
                                groupSets = groupSets.concat(sortLvlGrouping[levels[lPos + 1]][uName]);
                            }
                        }
                        parentGrouping[pKeys[kPos]] = groupSets;
                    }
                }
                else if (isMeasureAvail) {
                    for (let kPos = 0; kPos < pKeys.length; kPos++) {
                        let axisSets = parentGrouping[pKeys[kPos]];
                        let groupSets = [];
                        for (let aPos = 0; aPos < axisSets.length; aPos++) {
                            groupSets.push(axisSets[aPos]);
                            let uName = this.tupRowInfo[axisSets[aPos].ordinal].uNameCollection;
                            if (withoutAllLastPos > -1) {
                                uName = this.frameUniqueName(uName, axisSets[aPos], this.tupRowInfo[axisSets[aPos].ordinal]);
                            }
                            let parentUName = this.getParentUname(uName, axisSets[aPos], true, true);
                            if (measureObjects[parentUName]) {
                                measureObjects[parentUName] = this.sortRowHeaders(measureObjects[parentUName]);
                                groupSets = groupSets.concat(measureObjects[parentUName]);
                            }
                        }
                        parentGrouping[pKeys[kPos]] = groupSets;
                    }
                }
                sortLvlGrouping[levels[lPos]] = parentGrouping;
            }
            let newPos = 0;
            let totPos = 0;
            gSumFlag = false;
            gSumGrouping = this.sortRowHeaders(gSumGrouping);
            for (let rPos = this.colDepth; rPos < rowCount; rPos++) {
                let cell = gSumFlag ? gSumGrouping : sortLvlGrouping[levels[0]]['parent'];
                let currPos = gSumFlag ? (newPos - totPos) : newPos;
                if (cell[currPos]) {
                    this.pivotValues[rPos] = [cell[currPos]];
                    this.pivotValues[rPos][0].rowIndex = rPos;
                    this.valueContent[newPos][0] = this.pivotValues[rPos][0];
                }
                newPos++;
                if (this.pivotValues[rPos][0].type === 'grand sum') {
                    gSumFlag = true;
                    totPos = newPos;
                }
            }
        }
    }
    /* tslint:disable:max-func-body-length */
    performColumnSorting() {
        if (this.enableSort) {
            for (let i = 0; i < this.dataSourceSettings.columns.length; i++) {
                let temporary = [];
                let index = 0;
                let grandTotal = [];
                for (let j = 0; j < this.pivotValues.length; j++) {
                    let header = this.pivotValues[j];
                    let key;
                    let keys;
                    let arrange = {};
                    let value = 1;
                    grandTotal[index] = [];
                    temporary[index] = [];
                    let k = 1;
                    for (k = k; k < header.length; k++) {
                        if (!header[k].isNamedSet) {
                            if (header[k].memberType != 2 && header[k].hierarchy
                                != '[Measures]' && header[k].level != -1) {
                                isNullOrUndefined(arrange[header[k].formattedText]) ?
                                    arrange[header[k].formattedText] = [] : arrange[k];
                                arrange[header[k].formattedText][header[k].colIndex] = header[k];
                            }
                            else if (Object.keys(arrange).length > 0) {
                                grandTotal[index][grandTotal[index].length + value] = header[k];
                                key = Object.keys(arrange);
                                /* tslint:disable:typedef */
                                key = this.sortColumnHeaders(key, this.sortObject[header[k - 1].levelUniqueName] ||
                                    this.sortObject[header[k].hierarchy]);
                                isNullOrUndefined(temporary[index]) ? temporary[index] = [] : temporary[index];
                                for (let l = 0; l < key.length; l++) {
                                    let length = Object.keys(arrange[key[l]]).length;
                                    for (let q = 0; q < length; q++) {
                                        value = temporary[index].length == 0 ? 1 : 0;
                                        temporary[index][temporary[index].length + value] =
                                            arrange[key[l]][Number(Object.keys(arrange[key[l]])[q])];
                                    }
                                }
                            }
                            else if ((header[k].level === -1 || header[k].level === 0) &&
                                Object.keys(arrange).length >= 0 && header[k].hierarchy != '[Measures]') {
                                grandTotal[index][grandTotal[index].length + value] = header[k];
                            }
                            if (header[k].level != -1 && Object.keys(arrange).length === 1 &&
                                header[k].hierarchy != '[Measures]' && !isNullOrUndefined(header[k + 1]) &&
                                header[k + 1].level === -1) {
                                let height = Object.keys(arrange[header[k].formattedText]).length;
                                let weight = Object.keys(arrange[header[k].formattedText]);
                                if (height > 1) {
                                    for (let hgt = 0; hgt < height; hgt++) {
                                        value = grandTotal[index].length == 0 ? 1 : 0;
                                        grandTotal[index][grandTotal[index].length + value] =
                                            arrange[header[k].formattedText][Number(weight[hgt])];
                                    }
                                }
                                else {
                                    grandTotal[index][grandTotal[index].length + value] = header[k];
                                }
                            }
                            if (Object.keys(grandTotal[index]).length > 0) {
                                value = temporary[index].length == 0 ? 1 : 0;
                                let height1 = grandTotal[index].length;
                                if (height1 > 2) {
                                    for (let hgt1 = 1; hgt1 < height1; hgt1++) {
                                        value = temporary[index].length == 0 ? 1 : 0;
                                        temporary[index][temporary[index].length + value] =
                                            grandTotal[index][hgt1];
                                    }
                                }
                                else {
                                    temporary[index][temporary[index].length + value] =
                                        grandTotal[index][1] || grandTotal[index][0];
                                }
                                arrange = {};
                                grandTotal[index] = [];
                            }
                        }
                    }
                    if (Object.keys(arrange).length > 0) {
                        grandTotal[index][grandTotal[index].length + value] = header[k];
                        keys = Object.keys(arrange);
                        /* tslint:disable:typedef */
                        let order = this.sortObject[header[k - 1].levelUniqueName] || this.sortObject[header[k - 1].hierarchy];
                        key = this.sortColumnHeaders(keys, order);
                        isNullOrUndefined(temporary[index]) ? temporary[index] = [] : temporary[index];
                        for (let len = 0; len < keys.length; len++) {
                            let leng = Object.keys(arrange[keys[len]]).length;
                            for (let q = 0; q < leng; q++) {
                                value = temporary[index].length == 0 ? 1 : 0;
                                temporary[index][temporary[index].length + value] =
                                    arrange[key[len]][Number(Object.keys(arrange[keys[len]])[q])];
                            }
                        }
                    }
                    for (let m = 1; m < temporary[index].length; m++) {
                        this.pivotValues[index][m] = temporary[index][m];
                    }
                    for (let n = j; n < this.pivotValues.length; n++) {
                        let pElement = extend({}, this.pivotValues[n + 1], null, true);
                        let cElement = extend({}, this.pivotValues[n], null, true);
                        if (Object.keys(pElement).length === Object.keys(cElement).length && Object.keys(pElement).length > 2) {
                            for (let o = 1; o < this.pivotValues[j].length; o++) {
                                if (Object.keys(pElement).length > 0 && cElement[o].colIndex
                                    != pElement[o].colIndex) {
                                    this.pivotValues[n + 1][o] = pElement[cElement[o].colIndex];
                                }
                            }
                            break;
                        }
                    }
                    index++;
                    arrange = {};
                }
                for (let i = 0; i < this.pivotValues.length; i++) {
                    let header = this.pivotValues[i];
                    for (let j = 1; j < header.length; j++) {
                        header[j].colIndex = j;
                    }
                }
            }
        }
    }
    frameUniqueName(uniqueName, currentCell, currentTuple) {
        let hasLastMeasure = uniqueName.indexOf(currentCell.actualText.toString() + '::[Measures]') > -1;
        uniqueName = uniqueName.substring(0, uniqueName.indexOf(currentCell.actualText.toString())) +
            currentCell.actualText.toString();
        let measureAvail = uniqueName.split('::[').length <= currentTuple.measurePosition;
        uniqueName = uniqueName + ((hasLastMeasure || measureAvail) ? ('::' + currentTuple.measureName) : '');
        return uniqueName;
    }
    sortRowHeaders(headers) {
        if (headers.length > 0 && headers[0].memberType !== 3 && !headers[0].isNamedSet) {
            let order = (this.sortObject[headers[0].hierarchy] || this.sortObject[headers[0].levelUniqueName]);
            if (order === 'Ascending' || order === undefined) {
                headers == headers.sort((a, b) => (a.formattedText > b.formattedText) ? 1 :
                    ((b.formattedText > a.formattedText) ? -1 : 0));
            }
            else if (order === 'Descending') {
                headers == headers.sort((a, b) => (a.formattedText < b.formattedText) ? 1 :
                    ((b.formattedText < a.formattedText) ? -1 : 0));
            }
            else {
                
            }
        }
        return headers;
    }
    sortColumnHeaders(keys, order) {
        if (order === 'Ascending' || order === undefined) {
            keys.sort((a, b) => (a > b) ? 1 : ((b > a) ? -1 : 0));
        }
        else if (order === 'Descending') {
            keys.sort((a, b) => (a < b) ? 1 : ((b < a) ? -1 : 0));
        }
        return keys;
    }
    frameSortObject() {
        if (this.enableSort) {
            for (let fPos = 0; fPos < this.sortSettings.length; fPos++) {
                this.sortObject[this.sortSettings[fPos].name] = this.sortSettings[fPos].order;
            }
        }
    }
    /* tslint:enable */
    getParentUname(uniqueNameColl, cell, isMeasureAvail, isLastMeasure) {
        let parentString = '';
        if (isMeasureAvail && !isLastMeasure) {
            let tuple = this.tupRowInfo[cell.ordinal];
            let sepPos = [];
            let sepObjects = {};
            for (let i = 0; i < uniqueNameColl.length; i++) {
                if (uniqueNameColl[i] === '~' || uniqueNameColl[i] === ':') {
                    sepPos.push(i);
                    sepObjects[i] = uniqueNameColl[i] + uniqueNameColl[i];
                    i++;
                }
            }
            if (tuple.measurePosition >= (uniqueNameColl.split('::[').length - 1)) {
                if (sepPos[sepPos.length - 2] > -1) {
                    parentString = uniqueNameColl.substring(0, sepPos[sepPos.length - 2]) + sepObjects[sepPos[sepPos.length - 1]] +
                        tuple.measureName;
                }
                else {
                    parentString = 'parent';
                }
            }
            else {
                let lastPosition = uniqueNameColl.lastIndexOf('~~') > uniqueNameColl.lastIndexOf('::[') ?
                    uniqueNameColl.lastIndexOf('~~') : uniqueNameColl.lastIndexOf('::[');
                parentString = lastPosition > -1 ? uniqueNameColl.substring(0, lastPosition) : 'parent';
            }
        }
        else {
            let lastPosition = uniqueNameColl.lastIndexOf('~~') > uniqueNameColl.lastIndexOf('::[') ?
                uniqueNameColl.lastIndexOf('~~') : uniqueNameColl.lastIndexOf('::[');
            parentString = lastPosition > -1 ? uniqueNameColl.substring(0, lastPosition) : 'parent';
        }
        return parentString;
    }
    performColumnSpanning() {
        let spanCollection = {};
        let rowPos = this.rowStartPos - 1;
        let colMeasureCount = Object.keys(this.colMeasures).length;
        while (rowPos > -1) {
            spanCollection[rowPos] = {};
            let colPos = this.pivotValues[rowPos].length - 1;
            while (colPos > 0) {
                spanCollection[rowPos][colPos] = 1;
                let nextColCell = this.pivotValues[rowPos][colPos + 1];
                /* tslint:disable-next-line:max-line-length */
                let nextRowCell = (this.pivotValues[rowPos + 1] && this.rowStartPos - rowPos > 1) ? this.pivotValues[rowPos + 1][colPos] : undefined;
                let currCell = this.pivotValues[rowPos][colPos];
                let colflag = false;
                let rowflag = false;
                let tupColInfo = this.tupColumnInfo[currCell.ordinal];
                let isSubTot = tupColInfo.allStartPos > (tupColInfo.typeCollection[0] === '3' ? 1 : 0);
                if (nextRowCell && nextColCell && ((currCell.memberType === 2 || currCell.level === -1) ?
                    (nextColCell.actualText === currCell.actualText) :
                    ((currCell.memberType === 3 && currCell.actualText === nextColCell.actualText) ||
                        nextColCell.valueSort.levelName === currCell.valueSort.levelName))) {
                    if (currCell.memberType === 2) {
                        if (isSubTot ? nextColCell.type === 'sum' : true) {
                            currCell.colSpan = (nextColCell.colSpan + 1) >
                                (tupColInfo.measurePosition > rowPos ? colMeasureCount : 0) ? 1 : (nextColCell.colSpan + 1);
                        }
                        else {
                            currCell.colSpan = 1;
                        }
                    }
                    else {
                        currCell.colSpan = nextColCell.colSpan + 1;
                        currCell.ordinal = nextColCell.ordinal;
                    }
                    colflag = true;
                }
                if (currCell.memberType === 2) {
                    if (isSubTot) {
                        currCell.type = 'sum';
                        /* tslint:disable-next-line:max-line-length */
                        //currCell.formattedText = (this.pivotValues[tupColInfo.allStartPos - 1] as IAxisSet[])[colPos].formattedText + ' Total';
                        currCell.formattedText = 'Total';
                        currCell.valueSort.levelName = currCell.valueSort.levelName;
                        currCell.valueSort[currCell.valueSort.levelName.toString()] = 1;
                    }
                    else {
                        let levelName = 'Grand Total';
                        if (nextRowCell && colMeasureCount > 0) {
                            levelName = nextRowCell.memberType === 3 ? ('Grand Total.' + nextRowCell.formattedText) :
                                nextRowCell.valueSort.levelName;
                        }
                        currCell.type = 'grand sum';
                        currCell.formattedText = 'Grand Total';
                        currCell.valueSort.levelName = levelName;
                        currCell.valueSort[levelName.toString()] = 1;
                    }
                    currCell.hasChild = false;
                }
                else if (currCell.level === -1) {
                    currCell.type = 'sum';
                    //currCell.formattedText = currCell.formattedText + ' Total';
                    currCell.formattedText = 'Total';
                    currCell.hasChild = false;
                    currCell.valueSort.levelName = currCell.valueSort.levelName;
                    currCell.valueSort[currCell.valueSort.levelName.toString()] = 1;
                }
                if (nextRowCell) {
                    if ((currCell.memberType === 2 && nextRowCell.memberType === 2) || nextRowCell.actualText === currCell.actualText) {
                        spanCollection[rowPos][colPos] = spanCollection[rowPos + 1] ? (spanCollection[rowPos + 1][colPos] + 1) : 1;
                        /* tslint:disable-next-line:max-line-length */
                        if (rowPos === 0 || (currCell.memberType === 1 && currCell.level > -1 && nextRowCell.memberType === 1 && nextRowCell.level === -1)) {
                            currCell.rowSpan = currCell.isDrilled ? 1 : (spanCollection[rowPos + 1][colPos] + 1);
                            /* tslint:disable-next-line:max-line-length */
                            nextRowCell.rowSpan = (nextRowCell.isDrilled && nextRowCell.level === -1) ? spanCollection[rowPos + 1][colPos] : nextRowCell.rowSpan;
                        }
                        else {
                            if (currCell.memberType === 3) {
                                currCell.rowSpan = 1;
                            }
                            else {
                                currCell.rowSpan = -1;
                            }
                        }
                        rowflag = true;
                    }
                    else if (currCell.isDrilled && currCell.level === -1 && nextRowCell.memberType === 2) {
                        spanCollection[rowPos][colPos] = spanCollection[rowPos + 1] ? (spanCollection[rowPos + 1][colPos] + 1) : 1;
                        currCell.rowSpan = -1;
                        rowflag = true;
                    }
                    else {
                        currCell.rowSpan = rowPos === 0 ? spanCollection[rowPos][colPos] : -1;
                        /* tslint:disable-next-line:max-line-length */
                        nextRowCell.rowSpan = ((nextRowCell.level > -1 && !nextRowCell.isDrilled) || (currCell.memberType !== 2 && nextRowCell.memberType === 2)) ? spanCollection[rowPos + 1][colPos] : 1;
                    }
                }
                else {
                    currCell.rowSpan = (currCell.level > -1 || this.rowStartPos === 1) ? spanCollection[rowPos][colPos] : -1;
                }
                if (!colflag) {
                    currCell.colSpan = 1;
                }
                if (!rowflag) {
                    spanCollection[rowPos][colPos] = 1;
                }
                colPos--;
            }
            rowPos--;
        }
    }
    frameValues(tuples, colLength) {
        let rowStartPos = this.colDepth;
        let rowEndPos = this.pivotValues.length;
        let startRowOrdinal = 0;
        if (this.customArgs.action === 'down') {
            let keys = Object.keys(this.onDemandDrillEngine);
            rowStartPos = Number(keys[0]);
            rowEndPos = Number(keys[keys.length - 1]) + 1;
            startRowOrdinal = this.onDemandDrillEngine[rowStartPos][0].ordinal;
        }
        let valCollection = {};
        for (let colPos = 0; colPos < tuples.length; colPos++) {
            valCollection[Number(tuples[colPos].getAttribute('CellOrdinal'))] = tuples[colPos];
        }
        for (let rowPos = rowStartPos; rowPos < rowEndPos; rowPos++) {
            let columns = this.pivotValues[rowPos];
            let rowOrdinal = columns[0].ordinal;
            for (let colPos = 1; colPos < this.pivotValues[0].length; colPos++) {
                let colOrdinal = this.pivotValues[this.colDepth - 1][colPos].ordinal;
                let lastColCell = this.pivotValues[this.colDepth - 1][colPos];
                let measure = columns[0].memberType === 3 ? columns[0].actualText.toString() :
                    ((this.tupColumnInfo[lastColCell.ordinal] && this.tupColumnInfo[lastColCell.ordinal].measure) ?
                        this.tupColumnInfo[lastColCell.ordinal].measure.querySelector('UName').textContent :
                        columns[0].actualText);
                if (columns[0].type === 'header') {
                    columns[colPos] = {
                        axis: 'value',
                        actualText: this.getUniqueName(measure),
                        formattedText: '',
                        value: 0,
                        colIndex: colPos,
                        rowIndex: rowPos
                    };
                }
                else {
                    let valElement;
                    let formattedText;
                    let value = '0';
                    let measureName = this.getUniqueName(measure);
                    let showTotals = true;
                    if (this.tupRowInfo[rowOrdinal]) {
                        showTotals = this.tupRowInfo[rowOrdinal].showTotals;
                    }
                    else {
                        showTotals = this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals;
                    }
                    valElement = valCollection[(rowOrdinal - startRowOrdinal) * colLength + colOrdinal];
                    /* tslint:disable:max-line-length */
                    formattedText = !showTotals ? '' :
                        ((!isNullOrUndefined(valElement) && !isNullOrUndefined(valElement.querySelector('FmtValue'))) ?
                            valElement.querySelector('FmtValue').textContent : this.emptyCellTextContent);
                    value = !showTotals ? '0' :
                        ((!isNullOrUndefined(valElement) && !isNullOrUndefined(valElement.querySelector('Value'))) ?
                            valElement.querySelector('Value').textContent : null);
                    formattedText = showTotals && !isNullOrUndefined(value) ?
                        this.getFormattedValue(Number(value), measureName, (formattedText !== '' ? formattedText : value)) :
                        formattedText;
                    let isSum = (this.tupColumnInfo[colOrdinal] ? (this.tupColumnInfo[colOrdinal].allCount > 0 ||
                        this.tupColumnInfo[colOrdinal].drillStartPos > -1) : true) ||
                        (this.tupRowInfo[rowOrdinal] ? (this.tupRowInfo[rowOrdinal].allCount > 0 ||
                            this.tupRowInfo[rowOrdinal].drillStartPos > -1) : true);
                    columns[colPos] = {
                        axis: 'value',
                        actualText: measureName,
                        formattedText: formattedText,
                        colOrdinal: colOrdinal,
                        rowOrdinal: rowOrdinal,
                        columnHeaders: this.tupColumnInfo[colOrdinal] ? this.tupColumnInfo[colOrdinal].captionCollection : '',
                        rowHeaders: this.tupRowInfo[rowOrdinal] ? this.tupRowInfo[rowOrdinal].captionCollection : '',
                        value: !isNullOrUndefined(value) ? Number(value) : null,
                        colIndex: colPos,
                        rowIndex: rowPos,
                        isSum: isSum
                    };
                }
                this.valueContent[rowPos - this.rowStartPos][colPos] = columns[colPos];
            }
        }
    }
    /** hidden */
    getFormattedValue(value, fieldName, formattedText) {
        let formattedValue = formattedText;
        if (this.formatFields[fieldName] && !isNullOrUndefined(value)) {
            let formatField = (this.formatFields[fieldName].properties ?
                this.formatFields[fieldName].properties : this.formatFields[fieldName]);
            let formatObj = extend({}, formatField, null, true);
            delete formatObj.name;
            if (!formatObj.minimumSignificantDigits && formatObj.minimumSignificantDigits < 1) {
                delete formatObj.minimumSignificantDigits;
            }
            if (!formatObj.maximumSignificantDigits && formatObj.maximumSignificantDigits < 1) {
                delete formatObj.maximumSignificantDigits;
            }
            if (formatObj.type) {
                formattedValue = this.globalize.formatDate(new Date(value.toString()), formatObj);
            }
            else {
                delete formatObj.type;
                if ((formatObj.format) && !(this.formatRegex.test(formatObj.format))) {
                    let pattern = formatObj.format.match(this.customRegex);
                    let integerPart = pattern[6];
                    formatObj.useGrouping = integerPart.indexOf(',') !== -1;
                }
                formattedValue = this.globalize.formatNumber(value, formatObj);
            }
        }
        return formattedValue;
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    getMeasureInfo() {
        let mAxis = 'column';
        let mIndex;
        let values = [];
        for (let field of this.values) {
            values[values.length] = (field.isCalculatedField ? this.fieldList[field.name].tag : field.name);
        }
        if (values.length > 1) {
            if (this.isMeasureAvail) {
                let isAvail = false;
                for (let i = 0, cnt = this.rows.length; i < cnt; i++) {
                    if (this.rows[i].name.toLowerCase() === '[measures]') {
                        mAxis = 'row';
                        mIndex = i;
                        isAvail = true;
                        break;
                    }
                }
                if (!isAvail) {
                    for (let i = 0, cnt = this.columns.length; i < cnt; i++) {
                        if (this.columns[i].name.toLowerCase() === '[measures]') {
                            mAxis = 'column';
                            mIndex = i;
                            isAvail = true;
                            break;
                        }
                    }
                }
            }
            else {
                mAxis = this.valueAxis;
                mIndex = mAxis === 'row' ? this.rows.length - 1 : this.columns.length - 1;
            }
            return { measureAxis: mAxis, measureIndex: mIndex, valueInfo: values };
        }
        else {
            return { measureAxis: mAxis, measureIndex: -1, valueInfo: [] };
        }
    }
    /* tslint:disable:max-func-body-length */
    frameMeasureOrder(measureInfo, axis, tuples, vTuples, cLen) {
        let orderedTuples = [];
        let orderedVTuples = [];
        let orderedIndex = [];
        let levels = {};
        let cLevels = [];
        let measureAxis = measureInfo.measureAxis;
        let measureIndex = measureInfo.measureIndex;
        let values = measureInfo.valueInfo;
        if (measureAxis === axis && values.length > 0) {
            let levelCollection = {};
            let uniqueLevels = [];
            for (let j = 0, lnt = tuples.length; j < lnt; j++) {
                let node = tuples[j];
                let members = [].slice.call(node.querySelectorAll('Member'));
                let level = '';
                let cLevel = '';
                let i = 0;
                while (i < members.length) {
                    level = level + (level !== '' ? '~~' : '') + members[i].querySelector('UName').textContent;
                    if (i === measureIndex && measureIndex === 0) {
                        cLevel = level;
                    }
                    else if (i === (measureIndex - 1)) {
                        cLevel = level;
                    }
                    i++;
                }
                if (levelCollection[cLevel]) {
                    levelCollection[cLevel][levelCollection[cLevel].length] = level;
                }
                else {
                    levelCollection[cLevel] = [level];
                    uniqueLevels[uniqueLevels.length] = cLevel;
                }
                levels[level] = { index: j, node: node };
                cLevels[cLevels.length] = level;
            }
            if (cLevels.length > 0) {
                if (uniqueLevels.length > 0) {
                    if (measureIndex === 0) {
                        for (let name of values) {
                            for (let key of uniqueLevels) {
                                if (key === name) {
                                    for (let level of levelCollection[key]) {
                                        orderedIndex[orderedIndex.length] = levels[level].index;
                                        orderedTuples[orderedTuples.length] = levels[level].node;
                                    }
                                }
                            }
                        }
                    }
                    else {
                        for (let key of uniqueLevels) {
                            for (let name of values) {
                                for (let level of levelCollection[key]) {
                                    let levelInfo = level.split('~~');
                                    if (levelInfo[measureIndex] === name) {
                                        orderedIndex[orderedIndex.length] = levels[level].index;
                                        orderedTuples[orderedTuples.length] = levels[level].node;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (vTuples.length > 0) {
                let valueIndex = [];
                let vOrdinalIndex = [];
                let len = 0;
                let cRow = 0;
                for (let j = 0, cnt = vTuples.length; j < cnt; j++) {
                    if (len > (cLen - 1)) {
                        cRow++;
                        len = 0;
                        if (!valueIndex[cRow]) {
                            valueIndex[cRow] = [];
                        }
                        valueIndex[cRow][len] = j;
                        len++;
                    }
                    else {
                        if (!valueIndex[cRow]) {
                            valueIndex[cRow] = [];
                        }
                        valueIndex[cRow][len] = j;
                        len++;
                    }
                    vOrdinalIndex[vOrdinalIndex.length] = Number(vTuples[j].getAttribute('CellOrdinal'));
                }
                if (measureAxis === 'column') {
                    if (valueIndex.length > 0 && valueIndex[0].length === orderedIndex.length) {
                        for (let i = 0, cnt = orderedIndex.length; i < cnt; i++) {
                            let j = 0;
                            while (j < valueIndex.length) {
                                let index = (j * cLen) + i;
                                let ordinalValue = vOrdinalIndex[index].toString();
                                let tuple = vTuples[Number(valueIndex[j][orderedIndex[i]])];
                                tuple.setAttribute('CellOrdinal', ordinalValue.toString());
                                orderedVTuples[index] = tuple;
                                j++;
                            }
                        }
                    }
                }
                else {
                    if (valueIndex.length === orderedIndex.length) {
                        for (let i = 0, cnt = orderedIndex.length; i < cnt; i++) {
                            let j = 0;
                            while (j < valueIndex[orderedIndex[i]].length) {
                                let index = (i * cLen) + j;
                                let ordinalValue = vOrdinalIndex[index].toString();
                                let tuple = vTuples[Number(valueIndex[orderedIndex[i]][j])];
                                tuple.setAttribute('CellOrdinal', ordinalValue.toString());
                                orderedVTuples[orderedVTuples.length] = tuple;
                                j++;
                            }
                        }
                    }
                }
            }
            return { orderedHeaderTuples: orderedTuples, orderedValueTuples: orderedVTuples };
        }
        else {
            return { orderedHeaderTuples: tuples, orderedValueTuples: vTuples };
        }
    }
    /* tslint:disable:max-func-body-length */
    getDrilledSets(uNameCollection, currentCell, fieldPos, axis) {
        let levels = [];
        let memberName = currentCell.actualText.toString();
        let tupCollection = axis === 'row' ? this.tupRowInfo : this.tupColumnInfo;
        let currTuple = tupCollection[currentCell.ordinal];
        let measurePos = tupCollection[0].typeCollection.indexOf('3');
        let allStartPos = measurePos === 0 ? 1 : 0;
        let tupPos = 0;
        let isWithoutAllMember = tupCollection[0].typeCollection[fieldPos] === '1';
        while (tupPos < tupCollection.length) {
            /* tslint:disable-next-line:max-line-length */
            if (isNullOrUndefined(tupCollection[tupPos].allStartPos) || tupCollection[tupPos].allStartPos > allStartPos) {
                levels[levels.length] = tupCollection[tupPos].uNameCollection;
            }
            tupPos++;
        }
        let memberArray = uNameCollection.split('::[').map((item) => {
            return item[0] === '[' ? item : ('[' + item);
        });
        let joinArray = [];
        for (let memPos = 0; memPos <= fieldPos; memPos++) {
            if ((isWithoutAllMember || this.isPaging) && memPos === fieldPos) {
                let splitLevels = memberArray[memPos].split('~~');
                let drillLevel = splitLevels.indexOf(memberName);
                let cropLevels = [];
                for (let lPos = 0; lPos <= drillLevel; lPos++) {
                    cropLevels.push(splitLevels[lPos]);
                }
                joinArray[joinArray.length] = cropLevels.length > 0 ? cropLevels.join('~~') : memberArray[memPos];
            }
            else {
                joinArray[joinArray.length] = memberArray[memPos];
            }
        }
        uNameCollection = joinArray.join('::');
        let childSets = [];
        let memberObj = {};
        for (let item of levels) {
            if (item.indexOf(uNameCollection) === 0) {
                childSets.push(item);
                if (this.isPaging) {
                    let drillField = item.split('::[')[fieldPos];
                    drillField = drillField[0] == '[' ? drillField : ('[' + drillField);
                    let drillFieldSep = drillField.split('~~');
                    for (let fPos = drillFieldSep.indexOf(memberName); fPos < drillFieldSep.length; fPos++) {
                        memberObj[drillFieldSep[fPos]] = drillFieldSep[fPos];
                    }
                }
            }
        }
        if (this.isPaging) {
            let fieldSep = currTuple.uNameCollection.split('::[').map((item) => {
                return item[0] === '[' ? item : ('[' + item);
            });
            let cropArray = [];
            for (let fPos = 0; fPos < fieldSep.length; fPos++) {
                if (fPos !== fieldPos) {
                    cropArray[fPos] = fieldSep[fPos];
                }
            }
            let drillFieldSep = Object.keys(memberObj);
            for (let fPos = 0; fPos < drillFieldSep.length; fPos++) {
                cropArray[fieldPos] = drillFieldSep[fPos];
                childSets.push(cropArray.join('::'));
            }
        }
        let drillSets = {};
        for (let level of childSets) {
            let fields = level.split('::[').map((item) => {
                return item[0] === '[' ? item : ('[' + item);
            });
            let set = '';
            for (let pos = 0; pos <= fieldPos; pos++) {
                let field = fields[pos];
                let members = field.split('~~');
                set = set + (set !== '' ? '~~' : '') + members[members.length - 1];
            }
            drillSets[set] = set;
        }
        return drillSets;
    }
    updateDrilledInfo(dataSourceSettings) {
        this.dataSourceSettings = dataSourceSettings;
        this.drilledMembers = dataSourceSettings.drilledMembers ? this.updateDrilledItems(dataSourceSettings.drilledMembers) : [];
        // MDXQuery.getCellSets(this.dataSourceSettings as IDataOptions, this);
        this.generateGridData(dataSourceSettings);
    }
    updateCalcFields(dataSourceSettings, lastcalcInfo) {
        this.dataSourceSettings = dataSourceSettings;
        this.calculatedFieldSettings = dataSourceSettings.calculatedFieldSettings ? dataSourceSettings.calculatedFieldSettings : [];
        this.getAxisFields();
        this.updateFieldlist();
        this.loadCalculatedMemberElements(this.calculatedFieldSettings);
        if (this.dataFields[lastcalcInfo.name]) {
            this.generateGridData(dataSourceSettings);
        }
        else {
            MDXQuery.getCellSets(dataSourceSettings, this, true, undefined, true);
        }
    }
    onSort(dataSourceSettings) {
        this.dataSourceSettings = dataSourceSettings;
        this.sortSettings = dataSourceSettings.sortSettings ? dataSourceSettings.sortSettings : [];
        this.getAxisFields();
        this.frameSortObject();
        this.updateFieldlist();
        if (this.xmlaCellSet.length > 0 && this.xmlDoc) {
            this.generateEngine(this.xmlDoc, this.request, this.customArgs);
        }
        else {
            this.generateGridData(dataSourceSettings);
        }
    }
    updateFieldlist(isInit) {
        let i = 0;
        while (i < this.savedFieldListData.length) {
            let fieldName = this.savedFieldListData[i].id;
            let parentID = this.savedFieldListData[i].pid;
            // let aggregateType: string = this.getAggregateType(fieldName);
            // this.savedFieldListData[i].aggregateType = aggregateType;
            if (this.savedFieldList[fieldName]) {
                let sortOrder = (this.enableSort ? this.sortObject[fieldName] ? this.sortObject[fieldName] : 'Ascending' : 'None');
                this.savedFieldList[fieldName].isSelected = false;
                this.savedFieldList[fieldName].isExcelFilter = false;
                // this.savedFieldList[fieldName].aggregateType = aggregateType;
                this.savedFieldList[fieldName].sort = sortOrder;
                this.savedFieldListData[i].sort = sortOrder;
                if (isInit) {
                    this.savedFieldList[fieldName].filter = [];
                    this.savedFieldList[fieldName].actualFilter = [];
                }
            }
            if (this.dataFields[fieldName] && this.savedFieldList[fieldName] && this.selectedItems.indexOf(fieldName) > -1) {
                this.savedFieldList[fieldName].isSelected = true;
                this.savedFieldListData[i].isSelected = true;
            }
            else {
                if (this.dataFields[parentID] && this.savedFieldList[parentID] && this.selectedItems.indexOf(parentID) > -1) {
                    this.savedFieldListData[i].isSelected = true;
                }
                else {
                    this.savedFieldListData[i].isSelected = false;
                }
            }
            if ((this.savedFieldList[fieldName] && this.savedFieldList[fieldName].isCalculatedField) ||
                fieldName.toLowerCase() === '[calculated members].[_0]') {
                let isAvail = false;
                for (let field of this.calculatedFieldSettings) {
                    if (fieldName === field.name) {
                        let expression = field.formula;
                        let formatString = field.formatString;
                        this.savedFieldListData[i].formula = expression;
                        this.savedFieldListData[i].formatString = formatString;
                        this.savedFieldListData[i].parentHierarchy = (expression.toLowerCase().indexOf('measure') > -1 ?
                            undefined : field.hierarchyUniqueName);
                        this.savedFieldList[fieldName].formula = expression;
                        this.savedFieldList[fieldName].formatString = formatString;
                        this.savedFieldList[fieldName].parentHierarchy = this.savedFieldListData[i].parentHierarchy;
                        isAvail = true;
                    }
                }
                if (!isAvail || (fieldName.toLowerCase() === '[calculated members].[_0]' &&
                    this.calculatedFieldSettings.length === 0)) {
                    this.savedFieldListData.splice(i, 1);
                    i--;
                    if (this.savedFieldList[fieldName]) {
                        delete this.savedFieldList[fieldName];
                    }
                }
            }
            i++;
        }
        this.fieldList = this.savedFieldList;
        this.fieldListData = this.savedFieldListData;
    }
    updateFieldlistData(name, isSelect) {
        for (let item of this.fieldListData) {
            if (item.id === name) {
                item.isSelected = isSelect ? true : false;
                break;
            }
        }
    }
    getFormattedFields(formats) {
        this.formatFields = {};
        let cnt = formats.length;
        while (cnt--) {
            this.formatFields[formats[cnt].name] = formats[cnt];
        }
    }
    getFieldList(dataSourceSettings) {
        let args = {
            catalog: dataSourceSettings.catalog,
            cube: dataSourceSettings.cube,
            url: dataSourceSettings.url,
            LCID: dataSourceSettings.localeIdentifier.toString(),
            request: 'MDSCHEMA_HIERARCHIES'
        };
        this.getTreeData(args, this.getFieldListItems.bind(this), { dataSourceSettings: dataSourceSettings, action: 'loadFieldElements' });
    }
    getTreeData(args, successMethod, customArgs) {
        let connectionString = this.getConnectionInfo(args.url, args.LCID);
        /* tslint:disable-next-line:max-line-length */
        let soapMessage = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"><Header/><Body><Discover xmlns=\"urn:schemas-microsoft-com:xml-analysis\"><RequestType>' +
            args.request + '</RequestType><Restrictions><RestrictionList><CATALOG_NAME>' + args.catalog +
            /* tslint:disable-next-line:max-line-length */
            '</CATALOG_NAME><CUBE_NAME>' + args.cube + '</CUBE_NAME></RestrictionList></Restrictions><Properties><PropertyList><Catalog>' + args.catalog +
            /* tslint:disable-next-line:max-line-length */
            '</Catalog> <LocaleIdentifier>' + connectionString.LCID + '</LocaleIdentifier></PropertyList></Properties></Discover></Body></Envelope>';
        this.doAjaxPost('POST', connectionString.url, soapMessage, successMethod, customArgs);
    }
    getAxisFields() {
        this.rows = this.dataSourceSettings.rows ? this.dataSourceSettings.rows : [];
        this.columns = this.dataSourceSettings.columns ? this.dataSourceSettings.columns : [];
        this.filters = this.dataSourceSettings.filters ? this.dataSourceSettings.filters : [];
        this.values = this.dataSourceSettings.values ? this.dataSourceSettings.values : [];
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns, this.values, this.filters);
        let len = dataFields.length;
        while (len--) {
            this.dataFields[dataFields[len].name] = dataFields[len];
            if (dataFields[len].name.toLowerCase() === '[measures]') {
                this.isMeasureAvail = true;
            }
            else {
                this.selectedItems.push(dataFields[len].name);
            }
        }
        if (!this.isMeasureAvail && this.values.length > 0) {
            let measureField = { name: '[Measures]', caption: 'Measures' };
            if (this.valueAxis === 'row') {
                this.rows.push(measureField);
            }
            else {
                this.columns.push(measureField);
            }
            this.isMeasureAvail = true;
        }
    }
    getAggregateType(fieldName, aggregateType) {
        let type;
        switch (aggregateType) {
            case '1':
                type = 'Sum';
                break;
            case '2':
                type = 'Count';
                break;
            case '3':
                type = 'Min';
                break;
            case '4':
                type = 'Max';
                break;
            case '5':
                type = 'Avg';
                break;
            case '8':
                type = 'DistinctCount';
                break;
            case '127':
                type = 'CalculatedField';
                break;
            default:
                type = undefined;
                break;
        }
        // if (this.dataFields[fieldName]) {
        //     return this.dataFields[fieldName].type;
        // } else {
        //     return undefined;
        // }
        if (type) {
            return type;
        }
        else {
            return undefined;
        }
    }
    getUniqueName(name) {
        let uName = name;
        for (let item of this.calculatedFieldSettings) {
            let expression = item.formula;
            let prefixName = (expression.toLowerCase().indexOf('measure') > -1 ? '[Measures].' : item.hierarchyUniqueName + '.');
            let uniqueName = prefixName + '[' + item.name + ']';
            if (name === uniqueName) {
                uName = item.name;
                break;
            }
        }
        return uName;
    }
    updateFilterItems(filterItems) {
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns);
        for (let filter of filterItems) {
            if (filter.type === 'Include' && this.allowMemberFilter) {
                let members = this.fieldList[filter.name].members;
                let isMembersAvail = (members && Object.keys(members).length > 0);
                this.fieldList[filter.name].actualFilter = [...filter.items];
                let selectedElements = extend([], filter.items, null, true);
                if (isMembersAvail) {
                    let i = 0;
                    while (i < selectedElements.length) {
                        let parentNodes = [];
                        parentNodes = this.getParentNode(selectedElements[i], members, parentNodes);
                        for (let node of parentNodes) {
                            let index = PivotUtil.inArray(node, filter.items);
                            if (index !== -1) {
                                filter.items.splice(index, 1);
                            }
                        }
                        i++;
                    }
                }
                let currentItems = [];
                for (let selectedElement of filter.items) {
                    // currentItems.push(selectedElement.replace(/\&/g, '&amp;'));
                    currentItems.push(selectedElement);
                    if (isMembersAvail) {
                        this.fieldList[filter.name].filter.push(members[selectedElement].caption);
                    }
                    else {
                        this.fieldList[filter.name].filter.push(selectedElement);
                    }
                }
                this.filterMembers[filter.name] = currentItems;
                this.fieldList[filter.name].isExcelFilter = false;
            }
            else if ((this.allowValueFilter || this.allowLabelFilter) &&
                ['Date', 'Label', 'Number', 'Value'].indexOf(filter.type) !== -1) {
                for (let item of dataFields) {
                    if (item.name === filter.name) {
                        let filterMembers = this.filterMembers[filter.name];
                        if (filterMembers && (typeof filterMembers[0] === 'object' && filterMembers[0].type === filter.type)) {
                            filterMembers[filterMembers.length] = filter;
                        }
                        else {
                            this.filterMembers[filter.name] = [filter];
                        }
                        this.fieldList[filter.name].isExcelFilter = true;
                        break;
                    }
                }
            }
        }
    }
    getParentNode(name, members, items) {
        if (members[name].parent && name !== members[name].parent) {
            let parentItem = members[name].parent;
            items.push(parentItem);
            this.getParentNode(parentItem, members, items);
        }
        return items;
    }
    updateDrilledItems(drilledMembers) {
        let drilledItems = [];
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns);
        for (let item of drilledMembers) {
            for (let field of dataFields) {
                if (item.name === field.name) {
                    drilledItems.push(item);
                    break;
                }
            }
        }
        return drilledItems;
    }
    // private updateAllMembers(dataSourceSettings: IDataOptions, slicers: IFieldOptions[]): void {
    //     let query: string = '';
    //     for (let field of slicers) {
    //         let fieldList: IOlapField = this.fieldList[field.name];
    //         if (!(fieldList && fieldList.hasAllMember && fieldList.allMember)) {
    //             query = query + (query !== '' ? ' * ' : '') + '{' + field.name + '}';
    //         } else {
    //             continue;
    //         }
    //     }
    //     if (query !== '') {
    //         this.getAllMember(dataSourceSettings, query);
    //     } else {
    //         return;
    //     }
    // }
    // private getAllMember(dataSourceSettings: IDataOptions, query: string): void {
    //     let dimProp: string = 'DIMENSION PROPERTIES HIERARCHY_UNIQUE_NAME, CHILDREN_CARDINALITY';
    //     let mdxQuery: string = 'SELECT (' + query + ')' + dimProp + ' ON 0 FROM [' + dataSourceSettings.cube + ']';
    //     let xmla: string = this.getSoapMsg(dataSourceSettings, mdxQuery);
    //     let connectionString: ConnectionInfo = this.getConnectionInfo(dataSourceSettings.url, dataSourceSettings.localeIdentifier);
    //     /* tslint:disable-next-line:max-line-length */
    //     this.doAjaxPost('POST', connectionString.url, xmla, this.generateAllMembers.bind(this), 
    // { dataSourceSettings: dataSourceSettings, action: 'fetchAllMembers' });
    // }
    /**
     * @hidden
     */
    getDrillThroughData(pivotValue, maxRows) {
        let column = this.tupColumnInfo[pivotValue.colOrdinal] &&
            this.tupColumnInfo[pivotValue.colOrdinal].uNameCollection &&
            this.tupColumnInfo[pivotValue.colOrdinal].uNameCollection !== '' ?
            this.tupColumnInfo[pivotValue.colOrdinal].uNameCollection.split('::[').map((item) => {
                return item[0] === '[' ? item : ('[' + item);
            }) : [];
        let row = this.tupRowInfo[pivotValue.rowOrdinal] &&
            this.tupRowInfo[pivotValue.rowOrdinal].uNameCollection &&
            this.tupRowInfo[pivotValue.rowOrdinal].uNameCollection !== '' ?
            this.tupRowInfo[pivotValue.rowOrdinal].uNameCollection.split('::[').map((item) => {
                return item[0] === '[' ? item : ('[' + item);
            }) : [];
        let columnQuery = '';
        let rowQuery = '';
        for (let i = 0; i < column.length; i++) {
            columnQuery = (columnQuery.length > 0 ? (columnQuery + ',') : '') + (column[i].split('~~').length > 1 ?
                column[i].split('~~')[column[i].split('~~').length - 1] : column[i]);
        }
        for (let i = 0; i < row.length; i++) {
            rowQuery = (rowQuery.length > 0 ? (rowQuery + ',') : '') + (row[i].split('~~').length > 1 ?
                row[i].split('~~')[row[i].split('~~').length - 1] : row[i]);
        }
        let drillQuery = 'DRILLTHROUGH MAXROWS ' + maxRows + ' Select(' + (columnQuery.length > 0 ? columnQuery : '') +
            (columnQuery.length > 0 && rowQuery.length > 0 ? ',' : '') + (rowQuery.length > 0 ? rowQuery : '') + ') on 0 from [' +
            this.dataSourceSettings.cube + ']';
        drillQuery = drillQuery.replace(/&/g, '&amp;');
        let xmla = this.getSoapMsg(this.dataSourceSettings, drillQuery);
        let connectionString = this.getConnectionInfo(this.dataSourceSettings.url, this.dataSourceSettings.localeIdentifier);
        this.doAjaxPost('POST', connectionString.url, xmla, this.drillThroughSuccess.bind(this), { dataSourceSettings: this.dataSourceSettings, action: 'drillThrough' });
    }
    drillThroughSuccess(xmlDoc) {
        let tag = [].slice.call(xmlDoc.querySelectorAll('row'));
        let gridJSON = '';
        if (tag.length > 0) {
            let json = [];
            let i = 0;
            while (i < tag.length) {
                let child = [].slice.call(tag[i].children);
                let j = 0;
                while (j < child.length) {
                    json.push('"' + child[j].tagName + '"' + ':' + '"' + child[j].textContent + '"');
                    j++;
                }
                i++;
            }
            let value = json[0];
            let k = 0;
            while (k < json.length) {
                if (Object.keys(JSON.parse('[{' + json[k] + '}]')[0])[0] === Object.keys(JSON.parse('[{' + value + '}]')[0])[0]) {
                    gridJSON += gridJSON === '' ? '[{' + json[k] : '}, {' + json[k];
                    k++;
                    continue;
                }
                gridJSON += ',' + json[k];
                k++;
            }
            gridJSON += '}]';
        }
        else {
            let tag = [].slice.call(xmlDoc.querySelectorAll('faultstring'));
            let i = 0;
            while (i < tag.length) {
                gridJSON += tag[i].textContent;
                i++;
            }
        }
        this.gridJSON = gridJSON;
    }
    /* tslint:disable-next-line:max-line-length */
    getFilterMembers(dataSourceSettings, fieldName, levelCount, isSearchFilter, loadLevelMember) {
        // let dimProp: string = 'DIMENSION PROPERTIES PARENT_UNIQUE_NAME, HIERARCHY_UNIQUE_NAME, CHILDREN_CARDINALITY, MEMBER_TYPE';
        let levels = this.fieldList[fieldName].levels;
        let cLevel = this.fieldList[fieldName].levelCount;
        let filterQuery;
        if (loadLevelMember) {
            filterQuery = 'Descendants({' + levels[cLevel].id + '}, ' +
                levels[levelCount - 1].id + ', ' + ((levelCount - cLevel) === 1 ? 'SELF)' : 'SELF_AND_BEFORE)');
        }
        else {
            filterQuery = fieldName + ', Descendants({' + levels[0].id + '}, ' + levels[levelCount - 1].id + ', SELF_AND_BEFORE)';
        }
        this.fieldList[fieldName].levelCount = levelCount;
        if (!isSearchFilter) {
            this.getMembers(dataSourceSettings, fieldName, false, filterQuery, loadLevelMember);
        }
        return filterQuery;
    }
    /* tslint:disable-next-line:max-line-length */
    getMembers(dataSourceSettings, fieldName, isAllFilterData, filterParentQuery, loadLevelMember) {
        // dimProp = "dimension properties CHILDREN_CARDINALITY, MEMBER_TYPE";
        /* tslint:disable-next-line:max-line-length */
        let dimProp = 'DIMENSION PROPERTIES PARENT_UNIQUE_NAME, HIERARCHY_UNIQUE_NAME, CHILDREN_CARDINALITY, MEMBER_TYPE, MEMBER_VALUE';
        let mdxQuery;
        let hasAllMember = this.fieldList[fieldName].hasAllMember;
        let hierarchy = (hasAllMember ? fieldName : fieldName + '.LEVELS(0)').replace(/\&/g, '&amp;');
        if (!isAllFilterData) {
            mdxQuery = 'SELECT ({' + (filterParentQuery ?
                filterParentQuery : (hasAllMember ? hierarchy + ', ' + hierarchy + '.CHILDREN' : hierarchy + '.ALLMEMBERS')) + '})' +
                dimProp + ' ON 0 FROM [' + dataSourceSettings.cube + ']';
        }
        else {
            mdxQuery = 'SELECT ({' + hierarchy + '.ALLMEMBERS})' + dimProp + ' ON 0 FROM [' + dataSourceSettings.cube + ']';
        }
        let xmla = this.getSoapMsg(dataSourceSettings, mdxQuery);
        let connectionString = this.getConnectionInfo(dataSourceSettings.url, dataSourceSettings.localeIdentifier);
        if (!loadLevelMember) {
            this.fieldList[fieldName].filterMembers = [];
            this.fieldList[fieldName].childMembers = [];
            this.fieldList[fieldName].searchMembers = [];
            // this.fieldList[fieldName].isHierarchy = true;
            this.fieldList[fieldName].members = {};
            this.fieldList[fieldName].currrentMembers = {};
            /* tslint:disable-next-line:max-line-length */
        }
        this.doAjaxPost('POST', connectionString.url, xmla, this.generateMembers.bind(this), { dataSourceSettings: dataSourceSettings, fieldName: fieldName, loadLevelMembers: loadLevelMember, action: 'fetchMembers' });
    }
    getChildMembers(dataSourceSettings, memberUQName, fieldName) {
        // dimProp = "dimension properties CHILDREN_CARDINALITY, MEMBER_TYPE";
        /* tslint:disable-next-line:max-line-length */
        let dimProp = 'DIMENSION PROPERTIES PARENT_UNIQUE_NAME, HIERARCHY_UNIQUE_NAME, CHILDREN_CARDINALITY, MEMBER_TYPE, MEMBER_VALUE';
        /* tslint:disable-next-line:max-line-length */
        // var mdxQuery = 'SELECT SUBSET({' + memberUQName + '.CHILDREN}, 0, 5000)' + dimProp + ' ON 0 FROM [' + dataSourceSettings.cube + ']';
        /* tslint:disable-next-line:max-line-length */
        let mdxQuery = 'SELECT ({' + memberUQName.replace(/\&/g, '&amp;') + '.CHILDREN})' + dimProp + ' ON 0 FROM [' + dataSourceSettings.cube + ']';
        let xmla = this.getSoapMsg(dataSourceSettings, mdxQuery);
        let connectionString = this.getConnectionInfo(dataSourceSettings.url, dataSourceSettings.localeIdentifier);
        /* tslint:disable-next-line:max-line-length */
        this.doAjaxPost('POST', connectionString.url, xmla, this.generateMembers.bind(this), { dataSourceSettings: dataSourceSettings, fieldName: fieldName, action: 'fetchChildMembers' });
    }
    getCalcChildMembers(dataSourceSettings, memberUQName) {
        this.calcChildMembers = [];
        /* tslint:disable-next-line:max-line-length */
        let dimProp = 'DIMENSION PROPERTIES PARENT_UNIQUE_NAME, HIERARCHY_UNIQUE_NAME, CHILDREN_CARDINALITY, MEMBER_TYPE, MEMBER_VALUE';
        let mdxQuery = 'SELECT ({' + memberUQName.replace(/\&/g, '&amp;') + '.MEMBERS})' +
            dimProp + ' ON 0 FROM [' + dataSourceSettings.cube + ']';
        let connectionString = this.getConnectionInfo(dataSourceSettings.url, dataSourceSettings.localeIdentifier);
        let xmla = this.getSoapMsg(dataSourceSettings, mdxQuery);
        /* tslint:disable-next-line:max-line-length */
        this.doAjaxPost('POST', connectionString.url, xmla, this.generateMembers.bind(this), { dataSourceSettings: dataSourceSettings, action: 'fetchCalcChildMembers' });
    }
    /* tslint:disable-next-line:max-line-length */
    getSearchMembers(dataSourceSettings, fieldName, searchString, maxNodeLimit, isAllFilterData, levelCount) {
        this.fieldList[fieldName].searchMembers = [];
        this.fieldList[fieldName].currrentMembers = {};
        if (searchString !== '') {
            // dimProp = "dimension properties CHILDREN_CARDINALITY, MEMBER_TYPE";
            /* tslint:disable-next-line:max-line-length */
            let dimProp = 'DIMENSION PROPERTIES PARENT_UNIQUE_NAME, HIERARCHY_UNIQUE_NAME, CHILDREN_CARDINALITY, MEMBER_TYPE, MEMBER_VALUE';
            let hierarchy = fieldName.replace(/\&/g, '&amp;');
            let mdxQuery = 'WITH SET [SearchMembersSet] AS &#39;FILTER(' + (isAllFilterData ? hierarchy + '.ALLMEMBERS, ' :
                '{' + (levelCount > 1 ? this.getFilterMembers(dataSourceSettings, fieldName, levelCount, true) :
                    hierarchy + ', ' + hierarchy + '.CHILDREN') + '},') +
                '(INSTR(1, ' + hierarchy + '.CurrentMember.member_caption, "' + searchString + '") > 0))&#39;' +
                'SET [SearchParentsSet] AS &#39;GENERATE([SearchMembersSet], ASCENDANTS([SearchMembersSet].Current))&#39;' +
                'SET [SearchSet] AS &#39;HIERARCHIZE(DISTINCT({[SearchMembersSet], [SearchParentsSet]}))&#39;' +
                'SELECT SUBSET([SearchSet], 0, ' + maxNodeLimit + ')' + dimProp + ' ON 0 FROM [' + dataSourceSettings.cube + ']';
            let xmla = this.getSoapMsg(dataSourceSettings, mdxQuery);
            let connectionString = this.getConnectionInfo(dataSourceSettings.url, dataSourceSettings.localeIdentifier);
            /* tslint:disable-next-line:max-line-length */
            this.doAjaxPost('POST', connectionString.url, xmla, this.generateMembers.bind(this), { dataSourceSettings: dataSourceSettings, fieldName: fieldName, action: 'fetchSearchMembers' });
        }
        else {
            return;
        }
    }
    generateMembers(xmlDoc, request, customArgs) {
        let fields = [].slice.call(xmlDoc.querySelectorAll('Axis[name="Axis0"] Tuple'));
        let fieldName = customArgs.fieldName;
        let allMember;
        let filterMembers = {};
        for (let field of fields) {
            // let hierarchyUqName: string = fields[0].querySelector('Member HIERARCHY_UNIQUE_NAME').textContent;
            let member = field.querySelector('Member');
            let memberType = member.querySelector('MEMBER_TYPE').textContent;
            let memberUqName = member.querySelector('UName').textContent;
            let caption = member.querySelector('Caption').textContent;
            let nodeAttr = { 'data-fieldName': fieldName };
            /* tslint:disable-next-line:max-line-length */
            let parentUqName = member.querySelector('PARENT_UNIQUE_NAME') ? member.querySelector('PARENT_UNIQUE_NAME').textContent : '';
            if (parentUqName === '' && memberType === '1') {
                filterMembers = {
                    /* tslint:disable-next-line:max-line-length */
                    hasChildren: (field.querySelector('CHILDREN_CARDINALITY') ? (field.querySelector('CHILDREN_CARDINALITY').textContent !== '0') ? true : false : false),
                    isSelected: false,
                    id: memberUqName,
                    tag: memberUqName,
                    name: caption,
                    caption: caption,
                    htmlAttributes: nodeAttr
                };
                if (customArgs.action === 'fetchMembers' || customArgs.action === 'fetchChildMembers') {
                    /* tslint:disable-next-line:max-line-length */
                    this.fieldList[fieldName].members[memberUqName] = { name: memberUqName, caption: caption, parent: undefined, isNodeExpand: false, isSelected: false };
                    this.fieldList[fieldName].filterMembers.push(filterMembers);
                    this.fieldList[fieldName].childMembers.push(filterMembers);
                }
                else if (customArgs.action === 'fetchSearchMembers') {
                    /* tslint:disable-next-line:max-line-length */
                    this.fieldList[fieldName].currrentMembers[memberUqName] = { name: memberUqName, caption: caption, parent: undefined, isNodeExpand: false, isSelected: false };
                    this.fieldList[fieldName].searchMembers.push(filterMembers);
                    filterMembers.expanded = true;
                }
                else {
                    this.calcChildMembers.push(filterMembers);
                }
            }
            else if (parentUqName !== '' && memberType === '1') {
                if (parentUqName === allMember && memberType === '1') {
                    filterMembers = {
                        /* tslint:disable-next-line:max-line-length */
                        hasChildren: (field.querySelector('CHILDREN_CARDINALITY') ? (field.querySelector('CHILDREN_CARDINALITY').textContent !== '0') ? true : false : false),
                        id: memberUqName,
                        name: caption,
                        isSelected: false,
                        caption: caption,
                        htmlAttributes: nodeAttr,
                        tag: memberUqName
                    };
                    if (customArgs.action === 'fetchMembers' || customArgs.action === 'fetchChildMembers') {
                        this.fieldList[fieldName].filterMembers.push(filterMembers);
                        this.fieldList[fieldName].childMembers.push(filterMembers);
                        /* tslint:disable-next-line:max-line-length */
                        this.fieldList[fieldName].members[memberUqName] = { name: memberUqName, caption: caption, parent: undefined, isNodeExpand: false, isSelected: false };
                    }
                    else if (customArgs.action === 'fetchSearchMembers') {
                        filterMembers.expanded = true;
                        this.fieldList[fieldName].searchMembers.push(filterMembers);
                        /* tslint:disable-next-line:max-line-length */
                        this.fieldList[fieldName].currrentMembers[memberUqName] = { name: memberUqName, caption: caption, parent: undefined, isNodeExpand: false, isSelected: false };
                    }
                    else {
                        this.calcChildMembers.push(filterMembers);
                    }
                }
                else {
                    if (customArgs.action === 'fetchMembers' && this.fieldList[fieldName].members[memberUqName]) {
                        continue;
                    }
                    /* tslint:disable-next-line:max-line-length */
                    let nodeSelect = (customArgs.loadLevelMembers ? this.fieldList[fieldName].members[parentUqName].isSelected : false);
                    filterMembers = {
                        /* tslint:disable-next-line:max-line-length */
                        hasChildren: (field.querySelector('CHILDREN_CARDINALITY') ? (field.querySelector('CHILDREN_CARDINALITY').textContent !== '0') ? true : false : false),
                        htmlAttributes: nodeAttr,
                        isSelected: false,
                        id: memberUqName,
                        pid: parentUqName,
                        name: caption,
                        caption: caption,
                        tag: memberUqName
                    };
                    if (customArgs.action === 'fetchMembers' || customArgs.action === 'fetchChildMembers') {
                        this.fieldList[fieldName].isHierarchy = false;
                        this.fieldList[fieldName].filterMembers.push(filterMembers);
                        this.fieldList[fieldName].childMembers.push(filterMembers);
                        /* tslint:disable-next-line:max-line-length */
                        this.fieldList[fieldName].members[memberUqName] = { name: memberUqName, caption: caption, parent: parentUqName, isNodeExpand: false, isSelected: nodeSelect };
                    }
                    else if (customArgs.action === 'fetchSearchMembers') {
                        this.fieldList[fieldName].searchMembers.push(filterMembers);
                        filterMembers.expanded = true;
                        /* tslint:disable-next-line:max-line-length */
                        this.fieldList[fieldName].currrentMembers[memberUqName] = { name: memberUqName, caption: caption, parent: parentUqName, isNodeExpand: false, isSelected: false };
                    }
                    else {
                        this.calcChildMembers.push(filterMembers);
                    }
                }
            }
            else if (memberType === '2') {
                allMember = memberUqName;
            }
        }
    }
    // private generateAllMembers(xmlDoc: Document, request: Ajax, customArgs: FieldData): void {
    //     let members: HTMLElement[] = [].slice.call(xmlDoc.querySelectorAll('Axis[name="Axis0"] Member'));
    //     for (let member of members) {
    //         let caption: string = member.querySelector('Caption').textContent;
    //         let fieldName: string = member.querySelector('HIERARCHY_UNIQUE_NAME').textContent;
    //         this.fieldList[fieldName].allMember = caption;
    //     }
    // }
    getFieldListItems(xmlDoc, request, customArgs) {
        let fieldDate = {};
        let hierarchyElements = [];
        let fields = [].slice.call(xmlDoc.querySelectorAll('row'));
        for (let field of fields) {
            let isAllMemberAvail = [].slice.call(field.querySelectorAll('ALL_MEMBER')).length > 0;
            hierarchyElements.push({
                pid: field.querySelector('DIMENSION_UNIQUE_NAME').textContent,
                id: field.querySelector('HIERARCHY_UNIQUE_NAME').textContent,
                name: field.querySelector('HIERARCHY_CAPTION').textContent,
                caption: field.querySelector('HIERARCHY_CAPTION').textContent,
                tag: field.querySelector('HIERARCHY_UNIQUE_NAME').textContent,
                hasAllMember: isAllMemberAvail,
                allMember: (isAllMemberAvail ? field.querySelectorAll('ALL_MEMBER')[0].textContent : undefined),
                // aggregateType: this.getAggregateType(field.querySelector('HIERARCHY_UNIQUE_NAME').textContent),
                type: 'string'
            });
        }
        fieldDate = {
            hierarchy: hierarchyElements,
            hierarchySuccess: xmlDoc,
            measures: []
        };
        this.fieldListObj = fieldDate;
        let args = {
            catalog: customArgs.dataSourceSettings.catalog,
            cube: customArgs.dataSourceSettings.cube,
            url: customArgs.dataSourceSettings.url,
            LCID: customArgs.dataSourceSettings.localeIdentifier.toString(),
            request: 'MDSCHEMA_DIMENSIONS'
        };
        this.getTreeData(args, this.loadDimensionElements.bind(this), customArgs);
    }
    loadCalculatedMemberElements(calcMembers) {
        if (calcMembers.length > 0) {
            let fieldListElements = this.fieldListData;
            // let calcElements: IOlapField[] = [];
            let calcObj = {
                hasChildren: true,
                isSelected: false,
                id: '[Calculated Members].[_0]',
                name: '[Calculated Members].[_0]',
                caption: 'Calculated Members',
                spriteCssClass: 'e-calcMemberGroupCDB' + ' ' + ICON,
                tag: '[Calculated Members].[_0]',
                //aggregateType: this.getAggregateType(dimensionName),
                type: 'string'
            };
            if (fieldListElements.length > 0 && fieldListElements[0].id.toLowerCase() === '[measures]') {
                fieldListElements.splice(0, 0, calcObj);
            }
            for (let field of calcMembers) {
                if (!this.fieldList[field.name]) {
                    let expression = field.formula;
                    let prefixName = (expression.toLowerCase().indexOf('measure') > -1 ? '[Measures].' :
                        field.hierarchyUniqueName + '.');
                    let uniqueName = prefixName + '[' + field.name + ']';
                    let caption = (this.dataFields[field.name] && this.dataFields[field.name].caption ?
                        this.dataFields[field.name].caption : field.name);
                    let formatString = field.formatString;
                    let calcField = {
                        hasChildren: false,
                        isSelected: false,
                        id: field.name,
                        pid: '[Calculated Members].[_0]',
                        name: field.name,
                        caption: caption,
                        spriteCssClass: 'e-calc-member' + ' ' + (expression.toLowerCase().indexOf('measure') > -1 ?
                            'e-calc-measure-icon' : 'e-calc-dimension-icon') + ' ' + ICON,
                        tag: uniqueName,
                        formula: expression,
                        formatString: formatString,
                        aggregateType: undefined,
                        type: 'CalculatedField',
                        filter: [],
                        dateMember: [],
                        sort: 'Ascending',
                        actualFilter: [],
                        filterMembers: [],
                        childMembers: [],
                        searchMembers: [],
                        members: {},
                        currrentMembers: {},
                        isHierarchy: true,
                        isExcelFilter: false,
                        isCalculatedField: true,
                        fieldType: (expression.toLowerCase().indexOf('measure') > -1 ? 'Measure' : 'Dimension'),
                        parentHierarchy: (expression.toLowerCase().indexOf('measure') > -1 ? undefined : field.hierarchyUniqueName),
                    };
                    fieldListElements.push(calcField);
                    this.fieldList[calcField.id] = calcField;
                }
            }
        }
        else {
            return;
        }
    }
    loadDimensionElements(xmlDoc, request, customArgs) {
        let hierarchyElements = [];
        let fields = [].slice.call(xmlDoc.querySelectorAll('row'));
        let measure = {};
        for (let field of fields) {
            let dimensionName = field.querySelector('DIMENSION_UNIQUE_NAME').textContent;
            let dimensionCaption = field.querySelector('DIMENSION_CAPTION').textContent;
            if (dimensionName.toLowerCase().indexOf('[measure') >= 0) {
                measure = {
                    hasChildren: true,
                    isSelected: false,
                    id: dimensionName,
                    name: dimensionName,
                    caption: dimensionCaption,
                    /* tslint:disable-next-line:max-line-length */
                    spriteCssClass: dimensionName.toLowerCase() === '[measures]' ? 'e-measureGroupCDB-icon' + ' ' + ICON : 'e-dimensionCDB-icon' + ' ' + ICON,
                    tag: dimensionName,
                    // aggregateType: this.getAggregateType(dimensionName),
                    type: 'string'
                };
            }
            else if (isNullOrUndefined(fields[0].querySelector('HIERARCHY_CAPTION'))) {
                hierarchyElements.push({
                    hasChildren: true,
                    isSelected: false,
                    id: (this.isMondrian ? dimensionName + '~#^Dim' : dimensionName),
                    name: dimensionName,
                    caption: dimensionCaption,
                    spriteCssClass: 'e-dimensionCDB-icon' + ' ' + ICON,
                    tag: dimensionName,
                    defaultHierarchy: field.querySelector('DEFAULT_HIERARCHY').textContent,
                    // aggregateType: this.getAggregateType(dimensionName),
                    type: 'string'
                });
            }
        }
        hierarchyElements.splice(0, 0, measure);
        this.fieldListData = hierarchyElements;
        // customArgs.hierarchy = this.fieldListData;
        // customArgs.hierarchySuccess = this.fieldListObj.hierarchySuccess;
        // this.loadHierarchyElements(customArgs);
        let args = {
            catalog: customArgs.dataSourceSettings.catalog,
            cube: customArgs.dataSourceSettings.cube,
            url: customArgs.dataSourceSettings.url,
            LCID: customArgs.dataSourceSettings.localeIdentifier.toString(),
            request: 'MDSCHEMA_SETS'
        };
        this.getTreeData(args, this.loadNamedSetElements.bind(this), customArgs);
    }
    loadNamedSetElements(xmlDoc, request, customArgs) {
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns, this.filters);
        let dimensionElements = this.fieldListData;
        let reportElement = [];
        for (let field of dataFields) {
            reportElement.push(field.name);
        }
        let measureGroupItems = [];
        let fields = [].slice.call(xmlDoc.querySelectorAll('row'));
        for (let field of fields) {
            if (!(measureGroupItems.indexOf(field.querySelector('DIMENSIONS').textContent.split('.')[0]) >= 0)) {
                dimensionElements.push({
                    hasChildren: true,
                    isSelected: false,
                    pid: field.querySelector('DIMENSIONS').textContent.split('.')[0],
                    /* tslint:disable-next-line:max-line-length */
                    id: field.querySelector('SET_DISPLAY_FOLDER').textContent + '_' + field.querySelector('DIMENSIONS').textContent.split('.')[0],
                    name: field.querySelector('SET_DISPLAY_FOLDER').textContent,
                    spriteCssClass: 'e-folderCDB-icon' + ' ' + ICON + ' ' + 'namedSets',
                    caption: field.querySelector('SET_DISPLAY_FOLDER').textContent,
                    /* tslint:disable-next-line:max-line-length */
                    // aggregateType: this.getAggregateType(field.querySelector('SET_DISPLAY_FOLDER').textContent + '_' + field.querySelector('DIMENSIONS').textContent.split('.')[0]),
                    type: 'string'
                });
                measureGroupItems.push(field.querySelector('DIMENSIONS').textContent.split('.')[0]);
            }
            let id = '[' + field.querySelector('SET_NAME').textContent.trim() + ']';
            let fieldObj = {
                hasChildren: true,
                isNamedSets: true,
                isSelected: (reportElement.indexOf('[' + field.querySelector('SET_NAME').textContent + ']') >= 0),
                /* tslint:disable-next-line:max-line-length */
                pid: field.querySelector('SET_DISPLAY_FOLDER').textContent + '_' + field.querySelector('DIMENSIONS').textContent.split('.')[0],
                id: id,
                name: field.querySelector('SET_CAPTION').textContent,
                caption: field.querySelector('SET_CAPTION').textContent,
                spriteCssClass: 'e-namedSetCDB-icon' + ' ' + ICON,
                tag: field.querySelector('EXPRESSION').textContent,
                // aggregateType: this.getAggregateType(id),
                type: 'string',
                filter: [],
                dateMember: [],
                // sort: 'Ascending',
                actualFilter: [],
                filterMembers: [],
                childMembers: [],
                searchMembers: [],
                members: {},
                currrentMembers: {},
                isHierarchy: true,
                isExcelFilter: false
            };
            dimensionElements.push(fieldObj);
            this.fieldList[id] = fieldObj;
        }
        // let args: ConnectionInfo = {
        //     catalog: customArgs.dataSourceSettings.catalog,
        //     cube: customArgs.dataSourceSettings.cube,
        //     url: customArgs.dataSourceSettings.url,
        //     LCID: customArgs.dataSourceSettings.localeIdentifier.toString(),
        //     request: 'MDSCHEMA_SETS'
        // };
        // this.getTreeData(args, this.loadHierarchyElements.bind(this), customArgs);
        customArgs.hierarchy = this.fieldListData;
        customArgs.hierarchySuccess = this.fieldListObj.hierarchySuccess;
        this.loadHierarchyElements(customArgs);
    }
    loadHierarchyElements(customArgs) {
        let data = customArgs.hierarchySuccess;
        let dimensionElements = customArgs.hierarchy;
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns, this.filters);
        let reportElement = [];
        for (let field of dataFields) {
            reportElement.push(field.name);
        }
        let fields = [].slice.call(data.querySelectorAll('row'));
        for (let field of fields) {
            let dimensionName = field.querySelector('DIMENSION_UNIQUE_NAME').textContent;
            let hierarchyName = field.querySelector('HIERARCHY_UNIQUE_NAME').textContent;
            let isAllMemberAvail = [].slice.call(field.querySelectorAll('ALL_MEMBER')).length > 0;
            let allMember;
            if (isAllMemberAvail) {
                let stringCollection = field.querySelectorAll('ALL_MEMBER')[0].textContent.replace(/[\[\]\&']+/g, '').split('.');
                allMember = stringCollection[stringCollection.length - 1].trim();
            }
            else {
                allMember = undefined;
            }
            /* tslint:disable-next-line:max-line-length */
            let hierarchyFolderName = ((field.querySelector('HIERARCHY_DISPLAY_FOLDER')) ? (field.querySelector('HIERARCHY_DISPLAY_FOLDER').textContent) : '');
            let curElement = [];
            for (let item of dimensionElements) {
                if (item.tag === dimensionName) {
                    curElement.push(item);
                }
            }
            if (curElement.length > 0 && (dimensionName !== hierarchyName || this.isMondrian)) {
                let parentID = dimensionName + (this.isMondrian ? '~#^Dim' : '');
                if (hierarchyFolderName !== '') {
                    let folderName = dimensionName + (this.isMondrian ? '~#^Dim' : '') + '_' + hierarchyFolderName;
                    let curParentElement = [];
                    for (let item of dimensionElements) {
                        if (item.tag === folderName && item.pid === parentID) {
                            curParentElement.push(item);
                        }
                    }
                    if (curParentElement.length === 0) {
                        let fieldObj = {
                            hasChildren: true,
                            isSelected: false,
                            pid: dimensionName + (this.isMondrian ? '~#^Dim' : ''),
                            id: folderName,
                            name: hierarchyFolderName,
                            spriteCssClass: 'e-folderCDB-icon' + ' ' + ICON,
                            tag: folderName,
                            caption: hierarchyFolderName,
                            // aggregateType: this.getAggregateType(hierarchyFolderName),
                            type: 'string'
                        };
                        dimensionElements.push(fieldObj);
                    }
                    parentID = folderName;
                }
                let fieldObj = {
                    /* tslint:disable-next-line:max-line-length */
                    hasChildren: (field.querySelector('HIERARCHY_ORIGIN') ? ((field.querySelector('HIERARCHY_ORIGIN').textContent !== '2') && field.querySelector('HIERARCHY_ORIGIN').textContent !== '6') ? true : false : true),
                    // hasChildren: true,
                    isSelected: (reportElement.indexOf(hierarchyName) >= 0),
                    pid: parentID,
                    id: hierarchyName,
                    name: field.querySelector('HIERARCHY_CAPTION').textContent,
                    /* tslint:disable-next-line:max-line-length */
                    spriteCssClass: (field.querySelector('HIERARCHY_ORIGIN') ? ((field.querySelector('HIERARCHY_ORIGIN').textContent !== '2') && field.querySelector('HIERARCHY_ORIGIN').textContent !== '6') ? 'e-hierarchyCDB-icon' : 'e-attributeCDB-icon' : 'e-hierarchyCDB-icon') + ' ' + ICON,
                    hasAllMember: isAllMemberAvail,
                    allMember: allMember,
                    tag: hierarchyName,
                    caption: field.querySelector('HIERARCHY_CAPTION').textContent,
                    // aggregateType: this.getAggregateType(hierarchyName),
                    type: 'string',
                    filter: [],
                    dateMember: [],
                    sort: (this.enableSort ? this.sortObject[hierarchyName] ? this.sortObject[hierarchyName] : 'Ascending' : 'None'),
                    actualFilter: [],
                    filterMembers: [],
                    childMembers: [],
                    searchMembers: [],
                    members: {},
                    currrentMembers: {},
                    levels: [],
                    levelCount: 1,
                    /* tslint:disable-next-line:max-line-length */
                    isHierarchy: (field.querySelector('HIERARCHY_ORIGIN') ? ((field.querySelector('HIERARCHY_ORIGIN').textContent !== '2') && field.querySelector('HIERARCHY_ORIGIN').textContent !== '6') ? false : true : false),
                    isExcelFilter: false
                };
                dimensionElements.push(fieldObj);
                this.fieldList[hierarchyName] = fieldObj;
            }
        }
        let args = {
            catalog: customArgs.dataSourceSettings.catalog,
            cube: customArgs.dataSourceSettings.cube,
            url: customArgs.dataSourceSettings.url,
            LCID: customArgs.dataSourceSettings.localeIdentifier.toString(),
            request: 'MDSCHEMA_LEVELS'
        };
        this.getTreeData(args, this.loadLevelElements.bind(this), customArgs);
    }
    loadLevelElements(xmlDoc, request, customArgs) {
        let newDataSource = [];
        let dimensionElements = this.fieldListData;
        newDataSource = [];
        let fields = [].slice.call(xmlDoc.querySelectorAll('row'));
        for (let field of fields) {
            /* tslint:disable-next-line:max-line-length */
            if (parseInt(field.querySelector('LEVEL_TYPE').textContent, 10) !== 1 && field.querySelector('HIERARCHY_UNIQUE_NAME').textContent.toLowerCase() !== '[measures]') {
                let dimensionName = field.querySelector('HIERARCHY_UNIQUE_NAME').textContent;
                let levelName = field.querySelector('LEVEL_UNIQUE_NAME').textContent;
                let levelCaption = field.querySelector('LEVEL_CAPTION').textContent;
                let levelObj = {
                    hasChildren: false,
                    isChecked: false,
                    isSelected: this.fieldList[dimensionName].isSelected,
                    pid: dimensionName,
                    id: levelName,
                    name: levelCaption,
                    tag: levelName,
                    /* tslint:disable-next-line:max-line-length */
                    spriteCssClass: 'e-level-members e-hierarchy-level-' + parseInt(field.querySelector('LEVEL_NUMBER').textContent, 10) + '-icon' + ' ' + ICON,
                    caption: levelCaption,
                    // aggregateType: this.getAggregateType(levelName),
                    type: 'string'
                };
                newDataSource.push(levelObj);
                if (this.fieldList[dimensionName] && this.fieldList[dimensionName].spriteCssClass &&
                    this.fieldList[dimensionName].spriteCssClass.indexOf('e-attributeCDB-icon') === -1) {
                    this.fieldList[dimensionName].levels.push(levelObj);
                    this.fieldList[dimensionName].isHierarchy = false;
                }
                else {
                    this.fieldList[dimensionName].isHierarchy = true;
                }
            }
        }
        this.fieldListData = dimensionElements = dimensionElements.concat(newDataSource);
        let args = {
            catalog: customArgs.dataSourceSettings.catalog,
            cube: customArgs.dataSourceSettings.cube,
            url: customArgs.dataSourceSettings.url,
            LCID: customArgs.dataSourceSettings.localeIdentifier.toString(),
            request: 'MDSCHEMA_MEASURES'
        };
        this.getTreeData(args, this.loadMeasureElements.bind(this), customArgs);
    }
    loadMeasureElements(xmlDoc, request, customArgs) {
        let dimensionElements = this.fieldListData;
        let measureGroupItems = [];
        let caption;
        let dataFields = extend([], this.values, null, true);
        let reportElement = [];
        for (let field of dataFields) {
            reportElement.push(field.name);
        }
        if (this.locale !== 'en-US') {
            let args = {
                catalog: customArgs.dataSourceSettings.catalog,
                cube: customArgs.dataSourceSettings.cube,
                url: customArgs.dataSourceSettings.url,
                LCID: customArgs.dataSourceSettings.localeIdentifier.toString(),
                request: 'MDSCHEMA_MEASUREGROUPS'
            };
            this.getTreeData(args, this.loadMeasureGroups.bind(this), customArgs);
        }
        let fields = [].slice.call(xmlDoc.querySelectorAll('row'));
        for (let field of fields) {
            /* tslint:disable-next-line:max-line-length */
            let measureGRPName = isNullOrUndefined(field.querySelector('MEASUREGROUP_NAME')) ? '' : field.querySelector('MEASUREGROUP_NAME').textContent;
            let measureName = field.querySelector('MEASURE_UNIQUE_NAME').textContent;
            let formatString = field.querySelector('DEFAULT_FORMAT_STRING') ?
                field.querySelector('DEFAULT_FORMAT_STRING').textContent : '#,#';
            let aggregateType = field.querySelector('MEASURE_AGGREGATOR') ?
                field.querySelector('MEASURE_AGGREGATOR').textContent : '1';
            if (!(measureGroupItems.indexOf(measureGRPName) >= 0)) {
                if (this.locale !== 'en-US') {
                    let measureInfo = [];
                    for (let item of this.fieldListObj.measuresGroups) {
                        if (item.querySelector('MEASUREGROUP_NAME').textContent === measureGRPName) {
                            measureInfo.push(item);
                        }
                    }
                    caption = measureInfo.length > 0 ? measureInfo[0].querySelector('MEASUREGROUP_CAPTION').textContent : measureGRPName;
                }
                else {
                    caption = measureGRPName;
                }
                if (measureGRPName !== '') {
                    dimensionElements.push({
                        hasChildren: true,
                        isChecked: false,
                        isSelected: false,
                        pid: '[Measures]',
                        id: measureGRPName,
                        name: caption,
                        spriteCssClass: 'e-measureCDB e-folderCDB-icon' + ' ' + ICON,
                        tag: measureGRPName,
                        caption: caption,
                        aggregateType: this.getAggregateType(measureGRPName, aggregateType),
                        type: 'string'
                    });
                    measureGroupItems.push(measureGRPName);
                }
            }
            let fieldObj = {
                hasChildren: false,
                isSelected: (reportElement.indexOf(measureName) >= 0),
                pid: measureGRPName === '' ? '[Measures]' : measureGRPName,
                id: measureName,
                name: field.querySelector('MEASURE_CAPTION').textContent,
                spriteCssClass: 'e-measure-icon' + ' ' + ICON,
                tag: measureName,
                caption: field.querySelector('MEASURE_CAPTION').textContent,
                aggregateType: this.getAggregateType(measureName, aggregateType),
                type: 'number',
                filter: [],
                // sort: 'Ascending',
                actualFilter: [],
                filterMembers: [],
                childMembers: [],
                searchMembers: [],
                members: {},
                currrentMembers: {},
                formatString: formatString
            };
            dimensionElements.push(fieldObj);
            this.fieldList[measureName] = fieldObj;
            if ((reportElement.indexOf(measureName) >= 0)) {
                reportElement.splice(reportElement.indexOf(measureName), 1);
            }
        }
        this.measureReportItems = reportElement;
        // let args: ConnectionInfo = {
        //     catalog: customArgs.dataSourceSettings.catalog,
        //     cube: customArgs.dataSourceSettings.cube,
        //     url: customArgs.dataSourceSettings.url,
        //     LCID: customArgs.dataSourceSettings.localeIdentifier.toString(),
        //     request: 'MDSCHEMA_KPIS'
        // };
        // customArgs.reportElement = this.measureReportItems;
        // this.getTreeData(args, this.loadKPIElements.bind(this), customArgs);
    }
    loadMeasureGroups(xmlDoc, request, customArgs) {
        if (isNullOrUndefined(this.fieldListObj)) {
            this.fieldListObj = {};
        }
        this.fieldListObj.measuresGroups = [].slice.call(xmlDoc.querySelectorAll('row'));
    }
    // private loadKPIElements(xmlDoc: Document, request: Ajax, customArgs: FieldData): void {
    //     let dimensionElements: IOlapField[] = this.fieldListData;
    //     let parser = new DOMParser();
    //     let measureGroupItems: string[] = [];
    //     let fields: HTMLElement[] = [].slice.call(xmlDoc.querySelectorAll('row'));
    //     dimensionElements.splice(1, 0, {
    //         hasChildren: true,
    //         isChecked: false,
    //         id: 'folderStruct',
    //         name: 'KPI',
    //         spriteCssClass: 'kpiCDB e-kpiCDB-icon' + ' ' +  cls.ICON,
    //         tag: '',
    //         caption: 'KPI',
    //         aggregateType: this.getAggregateType('folderStruct'),
    //         type: 'string'
    //     });
    //     for (let field of fields) {
    //         let kpiName: string = field.querySelector('KPI_CAPTION').textContent;
    //         let kpiGoal: string = field.querySelector('KPI_GOAL').textContent;
    //         let kpiStatus: string = field.querySelector('KPI_STATUS').textContent;
    //         let kpiTrend: string = field.querySelector('KPI_TREND').textContent;
    //         let kpiValue: string = field.querySelector('KPI_VALUE').textContent;
    //         if (!(measureGroupItems.indexOf(field.querySelector('KPI_NAME').textContent) >= 0)) {
    //             dimensionElements.push({
    //                 hasChildren: true,
    //                 isChecked: false,
    //                 pid: 'folderStruct',
    //                 id: kpiName,
    //                 name: kpiName,
    //                 spriteCssClass: 'e-folderCDB-icon' + ' ' +  cls.ICON,
    //                 tag: kpiName,
    //                 caption: kpiName,
    //                 aggregateType: this.getAggregateType(kpiName),
    //                 type: 'string'
    //             });
    //             measureGroupItems.push(kpiName);
    //         }
    //         let kpiCollection: { [key: string]: string } = {
    //             'kpiGoal': kpiGoal,
    //             'kpiStatus': kpiStatus,
    //             'kpiTrend': kpiTrend,
    //             'kpiValue': kpiValue
    //         };
    //         let i: number = 0;
    //         for (let kpi of Object.keys(kpiCollection)) {
    //             let id: string = kpiCollection[kpi];
    //             let name: string = (kpi).split('kpi')[1];
    //             let cssClass: string = 'e-' + kpi + '-icon';
    //             let fieldObj: IOlapField = {
    //                 hasChildren: true,
    //                 isSelected: (customArgs.reportElement.indexOf(id) >= 0),
    //                 id: id,
    //                 pid: kpiName,
    //                 name: name,
    //                 spriteCssClass: cssClass + ' ' +  cls.ICON,
    //                 tag: id,
    //                 caption: name,
    //                 aggregateType: this.getAggregateType(id),
    //                 type: 'number',
    //                 filter: [],
    //                 sort: 'Ascending',
    //                 filterMembers: [],
    //                 searchMembers: [],
    //                 members: {},
    //                 currrentMembers: {}
    //             };
    //             dimensionElements.push(fieldObj);
    //             this.fieldList[id] = fieldObj;
    //         }
    //     }
    // }
    doAjaxPost(type, url, data, success, customArgs) {
        let ajax = new Ajax({
            mode: false,
            contentType: 'text/xml',
            url: url,
            data: data,
            dataType: 'xml',
            type: type,
            onSuccess: (args, request) => {
                let parser = new DOMParser();
                // parsing string type result as XML
                let xmlDoc = parser.parseFromString(args, 'text/xml');
                success(xmlDoc, request, customArgs);
            },
            onFailure: (e) => {
                return e;
            }
        });
        ajax.send();
    }
    getSoapMsg(dataSourceSettings, query) {
        let xmlMsg = '';
        let sourceInfo = '';
        let connectionString = this.getConnectionInfo(dataSourceSettings.url, dataSourceSettings.localeIdentifier);
        if (this.isMondrian) {
            sourceInfo = '';
            /* tslint:disable-next-line:max-line-length */
            xmlMsg = '<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"><SOAP-ENV:Body><Execute xmlns=\"urn:schemas-microsoft-com:xml-analysis\"><Command><Statement><![CDATA[' +
                query + ']]></Statement></Command><Properties><PropertyList><DataSourceInfo>' + sourceInfo +
                /* tslint:disable-next-line:max-line-length */
                '</DataSourceInfo><Catalog>' + dataSourceSettings.catalog + '</Catalog><AxisFormat>TupleFormat</AxisFormat><Content>Data</Content><Format>Multidimensional</Format></PropertyList></Properties></Execute></SOAP-ENV:Body></SOAP-ENV:Envelope>';
        }
        else {
            /* tslint:disable-next-line:max-line-length */
            xmlMsg = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"> <Header></Header> <Body> <Execute xmlns=\"urn:schemas-microsoft-com:xml-analysis\"> <Command> <Statement> ' +
                query + ' </Statement> </Command> <Properties> <PropertyList> <Catalog>' + dataSourceSettings.catalog +
                /* tslint:disable-next-line:max-line-length */
                '</Catalog> <LocaleIdentifier>' + connectionString.LCID + '</LocaleIdentifier></PropertyList> </Properties> </Execute> </Body> </Envelope>';
        }
        return xmlMsg;
    }
    getConnectionInfo(connectionString, locale) {
        let connectionInfo = { url: '', LCID: '1033' };
        if (connectionString !== '') {
            for (let obj of connectionString.split(';')) {
                if (obj.toLowerCase().indexOf('locale') < 0 && connectionInfo.url.length === 0) {
                    connectionInfo.url = obj;
                }
                else if (obj.toLowerCase().indexOf('locale') >= 0) {
                    connectionInfo.LCID = obj.replace(/ /g, '').split('=')[1];
                }
                else if (!isNullOrUndefined(locale)) {
                    connectionInfo.LCID = locale.toString();
                }
            }
        }
        return connectionInfo;
    }
    getMDXQuery(dataSourceSettings) {
        MDXQuery.getCellSets(dataSourceSettings, this, true, undefined, true);
        return this.mdxQuery;
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PivotView_1;
/**
 * It holds the settings of Grouping Bar.
 */
class GroupingBarSettings extends ChildProperty {
}
__decorate([
    Property(true)
], GroupingBarSettings.prototype, "showFilterIcon", void 0);
__decorate([
    Property(true)
], GroupingBarSettings.prototype, "showSortIcon", void 0);
__decorate([
    Property(true)
], GroupingBarSettings.prototype, "showRemoveIcon", void 0);
__decorate([
    Property(true)
], GroupingBarSettings.prototype, "showValueTypeIcon", void 0);
__decorate([
    Property('Both')
], GroupingBarSettings.prototype, "displayMode", void 0);
__decorate([
    Property(true)
], GroupingBarSettings.prototype, "allowDragAndDrop", void 0);
/**
 * Configures the edit behavior of the Grid.
 */
class CellEditSettings extends ChildProperty {
}
__decorate([
    Property(false)
], CellEditSettings.prototype, "allowAdding", void 0);
__decorate([
    Property(false)
], CellEditSettings.prototype, "allowEditing", void 0);
__decorate([
    Property(false)
], CellEditSettings.prototype, "allowDeleting", void 0);
__decorate([
    Property(false)
], CellEditSettings.prototype, "allowCommandColumns", void 0);
__decorate([
    Property('Normal')
], CellEditSettings.prototype, "mode", void 0);
__decorate([
    Property(true)
], CellEditSettings.prototype, "allowEditOnDblClick", void 0);
__decorate([
    Property(true)
], CellEditSettings.prototype, "showConfirmDialog", void 0);
__decorate([
    Property(false)
], CellEditSettings.prototype, "showDeleteConfirmDialog", void 0);
/**
 * Configures the conditional based hyper link settings.
 */
class ConditionalSettings extends ChildProperty {
}
__decorate([
    Property()
], ConditionalSettings.prototype, "measure", void 0);
__decorate([
    Property()
], ConditionalSettings.prototype, "label", void 0);
__decorate([
    Property('NotEquals')
], ConditionalSettings.prototype, "conditions", void 0);
__decorate([
    Property()
], ConditionalSettings.prototype, "value1", void 0);
__decorate([
    Property()
], ConditionalSettings.prototype, "value2", void 0);
/**
 * It holds the settings of Hyperlink.
 */
class HyperlinkSettings extends ChildProperty {
}
__decorate([
    Property(false)
], HyperlinkSettings.prototype, "showHyperlink", void 0);
__decorate([
    Property(false)
], HyperlinkSettings.prototype, "showRowHeaderHyperlink", void 0);
__decorate([
    Property(false)
], HyperlinkSettings.prototype, "showColumnHeaderHyperlink", void 0);
__decorate([
    Property(false)
], HyperlinkSettings.prototype, "showValueCellHyperlink", void 0);
__decorate([
    Property(false)
], HyperlinkSettings.prototype, "showSummaryCellHyperlink", void 0);
__decorate([
    Collection([], ConditionalSettings)
], HyperlinkSettings.prototype, "conditionalSettings", void 0);
__decorate([
    Property()
], HyperlinkSettings.prototype, "headerText", void 0);
__decorate([
    Property('')
], HyperlinkSettings.prototype, "cssClass", void 0);
/**
 * It holds the option for configure the chart and grid view.
 */
class DisplayOption extends ChildProperty {
}
__decorate([
    Property('Table')
], DisplayOption.prototype, "view", void 0);
__decorate([
    Property('Table')
], DisplayOption.prototype, "primary", void 0);
/**
 * Represents the PivotView component.
 * ```html
 * <div id="PivotView"></div>
 * <script>
 *  var pivotviewObj = new PivotView({ enableGroupingBar: true });
 *  pivotviewObj.appendTo("#pivotview");
 * </script>
 * ```
 */
let PivotView = PivotView_1 = class PivotView extends Component {
    /**
     * Constructor for creating the widget
     * @param  {PivotViewModel} options?
     * @param  {string|HTMLElement} element?
     */
    constructor(options, element) {
        super(options, element);
        /** @hidden */
        this.verticalScrollScale = 1;
        /** @hidden */
        this.horizontalScrollScale = 1;
        /** @hidden */
        this.scrollerBrowserLimit = 500000;
        /** @hidden */
        this.lastSortInfo = {};
        /** @hidden */
        this.lastFilterInfo = {};
        /** @hidden */
        this.lastAggregationInfo = {};
        /** @hidden */
        this.lastCalcFieldInfo = {};
        /** @hidden */
        this.isScrolling = false;
        this.shiftLockedPos = [];
        this.savedSelectedCellsPos = [];
        this.isPopupClicked = false;
        this.isMouseDown = false;
        this.isMouseUp = false;
        this.fieldsType = {};
        this.defaultItems = {};
        this.isCellBoxMultiSelection = false;
        /** @hidden */
        this.gridHeaderCellInfo = [];
        /** @hidden */
        this.gridCellCollection = {};
        /** @hidden */
        this.rowRangeSelection = { enable: false, startIndex: 0, endIndex: 0 };
        /** @hidden */
        this.resizeInfo = {};
        /** @hidden */
        this.scrollPosObject = {
            vertical: 0, horizontal: 0, verticalSection: 0,
            horizontalSection: 0, top: 0, left: 0, scrollDirection: { direction: '', position: 0 }
        };
        /** @hidden */
        this.pivotColumns = [];
        /** @hidden */
        this.totColWidth = 0;
        /** @hidden */
        this.posCount = 0;
        /** @hidden */
        this.isModified = false;
        this.needsID = true;
        this.pivotRefresh = Component.prototype.refresh;
        this.pivotView = this;
        setValue('mergePersistData', this.mergePersistPivotData, this);
    }
    /**
     * To provide the array of modules needed for control rendering
     * @return {ModuleDeclaration[]}
     * @hidden
     */
    requiredModules() {
        let modules = [];
        let isCommonRequire;
        isCommonRequire = true;
        modules.push({ args: [this], member: 'groupingbar' });
        if (this.allowConditionalFormatting) {
            modules.push({ args: [this], member: 'conditionalformatting' });
        }
        if (this.allowNumberFormatting) {
            isCommonRequire = true;
            modules.push({ args: [this], member: 'numberformatting' });
        }
        if (this.allowCalculatedField) {
            isCommonRequire = true;
            modules.push({ args: [this], member: 'calculatedfield' });
        }
        // if (this.showGroupingBar || !this.showGroupingBar) {
        //     isCommonRequire = true;
        //     modules.push({ args: [this], member: 'grouping' });
        // }
        if (this.showToolbar && this.toolbar.length > 0) {
            isCommonRequire = true;
            modules.push({ args: [this], member: 'toolbar' });
        }
        if (this.showFieldList) {
            isCommonRequire = true;
            modules.push({ args: [this], member: 'fieldlist' });
        }
        if (this.allowExcelExport) {
            modules.push({ args: [this], member: 'excelExport' });
        }
        if (this.allowPdfExport) {
            modules.push({ args: [this], member: 'pdfExport' });
        }
        if (this.enableVirtualization) {
            modules.push({ args: [this], member: 'virtualscroll' });
        }
        if (this.allowGrouping) {
            isCommonRequire = true;
            modules.push({ args: [this], member: 'grouping' });
        }
        if (this.gridSettings) {
            if (this.gridSettings.contextMenuItems) {
                isCommonRequire = true;
            }
        }
        if (isCommonRequire) {
            modules.push({ args: [this], member: 'common' });
        }
        return modules;
    }
    /**
     * For internal use only - Initializing internal properties;
     * @private
     */
    preRender() {
        if (this.dataSourceSettings && this.dataSourceSettings.providerType === 'SSAS') {
            this.dataType = 'olap';
            this.olapEngineModule = new OlapEngine();
        }
        else {
            this.dataType = 'pivot';
            this.engineModule = new PivotEngine();
        }
        this.initProperties();
        this.isAdaptive = Browser.isDevice;
        this.renderToolTip();
        this.keyboardModule = new KeyboardInteraction(this);
        this.contextMenuModule = new PivotContextMenu(this);
        this.globalize = new Internationalization(this.locale);
        this.defaultLocale = {
            grandTotal: 'Grand Total',
            total: 'Total',
            value: 'Value',
            noValue: 'No value',
            row: 'Row',
            column: 'Column',
            collapse: 'Collapse',
            expand: 'Expand',
            rowAxisPrompt: 'Drop row here',
            columnAxisPrompt: 'Drop column here',
            valueAxisPrompt: 'Drop value here',
            filterAxisPrompt: 'Drop filter here',
            filter: 'Filter',
            filtered: 'Filtered',
            sort: 'Sort',
            filters: 'Filters',
            rows: 'Rows',
            columns: 'Columns',
            values: 'Values',
            close: 'Close',
            cancel: 'Cancel',
            delete: 'Delete',
            CalculatedField: 'Calculated Field',
            createCalculatedField: 'Create Calculated Field',
            fieldName: 'Enter the field name',
            error: 'Error',
            invalidFormula: 'Invalid formula.',
            dropText: 'Example: ("Sum(Order_Count)" + "Sum(In_Stock)") * 250',
            dropTextMobile: 'Add fields and edit formula here.',
            dropAction: 'Calculated field cannot be place in any other region except value axis.',
            alert: 'Alert',
            warning: 'Warning',
            ok: 'OK',
            search: 'Search',
            drag: 'Drag',
            remove: 'Remove',
            allFields: 'All Fields',
            formula: 'Formula',
            addToRow: 'Add to Row',
            addToColumn: 'Add to Column',
            addToValue: 'Add to Value',
            addToFilter: 'Add to Filter',
            emptyData: 'No records to display',
            fieldExist: 'A field already exists in this name. Please enter a different name.',
            confirmText: 'A calculation field already exists in this name. Do you want to replace it?',
            noMatches: 'No matches',
            format: 'Summaries values by',
            edit: 'Edit',
            clear: 'Clear',
            formulaField: 'Drag and drop fields to formula',
            dragField: 'Drag field to formula',
            clearFilter: 'Clear',
            by: 'by',
            all: 'All',
            multipleItems: 'Multiple items',
            /* tslint:disable */
            member: 'Member',
            label: 'Label',
            date: 'Date',
            enterValue: 'Enter value',
            chooseDate: 'Enter date',
            Before: 'Before',
            BeforeOrEqualTo: 'Before Or Equal To',
            After: 'After',
            AfterOrEqualTo: 'After Or Equal To',
            labelTextContent: 'Show the items for which the label',
            dateTextContent: 'Show the items for which the date',
            valueTextContent: 'Show the items for which',
            Equals: 'Equals',
            DoesNotEquals: 'Does Not Equal',
            BeginWith: 'Begins With',
            DoesNotBeginWith: 'Does Not Begin With',
            EndsWith: 'Ends With',
            DoesNotEndsWith: 'Does Not End With',
            Contains: 'Contains',
            DoesNotContains: 'Does Not Contain',
            GreaterThan: 'Greater Than',
            GreaterThanOrEqualTo: 'Greater Than Or Equal To',
            LessThan: 'Less Than',
            LessThanOrEqualTo: 'Less Than Or Equal To',
            Between: 'Between',
            NotBetween: 'Not Between',
            And: 'and',
            Sum: 'Sum',
            Count: 'Count',
            DistinctCount: 'Distinct Count',
            Product: 'Product',
            Avg: 'Avg',
            Min: 'Min',
            SampleVar: 'Sample Var',
            PopulationVar: 'Population Var',
            RunningTotals: 'Running Totals',
            Max: 'Max',
            Index: 'Index',
            SampleStDev: 'Sample StDev',
            PopulationStDev: 'Population StDev',
            PercentageOfRowTotal: '% of Row Total',
            PercentageOfParentTotal: '% of Parent Total',
            PercentageOfParentColumnTotal: '% of Parent Column Total',
            PercentageOfParentRowTotal: '% of Parent Row Total',
            DifferenceFrom: 'Difference From',
            PercentageOfDifferenceFrom: '% of Difference From',
            PercentageOfGrandTotal: '% of Grand Total',
            PercentageOfColumnTotal: '% of Column Total',
            MoreOption: 'More...',
            /* tslint:enable */
            NotEquals: 'Not Equals',
            AllValues: 'All Values',
            conditionalFormating: 'Conditional Formatting',
            apply: 'APPLY',
            condition: 'Add Condition',
            formatLabel: 'Format',
            valueFieldSettings: 'Value field settings',
            baseField: 'Base field :',
            baseItem: 'Base item :',
            summarizeValuesBy: 'Summarize values by :',
            sourceName: 'Field name :',
            sourceCaption: 'Field caption :',
            example: 'e.g:',
            editorDataLimitMsg: ' more items. Search to refine further.',
            details: 'Details',
            manageRecords: 'Manage Records',
            Years: 'Years',
            Quarters: 'Quarters',
            Months: 'Months',
            Days: 'Days',
            Hours: 'Hours',
            Minutes: 'Minutes',
            Seconds: 'Seconds',
            save: 'Save a report',
            new: 'Create a new report',
            load: 'Load',
            saveAs: 'Save as current report',
            rename: 'Rename a current report',
            deleteReport: 'Delete a current report',
            export: 'Export',
            subTotals: 'Sub totals',
            grandTotals: 'Grand totals',
            reportName: 'Report Name :',
            pdf: 'PDF',
            excel: 'Excel',
            csv: 'CSV',
            png: 'PNG',
            jpeg: 'JPEG',
            svg: 'SVG',
            mdxQuery: 'MDX Query',
            showSubTotals: 'Show sub totals',
            doNotShowSubTotals: 'Do not show sub totals',
            showSubTotalsRowsOnly: 'Show sub totals rows only',
            showSubTotalsColumnsOnly: 'Show sub totals columns only',
            showGrandTotals: 'Show grand totals',
            doNotShowGrandTotals: 'Do not show grand totals',
            showGrandTotalsRowsOnly: 'Show grand totals rows only',
            showGrandTotalsColumnsOnly: 'Show grand totals columns only',
            fieldList: 'Show fieldlist',
            grid: 'Show table',
            toolbarFormatting: 'Conditional formatting',
            chart: 'Chart',
            reportMsg: 'Please enter vaild report name!!!',
            reportList: 'Report list',
            removeConfirm: 'Are you sure want to delete this report?',
            emptyReport: 'No reports found!!',
            bar: 'Bar',
            line: 'Line',
            area: 'Area',
            scatter: 'Scatter',
            polar: 'Polar',
            of: 'of',
            emptyFormat: 'No format found!!!',
            emptyInput: 'Enter a value',
            newReportConfirm: 'Want to save changes to report?',
            emptyReportName: 'Enter a report name',
            qtr: 'Qtr',
            null: 'null',
            undefined: 'undefined',
            groupOutOfRange: 'Out of Range',
            fieldDropErrorAction: 'The field you are moving cannot be placed in that area of the report',
            aggregate: 'Aggregate',
            drillThrough: 'Drill Through',
            ascending: 'Ascending',
            descending: 'Descending',
            number: 'Number',
            currency: 'Currency',
            percentage: 'Percentage',
            formatType: 'Format Type',
            customText: 'Currency Symbol',
            symbolPosition: 'Symbol Position',
            left: 'Left',
            right: 'Right',
            grouping: 'Grouping',
            true: 'True',
            false: 'False',
            decimalPlaces: 'Decimal Places',
            numberFormat: 'Number Formatting',
            memberType: 'Field Type',
            formatString: 'Format String',
            expressionField: 'Expression',
            customFormat: 'Enter custom format string',
            selectedHierarchy: 'Parent Hierarchy',
            olapDropText: 'Example: [Measures].[Order Quantity] + ([Measures].[Order Quantity] * 0.10)',
            Percent: 'Percent',
            Currency: 'Currency',
            Custom: 'Custom',
            Measure: 'Measure',
            Dimension: 'Dimension',
            Standard: 'Standard',
            blank: '(Blank)',
            fieldTooltip: 'Drag and drop fields to create an expression. ' +
                'And, if you want to edit the existing the calculated fields! ' +
                'You can achieve it by simply selecting the field under "Calculated Members".',
            fieldTitle: 'Field Name',
            QuarterYear: 'Quarter Year',
            drillError: 'Cannot show the raw items of calculated fields.',
            caption: 'Field Caption',
            copy: 'Copy',
            defaultReport: 'Default report',
            customFormatString: 'Custom Format',
            invalidFormat: 'Invalid Format.',
            group: 'Group',
            unGroup: 'Ungroup',
            invalidSelection: 'Cannot group that selection.',
            groupName: 'Enter the caption to display in header',
            captionName: 'Enter the caption for group field',
            selectedItems: 'Selected items',
            groupFieldCaption: 'Field caption',
            groupTitle: 'Group name',
            startAt: 'Starting at',
            endAt: 'Ending at',
            groupBy: 'Interval by',
            selectGroup: 'Select groups'
        };
        this.localeObj = new L10n(this.getModuleName(), this.defaultLocale, this.locale);
        this.renderContextMenu();
        this.isDragging = false;
        this.addInternalEvents();
        //setCurrencyCode(this.currencyCode);
    }
    onBeforeTooltipOpen(args) {
        args.element.classList.add('e-pivottooltipwrap');
    }
    renderToolTip() {
        if (this.showTooltip) {
            this.tooltip = new Tooltip({
                target: 'td.e-valuescontent',
                showTipPointer: false,
                enableRtl: this.enableRtl,
                beforeRender: this.setToolTip.bind(this),
                beforeOpen: this.onBeforeTooltipOpen
            });
            this.tooltip.isStringTemplate = true;
            this.tooltip.appendTo(this.element);
        }
        else if (this.tooltip) {
            this.tooltip.destroy();
        }
    }
    /** @hidden */
    renderContextMenu() {
        if (this.gridSettings.contextMenuItems || (this.allowGrouping && this.dataType === 'pivot')) {
            let conmenuItems = [];
            let groupItems = [];
            let customItems = [];
            let exportItems = [];
            let aggItems = [];
            let expItems = [];
            let aggregateItems = [];
            if (this.gridSettings.contextMenuItems) {
                for (let item of this.gridSettings.contextMenuItems) {
                    if (typeof item === 'string' && this.getDefaultItems().indexOf(item) !== -1) {
                        if (item.toString().toLowerCase().indexOf('aggregate') !== -1) {
                            aggregateItems = [
                                { text: this.localeObj.getConstant('Sum'), id: this.element.id + '_AggSum' },
                                { text: this.localeObj.getConstant('DistinctCount'), id: this.element.id + '_AggDistinctCount' },
                                { text: this.localeObj.getConstant('Count'), id: this.element.id + '_AggCount' },
                                { text: this.localeObj.getConstant('Product'), id: this.element.id + '_AggProduct' },
                                { text: this.localeObj.getConstant('Avg'), id: this.element.id + '_AggAvg' },
                                { text: this.localeObj.getConstant('Max'), id: this.element.id + '_AggMax' },
                                { text: this.localeObj.getConstant('Min'), id: this.element.id + '_AggMin' },
                                { text: this.localeObj.getConstant('MoreOption'), id: this.element.id + '_AggMoreOption' }
                            ];
                        }
                        else if (item.toString().toLowerCase().indexOf('export') !== -1) {
                            exportItems.push(this.buildDefaultItems(item));
                        }
                        else {
                            conmenuItems.push(this.buildDefaultItems(item));
                        }
                    }
                    else if (typeof item !== 'string') {
                        customItems.push(item);
                    }
                }
            }
            if (this.allowGrouping && this.dataType === 'pivot') {
                groupItems.push(this.buildDefaultItems('Group'));
                groupItems.push(this.buildDefaultItems('Ungroup'));
            }
            if (aggregateItems.length > 0) {
                let aggregateGroup = this.buildDefaultItems('Aggregate');
                aggregateGroup.items = aggregateItems;
                aggItems.push(aggregateGroup);
            }
            if (exportItems.length > 0) {
                let exportGroupItems = this.buildDefaultItems('export');
                exportGroupItems.items = exportItems;
                expItems.push(exportGroupItems);
            }
            this.gridSettings.contextMenuItems = [];
            Array.prototype.push.apply(this.gridSettings.contextMenuItems, aggItems);
            Array.prototype.push.apply(this.gridSettings.contextMenuItems, conmenuItems);
            Array.prototype.push.apply(this.gridSettings.contextMenuItems, groupItems);
            Array.prototype.push.apply(this.gridSettings.contextMenuItems, expItems);
            Array.prototype.push.apply(this.gridSettings.contextMenuItems, customItems);
        }
    }
    getDefaultItems() {
        return ['Drillthrough', 'Expand',
            'Collapse', 'Pdf Export', 'Excel Export', 'Csv Export', 'Sort Ascending', 'Sort Descending',
            'Aggregate', 'CalculatedField'];
    }
    buildDefaultItems(item) {
        let menuItem;
        switch (item) {
            case 'Aggregate':
                menuItem = {
                    text: this.localeObj.getConstant('aggregate'), target: 'th.e-valuesheader,td.e-valuescontent,.e-stot',
                    id: this.element.id + '_aggregate'
                };
                break;
            case 'CalculatedField':
                menuItem = {
                    text: this.localeObj.getConstant('CalculatedField'), target: 'td.e-valuescontent',
                    id: this.element.id + '_CalculatedField'
                };
                break;
            case 'Drillthrough':
                menuItem = {
                    text: this.localeObj.getConstant('drillThrough'), target: 'td.e-valuescontent',
                    id: this.element.id + '_drillthrough_menu', iconCss: PIVOTVIEW_GRID + ' ' + ICON
                };
                break;
            case 'export':
                menuItem = {
                    text: this.localeObj.getConstant('export'), target: 'td.e-valuescontent',
                    id: this.element.id + '_exporting', iconCss: PIVOTVIEW_EXPORT + ' ' + ICON
                };
                break;
            case 'Pdf Export':
                menuItem = {
                    text: this.localeObj.getConstant('pdf'), id: this.element.id + '_pdf',
                    iconCss: GRID_PDF_EXPORT + ' ' + ICON
                };
                break;
            case 'Excel Export':
                menuItem = {
                    text: this.localeObj.getConstant('excel'), id: this.element.id + '_excel',
                    iconCss: GRID_EXCEL_EXPORT + ' ' + ICON
                };
                break;
            case 'Csv Export':
                menuItem = {
                    text: this.localeObj.getConstant('csv'), id: this.element.id + '_csv',
                    iconCss: GRID_CSV_EXPORT + ' ' + ICON,
                };
                break;
            case 'Expand':
                menuItem = {
                    text: this.localeObj.getConstant('expand'), target: 'td.e-rowsheader,.e-columnsheader',
                    id: this.element.id + '_expand', iconCss: PIVOTVIEW_EXPAND + ' ' + ICON
                };
                break;
            case 'Collapse':
                menuItem = {
                    text: this.localeObj.getConstant('collapse'), target: 'td.e-rowsheader,.e-columnsheader',
                    id: this.element.id + '_collapse', iconCss: PIVOTVIEW_COLLAPSE + ' ' + ICON
                };
                break;
            case 'Sort Ascending':
                menuItem = {
                    text: this.localeObj.getConstant('ascending'), target: 'th.e-valuesheader,.e-stot',
                    id: this.element.id + '_sortasc', iconCss: ICON_ASC + ' ' + ICON
                };
                break;
            case 'Sort Descending':
                menuItem = {
                    text: this.localeObj.getConstant('descending'), target: 'th.e-valuesheader,.e-stot',
                    id: this.element.id + '_sortdesc', iconCss: ICON_DESC + ' ' + ICON
                };
                break;
            case 'Group':
                menuItem = {
                    text: this.localeObj.getConstant('group'), target: 'td.e-rowsheader,.e-columnsheader',
                    id: this.element.id + '_custom_group', iconCss: PIVOTVIEW_GROUP + ' ' + ICON
                };
                break;
            case 'Ungroup':
                menuItem = {
                    text: this.localeObj.getConstant('unGroup'), target: 'td.e-rowsheader,.e-columnsheader',
                    id: this.element.id + '_custom_ungroup', iconCss: PIVOTVIEW_UN_GROUP + ' ' + ICON
                };
                break;
        }
        this.defaultItems[item] = {
            text: menuItem.text, id: menuItem.id,
            target: menuItem.target, iconCss: menuItem.iconCss
        };
        return this.defaultItems[item];
    }
    /* tslint:disable:align */
    initProperties() {
        this.pivotRefresh = Component.prototype.refresh;
        this.isScrolling = false;
        this.setProperties({ pivotValues: [] }, true);
        this.scrollPosObject = {
            vertical: 0, horizontal: 0, verticalSection: 0,
            horizontalSection: 0, top: 0, left: 0, scrollDirection: { direction: '', position: 0 }
        };
        this.queryCellInfo = this.gridSettings.queryCellInfo ? this.gridSettings.queryCellInfo.bind(this) : undefined;
        this.headerCellInfo = this.gridSettings.headerCellInfo ? this.gridSettings.headerCellInfo.bind(this) : undefined;
        this.resizing = this.gridSettings.resizing ? this.gridSettings.resizing.bind(this) : undefined;
        this.resizeStop = this.gridSettings.resizeStop ? this.gridSettings.resizeStop.bind(this) : undefined;
        this.pdfHeaderQueryCellInfo = this.gridSettings.pdfHeaderQueryCellInfo ?
            this.gridSettings.pdfHeaderQueryCellInfo.bind(this) : undefined;
        this.pdfQueryCellInfo = this.gridSettings.pdfQueryCellInfo ? this.gridSettings.pdfQueryCellInfo.bind(this) : undefined;
        this.excelHeaderQueryCellInfo = this.gridSettings.excelHeaderQueryCellInfo ?
            this.gridSettings.excelHeaderQueryCellInfo.bind(this) : undefined;
        this.excelQueryCellInfo = this.gridSettings.excelQueryCellInfo ?
            this.gridSettings.excelQueryCellInfo.bind(this) : undefined;
        this.columnDragStart = this.gridSettings.columnDragStart ? this.gridSettings.columnDragStart.bind(this) : undefined;
        this.columnDrag = this.gridSettings.columnDrag ? this.gridSettings.columnDrag.bind(this) : undefined;
        this.columnDrop = this.gridSettings.columnDrop ? this.gridSettings.columnDrop.bind(this) : undefined;
        this.beforeColumnsRender = this.gridSettings.columnRender ? this.gridSettings.columnRender : undefined;
        this.selected = this.gridSettings.cellSelected ? this.gridSettings.cellSelected : undefined;
        this.cellDeselected = this.gridSettings.cellDeselected ? this.gridSettings.cellDeselected : undefined;
        this.rowSelected = this.gridSettings.rowSelected ? this.gridSettings.rowSelected : undefined;
        this.rowDeselected = this.gridSettings.rowDeselected ? this.gridSettings.rowDeselected : undefined;
        this.chartTooltipRender = this.chartSettings.tooltipRender ? this.chartSettings.tooltipRender : undefined;
        this.chartLoaded = this.chartSettings.loaded ? this.chartSettings.loaded : undefined;
        this.chartLoad = this.chartSettings.load ? this.chartSettings.load : undefined;
        this.chartResized = this.chartSettings.resized ? this.chartSettings.resized : undefined;
        this.chartAxisLabelRender = this.chartSettings.axisLabelRender ? this.chartSettings.axisLabelRender : undefined;
        this.contextMenuClick = this.gridSettings.contextMenuClick ? this.gridSettings.contextMenuClick : undefined;
        this.contextMenuOpen = this.gridSettings.contextMenuOpen ? this.gridSettings.contextMenuOpen : undefined;
        this.beforePdfExport = this.gridSettings.beforePdfExport ? this.gridSettings.beforePdfExport.bind(this) : undefined;
        this.beforeExcelExport = this.gridSettings.beforeExcelExport ? this.gridSettings.beforeExcelExport.bind(this) : undefined;
        if (this.gridSettings.rowHeight === null) {
            this.setProperties({ gridSettings: { rowHeight: this.isAdaptive ? 48 : 36 } }, true);
        }
        this.element.style.height = '100%';
        if (this.enableVirtualization) {
            this.updatePageSettings(true);
            if (this.allowExcelExport) {
                PivotView_1.Inject(ExcelExport$1);
            }
            if (this.allowPdfExport) {
                PivotView_1.Inject(PDFExport);
            }
            if (this.editSettings.allowEditing) {
                PivotView_1.Inject(DrillThrough);
            }
        }
        this.isCellBoxMultiSelection = this.gridSettings.allowSelection &&
            this.gridSettings.selectionSettings.cellSelectionMode === 'Box' &&
            this.gridSettings.selectionSettings.mode === 'Cell' && this.gridSettings.selectionSettings.type === 'Multiple';
        if (this.allowGrouping && !this.isCellBoxMultiSelection) {
            this.isCellBoxMultiSelection = true;
            /* tslint:disable-next-line:max-line-length */
            this.setProperties({ gridSettings: { allowSelection: true, selectionSettings: { cellSelectionMode: 'Box', mode: 'Cell', type: 'Multiple' } } }, true);
        }
        if (this.displayOption.view !== 'Table') {
            this.chartModule = new PivotChart();
        }
        this.currentView = this.currentView ? this.currentView : (this.displayOption.view === 'Both' ?
            this.displayOption.primary : this.displayOption.view);
    }
    /**
     * @hidden
     */
    updatePageSettings(isInit) {
        if (this.enableVirtualization) {
            let colValues = 1;
            let rowValues = 1;
            if (this.dataSourceSettings.values.length > 1 && this.dataType === 'pivot') {
                if (this.dataSourceSettings.valueAxis === 'row') {
                    rowValues = this.dataSourceSettings.values.length;
                }
                else {
                    colValues = this.dataSourceSettings.values.length;
                }
            }
            let heightAsNumber = this.getHeightAsNumber();
            if (isNaN(heightAsNumber)) {
                heightAsNumber = this.element.offsetHeight;
            }
            this.pageSettings = {
                columnCurrentPage: isInit ? 1 : this.pageSettings.columnCurrentPage,
                rowCurrentPage: isInit ? 1 : this.pageSettings.rowCurrentPage,
                columnSize: Math.ceil((Math.floor((this.getWidthAsNumber()) /
                    this.gridSettings.columnWidth) - 1) / colValues),
                rowSize: Math.ceil(Math.floor((heightAsNumber) / this.gridSettings.rowHeight) / rowValues),
                allowDataCompression: this.allowDataCompression
            };
        }
    }
    /**
     * Initialize the control rendering
     * @returns void
     * @hidden
     */
    render() {
        this.cellTemplateFn = this.templateParser(this.cellTemplate);
        if (this.spinnerTemplate) {
            createSpinner({ target: this.element, template: this.spinnerTemplate }, this.createElement);
        }
        else {
            createSpinner({ target: this.element }, this.createElement);
        }
        let loadArgs = {
            dataSourceSettings: this.dataSourceSettings,
            pivotview: isBlazor() ? undefined : this,
            fieldsType: {}
        };
        this.trigger(load, loadArgs, (observedArgs) => {
            if (isBlazor()) {
                observedArgs.dataSourceSettings.dataSource = this.dataSourceSettings.dataSource;
            }
            this.dataSourceSettings = observedArgs.dataSourceSettings;
            this.fieldsType = observedArgs.fieldsType;
            this.updateClass();
            this.notify(initSubComponent, {});
            this.notify(initialLoad, {});
            if (this.isAdaptive) {
                this.contextMenuModule.render();
            }
            this.notify(initToolbar, {});
        });
        if (isBlazor()) {
            this.renderComplete();
        }
    }
    /**
     * Register the internal events.
     * @returns void
     * @hidden
     */
    addInternalEvents() {
        this.on(initialLoad, this.generateData, this);
        this.on(dataReady, this.renderPivotGrid, this);
        this.on(contentReady, this.onContentReady, this);
    }
    /**
     * De-Register the internal events.
     * @returns void
     * @hidden
     */
    removeInternalEvents() {
        this.off(initialLoad, this.generateData);
        this.off(dataReady, this.renderPivotGrid);
        this.off(contentReady, this.onContentReady);
    }
    /**
     * Get the Pivot widget properties to be maintained in the persisted state.
     * @returns {string}
     */
    getPersistData() {
        let keyEntity = ['dataSourceSettings', 'pivotValues', 'gridSettings', 'chartSettings', 'displayOption'];
        /* tslint:disable */
        this.chartSettings['tooltipRender'] = undefined;
        this.chartSettings['resized'] = undefined;
        this.chartSettings['loaded'] = undefined;
        this.chartSettings['beforePrint'] = undefined;
        this.chartSettings['animationComplete'] = undefined;
        this.chartSettings['load'] = undefined;
        this.chartSettings['textRender'] = undefined;
        this.chartSettings['legendRender'] = undefined;
        this.chartSettings['seriesRender'] = undefined;
        this.chartSettings['pointRender'] = undefined;
        this.chartSettings['axisLabelRender'] = undefined;
        this.chartSettings['chartMouseClick'] = undefined;
        this.chartSettings['chartMouseMove'] = undefined;
        this.chartSettings['pointMove'] = undefined;
        this.chartSettings['pointClick'] = undefined;
        this.chartSettings['chartMouseDown'] = undefined;
        this.chartSettings['chartMouseLeave'] = undefined;
        this.chartSettings['dragComplete'] = undefined;
        this.chartSettings['chartMouseUp'] = undefined;
        this.chartSettings['scrollStart'] = undefined;
        this.chartSettings['zoomComplete'] = undefined;
        this.chartSettings['scrollChanged'] = undefined;
        this.chartSettings['scrollEnd'] = undefined;
        /* tslint:enable */
        return this.addOnPersist(keyEntity);
    }
    /**
     * Loads pivot Layout
     * @param {string} persistData - Specifies the persist data to be loaded to pivot.
     * @returns {void}
     */
    loadPersistData(persistData) {
        let pivotData;
        /* tslint:disable */
        if (isBlazor()) {
            pivotData = persistData;
            pivotData.dataSourceSettings.dataSource = this.dataSourceSettings.dataSource;
        }
        else {
            pivotData = JSON.parse(persistData);
        }
        this.setProperties({
            gridSettings: pivotData.gridSettings,
            pivotValues: pivotData.pivotValues,
            chartSettings: pivotData.chartSettings,
            displayOption: pivotData.displayOption
        }, true);
        /* tslint:enable */
        this.dataSourceSettings = pivotData.dataSourceSettings;
    }
    mergePersistPivotData() {
        let blazdataSource;
        if (isBlazor()) {
            blazdataSource = this.dataSourceSettings.dataSource;
        }
        let data = window.localStorage.getItem(this.getModuleName() + this.element.id);
        if (!(isNullOrUndefined(data) || (data === ''))) {
            this.setProperties(JSON.parse(data), true);
        }
        if (this.dataSourceSettings.dataSource instanceof Object && isBlazor()) {
            this.setProperties({ dataSourceSettings: { dataSource: blazdataSource } }, true);
        }
    }
    /**
     * Method to open conditional formatting dialog
     */
    showConditionalFormattingDialog() {
        if (this.conditionalFormattingModule) {
            this.conditionalFormattingModule.showConditionalFormattingDialog();
        }
    }
    /**
     * Method to open calculated field dialog
     */
    createCalculatedFieldDialog() {
        if (this.calculatedFieldModule) {
            this.calculatedFieldModule.createCalculatedFieldDialog();
        }
    }
    /**
     * It returns the Module name.
     * @returns string
     * @hidden
     */
    getModuleName() {
        return 'pivotview';
    }
    /**
     * Copy the selected rows or cells data into clipboard.
     * @param {boolean} withHeader - Specifies whether the column header text needs to be copied along with rows or cells.
     * @returns {void}
     * @hidden
     */
    copy(withHeader) {
        this.grid.copy(withHeader);
    }
    /**
     * By default, prints all the pages of the Grid and hides the pager.
     * > You can customize print options using the
     * [`printMode`](./api-pivotgrid.html#printmode-string).
     * @returns {void}
     * @hidden
     */
    // public print(): void {
    //     this.grid.print();
    // }
    /* tslint:disable:max-func-body-length */
    /**
     * Called internally if any of the property value changed.
     * @returns void
     * @hidden
     */
    onPropertyChanged(newProp, oldProp) {
        for (let prop of Object.keys(newProp)) {
            switch (prop) {
                case 'dataSourceSettings':
                case 'hyperlinkSettings':
                case 'allowDrillThrough':
                case 'editSettings':
                case 'allowDataCompression':
                    if (newProp.dataSourceSettings && Object.keys(newProp.dataSourceSettings).length === 1
                        && newProp.dataSourceSettings.groupSettings && this.dataType === 'pivot') {
                        this.updateGroupingReport(newProp.dataSourceSettings.groupSettings, 'Date');
                    }
                    if (newProp.dataSourceSettings && Object.keys(newProp.dataSourceSettings).length === 1
                        && Object.keys(newProp.dataSourceSettings)[0] === 'dataSource') {
                        if (!(isBlazor() && this.enableVirtualization)) {
                            this.engineModule.fieldList = null;
                            this.refreshData();
                        }
                    }
                    else {
                        this.notify(initialLoad, {});
                    }
                    break;
                case 'height':
                case 'width':
                    this.layoutRefresh();
                    break;
                case 'pivotValues':
                case 'displayOption':
                    if (!this.showToolbar && newProp.displayOption && Object.keys(newProp.displayOption).length === 1 &&
                        newProp.displayOption.view) {
                        this.currentView = (newProp.displayOption.view === 'Both' ?
                            this.displayOption.primary : newProp.displayOption.view);
                        if (this.showGroupingBar || this.showFieldList) {
                            if (this.showFieldList && this.pivotFieldListModule) {
                                this.pivotFieldListModule.destroy();
                            }
                            if (this.showGroupingBar && this.groupingBarModule) {
                                this.groupingBarModule.destroy();
                            }
                            this.notify(initSubComponent, this);
                        }
                        if (!this.grid && newProp.displayOption.view !== 'Chart') {
                            this.renderEmptyGrid();
                            if (newProp.displayOption.view === 'Table') {
                                if (this.chartModule) {
                                    this.chartModule.destroy();
                                    this.chart = undefined;
                                    this.chartModule = undefined;
                                }
                            }
                        }
                        else if (!this.chartModule && this.displayOption.view !== 'Table') {
                            this.chartModule = new PivotChart();
                        }
                    }
                    this.notify(dataReady, {});
                    break;
                case 'gridSettings':
                    this.lastGridSettings = newProp.gridSettings;
                    this.isCellBoxMultiSelection = this.gridSettings.allowSelection &&
                        this.gridSettings.selectionSettings.cellSelectionMode === 'Box' &&
                        this.gridSettings.selectionSettings.mode === 'Cell' && this.gridSettings.selectionSettings.type === 'Multiple';
                    if (this.allowGrouping && this.groupingModule && !this.isCellBoxMultiSelection) {
                        /* tslint:disable-next-line:max-line-length */
                        this.setProperties({ gridSettings: { allowSelection: true, selectionSettings: { cellSelectionMode: 'Box', mode: 'Cell', type: 'Multiple' } } }, true);
                        this.isCellBoxMultiSelection = true;
                    }
                    this.renderModule.updateGridSettings();
                    break;
                case 'chartSettings':
                    this.chartModule.loadChart(this, this.chartSettings);
                    this.notify(uiUpdate, this);
                    break;
                case 'locale':
                case 'currencyCode':
                case 'enableRtl':
                    if (this.tooltip) {
                        this.tooltip.destroy();
                    }
                    super.refresh();
                    this.updateClass();
                    break;
                case 'enableValueSorting':
                    this.enableValueSorting = newProp.enableValueSorting;
                    this.updateDataSource();
                    break;
                case 'showGroupingBar':
                    if (this.element.querySelector('.e-grouping-bar')) {
                        this.element.querySelector('.e-grouping-bar').remove();
                    }
                    this.renderPivotGrid();
                    break;
                case 'groupingBarSettings':
                    this.axisFieldModule.render();
                    break;
                case 'showTooltip':
                    this.renderToolTip();
                    break;
                case 'toolbar':
                    if (this.toolbarModule) {
                        this.toolbarModule.refreshToolbar();
                    }
                    break;
            }
        }
    }
    templateParser(template) {
        if (template) {
            try {
                if (document.querySelectorAll(template).length) {
                    return compile(document.querySelector(template).innerHTML.trim());
                }
            }
            catch (error) {
                return compile(template);
            }
        }
        return undefined;
    }
    getCellTemplate() {
        return this.cellTemplateFn;
    }
    /**
     * @hidden
     */
    appendHtml(node, innerHtml) {
        let tempElement = document.createElement('div');
        tempElement.innerHTML = innerHtml;
        if (!isNullOrUndefined(tempElement.firstChild)) {
            node.appendChild(tempElement.firstChild);
        }
        return node;
    }
    /**
     * Render the UI section of PivotView.
     * @returns void
     * @hidden
     */
    renderPivotGrid() {
        if (this.currentView === 'Table') {
            /* tslint:disable-next-line */
            if (this.cellTemplate && isBlazor()) {
                resetBlazorTemplate(this.element.id + '_cellTemplate', 'CellTemplate');
            }
        }
        if (this.chartModule) {
            this.chartModule.engineModule = this.engineModule;
            this.chartModule.loadChart(this, this.chartSettings);
            if (this.enableRtl && this.chart) {
                addClass([this.chart.element], PIVOTCHART_LTR);
            }
        }
        if (this.showFieldList || this.showGroupingBar) {
            this.notify(uiUpdate, this);
            if (this.pivotFieldListModule && this.allowDeferLayoutUpdate) {
                this.pivotFieldListModule.clonedDataSource = extend({}, this.dataSourceSettings, null, true);
            }
        }
        if (this.enableVirtualization) {
            this.virtualscrollModule = new VirtualScroll$1(this);
        }
        if (this.displayOption.view !== 'Chart') {
            if (this.hyperlinkSettings) {
                this.isRowCellHyperlink = (this.hyperlinkSettings.showRowHeaderHyperlink ?
                    true : this.hyperlinkSettings.showHyperlink ? true : false);
                this.isColumnCellHyperlink = (this.hyperlinkSettings.showColumnHeaderHyperlink ?
                    true : this.hyperlinkSettings.showHyperlink ? true : false);
                this.isValueCellHyperlink = (this.hyperlinkSettings.showValueCellHyperlink ?
                    true : this.hyperlinkSettings.showHyperlink ? true : false);
                this.isSummaryCellHyperlink = (this.hyperlinkSettings.showSummaryCellHyperlink ?
                    true : this.hyperlinkSettings.showHyperlink ? true : false);
                this.applyHyperlinkSettings();
            }
            if (this.allowDrillThrough || this.editSettings.allowEditing) {
                this.drillThroughModule = new DrillThrough(this);
            }
            this.renderModule = new Render(this);
            this.renderModule.render();
        }
        else if (this.grid) {
            remove(this.grid.element);
        }
        this.trigger(dataBound);
        if (this.allowConditionalFormatting) {
            this.applyFormatting(this.pivotValues);
        }
        if (this.showToolbar) {
            if (this.displayOption.view === 'Both' && this.chart && this.grid) {
                if (this.showGroupingBar && this.groupingBarModule && this.element.querySelector('.' + GROUPING_BAR_CLASS)) {
                    this.groupingBarModule.refreshUI();
                }
                if (this.toolbarModule && this.toolbarModule.toolbar) {
                    this.toolbarModule.toolbar.width = this.getGridWidthAsNumber() - 2;
                }
                this.chart.element.style.width = formatUnit(this.getGridWidthAsNumber());
                this.chart.width = formatUnit(this.getGridWidthAsNumber());
                if (this.currentView === 'Table') {
                    this.grid.element.style.display = '';
                    this.chart.element.style.display = 'none';
                }
                else {
                    this.grid.element.style.display = 'none';
                    this.chart.element.style.display = '';
                }
            }
        }
        if (this.toolbarModule) {
            if (this.showFieldList && this.element.querySelector('#' + this.element.id + '_PivotFieldList')) {
                this.element.querySelector('#' + this.element.id + '_PivotFieldList').style.display = 'none';
            }
            if (this.toolbarModule && this.toolbarModule.action !== 'New' && this.toolbarModule.action !== 'Load'
                && this.toolbarModule.action !== 'Remove') {
                this.isModified = true;
            }
            else {
                this.toolbarModule.action = '';
            }
        }
    }
    /**
     * @hidden
     */
    showWaitingPopup() {
        if (this.grid && this.grid.element) {
            showSpinner(this.grid.element);
        }
        else {
            showSpinner(this.element);
        }
    }
    /**
     * @hidden
     */
    hideWaitingPopup() {
        if (this.grid && this.grid.element) {
            hideSpinner(this.grid.element);
        }
        else {
            hideSpinner(this.element);
        }
    }
    /* tslint:disable:max-func-body-length */
    /**
     * Updates the PivotEngine using dataSource from Pivot View component.
     * @method updateDataSource
     * @return {void}
     * @hidden
     */
    updateDataSource(isRefreshGrid) {
        this.showWaitingPopup();
        let pivot = this;
        //setTimeout(() => {
        /* tslint:disable:align */
        let isSorted = Object.keys(pivot.lastSortInfo).length > 0 ? true : false;
        let isFiltered = Object.keys(pivot.lastFilterInfo).length > 0 ? true : false;
        let isAggChange = Object.keys(pivot.lastAggregationInfo).length > 0 ? true : false;
        let isCalcChange = Object.keys(pivot.lastCalcFieldInfo).length > 0 ? true : false;
        let args = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(pivot.dataSourceSettings)
        };
        pivot.trigger(enginePopulating, args, (observedArgs) => {
            if (!(pivot.enableVirtualization && (isSorted || isFiltered || isAggChange || isCalcChange))) {
                PivotUtil.updateDataSourceSettings(pivot, observedArgs.dataSourceSettings);
            }
            pivot.updatePageSettings(false);
            if (pivot.dataType === 'pivot' && pivot.enableVirtualization && (isSorted || isFiltered || isAggChange || isCalcChange)) {
                /* tslint:disable-next-line:no-any */
                let interopArguments = {};
                if (isSorted) {
                    pivot.setProperties({ dataSourceSettings: { valueSortSettings: { headerText: '' } } }, true);
                    if (isBlazor()) {
                        let ejsInterop = 'ejsInterop';
                        let sortInfo = {
                            name: pivot.lastSortInfo.name,
                            order: pivot.lastSortInfo.order
                        };
                        /* tslint:disable-next-line */
                        let sortArgs = window[ejsInterop].copyWithoutCircularReferences([pivot.lastSortInfo], pivot.lastSortInfo);
                        interopArguments = { 'key': 'onSort', 'arg': sortArgs };
                    }
                    else {
                        pivot.engineModule.onSort(pivot.lastSortInfo);
                    }
                    pivot.lastSortInfo = {};
                }
                if (isAggChange) {
                    if (isBlazor()) {
                        /* tslint:disable */
                        let ejsInterop = 'ejsInterop';
                        let aggregateArgs = window[ejsInterop].copyWithoutCircularReferences([pivot.lastAggregationInfo], pivot.lastAggregationInfo);
                        interopArguments = { 'key': 'onAggregation', 'arg': aggregateArgs };
                        /* tslint:enable */
                    }
                    else {
                        pivot.engineModule.onAggregation(pivot.lastAggregationInfo);
                    }
                    pivot.lastAggregationInfo = {};
                }
                if (isCalcChange) {
                    if (isBlazor()) {
                        /* tslint:disable */
                        let dataSourceSettings = window['ejsInterop'].copyWithoutCircularReferences([pivot.dataSourceSettings.properties], pivot.dataSourceSettings.properties);
                        interopArguments = {
                            'key': 'onCalcOperation',
                            'arg': {
                                lastCalcFieldInfo: pivot.lastCalcFieldInfo,
                                values: dataSourceSettings.values,
                                calculatedFieldSettings: dataSourceSettings.calculatedFieldSettings
                            }
                        };
                        /* tslint:enable */
                    }
                    else {
                        pivot.engineModule.onCalcOperation(pivot.lastCalcFieldInfo);
                    }
                    pivot.lastCalcFieldInfo = {};
                }
                if (isFiltered) {
                    if (isBlazor()) {
                        /* tslint:disable */
                        let filterArgs = window['ejsInterop'].copyWithoutCircularReferences([pivot.lastFilterInfo], pivot.lastFilterInfo);
                        let filterSettings = window['ejsInterop'].copyWithoutCircularReferences([pivot.dataSourceSettings.filterSettings], pivot.dataSourceSettings.filterSettings);
                        interopArguments = {
                            'key': 'onFilter',
                            'arg': { 'lastFilterInfo': filterArgs, 'filterSettings': filterSettings }
                        };
                        /* tslint:enable */
                    }
                    else {
                        pivot.engineModule.onFilter(pivot.lastFilterInfo, pivot.dataSourceSettings);
                    }
                    pivot.lastFilterInfo = {};
                }
                if (isBlazor()) {
                    /* tslint:disable */
                    pivot.interopAdaptor.invokeMethodAsync('PivotInteropMethod', interopArguments['key'], interopArguments['arg']).then((data) => {
                        pivot.updateBlazorData(data, pivot);
                        pivot.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
                        pivot.enginePopulatedEventMethod('updateDataSource', pivot);
                        if (pivot.calculatedFieldModule && pivot.calculatedFieldModule.isRequireUpdate) {
                            pivot.calculatedFieldModule.endDialog();
                            pivot.calculatedFieldModule.isRequireUpdate = false;
                        }
                    });
                    /* tslint:enable */
                }
                else {
                    pivot.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
                    pivot.enginePopulatedEventMethod('updateDataSource');
                }
            }
            else {
                if (pivot.dataType === 'olap') {
                    /* tslint:disable:align */
                    let customProperties = {
                        mode: '',
                        savedFieldList: pivot.olapEngineModule.fieldList,
                        savedFieldListData: pivot.olapEngineModule.fieldListData,
                        pageSettings: pivot.pageSettings,
                        enableValueSorting: pivot.enableValueSorting,
                        isDrillThrough: (pivot.allowDrillThrough || pivot.editSettings.allowEditing),
                        localeObj: pivot.localeObj
                    };
                    if (isCalcChange || isSorted) {
                        pivot.olapEngineModule.savedFieldList = pivot.olapEngineModule.fieldList;
                        pivot.olapEngineModule.savedFieldListData = pivot.olapEngineModule.fieldListData;
                        if (isCalcChange) {
                            pivot.olapEngineModule.updateCalcFields(pivot.dataSourceSettings, pivot.lastCalcFieldInfo);
                            pivot.lastCalcFieldInfo = {};
                        }
                        else {
                            pivot.olapEngineModule.onSort(pivot.dataSourceSettings);
                            pivot.lastSortInfo = {};
                        }
                    }
                    else {
                        pivot.olapEngineModule.renderEngine(pivot.dataSourceSettings, customProperties);
                    }
                    pivot.setProperties({ pivotValues: pivot.olapEngineModule.pivotValues }, true);
                    pivot.enginePopulatedEventMethod('updateDataSource');
                }
                else {
                    /* tslint:disable:align */
                    let customProperties = {
                        mode: '',
                        savedFieldList: pivot.engineModule.fieldList,
                        pageSettings: pivot.pageSettings,
                        enableValueSorting: pivot.enableValueSorting,
                        isDrillThrough: (pivot.allowDrillThrough || pivot.editSettings.allowEditing),
                        localeObj: pivot.localeObj,
                        fieldsType: pivot.fieldsType
                    };
                    if (isBlazor() && pivot.enableVirtualization) {
                        /* tslint:disable */
                        let ejsInterop = 'ejsInterop';
                        let customArgs = window[ejsInterop].copyWithoutCircularReferences([customProperties], customProperties);
                        let datasourceSettings = window[ejsInterop].copyWithoutCircularReferences([pivot.dataSourceSettings], pivot.dataSourceSettings);
                        pivot.interopAdaptor.invokeMethodAsync('PivotInteropMethod', 'renderEngine', { 'dataSourceSettings': datasourceSettings, 'customProperties': customArgs }).then((data) => {
                            pivot.updateBlazorData(data, pivot);
                            pivot.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
                            pivot.enginePopulatedEventMethod('updateDataSource', pivot);
                        });
                        /* tslint:enable */
                    }
                    else {
                        pivot.engineModule.renderEngine(pivot.dataSourceSettings, customProperties, pivot.getValueCellInfo.bind(pivot));
                        pivot.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
                        pivot.enginePopulatedEventMethod('updateDataSource');
                    }
                }
            }
        });
        //});
    }
    /**
     * Export Pivot widget data to Excel file(.xlsx).
     * @param  {ExcelExportProperties} excelExportProperties - Defines the export properties of the Grid.
     * @param  {boolean} isMultipleExport - Define to enable multiple export.
     * @param  {workbook} workbook - Defines the Workbook if multiple export is enabled.
     * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.
     * @returns void
     */
    /* tslint:disable-next-line:no-any */
    excelExport(excelExportProperties, isMultipleExport, workbook, isBlob) {
        if (this.enableVirtualization) {
            this.excelExportModule.exportToExcel('Excel');
        }
        else {
            this.grid.excelExport(excelExportProperties, isMultipleExport, workbook, isBlob);
        }
    }
    /**
     * Export PivotGrid data to CSV file.
     * @param  {ExcelExportProperties} excelExportProperties - Defines the export properties of the Grid.
     * @param  {boolean} isMultipleExport - Define to enable multiple export.
     * @param  {workbook} workbook - Defines the Workbook if multiple export is enabled.
     * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.
     * @returns void
     */
    /* tslint:disable-next-line:no-any */
    csvExport(excelExportProperties, isMultipleExport, workbook, isBlob) {
        if (this.enableVirtualization) {
            this.excelExportModule.exportToExcel('CSV');
        }
        else {
            this.grid.csvExport(excelExportProperties, isMultipleExport, workbook, isBlob);
        }
    }
    /**
     * Export Pivot widget data to PDF document.
     * @param  {pdfExportProperties} PdfExportProperties - Defines the export properties of the Grid.
     * @param  {isMultipleExport} isMultipleExport - Define to enable multiple export.
     * @param  {pdfDoc} pdfDoc - Defined the Pdf Document if multiple export is enabled.
     * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.
     * @returns void
     */
    pdfExport(pdfExportProperties, isMultipleExport, pdfDoc, isBlob) {
        if (this.enableVirtualization) {
            this.pdfExportModule.exportToPDF();
        }
        else {
            this.grid.pdfExport(pdfExportProperties, isMultipleExport, pdfDoc, isBlob);
        }
    }
    /**
     * Export method for the chart.
     * @param type - Defines the export type.
     * @param fileName - Defines file name of export document.
     * @param orientation - Defines the page orientation on pdf export(0 for Portrait mode, 1 for Landscape mode).
     * @param width - Defines width of the export document.
     * @param height - Defines height of the export document.
     */
    chartExport(type, fileName, orientation, width, height) {
        if (this.chart && this.chart.enableExport) {
            this.chart.exportModule.export(type, fileName, orientation, null, width, height);
        }
    }
    /**
     * Print method for the chart.
     */
    printChart() {
        if (this.chart) {
            this.chart.print();
        }
    }
    /** @hidden */
    /* tslint:disable:max-func-body-length */
    onDrill(target, chartDrillInfo) {
        let delimiter = (this.dataSourceSettings.drilledMembers[0] && this.dataSourceSettings.drilledMembers[0].delimiter) ?
            this.dataSourceSettings.drilledMembers[0].delimiter : '**';
        let fieldName = '';
        let axis = '';
        let action = '';
        if (chartDrillInfo) {
            fieldName = chartDrillInfo.fieldName;
            axis = chartDrillInfo.cell.axis;
            action = chartDrillInfo.isDrilled ? 'up' : 'down';
        }
        else {
            fieldName = target.parentElement.getAttribute('fieldname');
            axis = target.parentElement.classList.contains(ROWSHEADER) ? 'row' : 'column';
            action = target.classList.contains(COLLAPSE) ? 'up' : 'down';
        }
        if (this.dataType === 'pivot') {
            let currentCell = chartDrillInfo ? chartDrillInfo.cell :
                this.engineModule.pivotValues[Number(target.parentElement.getAttribute('index'))][Number(target.parentElement.getAttribute('aria-colindex'))];
            let memberName = currentCell.valueSort.levelName.
                split(this.engineModule.valueSortSettings.headerDelimiter).join(delimiter);
            let fieldAvail = false;
            if (this.dataSourceSettings.drilledMembers.length === 0) {
                /* tslint:disable-next-line:max-line-length */
                this.setProperties({ dataSourceSettings: { drilledMembers: [{ name: fieldName, items: [memberName], delimiter: delimiter }] } }, true);
            }
            else {
                for (let fCnt = 0; fCnt < this.dataSourceSettings.drilledMembers.length; fCnt++) {
                    let field = this.dataSourceSettings.drilledMembers[fCnt];
                    memberName = memberName.split(delimiter).join(field.delimiter ? field.delimiter : delimiter);
                    delimiter = field.delimiter = field.delimiter ? field.delimiter : delimiter;
                    if (field.name === fieldName) {
                        fieldAvail = true;
                        let memIndex = field.items.indexOf(memberName);
                        if (memIndex > -1) {
                            field.items.splice(memIndex, 1);
                        }
                        else {
                            field.items.push(memberName);
                        }
                    }
                    else {
                        continue;
                    }
                }
                if (!fieldAvail) {
                    this.dataSourceSettings.drilledMembers.push({ name: fieldName, items: [memberName], delimiter: delimiter });
                }
            }
            this.showWaitingPopup();
            let pivot = this;
            //setTimeout(() => {
            let drilledItem = {
                fieldName: fieldName, memberName: memberName, delimiter: delimiter,
                axis: axis,
                action: action,
                currentCell: currentCell
            };
            let drillArgs = {
                drillInfo: drilledItem,
                pivotview: isBlazor() ? undefined : pivot
            };
            pivot.trigger(drill, drillArgs, (observedArgs) => {
                if (pivot.enableVirtualization) {
                    if (isBlazor()) {
                        /* tslint:disable */
                        let ejsInterop = 'ejsInterop';
                        let dataSourceSettings = window[ejsInterop].copyWithoutCircularReferences([pivot.dataSourceSettings], pivot.dataSourceSettings);
                        let drillItem = window[ejsInterop].copyWithoutCircularReferences([drilledItem], drilledItem);
                        let args = window[ejsInterop].copyWithoutCircularReferences([drillArgs], drillArgs);
                        pivot.interopAdaptor.invokeMethodAsync('PivotInteropMethod', 'onDrill', { 'dataSourceSettings': dataSourceSettings, 'drilledItem': drillItem }).then((data) => {
                            pivot.updateBlazorData(data, pivot);
                            pivot.engineModule.drilledMembers = pivot.dataSourceSettings.drilledMembers;
                            pivot.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
                            pivot.renderPivotGrid();
                        });
                        /* tslint:enable */
                    }
                    else {
                        pivot.engineModule.drilledMembers = pivot.dataSourceSettings.drilledMembers;
                        pivot.engineModule.onDrill(drilledItem);
                    }
                }
                else {
                    pivot.engineModule.generateGridData(pivot.dataSourceSettings);
                }
                if (!(isBlazor() && pivot.enableVirtualization)) {
                    pivot.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
                    pivot.renderPivotGrid();
                }
            });
        }
        else {
            this.onOlapDrill(fieldName, axis, action, delimiter, target, chartDrillInfo);
        }
    }
    /* tslint:disable-next-line:max-line-length */
    onOlapDrill(fieldName, axis, action, delimiter, target, chartDrillInfo) {
        let currentCell = chartDrillInfo ? chartDrillInfo.cell :
            this.olapEngineModule.pivotValues[Number(target.parentElement.getAttribute('index'))][Number(target.parentElement.getAttribute('aria-colindex'))];
        let tupInfo = axis === 'row' ? this.olapEngineModule.tupRowInfo[currentCell.ordinal] :
            this.olapEngineModule.tupColumnInfo[currentCell.ordinal];
        let drillInfo = {
            axis: axis,
            action: action,
            fieldName: fieldName,
            delimiter: delimiter,
            memberName: tupInfo.uNameCollection,
            currentCell: currentCell
        };
        /* tslint:disable-next-line:max-line-length */
        let fieldPos = tupInfo.drillInfo.map((item) => { return item.hierarchy; }).indexOf(currentCell.hierarchy.toString());
        if (drillInfo && drillInfo.action === 'down') {
            this.olapEngineModule.drilledSets[currentCell.actualText] = tupInfo.members[fieldPos];
            let fields = drillInfo.memberName.split('::[').map((item) => {
                return item[0] === '[' ? item : ('[' + item);
            });
            let member = '';
            for (let pos = 0; pos <= fieldPos; pos++) {
                let field = fields[pos];
                let members = field.split('~~');
                member = member + (member !== '' ? '~~' : '') + members[members.length - 1];
            }
            drillInfo.memberName = member;
            let drillItem = [];
            for (let field of this.dataSourceSettings.drilledMembers) {
                if (field.name === drillInfo.fieldName) {
                    drillItem.push(field);
                }
            }
            if (drillItem.length > 0) {
                if (drillItem[0].delimiter) {
                    member = member.replace(/~~/g, drillItem[0].delimiter);
                }
                let index = PivotUtil.inArray(member, drillItem[0].items);
                if (index === -1) {
                    drillItem[0].items.push(member);
                }
            }
            else {
                let drilledMember = { name: drillInfo.fieldName, items: [member], delimiter: '~~' };
                if (!this.dataSourceSettings.drilledMembers) {
                    this.dataSourceSettings.drilledMembers = [drilledMember];
                }
                else {
                    this.dataSourceSettings.drilledMembers.push(drilledMember);
                }
            }
            this.olapEngineModule.updateDrilledInfo(this.dataSourceSettings);
        }
        else {
            delete this.olapEngineModule.drilledSets[currentCell.actualText];
            let drillSets = this.olapEngineModule.getDrilledSets(drillInfo.memberName, currentCell, fieldPos, axis);
            let keys = Object.keys(drillSets);
            for (let key of keys) {
                let drillSet = drillSets[key];
                for (let i = 0, cnt = this.dataSourceSettings.drilledMembers.length; i < cnt; i++) {
                    let drillItem = this.dataSourceSettings.drilledMembers[i];
                    let member = drillSet;
                    if (drillItem.delimiter) {
                        member = drillSet.replace(/~~/g, drillItem.delimiter);
                    }
                    let items = [];
                    for (let itemPos = 0; itemPos < drillItem.items.length; itemPos++) {
                        if (drillItem.items[itemPos].indexOf(member) !== 0) {
                            items[items.length] = drillItem.items[itemPos];
                        }
                    }
                    drillItem.items = items;
                }
            }
            let drilledMembers = [];
            for (let fields of this.dataSourceSettings.drilledMembers) {
                if (fields.items.length > 0) {
                    drilledMembers.push(fields);
                }
            }
            this.setProperties({ dataSourceSettings: { drilledMembers: drilledMembers } }, true);
            this.olapEngineModule.updateDrilledInfo(this.dataSourceSettings);
        }
        this.setProperties({ pivotValues: this.olapEngineModule.pivotValues }, true);
        this.renderPivotGrid();
    }
    onContentReady() {
        if (this.currentView !== 'Table') {
            /* tslint:disable-next-line */
            if (this.cellTemplate && isBlazor()) {
                resetBlazorTemplate(this.element.id + '_cellTemplate', 'CellTemplate');
            }
        }
        this.isPopupClicked = false;
        if (this.showFieldList) {
            hideSpinner(this.pivotFieldListModule.fieldListSpinnerElement);
        }
        else if (this.fieldListSpinnerElement) {
            hideSpinner(this.fieldListSpinnerElement);
        }
        if (!this.isEmptyGrid) {
            this.hideWaitingPopup();
            this.trigger(dataBound);
        }
        else {
            this.isEmptyGrid = false;
        }
        if (this.grid) {
            let engine = this.dataType === 'pivot' ? this.engineModule : this.olapEngineModule;
            if (this.enableVirtualization && engine) {
                if (this.element.querySelector('.' + MOVABLECONTENT_DIV) &&
                    !this.element.querySelector('.' + MOVABLECONTENT_DIV).querySelector('.' + VIRTUALTRACK_DIV)) {
                    this.virtualDiv = createElement('div', { className: VIRTUALTRACK_DIV });
                    this.element.querySelector('.' + MOVABLECONTENT_DIV).appendChild(this.virtualDiv);
                }
                if (this.element.querySelector('.' + MOVABLEHEADER_DIV) &&
                    !this.element.querySelector('.' + MOVABLEHEADER_DIV).querySelector('.' + VIRTUALTRACK_DIV)) {
                    this.virtualHeaderDiv = createElement('div', { className: VIRTUALTRACK_DIV });
                    this.element.querySelector('.' + MOVABLEHEADER_DIV).appendChild(this.virtualHeaderDiv);
                }
                else {
                    this.virtualHeaderDiv =
                        this.element.querySelector('.' + MOVABLEHEADER_DIV).querySelector('.' + VIRTUALTRACK_DIV);
                }
                let movableTable = this.element.querySelector('.' + MOVABLECONTENT_DIV).querySelector('.e-table');
                let vHeight = (this.gridSettings.rowHeight * engine.rowCount + 0.1 - movableTable.clientHeight);
                if (vHeight > this.scrollerBrowserLimit) {
                    this.verticalScrollScale = vHeight / this.scrollerBrowserLimit;
                    vHeight = this.scrollerBrowserLimit;
                }
                let vWidth = (this.gridSettings.columnWidth * engine.columnCount
                    - this.grid.columns[0].width);
                if (vWidth > this.scrollerBrowserLimit) {
                    this.horizontalScrollScale = vWidth / this.scrollerBrowserLimit;
                    vWidth = this.scrollerBrowserLimit;
                }
                setStyleAttribute(this.virtualDiv, {
                    height: (vHeight > 0.1 ? vHeight : 0.1) + 'px',
                    width: (vWidth > 0.1 ? vWidth : 0.1) + 'px'
                });
                setStyleAttribute(this.virtualHeaderDiv, {
                    height: 0, width: (vWidth > 0.1 ? vWidth : 0.1) + 'px'
                });
                let mCnt = this.element.querySelector('.' + MOVABLECONTENT_DIV);
                let fCnt = this.element.querySelector('.' + FROZENCONTENT_DIV);
                let mHdr = this.element.querySelector('.' + MOVABLEHEADER_DIV);
                let verOffset = (mCnt.scrollTop > this.scrollerBrowserLimit) ?
                    mCnt.querySelector('.' + TABLE).style.transform.split(',')[1].trim() :
                    -(((mCnt.scrollTop * this.verticalScrollScale) - this.scrollPosObject.verticalSection - mCnt.scrollTop)) + 'px)';
                let horiOffset = (mCnt.scrollLeft > this.scrollerBrowserLimit) ?
                    (mCnt.querySelector('.' + TABLE).style.transform.split(',')[0].trim() + ',') :
                    'translate(' + -(((mCnt.scrollLeft * this.horizontalScrollScale) -
                        this.scrollPosObject.horizontalSection - mCnt.scrollLeft)) + 'px,';
                setStyleAttribute(fCnt.querySelector('.e-table'), {
                    transform: 'translate(' + 0 + 'px,' + verOffset
                });
                setStyleAttribute(mCnt.querySelector('.e-table'), {
                    transform: horiOffset + verOffset
                });
                setStyleAttribute(mHdr.querySelector('.e-table'), {
                    transform: horiOffset + 0 + 'px)'
                });
            }
            if (this.showGroupingBar) {
                this.element.style.minWidth = '400px';
                this.grid.element.style.minWidth = '400px';
            }
            else {
                this.element.style.minWidth = '310px';
                this.grid.element.style.minWidth = '310px';
            }
        }
        this.unwireEvents();
        this.wireEvents();
        this.isChartLoaded = false;
        if (this.cellTemplate && isBlazor()) {
            let gridCells = Object.keys(this.gridCellCollection);
            if (gridCells.length > 0) {
                for (let cell of gridCells) {
                    /* tslint:disable-next-line */
                    let templateObject = {};
                    let tCell = this.gridCellCollection[cell];
                    let colIndex = Number(tCell.getAttribute('aria-colindex'));
                    let rowIndex = Number(tCell.getAttribute('index'));
                    let pivotCell = this.pivotValues[rowIndex][colIndex];
                    templateObject.axis = pivotCell.axis;
                    if (templateObject.axis === 'column' || templateObject.axis === 'row') {
                        templateObject.fieldName = pivotCell.valueSort.axis;
                        templateObject.formattedText = pivotCell.formattedText;
                    }
                    else {
                        templateObject.fieldName = pivotCell.actualText;
                        templateObject.formattedText = pivotCell.formattedText;
                        templateObject.value = pivotCell.value;
                    }
                    /* tslint:disable-next-line */
                    let element = this.getCellTemplate()(templateObject, this, 'cellTemplate', this.element.id + '_cellTemplate');
                    if (element && element !== '' && element.length > 0) {
                        if (this.enableHtmlSanitizer) {
                            this.appendHtml(tCell, SanitizeHtmlHelper.sanitize(element[0].outerHTML));
                        }
                        else {
                            this.appendHtml(tCell, element[0].outerHTML);
                        }
                    }
                }
                updateBlazorTemplate(this.element.id + '_cellTemplate', 'CellTemplate', this);
            }
        }
    }
    setToolTip(args) {
        let colIndex = Number(args.target.getAttribute('aria-colindex'));
        let rowIndex = Number(args.target.getAttribute('index'));
        let cell = this.pivotValues[rowIndex][colIndex];
        this.tooltip.content = '';
        let aggregateType;
        let caption;
        let hasField = false;
        if (cell && this.dataType === 'olap') {
            if (this.olapEngineModule.fieldList[cell.actualText]) {
                let field = this.olapEngineModule.fieldList[cell.actualText];
                aggregateType = field.isCalculatedField ? field.type : field.aggregateType;
                caption = field.caption;
                hasField = true;
            }
        }
        else {
            if (cell && this.engineModule.fieldList[cell.actualText]) {
                let field = this.engineModule.fieldList[cell.actualText];
                aggregateType = field.aggregateType;
                caption = field.caption;
                hasField = true;
            }
        }
        if (cell && hasField) {
            this.tooltip.content = '<div class=' + PIVOTTOOLTIP + '><p class=' + TOOLTIP_HEADER + '>' +
                this.localeObj.getConstant('row') + ':</p><p class=' + TOOLTIP_CONTENT + '>' +
                this.getRowText(rowIndex, 0) +
                '</p></br><p class=' + TOOLTIP_HEADER + '>' +
                this.localeObj.getConstant('column') + ':</p><p class=' + TOOLTIP_CONTENT + '>' +
                this.getColText(0, colIndex, rowIndex) + '</p></br>' + (cell.actualText !== '' ? ('<p class=' + TOOLTIP_HEADER + '>' +
                (this.dataType === 'olap' ? '' :
                    (this.localeObj.getConstant(aggregateType) + ' ' + this.localeObj.getConstant('of') + ' ')) +
                caption + ':</p><p class=' + TOOLTIP_CONTENT + '>' +
                (((cell.formattedText === '0' || cell.formattedText === '') ?
                    this.localeObj.getConstant('noValue') : cell.formattedText)) + '</p></div>') : '');
        }
        else {
            args.cancel = true;
        }
    }
    getRowText(rowIndex, colIndex) {
        let cell = this.pivotValues[rowIndex][colIndex];
        let level = cell.level;
        let rowText = cell.type === 'grand sum' ? this.localeObj.getConstant('grandTotal') : cell.formattedText;
        while (level > 0 || cell.index === undefined) {
            rowIndex--;
            cell = this.pivotValues[rowIndex][colIndex];
            if (cell.index !== undefined) {
                if (level > cell.level) {
                    rowText = rowText + ' - ' + cell.formattedText;
                    level = level - 1;
                }
            }
        }
        return rowText.split(' - ').reverse().join(' - ');
    }
    getColText(rowIndex, colIndex, limit) {
        let cell = this.pivotValues[0][colIndex];
        let axis = cell.axis;
        let colText = cell.type === 'grand sum' ? this.localeObj.getConstant('grandTotal') : cell.formattedText;
        while (axis !== 'value' && limit > rowIndex) {
            rowIndex++;
            if (this.pivotValues[rowIndex]) {
                cell = this.pivotValues[rowIndex][colIndex];
                axis = cell.axis;
                if (cell.type !== 'sum' && cell.type !== 'grand sum' && axis !== 'value') {
                    colText = colText + ' - ' + cell.formattedText;
                }
            }
        }
        return colText;
    }
    updateClass() {
        if (this.enableRtl) {
            addClass([this.element], RTL);
        }
        else {
            removeClass([this.element], RTL);
        }
        if (this.isAdaptive) {
            addClass([this.element], DEVICE);
        }
        else {
            removeClass([this.element], DEVICE);
        }
    }
    mouseRclickHandler(e) {
        if (e.which === 3) {
            this.lastCellClicked = e.target;
        }
        else if (e.which === 0) {
            this.lastCellClicked = e.target;
        }
        this.lastCellClicked = e.target;
    }
    mouseDownHandler(e) {
        if (e.which === 3) {
            this.lastCellClicked = e.target;
        }
        if (this.isCellBoxMultiSelection) {
            this.isMouseDown = true;
            this.isMouseUp = false;
            let parent = this.parentAt(e.target, 'TH');
            this.clearSelection(parent, e, Number(parent.getAttribute('aria-colindex')), Number(parent.getAttribute('index')));
            this.lastSelectedElement = undefined;
        }
    }
    mouseMoveHandler(e) {
        if (this.isCellBoxMultiSelection) {
            e.preventDefault();
            if (this.isMouseDown && e.target) {
                let ele = e.target;
                let parentElement = this.parentAt(ele, 'TH');
                if (this.lastSelectedElement && this.lastSelectedElement !== parentElement &&
                    parentElement.classList.contains(SELECTED_BGCOLOR)) {
                    this.lastSelectedElement.classList.remove(CELL_ACTIVE_BGCOLOR);
                    this.lastSelectedElement.classList.remove(SELECTED_BGCOLOR);
                    this.lastSelectedElement = parentElement;
                }
                else {
                    this.lastSelectedElement = parentElement;
                    parentElement.classList.add(CELL_ACTIVE_BGCOLOR);
                    parentElement.classList.add(SELECTED_BGCOLOR);
                }
                this.renderModule.selected();
            }
        }
    }
    mouseUpHandler(e) {
        if (this.isCellBoxMultiSelection) {
            this.isMouseDown = false;
            this.isMouseUp = true;
        }
    }
    parentAt(target, tagName) {
        while (target.tagName !== tagName) {
            if (target.parentElement) {
                target = target.parentElement;
            }
            else {
                break;
            }
        }
        return target;
    }
    mouseClickHandler(e) {
        if (e.which === 3) {
            this.lastCellClicked = e.target;
        }
        else if (e.which === 0) {
            this.lastCellClicked = e.target;
        }
        let target = e.target;
        if ((target.classList.contains('e-headercell') ||
            target.classList.contains('e-headercelldiv') ||
            target.classList.contains('e-rowsheader') ||
            target.classList.contains('e-rowcell') ||
            target.classList.contains('e-stackedheadercelldiv') ||
            target.classList.contains('e-headertext') ||
            target.classList.contains('e-ascending') ||
            target.classList.contains('e-descending')) && this.enableValueSorting && this.dataType === 'pivot') {
            let ele = null;
            if (target.classList.contains('e-headercell') || target.classList.contains('e-rowsheader')
                || target.classList.contains('e-rowcell')) {
                ele = target;
            }
            else if (target.classList.contains('e-stackedheadercelldiv') || target.classList.contains('e-headercelldiv') ||
                target.classList.contains('e-ascending') || target.classList.contains('e-descending')) {
                ele = target.parentElement;
            }
            else if (target.classList.contains('e-headertext')) {
                ele = target.parentElement.parentElement;
            }
            this.CellClicked(target, e);
            if ((ele.parentElement.parentElement.parentElement.parentElement.classList.contains('e-movableheader')
                && this.dataSourceSettings.valueAxis === 'column') || (ele.parentElement.classList.contains('e-row') &&
                this.dataSourceSettings.valueAxis === 'row') && (ele.classList.contains('e-rowsheader') ||
                ele.classList.contains('e-stot'))) {
                /* tslint:disable */
                let colIndex = Number(ele.getAttribute('aria-colindex'));
                let rowIndex = Number(ele.getAttribute('index'));
                if (this.dataSourceSettings.valueAxis === 'row' && (this.dataSourceSettings.values.length > 1 || this.dataSourceSettings.alwaysShowValueHeader)) {
                    rowIndex = this.pivotValues[rowIndex][colIndex].type === 'value' ? rowIndex : (rowIndex + 1);
                }
                else if (this.dataSourceSettings.valueAxis === 'column' && (this.dataSourceSettings.values.length > 1 || this.dataSourceSettings.alwaysShowValueHeader)) {
                    colIndex = (Number(ele.getAttribute('aria-colindex')) + Number(ele.getAttribute('aria-colspan')) - 1);
                    rowIndex = this.engineModule.headerContent.length - 1;
                }
                this.setProperties({
                    dataSourceSettings: {
                        valueSortSettings: {
                            columnIndex: (Number(ele.getAttribute('aria-colindex')) +
                                Number(ele.getAttribute('aria-colspan')) - 1),
                            sortOrder: this.dataSourceSettings.valueSortSettings.sortOrder === 'Descending' ? 'Ascending' : 'Descending',
                            headerText: this.pivotValues[rowIndex][colIndex].valueSort.levelName,
                            headerDelimiter: this.dataSourceSettings.valueSortSettings.headerDelimiter ?
                                this.dataSourceSettings.valueSortSettings.headerDelimiter : '.'
                        }
                    }
                }, true);
                /* tslint:enable */
                this.showWaitingPopup();
                let pivot = this;
                //setTimeout(() => {
                pivot.engineModule.enableValueSorting = true;
                if (pivot.enableVirtualization) {
                    if (pivot.dataSourceSettings.enableSorting) {
                        for (let key of Object.keys(pivot.engineModule.fieldList)) {
                            pivot.engineModule.fieldList[key].sort = 'Ascending';
                        }
                        pivot.setProperties({ dataSourceSettings: { sortSettings: [] } }, true);
                    }
                    if (isBlazor()) {
                        /* tslint:disable */
                        pivot.interopAdaptor.invokeMethodAsync('PivotInteropMethod', 'applyValueSorting', { 'valueSortSettings': pivot.dataSourceSettings.valueSortSettings.properties }).then((data) => {
                            pivot.updateBlazorData(data, pivot);
                            pivot.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
                            pivot.renderPivotGrid();
                        });
                        /* tslint:enable */
                    }
                    else {
                        pivot.engineModule.rMembers = pivot.engineModule.headerCollection.rowHeaders;
                        pivot.engineModule.cMembers = pivot.engineModule.headerCollection.columnHeaders;
                        pivot.engineModule.applyValueSorting();
                        pivot.engineModule.updateEngine();
                    }
                }
                else {
                    pivot.engineModule.generateGridData(pivot.dataSourceSettings);
                }
                if (!(isBlazor() && pivot.enableVirtualization)) {
                    pivot.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
                    pivot.renderPivotGrid();
                }
            }
        }
        else if (target.classList.contains(COLLAPSE) || target.classList.contains(EXPAND)) {
            this.onDrill(target);
        }
        else {
            this.CellClicked(target, e);
            return;
        }
    }
    framePivotColumns(gridcolumns) {
        for (let column of gridcolumns) {
            if (column.columns && column.columns.length > 0) {
                this.framePivotColumns(column.columns);
            }
            else {
                /* tslint:disable */
                let levelName = column.field === '0.formattedText' ? '' :
                    (column.customAttributes ? column.customAttributes.cell.valueSort.levelName : '');
                let width = this.renderModule.setSavedWidth(column.field === '0.formattedText' ? column.field :
                    levelName, Number(column.width === 'auto' ? column.minWidth : column.width));
                this.pivotColumns.push({
                    allowReordering: column.allowReordering,
                    allowResizing: column.allowResizing,
                    headerText: levelName,
                    width: width
                });
                this.totColWidth = this.totColWidth + Number(width);
                /* tslint:enable */
            }
        }
    }
    /** @hidden */
    setGridColumns(gridcolumns) {
        if (this.element.offsetWidth < this.totColWidth) {
            for (let column of gridcolumns) {
                if (column.columns && column.columns.length > 0) {
                    this.setGridColumns(column.columns);
                }
                else {
                    /* tslint:disable */
                    let levelName = column.field === '0.formattedText' ? '' :
                        (column.customAttributes ? column.customAttributes.cell.valueSort.levelName : '');
                    column.allowReordering = this.pivotColumns[this.posCount].allowReordering;
                    column.allowResizing = this.pivotColumns[this.posCount].allowResizing;
                    let calcWidth = this.renderModule.setSavedWidth(column.field === '0.formattedText' ? column.field :
                        levelName, Number(this.pivotColumns[this.posCount].width));
                    if (column.width !== 'auto') {
                        column.width = calcWidth;
                    }
                    else {
                        column.minWidth = calcWidth;
                    }
                    this.posCount++;
                    if (column.allowReordering) {
                        this.gridSettings.allowReordering = true;
                    }
                    if (column.allowResizing) {
                        this.gridSettings.allowResizing = true;
                    }
                }
            }
            if (this.gridSettings.allowReordering) {
                Grid.Inject(Reorder);
            }
            if (this.gridSettings.allowResizing) {
                Grid.Inject(Resize);
            }
            /* tslint:enable */
        }
    }
    /** @hidden */
    fillGridColumns(gridcolumns) {
        for (let column of gridcolumns) {
            column.allowReordering = this.gridSettings.allowReordering;
            column.allowResizing = this.gridSettings.allowResizing;
            this.posCount++;
            if (column.columns && column.columns.length > 0) {
                this.fillGridColumns(column.columns);
            }
        }
    }
    /** @hidden */
    triggerColumnRenderEvent(gridcolumns) {
        this.pivotColumns = [];
        this.totColWidth = 0;
        this.framePivotColumns(gridcolumns);
        let firstColWidth = this.pivotColumns[0].width;
        let eventArgs = {
            columns: this.pivotColumns,
            dataSourceSettings: this.dataSourceSettings
        };
        this.trigger(beforeColumnsRender, eventArgs);
        if (firstColWidth !== this.pivotColumns[0].width && this.element.offsetWidth < this.totColWidth) {
            this.firstColWidth = this.pivotColumns[0].width;
        }
        this.posCount = 0;
        this.setGridColumns(gridcolumns);
    }
    /** @hidden */
    setCommonColumnsWidth(columns, width) {
        for (let column of columns) {
            if (column.field !== '0.formattedText') {
                if (column.columns) {
                    this.setCommonColumnsWidth(column.columns, width);
                }
                else {
                    if (column.width !== 'auto') {
                        column.width = width;
                    }
                    else {
                        column.minWidth = width;
                    }
                }
            }
            else {
                column.width = !this.firstColWidth ? column.width : this.firstColWidth;
            }
        }
    }
    /** @hidden */
    getHeightAsNumber() {
        let height;
        if (isNaN(this.height)) {
            if (this.height.toString().indexOf('%') > -1) {
                height = (parseFloat(this.height.toString()) / 100) * this.element.offsetHeight;
            }
            else if (this.height.toString().indexOf('px') > -1) {
                height = Number(this.height.toString().split('px')[0]);
            }
        }
        else {
            height = Number(this.height);
        }
        if (height < this.gridSettings.rowHeight) {
            height = this.gridSettings.rowHeight;
        }
        return height;
    }
    /** @hidden */
    getWidthAsNumber() {
        let width;
        if (isNaN(this.width)) {
            if (this.width.toString().indexOf('%') > -1) {
                width = (parseFloat(this.width.toString()) / 100) * this.element.offsetWidth;
            }
            else if (this.width.toString().indexOf('px') > -1) {
                width = Number(this.width.toString().split('px')[0]);
            }
            if (isNaN(width)) {
                width = this.element.offsetWidth;
            }
        }
        else {
            width = Number(this.width);
        }
        if (width < 400) {
            width = 400;
        }
        return width;
    }
    /** @hidden */
    getGridWidthAsNumber() {
        let width;
        if (isNaN(this.grid.width)) {
            if (this.grid.width.toString().indexOf('%') > -1) {
                width = (parseFloat(this.grid.width.toString()) / 100) * this.element.offsetWidth;
            }
            else if (this.grid.width.toString().indexOf('px') > -1) {
                width = Number(this.grid.width.toString().split('px')[0]);
            }
            if (isNaN(width)) {
                width = this.element.offsetWidth;
            }
        }
        else {
            width = Number(this.grid.width);
        }
        return width;
    }
    /** @hidden */
    onWindowResize() {
        /* tslint:disable */
        clearTimeout(this.timeOutObj);
        this.timeOutObj = setTimeout(this.layoutRefresh.bind(this), 500);
        /* tslint:enable */
    }
    /**
     * Refreshes the Pivot Table for blazor layoutRefresh is called for other base refresh is called
     */
    refresh() {
        if (isBlazor()) {
            this.layoutRefresh();
        }
        else {
            this.pivotRefresh();
        }
    }
    /** @hidden */
    layoutRefresh() {
        if (this.element && this.element.classList.contains('e-pivotview') &&
            (this.dataType === 'olap' ? (this.olapEngineModule && this.olapEngineModule.pivotValues) :
                this.engineModule && this.engineModule.pivotValues)) {
            if (this.grid) {
                let colLength = (this.dataType === 'olap' && this.olapEngineModule.pivotValues.length > 0) ?
                    this.olapEngineModule.pivotValues[0].length : (this.dataSourceSettings.values.length > 0 &&
                    this.engineModule.pivotValues.length > 0 ? this.engineModule.pivotValues[0].length : 2);
                let colWidth = this.renderModule.resizeColWidth(colLength);
                this.grid.width = this.renderModule.calculateGridWidth();
                this.renderModule.calculateGridHeight(true);
                this.setCommonColumnsWidth(this.grid.columns, colWidth);
                this.posCount = 0;
                if (!this.showGroupingBar) {
                    this.setGridColumns(this.grid.columns);
                }
                if (this.currentView === 'Table') {
                    /* tslint:disable-next-line */
                    if (this.cellTemplate && isBlazor()) {
                        resetBlazorTemplate(this.element.id + '_cellTemplate', 'CellTemplate');
                    }
                }
                this.grid.refreshColumns();
                if (this.showGroupingBar && this.groupingBarModule && this.element.querySelector('.' + GROUPING_BAR_CLASS)) {
                    this.groupingBarModule.setGridRowWidth();
                }
            }
            if (this.showToolbar && this.toolbarModule && this.toolbarModule.toolbar) {
                this.toolbarModule.toolbar.width = this.grid ? (this.getGridWidthAsNumber() - 2) : (this.getWidthAsNumber() - 2);
            }
            if (this.chart) {
                this.chart.width = (this.showToolbar && this.grid) ? this.getGridWidthAsNumber().toString() :
                    this.getWidthAsNumber().toString();
                if (this.displayOption.view === 'Chart' && this.showGroupingBar && this.groupingBarModule &&
                    this.element.querySelector('.' + CHART_GROUPING_BAR_CLASS)) {
                    this.groupingBarModule.refreshUI();
                }
            }
        }
    }
    CellClicked(target, e) {
        let ele = null;
        if (target.classList.contains('e-headercell') || target.classList.contains('e-rowcell')) {
            ele = target;
        }
        else if (target.classList.contains('e-stackedheadercelldiv') || target.classList.contains('e-cellvalue') ||
            target.classList.contains('e-headercelldiv')) {
            ele = target.parentElement;
        }
        else if (target.classList.contains('e-headertext')) {
            ele = target.parentElement.parentElement;
        }
        else if (target.classList.contains(ROW_SELECT)) {
            if (target.classList.contains(SPAN_CLICKED)) {
                this.isPopupClicked = false;
            }
            else {
                this.isPopupClicked = true;
            }
        }
        /* tslint:disable */
        if (ele) {
            let colIndex = Number(ele.getAttribute('aria-colindex'));
            let rowIndex = Number(ele.getAttribute('index'));
            let colSpan = Number(ele.getAttribute('aria-colspan'));
            // let selectArgs: PivotCellSelectedEventArgs = { isCellClick: true, currentCell: target };
            let selectArgs = {
                cancel: false,
                isCellClick: true,
                currentCell: ele,
                data: this.pivotValues[rowIndex][colIndex]
            };
            this.trigger(cellSelecting, selectArgs, (observedArgs) => {
                if (this.gridSettings.allowSelection) {
                    if (this.gridSettings.selectionSettings.mode === 'Both' ? !ele.classList.contains(ROW_CELL_CLASS) :
                        this.gridSettings.selectionSettings.mode !== 'Row') {
                        this.clearSelection(ele, e, colIndex, rowIndex);
                        if (!observedArgs.cancel) {
                            this.applyColumnSelection(e, ele, colIndex, colIndex + (colSpan > 0 ? (colSpan - 1) : 0), rowIndex);
                        }
                    }
                    else {
                        this.clearSelection(ele, e, colIndex, rowIndex);
                    }
                    if (this.gridSettings.selectionSettings.type === 'Multiple' &&
                        (this.gridSettings.selectionSettings.mode === 'Row' || this.gridSettings.selectionSettings.mode === 'Both')) {
                        this.applyRowSelection(0, rowIndex, e);
                    }
                }
                if (this.cellClick && observedArgs.isCellClick) {
                    this.trigger(cellClick, {
                        currentCell: ele,
                        data: this.pivotValues[rowIndex][colIndex]
                    });
                }
            });
        }
    }
    /** @hidden */
    clearSelection(ele, e, colIndex, rowIndex) {
        if ((!e.shiftKey && !e.ctrlKey) || this.gridSettings.selectionSettings.type === 'Single') {
            if (this.gridSettings.selectionSettings.mode === 'Cell') {
                if (ele.classList.contains(COLUMNSHEADER)) {
                    removeClass(this.element.querySelectorAll(('.' + ROW_CELL_CLASS + '.') + CELL_SELECTED_BGCOLOR), CELL_SELECTED_BGCOLOR);
                }
                else {
                    removeClass(this.element.querySelectorAll(('.' + COLUMNSHEADER + '.') + CELL_ACTIVE_BGCOLOR), [CELL_ACTIVE_BGCOLOR, SELECTED_BGCOLOR]);
                }
            }
            else if (this.gridSettings.selectionSettings.mode === 'Both') {
                if (ele.classList.contains(ROW_CELL_CLASS)) {
                    for (let ele of [].slice.call(this.element.querySelectorAll('.' + SELECTED_BGCOLOR))) {
                        if (Number(ele.getAttribute('index')) !== rowIndex) {
                            removeClass([ele], [CELL_ACTIVE_BGCOLOR, SELECTED_BGCOLOR]);
                        }
                    }
                }
                else {
                    removeClass(this.element.querySelectorAll('.' + CELL_SELECTED_BGCOLOR), CELL_SELECTED_BGCOLOR);
                }
            }
        }
    }
    /** @hidden */
    applyRowSelection(colIndex, rowIndex, e) {
        let pivotValue = this.engineModule.pivotValues[rowIndex][colIndex];
        if (!e.ctrlKey && !e.shiftKey && pivotValue && pivotValue.members && pivotValue.members.length > 0) {
            let parentLevel = pivotValue.level;
            let rCount = rowIndex;
            do {
                rCount++;
                pivotValue = this.engineModule.pivotValues[rCount][colIndex];
            } while (pivotValue && parentLevel < pivotValue.level);
            let _this = this;
            if (this.isAdaptive) {
                this.rowRangeSelection = {
                    enable: true,
                    startIndex: rowIndex - _this.renderModule.rowStartPos,
                    endIndex: rCount - (1 + _this.renderModule.rowStartPos)
                };
            }
            else {
                _this.grid.selectionModule.selectRowsByRange(rowIndex -
                    _this.renderModule.rowStartPos, rCount - (1 + _this.renderModule.rowStartPos));
            }
        }
    }
    /** @hidden */
    applyColumnSelection(e, target, colStart, colEnd, rowStart) {
        if (!target.classList.contains(ROWSHEADER) &&
            (this.gridSettings.selectionSettings.mode === 'Cell' ? target.classList.contains(COLUMNSHEADER) : true)) {
            let isCtrl = e.ctrlKey;
            if (this.isAdaptive && this.gridSettings.selectionSettings.type === 'Multiple') {
                this.grid.selectionModule.showPopup(e);
                if (this.isPopupClicked) {
                    this.element.querySelector('.' + ROW_SELECT).classList.add(SPAN_CLICKED);
                    isCtrl = true;
                }
                else {
                    this.element.querySelector('.' + ROW_SELECT).classList.remove(SPAN_CLICKED);
                    isCtrl = false;
                }
            }
            let queryStringArray = [];
            let type = this.gridSettings.selectionSettings.type;
            let isToggle = target.classList.contains(CELL_ACTIVE_BGCOLOR);
            let activeColumns = [];
            let actColPos = {};
            for (let cCnt = colStart; cCnt <= colEnd; cCnt++) {
                activeColumns.push(cCnt.toString());
            }
            if (!isCtrl || type === 'Single') {
                for (let ele of [].slice.call(this.element.querySelectorAll('.' + CELL_ACTIVE_BGCOLOR))) {
                    removeClass([ele], [CELL_ACTIVE_BGCOLOR, SELECTED_BGCOLOR]);
                    if (activeColumns.indexOf(ele.getAttribute('aria-colindex')) === -1) {
                        isToggle = false;
                    }
                    let colIndex = Number(ele.getAttribute('aria-colindex'));
                    actColPos[colIndex] = colIndex;
                }
                /* tslint:disable-next-line:no-any */
                activeColumns = Object.keys(actColPos).length > 0 ? Object.keys(actColPos).sort(function (a, b) {
                    return a - b;
                }) : activeColumns;
            }
            else {
                isToggle = false;
            }
            if (type === 'Multiple' && e.shiftKey) {
                this.shiftLockedPos = this.shiftLockedPos.length === 0 ? activeColumns : this.shiftLockedPos;
                if (Number(this.shiftLockedPos[0]) <= colStart) {
                    colStart = Number(this.shiftLockedPos[0]);
                }
                else {
                    colEnd = colEnd < Number(this.shiftLockedPos[this.shiftLockedPos.length - 1]) ?
                        Number(this.shiftLockedPos[this.shiftLockedPos.length - 1]) : colEnd;
                }
            }
            else {
                this.shiftLockedPos = [];
            }
            let rowSelectedList = [];
            if (e.ctrlKey && this.gridSettings.selectionSettings.mode === 'Both' && type === 'Multiple' && !target.classList.contains(ROWSHEADER)) {
                for (let ele of [].slice.call(this.element.querySelectorAll('.' + ROWSHEADER + '.' + CELL_SELECTED_BGCOLOR))) {
                    rowSelectedList.push(ele.getAttribute('index'));
                }
            }
            let count = colStart;
            while (count <= colEnd) {
                queryStringArray.push('[aria-colindex="' + count + '"]' + (this.gridSettings.selectionSettings.mode === 'Cell' ?
                    '[index="' + rowStart + '"]' : "") + '');
                count++;
            }
            if (!isToggle) {
                rowStart = target.classList.contains('e-headercell') ? rowStart : (this.renderModule.rowStartPos - 1);
                let isTargetSelected = target.classList.contains(CELL_ACTIVE_BGCOLOR);
                for (let ele of [].slice.call(this.element.querySelectorAll(queryStringArray.toString()))) {
                    if (Number(ele.getAttribute('index')) >= rowStart) {
                        if (isTargetSelected && isCtrl && (rowSelectedList.indexOf(ele.getAttribute('index')) === -1)) {
                            removeClass([ele], [CELL_ACTIVE_BGCOLOR, SELECTED_BGCOLOR]);
                        }
                        else {
                            addClass([ele], [CELL_ACTIVE_BGCOLOR, SELECTED_BGCOLOR]);
                        }
                    }
                }
            }
            this.renderModule.selected();
        }
    }
    getSelectedCellsPos() {
        let control = this;
        control.savedSelectedCellsPos = [];
        for (let ele of [].slice.call(this.element.querySelectorAll('.' + SELECTED_BGCOLOR))) {
            control.savedSelectedCellsPos.push({ rowIndex: ele.getAttribute('index'), colIndex: ele.getAttribute('aria-colindex') });
        }
    }
    setSavedSelectedCells() {
        let control = this;
        for (let item of [].slice.call(this.savedSelectedCellsPos)) {
            let query = '[aria-colindex="' + item.colIndex + '"][index="' + item.rowIndex + '"]';
            addClass([control.element.querySelector(query)], [CELL_ACTIVE_BGCOLOR, SELECTED_BGCOLOR]);
        }
    }
    /* tslint:enable */
    renderEmptyGrid() {
        this.isEmptyGrid = true;
        this.renderModule = new Render(this);
        if (this.grid && this.grid.element && this.element.querySelector('.e-grid')) {
            /* tslint:disable */
            this.grid.setProperties({
                columns: this.renderModule.frameEmptyColumns(),
                dataSource: this.renderModule.frameEmptyData()
            }, true);
            /* tslint:enable */
            this.grid.notify('datasource-modified', {});
            this.grid.refreshColumns();
        }
        else {
            if (this.element.querySelector('.' + GRID_CLASS)) {
                remove(this.element.querySelector('.' + GRID_CLASS));
            }
            this.renderModule.bindGrid(this, true);
            /* tslint:disable:no-empty */
            this.grid.showSpinner = () => { };
            this.grid.hideSpinner = () => { };
            /* tslint:enable:no-empty */
            this.element.appendChild(createElement('div', { id: this.element.id + '_grid' }));
            this.grid.isStringTemplate = true;
            this.grid.appendTo('#' + this.element.id + '_grid');
            /* tslint:disable-next-line:no-any */
            this.grid.off('data-ready', this.grid.dataReady);
            this.grid.on('data-ready', () => {
                this.grid.scrollModule.setWidth();
                this.grid.scrollModule.setHeight();
                this.grid.element.querySelector('.e-movablecontent').style.overflowY = 'auto';
            });
        }
    }
    /* tslint:disable */
    initEngine() {
        let args = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.dataSourceSettings)
        };
        this.trigger(enginePopulating, args, (observedArgs) => {
            PivotUtil.updateDataSourceSettings(this, observedArgs.dataSourceSettings);
            this.updatePageSettings(false);
            /* tslint:disable:align */
            let customProperties = {
                mode: '',
                savedFieldList: undefined,
                pageSettings: this.pageSettings,
                enableValueSorting: this.enableValueSorting,
                isDrillThrough: (this.allowDrillThrough || this.editSettings.allowEditing),
                localeObj: this.localeObj,
                fieldsType: this.fieldsType
            };
            if (this.dataType === 'pivot') {
                if (this.dataSourceSettings.groupSettings && this.dataSourceSettings.groupSettings.length > 0) {
                    let dataSet = this.engineModule.data;
                    this.clonedDataSet = (this.clonedDataSet ? this.clonedDataSet : PivotUtil.getClonedData(dataSet));
                    this.setProperties({ dataSourceSettings: { dataSource: [] } }, true);
                    this.clonedReport = this.clonedReport ? this.clonedReport : extend({}, this.dataSourceSettings, null, true);
                    this.setProperties({ dataSourceSettings: { dataSource: dataSet } }, true);
                }
                if (isBlazor() && this.enableVirtualization) {
                    let pivot = this;
                    let ejsInterop = 'ejsInterop';
                    let customArgs = window[ejsInterop].copyWithoutCircularReferences([customProperties], customProperties);
                    let datasourceSettings = window[ejsInterop].copyWithoutCircularReferences([pivot.dataSourceSettings], pivot.dataSourceSettings);
                    pivot.interopAdaptor.invokeMethodAsync('PivotInteropMethod', 'renderEngine', { 'dataSourceSettings': datasourceSettings, 'customProperties': customArgs }).then((data) => {
                        pivot.updateBlazorData(data, pivot);
                        PivotUtil.setPivotProperties(pivot, { pivotValues: pivot.engineModule.pivotValues });
                        pivot.enginePopulatedEventMethod('initEngine', pivot);
                    });
                }
                else {
                    this.engineModule.renderEngine(this.dataSourceSettings, customProperties, this.getValueCellInfo.bind(this));
                    this.setProperties({ pivotValues: this.engineModule.pivotValues }, true);
                    this.enginePopulatedEventMethod('initEngine');
                }
            }
            else if (this.dataSourceSettings.providerType === 'SSAS' && this.dataType === 'olap') {
                customProperties.savedFieldList = this.olapEngineModule.fieldList;
                customProperties.savedFieldListData = this.olapEngineModule.fieldListData;
                this.olapEngineModule.renderEngine(this.dataSourceSettings, customProperties);
                this.setProperties({ pivotValues: this.olapEngineModule.pivotValues }, true);
                this.enginePopulatedEventMethod('initEngine');
            }
        });
    }
    enginePopulatedEventMethod(action, control) {
        if (action === 'initEngine') {
            const this$ = control ? control : this;
            this.trigger(enginePopulated, { pivotValues: this.pivotValues }, (observedArgs) => {
                if (this$.dataType === 'olap') {
                    this$.olapEngineModule.pivotValues = isBlazor() ? this.olapEngineModule.pivotValues : observedArgs.pivotValues;
                    this$.pivotValues = this$.olapEngineModule.pivotValues;
                }
                else {
                    this$.engineModule.pivotValues = isBlazor() ? this.engineModule.pivotValues : observedArgs.pivotValues;
                    this$.pivotValues = this$.engineModule.pivotValues;
                }
                this$.notify(dataReady, {});
                this$.isEmptyGrid = false;
            });
        }
        else {
            let pivot = control ? control : this;
            let eventArgs = {
                dataSourceSettings: pivot.dataSourceSettings,
                pivotValues: isBlazor() ? pivot.dataType === 'olap' ? pivot.olapEngineModule.pivotValues :
                    pivot.engineModule.pivotValues : pivot.pivotValues
            };
            pivot.trigger(enginePopulated, eventArgs, (observedArgs) => {
                let dataSource = pivot.dataSourceSettings.dataSource;
                if (isBlazor() && observedArgs.dataSourceSettings.dataSource instanceof Object) {
                    observedArgs.dataSourceSettings.dataSource = dataSource;
                }
                pivot.dataSourceSettings = observedArgs.dataSourceSettings;
                if (pivot.dataType === 'olap') {
                    pivot.olapEngineModule.pivotValues = isBlazor() ? pivot.olapEngineModule.pivotValues : observedArgs.pivotValues;
                    pivot.setProperties({ pivotValues: pivot.olapEngineModule.pivotValues }, true);
                }
                else {
                    pivot.engineModule.pivotValues = isBlazor() ? pivot.engineModule.pivotValues : observedArgs.pivotValues;
                    pivot.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
                }
                pivot.pivotCommon.engineModule = pivot.dataType === 'olap' ? pivot.olapEngineModule : pivot.engineModule;
                pivot.pivotCommon.dataSourceSettings = pivot.dataSourceSettings;
                pivot.renderPivotGrid();
            });
        }
    }
    /** @hidden */
    updateBlazorData(data, control) {
        control.allowServerDataBinding = false;
        let pivVal;
        let pivotFL;
        let pivotFields;
        let valueSort;
        let blazPivot = control;
        let valContent = [];
        let headContent = [];
        pivotFL = JSON.parse(data["fieldList"]);
        pivVal = JSON.parse(data["pivotValue"]);
        pivotFields = JSON.parse(data["fields"]);
        valueSort = JSON.parse(data["valueSortSettings"]);
        let len = pivVal.length;
        let pvalues = JSON.parse(pivVal[0]);
        let pvalLen = pvalues.length;
        var blazPivotValues = new Array(len);
        for (i = 0; i < len; i++) {
            blazPivotValues[i] = new Array(pvalLen);
        }
        for (var i = 0; i < len; i++) {
            if (pivVal[i] != null) {
                let values = JSON.parse(pivVal[i]);
                let valLen = values.length;
                for (let j = 0; j < valLen; j++) {
                    blazPivotValues[i][j] = values[j];
                }
            }
            else {
                blazPivotValues[i] = undefined;
                //headContent[i] = undefined;
            }
        }
        let pivotValues = blazPivotValues;
        let rowPos;
        for (let rCnt = 0; rCnt < pivotValues.length; rCnt++) {
            if (pivotValues[rCnt] && pivotValues[rCnt][0] && pivotValues[rCnt][0].axis === 'row') {
                rowPos = rCnt;
                break;
            }
        }
        blazPivot.pivotValues = blazPivotValues;
        valContent = blazPivot.frameContent(blazPivotValues, 'value', rowPos, blazPivot);
        headContent = blazPivot.frameContent(blazPivotValues, 'header', rowPos, blazPivot);
        this.engineModule.pivotValues = blazPivotValues;
        this.engineModule.fieldList = pivotFL;
        this.engineModule.fields = pivotFields;
        this.engineModule.valueSortSettings = valueSort;
        this.engineModule.valueContent = valContent;
        this.engineModule.headerContent = headContent;
        this.engineModule.isEngineUpdated = JSON.parse(data["isEngineUpdated"]);
        this.engineModule.isEmptyData = JSON.parse(data["isEmptyData"]);
        this.engineModule.rowCount = JSON.parse(data["rowCount"]);
        this.engineModule.columnCount = JSON.parse(data["columnCount"]);
        this.engineModule.rowStartPos = JSON.parse(data["rowStartPos"]);
        this.engineModule.colStartPos = JSON.parse(data["colStartPos"]);
        this.engineModule.rowFirstLvl = JSON.parse(data["rowFirstLvl"]);
        this.engineModule.colFirstLvl = JSON.parse(data["colFirstLvl"]);
        control.allowServerDataBinding = true;
    }
    /** @hidden */
    frameContent(pivotValues, type, rowPosition, control) {
        let dataContent = [];
        var pivot = control;
        if (pivot.dataSourceSettings.values.length > 0 && !pivot.engineModule.isEmptyData) {
            if ((pivot.enableValueSorting) || !pivot.engineModule.isEngineUpdated) {
                let rowCnt = 0;
                let start = type === 'value' ? rowPosition : 0;
                let end = type === 'value' ? pivotValues.length : rowPosition;
                for (var rCnt = start; rCnt < end; rCnt++) {
                    if (pivotValues[rCnt]) {
                        rowCnt = type === 'header' ? rCnt : rowCnt;
                        dataContent[rowCnt] = {};
                        for (var cCnt = 0; cCnt < pivotValues[rCnt].length; cCnt++) {
                            if (pivotValues[rCnt][cCnt]) {
                                dataContent[rowCnt][cCnt] = pivotValues[rCnt][cCnt];
                            }
                        }
                        rowCnt++;
                    }
                }
            }
        }
        return dataContent;
    }
    /* tslint:enable */
    generateData() {
        if (this.displayOption.view !== 'Chart') {
            this.renderEmptyGrid();
        }
        this.refreshData();
    }
    refreshData() {
        this.showWaitingPopup();
        let pivot = this;
        if (isBlazor()) {
            if (pivot.dataType === 'olap') {
                if (pivot.dataSourceSettings.dataSource instanceof DataManager) {
                    pivot.dataSourceSettings.dataSource = undefined;
                }
            }
        }
        if (pivot.dataSourceSettings && (pivot.dataSourceSettings.dataSource || pivot.dataSourceSettings.url)) {
            if (pivot.dataSourceSettings.dataSource instanceof DataManager) {
                if (isBlazor() && pivot.enableVirtualization) {
                    if (!pivot.element.querySelector('.e-spinner-pane')) {
                        this.showWaitingPopup();
                    }
                    pivot.initEngine();
                }
                else {
                    setTimeout(pivot.getData.bind(pivot), 100);
                }
            }
            else if ((this.dataSourceSettings.url !== '' && this.dataType === 'olap') ||
                pivot.dataSourceSettings.dataSource.length > 0) {
                if (pivot.dataType === 'pivot') {
                    this.hideWaitingPopup();
                    pivot.engineModule.data = pivot.dataSourceSettings.dataSource;
                }
                pivot.initEngine();
            }
            else {
                this.hideWaitingPopup();
            }
        }
        else {
            this.hideWaitingPopup();
        }
    }
    getValueCellInfo(aggregateObj) {
        let args = aggregateObj;
        this.trigger(aggregateCellInfo, args);
        return args;
    }
    /**
     * De-Register the internal events.
     * @returns void
     * @hidden
     */
    bindTriggerEvents(args) {
        this.trigger(getObject('name', args), args);
    }
    getData() {
        if (isBlazor()) {
            this.dataSourceSettings.dataSource.
                executeQuery(new Query().requiresCount()).then(this.executeQuery.bind(this));
        }
        else {
            this.dataSourceSettings.dataSource.executeQuery(new Query()).then(this.executeQuery.bind(this));
        }
    }
    executeQuery(e) {
        if (!this.element.querySelector('.e-spinner-pane')) {
            this.showWaitingPopup();
        }
        let pivot = this;
        //setTimeout(() => {
        pivot.engineModule.data = e.result;
        pivot.initEngine();
        //});
    }
    /** @hidden */
    applyFormatting(pivotValues) {
        if (pivotValues) {
            let colIndex = [];
            for (let len = pivotValues.length, i = 0; i < len; i++) {
                if (pivotValues[i] !== undefined && pivotValues[i][0] === undefined) {
                    colIndex.push(i);
                }
            }
            for (let i = 0; i < pivotValues.length; i++) {
                for (let j = 1; (pivotValues[i] && j < pivotValues[i].length); j++) {
                    if (pivotValues[i][j].axis === 'value' && pivotValues[i][j].formattedText !== '') {
                        pivotValues[i][j].style = undefined;
                        pivotValues[i][j].cssClass = undefined;
                        let format = this.dataSourceSettings.conditionalFormatSettings;
                        for (let k = 0; k < format.length; k++) {
                            if ((format[k].applyGrandTotals === true || isNullOrUndefined(format[k].applyGrandTotals)) ? true :
                                pivotValues[i][j].rowHeaders !== '' &&
                                    pivotValues[i][j].columnHeaders !== '') {
                                if (this.checkCondition(pivotValues[i][j].value, format[k].conditions, format[k].value1, format[k].value2)) {
                                    // let ilen: number =
                                    //     (this.dataSourceSettings.valueAxis === 'row' ? i : this.engineModule.headerContent.length - 1);
                                    // let jlen: number = (this.dataSourceSettings.valueAxis === 'row' ? 0 : j);
                                    if ((!format[k].measure || pivotValues[i][j].actualText === format[k].measure) &&
                                        (format[k].measure === undefined || format[k].measure !== '') && (format[k].label === undefined ||
                                        format[k].label !== '') && ((!format[k].label ||
                                        (pivotValues[i][0].valueSort.levelName
                                            .indexOf(format[k].label)) > -1) || (pivotValues[i][j]
                                        .rowHeaders.indexOf(format[k].label) > -1) ||
                                        (pivotValues[i][j].columnHeaders
                                            .indexOf(format[k].label) > -1))) {
                                        if (format[k].style && format[k].style.backgroundColor) {
                                            format[k].style.backgroundColor = this.conditionalFormattingModule
                                                .isHex(format[k].style.backgroundColor.substr(1)) ? format[k].style.backgroundColor :
                                                this.conditionalFormattingModule.colourNameToHex(format[k].style.backgroundColor);
                                        }
                                        if (format[k].style && format[k].style.color) {
                                            format[k].style.color = this.conditionalFormattingModule
                                                .isHex(format[k].style.color.substr(1)) ? format[k].style.color :
                                                this.conditionalFormattingModule.colourNameToHex(format[k].style.color);
                                        }
                                        pivotValues[i][j].style = format[k].style;
                                        pivotValues[i][j].cssClass = 'format' + this.element.id + k;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let format = this.dataSourceSettings.conditionalFormatSettings;
            for (let k = 0; k < format.length; k++) {
                let sheet = (this.createStyleSheet.bind(this))();
                let str = 'color: ' + format[k].style.color + '!important;background-color: ' + format[k].style.backgroundColor +
                    '!important;font-size: ' + format[k].style.fontSize + '!important;font-family: ' + format[k].style.fontFamily +
                    ' !important;';
                sheet.insertRule('.format' + this.element.id + k + '{' + str + '}', 0);
            }
        }
    }
    createStyleSheet() {
        let style = document.createElement('style');
        style.appendChild(document.createTextNode(''));
        document.head.appendChild(style);
        return style.sheet;
    }
    applyHyperlinkSettings() {
        if (this.pivotValues) {
            let pivotValues = this.pivotValues;
            let colIndex = [];
            for (let len = pivotValues.length, i = 0; i < len; i++) {
                if (pivotValues[i] !== undefined && pivotValues[i][0] === undefined) {
                    colIndex.push(i);
                }
            }
            if (this.hyperlinkSettings.conditionalSettings.length > 0) {
                for (let i = 0; i < pivotValues.length; i++) {
                    for (let j = 1; (pivotValues[i] && j < pivotValues[i].length); j++) {
                        if (pivotValues[i][j].axis === 'value') {
                            pivotValues[i][j].enableHyperlink = false;
                            let collection = this.hyperlinkSettings.conditionalSettings;
                            for (let k = 0; k < collection.length; k++) {
                                if (this.checkCondition(pivotValues[i][j].value, collection[k].conditions, collection[k].value1, collection[k].value2)) {
                                    let ilen = (this.dataSourceSettings.valueAxis === 'row' ?
                                        i : (this.dataType === 'pivot' ?
                                        this.engineModule.headerContent.length - 1 : this.olapEngineModule.headerContent.length - 1));
                                    let jlen = (this.dataSourceSettings.valueAxis === 'row' ? 0 : j);
                                    if ((!collection[k].measure || this.dataSourceSettings.values.length === 1 ||
                                        (pivotValues[ilen][jlen].valueSort &&
                                            (pivotValues[ilen][jlen].actualText === collection[k].measure))) &&
                                        (!collection[k].label || ((pivotValues[colIndex[collection[k].label.split('.').length - 1]] &&
                                            pivotValues[colIndex[collection[k].label.split('.').length - 1]][j] &&
                                            pivotValues[colIndex[collection[k].label.split('.').length - 1]][j].valueSort &&
                                            pivotValues[colIndex[collection[k].label.split('.').length - 1]][j].
                                                valueSort[collection[k].label]) || (pivotValues[i][0].
                                            valueSort.levelName.indexOf(collection[k].label) > -1)))) {
                                        pivotValues[i][j].enableHyperlink = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (!isNullOrUndefined(this.hyperlinkSettings.headerText)) {
                for (let i = 0; i < pivotValues.length; i++) {
                    for (let j = 1; (pivotValues[i] && j < pivotValues[i].length); j++) {
                        if (pivotValues[i][j].axis === 'value') {
                            // (pivotValues[i][j] as IAxisSet).enableHyperlink = false;
                            let label = this.hyperlinkSettings.headerText;
                            let ilen = (this.dataSourceSettings.valueAxis === 'row' ?
                                i : (this.dataType === 'pivot' ?
                                this.engineModule.headerContent.length - 1 : this.olapEngineModule.headerContent.length - 1));
                            let jlen = (this.dataSourceSettings.valueAxis === 'row' ? 0 : j);
                            if ((pivotValues[colIndex[label.split('.').length - 1]] &&
                                pivotValues[colIndex[label.split('.').length - 1]][j] &&
                                pivotValues[colIndex[label.split('.').length - 1]][j].
                                    valueSort && pivotValues[colIndex[label.split('.').length - 1]][j].
                                valueSort[label])) {
                                for (let index of colIndex) {
                                    if (pivotValues[index][j] &&
                                        pivotValues[index][j].axis === 'column' &&
                                        (pivotValues[index][j].valueSort.levelName.indexOf(label) > -1)) {
                                        pivotValues[index][j].enableHyperlink = true;
                                    }
                                }
                                pivotValues[i][j].enableHyperlink = true;
                            }
                            else if (pivotValues[i][0].valueSort.levelName.indexOf(label) > -1) {
                                pivotValues[i][0].enableHyperlink = true;
                                pivotValues[i][j].enableHyperlink = true;
                            }
                        }
                    }
                }
            }
            else {
                return;
            }
        }
    }
    checkCondition(cellValue, conditions, conditionalValue1, conditionalValue2) {
        switch (conditions) {
            case 'LessThan':
                return cellValue < conditionalValue1;
            case 'LessThanOrEqualTo':
                return cellValue <= conditionalValue1;
            case 'GreaterThan':
                return cellValue > conditionalValue1;
            case 'GreaterThanOrEqualTo':
                return cellValue >= conditionalValue1;
            case 'Equals':
                return cellValue === conditionalValue1;
            case 'NotEquals':
                return cellValue !== conditionalValue1;
            case 'Between':
                return (conditionalValue1 < conditionalValue2 && cellValue >= conditionalValue1 && cellValue <= conditionalValue2) ||
                    (conditionalValue1 > conditionalValue2 && cellValue <= conditionalValue1 && cellValue >= conditionalValue2);
            case 'NotBetween':
                return !((conditionalValue1 < conditionalValue2 && cellValue >= conditionalValue1 && cellValue <= conditionalValue2) ||
                    (conditionalValue1 > conditionalValue2 && cellValue <= conditionalValue1 && cellValue >= conditionalValue2));
            default:
                return false;
        }
    }
    /** @hidden */
    updateGroupingReport(newGroupSettings, updateGroupType) {
        if (!this.clonedDataSet && !this.clonedReport) {
            let dataSet = this.engineModule.data;
            this.clonedDataSet = PivotUtil.getClonedData(dataSet);
            this.setProperties({ dataSourceSettings: { dataSource: [] } }, true);
            this.clonedReport = PivotUtil.getClonedDataSourceSettings(this.dataSourceSettings);
            this.setProperties({ dataSourceSettings: { dataSource: dataSet } }, true);
        }
        /* tslint:disable-next-line:max-line-length */
        let dateGroup = /_date_group_years|_date_group_quarters|_date_group_quarterYear|_date_group_months|_date_group_days|_date_group_hours|_date_group_minutes|_date_group_seconds/g;
        let data = PivotUtil.getClonedData(this.clonedDataSet);
        let dataSource = this.dataSourceSettings;
        let clonedReport = this.clonedReport.properties ?
            this.clonedReport.properties : this.clonedReport;
        let axisFields = [dataSource.rows, dataSource.columns, dataSource.values, dataSource.filters];
        let fieldSettings = [dataSource.filterSettings, dataSource.sortSettings, dataSource.formatSettings, dataSource.drilledMembers];
        let clonedAxisFields = clonedReport.rows;
        clonedAxisFields = clonedAxisFields.concat(clonedReport.columns, clonedReport.values, clonedReport.filters);
        if (newGroupSettings.length === 0 || newGroupSettings.length > 0) {
            this.engineModule.groupingFields = {};
            /* tslint:disable-next-line:max-line-length */
            this.setProperties({ dataSourceSettings: { dataSource: data, groupSettings: newGroupSettings.length > 0 ? dataSource.groupSettings : [] } }, true);
            let isDateGroupUpdated = updateGroupType === 'Date';
            let fields = [];
            for (let i = 0, cnt = axisFields.length; i < cnt; i++) {
                for (let j = 0, len = axisFields[i].length; j < len; j++) {
                    let fieldName = axisFields[i][j].name;
                    if (fields.indexOf(fieldName) === -1) {
                        fields.push(fieldName);
                    }
                    let index = fields.indexOf(fieldName);
                    let group = PivotUtil.getFieldByName(fieldName, dataSource.groupSettings);
                    if ((!isNullOrUndefined(fieldName.match(dateGroup)) &&
                        isDateGroupUpdated) || (fieldName.indexOf('_custom_group') !== -1 &&
                        /* tslint:disable-next-line:max-line-length */
                        !PivotUtil.getFieldByName(fieldName.replace('_custom_group', ''), dataSource.groupSettings))) {
                        axisFields[i].splice(j, 1);
                        fields.splice(index, 1);
                        j--;
                        len--;
                    }
                    else {
                        let fieldObj = PivotUtil.getFieldByName(fieldName, clonedAxisFields);
                        if (fieldObj) {
                            axisFields[i].splice(j, 1, fieldObj);
                        }
                    }
                }
            }
            for (let fieldName of fields) {
                let filterObj = PivotUtil.getFilterItemByName(fieldName, clonedReport.filterSettings);
                let sortObj = PivotUtil.getFieldByName(fieldName, clonedReport.sortSettings);
                let formatObj = PivotUtil.getFieldByName(fieldName, clonedReport.formatSettings);
                let drillObj = PivotUtil.getFieldByName(fieldName, clonedReport.drilledMembers);
                let settingsObj = [filterObj, sortObj, formatObj, drillObj];
                for (let i = 0, cnt = fieldSettings.length; i < cnt; i++) {
                    let isExists = false;
                    for (let j = 0, len = fieldSettings[i].length; j < len; j++) {
                        let name = fieldSettings[i][j].name;
                        /* tslint:disable-next-line:max-line-length */
                        if ((!isNullOrUndefined(name.match(dateGroup)) && isDateGroupUpdated) || (name.indexOf('_custom_group') !== -1 &&
                            !PivotUtil.getFieldByName(name.replace('_custom_group', ''), dataSource.groupSettings))) {
                            fieldSettings[i].splice(j, 1);
                            j--;
                            len--;
                        }
                        else if (fieldName === fieldSettings[i][j].name) {
                            isExists = true;
                            if (settingsObj[i]) {
                                fieldSettings[i].splice(j, 1, settingsObj[i]);
                            }
                            else {
                                fieldSettings[i].splice(j, 1);
                                j--;
                                len--;
                            }
                            break;
                        }
                    }
                    if (!isExists && i === 0 && filterObj) {
                        fieldSettings[i].push(filterObj);
                    }
                    if (!isExists && i === 1 && sortObj) {
                        fieldSettings[i].push(sortObj);
                    }
                    if (!isExists && i === 2 && formatObj) {
                        fieldSettings[i].push(formatObj);
                    }
                    if (!isExists && i === 3 && drillObj) {
                        fieldSettings[i].push(drillObj);
                    }
                }
            }
        }
    }
    wireEvents() {
        if (this.displayOption.view !== 'Chart') {
            EventHandler.add(this.element, this.isAdaptive ? 'touchend' : 'click', this.mouseClickHandler, this);
            EventHandler.add(this.element, 'mousedown', this.mouseDownHandler, this);
            EventHandler.add(this.element.querySelector('.' + GRID_HEADER), 'mousemove', this.mouseMoveHandler, this);
            EventHandler.add(this.element, 'mouseup', this.mouseUpHandler, this);
            EventHandler.add(this.element, this.isAdaptive ? 'touchend' : 'contextmenu', this.mouseRclickHandler, this);
        }
        window.addEventListener('resize', this.onWindowResize.bind(this), true);
    }
    unwireEvents() {
        if (this.displayOption.view !== 'Chart') {
            EventHandler.remove(this.element, this.isAdaptive ? 'touchend' : 'click', this.mouseClickHandler);
            EventHandler.remove(this.element, 'mousedown', this.mouseDownHandler);
            if (this.element.querySelector('.' + GRID_HEADER)) {
                EventHandler.remove(this.element.querySelector('.' + GRID_HEADER), 'mousemove', this.mouseMoveHandler);
            }
            EventHandler.remove(this.element, 'mouseup', this.mouseUpHandler);
            EventHandler.remove(this.element, this.isAdaptive ? 'touchend' : 'contextmenu', this.mouseRclickHandler);
        }
        window.removeEventListener('resize', this.onWindowResize.bind(this), true);
    }
    /**
     * To destroy the PivotView elements.
     * @returns void
     */
    destroy() {
        this.removeInternalEvents();
        if (this.showGroupingBar && this.groupingBarModule) {
            this.groupingBarModule.destroy();
        }
        if (this.allowGrouping && this.groupingModule) {
            this.groupingModule.destroy();
        }
        if (this.showToolbar && this.toolbarModule) {
            this.toolbarModule.destroy();
        }
        if (this.enableVirtualization && this.virtualscrollModule) {
            this.virtualscrollModule.destroy();
        }
        if (this.allowConditionalFormatting && this.conditionalFormattingModule) {
            this.conditionalFormattingModule.destroy();
        }
        if (this.allowNumberFormatting && this.numberFormattingModule) {
            this.numberFormattingModule.destroy();
        }
        if (this.isAdaptive && this.contextMenuModule) {
            this.contextMenuModule.destroy();
        }
        if (this.keyboardModule) {
            this.keyboardModule.destroy();
        }
        if (this.tooltip) {
            this.tooltip.destroy();
        }
        if (this.chart) {
            this.chart.destroy();
        }
        this.unwireEvents();
        removeClass([this.element], ROOT);
        removeClass([this.element], RTL);
        removeClass([this.element], DEVICE);
        this.element.innerHTML = '';
        super.destroy();
    }
};
__decorate([
    Property('USD')
], PivotView.prototype, "currencyCode", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "showFieldList", void 0);
__decorate([
    Complex({}, GridSettings)
], PivotView.prototype, "gridSettings", void 0);
__decorate([
    Complex({}, ChartSettings)
], PivotView.prototype, "chartSettings", void 0);
__decorate([
    Complex({}, GroupingBarSettings)
], PivotView.prototype, "groupingBarSettings", void 0);
__decorate([
    Complex({}, HyperlinkSettings)
], PivotView.prototype, "hyperlinkSettings", void 0);
__decorate([
    Complex({}, DataSourceSettings)
], PivotView.prototype, "dataSourceSettings", void 0);
__decorate([
    Complex({}, CellEditSettings)
], PivotView.prototype, "editSettings", void 0);
__decorate([
    Complex({}, DisplayOption)
], PivotView.prototype, "displayOption", void 0);
__decorate([
    Property()
], PivotView.prototype, "pivotValues", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "showGroupingBar", void 0);
__decorate([
    Property(true)
], PivotView.prototype, "showTooltip", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "showToolbar", void 0);
__decorate([
    Property([])
], PivotView.prototype, "toolbar", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "showValuesButton", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowCalculatedField", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "enableValueSorting", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowConditionalFormatting", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowNumberFormatting", void 0);
__decorate([
    Property('auto')
], PivotView.prototype, "height", void 0);
__decorate([
    Property('auto')
], PivotView.prototype, "width", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowExcelExport", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "enableVirtualization", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowDrillThrough", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowPdfExport", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowDeferLayoutUpdate", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowDataCompression", void 0);
__decorate([
    Property(1000)
], PivotView.prototype, "maxNodeLimitInMemberEditor", void 0);
__decorate([
    Property(10000)
], PivotView.prototype, "maxRowsInDrillThrough", void 0);
__decorate([
    Property(true)
], PivotView.prototype, "loadOnDemandInMemberEditor", void 0);
__decorate([
    Property(true)
], PivotView.prototype, "enableHtmlSanitizer", void 0);
__decorate([
    Property()
], PivotView.prototype, "cellTemplate", void 0);
__decorate([
    Property()
], PivotView.prototype, "spinnerTemplate", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowGrouping", void 0);
__decorate([
    Event()
], PivotView.prototype, "queryCellInfo", void 0);
__decorate([
    Event()
], PivotView.prototype, "headerCellInfo", void 0);
__decorate([
    Event()
], PivotView.prototype, "resizing", void 0);
__decorate([
    Event()
], PivotView.prototype, "resizeStop", void 0);
__decorate([
    Event()
], PivotView.prototype, "pdfHeaderQueryCellInfo", void 0);
__decorate([
    Event()
], PivotView.prototype, "pdfQueryCellInfo", void 0);
__decorate([
    Event()
], PivotView.prototype, "excelHeaderQueryCellInfo", void 0);
__decorate([
    Event()
], PivotView.prototype, "excelQueryCellInfo", void 0);
__decorate([
    Event()
], PivotView.prototype, "columnDragStart", void 0);
__decorate([
    Event()
], PivotView.prototype, "columnDrag", void 0);
__decorate([
    Event()
], PivotView.prototype, "columnDrop", void 0);
__decorate([
    Event()
], PivotView.prototype, "beforePdfExport", void 0);
__decorate([
    Event()
], PivotView.prototype, "beforeExcelExport", void 0);
__decorate([
    Event()
], PivotView.prototype, "beforeColumnsRender", void 0);
__decorate([
    Event()
], PivotView.prototype, "selected", void 0);
__decorate([
    Event()
], PivotView.prototype, "cellDeselected", void 0);
__decorate([
    Event()
], PivotView.prototype, "rowSelected", void 0);
__decorate([
    Event()
], PivotView.prototype, "rowDeselected", void 0);
__decorate([
    Event()
], PivotView.prototype, "chartTooltipRender", void 0);
__decorate([
    Event()
], PivotView.prototype, "chartLoaded", void 0);
__decorate([
    Event()
], PivotView.prototype, "chartLoad", void 0);
__decorate([
    Event()
], PivotView.prototype, "chartResized", void 0);
__decorate([
    Event()
], PivotView.prototype, "chartAxisLabelRender", void 0);
__decorate([
    Event()
], PivotView.prototype, "contextMenuClick", void 0);
__decorate([
    Event()
], PivotView.prototype, "contextMenuOpen", void 0);
__decorate([
    Event()
], PivotView.prototype, "onPdfCellRender", void 0);
__decorate([
    Event()
], PivotView.prototype, "saveReport", void 0);
__decorate([
    Event()
], PivotView.prototype, "fetchReport", void 0);
__decorate([
    Event()
], PivotView.prototype, "loadReport", void 0);
__decorate([
    Event()
], PivotView.prototype, "renameReport", void 0);
__decorate([
    Event()
], PivotView.prototype, "removeReport", void 0);
__decorate([
    Event()
], PivotView.prototype, "newReport", void 0);
__decorate([
    Event()
], PivotView.prototype, "toolbarRender", void 0);
__decorate([
    Event()
], PivotView.prototype, "toolbarClick", void 0);
__decorate([
    Event()
], PivotView.prototype, "load", void 0);
__decorate([
    Event()
], PivotView.prototype, "enginePopulating", void 0);
__decorate([
    Event()
], PivotView.prototype, "enginePopulated", void 0);
__decorate([
    Event()
], PivotView.prototype, "onFieldDropped", void 0);
__decorate([
    Event()
], PivotView.prototype, "fieldDrop", void 0);
__decorate([
    Event()
], PivotView.prototype, "dataBound", void 0);
__decorate([
    Event()
], PivotView.prototype, "created", void 0);
__decorate([
    Event()
], PivotView.prototype, "destroyed", void 0);
__decorate([
    Event()
], PivotView.prototype, "beforeExport", void 0);
__decorate([
    Event()
], PivotView.prototype, "conditionalFormatting", void 0);
__decorate([
    Event()
], PivotView.prototype, "memberFiltering", void 0);
__decorate([
    Event()
], PivotView.prototype, "cellClick", void 0);
__decorate([
    Event()
], PivotView.prototype, "drillThrough", void 0);
__decorate([
    Event()
], PivotView.prototype, "beginDrillThrough", void 0);
__decorate([
    Event()
], PivotView.prototype, "hyperlinkCellClick", void 0);
__decorate([
    Event()
], PivotView.prototype, "cellSelecting", void 0);
__decorate([
    Event()
], PivotView.prototype, "drill", void 0);
__decorate([
    Event()
], PivotView.prototype, "cellSelected", void 0);
__decorate([
    Event()
], PivotView.prototype, "chartSeriesCreated", void 0);
__decorate([
    Event()
], PivotView.prototype, "aggregateCellInfo", void 0);
__decorate([
    Event()
], PivotView.prototype, "fieldListRefreshed", void 0);
PivotView = PivotView_1 = __decorate([
    NotifyPropertyChanges
], PivotView);

/**
 * Base export
 */

/**
 * Renderer Export
 */

/**
 * Action export
 */

/**
 * PivotGrid component exported items
 */

/**
 * Keyboard interaction
 */
/** @hidden */
class CommonKeyboardInteraction {
    /**
     * Constructor
     */
    constructor(parent) {
        this.keyConfigs = {
            shiftF: 'shift+F',
            shiftS: 'shift+S',
            delete: 'delete',
            enter: 'enter'
        };
        this.parent = parent;
        this.parent.element.tabIndex = this.parent.element.tabIndex === -1 ? 0 : this.parent.element.tabIndex;
        this.keyboardModule = new KeyboardEvents(this.parent.element, {
            keyAction: this.keyActionHandler.bind(this),
            keyConfigs: this.keyConfigs,
            eventName: 'keydown'
        });
    }
    keyActionHandler(e) {
        switch (e.action) {
            case 'shiftF':
                this.processFilter(e);
                break;
            case 'shiftS':
                this.processSort(e);
                break;
            case 'delete':
                this.processDelete(e);
                break;
            case 'enter':
                this.processOpenContextMenu(e);
                break;
        }
    }
    processOpenContextMenu(e) {
        let target = e.target;
        if (target && closest(target, '.' + PIVOT_BUTTON_CLASS) &&
            closest(target, '.' + VALUE_AXIS_CLASS)) {
            target.querySelector('.' + AXISFIELD_ICON_CLASS).click();
            e.preventDefault();
            return;
        }
    }
    processSort(e) {
        let target = e.target;
        if (target && closest(target, '.' + PIVOT_BUTTON_CLASS) &&
            !closest(target, '.' + VALUE_AXIS_CLASS) && !closest(target, '.' + AXIS_FILTER_CLASS)) {
            target.querySelector('.' + SORT_CLASS).click();
            e.preventDefault();
            return;
        }
    }
    processFilter(e) {
        let target = e.target;
        if (target && closest(target, '.' + PIVOT_BUTTON_CLASS) && !closest(target, '.' + VALUE_AXIS_CLASS)) {
            target.querySelector('.' + FILTER_COMMON_CLASS).click();
            e.preventDefault();
            return;
        }
    }
    processDelete(e) {
        let target = e.target;
        if (target && closest(target, '.' + PIVOT_BUTTON_CLASS)) {
            target.querySelector('.' + REMOVE_CLASS).click();
            e.preventDefault();
            return;
        }
    }
    /**
     * To destroy the keyboard module.
     * @return {void}
     * @private
     */
    destroy() {
        if (this.keyboardModule) {
            this.keyboardModule.destroy();
        }
        else {
            return;
        }
    }
}

/**
 * `EventBase` for active fields action.
 */
/** @hidden */
class EventBase {
    /**
     * Constructor for the dialog action.
     * @hidden
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Updates sorting order for the selected field.
     * @method updateSorting
     * @param  {Event} args - Contains clicked element information to update dataSource.
     * @return {void}
     * @hidden
     */
    updateSorting(args) {
        if (!(args.target.classList.contains(FILTER_COMMON_CLASS)) &&
            !(args.target.classList.contains(REMOVE_CLASS))) {
            if (this.parent.filterDialog.dialogPopUp) {
                this.parent.filterDialog.dialogPopUp.close();
            }
            let target = args.target;
            let fieldName;
            let checkisDescending;
            let isDescending;
            if (target.id) {
                fieldName = target.id;
                checkisDescending = [].slice.call(target.querySelectorAll('.' + SORT_DESCEND_CLASS));
            }
            else {
                fieldName = target.parentElement.id;
                checkisDescending = [].slice.call(target.parentElement.querySelectorAll('.' + SORT_DESCEND_CLASS));
            }
            if (checkisDescending.length === 0) {
                isDescending = false;
            }
            else {
                isDescending = true;
            }
            //isDescending = (target.querySelectorAll(cls.SORT_DESCEND_CLASS));
            let sortObj = PivotUtil.getFieldByName(fieldName, this.parent.dataSourceSettings.sortSettings);
            if (!isNullOrUndefined(sortObj)) {
                for (let i = 0; i < this.parent.dataSourceSettings.sortSettings.length; i++) {
                    if (this.parent.dataSourceSettings.sortSettings[i].name === fieldName) {
                        this.parent.dataSourceSettings.sortSettings.splice(i, 1);
                        break;
                    }
                }
                let newSortObj = { name: fieldName, order: isDescending ? 'Ascending' : 'Descending' };
                // let newSortObj: ISort = { name: fieldName, order: isNone ? 'Ascending' : isDescending ? 'None' : 'Descending' };
                this.parent.dataSourceSettings.sortSettings.push(newSortObj);
            }
            else {
                let newSortObj = { name: fieldName, order: isDescending ? 'Ascending' : 'Descending' };
                //let newSortObj: ISort = { name: fieldName, order: isNone ? 'Ascending' : isDescending ? 'None' : 'Descending'  };
                this.parent.dataSourceSettings.sortSettings.push(newSortObj);
            }
            this.parent.control.lastSortInfo =
                this.parent.dataSourceSettings.sortSettings[this.parent.dataSourceSettings.sortSettings.length - 1];
            isDescending ? removeClass([target], SORT_DESCEND_CLASS) : addClass([target], SORT_DESCEND_CLASS);
            // if (isDescending) {
            //     removeClass([target], cls.SORT_DESCEND_CLASS);
            //     addClass([target], cls.SORTING);
            // } else if (!isDescending && !isNone) {
            //     addClass([target], cls.SORT_DESCEND_CLASS);
            // } else if (isNone) {
            //     removeClass([target], cls.SORTING);
            // } else if (!isNone) {
            //     removeClass([target], cls.SORT_DESCEND_CLASS);
            //     removeClass([target], cls.SORTING);
            //    //addClass([target], cls.SORT_CLASS);
            // }
        }
    }
    /**
     * Updates sorting order for the selected field.
     * @method updateFiltering
     * @param  {Event} args - Contains clicked element information to update dataSource.
     * @return {void}
     * @hidden
     */
    updateFiltering(args) {
        let target = args.target;
        let fieldName = target.parentElement.id;
        let fieldCaption = target.parentElement.textContent;
        let isInclude = false;
        let filterItems = [];
        let treeData = [];
        if (this.parent.dataSourceSettings.allowMemberFilter) {
            if (this.parent.dataType === 'olap') {
                treeData = this.getOlapData(fieldName, isInclude);
            }
            else {
                let members = PivotUtil.getClonedData(this.parent.engineModule.fieldList[fieldName].dateMember);
                /* tslint:disable:typedef */
                members =
                    this.parent.engineModule.fieldList[fieldName].sort === 'Ascending' ?
                        (members.sort((a, b) => (a.actualText > b.actualText) ? 1 :
                            ((b.actualText > a.actualText) ? -1 : 0))) :
                        this.parent.engineModule.fieldList[fieldName].sort === 'Descending' ?
                            (members.sort((a, b) => (a.actualText < b.actualText) ? 1 :
                                ((b.actualText < a.actualText) ? -1 : 0))) :
                            members;
                /* tslint:enable:typedef */
                let filterObj = PivotUtil.getFilterItemByName(fieldName, this.parent.dataSourceSettings.filterSettings);
                if (!isNullOrUndefined(filterObj)) {
                    isInclude = this.isValidFilterItemsAvail(fieldName, filterObj) && filterObj.type === 'Include' ? true : false;
                    filterItems = filterObj.items ? filterObj.items : [];
                }
                treeData =
                    this.getTreeData(isInclude, members, filterItems, fieldName);
            }
        }
        if (this.parent.filterDialog.dialogPopUp) {
            this.parent.filterDialog.dialogPopUp.close();
        }
        let popupTarget;
        popupTarget = this.parent.moduleName !== 'pivotfieldlist' ?
            popupTarget = this.parent.element : popupTarget = document.getElementById(this.parent.parentID + '_Wrapper');
        this.parent.filterDialog.createFilterDialog(treeData, fieldName, fieldCaption, popupTarget);
    }
    /**
     * Returns boolean by checing the valid filter members from the selected filter settings.
     * @method isValidFilterItemsAvail
     * @param  {string} fieldName - Gets filter members for the given field name.
     * @return {boolean}
     * @hidden
     */
    isValidFilterItemsAvail(fieldName, filterObj) {
        let isItemAvail = false;
        let filterTypes = ['Include', 'Exclude'];
        if (filterObj && filterTypes.indexOf(filterObj.type) >= 0) {
            let engineModule = this.parent.engineModule;
            let field = engineModule.fieldList[fieldName];
            let members = (engineModule.formatFields[fieldName] &&
                (['date', 'dateTime', 'time'].indexOf(engineModule.formatFields[fieldName].type) > -1)) ?
                field.formattedMembers : field.members;
            for (let item of filterObj.items) {
                if (members[item]) {
                    isItemAvail = true;
                    break;
                }
            }
        }
        return isItemAvail;
    }
    getOlapData(fieldName, isInclude) {
        let treeData = [];
        let filterItems = [];
        this.parent.filterDialog.isSearchEnabled = false;
        let updatedTreeData = [];
        let engineModule = this.parent.engineModule;
        let filterObj = PivotUtil.getFilterItemByName(fieldName, this.parent.dataSourceSettings.filterSettings);
        if (engineModule.fieldList[fieldName].filterMembers.length === 0) {
            if (!this.parent.control.loadOnDemandInMemberEditor) {
                engineModule.getMembers(this.parent.dataSourceSettings, fieldName, true);
            }
            else if (filterObj && filterObj.levelCount > 1 && engineModule.fieldList[fieldName].levels.length > 1) {
                engineModule.getFilterMembers(this.parent.dataSourceSettings, fieldName, filterObj.levelCount);
            }
            else {
                engineModule.fieldList[fieldName].levelCount = 1;
                engineModule.getMembers(this.parent.dataSourceSettings, fieldName);
            }
        }
        else {
            engineModule.fieldList[fieldName].currrentMembers = {};
            engineModule.fieldList[fieldName].searchMembers = [];
        }
        let isHierarchy = engineModule.fieldList[fieldName].isHierarchy;
        treeData = engineModule.fieldList[fieldName].filterMembers;
        if (!isNullOrUndefined(filterObj)) {
            isInclude = filterObj.type ? filterObj.type === 'Include' ? true : false : true;
            filterItems = filterObj.items ? filterObj.items : [];
        }
        let filterItemObj = {};
        let dummyfilterItems = {};
        let memberObject = engineModule.fieldList[fieldName].members;
        for (let item of filterItems) {
            filterItemObj[item] = item;
            dummyfilterItems[item] = item;
            if (memberObject[item]) {
                dummyfilterItems = this.getParentNode(fieldName, item, dummyfilterItems);
            }
        }
        treeData = this.getFilteredTreeNodes(fieldName, treeData, dummyfilterItems, updatedTreeData, isHierarchy);
        treeData = this.getOlapTreeData(isInclude, PivotUtil.getClonedData(treeData), filterItemObj, fieldName, isHierarchy);
        treeData = this.sortOlapFilterData(treeData, engineModule.fieldList[fieldName].sort);
        return treeData;
    }
    /**
     * Gets sorted filter members for the selected field.
     * @method sortFilterData
     * @param  {{ [key: string]: Object }[]} treeData - Gets filter members for the given field name.
     * @return {{ [key: string]: Object }[]}
     * @hidden
     */
    sortOlapFilterData(treeData, order) {
        if (treeData.length > 0) {
            /* tslint:disable:typedef */
            treeData = order === 'Ascending' ?
                (treeData.sort((a, b) => (a.caption > b.caption) ? 1 :
                    ((b.caption > a.caption) ? -1 : 0))) : order === 'Descending' ?
                (treeData.sort((a, b) => (a.caption < b.caption) ? 1 :
                    ((b.caption < a.caption) ? -1 : 0))) : treeData;
            /* tslint:enable:typedef */
        }
        return treeData;
    }
    getParentIDs(treeObj, id, parent) {
        let data = treeObj.fields.dataSource;
        let pid;
        for (let li of data) {
            if (li.id === id) {
                pid = li.pid;
                break;
            }
        }
        if (pid) {
            parent.push(pid);
            this.getParentIDs(treeObj, pid, parent);
        }
        return parent;
    }
    getChildIDs(treeObj, id, children) {
        let data = treeObj.fields.dataSource;
        let cID;
        for (let li of data) {
            if (li.pid === id) {
                cID = li.id;
                break;
            }
        }
        if (cID) {
            children.push(cID);
            this.getParentIDs(treeObj, cID, children);
        }
        return children;
    }
    /**
     * show tree nodes using search text.
     * @hidden
     */
    /* tslint:disable:max-func-body-length */
    searchTreeNodes(args, treeObj, isFieldCollection, isHierarchy) {
        if (isFieldCollection) {
            let searchList = [];
            let nonSearchList = [];
            let list = [].slice.call(treeObj.element.querySelectorAll('li'));
            for (let element of list) {
                if ((element.querySelector('.e-list-text').textContent.toLowerCase()).indexOf(args.value.toLowerCase()) > -1) {
                    searchList.push(element);
                }
                else {
                    nonSearchList.push(element);
                }
            }
            treeObj.enableNodes(searchList);
            removeClass(searchList, ICON_DISABLE);
            treeObj.disableNodes(nonSearchList);
            addClass(nonSearchList, ICON_DISABLE);
            if (searchList.length > 0 && nonSearchList.length > 0) {
                for (let currentNode of searchList) {
                    let id = currentNode.getAttribute('data-uid');
                    let parentIDs = this.getParentIDs(treeObj, id, []);
                    let childIDs = this.getChildIDs(treeObj, id, []);
                    let pNodes = [];
                    if (parentIDs.length > 0) {
                        for (let li of nonSearchList) {
                            if (PivotUtil.inArray(li.getAttribute('data-uid'), parentIDs) !== -1) {
                                pNodes.push(li);
                            }
                        }
                    }
                    if (childIDs.length > 0) {
                        for (let li of nonSearchList) {
                            if (PivotUtil.inArray(li.getAttribute('data-uid'), childIDs) !== -1) {
                                pNodes.push(li);
                            }
                        }
                    }
                    treeObj.enableNodes(pNodes);
                    removeClass(pNodes, ICON_DISABLE);
                }
            }
            if ([].slice.call(treeObj.element.querySelectorAll('li.' + ICON_DISABLE)).length === 0) {
                treeObj.collapseAll();
            }
            else {
                treeObj.expandAll(undefined, undefined, true);
            }
        }
        else {
            this.parent.searchTreeItems = [];
            if (this.parent.dataType === 'olap' && !isHierarchy) {
                this.updateOlapSearchTree(args, treeObj, isHierarchy);
            }
            else {
                let searchList = [];
                let memberCount = 0;
                memberCount = 1;
                for (let item of this.parent.currentTreeItems) {
                    if (item.name.toLowerCase().indexOf(args.value.toLowerCase()) > -1) {
                        this.parent.searchTreeItems.push(item);
                        if (memberCount <= this.parent.control.maxNodeLimitInMemberEditor) {
                            searchList.push(item);
                        }
                        memberCount++;
                    }
                }
                memberCount--;
                if (memberCount > this.parent.control.maxNodeLimitInMemberEditor) {
                    this.parent.editorLabelElement.innerText = (memberCount - this.parent.control.maxNodeLimitInMemberEditor) +
                        this.parent.control.localeObj.getConstant('editorDataLimitMsg');
                    this.parent.filterDialog.dialogPopUp.height = (this.parent.filterDialog.allowExcelLikeFilter ? '440px' : '400px');
                    this.parent.isDataOverflow = true;
                }
                else {
                    this.parent.editorLabelElement.innerText = '';
                    this.parent.filterDialog.dialogPopUp.height = (this.parent.filterDialog.allowExcelLikeFilter ? '400px' : '350px');
                    this.parent.isDataOverflow = false;
                }
                this.parent.isDataOverflow = (memberCount > this.parent.control.maxNodeLimitInMemberEditor);
                this.parent.editorLabelElement.parentElement.style.display = this.parent.isDataOverflow ? 'block' : 'none';
                treeObj.fields = { dataSource: searchList, id: 'id', text: 'name', isChecked: 'isSelected', parentID: 'pid' };
                treeObj.dataBind();
            }
        }
    }
    updateOlapSearchTree(args, treeObj, isHierarchy) {
        let treeData = [];
        let filterDialog = this.parent.filterDialog.dialogPopUp.element;
        let fieldName = filterDialog.getAttribute('data-fieldname');
        if (args.value.toLowerCase() === '') {
            this.parent.filterDialog.isSearchEnabled = false;
            this.parent.engineModule.fieldList[fieldName].searchMembers = [];
            // (this.parent.engineModule.fieldList[fieldName] as IOlapField).currrentMembers = {};
            let updatedTreeData = [];
            let filterItemObj = {};
            let dummyfilterItems = {};
            let memberObject = this.parent.engineModule.fieldList[fieldName].members;
            let members = Object.keys(memberObject);
            let filterItems = [];
            for (let item of members) {
                if (memberObject[item].isSelected) {
                    if (!(memberObject[item].parent && memberObject[memberObject[item].parent].isSelected)) {
                        filterItems.push(item);
                    }
                }
            }
            for (let item of filterItems) {
                filterItemObj[item] = item;
                dummyfilterItems[item] = item;
                if (memberObject[item]) {
                    dummyfilterItems = this.getParentNode(fieldName, item, dummyfilterItems);
                }
            }
            let searchData = this.parent.engineModule.fieldList[fieldName].filterMembers;
            treeData = this.getFilteredTreeNodes(fieldName, searchData, dummyfilterItems, updatedTreeData, isHierarchy);
            treeData = this.getOlapTreeData(true, PivotUtil.getClonedData(treeData), filterItemObj, fieldName, isHierarchy, true);
        }
        else {
            this.parent.filterDialog.isSearchEnabled = true;
            let searchData = this.parent.engineModule.fieldList[fieldName].searchMembers;
            treeData = PivotUtil.getClonedData(searchData);
            treeData = this.getOlapSearchTreeData(true, treeData, fieldName);
        }
        treeObj.fields = { dataSource: treeData, id: 'id', text: 'name', isChecked: 'isSelected', parentID: 'pid' };
        treeObj.dataBind();
    }
    getTreeData(isInclude, members, filterItems, fieldName) {
        this.parent.currentTreeItems = [];
        this.parent.searchTreeItems = [];
        this.parent.currentTreeItemsPos = {};
        this.parent.savedTreeFilterPos = {};
        let engineModule = this.parent.engineModule;
        this.parent.isDateField = engineModule.formatFields[fieldName] &&
            ((['date', 'dateTime', 'time']).indexOf(engineModule.formatFields[fieldName].type) > -1);
        let list = [];
        let memberCount = 1;
        let filterObj = {};
        for (let item of filterItems) {
            filterObj[item] = item;
        }
        for (let member of members) {
            let memberName = this.parent.isDateField ? member.formattedText : member.actualText.toString();
            /* tslint:disable */
            let obj = {
                id: member.actualText.toString(),
                name: memberName,
                isSelected: isInclude ? false : true
            };
            /* tslint:disable */
            if (filterObj[memberName] !== undefined) {
                obj.isSelected = isInclude ? true : false;
            }
            if (memberCount <= this.parent.control.maxNodeLimitInMemberEditor) {
                list.push(obj);
            }
            if (!obj.isSelected) {
                this.parent.savedTreeFilterPos[memberCount - 1] = memberName;
            }
            this.parent.currentTreeItems.push(obj);
            this.parent.searchTreeItems.push(obj);
            this.parent.currentTreeItemsPos[member.actualText] = memberCount - 1;
            memberCount++;
        }
        this.parent.isDataOverflow = ((memberCount - 1) > this.parent.control.maxNodeLimitInMemberEditor);
        return list;
    }
    /* tslint:disable-next-line:max-line-length */
    getOlapTreeData(isInclude, members, filterObj, fieldName, isHierarchy, isSearchRender) {
        let engineModule = this.parent.engineModule;
        let fieldList = engineModule.fieldList[fieldName];
        this.parent.currentTreeItems = [];
        this.parent.searchTreeItems = [];
        this.parent.currentTreeItemsPos = {};
        let list = [];
        let memberCount = 1;
        for (let member of members) {
            let obj = member;
            let memberName = member.id.toString();
            if (!isSearchRender) {
                obj.isSelected = isInclude ? false : true;
            }
            if (filterObj[memberName] !== undefined) {
                obj.isSelected = isInclude ? true : false;
            }
            if (!isSearchRender && member.hasChildren) {
                this.updateChildNodeStates(fieldList.filterMembers, fieldName, member.id, obj.isSelected);
            }
            fieldList.members[memberName].isSelected = obj.isSelected;
            if (fieldList.currrentMembers && fieldList.currrentMembers[memberName]) {
                fieldList.currrentMembers[memberName].isSelected = obj.isSelected;
            }
            if (memberCount <= this.parent.control.maxNodeLimitInMemberEditor && isHierarchy) {
                list.push(obj);
            }
            this.parent.currentTreeItems.push(obj);
            this.parent.searchTreeItems.push(obj);
            this.parent.currentTreeItemsPos[memberName] = memberCount - 1;
            memberCount++;
        }
        this.parent.isDataOverflow = isHierarchy ? ((memberCount - 1) > this.parent.control.maxNodeLimitInMemberEditor) : false;
        return isHierarchy ? list : members;
    }
    /* tslint:disable-next-line:max-line-length */
    getOlapSearchTreeData(isInclude, members, fieldName) {
        let cMembers = this.parent.engineModule.fieldList[fieldName].members;
        for (let member of members) {
            let memberName = member.id.toString();
            if (cMembers[memberName]) {
                member.isSelected = cMembers[memberName].isSelected;
            }
            this.parent.searchTreeItems.push(member);
        }
        return members;
    }
    updateChildNodeStates(members, fieldName, node, state) {
        let cMembers = this.parent.engineModule.fieldList[fieldName].members;
        let sMembers = this.parent.engineModule.fieldList[fieldName].currrentMembers;
        for (let member of members) {
            if (member.pid && member.pid.toString() === node) {
                cMembers[member.id].isSelected = state;
                if (sMembers && sMembers[member.id]) {
                    sMembers[member.id].isSelected = state;
                }
                if (member.hasChildren) {
                    this.updateChildNodeStates(members, fieldName, member.id, state);
                }
            }
        }
    }
    /**
     * get the parent node of particular filter members.
     * @hidden
     */
    getParentNode(fieldName, item, filterObj) {
        let members = this.parent.engineModule.fieldList[fieldName].members;
        if (members[item].parent && item !== members[item].parent) {
            let parentItem = members[item].parent;
            filterObj[parentItem] = parentItem;
            this.getParentNode(fieldName, parentItem, filterObj);
        }
        return filterObj;
    }
    /* tslint:disable-next-line:max-line-length */
    getFilteredTreeNodes(fieldName, members, filterObj, treeData, isHierarchy) {
        let parentNodes = [];
        let memberObject = this.parent.engineModule.fieldList[fieldName].members;
        let selectedNodes = filterObj ? Object.keys(filterObj) : [];
        for (let node of selectedNodes) {
            let parent = memberObject[node].parent;
            if (parent !== undefined && PivotUtil.inArray(parent, parentNodes) === -1) {
                parentNodes.push(parent);
            }
        }
        for (let member of members) {
            if (isNullOrUndefined(member.pid) || PivotUtil.inArray(member.pid, parentNodes) !== -1) {
                treeData.push(member);
                if (isNullOrUndefined(member.pid) && PivotUtil.inArray(member.id, parentNodes) !== -1) {
                    memberObject[member.id].isNodeExpand = true;
                }
                else if (!isNullOrUndefined(member.pid) && PivotUtil.inArray(member.pid, parentNodes) !== -1) {
                    memberObject[member.id].isNodeExpand = false;
                    memberObject[member.pid].isNodeExpand = true;
                }
                else {
                    memberObject[member.id].isNodeExpand = false;
                }
            }
            else {
                memberObject[member.id].isNodeExpand = false;
            }
        }
        return treeData;
    }
}

/**
 * `DialogAction` module is used to handle field list dialog related behaviour.
 */
/** @hidden */
class NodeStateModified {
    /**
     * Constructor for the dialog action.
     * @hidden
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Updates the dataSource by drag and drop the selected field from either field list or axis table with dropped target position.
     * @method onStateModified
     * @param  {DragEventArgs & DragAndDropEventArgs} args -  Contains both pivot button and field list drag and drop information.
     * @param  {string} fieldName - Defines dropped field name to update dataSource.
     * @return {void}
     * @hidden
     */
    onStateModified(args, fieldName) {
        let droppedClass = '';
        let nodeDropped = true;
        let target = closest(args.target, '.' + DROPPABLE_CLASS);
        let droppedPosition = -1;
        this.parent.dataSourceUpdate.btnElement = args.element ? args.element.parentElement : undefined;
        if (target) {
            droppedClass = target.classList[1] === ROW_AXIS_CLASS ?
                'rows' : target.classList[1] === COLUMN_AXIS_CLASS ? 'columns' : target.classList[1] === VALUE_AXIS_CLASS ?
                'values' : target.classList[1] === FILTER_AXIS_CLASS ? 'filters' : '';
        }
        if (this.parent.dataType === 'olap') {
            let actualFieldName = (this.parent.engineModule.fieldList[fieldName] &&
                this.parent.engineModule.fieldList[fieldName].isCalculatedField ?
                this.parent.engineModule.fieldList[fieldName].tag : fieldName);
            if (args.cancel && droppedClass === '') {
                nodeDropped = false;
                return nodeDropped;
            }
            else if ((this.parent.dataSourceUpdate.btnElement &&
                (this.parent.dataSourceUpdate.btnElement.getAttribute('isValue') === 'true' &&
                    (droppedClass === 'filters' || droppedClass === 'values'))) ||
                (this.parent.dataSourceUpdate.btnElement &&
                    (this.parent.dataSourceUpdate.btnElement.getAttribute('isValue') === 'false' &&
                        actualFieldName.toLowerCase().indexOf('[measures].') > -1 &&
                        (droppedClass === 'filters' || droppedClass === 'rows' || droppedClass === 'columns'))) ||
                (this.parent.dataSourceUpdate.btnElement &&
                    (this.parent.dataSourceUpdate.btnElement.getAttribute('isValue') === 'false' &&
                        actualFieldName.toLowerCase().indexOf('[measures].') === -1 &&
                        this.parent.engineModule.fieldList[fieldName] &&
                        this.parent.engineModule.fieldList[fieldName].isNamedSets &&
                        (droppedClass === 'filters' || droppedClass === 'values'))) ||
                (this.parent.dataSourceUpdate.btnElement &&
                    (this.parent.dataSourceUpdate.btnElement.getAttribute('isValue') === 'false' &&
                        actualFieldName.toLowerCase().indexOf('[measures].') === -1 && droppedClass === 'values'))) {
                let title = this.parent.localeObj.getConstant('warning');
                let description = this.parent.localeObj.getConstant('fieldDropErrorAction');
                this.parent.errorDialog.createErrorDialog(title, description);
                nodeDropped = false;
                return nodeDropped;
            }
        }
        else {
            if ((args.cancel && droppedClass === '') ||
                (this.parent.dataSourceUpdate.btnElement && this.parent.dataSourceUpdate.btnElement.getAttribute('isValue') === 'true' &&
                    ((droppedClass === 'filters' || droppedClass === 'values') ||
                        droppedClass.indexOf(this.parent.dataSourceSettings.valueAxis) > -1))) {
                nodeDropped = false;
                return nodeDropped;
            }
        }
        if (droppedClass !== '') {
            if (this.parent.dataType === 'olap') {
                let actualFieldName = (this.parent.engineModule.fieldList[fieldName] &&
                    this.parent.engineModule.fieldList[fieldName].isCalculatedField ?
                    this.parent.engineModule.fieldList[fieldName].tag : fieldName);
                if ((actualFieldName.toLowerCase().indexOf('[measures].') > -1 &&
                    (droppedClass === 'filters' || droppedClass === 'rows' || droppedClass === 'columns')) ||
                    (this.parent.engineModule.fieldList[fieldName] &&
                        this.parent.engineModule.fieldList[fieldName].isNamedSets && droppedClass === 'filters') ||
                    (actualFieldName.toLowerCase().indexOf('[measures].') === -1 && droppedClass === 'values')) {
                    let title = this.parent.localeObj.getConstant('warning');
                    let description = this.parent.localeObj.getConstant('fieldDropErrorAction');
                    this.parent.errorDialog.createErrorDialog(title, description);
                    nodeDropped = false;
                    return nodeDropped;
                }
            }
            if (this.parent.dataType === 'pivot' && this.parent.engineModule.fieldList[fieldName] &&
                this.parent.engineModule.fieldList[fieldName].aggregateType === 'CalculatedField' && droppedClass !== 'values') {
                let title = this.parent.localeObj.getConstant('warning');
                let description = this.parent.localeObj.getConstant('dropAction');
                this.parent.errorDialog.createErrorDialog(title, description);
                nodeDropped = false;
                return nodeDropped;
            }
            droppedPosition = this.getButtonPosition(args.target, droppedClass);
        }
        else if (this.parent.engineModule.fieldList[fieldName]) {
            this.parent.engineModule.fieldList[fieldName].isSelected = false;
            if (this.parent.dataType === 'olap') {
                this.parent.engineModule.updateFieldlistData(fieldName);
            }
        }
        this.parent.dataSourceUpdate.updateDataSource(fieldName, droppedClass, droppedPosition);
        return isBlazor() ? false : nodeDropped;
    }
    getButtonPosition(target, droppedClass) {
        let droppedPosition = -1;
        let targetBtn = closest(target, '.' + PIVOT_BUTTON_WRAPPER_CLASS);
        if (!isNullOrUndefined(targetBtn)) {
            targetBtn = targetBtn.querySelector('.' + PIVOT_BUTTON_CLASS);
            let axisPanel = this.parent.element.querySelector('.e-' + droppedClass);
            let pivotButtons = [].slice.call(axisPanel.querySelectorAll('.' + PIVOT_BUTTON_CLASS));
            for (let i = 0, n = pivotButtons.length; i < n; i++) {
                if (pivotButtons[i].id === targetBtn.id) {
                    droppedPosition = i;
                    break;
                }
            }
        }
        return droppedPosition;
    }
}

/**
 * `DataSourceUpdate` module is used to update the dataSource.
 */
/** @hidden */
class DataSourceUpdate {
    /**
     * Constructor for the dialog action.
     * @hidden
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Updates the dataSource by adding the given field along with field dropped position to the dataSource.
     * @param  {string} fieldName - Defines dropped field name to update dataSource.
     * @param  {string} droppedClass -  Defines dropped field axis name to update dataSource.
     * @param  {number} fieldCaption - Defines dropped position to the axis based on field position.
     * @method updateDataSource
     * @return {void}
     * @hidden
     */
    updateDataSource(fieldName, droppedClass, droppedPosition) {
        let dataSourceItem;
        let draggedClass;
        let row = this.parent.dataSourceSettings.rows;
        let column = this.parent.dataSourceSettings.columns;
        let value = this.parent.dataSourceSettings.values;
        let filter = this.parent.dataSourceSettings.filters;
        let field = [row, column, value, filter];
        for (let len = 0, lnt = field.length; len < lnt; len++) {
            if (field[len]) {
                for (let i = 0, n = field[len].length; i < n; i++) {
                    if (field[len][i].name === fieldName || (this.parent.dataType === 'olap' &&
                        field[len][i].name.toLowerCase() === '[measures]' && field[len][i].name.toLowerCase() === fieldName)) {
                        draggedClass = len === 0 ? 'rows' : len === 1 ? 'columns' : len === 2 ? 'values' : 'filters';
                    }
                    if (!draggedClass) {
                        draggedClass = 'fieldList';
                    }
                }
            }
        }
        let eventdrop = {
            'droppedField': this.parent.engineModule.fieldList[fieldName.toString()], 'dataSourceSettings': this.parent.dataSourceSettings,
            'droppedAxis': droppedClass, 'draggedAxis': draggedClass, 'cancel': false
        };
        this.control.trigger(fieldDrop, eventdrop, (observedArgs) => {
            if (!observedArgs.cancel) {
                if (this.control && this.btnElement && this.btnElement.getAttribute('isvalue') === 'true') {
                    switch (droppedClass) {
                        case '':
                            this.control.setProperties({ dataSourceSettings: { values: [] } }, true);
                            break;
                        case 'rows':
                            this.control.setProperties({ dataSourceSettings: { valueAxis: 'row' } }, true);
                            break;
                        case 'columns':
                            this.control.setProperties({ dataSourceSettings: { valueAxis: 'column' } }, true);
                            break;
                    }
                }
                else {
                    dataSourceItem = this.removeFieldFromReport(fieldName.toString());
                    dataSourceItem = dataSourceItem ? dataSourceItem : this.getNewField(fieldName.toString());
                    if (dataSourceItem.type === 'CalculatedField' && droppedClass !== '') {
                        droppedClass = 'values';
                    }
                }
                if (this.parent.dataType === 'olap') {
                    dataSourceItem = this.removeFieldFromReport(fieldName.toString());
                    dataSourceItem = dataSourceItem ? dataSourceItem : this.getNewField(fieldName.toString());
                    if (this.parent.dataSourceSettings.values.length === 0) {
                        this.removeFieldFromReport('[measures]');
                    }
                    if (dataSourceItem.type === 'CalculatedField' && droppedClass !== '') {
                        droppedClass = 'values';
                    }
                }
                if (this.control) {
                    let eventArgs = {
                        'droppedField': dataSourceItem, 'dataSourceSettings': this.parent.dataSourceSettings, 'droppedAxis': droppedClass
                    };
                    /* tslint:disable */
                    let dataSourceUpdate = this;
                    this.control.trigger(onFieldDropped, eventArgs, (observedArgs) => {
                        eventArgs = observedArgs;
                        if (dataSourceItem) {
                            dataSourceItem = observedArgs.droppedField;
                            switch (droppedClass) {
                                case 'filters':
                                    droppedPosition !== -1 ?
                                        (isBlazor() ? dataSourceUpdate.parent.dataSourceSettings.filters.splice(droppedPosition, 0, dataSourceItem) : this.parent.dataSourceSettings.filters.splice(droppedPosition, 0, dataSourceItem)) :
                                        (isBlazor() ? dataSourceUpdate.parent.dataSourceSettings.filters.push(dataSourceItem) : this.parent.dataSourceSettings.filters.push(dataSourceItem));
                                    break;
                                case 'rows':
                                    droppedPosition !== -1 ?
                                        (isBlazor() ? dataSourceUpdate.parent.dataSourceSettings.rows.splice(droppedPosition, 0, dataSourceItem) : this.parent.dataSourceSettings.rows.splice(droppedPosition, 0, dataSourceItem)) :
                                        (isBlazor() ? dataSourceUpdate.parent.dataSourceSettings.rows.push(dataSourceItem) : this.parent.dataSourceSettings.rows.push(dataSourceItem));
                                    break;
                                case 'columns':
                                    droppedPosition !== -1 ?
                                        (isBlazor() ? dataSourceUpdate.parent.dataSourceSettings.columns.splice(droppedPosition, 0, dataSourceItem) : this.parent.dataSourceSettings.columns.splice(droppedPosition, 0, dataSourceItem)) :
                                        (isBlazor() ? dataSourceUpdate.parent.dataSourceSettings.columns.push(dataSourceItem) : this.parent.dataSourceSettings.columns.push(dataSourceItem));
                                    break;
                                case 'values':
                                    droppedPosition !== -1 ?
                                        (isBlazor() ? dataSourceUpdate.parent.dataSourceSettings.values.splice(droppedPosition, 0, dataSourceItem) : this.parent.dataSourceSettings.values.splice(droppedPosition, 0, dataSourceItem)) :
                                        (isBlazor() ? dataSourceUpdate.parent.dataSourceSettings.values.push(dataSourceItem) : this.parent.dataSourceSettings.values.push(dataSourceItem));
                                    if (isBlazor()) {
                                        if (dataSourceUpdate.parent.dataType === 'olap' && !dataSourceUpdate.parent.engineModule.isMeasureAvail) {
                                            let measureField = {
                                                name: '[Measures]', caption: 'Measures', baseField: undefined, baseItem: undefined
                                            };
                                            let fieldAxis = dataSourceUpdate.parent.dataSourceSettings.valueAxis === 'row' ?
                                                dataSourceUpdate.parent.dataSourceSettings.rows : dataSourceUpdate.parent.dataSourceSettings.columns;
                                            fieldAxis.push(measureField);
                                        }
                                    }
                                    else {
                                        if (this.parent.dataType === 'olap' && !this.parent.engineModule.isMeasureAvail) {
                                            let measureField = {
                                                name: '[Measures]', caption: 'Measures', baseField: undefined, baseItem: undefined
                                            };
                                            let fieldAxis = this.parent.dataSourceSettings.valueAxis === 'row' ?
                                                this.parent.dataSourceSettings.rows : this.parent.dataSourceSettings.columns;
                                            fieldAxis.push(measureField);
                                        }
                                    }
                                    break;
                            }
                            if (isBlazor()) {
                                dataSourceUpdate.parent.control.pivotButtonModule.updateDataSource();
                                dataSourceUpdate.parent.control.axisFieldModule.render();
                            }
                        }
                    });
                }
            }
        });
    }
    /* tslint:enable */
    /**
     * Updates the dataSource by removing the given field from the dataSource.
     * @param  {string} fieldName - Defines dropped field name to remove dataSource.
     * @method removeFieldFromReport
     * @return {void}
     * @hidden
     */
    removeFieldFromReport(fieldName) {
        let dataSourceItem;
        let isDataSource = false;
        let rows = this.parent.dataSourceSettings.rows;
        let columns = this.parent.dataSourceSettings.columns;
        let values = this.parent.dataSourceSettings.values;
        let filters = this.parent.dataSourceSettings.filters;
        let fields = [rows, columns, values, filters];
        let field = this.parent.engineModule.fieldList[fieldName];
        for (let len = 0, lnt = fields.length; len < lnt; len++) {
            if (!isDataSource && fields[len]) {
                for (let i = 0, n = fields[len].length; i < n; i++) {
                    if (fields[len][i].name === fieldName || (this.parent.dataType === 'olap' &&
                        fields[len][i].name.toLowerCase() === '[measures]' && fields[len][i].name.toLowerCase() === fieldName)) {
                        dataSourceItem = fields[len][i].properties ?
                            fields[len][i].properties : fields[len][i];
                        dataSourceItem.type = (field && field.type === 'number') ? dataSourceItem.type :
                            'Count';
                        fields[len].splice(i, 1);
                        if (this.parent.dataType === 'olap') {
                            let engineModule = this.parent.engineModule;
                            if (engineModule && engineModule.fieldList[fieldName]) {
                                engineModule.fieldList[fieldName].currrentMembers = {};
                                engineModule.fieldList[fieldName].searchMembers = [];
                            }
                        }
                        isDataSource = true;
                        break;
                    }
                }
            }
        }
        return dataSourceItem;
    }
    /**
     * Creates new field object given field name from the field list data.
     * @param  {string} fieldName - Defines dropped field name to add dataSource.
     * @method getNewField
     * @return {void}
     * @hidden
     */
    getNewField(fieldName) {
        let newField;
        if (this.parent.dataType === 'olap') {
            let field = this.parent.engineModule.fieldList[fieldName];
            newField = {
                name: fieldName,
                caption: field.caption,
                isNamedSet: field.isNamedSets,
                isCalculatedField: field.isCalculatedField,
                type: (field.aggregateType === undefined ? field.type === 'number' ? 'Sum' :
                    'Count' : field.aggregateType),
            };
        }
        else {
            let field = this.parent.engineModule.fieldList[fieldName];
            newField = {
                name: fieldName,
                caption: field.caption,
                type: ((field.aggregateType === undefined || field.aggregateType === null) ?
                    field.type === 'number' ? 'Sum' :
                        'Count' : field.aggregateType),
                showNoDataItems: field.showNoDataItems,
                baseField: field.baseField,
                baseItem: field.baseItem,
            };
        }
        return newField;
    }
}

/**
 * `ErrorDialog` module to create error dialog.
 */
/** @hidden */
class ErrorDialog {
    /**
     * Constructor for the dialog action.
     * @hidden
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Creates the error dialog for the unexpected action done.
     * @method createErrorDialog
     * @return {void}
     * @hidden
     */
    createErrorDialog(title, description, target) {
        let errorDialog = createElement('div', {
            id: this.parent.parentID + '_ErrorDialog',
            className: ERROR_DIALOG_CLASS
        });
        this.parent.element.appendChild(errorDialog);
        let zIndex = target ? Number(target.style.zIndex) + 1 : (this.parent.moduleName === 'pivotfieldlist' &&
            this.parent.renderMode === 'Popup' && this.parent.control ?
            this.parent.control.dialogRenderer.fieldListDialog.zIndex + 1 : 1000001);
        this.errorPopUp = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: false,
            header: title,
            content: description,
            isModal: true,
            visible: true,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            width: 'auto',
            height: 'auto',
            zIndex: zIndex,
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    click: this.closeErrorDialog.bind(this),
                    buttonModel: { cssClass: OK_BUTTON_CLASS, content: this.parent.localeObj.getConstant('ok'), isPrimary: true }
                }
            ],
            closeOnEscape: true,
            target: document.body,
            close: this.removeErrorDialog.bind(this)
        });
        this.errorPopUp.isStringTemplate = true;
        this.errorPopUp.appendTo(errorDialog);
    }
    closeErrorDialog() {
        this.errorPopUp.close();
    }
    removeErrorDialog() {
        if (this.errorPopUp && !this.errorPopUp.isDestroyed) {
            this.errorPopUp.destroy();
        }
        if (document.getElementById(this.parent.parentID + '_ErrorDialog')) {
            remove(document.getElementById(this.parent.parentID + '_ErrorDialog'));
        }
    }
}

/**
 * `FilterDialog` module to create filter dialog.
 */
/** @hidden */
class FilterDialog {
    /**
     * Constructor for the dialog action.
     * @hidden
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Creates the member filter dialog for the selected field.
     * @method createFilterDialog
     * @return {void}
     * @hidden
     */
    createFilterDialog(treeData, fieldName, fieldCaption, target) {
        let editorDialog = createElement('div', {
            id: this.parent.parentID + '_EditorTreeView',
            className: MEMBER_EDITOR_DIALOG_CLASS + ' ' + (this.parent.dataType === 'olap' ? 'e-olap-editor-dialog' : ''),
            attrs: { 'data-fieldName': fieldName, 'aria-label': fieldCaption },
            styles: 'visibility:hidden;'
        });
        let filterCaption = this.parent.engineModule.fieldList[fieldName].caption;
        let headerTemplate = this.parent.localeObj.getConstant('filter') + ' ' +
            '"' + fieldCaption + '"' + ' ' + this.parent.localeObj.getConstant('by');
        this.filterObject = this.getFilterObject(fieldName);
        this.isSearchEnabled = false;
        this.allowExcelLikeFilter = this.isExcelFilter(fieldName);
        this.parent.element.appendChild(editorDialog);
        this.dialogPopUp = new Dialog({
            animationSettings: { effect: (this.allowExcelLikeFilter ? 'None' : 'Fade') },
            allowDragging: false,
            header: (this.allowExcelLikeFilter ? headerTemplate : filterCaption),
            content: (this.allowExcelLikeFilter ? '' : this.createTreeView(treeData, fieldCaption, fieldName)),
            isModal: this.parent.renderMode === 'Popup' ? true : this.parent.isAdaptive ? true : false,
            visible: true,
            showCloseIcon: this.allowExcelLikeFilter ? true : false,
            enableRtl: this.parent.enableRtl,
            width: 'auto',
            height: this.parent.isDataOverflow ? (this.allowExcelLikeFilter ? '440px' : '400px') :
                (this.allowExcelLikeFilter ? '400px' : '350px'),
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    buttonModel: {
                        cssClass: OK_BUTTON_CLASS, content: this.parent.localeObj.getConstant('ok'), isPrimary: true
                    }
                },
                {
                    buttonModel: {
                        cssClass: 'e-clear-filter-button' + (this.allowExcelLikeFilter ? '' : ' ' + ICON_DISABLE),
                        iconCss: 'e-icons e-clear-filter-icon', enableRtl: this.parent.enableRtl,
                        content: this.parent.localeObj.getConstant('clearFilter'), disabled: (this.filterObject ? false : true)
                    }
                },
                {
                    click: this.closeFilterDialog.bind(this),
                    buttonModel: { cssClass: CANCEL_BUTTON_CLASS, content: this.parent.localeObj.getConstant('cancel') }
                }
            ],
            closeOnEscape: true,
            target: target,
            close: this.removeFilterDialog.bind(this)
        });
        this.dialogPopUp.isStringTemplate = true;
        this.dialogPopUp.appendTo(editorDialog);
        // this.dialogPopUp.element.querySelector('.e-dlg-header').innerHTML = (this.allowExcelLikeFilter ? headerTemplate : filterCaption);
        if (this.allowExcelLikeFilter) {
            this.createTabMenu(treeData, fieldCaption, fieldName);
            addClass([this.dialogPopUp.element], 'e-excel-filter');
            this.updateCheckedState(fieldCaption);
        }
        else {
            this.updateCheckedState(fieldCaption);
        }
        setStyleAttribute(this.dialogPopUp.element, { 'visibility': 'visible' });
        if (this.allowExcelLikeFilter) {
            this.dialogPopUp.element.querySelector('.e-dlg-closeicon-btn').focus();
        }
        else {
            return;
        }
    }
    /* tslint:disable */
    createTreeView(treeData, fieldCaption, fieldName) {
        let editorTreeWrapper = createElement('div', {
            id: this.parent.parentID + 'EditorDiv',
            className: EDITOR_TREE_WRAPPER_CLASS + (this.allowExcelLikeFilter ? ' e-excelfilter' : '')
        });
        let levelWrapper = createElement('button', {
            id: this.parent.parentID + '_LevelDiv',
            className: 'e-level-wrapper-class'
        });
        let searchWrapper = createElement('div', {
            id: this.parent.parentID + '_SearchDiv', attrs: { 'tabindex': '-1' },
            className: EDITOR_SEARCH_WRAPPER_CLASS
        });
        let filterCaption = this.parent.engineModule.fieldList[fieldName].caption;
        let editorSearch = createElement('input', { attrs: { 'type': 'text' } });
        let nodeLimitText = this.parent.isDataOverflow ?
            ((this.parent.currentTreeItems.length - this.parent.control.maxNodeLimitInMemberEditor) +
                this.parent.control.localeObj.getConstant('editorDataLimitMsg')) : '';
        let labelWrapper = createElement('div', {
            id: this.parent.parentID + '_LabelDiv',
            attrs: { 'tabindex': '-1', 'title': nodeLimitText },
            className: EDITOR_LABEL_WRAPPER_CLASS
        });
        this.parent.editorLabelElement = createElement('label', { className: EDITOR_LABEL_CLASS });
        this.parent.editorLabelElement.innerText = nodeLimitText;
        labelWrapper.style.display = this.parent.isDataOverflow ? 'block' : 'none';
        labelWrapper.appendChild(this.parent.editorLabelElement);
        searchWrapper.appendChild(editorSearch);
        searchWrapper.appendChild(levelWrapper);
        let selectAllWrapper = createElement('div', {
            id: this.parent.parentID + '_AllDiv', attrs: { 'tabindex': '-1' },
            className: SELECT_ALL_WRAPPER_CLASS
        });
        let selectAllContainer = createElement('div', { className: SELECT_ALL_CLASS });
        let treeOuterDiv = createElement('div', { className: EDITOR_TREE_CONTAINER_CLASS + '-outer-div' });
        let treeViewContainer = createElement('div', { className: EDITOR_TREE_CONTAINER_CLASS });
        let promptDiv = createElement('div', {
            className: EMPTY_MEMBER_CLASS + ' ' + ICON_DISABLE,
            innerHTML: this.parent.localeObj.getConstant('noMatches')
        });
        if (this.parent.dataType === 'olap' && this.parent.control.loadOnDemandInMemberEditor &&
            !this.parent.engineModule.fieldList[fieldName].isHierarchy &&
            !this.parent.engineModule.fieldList[fieldName].isNamedSets) {
            this.createLevelWrapper(levelWrapper, fieldName);
        }
        else {
            levelWrapper.style.display = 'none';
        }
        selectAllWrapper.appendChild(selectAllContainer);
        editorTreeWrapper.appendChild(searchWrapper);
        editorTreeWrapper.appendChild(selectAllWrapper);
        editorTreeWrapper.appendChild(promptDiv);
        this.editorSearch = new MaskedTextBox({
            placeholder: this.parent.localeObj.getConstant('search') + ' ' + '"' + filterCaption + '"',
            enableRtl: this.parent.enableRtl,
            cssClass: EDITOR_SEARCH_CLASS,
            showClearButton: true,
            change: (e) => {
                if (this.parent.dataType === 'olap') {
                    this.searchOlapTreeView(e, promptDiv, fieldCaption);
                }
                else {
                    this.parent.eventBase.searchTreeNodes(e, this.memberTreeView, false);
                    let filterDialog = this.dialogPopUp.element;
                    let liList = [].slice.call(this.memberTreeView.element.querySelectorAll('li'));
                    if (liList.length === 0) {
                        this.allMemberSelect.disableNodes([this.allMemberSelect.element.querySelector('li')]);
                        filterDialog.querySelector('.' + OK_BUTTON_CLASS).setAttribute('disabled', 'disabled');
                        removeClass([promptDiv], ICON_DISABLE);
                    }
                    else {
                        this.allMemberSelect.enableNodes([this.allMemberSelect.element.querySelector('li')]);
                        filterDialog.querySelector('.' + OK_BUTTON_CLASS).removeAttribute('disabled');
                        addClass([promptDiv], ICON_DISABLE);
                    }
                    this.updateCheckedState(fieldCaption);
                }
            }
        });
        this.editorSearch.isStringTemplate = true;
        this.editorSearch.appendTo(editorSearch);
        let nodeAttr = { 'data-fieldName': fieldName };
        let data = [{ id: 'all', name: 'All', isSelected: true, htmlAttributes: nodeAttr }];
        this.allMemberSelect = new TreeView({
            fields: { dataSource: data, id: 'id', text: 'name', isChecked: 'isSelected' },
            showCheckBox: true,
            expandOn: 'None',
            enableRtl: this.parent.enableRtl,
            nodeClicked: this.nodeCheck.bind(this, true),
            keyPress: this.nodeCheck.bind(this, true)
        });
        this.allMemberSelect.isStringTemplate = true;
        this.allMemberSelect.appendTo(selectAllContainer);
        treeOuterDiv.appendChild(treeViewContainer);
        editorTreeWrapper.appendChild(treeOuterDiv);
        this.memberTreeView = new TreeView({
            fields: { dataSource: treeData, id: 'id', text: 'name', isChecked: 'isSelected', parentID: 'pid' },
            showCheckBox: true,
            enableRtl: this.parent.enableRtl,
            nodeChecking: this.validateTreeNode.bind(this),
            nodeClicked: this.nodeCheck.bind(this, false),
            keyPress: this.nodeCheck.bind(this, false),
            nodeExpanding: this.updateChildNodes.bind(this),
            expandOn: 'None'
        });
        this.memberTreeView.isStringTemplate = true;
        this.memberTreeView.appendTo(treeViewContainer);
        editorTreeWrapper.appendChild(labelWrapper);
        return editorTreeWrapper;
    }
    createLevelWrapper(levelWrapper, fieldName) {
        let engineModule = this.parent.engineModule;
        let levels = engineModule.fieldList[fieldName].levels;
        let levelCount = engineModule.fieldList[fieldName].levelCount;
        let items = [];
        for (let i = 0, cnt = levels.length; i < cnt; i++) {
            items.push({ id: levels[i].id, text: levels[i].name });
        }
        this.dropMenu = new DropDownButton({
            cssClass: 'e-level-drop',
            items: items, iconCss: 'e-icons e-dropdown-icon',
            disabled: (levelCount === levels.length),
            beforeOpen: (args) => {
                let items = [].slice.call(args.element.querySelectorAll('li'));
                let engineModule = this.parent.engineModule;
                let levelCount = engineModule.fieldList[fieldName].levelCount;
                removeClass(items, MENU_DISABLE);
                for (let i = 0, cnt = items.length; i < cnt; i++) {
                    if (i < levelCount) {
                        addClass([items[i]], MENU_DISABLE);
                    }
                }
            },
            select: (args) => {
                let fieldName = this.dialogPopUp.element.getAttribute('data-fieldname');
                let engineModule = this.parent.engineModule;
                let selectedLevel;
                for (let i = 0, cnt = items.length; i < cnt; i++) {
                    if (items[i].id === args.item.id) {
                        selectedLevel = i;
                    }
                }
                engineModule.getFilterMembers(this.parent.dataSourceSettings, fieldName, selectedLevel + 1, false, true);
            },
            close: () => {
                let engineModule = this.parent.engineModule;
                let levels = engineModule.fieldList[fieldName].levels;
                let levelCount = engineModule.fieldList[fieldName].levelCount;
                if (levelCount === levels.length) {
                    this.dropMenu.disabled = true;
                    this.dropMenu.dataBind();
                }
                else {
                    this.dropMenu.disabled = false;
                }
            }
        });
        this.dropMenu.appendTo(levelWrapper);
    }
    searchOlapTreeView(e, promptDiv, fieldCaption) {
        let popupInstance = this;
        clearTimeout(this.timeOutObj);
        this.timeOutObj = setTimeout(function () {
            let engineModule = popupInstance.parent.engineModule;
            let filterDialog = popupInstance.dialogPopUp.element;
            let fieldName = filterDialog.getAttribute('data-fieldname');
            let nodeLimit = popupInstance.parent.control.maxNodeLimitInMemberEditor ?
                popupInstance.parent.control.maxNodeLimitInMemberEditor : 5000;
            if (!engineModule.fieldList[fieldName].isHierarchy) {
                if (popupInstance.dropMenu && e.value !== '') {
                    popupInstance.dropMenu.disabled = true;
                }
                else {
                    popupInstance.dropMenu.disabled = false;
                }
                if (!popupInstance.parent.control.loadOnDemandInMemberEditor) {
                    engineModule.getSearchMembers(popupInstance.parent.dataSourceSettings, fieldName, e.value.toLowerCase(), nodeLimit, true);
                }
                else {
                    let levelCount = engineModule.fieldList[fieldName].levelCount ? engineModule.fieldList[fieldName].levelCount : 1;
                    engineModule.getSearchMembers(popupInstance.parent.dataSourceSettings, fieldName, e.value.toLowerCase(), nodeLimit, false, levelCount);
                }
                popupInstance.parent.eventBase.searchTreeNodes(e, popupInstance.memberTreeView, false, false);
            }
            else {
                popupInstance.parent.eventBase.searchTreeNodes(e, popupInstance.memberTreeView, false, true);
            }
            let liList = [].slice.call(popupInstance.memberTreeView.element.querySelectorAll('li'));
            // for (let element of liList) {
            //     if (element.querySelector('.interaction')) {
            //         setStyleAttribute(element.querySelector('.interaction'), { display: 'none' });
            //     }
            // }
            if (liList.length === 0) {
                popupInstance.allMemberSelect.disableNodes([popupInstance.allMemberSelect.element.querySelector('li')]);
                filterDialog.querySelector('.' + OK_BUTTON_CLASS).setAttribute('disabled', 'disabled');
                removeClass([promptDiv], ICON_DISABLE);
            }
            else {
                popupInstance.allMemberSelect.enableNodes([popupInstance.allMemberSelect.element.querySelector('li')]);
                filterDialog.querySelector('.' + OK_BUTTON_CLASS).removeAttribute('disabled');
                addClass([promptDiv], ICON_DISABLE);
            }
            popupInstance.updateCheckedState(fieldCaption);
        }, 500);
    }
    /* tslint:enable */
    /* tslint:disable:no-any */
    nodeCheck(isAllMember, args) {
        let checkedNode = [args.node];
        if (args.event.target.classList.contains('e-fullrow') || args.event.key === 'Enter') {
            let memberObj = isAllMember ? this.allMemberSelect : this.memberTreeView;
            let getNodeDetails = memberObj.getNode(args.node);
            if (getNodeDetails.isChecked === 'true') {
                memberObj.uncheckAll(checkedNode);
            }
            else {
                memberObj.checkAll(checkedNode);
            }
        }
    }
    updateChildNodes(args) {
        if (this.parent.dataType === 'olap') {
            let engineModule = this.parent.engineModule;
            let fieldName = args.node.getAttribute('data-fieldname');
            let fieldList = engineModule.fieldList[fieldName];
            let filterItems = [];
            if (fieldList && fieldList.filterMembers.length > 0 && !this.isSearchEnabled &&
                !fieldList.members[args.nodeData.id].isNodeExpand) {
                let childNodes = [];
                for (let item of fieldList.filterMembers) {
                    if (item.pid === args.nodeData.id.toString()) {
                        childNodes.push(item);
                    }
                }
                if (childNodes.length === 0) {
                    fieldList.childMembers = [];
                    engineModule.getChildMembers(this.parent.dataSourceSettings, args.nodeData.id.toString(), fieldName);
                    childNodes = fieldList.childMembers;
                    fieldList.childMembers = [];
                }
                let treeData = PivotUtil.getClonedData(childNodes);
                let curTreeData = this.memberTreeView.fields.dataSource;
                let isInclude = false;
                if (!isNullOrUndefined(this.filterObject)) {
                    isInclude = this.filterObject.type === 'Include' ? true : false;
                    filterItems = this.filterObject.items ? this.filterObject.items : [];
                }
                treeData = this.updateChildData(isInclude, treeData, filterItems, fieldName, args.nodeData);
                treeData = this.parent.eventBase.sortOlapFilterData(treeData, engineModule.fieldList[fieldName].sort);
                for (let node of treeData) {
                    curTreeData.push(node);
                }
                fieldList.members[args.nodeData.id].isNodeExpand = true;
                this.memberTreeView.addNodes(treeData, args.node);
            }
        }
    }
    /* tslint:disable-next-line:max-line-length */
    updateChildData(isInclude, members, filterItems, fieldName, parentNode) {
        let memberCount = Object.keys(this.parent.currentTreeItemsPos).length;
        let fieldList = this.parent.engineModule.fieldList[fieldName];
        let list = [];
        let childMemberCount = 1;
        for (let member of members) {
            let obj = member;
            let memberName = member.id.toString();
            fieldList.members[memberName].isNodeExpand = false;
            member.isSelected = (parentNode.isChecked === 'true');
            if (childMemberCount <= this.parent.control.maxNodeLimitInMemberEditor) {
                list.push(obj);
            }
            this.parent.currentTreeItems.push(obj);
            this.parent.searchTreeItems.push(obj);
            this.parent.currentTreeItemsPos[memberName] = memberCount;
            memberCount++;
            childMemberCount++;
        }
        this.parent.isDataOverflow = false;
        return list;
    }
    createTabMenu(treeData, fieldCaption, fieldName) {
        let wrapper = createElement('div', {
            className: 'e-filter-tab-wrapper'
        });
        this.dialogPopUp.content = wrapper;
        this.dialogPopUp.dataBind();
        let types = ['Label', 'Value', 'Include', 'Exclude'];
        let regx = '((-|\\+)?[0-9]+(\\.[0-9]+)?)+';
        let member = Object.keys(this.parent.engineModule.fieldList[fieldName].members)[0];
        let fieldType = this.parent.engineModule.fieldList[fieldName].type;
        let formatObj = PivotUtil.getFieldByName(fieldName, this.parent.dataSourceSettings.formatSettings);
        let items = [
            {
                header: {
                    text: this.parent.localeObj.getConstant('member'),
                    iconCss: (this.filterObject && types.indexOf(this.filterObject.type) > 1 ? SELECTED_OPTION_ICON_CLASS : '')
                },
                content: this.createTreeView(treeData, fieldCaption, fieldName)
            }
        ];
        for (let type of types) {
            if (((type === 'Label') && this.parent.dataSourceSettings.allowLabelFilter) ||
                (type === 'Value' && this.parent.dataSourceSettings.allowValueFilter)) {
                let filterType = (type === 'Label' && member && ((member).match(regx) &&
                    (member).match(regx)[0].length === (member).length) && fieldType === 'number') ? 'Number' :
                    (type === 'Label' && member && (new Date(member).toString() !== 'Invalid Date') &&
                        ((formatObj && formatObj.type) || (this.filterObject && this.filterObject.type === 'Date'))) ? 'Date' : type;
                let item = {
                    header: {
                        text: (filterType === 'Number' ? this.parent.localeObj.getConstant('label') :
                            this.parent.localeObj.getConstant(filterType.toLowerCase())),
                        iconCss: (this.filterObject && this.filterObject.type === filterType ? SELECTED_OPTION_ICON_CLASS : '')
                    },
                    /* tslint:disable-next-line:max-line-length */
                    content: this.createCustomFilter(fieldName, (this.filterObject && this.filterObject.type === filterType ? this.filterObject : undefined), filterType.toLowerCase())
                };
                items.push(item);
            }
        }
        let selectedIndex = (this.filterObject ? (['Label', 'Date', 'Number'].indexOf(this.filterObject.type) >= 0) ?
            1 : this.filterObject.type === 'Value' ?
            (this.parent.dataSourceSettings.allowLabelFilter && this.parent.dataSourceSettings.allowValueFilter) ? 2 : 1 : 0 : 0);
        selectedIndex = (!this.parent.dataSourceSettings.allowMemberFilter && selectedIndex === 0) ? 1 : selectedIndex;
        this.tabObj = new Tab({
            heightAdjustMode: 'Auto',
            items: items,
            height: '100%',
            selectedItem: selectedIndex,
            enableRtl: this.parent.enableRtl
        });
        this.tabObj.isStringTemplate = true;
        this.tabObj.appendTo(wrapper);
        if (!this.parent.dataSourceSettings.allowMemberFilter) {
            this.tabObj.hideTab(0);
        }
        if (selectedIndex > 0) {
            /* tslint:disable-next-line:max-line-length */
            addClass([this.dialogPopUp.element.querySelector('.e-filter-div-content' + '.' + (selectedIndex === 1 && this.parent.dataSourceSettings.allowLabelFilter ? 'e-label-filter' : 'e-value-filter'))], 'e-selected-tab');
        }
    }
    /* tslint:disable */
    createCustomFilter(fieldName, filterObject, type) {
        let dataSource = [];
        let valueOptions = [];
        let levelOptions = [];
        let measures = this.parent.dataSourceSettings.values;
        let selectedOption = 'DoesNotEquals';
        let selectedValueIndex = 0;
        let selectedLevelIndex = 0;
        let options = {
            label: ['Equals', 'DoesNotEquals', 'BeginWith', 'DoesNotBeginWith', 'EndsWith',
                'DoesNotEndsWith', 'Contains', 'DoesNotContains', 'GreaterThan',
                'GreaterThanOrEqualTo', 'LessThan', 'LessThanOrEqualTo', 'Between', 'NotBetween'],
            date: ['Equals', 'DoesNotEquals', 'Before', 'BeforeOrEqualTo', 'After', 'AfterOrEqualTo',
                'Between', 'NotBetween'],
            value: ['Equals', 'DoesNotEquals', 'GreaterThan', 'GreaterThanOrEqualTo', 'LessThan',
                'LessThanOrEqualTo', 'Between', 'NotBetween']
        };
        let betweenOperators = ['Between', 'NotBetween'];
        let operatorCollection = (type === 'label' ? options.label : type === 'date' ? options.date : options.value);
        for (let operator of operatorCollection) {
            selectedOption = ((filterObject && operator === filterObject.condition) ?
                operatorCollection.indexOf(filterObject.condition) >= 0 ?
                    filterObject.condition : operatorCollection[0] : selectedOption);
            dataSource.push({ value: operator, text: this.parent.localeObj.getConstant(operator) });
        }
        let len = measures.length;
        while (len--) {
            valueOptions.unshift({ value: measures[len].name, text: (measures[len].caption ? measures[len].caption : measures[len].name) });
            selectedValueIndex = filterObject && filterObject.type === 'Value' &&
                filterObject.measure === measures[len].name &&
                filterObject.condition === selectedOption ? len : selectedValueIndex;
        }
        if (this.parent.dataType === 'olap') {
            let engineModule = this.parent.engineModule;
            let levels = engineModule.fieldList[fieldName].levels;
            if (this.parent.engineModule.fieldList[fieldName].isHierarchy) {
                let levelObj;
                let fieldlistData = this.parent.engineModule.fieldListData;
                for (let item of fieldlistData) {
                    if (item && item.pid === fieldName) {
                        levelObj = item;
                        break;
                    }
                }
                levelOptions.push({
                    value: levelObj ? levelObj.id : fieldName,
                    text: levelObj ? levelObj.caption : engineModule.fieldList[fieldName].name
                });
                selectedLevelIndex = 0;
                if (filterObject && filterObject.name === fieldName && filterObject.type.toLowerCase() === type) {
                    levelOptions[levelOptions.length - 1]['iconClass'] = ICON + ' ' + SELECTED_LEVEL_ICON_CLASS;
                }
            }
            else {
                for (let i = 0, cnt = levels.length; i < cnt; i++) {
                    selectedLevelIndex = (filterObject &&
                        filterObject.selectedField === levels[i].id ? i : selectedLevelIndex);
                    levelOptions.push({ value: levels[i].id, text: levels[i].name });
                    for (let field of this.parent.dataSourceSettings.filterSettings) {
                        if (field.name === fieldName && field.selectedField === levels[i].id && field.type.toLowerCase() === type) {
                            levelOptions[levelOptions.length - 1]['iconClass'] = ICON + ' ' + SELECTED_LEVEL_ICON_CLASS;
                            break;
                        }
                    }
                }
            }
        }
        let mainDiv = createElement('div', {
            className: FILTER_DIV_CONTENT_CLASS + ' e-' + ((['date', 'number']).indexOf(type) >= 0 ? 'label' : type) + '-filter',
            id: this.parent.parentID + '_' + type + '_filter_div_content',
            attrs: {
                'data-type': type, 'data-fieldName': fieldName, 'data-operator': selectedOption,
                'data-selectedField': (this.parent.dataType === 'olap' &&
                    levelOptions.length > 0 ? levelOptions[selectedLevelIndex].value.toString() : ''),
                'data-measure': (this.parent.dataSourceSettings.values.length > 0 ?
                    this.parent.dataSourceSettings.values[selectedValueIndex].name : ''),
                'data-value1': (filterObject && selectedOption === filterObject.condition ?
                    filterObject.value1 ? filterObject.value1.toString() : '' : ''),
                'data-value2': (filterObject && selectedOption === filterObject.condition ?
                    filterObject.value2 ? filterObject.value2.toString() : '' : '')
            }
        });
        let textContentdiv = createElement('div', {
            className: FILTER_TEXT_DIV_CLASS,
            innerHTML: this.parent.localeObj.getConstant(type + 'TextContent')
        });
        let betweenTextContentdiv = createElement('div', {
            className: BETWEEN_TEXT_DIV_CLASS + ' ' +
                (betweenOperators.indexOf(selectedOption) === -1 ? ICON_DISABLE : ''),
            innerHTML: this.parent.localeObj.getConstant('And')
        });
        let separatordiv = createElement('div', { className: SEPARATOR_DIV_CLASS });
        let filterWrapperDiv1 = createElement('div', { className: FILTER_OPTION_WRAPPER_1_CLASS });
        let levelWrapperDiv = createElement('div', {
            className: 'e-level-option-wrapper' + ' ' +
                (this.parent.dataType === 'olap' ? '' : ICON_DISABLE),
        });
        let optionWrapperDiv1 = createElement('div', {
            className: 'e-measure-option-wrapper' + ' ' + (((['label', 'date', 'number']).indexOf(type) >= 0) ? ICON_DISABLE : ''),
        });
        let optionWrapperDiv2 = createElement('div', { className: 'e-condition-option-wrapper' });
        let filterWrapperDiv2 = createElement('div', { className: FILTER_OPTION_WRAPPER_2_CLASS });
        let levelDropOption = createElement('div', { id: this.parent.parentID + '_' + type + '_level_option_wrapper' });
        let dropOptionDiv1 = createElement('div', { id: this.parent.parentID + '_' + type + '_measure_option_wrapper' });
        let dropOptionDiv2 = createElement('div', { id: this.parent.parentID + '_' + type + '_contition_option_wrapper' });
        let inputDiv1 = createElement('div', { className: FILTER_INPUT_DIV_1_CLASS });
        let inputDiv2 = createElement('div', {
            className: FILTER_INPUT_DIV_2_CLASS + ' ' +
                (betweenOperators.indexOf(selectedOption) === -1 ? ICON_DISABLE : '')
        });
        let inputField1 = createElement('input', {
            id: this.parent.parentID + '_' + type + '_input_option_1', attrs: { 'type': 'text' }
        });
        let inputField2 = createElement('input', {
            id: this.parent.parentID + '_' + type + '_input_option_2', attrs: { 'type': 'text' }
        });
        inputDiv1.appendChild(inputField1);
        inputDiv2.appendChild(inputField2);
        levelWrapperDiv.appendChild(levelDropOption);
        levelWrapperDiv.appendChild(separatordiv.cloneNode(true));
        optionWrapperDiv1.appendChild(dropOptionDiv1);
        optionWrapperDiv1.appendChild(separatordiv);
        optionWrapperDiv2.appendChild(dropOptionDiv2);
        filterWrapperDiv1.appendChild(levelWrapperDiv);
        filterWrapperDiv1.appendChild(optionWrapperDiv1);
        filterWrapperDiv1.appendChild(optionWrapperDiv2);
        filterWrapperDiv2.appendChild(inputDiv1);
        filterWrapperDiv2.appendChild(betweenTextContentdiv);
        filterWrapperDiv2.appendChild(inputDiv2);
        /* tslint:disable-next-line:max-line-length */
        this.createElements(filterObject, betweenOperators, dropOptionDiv1, dropOptionDiv2, inputField1, inputField2, valueOptions, dataSource, selectedValueIndex, selectedOption, type, levelDropOption, levelOptions, selectedLevelIndex);
        mainDiv.appendChild(textContentdiv);
        mainDiv.appendChild(filterWrapperDiv1);
        mainDiv.appendChild(filterWrapperDiv2);
        return mainDiv;
    }
    createElements(filterObj, operators, optionDiv1, optionDiv2, inputDiv1, inputDiv2, vDataSource, oDataSource, valueIndex, option, type, levelDropOption, lDataSource, levelIndex) {
        let popupInstance = this;
        if (this.parent.dataType === 'olap') {
            let levelWrapper = new DropDownList({
                dataSource: lDataSource, enableRtl: this.parent.enableRtl,
                fields: { value: 'value', text: 'text', iconCss: 'iconClass' },
                index: levelIndex,
                cssClass: LEVEL_OPTIONS_CLASS, width: '100%',
                change(args) {
                    let element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                    let fieldName = element.getAttribute('data-fieldName');
                    let type = element.getAttribute('data-type');
                    if (!isNullOrUndefined(element)) {
                        popupInstance.updateInputValues(element, type, inputDiv1, inputDiv2);
                        setStyleAndAttributes(element, { 'data-selectedField': args.value });
                        let filterObj;
                        for (let field of popupInstance.parent.dataSourceSettings.filterSettings) {
                            if (field.name === fieldName && field.selectedField === args.value) {
                                filterObj = field;
                                break;
                            }
                        }
                        if (filterObj) {
                            if (type === 'value' && filterObj.measure && filterObj.measure !== '') {
                                optionWrapper1.value = filterObj.measure ? filterObj.measure : vDataSource[0].value;
                            }
                            else {
                            }
                            if (filterObj.condition) {
                                optionWrapper.value = filterObj.condition ? filterObj.condition : 'DoesNotEquals';
                            }
                            else {
                                optionWrapper.value = 'DoesNotEquals';
                            }
                            let inputObj1;
                            let inputObj2;
                            if (type === 'value') {
                                inputObj1 = inputDiv1.ej2_instances[0];
                                inputObj2 = inputDiv2.ej2_instances[0];
                                if (inputObj1) {
                                    inputObj1.value = filterObj.value1 ? parseInt(filterObj.value1, 10) : undefined;
                                }
                                if (inputObj2) {
                                    inputObj2.value = filterObj.value2 ? parseInt(filterObj.value2, 10) : undefined;
                                }
                            }
                            else {
                                inputObj1 = inputDiv1.ej2_instances[0];
                                inputObj2 = inputDiv2.ej2_instances[0];
                                if (inputObj1) {
                                    inputObj1.value = filterObj.value1 ? filterObj.value1 : '';
                                }
                                if (inputObj2) {
                                    inputObj2.value = filterObj.value2 ? filterObj.value2 : '';
                                }
                            }
                        }
                        popupInstance.updateInputValues(element, type, inputDiv1, inputDiv2);
                    }
                    else {
                        return;
                    }
                }
            });
            levelWrapper.isStringTemplate = true;
            levelWrapper.appendTo(levelDropOption);
        }
        let optionWrapper1 = new DropDownList({
            dataSource: vDataSource, enableRtl: this.parent.enableRtl,
            fields: { value: 'value', text: 'text' }, index: valueIndex,
            cssClass: VALUE_OPTIONS_CLASS, width: '100%',
            change(args) {
                let element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                if (!isNullOrUndefined(element)) {
                    popupInstance.updateInputValues(element, type, inputDiv1, inputDiv2);
                    setStyleAndAttributes(element, { 'data-measure': args.value });
                }
                else {
                    return;
                }
            }
        });
        optionWrapper1.isStringTemplate = true;
        optionWrapper1.appendTo(optionDiv1);
        let optionWrapper = new DropDownList({
            dataSource: oDataSource, enableRtl: this.parent.enableRtl,
            fields: { value: 'value', text: 'text' }, value: option,
            cssClass: FILTER_OPERATOR_CLASS, width: '100%',
            change(args) {
                let element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                if (!isNullOrUndefined(element)) {
                    popupInstance.updateInputValues(element, type, inputDiv1, inputDiv2);
                    let disabledClasses = [BETWEEN_TEXT_DIV_CLASS, FILTER_INPUT_DIV_2_CLASS];
                    for (let className of disabledClasses) {
                        if (operators.indexOf(args.value) >= 0) {
                            removeClass([element.querySelector('.' + className)], ICON_DISABLE);
                        }
                        else {
                            addClass([element.querySelector('.' + className)], ICON_DISABLE);
                        }
                    }
                    setStyleAndAttributes(element, { 'data-operator': args.value });
                }
                else {
                    return;
                }
            }
        });
        optionWrapper.isStringTemplate = true;
        optionWrapper.appendTo(optionDiv2);
        if (type === 'date') {
            let inputObj1 = new DateTimePicker({
                placeholder: this.parent.localeObj.getConstant('chooseDate'),
                enableRtl: this.parent.enableRtl,
                format: 'dd/MM/yyyy hh:mm:ss a',
                showClearButton: true,
                value: (filterObj && option === filterObj.condition ?
                    (typeof (filterObj.value1) === 'string' ? new Date(filterObj.value1) : filterObj.value1) : null),
                change: (e) => {
                    let element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                    if (!isNullOrUndefined(element)) {
                        setStyleAndAttributes(element, { 'data-value1': e.value, 'data-value2': inputObj2.value });
                    }
                    else {
                        return;
                    }
                },
                width: '100%',
            });
            let inputObj2 = new DateTimePicker({
                placeholder: this.parent.localeObj.getConstant('chooseDate'),
                enableRtl: this.parent.enableRtl,
                format: 'dd/MM/yyyy hh:mm:ss a',
                showClearButton: true,
                value: (filterObj && option === filterObj.condition ?
                    (typeof (filterObj.value2) === 'string' ? new Date(filterObj.value2) : filterObj.value2) : null),
                change: (e) => {
                    let element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                    if (!isNullOrUndefined(element)) {
                        setStyleAndAttributes(element, { 'data-value1': inputObj1.value, 'data-value2': e.value });
                    }
                    else {
                        return;
                    }
                },
                width: '100%',
            });
            inputObj1.isStringTemplate = true;
            inputObj1.appendTo(inputDiv1);
            inputObj2.isStringTemplate = true;
            inputObj2.appendTo(inputDiv2);
        }
        else if (type === 'value') {
            let inputObj1 = new NumericTextBox({
                placeholder: this.parent.localeObj.getConstant('enterValue'),
                enableRtl: this.parent.enableRtl,
                showClearButton: true,
                format: '###.##',
                value: (filterObj && option === filterObj.condition ? parseInt(filterObj.value1, 10) : undefined),
                change: (e) => {
                    let element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                    if (!isNullOrUndefined(element)) {
                        setStyleAndAttributes(element, {
                            'data-value1': (e.value ? e.value.toString() : '0'),
                            'data-value2': (inputObj2.value ? inputObj2.value.toString() : '0')
                        });
                    }
                    else {
                        return;
                    }
                }, width: '100%'
            });
            let inputObj2 = new NumericTextBox({
                placeholder: this.parent.localeObj.getConstant('enterValue'),
                enableRtl: this.parent.enableRtl,
                showClearButton: true,
                format: '###.##',
                value: (filterObj && option === filterObj.condition ? parseInt(filterObj.value2, 10) : undefined),
                change: (e) => {
                    let element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                    if (!isNullOrUndefined(element)) {
                        setStyleAndAttributes(element, {
                            'data-value1': (inputObj1.value ? inputObj1.value.toString() : '0'),
                            'data-value2': (e.value ? e.value.toString() : '0')
                        });
                    }
                    else {
                        return;
                    }
                }, width: '100%'
            });
            inputObj1.isStringTemplate = true;
            inputObj1.appendTo(inputDiv1);
            inputObj2.isStringTemplate = true;
            inputObj2.appendTo(inputDiv2);
        }
        else {
            let inputObj1 = new MaskedTextBox({
                placeholder: this.parent.localeObj.getConstant('enterValue'),
                enableRtl: this.parent.enableRtl,
                showClearButton: true,
                value: (filterObj && option === filterObj.condition ? filterObj.value1 : ''),
                change: (e) => {
                    let element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                    if (!isNullOrUndefined(element)) {
                        setStyleAndAttributes(element, { 'data-value1': e.value, 'data-value2': inputObj2.value });
                    }
                    else {
                        return;
                    }
                }, width: '100%'
            });
            let inputObj2 = new MaskedTextBox({
                placeholder: this.parent.localeObj.getConstant('enterValue'),
                enableRtl: this.parent.enableRtl,
                showClearButton: true,
                value: (filterObj && option === filterObj.condition ? filterObj.value2 : ''),
                change: (e) => {
                    let element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                    if (!isNullOrUndefined(element)) {
                        setStyleAndAttributes(element, { 'data-value1': inputObj1.value, 'data-value2': e.value });
                    }
                    else {
                        return;
                    }
                }, width: '100%'
            });
            inputObj1.isStringTemplate = true;
            inputObj1.appendTo(inputDiv1);
            inputObj2.isStringTemplate = true;
            inputObj2.appendTo(inputDiv2);
        }
    }
    /* tslint:enable */
    updateInputValues(element, type, inputDiv1, inputDiv2) {
        let value1;
        let value2;
        if (type === 'date') {
            let inputObj1 = inputDiv1.ej2_instances[0];
            let inputObj2 = inputDiv2.ej2_instances[0];
            value1 = !isNullOrUndefined(inputObj1.value) ? inputObj1.value.toString() : '';
            value2 = !isNullOrUndefined(inputObj2.value) ? inputObj2.value.toString() : '';
        }
        else {
            let inputObj1 = inputDiv1.ej2_instances[0];
            let inputObj2 = inputDiv2.ej2_instances[0];
            value1 = inputObj1.value;
            value2 = inputObj2.value;
        }
        setStyleAndAttributes(element, { 'data-value1': value1, 'data-value2': value2 });
    }
    validateTreeNode(e) {
        if (e.node.classList.contains(ICON_DISABLE)) {
            e.cancel = true;
        }
        else {
            return;
        }
    }
    /**
     * Update filter state while Member check/uncheck.
     * @hidden
     */
    updateCheckedState(fieldCaption) {
        let filterDialog = this.dialogPopUp.element;
        setStyleAndAttributes(filterDialog, { 'role': 'menu', 'aria-haspopup': 'true' });
        let list = [].slice.call(this.memberTreeView.element.querySelectorAll('li'));
        let fieldName = filterDialog.getAttribute('data-fieldname');
        let uncheckedNodes = this.getUnCheckedNodes(fieldName);
        let checkedNodes = this.getCheckedNodes(fieldName);
        let firstNode = this.allMemberSelect.element.querySelector('li').querySelector('span.' + CHECK_BOX_FRAME_CLASS);
        if (list.length > 0) {
            if (checkedNodes > 0) {
                if (uncheckedNodes > 0) {
                    removeClass([firstNode], NODE_CHECK_CLASS);
                    addClass([firstNode], NODE_STOP_CLASS);
                }
                else if (uncheckedNodes === 0) {
                    removeClass([firstNode], NODE_STOP_CLASS);
                    addClass([firstNode], NODE_CHECK_CLASS);
                }
                this.dialogPopUp.buttons[0].buttonModel.disabled = false;
                filterDialog.querySelector('.' + OK_BUTTON_CLASS).removeAttribute('disabled');
            }
            else if (uncheckedNodes > 0 && checkedNodes === 0) {
                removeClass([firstNode], [NODE_CHECK_CLASS, NODE_STOP_CLASS]);
                if (this.getCheckedNodes(fieldName) === checkedNodes) {
                    this.dialogPopUp.buttons[0].buttonModel.disabled = true;
                    filterDialog.querySelector('.' + OK_BUTTON_CLASS).setAttribute('disabled', 'disabled');
                }
            }
        }
        else {
            this.dialogPopUp.buttons[0].buttonModel.disabled = true;
            filterDialog.querySelector('.' + OK_BUTTON_CLASS).setAttribute('disabled', 'disabled');
        }
    }
    getCheckedNodes(fieldName) {
        let engineModule = this.parent.engineModule;
        let nodeList = [];
        let checkeNodes = [];
        if (this.parent.dataType === 'olap' && engineModule &&
            !engineModule.fieldList[fieldName].isHierarchy) {
            nodeList = this.memberTreeView.getAllCheckedNodes();
            return nodeList.length;
        }
        else {
            for (let item of this.parent.searchTreeItems) {
                if (item.isSelected) {
                    checkeNodes.push(item);
                }
            }
            return checkeNodes.length;
        }
    }
    getUnCheckedNodes(fieldName) {
        let unCheckeNodes = [];
        let nodeList = [];
        let engineModule = this.parent.engineModule;
        if (this.parent.dataType === 'olap' && engineModule && !engineModule.fieldList[fieldName].isHierarchy) {
            nodeList = this.memberTreeView.getAllCheckedNodes();
            return (this.memberTreeView.fields.dataSource.length -
                nodeList.length);
        }
        else {
            // unCheckeNodes = this.parent.searchTreeItems.filter((item: { [key: string]: object }) => {
            //     return !item.isSelected;
            // });
            for (let item of this.parent.searchTreeItems) {
                if (!item.isSelected) {
                    unCheckeNodes.push(item);
                }
            }
            return unCheckeNodes.length;
        }
    }
    isExcelFilter(fieldName) {
        let isFilterField = false;
        for (let field of this.parent.dataSourceSettings.filters) {
            if (field.name === fieldName) {
                isFilterField = true;
                break;
            }
        }
        if (!isFilterField && (this.parent.dataSourceSettings.allowLabelFilter || this.parent.dataSourceSettings.allowValueFilter)) {
            return true;
        }
        else {
            return false;
        }
    }
    getFilterObject(fieldName) {
        let filterObj = PivotUtil.getFilterItemByName(fieldName, this.parent.dataSourceSettings.filterSettings);
        if (filterObj && (((['Label', 'Date', 'Number'].indexOf(filterObj.type) >= 0) &&
            this.parent.dataSourceSettings.allowLabelFilter) ||
            (filterObj.type === 'Value' && this.parent.dataSourceSettings.allowValueFilter) ||
            (['Include', 'Exclude'].indexOf(filterObj.type) >= 0 &&
                this.parent.eventBase.isValidFilterItemsAvail(fieldName, filterObj)))) {
            return filterObj;
        }
        return undefined;
    }
    /**
     * To close filter dialog.
     * @hidden
     */
    closeFilterDialog() {
        if (this.allowExcelLikeFilter) {
            if (this.tabObj && !this.tabObj.isDestroyed) {
                this.tabObj.destroy();
            }
        }
        if (this.dropMenu && !this.dropMenu.isDestroyed) {
            this.dropMenu.destroy();
        }
        if (document.getElementById(this.parent.parentID + '_LevelDiv-popup')) {
            remove(document.getElementById(this.parent.parentID + '_LevelDiv-popup'));
        }
        this.dialogPopUp.close();
    }
    removeFilterDialog() {
        if (this.dialogPopUp && !this.dialogPopUp.isDestroyed) {
            this.dialogPopUp.destroy();
        }
        if (document.getElementById(this.parent.parentID + '_EditorTreeView')) {
            remove(document.getElementById(this.parent.parentID + '_EditorTreeView'));
        }
    }
}

/**
 * PivotCommon is used to manipulate the relational or Multi-Dimensional public methods by using their dataSource
 * @hidden
 */
/** @hidden */
class PivotCommon {
    /**
     * Constructor for Pivot Common class
     * @param  {CommonArgs} control?
     * @hidden
     */
    constructor(control) {
        /** @hidden */
        this.currentTreeItems = [];
        /** @hidden */
        this.savedTreeFilterPos = {};
        /** @hidden */
        this.currentTreeItemsPos = {};
        /** @hidden */
        this.searchTreeItems = [];
        /** @hidden */
        this.isDataOverflow = false;
        /** @hidden */
        this.isDateField = false;
        this.element = control.element;
        this.moduleName = control.moduleName;
        this.dataSourceSettings = control.dataSourceSettings;
        this.engineModule = control.pivotEngine;
        this.enableRtl = control.enableRtl;
        this.isAdaptive = control.isAdaptive;
        this.renderMode = control.renderMode;
        this.parentID = control.id;
        this.localeObj = control.localeObj;
        this.dataType = control.dataType;
        this.nodeStateModified = new NodeStateModified(this);
        this.dataSourceUpdate = new DataSourceUpdate(this);
        this.eventBase = new EventBase(this);
        this.filterDialog = new FilterDialog(this);
        this.errorDialog = new ErrorDialog(this);
        this.keyboardModule = new CommonKeyboardInteraction(this);
        return this;
    }
    /**
     * To destroy the groupingbar
     * @return {void}
     * @hidden
     */
    destroy() {
        if (this.keyboardModule) {
            this.keyboardModule.destroy();
        }
    }
}

/**
 * Module to render Pivot Field List Dialog
 */
/** @hidden */
class DialogRenderer {
    /** Constructor for render module */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Initialize the field list layout rendering
     * @returns void
     * @private
     */
    render() {
        let fieldListWrappper = createElement('div', {
            id: this.parent.element.id + '_Wrapper',
            className: WRAPPER_CLASS + ' ' + (this.parent.dataType === 'olap' ? OLAP_WRAPPER_CLASS : ''),
            styles: 'width:' + this.parent.element.style.width
        });
        if (this.parent.isAdaptive) {
            addClass([fieldListWrappper], DEVICE);
        }
        else {
            removeClass([fieldListWrappper], DEVICE);
        }
        if (this.parent.enableRtl) {
            addClass([fieldListWrappper], RTL);
        }
        else {
            removeClass([fieldListWrappper], RTL);
        }
        if (this.parent.cssClass) {
            addClass([fieldListWrappper], this.parent.cssClass);
        }
        this.parentElement = createElement('div', { className: CONTAINER_CLASS });
        this.parent.element.appendChild(fieldListWrappper);
        if (this.parent.isAdaptive) {
            fieldListWrappper.removeAttribute('style');
            this.parentElement = createElement('div', { className: ADAPTIVE_CONTAINER_CLASS });
            this.renderAdaptiveLayout(fieldListWrappper);
        }
        if (this.parent.renderMode === 'Popup') {
            this.renderFieldListDialog(fieldListWrappper);
            this.unWireDialogEvent(this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS));
            this.wireDialogEvent(this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS));
        }
        else {
            this.renderStaticLayout(fieldListWrappper);
        }
    }
    renderStaticLayout(fieldListWrappper) {
        if (!this.parent.isAdaptive) {
            let layoutHeader = createElement('div', {
                className: FIELD_LIST_TITLE_CLASS
            });
            let headerContent = createElement('div', {
                className: FIELD_LIST_TITLE_CONTENT_CLASS,
                innerHTML: this.parent.localeObj.getConstant('staticFieldList')
            });
            layoutHeader.appendChild(headerContent);
            layoutHeader.appendChild(this.createCalculatedButton());
            addClass([fieldListWrappper], STATIC_FIELD_LIST_CLASS);
            fieldListWrappper.appendChild(layoutHeader);
            fieldListWrappper.appendChild(this.parentElement);
            addClass([fieldListWrappper], STATIC_FIELD_LIST_CLASS);
            if (this.parent.allowDeferLayoutUpdate) {
                fieldListWrappper.appendChild(this.createDeferUpdateButtons());
                this.renderDeferUpdateButtons();
            }
        }
    }
    renderDeferUpdateButtons() {
        if (this.parent.allowDeferLayoutUpdate) {
            this.deferUpdateCheckBox = new CheckBox({
                label: this.parent.localeObj.getConstant('deferLayoutUpdate'),
                checked: true,
                enableRtl: this.parent.enableRtl,
                change: this.onCheckChange.bind(this)
            });
            this.deferUpdateCheckBox.isStringTemplate = true;
            this.deferUpdateCheckBox.appendTo('#' + this.parent.element.id + 'DeferUpdateCheckBox');
            this.deferUpdateApplyButton = new Button({
                cssClass: DEFER_APPLY_BUTTON + ' ' + DEFER_UPDATE_BUTTON + (this.parent.renderMode === 'Popup' ?
                    (' ' + BUTTON_FLAT_CLASS) : ''),
                content: this.parent.localeObj.getConstant('apply'),
                enableRtl: this.parent.enableRtl,
                isPrimary: true
            });
            this.deferUpdateApplyButton.isStringTemplate = true;
            this.deferUpdateApplyButton.appendTo('#' + this.parent.element.id + '_DeferUpdateButton1');
            this.deferUpdateApplyButton.element.onclick = this.parent.renderMode === 'Fixed' ? this.applyButtonClick.bind(this) :
                this.onDeferUpdateClick.bind(this);
        }
        this.deferUpdateCancelButton = new Button({
            cssClass: DEFER_CANCEL_BUTTON + ' ' + CANCEL_BUTTON_CLASS + (this.parent.renderMode === 'Popup' ?
                (' ' + BUTTON_FLAT_CLASS) : ''),
            content: this.parent.allowDeferLayoutUpdate ? this.parent.localeObj.getConstant('cancel') :
                this.parent.localeObj.getConstant('close'),
            enableRtl: this.parent.enableRtl, isPrimary: !this.parent.allowDeferLayoutUpdate
        });
        this.deferUpdateCancelButton.isStringTemplate = true;
        this.deferUpdateCancelButton.appendTo('#' + this.parent.element.id + '_DeferUpdateButton2');
        this.deferUpdateCancelButton.element.onclick = this.parent.renderMode === 'Fixed' ? this.cancelButtonClick.bind(this) :
            this.onCloseFieldList.bind(this);
    }
    createDeferUpdateButtons() {
        let layoutFooter = createElement('div', {
            className: LAYOUT_FOOTER
        });
        if (this.parent.allowDeferLayoutUpdate) {
            let checkBoxLayout = createElement('div', {
                className: CHECKBOX_LAYOUT
            });
            let deferUpdateCheckBox = createElement('input', {
                id: this.parent.element.id + 'DeferUpdateCheckBox'
            });
            checkBoxLayout.appendChild(deferUpdateCheckBox);
            layoutFooter.appendChild(checkBoxLayout);
        }
        let buttonLayout = createElement('div', {
            className: BUTTON_LAYOUT
        });
        if (this.parent.allowDeferLayoutUpdate) {
            let deferUpdateButton1 = createElement('button', {
                id: this.parent.element.id + '_DeferUpdateButton1'
            });
            buttonLayout.appendChild(deferUpdateButton1);
        }
        let deferUpdateButton2 = createElement('button', {
            id: this.parent.element.id + '_DeferUpdateButton2'
        });
        buttonLayout.appendChild(deferUpdateButton2);
        layoutFooter.appendChild(buttonLayout);
        return layoutFooter;
    }
    onCheckChange(args) {
        if (args.checked) {
            this.parent.clonedDataSource = extend({}, this.parent.dataSourceSettings, null, true);
            this.parent.clonedFieldList = extend({}, this.parent.pivotFieldList, null, true);
        }
        this.parent.allowDeferLayoutUpdate = !this.parent.allowDeferLayoutUpdate;
        if (this.parent.renderMode === 'Fixed') {
            this.deferUpdateApplyButton.setProperties({ disabled: !this.parent.allowDeferLayoutUpdate });
            this.deferUpdateCancelButton.setProperties({ disabled: !this.parent.allowDeferLayoutUpdate });
        }
        else {
            if (this.parent.allowDeferLayoutUpdate) {
                this.deferUpdateApplyButton.element.style.display = '';
                this.deferUpdateCancelButton.setProperties({ content: this.parent.localeObj.getConstant('cancel') });
                this.deferUpdateCancelButton.isPrimary = false;
            }
            else {
                this.deferUpdateApplyButton.element.style.display = 'none';
                this.deferUpdateCancelButton.setProperties({ content: this.parent.localeObj.getConstant('close') });
                this.deferUpdateCancelButton.isPrimary = true;
            }
        }
        this.cancelButtonClick();
    }
    applyButtonClick() {
        this.parent.updateDataSource(false);
        let parent = this.parent;
        //setTimeout(() => {
        parent.axisFieldModule.render();
        parent.clonedDataSource = extend({}, parent.dataSourceSettings, null, true);
        parent.clonedFieldList = extend({}, parent.pivotFieldList, null, true);
        //});
    }
    cancelButtonClick() {
        /* tslint:disable:align */
        this.parent.
            setProperties({
            dataSourceSettings: this.parent.clonedDataSource.properties
        }, true);
        if (this.parent.dataType === 'olap') {
            this.parent.olapEngineModule.fieldList = extend({}, this.parent.clonedFieldList, null, true);
            for (let name of Object.keys(this.parent.clonedFieldList)) {
                let item = this.parent.clonedFieldList[name];
                this.parent.olapEngineModule.updateFieldlistData(item.id, item.isSelected);
            }
        }
        else {
            this.parent.engineModule.fieldList = extend({}, this.parent.clonedFieldList, null, true);
        }
        this.parent.updateDataSource(false, true);
    }
    renderFieldListDialog(fieldListWrappper) {
        let toggleFieldList = createElement('div', {
            className: TOGGLE_FIELD_LIST_CLASS + ' ' + ICON + ' ' + TOGGLE_SELECT_CLASS,
            attrs: {
                'tabindex': '0',
                title: this.parent.localeObj.getConstant('fieldList'),
                'aria-disabled': 'false',
                'aria-label': this.parent.localeObj.getConstant('fieldList')
            }
        });
        this.parent.element.appendChild(toggleFieldList);
        if (this.parent.isAdaptive) {
            let headerTemplate = '<div class=' + TITLE_MOBILE_HEADER + '><span class="' + ICON + ' ' +
                BACK_ICON + '"></span><div class=' + TITLE_MOBILE_CONTENT + '>' + this.parent.localeObj.getConstant('fieldList') +
                '</div></div>';
            let buttons = [{
                    click: this.showFieldListDialog.bind(this),
                    buttonModel: {
                        cssClass: ADAPTIVE_FIELD_LIST_BUTTON_CLASS + ' ' + BUTTON_SMALL_CLASS + ' ' + BUTTON_ROUND_CLASS,
                        iconCss: ICON + ' ' + ADD_ICON_CLASS,
                        isPrimary: true
                    }
                }, {
                    click: this.showCalculatedField.bind(this),
                    buttonModel: {
                        cssClass: ADAPTIVE_CALCULATED_FIELD_BUTTON_CLASS +
                            ' ' + BUTTON_SMALL_CLASS + ' ' + BUTTON_ROUND_CLASS + ' ' + ICON_DISABLE,
                        iconCss: ICON + ' ' + ADD_ICON_CLASS, enableRtl: this.parent.enableRtl,
                        isPrimary: true
                    }
                }];
            this.fieldListDialog = new Dialog({
                animationSettings: { effect: this.parent.enableRtl ? 'SlideRight' : 'SlideLeft' },
                header: headerTemplate,
                content: this.parentElement,
                isModal: true,
                showCloseIcon: false,
                visible: false,
                allowDragging: false,
                closeOnEscape: false,
                enableRtl: this.parent.enableRtl,
                width: '100%',
                height: '100%',
                position: { X: 'center', Y: 'center' },
                buttons: buttons,
                target: document.body,
                close: this.removeFieldListIcon.bind(this)
            });
            this.fieldListDialog.isStringTemplate = true;
            this.fieldListDialog.appendTo(fieldListWrappper);
            // this.fieldListDialog.element.querySelector('.e-dlg-header').innerHTML = headerTemplate;
            setStyleAttribute(fieldListWrappper.querySelector('#' + fieldListWrappper.id + '_dialog-content'), {
                'padding': '0'
            });
            let footer = fieldListWrappper.querySelector('.' + FOOTER_CONTENT_CLASS);
            addClass([footer], FIELD_LIST_FOOTER_CLASS);
            removeClass([footer.querySelector('.' + ADAPTIVE_CALCULATED_FIELD_BUTTON_CLASS)], BUTTON_FLAT_CLASS);
            removeClass([footer.querySelector('.' + ADAPTIVE_FIELD_LIST_BUTTON_CLASS)], BUTTON_FLAT_CLASS);
            this.fieldListDialog.element.querySelector('.' + BACK_ICON).onclick =
                this.parent.allowDeferLayoutUpdate ? this.onDeferUpdateClick.bind(this) : this.onCloseFieldList.bind(this);
        }
        else {
            let template = this.createDeferUpdateButtons().outerHTML;
            let headerTemplate = '<div class=' + TITLE_HEADER_CLASS + '><div class=' +
                TITLE_CONTENT_CLASS + '>' + this.parent.localeObj.getConstant('fieldList') + '</div></div>';
            this.fieldListDialog = new Dialog({
                animationSettings: { effect: 'Zoom' },
                header: headerTemplate,
                content: this.parentElement,
                isModal: false,
                showCloseIcon: false,
                visible: false,
                allowDragging: true,
                enableRtl: this.parent.enableRtl,
                width: this.parent.element.style.width,
                position: { X: 'center', Y: this.parent.element.offsetTop },
                footerTemplate: template,
                closeOnEscape: true,
                target: !isNullOrUndefined(this.parent.target) ? ((typeof this.parent.target) === 'string') ?
                    document.querySelector(this.parent.target) : this.parent.target : document.body,
                close: this.removeFieldListIcon.bind(this)
            });
            this.fieldListDialog.isStringTemplate = true;
            this.fieldListDialog.appendTo(fieldListWrappper);
            // this.fieldListDialog.element.querySelector('.e-dlg-header').innerHTML = headerTemplate;
            // this.fieldListDialog.element.querySelector('.e-footer-content').innerHTML = template;
            this.renderDeferUpdateButtons();
            setStyleAttribute(fieldListWrappper.querySelector('#' + fieldListWrappper.id + '_title'), { 'width': '100%' });
            fieldListWrappper.querySelector('.' + TITLE_HEADER_CLASS).appendChild(this.createCalculatedButton());
        }
    }
    /**
     * Called internally if any of the field added to axis.
     * @hidden
     */
    updateDataSource(selectedNodes) {
        let axis = ['filters', 'columns', 'rows', 'values'];
        for (let field of selectedNodes) {
            let fieldName = field;
            let droppedClass = axis[this.adaptiveElement.selectedItem];
            this.parent.pivotCommon.dataSourceUpdate.control = this.parent.getModuleName() === 'pivotview' ?
                this.parent : (this.parent.pivotGridModule ?
                this.parent.pivotGridModule : this.parent);
            this.parent.pivotCommon.dataSourceUpdate.updateDataSource(fieldName, droppedClass, -1);
        }
        this.parent.axisFieldModule.render();
        if (!this.parent.allowDeferLayoutUpdate) {
            this.parent.updateDataSource(true);
        }
        else {
            this.parent.triggerPopulateEvent();
        }
    }
    onDeferUpdateClick() {
        this.parent.updateDataSource();
        this.parent.dialogRenderer.fieldListDialog.hide();
    }
    renderAdaptiveLayout(fieldListWrappper) {
        let layoutFooter = createElement('div', {
            className: FIELD_LIST_FOOTER_CLASS
        });
        fieldListWrappper.appendChild(this.parentElement);
        let items = [
            {
                header: { 'text': this.parent.localeObj.getConstant('filters') },
                content: this.createAxisTable('filters')
            },
            {
                header: { 'text': this.parent.localeObj.getConstant('columns') },
                content: this.createAxisTable('columns')
            },
            {
                header: { 'text': this.parent.localeObj.getConstant('rows') },
                content: this.createAxisTable('rows')
            },
            {
                header: { 'text': this.parent.localeObj.getConstant('values') },
                content: this.createAxisTable('values')
            },
            {
                header: { 'text': this.parent.localeObj.getConstant('createCalculatedField') },
                content: 'Calculated Field Related UI'
            }
        ];
        if (!this.parent.allowCalculatedField) {
            items.pop();
        }
        this.adaptiveElement = new Tab({
            heightAdjustMode: 'Auto',
            items: items,
            height: '100%',
            enableRtl: this.parent.enableRtl,
            selected: this.tabSelect.bind(this)
        });
        if (this.parent.renderMode === 'Fixed') {
            layoutFooter.appendChild(this.createAddButton());
            addClass([fieldListWrappper], STATIC_FIELD_LIST_CLASS);
            this.adaptiveElement.isStringTemplate = true;
            this.adaptiveElement.appendTo(this.parentElement);
            this.parentElement.appendChild(layoutFooter);
        }
        else {
            this.adaptiveElement.isStringTemplate = true;
            this.adaptiveElement.appendTo(this.parentElement);
        }
    }
    tabSelect(e) {
        let fieldWrapper = closest(this.parentElement, '.' + WRAPPER_CLASS);
        if (fieldWrapper && fieldWrapper.querySelector('.' + ADAPTIVE_FIELD_LIST_BUTTON_CLASS)) {
            if (e.selectedIndex !== 4) {
                addClass([fieldWrapper.querySelector('.' + ADAPTIVE_CALCULATED_FIELD_BUTTON_CLASS)], ICON_DISABLE);
                removeClass([fieldWrapper.querySelector('.' + ADAPTIVE_FIELD_LIST_BUTTON_CLASS)], ICON_DISABLE);
            }
            else {
                removeClass([fieldWrapper.querySelector('.' + ADAPTIVE_CALCULATED_FIELD_BUTTON_CLASS)], ICON_DISABLE);
                addClass([fieldWrapper.querySelector('.' + ADAPTIVE_FIELD_LIST_BUTTON_CLASS)], ICON_DISABLE);
            }
        }
        if (e.selectedIndex === 4) {
            this.adaptiveElement.items[4].content = '';
            this.adaptiveElement.dataBind();
            this.parent.notify(initCalculatedField, {});
        }
        else {
            this.parent.axisFieldModule.render();
        }
    }
    createCalculatedButton() {
        let calculatedButton = createElement('div', {
            id: this.parent.element.id + '_CalculatedField',
            attrs: {
                'tabindex': '0',
                'aria-disabled': 'false',
                'aria-label': this.parent.localeObj.getConstant('CalculatedField')
            }
        });
        let calculateField = new Button({
            cssClass: CALCULATED_FIELD_CLASS + ' ' + ICON_DISABLE,
            content: this.parent.localeObj.getConstant('CalculatedField'),
            enableRtl: this.parent.enableRtl
        });
        calculateField.isStringTemplate = true;
        calculateField.appendTo(calculatedButton);
        if (this.parent.calculatedFieldModule) {
            removeClass([calculatedButton], ICON_DISABLE);
        }
        calculateField.element.onclick = this.showCalculatedField.bind(this);
        return calculatedButton;
    }
    createAddButton() {
        let footerContainer = createElement('div', {
            className: FIELD_LIST_FOOTER_CLASS + '-content'
        });
        let fieldListButton = createElement('div', {});
        let calculatedButton = createElement('div', {});
        let calculateField = new Button({
            cssClass: ADAPTIVE_CALCULATED_FIELD_BUTTON_CLASS +
                ' ' + BUTTON_SMALL_CLASS + ' ' + BUTTON_ROUND_CLASS + ' ' + ICON_DISABLE,
            iconCss: ICON + ' ' + ADD_ICON_CLASS,
            enableRtl: this.parent.enableRtl
        });
        let fieldList = new Button({
            cssClass: ADAPTIVE_FIELD_LIST_BUTTON_CLASS + ' ' + BUTTON_SMALL_CLASS + ' ' + BUTTON_ROUND_CLASS,
            iconCss: ICON + ' ' + ADD_ICON_CLASS,
            enableRtl: this.parent.enableRtl
        });
        fieldList.isStringTemplate = true;
        fieldList.appendTo(fieldListButton);
        calculateField.isStringTemplate = true;
        calculateField.appendTo(calculatedButton);
        footerContainer.appendChild(fieldListButton);
        footerContainer.appendChild(calculatedButton);
        calculateField.element.onclick = this.showCalculatedField.bind(this);
        fieldList.element.onclick = this.showFieldListDialog.bind(this);
        return footerContainer;
    }
    createAxisTable(axis) {
        let axisWrapper = createElement('div', {
            className: FIELD_LIST_CLASS + '-' + axis
        });
        let axisContent = createElement('div', { className: AXIS_CONTENT_CLASS + ' ' + 'e-' + axis });
        let axisPrompt = createElement('span', {
            className: AXIS_PROMPT_CLASS,
            innerHTML: this.parent.localeObj.getConstant('addPrompt')
        });
        axisWrapper.appendChild(axisContent);
        axisWrapper.appendChild(axisPrompt);
        return axisWrapper;
    }
    showCalculatedField(event) {
        if (!this.parent.isAdaptive) {
            if (this.parent.dialogRenderer.fieldListDialog) {
                this.parent.dialogRenderer.fieldListDialog.hide();
                addClass([this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], ICON_HIDDEN);
            }
        }
        this.parent.notify(initCalculatedField, {});
    }
    showFieldListDialog(event) {
        let activeindex = this.adaptiveElement.selectedItem;
        this.parent.treeViewModule.render(activeindex);
    }
    onShowFieldList() {
        if (this.parent.allowDeferLayoutUpdate) {
            if (this.parent.isAdaptive) {
                this.parent.axisFieldModule.render();
            }
            this.parent.clonedDataSource = extend({}, this.parent.dataSourceSettings, null, true);
            this.parent.clonedFieldList = extend({}, this.parent.pivotFieldList, null, true);
        }
        addClass([this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], ICON_HIDDEN);
        this.parent.dialogRenderer.fieldListDialog.show();
        this.parent.dialogRenderer.fieldListDialog.element.style.top =
            parseInt(this.parent.dialogRenderer.fieldListDialog.element.style.top, 10) < 0 ?
                '0px' : this.parent.dialogRenderer.fieldListDialog.element.style.top;
    }
    onCloseFieldList() {
        if (this.parent.allowDeferLayoutUpdate) {
            this.parent.dataSourceSettings =
                extend({}, this.parent.clonedDataSource.properties, null, true);
            this.parent.pivotGridModule.engineModule = this.parent.engineModule;
            this.parent.pivotGridModule.olapEngineModule = this.parent.olapEngineModule;
            this.parent.pivotGridModule.
                setProperties({
                dataSourceSettings: this.parent.clonedDataSource.properties
            }, true);
            if (Object.keys(this.parent.clonedFieldList).length > 0) {
                this.parent.dataType === 'olap' ? this.parent.olapEngineModule.fieldList =
                    extend({}, this.parent.clonedFieldList, null, true) :
                    this.parent.engineModule.fieldList = extend({}, this.parent.clonedFieldList, null, true);
            }
            this.parent.pivotGridModule.notify(uiUpdate, this);
            this.parent.pivotGridModule.notify(contentReady, this);
        }
        this.parent.dialogRenderer.fieldListDialog.hide();
    }
    removeFieldListIcon() {
        if (!document.getElementById(this.parent.element.id + 'calculateddialog')) {
            removeClass([this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], ICON_HIDDEN);
        }
    }
    keyPress(e) {
        let target = e.target;
        if (e.keyCode === 13 && e.target) {
            e.target.click();
            e.preventDefault();
            return;
        }
    }
    wireDialogEvent(element) {
        EventHandler.add(element, 'keydown', this.keyPress, this);
        EventHandler.add(element, 'click', this.onShowFieldList, this);
    }
    unWireDialogEvent(element) {
        EventHandler.remove(element, 'keydown', this.keyPress);
        EventHandler.remove(element, 'click', this.onShowFieldList);
    }
}

/**
 * Module to render Field List
 */
/** @hidden */
class TreeViewRenderer {
    /** Constructor for render module */
    constructor(parent) {
        this.selectedNodes = [];
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * Initialize the field list tree rendering
     * @returns void
     * @private
     */
    render(axis) {
        this.parentElement = this.parent.dialogRenderer.parentElement;
        this.fieldListSort = 'None';
        if (!this.parent.isAdaptive) {
            let fieldTable = createElement('div', {
                className: FIELD_TABLE_CLASS + ' ' + (this.parent.dataType === 'olap' ? OLAP_FIELD_TABLE_CLASS : '')
            });
            let treeHeader = createElement('div', {
                className: FIELD_HEADER_CLASS,
                innerHTML: this.parent.localeObj.getConstant('allFields')
            });
            let treeOuterDiv = createElement('div', { className: FIELD_LIST_TREE_CLASS + '-outer-div' });
            this.treeViewElement = createElement('div', {
                id: this.parent.element.id + '_TreeView',
                className: FIELD_LIST_CLASS + ' ' + (this.parent.dataType === 'olap' ? OLAP_FIELD_LIST_CLASS : '')
            });
            let fieldHeaderWrappper = createElement('div', { className: 'e-field-header-wrapper' });
            fieldHeaderWrappper.appendChild(treeHeader);
            fieldTable.appendChild(fieldHeaderWrappper);
            this.updateSortElements(fieldHeaderWrappper);
            treeOuterDiv.appendChild(this.treeViewElement);
            fieldTable.appendChild(treeOuterDiv);
            this.parentElement.appendChild(fieldTable);
            if (this.parent.renderMode === 'Fixed') {
                let centerDiv = createElement('div', { className: STATIC_CENTER_DIV_CLASS });
                let axisHeader = createElement('div', {
                    className: STATIC_CENTER_HEADER_CLASS,
                    innerHTML: this.parent.localeObj.getConstant('centerHeader')
                });
                this.parentElement.appendChild(centerDiv);
                this.parentElement.appendChild(axisHeader);
            }
            this.renderTreeView();
        }
        else {
            this.renderTreeDialog(axis);
        }
    }
    updateSortElements(headerWrapper) {
        let options = ['None', 'Ascend', 'Descend'];
        for (let option of options) {
            let spanElement = createElement('span', {
                attrs: {
                    'tabindex': '0',
                    'aria-disabled': 'false',
                    'aria-label': 'Sort ' + option,
                    'data-sort': option
                },
                className: ICON + ' ' + 'e-sort-' + option.toLowerCase() + ' ' +
                    (this.fieldListSort === option ? 'e-selected' : '')
            });
            headerWrapper.appendChild(spanElement);
            this.unWireFieldListEvent(spanElement);
            this.wireFieldListEvent(spanElement);
        }
    }
    renderTreeView() {
        this.fieldTable = new TreeView({
            /* tslint:disable-next-line:max-line-length */
            fields: { dataSource: this.getTreeData(), id: 'id', text: 'caption', isChecked: 'isSelected', parentID: 'pid', iconCss: 'spriteCssClass' },
            nodeChecked: this.nodeStateChange.bind(this),
            cssClass: FIELD_LIST_TREE_CLASS,
            showCheckBox: true,
            allowDragAndDrop: true,
            sortOrder: 'None',
            autoCheck: false,
            loadOnDemand: false,
            enableRtl: this.parent.enableRtl,
            nodeDragStart: this.dragStart.bind(this),
            nodeDragStop: this.dragStop.bind(this),
            drawNode: this.updateTreeNode.bind(this),
            nodeExpanding: this.updateNodeIcon.bind(this),
            nodeCollapsed: this.updateNodeIcon.bind(this),
        });
        this.treeViewElement.innerHTML = '';
        this.fieldTable.isStringTemplate = true;
        this.fieldTable.appendTo(this.treeViewElement);
    }
    updateNodeIcon(args) {
        if (this.parent.dataType === 'olap') {
            if (args.node && args.node.querySelector('.e-list-icon') &&
                (args.node.querySelector('.e-list-icon').className.indexOf('e-folderCDB-icon') > -1)) {
                let node = args.node.querySelector('.e-list-icon');
                removeClass([node], 'e-folderCDB-icon');
                addClass([node], 'e-folderCDB-open-icon');
            }
            else if (args.node && args.node.querySelector('.e-list-icon') &&
                (args.node.querySelector('.e-list-icon').className.indexOf('e-folderCDB-open-icon') > -1)) {
                let node = args.node.querySelector('.e-list-icon');
                removeClass([node], 'e-folderCDB-open-icon');
                addClass([node], 'e-folderCDB-icon');
            }
        }
    }
    updateTreeNode(args) {
        let allowDrag = false;
        let dragVisibility = true;
        if (this.parent.dataType === 'olap') {
            allowDrag = this.updateOlapTreeNode(args);
        }
        else {
            allowDrag = true;
        }
        let liTextElement = args.node.querySelector('.' + TEXT_CONTENT_CLASS);
        if (args.node.querySelector('.e-list-icon') && liTextElement) {
            let liIconElement = args.node.querySelector('.e-list-icon');
            liTextElement.insertBefore(liIconElement, args.node.querySelector('.e-list-text'));
        }
        if (allowDrag && !this.parent.isAdaptive) {
            allowDrag = false;
            let dragElement = createElement('span', {
                attrs: {
                    'tabindex': '-1',
                    title: this.parent.localeObj.getConstant('drag'),
                    'aria-disabled': 'false'
                },
                styles: 'visibility:' + (dragVisibility ? 'visible;' : 'hidden;'),
                className: ICON + ' ' + DRAG_CLASS
            });
            if (args.node.querySelector('.e-checkbox-wrapper') &&
                !args.node.querySelector('.cls.DRAG_CLASS') && liTextElement) {
                liTextElement.insertBefore(dragElement, args.node.querySelector('.e-checkbox-wrapper'));
            }
        }
        if (args.node.querySelector('.' + NODE_CHECK_CLASS)) {
            addClass([args.node.querySelector('.' + LIST_TEXT_CLASS)], LIST_SELECT_CLASS);
        }
    }
    updateOlapTreeNode(args) {
        let allowDrag = false;
        if (this.parent.dataType === 'olap') {
            /* tslint:disable-next-line:max-line-length */
            if (args.node && args.node.querySelector('.e-calcMemberGroupCDB,.e-measureGroupCDB-icon,.e-folderCDB-icon,.e-folderCDB-open-icon,.e-dimensionCDB-icon,.e-kpiCDB-icon')) {
                args.node.querySelector('.e-checkbox-wrapper').style.display = 'none';
            }
            if (args.node && args.node.querySelector('.e-list-icon') &&
                (args.node.querySelector('.e-list-icon').className.indexOf('e-level-members') > -1)) {
                if (this.parent.isAdaptive) {
                    args.node.querySelector('.e-checkbox-wrapper').style.display = 'none';
                }
                else {
                    args.node.querySelector('.e-checkbox-wrapper').style.visibility = 'hidden';
                }
            }
            if (args.node && (args.node.querySelector('.e-hierarchyCDB-icon,.e-attributeCDB-icon,.e-namedSetCDB-icon') ||
                args.node.querySelector('.e-measure-icon,.e-kpiGoal-icon,.e-kpiStatus-icon,.e-kpiTrend-icon,.e-kpiValue-icon') ||
                args.node.querySelector('.e-calc-measure-icon,.e-calc-dimension-icon'))) {
                if (args.node.querySelector('.e-measure-icon')) {
                    args.node.querySelector('.e-list-icon').style.display = 'none';
                    allowDrag = true;
                }
                else {
                    allowDrag = true;
                }
            }
        }
        else {
            allowDrag = true;
        }
        return allowDrag;
    }
    renderTreeDialog(axis) {
        let fieldListDialog = createElement('div', {
            id: this.parent.element.id + '_FieldListTreeView',
            className: ADAPTIVE_FIELD_LIST_DIALOG_CLASS + ' ' + (this.parent.dataType === 'olap' ? 'e-olap-editor-dialog' : ''),
        });
        this.parentElement.appendChild(fieldListDialog);
        this.fieldDialog = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: false,
            header: this.parent.localeObj.getConstant('adaptiveFieldHeader'),
            content: this.createTreeView(this.getTreeData(axis)),
            isModal: true,
            visible: true,
            showCloseIcon: false,
            enableRtl: this.parent.enableRtl,
            width: 'auto',
            height: '350px',
            position: { X: 'center', Y: 'center' },
            buttons: [{
                    click: this.closeTreeDialog.bind(this),
                    buttonModel: {
                        cssClass: CANCEL_BUTTON_CLASS, content: this.parent.localeObj.getConstant('cancel')
                    }
                }, {
                    click: this.onFieldAdd.bind(this),
                    buttonModel: {
                        cssClass: OK_BUTTON_CLASS, content: this.parent.localeObj.getConstant('add'),
                        isPrimary: true
                    }
                }],
            closeOnEscape: true,
            target: this.parentElement.parentElement,
            close: this.dialogClose.bind(this)
        });
        this.fieldDialog.isStringTemplate = true;
        this.fieldDialog.appendTo(fieldListDialog);
        // this.fieldDialog.element.querySelector('.e-dlg-header').innerHTML = this.parent.localeObj.getConstant('adaptiveFieldHeader');
    }
    dialogClose() {
        if (document.getElementById(this.parent.element.id + '_FieldListTreeView')) {
            remove(document.getElementById(this.parent.element.id + '_FieldListTreeView'));
        }
    }
    createTreeView(treeData) {
        let editorTreeWrapper = createElement('div', {
            id: this.parent.element.id + 'EditorDiv',
            className: EDITOR_TREE_WRAPPER_CLASS
        });
        let searchWrapper = createElement('div', {
            id: this.parent.element.id + '_SearchDiv', attrs: { 'tabindex': '-1' },
            className: EDITOR_SEARCH_WRAPPER_CLASS
        });
        let editorSearch = createElement('input', { attrs: { 'type': 'text' } });
        searchWrapper.appendChild(editorSearch);
        let treeOuterDiv = createElement('div', { className: EDITOR_TREE_CONTAINER_CLASS + '-outer-div' });
        let treeViewContainer = createElement('div', {
            className: EDITOR_TREE_CONTAINER_CLASS + ' ' + (this.parent.dataType === 'olap' ? 'e-olap-field-list-tree' : '')
        });
        editorTreeWrapper.appendChild(searchWrapper);
        this.editorSearch = new MaskedTextBox({
            showClearButton: true,
            placeholder: this.parent.localeObj.getConstant('search'),
            enableRtl: this.parent.enableRtl,
            cssClass: EDITOR_SEARCH_CLASS,
            change: this.textChange.bind(this)
        });
        this.editorSearch.isStringTemplate = true;
        this.editorSearch.appendTo(editorSearch);
        let promptDiv = createElement('div', {
            className: EMPTY_MEMBER_CLASS + ' ' + ICON_DISABLE,
            innerHTML: this.parent.localeObj.getConstant('noMatches')
        });
        editorTreeWrapper.appendChild(promptDiv);
        treeOuterDiv.appendChild(treeViewContainer);
        editorTreeWrapper.appendChild(treeOuterDiv);
        this.fieldTable = new TreeView({
            /* tslint:disable-next-line:max-line-length */
            fields: { dataSource: treeData, id: 'id', text: 'caption', isChecked: 'isSelected', parentID: 'pid', iconCss: 'spriteCssClass' },
            showCheckBox: true,
            autoCheck: false,
            loadOnDemand: false,
            sortOrder: this.parent.dataType === 'olap' ? 'None' : 'Ascending',
            enableRtl: this.parent.enableRtl,
            nodeChecked: this.addNode.bind(this),
            drawNode: this.updateTreeNode.bind(this),
            nodeExpanding: this.updateNodeIcon.bind(this),
            nodeCollapsed: this.updateNodeIcon.bind(this),
        });
        this.fieldTable.isStringTemplate = true;
        this.fieldTable.appendTo(treeViewContainer);
        return editorTreeWrapper;
    }
    textChange(e) {
        this.parent.pivotCommon.eventBase.searchTreeNodes(e, this.fieldTable, true);
        let promptDiv = this.fieldDialog.element.querySelector('.' + EMPTY_MEMBER_CLASS);
        let liList = [].slice.call(this.fieldTable.element.querySelectorAll('li'));
        /* tslint:disable-next-line:max-line-length */
        let disabledList = [].slice.call(this.fieldTable.element.querySelectorAll('li.' + ICON_DISABLE));
        if (liList.length === disabledList.length) {
            removeClass([promptDiv], ICON_DISABLE);
        }
        else {
            addClass([promptDiv], ICON_DISABLE);
        }
    }
    dragStart(args) {
        if (args.event.target.classList.contains(DRAG_CLASS)) {
            this.parent.isDragging = true;
            addClass([args.draggedNode.querySelector('.' + LIST_TEXT_CLASS)], SELECTED_NODE_CLASS);
            let data;
            if (this.parent.dataType === 'olap') {
                data = this.parent.olapEngineModule.fieldList[args.draggedNode.getAttribute('data-uid')];
            }
            else {
                data = this.parent.engineModule.fieldList[args.draggedNode.getAttribute('data-uid')];
            }
            let axis = [ROW_AXIS_CLASS, COLUMN_AXIS_CLASS, FILTER_AXIS_CLASS];
            if (data && data.aggregateType === 'CalculatedField') {
                for (let axisContent of axis) {
                    addClass([this.parentElement.querySelector('.' + axisContent)], NO_DRAG_CLASS);
                }
            }
            let dragItem = args.clonedNode;
            if (dragItem && (this.parent.getModuleName() === 'pivotfieldlist' &&
                this.parent.renderMode) === 'Popup') {
                dragItem.style.zIndex = (this.parent.dialogRenderer.fieldListDialog.zIndex + 1).toString();
            }
        }
        else {
            args.cancel = true;
        }
    }
    dragStop(args) {
        args.cancel = true;
        this.parent.isDragging = false;
        let axis = [ROW_AXIS_CLASS, COLUMN_AXIS_CLASS, FILTER_AXIS_CLASS];
        for (let axisElement of axis) {
            removeClass([this.parentElement.querySelector('.' + axisElement)], NO_DRAG_CLASS);
        }
        removeClass([args.draggedNode.querySelector('.' + LIST_TEXT_CLASS)], SELECTED_NODE_CLASS);
        if (this.parent.pivotCommon.filterDialog.dialogPopUp) {
            this.parent.pivotCommon.filterDialog.dialogPopUp.close();
        }
        let fieldName = args.draggedNodeData.id.toString();
        if (!this.isNodeDropped(args, fieldName)) {
            return;
        }
        let list = this.parent.pivotFieldList;
        let selectedNode = list[fieldName];
        this.parent.pivotCommon.dataSourceUpdate.control = this.parent.getModuleName() === 'pivotview' ? this.parent :
            (this.parent.pivotGridModule ? this.parent.pivotGridModule : this.parent);
        if (this.parent.pivotCommon.nodeStateModified.onStateModified(args, fieldName)) {
            if (this.parent.allowDeferLayoutUpdate) {
                selectedNode.isSelected = true;
                this.updateDataSource();
            }
            else {
                this.parent.updateDataSource();
            }
            let parent = this.parent;
            //setTimeout(() => {
            parent.axisFieldModule.render();
            //});
        }
    }
    isNodeDropped(args, targetID) {
        let isDropped = true;
        if (args.draggedNodeData.isChecked === 'true') {
            let target = this.getButton(targetID);
            let axisPanel = closest(target, '.' + DROPPABLE_CLASS);
            let droppableElement = closest(args.target, '.' + DROPPABLE_CLASS);
            if (target && axisPanel === droppableElement) {
                let pivotButtons = [].slice.call(axisPanel.querySelectorAll('.' + PIVOT_BUTTON_CLASS));
                let dropTarget = closest(args.target, '.' + PIVOT_BUTTON_WRAPPER_CLASS);
                let sourcePosition;
                let dropPosition = -1;
                for (let i = 0, n = pivotButtons.length; i < n; i++) {
                    if (pivotButtons[i].id === target.id) {
                        sourcePosition = i;
                    }
                    if (dropTarget) {
                        let droppableButton = dropTarget.querySelector('.' + PIVOT_BUTTON_CLASS);
                        if (pivotButtons[i].id === droppableButton.id) {
                            dropPosition = i;
                        }
                    }
                }
                if (sourcePosition === dropPosition || (sourcePosition === (pivotButtons.length - 1) && dropPosition === -1)) {
                    let parentElement = document.getElementById(this.parent.element.id + '_Wrapper');
                    removeClass([].slice.call(parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS)), INDICATOR_HOVER_CLASS);
                    isDropped = false;
                }
            }
        }
        return isDropped;
    }
    getButton(fieldName) {
        let wrapperElement = document.getElementById(this.parent.element.id + '_Wrapper');
        let pivotButtons = [].slice.call(wrapperElement.querySelectorAll('.' + PIVOT_BUTTON_CLASS));
        let buttonElement;
        for (let i = 0, n = pivotButtons.length; i < n; i++) {
            if (pivotButtons[i].id === fieldName) {
                buttonElement = pivotButtons[i];
                break;
            }
        }
        return buttonElement;
    }
    nodeStateChange(args) {
        let node = closest(args.node, '.' + TEXT_CONTENT_CLASS);
        if (!isNullOrUndefined(node)) {
            let li = closest(node, 'li');
            let id = li.getAttribute('data-uid');
            if (this.parent.pivotCommon.filterDialog.dialogPopUp) {
                this.parent.pivotCommon.filterDialog.dialogPopUp.close();
            }
            let list = this.parent.pivotFieldList;
            let selectedNode = list[id];
            let eventdrop = {
                'droppedField': selectedNode, 'dataSourceSettings': this.parent.dataSourceSettings,
                'droppedAxis': 'rows', 'draggedAxis': 'fieldlist', 'cancel': false
            };
            this.parent.trigger(fieldDrop, eventdrop, (observedArgs) => {
                if (!observedArgs.cancel) {
                    if (args.action === 'check') {
                        addClass([node.querySelector('.' + LIST_TEXT_CLASS)], LIST_SELECT_CLASS);
                        this.updateSelectedNodes(li, args.action);
                        let addNode = this.parent.pivotCommon.dataSourceUpdate.getNewField(id);
                        if (selectedNode.type === 'number' || (selectedNode.type === 'CalculatedField' &&
                            selectedNode.formula && selectedNode.formula.indexOf('Measure') > -1 &&
                            this.parent.dataType === 'olap')) {
                            this.parent.dataSourceSettings.values.push(addNode);
                            if (this.parent.dataType === 'olap' && this.parent.olapEngineModule &&
                                !(this.parent.olapEngineModule).isMeasureAvail) {
                                let measureField = {
                                    name: '[Measures]', caption: 'Measures', baseField: undefined, baseItem: undefined,
                                };
                                let fieldAxis = this.parent.dataSourceSettings.valueAxis === 'row' ?
                                    this.parent.dataSourceSettings.rows : this.parent.dataSourceSettings.columns;
                                fieldAxis.push(measureField);
                            }
                        }
                        else {
                            this.parent.dataSourceSettings.rows.push(addNode);
                        }
                    }
                    else {
                        removeClass([node.querySelector('.' + LIST_TEXT_CLASS)], LIST_SELECT_CLASS);
                        this.updateSelectedNodes(li, args.action);
                        this.parent.pivotCommon.dataSourceUpdate.removeFieldFromReport(id);
                        if (this.parent.dataType === 'olap' && this.parent.dataSourceSettings.values.length === 0) {
                            this.parent.pivotCommon.dataSourceUpdate.removeFieldFromReport('[Measures]');
                        }
                    }
                    if (!this.parent.allowDeferLayoutUpdate) {
                        this.parent.updateDataSource(true);
                    }
                    else {
                        selectedNode.isSelected = args.action === 'check';
                        if (this.parent.dataType === 'olap') {
                            this.parent.olapEngineModule.updateFieldlistData(id, args.action === 'check');
                        }
                        this.updateDataSource();
                    }
                    let parent = this.parent;
                    setTimeout(() => {
                        parent.axisFieldModule.render();
                    });
                }
                else {
                    let chkState = this.parent.treeViewModule.treeViewElement.querySelectorAll('.e-checkbox-wrapper');
                    let innerText = this.parent.treeViewModule.treeViewElement.querySelectorAll('.e-list-text');
                    let checkClass = this.parent.treeViewModule.treeViewElement.querySelectorAll('.e-frame');
                    for (let i = 0; i < chkState.length; i++) {
                        if (observedArgs.droppedField.caption === innerText[i].textContent) {
                            if (chkState[i].getAttribute('aria-checked') === 'false') {
                                chkState[i].setAttribute('aria-checked', 'false');
                                checkClass[i].classList.add(NODE_CHECK_CLASS);
                            }
                            else {
                                chkState[i].setAttribute('aria-checked', 'true');
                                checkClass[i].classList.remove(NODE_CHECK_CLASS);
                            }
                        }
                    }
                }
            });
        }
    }
    updateSelectedNodes(li, state) {
        if (li && li.querySelector('ul')) {
            for (let element of [].slice.call(li.querySelectorAll('li'))) {
                if (state === 'check') {
                    addClass([element.querySelector('.' + LIST_TEXT_CLASS)], LIST_SELECT_CLASS);
                }
                else {
                    removeClass([element.querySelector('.' + LIST_TEXT_CLASS)], LIST_SELECT_CLASS);
                }
            }
        }
    }
    updateDataSource() {
        if (this.parent.getModuleName() === 'pivotfieldlist' && this.parent.renderMode === 'Popup') {
            if (this.parent.dataType === 'olap') {
                this.parent.pivotGridModule.olapEngineModule = this.parent.olapEngineModule;
            }
            else {
                this.parent.pivotGridModule.engineModule = this.parent.engineModule;
            }
            /* tslint:disable-next-line:max-line-length */
            this.parent.pivotGridModule.setProperties({ dataSourceSettings: this.parent.dataSourceSettings.properties }, true);
            this.parent.pivotGridModule.notify(uiUpdate, this);
        }
        else {
            this.parent.triggerPopulateEvent();
        }
    }
    addNode(args) {
        let fieldList = this.parent.pivotFieldList;
        let selectedNode = fieldList[args.data[0].id.toString()];
        if (args.action === 'check') {
            this.selectedNodes.push(selectedNode.id.toString());
        }
        else {
            let count = this.selectedNodes.length;
            while (count--) {
                if (this.selectedNodes[count] === selectedNode.id.toString()) {
                    this.selectedNodes.splice(count, 1);
                    break;
                }
            }
        }
    }
    refreshTreeView() {
        if (this.fieldTable) {
            let treeData = this.getUpdatedData();
            this.fieldTable.fields = {
                dataSource: treeData, id: 'id', text: 'caption', isChecked: 'isSelected', parentID: 'pid', iconCss: 'spriteCssClass'
            };
            this.fieldTable.dataBind();
        }
    }
    getUpdatedData() {
        let treeData = this.getTreeData();
        let expandedNodes = this.fieldTable.expandedNodes;
        this.updateExpandedNodes(treeData, expandedNodes);
        return this.applySorting(treeData, this.fieldListSort);
    }
    getTreeData(axis) {
        let data = [];
        if (this.parent.dataType === 'olap') {
            data = this.getOlapTreeData(axis);
        }
        else {
            let keys = Object.keys(this.parent.pivotFieldList);
            let fieldList = {};
            for (let key of keys) {
                let member = this.parent.pivotFieldList[key];
                fieldList[key] = { id: member.id, caption: member.caption, isSelected: member.isSelected };
            }
            if (this.parent.isAdaptive) {
                /* tslint:disable-next-line:max-line-length */
                let fields = [this.parent.dataSourceSettings.filters, this.parent.dataSourceSettings.columns, this.parent.dataSourceSettings.rows,
                    this.parent.dataSourceSettings.values];
                let currentFieldSet = fields[axis];
                let len = keys.length;
                while (len--) {
                    fieldList[keys[len]].isSelected = false;
                }
                for (let item of currentFieldSet) {
                    fieldList[item.name].isSelected = true;
                }
            }
            let list = fieldList;
            for (let member of keys) {
                let obj = list[member];
                data.push(obj);
            }
        }
        return data;
    }
    getOlapTreeData(axis) {
        let data = [];
        let fieldListData = this.parent.olapEngineModule.fieldListData;
        if (this.parent.isAdaptive) {
            /* tslint:disable-next-line:max-line-length */
            let fields = [
                this.parent.dataSourceSettings.filters, this.parent.dataSourceSettings.columns,
                this.parent.dataSourceSettings.rows, this.parent.dataSourceSettings.values
            ];
            let currentFieldSet = fields[axis];
            let i = 0;
            while (i < fieldListData.length) {
                let item = fieldListData[i];
                /* tslint:disable */
                let framedSet;
                /* tslint:enable */
                if (axis === 3) {
                    if (item.id.toLowerCase() !== '[measures]' &&
                        (item.id.toLowerCase().indexOf('[measures]') === 0 ||
                            (item.spriteCssClass && item.spriteCssClass.indexOf('e-measureCDB') !== -1)) ||
                        (item.id.toLowerCase() === '[calculated members].[_0]' ||
                            (item.spriteCssClass && item.spriteCssClass.indexOf('e-calc-measure-icon') !== -1))) {
                        framedSet = {
                            id: item.id, caption: item.caption, hasChildren: item.hasChildren,
                            type: item.type, aggregateType: item.aggregateType,
                            isSelected: item.isSelected, pid: item.pid, spriteCssClass: item.spriteCssClass
                        };
                        framedSet.isSelected = false;
                        if (framedSet.spriteCssClass && framedSet.spriteCssClass.indexOf('e-measureCDB') !== -1) {
                            framedSet.spriteCssClass = framedSet.spriteCssClass.replace('e-folderCDB-icon', 'e-measureGroupCDB-icon');
                            framedSet.pid = undefined;
                        }
                        for (let field of currentFieldSet) {
                            if (framedSet.id === field.name) {
                                framedSet.isSelected = true;
                                break;
                            }
                        }
                        data.push(framedSet);
                    }
                }
                else {
                    if (!(item.id.toLowerCase().indexOf('[measures]') === 0) &&
                        !(item.spriteCssClass && item.spriteCssClass.indexOf('e-measureCDB') !== -1) &&
                        !(item.spriteCssClass && item.spriteCssClass.indexOf('e-calc-measure-icon') !== -1)) {
                        framedSet = {
                            id: item.id, caption: item.caption, hasChildren: item.hasChildren,
                            type: item.type, aggregateType: item.aggregateType,
                            isSelected: item.isSelected, pid: item.pid, spriteCssClass: item.spriteCssClass
                        };
                        framedSet.isSelected = false;
                        for (let item of currentFieldSet) {
                            if (framedSet.id === item.name) {
                                framedSet.isSelected = true;
                                break;
                            }
                        }
                        data.push(framedSet);
                    }
                }
                i++;
            }
        }
        else {
            data = PivotUtil.getClonedData(this.parent.olapEngineModule.fieldListData);
        }
        return data;
    }
    updateExpandedNodes(data, expandedNodes) {
        if (expandedNodes.length > 0) {
            let i = 0;
            for (let field of data) {
                if (expandedNodes.indexOf(field.id) > -1) {
                    i++;
                    field.expanded = true;
                    field.spriteCssClass = (field.spriteCssClass &&
                        field.spriteCssClass.toString().indexOf('e-folderCDB-icon') > -1 ?
                        field.spriteCssClass.toString().replace('e-folderCDB-icon', 'e-folderCDB-open-icon') :
                        field.spriteCssClass);
                    if (i === (expandedNodes.length)) {
                        break;
                    }
                }
            }
        }
    }
    updateSorting(args) {
        let target = args.target;
        let option = target.getAttribute('data-sort');
        if (target.className.indexOf('e-selected') === -1) {
            switch (option) {
                case 'None':
                    this.fieldListSort = 'None';
                    addClass([target], 'e-selected');
                    removeClass([this.parentElement.querySelector('.e-sort-ascend')], 'e-selected');
                    removeClass([this.parentElement.querySelector('.e-sort-descend')], 'e-selected');
                    break;
                case 'Ascend':
                    this.fieldListSort = 'Ascend';
                    addClass([target], 'e-selected');
                    removeClass([this.parentElement.querySelector('.e-sort-none')], 'e-selected');
                    removeClass([this.parentElement.querySelector('.e-sort-descend')], 'e-selected');
                    break;
                case 'Descend':
                    this.fieldListSort = 'Descend';
                    addClass([target], 'e-selected');
                    removeClass([this.parentElement.querySelector('.e-sort-ascend')], 'e-selected');
                    removeClass([this.parentElement.querySelector('.e-sort-none')], 'e-selected');
                    break;
            }
            this.refreshTreeView();
        }
    }
    applySorting(treeData, sortOrder) {
        if (this.parent.dataType === 'olap') {
            let measure;
            let calcMember;
            if (this.parent.dataSourceSettings.calculatedFieldSettings.length > 0 &&
                treeData[0].id.toLowerCase() === '[calculated members].[_0]') {
                calcMember = treeData[0];
                measure = treeData[1];
                treeData.splice(0, 2);
            }
            else {
                measure = treeData[0];
                treeData.splice(0, 1);
            }
            /* tslint:disable:typedef */
            treeData = sortOrder === 'Ascend' ?
                (treeData.sort((a, b) => (a.caption > b.caption) ? 1 : ((b.caption > a.caption) ? -1 : 0))) :
                sortOrder === 'Descend' ?
                    (treeData.sort((a, b) => (a.caption < b.caption) ? 1 : ((b.caption < a.caption) ? -1 : 0))) :
                    treeData;
            /* tslint:enable:typedef */
            if (calcMember) {
                treeData.splice(0, 0, calcMember, measure);
            }
            else {
                treeData.splice(0, 0, measure);
            }
        }
        else {
            this.fieldTable.sortOrder = ((sortOrder === 'Ascend' ? 'Ascending' : (sortOrder === 'Descend' ? 'Descending' : 'None')));
        }
        return treeData;
    }
    onFieldAdd(e) {
        this.parent.dialogRenderer.updateDataSource(this.selectedNodes);
        this.closeTreeDialog();
    }
    closeTreeDialog() {
        this.selectedNodes = [];
        this.fieldDialog.hide();
    }
    keyPress(e) {
        let target = e.target;
        if (e.keyCode === 13 && e.target) {
            e.target.click();
            e.preventDefault();
            return;
        }
    }
    wireFieldListEvent(element) {
        EventHandler.add(element, 'keydown', this.keyPress, this);
        EventHandler.add(element, 'click', this.updateSorting, this);
    }
    unWireFieldListEvent(element) {
        EventHandler.remove(element, 'keydown', this.keyPress);
        EventHandler.remove(element, 'click', this.updateSorting);
    }
    /**
     * @hidden
     */
    addEventListener() {
        this.parent.on(treeViewUpdate, this.refreshTreeView, this);
    }
    /**
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(treeViewUpdate, this.refreshTreeView);
    }
    /**
     * To destroy the tree view event listener
     * @return {void}
     * @hidden
     */
    destroy() {
        this.removeEventListener();
    }
}

/**
 * Module to render Axis Field Table
 */
/** @hidden */
class AxisTableRenderer {
    /** Constructor for render module */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Initialize the axis table rendering
     * @returns void
     * @private
     */
    render() {
        if (!this.parent.isAdaptive) {
            let axisTable = createElement('div', {
                className: AXIS_TABLE_CLASS + ' ' + (this.parent.dataType === 'olap' ? OLAP_AXIS_TABLE_CLASS : '')
            });
            this.leftAxisPanel = createElement('div', { className: LEFT_AXIS_PANEL_CLASS });
            this.rightAxisPanel = createElement('div', { className: RIGHT_AXIS_PANEL_CLASS });
            this.parent.dialogRenderer.parentElement.appendChild(axisTable);
            axisTable.appendChild(this.leftAxisPanel);
            axisTable.appendChild(this.rightAxisPanel);
            this.axisTable = axisTable;
            this.renderAxisTable();
        }
        this.parent.axisFieldModule.render();
    }
    renderAxisTable() {
        let fieldLabels = ['filters', 'rows', 'columns', 'values'];
        for (let len = 0, lnt = fieldLabels.length; len < lnt; len++) {
            let axis = createElement('div', {
                className: FIELD_LIST_CLASS + '-' + fieldLabels[len]
            });
            let axisTitleWrapper = createElement('div', {
                className: AXIS_ICON_CLASS + '-wrapper'
            });
            let axisTitle = createElement('div', {
                className: AXIS_HEADER_CLASS,
                innerHTML: this.parent.localeObj.getConstant(fieldLabels[len])
            });
            axisTitleWrapper.appendChild(this.getIconupdate(fieldLabels[len]));
            axisTitleWrapper.appendChild(axisTitle);
            let axisContent = createElement('div', { className: AXIS_CONTENT_CLASS + ' ' + 'e-' + fieldLabels[len] });
            let localePrompt;
            if (fieldLabels[len] === 'rows') {
                localePrompt = this.parent.localeObj.getConstant('dropRowPrompt');
            }
            else if (fieldLabels[len] === 'columns') {
                localePrompt = this.parent.localeObj.getConstant('dropColPrompt');
            }
            else if (fieldLabels[len] === 'values') {
                localePrompt = this.parent.localeObj.getConstant('dropValPrompt');
            }
            else {
                localePrompt = this.parent.localeObj.getConstant('dropFilterPrompt');
            }
            let axisPrompt = createElement('span', {
                className: AXIS_PROMPT_CLASS,
                innerHTML: localePrompt
            });
            let droppable = new Droppable(axisContent, {});
            axis.appendChild(axisTitleWrapper);
            axis.appendChild(axisContent);
            axis.appendChild(axisPrompt);
            if (len <= 1) {
                this.leftAxisPanel.appendChild(axis);
            }
            else {
                this.rightAxisPanel.appendChild(axis);
            }
            this.unWireEvent(axisContent);
            this.wireEvent(axisContent);
        }
    }
    getIconupdate(axis) {
        let axisWrapper = createElement('span', {
            attrs: { 'tabindex': '-1', 'aria-disabled': 'false' },
            className: AXIS_ICON_CLASS + '-icon-wrapper'
        });
        let axisElement = createElement('span', {
            attrs: {
                'tabindex': '-1', 'aria-disabled': 'false'
            },
            className: ICON + ' ' + AXIS_ICON_CLASS + '-' + axis
        });
        axisWrapper.appendChild(axisElement);
        return axisWrapper;
    }
    wireEvent(element) {
        EventHandler.add(element, 'mouseover', this.updateDropIndicator, this);
        EventHandler.add(element, 'mouseleave', this.updateDropIndicator, this);
    }
    unWireEvent(element) {
        EventHandler.remove(element, 'mouseover', this.updateDropIndicator);
        EventHandler.remove(element, 'mouseleave', this.updateDropIndicator);
    }
    updateDropIndicator(e) {
        let parentElement = this.parent.dialogRenderer.parentElement;
        if (this.parent.isDragging && e.target.classList.contains(AXIS_CONTENT_CLASS) && e.type === 'mouseover') {
            removeClass([].slice.call(parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS)), INDICATOR_HOVER_CLASS);
            removeClass([].slice.call(parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS + '-last')), INDICATOR_HOVER_CLASS);
            let element = [].slice.call(e.target.querySelectorAll('.' + PIVOT_BUTTON_WRAPPER_CLASS));
            if (element.length > 0) {
                addClass([element[element.length - 1].querySelector('.' + DROP_INDICATOR_CLASS + '-last')], INDICATOR_HOVER_CLASS);
            }
        }
        else if (e.type === 'mouseleave') {
            removeClass([].slice.call(parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS)), INDICATOR_HOVER_CLASS);
            removeClass([].slice.call(parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS + '-last')), INDICATOR_HOVER_CLASS);
        }
    }
}

/**
 * Module to render Pivot button
 */
/** @hidden */
class PivotButton {
    /** Constructor for render module */
    constructor(parent) {
        this.parent = parent;
        this.menuOption = new AggregateMenu(this.parent);
        this.parent.pivotButtonModule = this;
        this.addEventListener();
        if (this.parent instanceof PivotFieldList) {
            this.axisField = new AxisFieldRenderer(this.parent);
        }
    }
    /* tslint:disable */
    renderPivotButton(args) {
        let field = extend([], args.field, null, true);
        let axis = args.axis;
        let axisElement;
        let valuePos = -1;
        let showValuesButton = (this.parent.dataType === 'pivot' ? (this.parent.getModuleName() == "pivotfieldlist" &&
            this.parent.pivotGridModule) ?
            this.parent.pivotGridModule.showValuesButton : this.parent.showValuesButton : false);
        if (((this.parent.dataSourceSettings.valueAxis === 'row' && args.axis === 'rows') ||
            (this.parent.dataSourceSettings.valueAxis === 'column' && args.axis === 'columns')) && showValuesButton && this.parent.dataSourceSettings.values.length > 1) {
            valuePos = field.length;
            field.push({
                name: this.parent.localeObj.getConstant('values'), caption: this.parent.localeObj.getConstant('values'),
                axis: args.axis
            });
        }
        this.parentElement = this.parent.getModuleName() === 'pivotview' ? this.parent.element :
            document.getElementById(this.parent.element.id + '_Wrapper');
        if (this.parent.getModuleName() === 'pivotfieldlist') {
            this.parentElement = document.getElementById(this.parent.element.id + '_Wrapper');
            if (this.parentElement.querySelector('.' + FIELD_LIST_CLASS + '-' + axis)) {
                let axisPrompt = this.parentElement.querySelector('.' + FIELD_LIST_CLASS + '-' + axis)
                    .querySelector('.' + AXIS_PROMPT_CLASS);
                if (field.length === 0) {
                    removeClass([axisPrompt], ICON_DISABLE);
                }
                else {
                    addClass([axisPrompt], ICON_DISABLE);
                }
                axisElement =
                    this.parentElement.querySelector('.' + FIELD_LIST_CLASS + '-' + axis).querySelector('.' + AXIS_CONTENT_CLASS);
            }
            else {
                return;
            }
        }
        else {
            this.parentElement = this.parent.element;
            axisElement = this.parentElement.querySelector('.e-group-' + axis);
        }
        if (axisElement) {
            if (this.parent.getModuleName() === 'pivotview' && field.length === 0) {
                for (let element of this.parentElement.querySelectorAll('.e-group-' + axis)) {
                    if (!element.classList.contains(GROUP_CHART_VALUE)) {
                        let axisPrompt = createElement('span', {
                            className: AXIS_PROMPT_CLASS,
                            innerHTML: (this.parent.groupingBarSettings.allowDragAndDrop ? axis === 'rows' ? this.parent.localeObj.getConstant('rowAxisPrompt') :
                                axis === 'columns' ? this.parent.localeObj.getConstant('columnAxisPrompt') :
                                    axis === 'values' ? this.parent.localeObj.getConstant('valueAxisPrompt') :
                                        this.parent.localeObj.getConstant('filterAxisPrompt') : '')
                        });
                        element.appendChild(axisPrompt);
                    }
                }
            }
            else {
                for (let i = 0, cnt = field.length; i < cnt; i++) {
                    for (let element of (this.parent.getModuleName() === 'pivotfieldlist' ? [axisElement] : this.parentElement.querySelectorAll('.e-group-' + axis))) {
                        element = element;
                        let isMeasureAvail = (this.parent.dataType === 'olap' && (field[i].name.toLowerCase() === '[measures]' || axis === 'values'));
                        let isMeasureFieldsAvail = (this.parent.dataType === 'olap' && axis === 'values');
                        if (!element.classList.contains(GROUP_CHART_VALUE)) {
                            let buttonWrapper = createElement('div', {
                                className: PIVOT_BUTTON_WRAPPER_CLASS + (i === 0 ? ' e-first-btn' : ''),
                                attrs: { 'data-tag': axis + ':' + field[i].name }
                            });
                            let buttonElement = createElement('div', {
                                id: field[i].name, className: PIVOT_BUTTON_CLASS + ' ' + field[i].name.replace(/[^A-Z0-9]/ig, ''),
                                attrs: {
                                    'data-uid': field[i].name, 'tabindex': '0', 'isvalue': (i === valuePos || isMeasureAvail && !isMeasureFieldsAvail) ? 'true' : 'false',
                                    'aria-disabled': 'false', 'aria-label': field[i].caption ? field[i].caption : field[i].name,
                                    'data-type': (this.parent.dataType === 'olap' ? isMeasureFieldsAvail ? 'isMeasureFieldsAvail' : isMeasureAvail ? 'isMeasureAvail' : field[i].type : field[i].type),
                                    'data-caption': field[i].caption ? field[i].caption : field[i].name,
                                    'data-basefield': field[i].baseField,
                                    'data-baseitem': field[i].baseItem
                                }
                            });
                            let dropIndicatorElement = createElement('span', {
                                attrs: { 'tabindex': '-1', 'aria-disabled': 'false' },
                                className: DROP_INDICATOR_CLASS
                            });
                            let dropLastIndicatorElement = createElement('span', {
                                attrs: { 'tabindex': '-1', 'aria-disabled': 'false' },
                                className: DROP_INDICATOR_CLASS + '-last'
                            });
                            let dragWrapper = this.createButtonDragIcon(buttonElement);
                            let contentElement = this.createButtonText(field, i, axis, valuePos);
                            buttonElement.appendChild(contentElement);
                            if (!isMeasureAvail && !field[i].isNamedSet && !field[i].isCalculatedField) {
                                if (['filters', 'values'].indexOf(axis) === -1 && valuePos !== i &&
                                    !(this.parent.dataType === 'olap' && ((this.parent.getModuleName() === 'pivotview' &&
                                        this.parent.enableVirtualization) || (this.parent.getModuleName() === 'pivotfieldlist' &&
                                        this.parent.pivotGridModule !== undefined &&
                                        this.parent.pivotGridModule.enableVirtualization)))) {
                                    this.createSortOption(buttonElement, field[i].name);
                                }
                                if (axis !== 'values' && valuePos !== i) {
                                    this.createFilterOption(buttonElement, field[i].name, axis);
                                }
                                if (axis === 'values') {
                                    this.getTypeStatus(field, i, buttonElement);
                                }
                            }
                            let removeElement = createElement('span', {
                                attrs: { 'tabindex': '-1', 'aria-disabled': 'false' },
                                className: ICON + ' ' + REMOVE_CLASS
                            });
                            if (this.parent.getModuleName() === 'pivotview') {
                                if (this.parent.groupingBarSettings.showRemoveIcon) {
                                    removeClass([removeElement], ICON_DISABLE);
                                }
                                else {
                                    addClass([removeElement], ICON_DISABLE);
                                }
                            }
                            buttonElement.appendChild(removeElement);
                            buttonWrapper.appendChild(dropIndicatorElement);
                            buttonWrapper.appendChild(buttonElement);
                            buttonWrapper.appendChild(dropLastIndicatorElement);
                            element.appendChild(buttonWrapper);
                            let pivotButton = new Button({ enableRtl: this.parent.enableRtl });
                            pivotButton.isStringTemplate = true;
                            pivotButton.appendTo(buttonElement);
                            this.unWireEvent(buttonWrapper, i === valuePos ? 'values' : axis, isMeasureAvail);
                            this.wireEvent(buttonWrapper, i === valuePos ? 'values' : axis, isMeasureAvail);
                            if ((this.parent.getModuleName() === 'pivotview' && !this.parent.isAdaptive) ||
                                this.parent.getModuleName() === 'pivotfieldlist') {
                                this.createDraggable(this.parent.getModuleName() === 'pivotview' ? contentElement : dragWrapper);
                            }
                        }
                    }
                }
                if (axis === 'values') {
                    for (let element of this.parentElement.querySelectorAll('.e-group-' + axis)) {
                        if (element.classList.contains(GROUP_CHART_VALUE) && this.parent.chartModule) {
                            let valueData = field.map((item) => { return { text: item.caption ? item.caption : item.name, value: item.name }; });
                            let parent = this.parent;
                            if (this.valueFiedDropDownList && element.querySelector('.' + GROUP_CHART_VALUE_DROPDOWN_DIV)) {
                                this.valueFiedDropDownList.dataSource = valueData;
                                this.valueFiedDropDownList.value = !parent.chartSettings.enableMultiAxis ?
                                    parent.chartModule.currentMeasure : valueData[0].value;
                            }
                            else {
                                let ddlDiv = createElement('div', { className: GROUP_CHART_VALUE_DROPDOWN_DIV });
                                element.appendChild(ddlDiv);
                                this.valueFiedDropDownList = new DropDownList({
                                    dataSource: valueData,
                                    enableRtl: this.parent.enableRtl,
                                    value: !parent.chartSettings.enableMultiAxis ?
                                        parent.chartModule.currentMeasure : valueData[0].value,
                                    width: 200,
                                    fields: { value: 'value', text: 'text' },
                                    cssClass: GROUP_CHART_VALUE_DROPDOWN,
                                    change(args) {
                                        if (args.e && args.e !== null) {
                                            parent.chartSettings.value = args.value;
                                        }
                                    }
                                });
                                this.valueFiedDropDownList.isStringTemplate = true;
                                this.valueFiedDropDownList.appendTo(ddlDiv);
                            }
                        }
                    }
                }
            }
        }
        else {
            return;
        }
    }
    createButtonText(field, i, axis, valuePos) {
        let buttonText;
        let aggregation;
        let filterMem;
        if (axis === "filters") {
            filterMem = this.updateButtontext(field[i].name);
        }
        let engineModule;
        if (this.parent.dataType === 'olap') {
            engineModule = this.parent.olapEngineModule;
        }
        else {
            engineModule = this.parent.engineModule;
        }
        if (engineModule.fieldList[field[i].name] !== undefined) {
            aggregation = engineModule.fieldList[field[i].name].aggregateType;
            if ((aggregation !== 'DistinctCount') && (engineModule.fieldList[field[i].name].type !== 'number' || engineModule.fieldList[field[i].name].type === 'include' ||
                engineModule.fieldList[field[i].name].type === 'exclude')) {
                aggregation = 'Count';
            }
            else {
                aggregation = aggregation === undefined ? 'Sum' :
                    engineModule.fieldList[field[i].name].aggregateType;
            }
        }
        let text = field[i].caption ? field[i].caption : field[i].name;
        buttonText = createElement('span', {
            attrs: {
                title: axis === 'filters' ? (this.parent.dataType === 'olap' && engineModule.fieldList[field[i].name].type === 'CalculatedField') ?
                    text : (text + ' (' + filterMem + ')') : (this.parent.dataType === 'olap' ?
                    text : (((!this.parent.dataSourceSettings.showAggregationOnValueField || axis !== 'values' || aggregation === 'CalculatedField') ?
                    text : this.parent.localeObj.getConstant(aggregation) + ' ' + this.parent.localeObj.getConstant('of') + ' ' + text))),
                'tabindex': '-1', 'aria-disabled': 'false', 'oncontextmenu': 'return false;',
                'data-type': valuePos === i ? '' : aggregation
            },
            className: PIVOT_BUTTON_CONTENT_CLASS + ' ' +
                (this.parent.getModuleName() === 'pivotview' && !this.parent.groupingBarSettings.allowDragAndDrop ? 'e-disable-drag' : ''),
            innerHTML: axis === 'filters' ? (this.parent.dataType === 'olap' && engineModule.fieldList[field[i].name].type === 'CalculatedField') ?
                text : (text + ' (' + filterMem + ')') : (this.parent.dataType === 'olap' ?
                text : (!this.parent.dataSourceSettings.showAggregationOnValueField || axis !== 'values' || aggregation === 'CalculatedField' ?
                text : this.parent.localeObj.getConstant(aggregation) + ' ' + this.parent.localeObj.getConstant('of') + ' ' + text))
        });
        return buttonText;
    }
    getTypeStatus(field, i, buttonElement) {
        let engineModule;
        if (this.parent.dataType === 'olap') {
            engineModule = this.parent.olapEngineModule;
        }
        else {
            engineModule = this.parent.engineModule;
        }
        let fieldListItem = engineModule.fieldList[field[i].name];
        if (fieldListItem.aggregateType !== 'CalculatedField') {
            this.createSummaryType(buttonElement, field[i].name);
        }
    }
    createSummaryType(pivotButton, fieldName) {
        let spanElement = createElement('span', {
            attrs: { 'tabindex': '-1', 'aria-disabled': 'false' },
            className: ICON + ' ' + AXISFIELD_ICON_CLASS
        });
        if (this.parent.getModuleName() === 'pivotview') {
            if (this.parent.groupingBarSettings.showValueTypeIcon) {
                removeClass([spanElement], ICON_DISABLE);
            }
            else {
                addClass([spanElement], ICON_DISABLE);
            }
        }
        pivotButton.appendChild(spanElement);
        return spanElement;
    }
    createMenuOption(args) {
        this.menuOption.render(args, this.parentElement);
        this.parent.pivotButtonModule = this;
    }
    createDraggable(target) {
        this.draggable = new Draggable(target, {
            clone: true,
            enableTailMode: true,
            enableAutoScroll: true,
            helper: this.createDragClone.bind(this),
            dragStart: this.onDragStart.bind(this),
            drag: this.onDragging.bind(this),
            dragStop: this.onDragStop.bind(this),
            abort: (this.parent.getModuleName() === 'pivotview' && !this.parent.groupingBarSettings.allowDragAndDrop ? '.' + PIVOT_BUTTON_CLASS : '')
        });
    }
    createButtonDragIcon(pivotButton) {
        let dragWrapper = createElement('span', {
            attrs: { 'tabindex': '-1', 'aria-disabled': 'false' }
        });
        let dragElement = createElement('span', {
            attrs: {
                'tabindex': '-1', 'aria-disabled': 'false'
            },
            className: ICON + ' ' + DRAG_CLASS
        });
        dragWrapper.appendChild(dragElement);
        pivotButton.appendChild(dragWrapper);
        return dragWrapper;
    }
    createSortOption(pivotButton, fieldName) {
        let sortCLass;
        let spanElement;
        let engineModule;
        if (this.parent.dataType === 'olap') {
            engineModule = this.parent.olapEngineModule;
        }
        else {
            engineModule = this.parent.engineModule;
        }
        if (!this.parent.allowDeferLayoutUpdate) {
            sortCLass = engineModule.fieldList[fieldName].sort === 'Descending' ? SORT_DESCEND_CLASS : '';
        }
        else {
            sortCLass = '';
            for (let i = 0; i < this.parent.dataSourceSettings.sortSettings.length; i++) {
                if (this.parent.dataSourceSettings.sortSettings[i].name === fieldName) {
                    sortCLass = this.parent.dataSourceSettings.sortSettings[i].order === 'Descending' ? SORT_DESCEND_CLASS : '';
                }
            }
        }
        if (engineModule.fieldList[fieldName].sort === 'None') {
            spanElement = createElement('span', {
                attrs: { 'tabindex': '-1', 'aria-disabled': 'false' },
                className: ICON
            });
        }
        else {
            spanElement = createElement('span', {
                attrs: { 'tabindex': '-1', 'aria-disabled': 'false' },
                className: ICON + ' ' + SORT_CLASS + ' ' + sortCLass
            });
        }
        if (this.parent.dataSourceSettings.enableSorting) {
            removeClass([spanElement], ICON_DISABLE);
        }
        else {
            addClass([spanElement], ICON_DISABLE);
        }
        if (this.parent.getModuleName() === 'pivotview') {
            if (this.parent.groupingBarSettings.showSortIcon) {
                removeClass([spanElement], ICON_DISABLE);
            }
            else {
                addClass([spanElement], ICON_DISABLE);
            }
        }
        pivotButton.appendChild(spanElement);
        return spanElement;
    }
    createFilterOption(pivotButton, fieldName, axis) {
        let filterCLass;
        let engineModule;
        if (this.parent.dataType === 'olap') {
            engineModule = this.parent.olapEngineModule;
        }
        else {
            engineModule = this.parent.engineModule;
        }
        if (!this.parent.allowDeferLayoutUpdate) {
            engineModule.fieldList[fieldName].filter = engineModule.fieldList[fieldName].filter === null ?
                [] : engineModule.fieldList[fieldName].filter;
            filterCLass = engineModule.fieldList[fieldName].filter.length === 0 ?
                !engineModule.fieldList[fieldName].isExcelFilter ? FILTER_CLASS : FILTERED_CLASS : FILTERED_CLASS;
        }
        else {
            filterCLass = FILTER_CLASS;
            for (let i = 0; i < this.parent.dataSourceSettings.filterSettings.length; i++) {
                if (this.parent.dataSourceSettings.filterSettings[i].name === fieldName) {
                    filterCLass = FILTERED_CLASS;
                }
            }
        }
        let spanElement = createElement('span', {
            attrs: {
                'tabindex': '-1', 'aria-disabled': 'false'
            },
            className: FILTER_COMMON_CLASS + ' ' + ICON + ' ' + filterCLass
        });
        if ((((this.parent.dataSourceSettings.allowLabelFilter || this.parent.dataSourceSettings.allowValueFilter) &&
            axis !== 'filters') || this.parent.dataSourceSettings.allowMemberFilter)) {
            removeClass([spanElement], ICON_DISABLE);
        }
        else {
            addClass([spanElement], ICON_DISABLE);
        }
        if (this.parent.getModuleName() === 'pivotview') {
            if (this.parent.groupingBarSettings.showFilterIcon &&
                (((this.parent.dataSourceSettings.allowLabelFilter || this.parent.dataSourceSettings.allowValueFilter) &&
                    axis !== 'filters') || this.parent.dataSourceSettings.allowMemberFilter)) {
                removeClass([spanElement], ICON_DISABLE);
            }
            else {
                addClass([spanElement], ICON_DISABLE);
            }
        }
        pivotButton.appendChild(spanElement);
        return spanElement;
    }
    // To update button text
    updateButtontext(fieldName) {
        let engineModule;
        if (this.parent.dataType === 'olap') {
            engineModule = this.parent.olapEngineModule;
        }
        else {
            engineModule = this.parent.engineModule;
        }
        let filterCount = engineModule.fieldList[fieldName].filter.length;
        let filterType = engineModule.fieldList[fieldName].filterType;
        let memLen = engineModule.fieldList[fieldName].dateMember.length;
        let filterMem;
        let firstNode = engineModule.fieldList[fieldName].filter[0];
        if (this.parent.dataType === 'olap') {
            filterMem = this.updateOlapButtonText(engineModule, fieldName, firstNode, filterCount);
        }
        else if (filterType === "include") {
            if (filterCount === 1) {
                filterMem = firstNode;
            }
            else if (filterCount > 1) {
                if (filterCount === memLen) {
                    filterMem = this.parent.localeObj.getConstant('all');
                }
                else {
                    filterMem = this.parent.localeObj.getConstant('multipleItems');
                }
            }
        }
        else if (filterType === "exclude") {
            if (filterCount === 1) {
                if (memLen === 2) {
                    if (firstNode !== engineModule.fieldList[fieldName].dateMember[0].actualText) {
                        filterMem = firstNode;
                    }
                    else {
                        filterMem = engineModule.fieldList[fieldName].dateMember[0].actualText;
                    }
                }
                else {
                    filterMem = this.parent.localeObj.getConstant('multipleItems');
                }
            }
            else if (filterCount > 1) {
                let j;
                let allNodes = Object.keys(engineModule.fieldList[fieldName].members);
                let filteredItems = engineModule.fieldList[fieldName].filter;
                if (filterCount === (allNodes.length - 1)) {
                    loop: for (j = 0; j < allNodes.length; j++) {
                        let test = allNodes[j];
                        let x = filteredItems.indexOf(test);
                        if (x === -1) {
                            filterMem = allNodes[j];
                            break loop;
                        }
                    }
                }
                else {
                    filterMem = this.parent.localeObj.getConstant('multipleItems');
                }
            }
        }
        else {
            filterMem = this.parent.localeObj.getConstant('all');
        }
        return filterMem;
    }
    updateOlapButtonText(engineModule, fieldName, firstNode, filterCount) {
        let filterMem;
        let filterItems = engineModule.fieldList[fieldName].actualFilter;
        if (filterItems.length > 0) {
            let cMembers = engineModule.fieldList[fieldName].members;
            let actualFilterItems = [];
            if (engineModule.fieldList[fieldName].filterMembers.length > 0) {
                let dummyfilterItems = {};
                for (let item of filterItems) {
                    dummyfilterItems[item] = item;
                    if (cMembers[item]) {
                        dummyfilterItems = this.parent.pivotCommon.eventBase.getParentNode(fieldName, item, dummyfilterItems);
                    }
                }
                let updatedFilterItems = dummyfilterItems ? Object.keys(dummyfilterItems) : [];
                for (let item of updatedFilterItems) {
                    if (cMembers[item].isSelected) {
                        if (!(cMembers[item].parent && cMembers[cMembers[item].parent].isSelected)) {
                            actualFilterItems.push(item);
                        }
                    }
                }
                firstNode = actualFilterItems.length === 1 ? cMembers[actualFilterItems[0]].caption : firstNode;
            }
            filterCount = actualFilterItems.length === 0 ? filterCount : actualFilterItems.length;
        }
        if (filterCount === 0) {
            filterMem = (engineModule.fieldList[fieldName].allMember ?
                engineModule.fieldList[fieldName].allMember : this.parent.localeObj.getConstant('all'));
        }
        else if (filterCount === 1) {
            filterMem = firstNode;
        }
        else if (filterCount > 1) {
            filterMem = this.parent.localeObj.getConstant('multipleItems');
        }
        return filterMem;
    }
    createDragClone(args) {
        let element = closest(args.element, '.' + PIVOT_BUTTON_CLASS);
        let cloneElement = createElement('div', {
            id: this.parent.element.id + '_DragClone',
            className: DRAG_CLONE_CLASS
        });
        let contentElement = createElement('span', {
            className: TEXT_CONTENT_CLASS,
            innerHTML: element.textContent
        });
        cloneElement.appendChild(contentElement);
        document.body.appendChild(cloneElement);
        return cloneElement;
    }
    onDragStart(e) {
        this.parent.isDragging = true;
        let engineModule;
        if (this.parent.dataType === 'olap') {
            engineModule = this.parent.olapEngineModule;
        }
        else {
            engineModule = this.parent.engineModule;
        }
        let element = closest(e.element, '.' + PIVOT_BUTTON_CLASS);
        let data = engineModule.fieldList[element.getAttribute('data-uid')];
        let axis = [ROW_AXIS_CLASS, COLUMN_AXIS_CLASS, FILTER_AXIS_CLASS];
        let dragItem = document.getElementById(this.parent.element.id + '_DragClone');
        addClass([element], SELECTED_NODE_CLASS);
        if (dragItem && (this.parent.getModuleName() === 'pivotfieldlist' &&
            this.parent.renderMode) === 'Popup') {
            let fieldListPopup = this.parent;
            dragItem.style.zIndex = (fieldListPopup.dialogRenderer.fieldListDialog.zIndex + 1).toString();
        }
        if (data && data.aggregateType === 'CalculatedField') {
            for (let axisContent of axis) {
                addClass([this.parentElement.querySelector('.' + axisContent)], NO_DRAG_CLASS);
            }
        }
        if (isBlazor()) {
            e.bindEvents(e.dragElement);
        }
    }
    onDragging(e) {
        this.draggable.setProperties({ cursorAt: { top: (!isNullOrUndefined(e.event.targetTouches) || Browser.isDevice) ? 60 : -20, } });
        // if (closest(e.event.srcElement, '.' + cls.PIVOT_BUTTON_WRAPPER_CLASS)) {
        //     let droppableElement: HTMLElement = closest(e.event.srcElement, '.' + cls.DROPPABLE_CLASS) as HTMLElement;
        //     let buttonElement: HTMLElement = closest(e.event.srcElement, '.' + cls.PIVOT_BUTTON_WRAPPER_CLASS) as HTMLElement;
        //     if (droppableElement.offsetHeight < droppableElement.scrollHeight) {
        //         let scrollPosition: number = (droppableElement.scrollHeight - buttonElement.offsetTop);
        //         if (buttonElement.offsetTop >= droppableElement.offsetTop && scrollPosition > droppableElement.scrollTop) {
        //             droppableElement.scrollTop += Math.abs(buttonElement.offsetHeight);
        //         } else if (buttonElement.offsetTop <= droppableElement.offsetTop) {
        //             droppableElement.scrollTop -= Math.abs(buttonElement.offsetHeight);
        //         }
        //     }
        // }
    }
    onDragStop(args) {
        this.parent.isDragging = false;
        if (args.target.classList && (args.target.classList.contains(GROUP_CHART_VALUE) || args.target.classList.contains(GROUP_CHART_VALUE_DROPDOWN))) {
            args.target = this.parent.element.querySelector('.' + GROUP_CHART_ROW);
        }
        let element = closest(args.element, '.' + PIVOT_BUTTON_CLASS);
        removeClass([].slice.call(this.parentElement.querySelectorAll('.' + PIVOT_BUTTON_CLASS)), SELECTED_NODE_CLASS);
        removeClass([].slice.call(this.parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS)), INDICATOR_HOVER_CLASS);
        let axis = [ROW_AXIS_CLASS, COLUMN_AXIS_CLASS, FILTER_AXIS_CLASS];
        for (let axisContent of axis) {
            removeClass([this.parentElement.querySelector('.' + axisContent)], NO_DRAG_CLASS);
        }
        if (this.parent.pivotCommon.filterDialog.dialogPopUp) {
            this.parent.pivotCommon.filterDialog.dialogPopUp.close();
        }
        if (document.getElementById(this.parent.element.id + '_DragClone')) {
            remove(document.getElementById(this.parent.element.id + '_DragClone'));
        }
        document.body.style.cursor = 'auto';
        if (!this.isButtonDropped(args.target, element)) {
            return;
        }
        this.parent.pivotCommon.dataSourceUpdate.control = this.parent.getModuleName() === 'pivotview' ? this.parent :
            (this.parent.pivotGridModule ? this.parent.pivotGridModule : this.parent);
        if (this.parent.pivotCommon.nodeStateModified.onStateModified(args, element.id)) {
            this.updateDataSource();
            let thisObj = this;
            //setTimeout(() => {
            thisObj.parent.axisFieldModule.render();
            //});
        }
    }
    isButtonDropped(dropTarget, target) {
        let axisPanel = closest(target, '.' + DROPPABLE_CLASS);
        let droppableElement = closest(dropTarget, '.' + DROPPABLE_CLASS);
        let isDropped = true;
        if (axisPanel === droppableElement) {
            let pivotButtons = [].slice.call(axisPanel.querySelectorAll('.' + PIVOT_BUTTON_CLASS));
            let droppableTarget = closest(dropTarget, '.' + PIVOT_BUTTON_WRAPPER_CLASS);
            let sourcePosition;
            let droppedPosition = -1;
            for (let i = 0, n = pivotButtons.length; i < n; i++) {
                if (pivotButtons[i].id === target.id) {
                    sourcePosition = i;
                }
                if (droppableTarget) {
                    let droppableButton = droppableTarget.querySelector('.' + PIVOT_BUTTON_CLASS);
                    if (pivotButtons[i].id === droppableButton.id) {
                        droppedPosition = i;
                    }
                }
            }
            if (sourcePosition === droppedPosition || (sourcePosition === (pivotButtons.length - 1) && droppedPosition === -1)) {
                removeClass([].slice.call(this.parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS)), INDICATOR_HOVER_CLASS);
                isDropped = false;
            }
        }
        return isDropped;
    }
    updateSorting(args) {
        if (!(args.target.classList.contains(FILTER_COMMON_CLASS)) &&
            !(args.target.classList.contains(REMOVE_CLASS))) {
            if ((this.parent instanceof PivotFieldList || this.parent.groupingBarSettings.showSortIcon) &&
                this.parent.dataSourceSettings.enableSorting &&
                !(this.parent.dataType === 'olap' && ((this.parent.getModuleName() === 'pivotfieldlist' &&
                    this.parent.pivotGridModule !== undefined &&
                    this.parent.pivotGridModule.enableVirtualization) ||
                    (this.parent.getModuleName() === 'pivotview' && this.parent.enableVirtualization)))) {
                if (((this.parent.getModuleName() === 'pivotview' && this.parent.enableValueSorting) ||
                    (this.parent.getModuleName() === 'pivotfieldlist' && this.parent.pivotGridModule !== undefined &&
                        this.parent.pivotGridModule.enableValueSorting))) {
                    if (this.parent.enableValueSorting || this.parent.pivotGridModule.enableValueSorting) {
                        if (args.target.classList.contains('e-pivot-button')) {
                            if (args.target.parentElement.getAttribute('data-tag').split(':')[0] === 'rows') {
                                this.parent.setProperties({ dataSourceSettings: { valueSortSettings: { headerText: '' } } }, true);
                            }
                        }
                        else {
                            if (args.target.parentElement.parentElement.getAttribute('data-tag').split(':')[0] === 'rows') {
                                this.parent.setProperties({ dataSourceSettings: { valueSortSettings: { headerText: '' } } }, true);
                            }
                        }
                    }
                }
                this.parent.pivotCommon.eventBase.updateSorting(args);
                if (!this.parent.allowDeferLayoutUpdate || this.parent.getModuleName() != "pivotfieldlist") {
                    this.updateDataSource(true);
                }
                let thisObj = this;
                //setTimeout(() => {
                if (thisObj.parent instanceof PivotFieldList) {
                    thisObj.axisField.render();
                }
                //});
            }
        }
    }
    /** @hidden */
    updateDataSource(isRefreshGrid) {
        if (!this.parent.allowDeferLayoutUpdate || this.parent.getModuleName() === 'pivotview') {
            this.parent.updateDataSource(isRefreshGrid);
        }
        else {
            if (this.parent.getModuleName() === 'pivotfieldlist' && this.parent.renderMode === 'Popup') {
                if (this.parent.dataType === 'olap') {
                    this.parent.pivotGridModule.olapEngineModule = this.parent.olapEngineModule;
                }
                else {
                    this.parent.pivotGridModule.engineModule = this.parent.engineModule;
                }
                this.parent.pivotGridModule.notify(uiUpdate, this);
                this.parent.
                    pivotGridModule.setProperties({ dataSourceSettings: this.parent.dataSourceSettings.properties }, true);
            }
            else {
                this.parent.triggerPopulateEvent();
            }
        }
    }
    updateFiltering(args) {
        let pivotObj = this.parent.pivotGridModule ? this.parent.pivotGridModule : this.parent;
        if (pivotObj && pivotObj.enableVirtualization && isBlazor() && pivotObj.dataType == 'pivot') {
            let fieldName = args.target.parentElement.id;
            let _this = this;
            pivotObj.interopAdaptor.invokeMethodAsync("PivotInteropMethod", 'fetchFieldMembers', fieldName).then(function (data) {
                let parsedData = JSON.parse(data.dateMembers);
                let dateMembers = [];
                let formattedMembers = {};
                let members = {};
                for (var i = 0; i < parsedData.length; i++) {
                    dateMembers.push({ formattedText: parsedData[i].FormattedText, actualText: parsedData[i].ActualText });
                    formattedMembers[parsedData[i].FormattedText] = {};
                    members[parsedData[i].ActualText] = {};
                }
                _this.parent.engineModule.fieldList[fieldName].dateMember = dateMembers;
                _this.parent.engineModule.fieldList[fieldName].formattedMembers = formattedMembers;
                _this.parent.engineModule.fieldList[fieldName].members = members;
                _this.updateFilterEvents(args);
            });
        }
        else {
            this.updateFilterEvents(args);
        }
    }
    updateFilterEvents(args) {
        this.parent.pivotCommon.eventBase.updateFiltering(args);
        let target = args.target;
        this.fieldName = target.parentElement.id;
        this.dialogPopUp = this.parent.pivotCommon.filterDialog.dialogPopUp;
        this.memberTreeView = this.parent.pivotCommon.filterDialog.memberTreeView;
        this.parent.pivotCommon.filterDialog.memberTreeView.nodeChecked = this.nodeStateModified.bind(this);
        this.parent.pivotCommon.filterDialog.allMemberSelect.nodeChecked = this.nodeStateModified.bind(this);
        this.bindDialogEvents();
    }
    bindDialogEvents() {
        if (this.parent.pivotCommon.filterDialog.allowExcelLikeFilter && this.parent.pivotCommon.filterDialog.tabObj) {
            this.index = this.parent.pivotCommon.filterDialog.tabObj.selectedItem;
            this.updateDialogButtonEvents();
            this.dialogPopUp.buttons = this.buttonModel();
            this.dialogPopUp.dataBind();
            this.parent.pivotCommon.filterDialog.tabObj.selected = this.tabSelect.bind(this);
        }
        else if (this.parent.dataSourceSettings.allowMemberFilter) {
            this.index = 0;
            this.updateDialogButtonEvents();
        }
    }
    buttonModel() {
        return [
            {
                buttonModel: {
                    cssClass: OK_BUTTON_CLASS, content: this.parent.localeObj.getConstant('ok'), isPrimary: true
                },
                click: (this.index === 0 ? this.updateFilterState.bind(this, this.fieldName) : this.updateCustomFilter.bind(this))
            },
            {
                buttonModel: {
                    cssClass: 'e-clear-filter-button' + (this.parent.pivotCommon.filterDialog.allowExcelLikeFilter ? '' : ' ' + ICON_DISABLE),
                    iconCss: 'e-icons e-clear-filter-icon', enableRtl: this.parent.enableRtl,
                    content: this.parent.localeObj.getConstant('clearFilter'), disabled: (this.parent.pivotCommon.filterDialog.filterObject ? false : true)
                },
                click: this.ClearFilter.bind(this)
            },
            {
                click: this.parent.pivotCommon.filterDialog.closeFilterDialog.bind(this),
                buttonModel: { cssClass: CANCEL_BUTTON_CLASS, content: this.parent.localeObj.getConstant('cancel') }
            }
        ];
    }
    tabSelect(e) {
        this.index = e.selectedIndex;
        this.updateDialogButtonEvents();
        removeClass([].slice.call(this.dialogPopUp.element.querySelectorAll('.e-selected-tab')), 'e-selected-tab');
        if (e.selectedIndex > 0) {
            /* tslint:disable-next-line:max-line-length */
            addClass([this.dialogPopUp.element.querySelector('.e-filter-div-content' + '.' + (e.selectedIndex === 1 && this.parent.dataSourceSettings.allowLabelFilter ? 'e-label-filter' : 'e-value-filter'))], 'e-selected-tab');
        }
        if (e.selectedIndex === 0) {
            this.parent.pivotCommon.filterDialog.updateCheckedState();
        }
        else {
            this.dialogPopUp.buttons[0].buttonModel.disabled = false;
            this.dialogPopUp.element.querySelector('.' + OK_BUTTON_CLASS).removeAttribute('disabled');
        }
    }
    updateDialogButtonEvents() {
        this.dialogPopUp.buttons = this.buttonModel();
        this.dialogPopUp.dataBind();
    }
    updateCustomFilter(args) {
        let dialogElement = this.dialogPopUp.element.querySelector('.e-selected-tab');
        let fieldName = dialogElement.getAttribute('data-fieldname');
        let levelName = dialogElement.getAttribute('data-selectedField');
        let filterType = dialogElement.getAttribute('data-type');
        let measure = dialogElement.getAttribute('data-measure');
        let operator = dialogElement.getAttribute('data-operator');
        let operand1 = dialogElement.getAttribute('data-value1');
        let operand2 = dialogElement.getAttribute('data-value2');
        let type = ((filterType === 'value') ? 'Value' : (filterType === 'date') ? 'Date' :
            (filterType === 'number') ? 'Number' : 'Label');
        let filterItem = {
            name: fieldName,
            type: type,
            measure: measure,
            condition: operator,
            value1: filterType === 'date' ? new Date(operand1) : operand1,
            value2: filterType === 'date' ? new Date(operand2) : operand2
        };
        let filterObject;
        if (this.parent.dataType === 'olap') {
            filterItem.selectedField = levelName;
            this.removeDataSourceSettings(fieldName, levelName, type);
            let filterItems = this.parent.dataSourceSettings.filterSettings;
            for (let item of filterItems) {
                if (item.name === fieldName && item.selectedField === levelName) {
                    filterObject = item;
                }
            }
        }
        else {
            filterObject = PivotUtil.getFilterItemByName(fieldName, this.parent.dataSourceSettings.filterSettings);
        }
        if ((isNullOrUndefined(operand1) || operand1 === '') ||
            (['Between', 'NotBetween'].indexOf(operator) > -1 && (isNullOrUndefined(operand2) || operand2 === ''))) {
            let inputElementString = (type.toLowerCase() + ((isNullOrUndefined(operand1) || operand1 === '') ? '_input_option_1' : '_input_option_2'));
            let focusElement = dialogElement.querySelector('#' + this.parent.element.id + '_' + inputElementString);
            addClass([focusElement], EMPTY_FIELD);
            focusElement.focus();
            return;
        }
        let filter = {
            cancel: false,
            filterSettings: filterItem,
            dataSourceSettings: this.parent.dataSourceSettings
        };
        this.parent.pivotGridModule ?
            this.parent.pivotGridModule.trigger(memberFiltering, filter) :
            this.parent.trigger(memberFiltering, filter);
        if (!filter.cancel) {
            if (filterObject) {
                // this.removeDataSourceSettings(fieldName);
                filterObject = filterObject.properties ?
                    filterObject.properties : filterObject;
                filterObject.type = type;
                filterObject.measure = measure;
                filterObject.condition = operator;
                filterObject.value1 = filterType === 'date' ? new Date(operand1) : operand1;
                filterObject.value2 = filterType === 'date' ? new Date(operand2) : operand2;
                if (this.parent.dataType === 'olap') {
                    filterObject.selectedField = levelName;
                }
            }
            else {
                this.parent.dataSourceSettings.filterSettings.push(filterItem);
            }
        }
        if (type !== 'Value') {
            this.parent.lastFilterInfo = PivotUtil.getFilterItemByName(fieldName, this.parent.dataSourceSettings.filterSettings);
        }
        this.dialogPopUp.close();
        if (!filter.cancel) {
            this.refreshPivotButtonState(fieldName, true);
            this.updateDataSource(true);
        }
    }
    ClearFilter(e) {
        let dialogElement = this.dialogPopUp.element;
        let fieldName = dialogElement.getAttribute('data-fieldname');
        let tabElement = dialogElement.querySelector('.e-selected-tab');
        this.dialogPopUp.close();
        if (this.parent.dataType === 'olap' && tabElement) {
            let levelName = tabElement.getAttribute('data-selectedField');
            this.removeDataSourceSettings(fieldName, levelName);
        }
        else {
            this.removeDataSourceSettings(fieldName);
        }
        let filterObject = PivotUtil.getFilterItemByName(fieldName, this.parent.dataSourceSettings.filterSettings);
        this.refreshPivotButtonState(fieldName, filterObject ? true : false);
        this.updateDataSource(true);
    }
    removeButton(args) {
        let target = args.target;
        let fieldName = target.parentElement.id;
        if (target.parentElement.getAttribute('isvalue') === 'true') {
            this.parent.setProperties({ dataSourceSettings: { values: [] } }, true);
            if (this.parent.dataType === 'olap') {
                this.parent.pivotCommon.dataSourceUpdate.removeFieldFromReport('[measures]');
            }
        }
        else {
            this.parent.pivotCommon.dataSourceUpdate.removeFieldFromReport(fieldName);
            if (this.parent.dataType === 'olap' && this.parent.dataSourceSettings.values.length === 0) {
                this.parent.pivotCommon.dataSourceUpdate.removeFieldFromReport('[measures]');
            }
        }
        if (this.parent.getModuleName() === 'pivotfieldlist') {
            this.parent.axisFieldModule.render();
        }
        this.updateDataSource();
    }
    nodeStateModified(args) {
        let target = closest(args.node, 'li');
        let fieldName = target.getAttribute('data-fieldname');
        if (target.getAttribute('data-uid') === 'all') {
            this.memberTreeView.nodeChecked = null;
            if (args.action === 'check') {
                this.memberTreeView.checkAll();
            }
            else {
                this.memberTreeView.uncheckAll();
            }
            if (this.parent.dataType === 'olap' && this.parent.olapEngineModule &&
                !this.parent.olapEngineModule.fieldList[fieldName].isHierarchy) {
                this.updateNodeStates(this.memberTreeView.getAllCheckedNodes(), fieldName, args.action);
            }
            this.checkedStateAll(args.action);
            this.memberTreeView.nodeChecked = this.nodeStateModified.bind(this);
        }
        else {
            if (this.parent.dataType === 'olap' && this.parent.olapEngineModule &&
                !this.parent.olapEngineModule.fieldList[fieldName].isHierarchy) {
                // let st1: number = new Date().getTime();
                let checkedNodes = this.memberTreeView.getAllCheckedNodes();
                // let st2: number = (new Date().getTime() - st1) / 1000;
                // console.log('getAllCheckedNodes:' + st2);
                this.updateNodeStates(checkedNodes, fieldName, args.action);
            }
            let pos = this.parent.pivotCommon.currentTreeItemsPos[target.getAttribute('data-uid')];
            if (args.action === 'check') {
                if (this.parent.pivotCommon.currentTreeItems[pos]) {
                    this.parent.pivotCommon.currentTreeItems[pos].isSelected = true;
                }
            }
            else {
                if (this.parent.pivotCommon.currentTreeItems[pos]) {
                    this.parent.pivotCommon.currentTreeItems[pos].isSelected = false;
                }
            }
        }
        this.parent.pivotCommon.filterDialog.updateCheckedState();
    }
    checkedStateAll(state) {
        let searchItemObj = {};
        for (let item of this.parent.pivotCommon.searchTreeItems) {
            item.isSelected = state === 'check';
            searchItemObj[item.id] = item.id;
        }
        for (let item of this.parent.pivotCommon.currentTreeItems) {
            if (searchItemObj[item.id] !== undefined) {
                item.isSelected = state === 'check';
            }
        }
    }
    updateNodeStates(checkedNodes, fieldName, state) {
        let fieldList = this.parent.pivotCommon.engineModule.fieldList[fieldName];
        let currentMembers = fieldList.members;
        let searchMembers = fieldList.currrentMembers;
        if (fieldList.searchMembers.length > 0) {
            let members = Object.keys(searchMembers);
            for (let member of members) {
                if (searchMembers[member]) {
                    searchMembers[member].isSelected = false;
                }
                if (currentMembers[member]) {
                    currentMembers[member].isSelected = false;
                    if (this.memberTreeView.element.querySelector('li[data-uid="' + member + '"]')) {
                        let element = this.memberTreeView.element.querySelector('li[data-uid="' + member + '"]');
                        if (element && !element.querySelector('ul')) {
                            this.parent.pivotCommon.eventBase.updateChildNodeStates(fieldList.filterMembers, fieldName, member, false);
                        }
                    }
                }
            }
            for (let node of checkedNodes) {
                if (currentMembers[node]) {
                    if (this.memberTreeView.element.querySelector('li[data-uid="' + node + '"]')) {
                        let element = this.memberTreeView.element.querySelector('li[data-uid="' + node + '"]');
                        if (element && !element.querySelector('ul')) {
                            currentMembers[node].isSelected = true;
                            this.parent.pivotCommon.eventBase.updateChildNodeStates(fieldList.filterMembers, fieldName, node, true);
                        }
                    }
                }
                if (searchMembers[node]) {
                    searchMembers[node].isSelected = true;
                }
            }
        }
        else {
            let members = Object.keys(currentMembers);
            for (let member of members) {
                if (currentMembers[member].isSelected) {
                    currentMembers[member].isSelected = false;
                }
            }
            for (let node of checkedNodes) {
                if (currentMembers[node]) {
                    currentMembers[node].isSelected = true;
                    this.parent.pivotCommon.eventBase.updateChildNodeStates(fieldList.filterMembers, fieldName, node, true);
                }
            }
        }
    }
    updateFilterState(fieldName, args) {
        let isNodeUnChecked = false;
        let filterItem = { items: [], name: fieldName, type: 'Include' };
        let engineModule = this.parent.olapEngineModule;
        if (this.parent.dataType === 'olap' && engineModule &&
            !engineModule.fieldList[fieldName].isHierarchy) {
            let cMembers = engineModule.fieldList[fieldName].members;
            let sMembers = engineModule.fieldList[fieldName].currrentMembers;
            filterItem.items = this.memberTreeView.getAllCheckedNodes();
            filterItem.levelCount = engineModule.fieldList[fieldName].levelCount;
            isNodeUnChecked = (filterItem.items.length ===
                this.memberTreeView.fields.dataSource.length ? false : true);
            if (engineModule.fieldList[fieldName].searchMembers.length > 0 && !isNodeUnChecked) {
                let cNodeLength = Object.keys(cMembers).length;
                let sNodeLength = Object.keys(sMembers).length;
                isNodeUnChecked = cNodeLength === sNodeLength && cNodeLength === filterItem.items.length ? false : true;
            }
            let filterItems = filterItem.items;
            for (let node of filterItems) {
                if (engineModule.fieldList[fieldName].searchMembers.length > 0 && sMembers[node]) {
                    sMembers[node].isSelected = true;
                }
                else if (cMembers[node]) {
                    cMembers[node].isSelected = true;
                }
            }
        }
        else {
            for (let item of this.parent.pivotCommon.searchTreeItems) {
                if (item.isSelected) {
                    if (this.parent.pivotCommon.isDateField) {
                        filterItem.items.push(item.name);
                    }
                    else {
                        filterItem.items.push(item.id);
                    }
                }
            }
            isNodeUnChecked = (filterItem.items.length === this.parent.pivotCommon.currentTreeItems.length ?
                false : true);
        }
        if (this.parent.dataType === 'olap') {
            this.removeDataSourceSettings(fieldName);
        }
        let filter = {
            filterSettings: filterItem,
            dataSourceSettings: this.parent.dataSourceSettings,
            cancel: false
        };
        this.parent.pivotGridModule ?
            this.parent.pivotGridModule.trigger(memberFiltering, filter) :
            this.parent.trigger(memberFiltering, filter);
        if (!filter.cancel) {
            let filterObject = PivotUtil.getFilterItemByName(fieldName, this.parent.dataSourceSettings.filterSettings);
            if (filterObject) {
                for (let i = 0; i < this.parent.dataSourceSettings.filterSettings.length; i++) {
                    if (this.parent.dataSourceSettings.filterSettings[i].name === fieldName) {
                        this.parent.dataSourceSettings.filterSettings.splice(i, 1);
                        break;
                    }
                }
                this.parent.dataSourceSettings.filterSettings.push(filterItem);
            }
            else if (!filter.cancel) {
                this.parent.dataSourceSettings.filterSettings.push(filterItem);
            }
        }
        this.dialogPopUp.close();
        if (!filter.cancel) {
            this.refreshPivotButtonState(fieldName, isNodeUnChecked);
            if (!isNodeUnChecked) {
                this.removeDataSourceSettings(fieldName);
            }
            this.parent.lastFilterInfo = filterItem;
            this.updateDataSource(true);
            let thisObj = this;
            //setTimeout(() => {
            if (thisObj.parent instanceof PivotFieldList) {
                thisObj.axisField.render();
            }
        }
        //});
    }
    refreshPivotButtonState(fieldName, isFiltered) {
        let pivotButtons = [].slice.call(this.parentElement.querySelectorAll('.e-pivot-button'));
        let selectedButton;
        for (let item of pivotButtons) {
            if (item.getAttribute('data-uid') === fieldName) {
                selectedButton = item.querySelector('.' + FILTER_COMMON_CLASS);
                break;
            }
        }
        if (isFiltered) {
            removeClass([selectedButton], FILTER_CLASS);
            addClass([selectedButton], FILTERED_CLASS);
        }
        else {
            removeClass([selectedButton], FILTERED_CLASS);
            addClass([selectedButton], FILTER_CLASS);
        }
    }
    removeDataSourceSettings(fieldName, selectedField, type) {
        let filterSettings = this.parent.dataSourceSettings.filterSettings;
        for (let len = 0, lnt = filterSettings.length; len < lnt; len++) {
            if (this.parent.dataType === 'olap' && selectedField) {
                if (!type && filterSettings[len].name === fieldName &&
                    filterSettings[len].selectedField === selectedField) {
                    filterSettings.splice(len, 1);
                    break;
                }
                else if (type) {
                    if (filterSettings[len].type !== type &&
                        filterSettings[len].name === fieldName) {
                        filterSettings.splice(len, 1);
                        lnt--;
                        len--;
                    }
                }
            }
            else {
                if (filterSettings[len].name === fieldName) {
                    filterSettings.splice(len, 1);
                    if (this.parent.dataType !== 'olap') {
                        break;
                    }
                    lnt--;
                    len--;
                }
            }
        }
    }
    updateDropIndicator(e) {
        if (this.parent.isDragging) {
            removeClass([].slice.call(this.parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS + '-last')), INDICATOR_HOVER_CLASS);
            removeClass([].slice.call(this.parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS)), INDICATOR_HOVER_CLASS);
            let element = closest(e.target, '.' + PIVOT_BUTTON_WRAPPER_CLASS);
            addClass([element.querySelector('.' + DROP_INDICATOR_CLASS)], INDICATOR_HOVER_CLASS);
        }
    }
    wireEvent(element, axis, isMeasureAvail) {
        EventHandler.add(element, 'mouseover', this.updateDropIndicator, this);
        if (!isMeasureAvail) {
            if (['filters', 'values'].indexOf(axis) === -1 && element.querySelector('.' + PIVOT_BUTTON_CLASS) !== null) {
                EventHandler.add(element.querySelector('.' + PIVOT_BUTTON_CLASS), 'click', this.updateSorting, this);
            }
            if (axis !== 'values' && element.querySelector('.' + FILTER_COMMON_CLASS) !== null) {
                EventHandler.add(element.querySelector('.' + FILTER_COMMON_CLASS), 'click', this.updateFiltering, this);
            }
            if (axis === 'values' && element.querySelector('.' + AXISFIELD_ICON_CLASS) !== null) {
                EventHandler.add(element.querySelector('.' + AXISFIELD_ICON_CLASS), 'click', this.createMenuOption, this);
            }
        }
        EventHandler.add(element.querySelector('.' + REMOVE_CLASS), 'click', this.removeButton, this);
    }
    unWireEvent(element, axis, isMeasureAvail) {
        EventHandler.remove(element, 'mouseover', this.updateDropIndicator);
        if (!isMeasureAvail) {
            if (['filters', 'values'].indexOf(axis) === -1 && element.querySelector('.' + PIVOT_BUTTON_CLASS) !== null) {
                EventHandler.remove(element.querySelector('.' + PIVOT_BUTTON_CLASS), 'click', this.updateSorting);
            }
            if (axis !== 'values' && element.querySelector('.' + FILTER_COMMON_CLASS) !== null) {
                EventHandler.remove(element.querySelector('.' + FILTER_COMMON_CLASS), 'click', this.updateFiltering);
            }
            if (axis === 'values' && element.querySelector('.' + AXISFIELD_ICON_CLASS) !== null) {
                EventHandler.remove(element.querySelector('.' + AXISFIELD_ICON_CLASS), 'click', this.createMenuOption);
            }
        }
        EventHandler.remove(element.querySelector('.' + REMOVE_CLASS), 'click', this.removeButton);
    }
    /**
     * @hidden
     */
    addEventListener() {
        this.handlers = {
            load: this.renderPivotButton
        };
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(pivotButtonUpdate, this.handlers.load, this);
    }
    /**
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(pivotButtonUpdate, this.handlers.load);
    }
    /**
     * To destroy the pivot button event listener
     * @return {void}
     * @hidden
     */
    destroy() {
        this.menuOption.destroy();
        this.removeEventListener();
    }
}

/**
 * Module to render Axis Fields
 */
/** @hidden */
class AxisFieldRenderer {
    /** Constructor for render module */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Initialize the pivot button rendering
     * @returns void
     * @private
     */
    render() {
        this.pivotButton = new PivotButton(this.parent);
        this.createPivotButtons();
    }
    createPivotButtons() {
        let rows = this.parent.dataSourceSettings.rows;
        let columns = this.parent.dataSourceSettings.columns;
        let values = this.parent.dataSourceSettings.values;
        let filters = this.parent.dataSourceSettings.filters;
        let fields = [rows, columns, values, filters];
        let parentElement = this.parent.dialogRenderer.parentElement;
        if (parentElement.querySelector('.' + FIELD_LIST_CLASS + '-filters')) {
            parentElement.querySelector('.' + FIELD_LIST_CLASS + '-filters').querySelector('.' + AXIS_CONTENT_CLASS).innerHTML = '';
        }
        if (parentElement.querySelector('.' + FIELD_LIST_CLASS + '-rows')) {
            parentElement.querySelector('.' + FIELD_LIST_CLASS + '-rows').querySelector('.' + AXIS_CONTENT_CLASS).innerHTML = '';
        }
        if (parentElement.querySelector('.' + FIELD_LIST_CLASS + '-columns')) {
            parentElement.querySelector('.' + FIELD_LIST_CLASS + '-columns').querySelector('.' + AXIS_CONTENT_CLASS).innerHTML = '';
        }
        if (parentElement.querySelector('.' + FIELD_LIST_CLASS + '-values')) {
            parentElement.querySelector('.' + FIELD_LIST_CLASS + '-values').querySelector('.' + AXIS_CONTENT_CLASS).innerHTML = '';
        }
        let axis = ['rows', 'columns', 'values', 'filters'];
        for (let len = 0, lnt = fields.length; len < lnt; len++) {
            if (fields[len]) {
                let args = {
                    field: fields[len],
                    axis: axis[len].toString()
                };
                this.parent.notify(pivotButtonUpdate, args);
            }
        }
    }
}

/**
 * Module to render Pivot Table component
 */
/** @hidden */
class Render$1 {
    /** Constructor for render module */
    constructor(parent) {
        this.parent = parent;
        this.parent.dialogRenderer = new DialogRenderer(this.parent);
        this.parent.treeViewModule = new TreeViewRenderer(this.parent);
        this.parent.axisTableModule = new AxisTableRenderer(this.parent);
        this.parent.axisFieldModule = new AxisFieldRenderer(this.parent);
    }
    /**
     * Initialize the pivot table rendering
     * @returns void
     * @private
     */
    render() {
        this.parent.dialogRenderer.render();
        if (!this.parent.isAdaptive) {
            this.parent.treeViewModule.render();
        }
        this.parent.axisTableModule.render();
    }
}

var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Represents the PivotFieldList component.
 * ```html
 * <div id="pivotfieldlist"></div>
 * <script>
 *  var pivotfieldlistObj = new PivotFieldList({ });
 *  pivotfieldlistObj.appendTo("#pivotfieldlist");
 * </script>
 * ```
 */
let PivotFieldList = class PivotFieldList extends Component {
    /**
     * Constructor for creating the widget
     * @param  {PivotFieldListModel} options?
     * @param  {string|HTMLButtonElement} element?
     */
    constructor(options, element) {
        super(options, element);
        this.isRequiredUpdate = true;
        /** @hidden */
        this.lastSortInfo = {};
        /** @hidden */
        this.lastFilterInfo = {};
        /** @hidden */
        this.lastAggregationInfo = {};
        /** @hidden */
        this.lastCalcFieldInfo = {};
    }
    /**
     * To provide the array of modules needed for control rendering
     * @return {ModuleDeclaration[]}
     * @hidden
     */
    requiredModules() {
        let modules = [];
        if (this.allowCalculatedField) {
            modules.push({ args: [this], member: 'calculatedfield' });
        }
        return modules;
    }
    /**
     * For internal use only - Initialize the event handler;
     * @private
     */
    preRender() {
        if (this.dataSourceSettings && this.dataSourceSettings.providerType === 'SSAS') {
            this.olapEngineModule = new OlapEngine();
            this.dataType = 'olap';
        }
        else {
            this.engineModule = new PivotEngine();
            this.dataType = 'pivot';
        }
        this.isAdaptive = Browser.isDevice;
        this.globalize = new Internationalization(this.locale);
        this.renderModule = new Render$1(this);
        this.defaultLocale = {
            staticFieldList: 'Pivot Field List',
            fieldList: 'Field List',
            dropFilterPrompt: 'Drop filter here',
            dropColPrompt: 'Drop column here',
            dropRowPrompt: 'Drop row here',
            dropValPrompt: 'Drop value here',
            addPrompt: 'Add field here',
            adaptiveFieldHeader: 'Choose field',
            centerHeader: 'Drag fields between axes below:',
            add: 'add',
            drag: 'Drag',
            filter: 'Filter',
            filtered: 'Filtered',
            sort: 'Sort',
            remove: 'Remove',
            filters: 'Filters',
            rows: 'Rows',
            columns: 'Columns',
            values: 'Values',
            CalculatedField: 'Calculated Field',
            createCalculatedField: 'Create Calculated Field',
            fieldName: 'Enter the field name',
            error: 'Error',
            invalidFormula: 'Invalid formula.',
            dropText: 'Example: ("Sum(Order_Count)" + "Sum(In_Stock)") * 250',
            dropTextMobile: 'Add fields and edit formula here.',
            dropAction: 'Calculated field cannot be place in any other region except value axis.',
            search: 'Search',
            close: 'Close',
            cancel: 'Cancel',
            delete: 'Delete',
            alert: 'Alert',
            warning: 'Warning',
            ok: 'OK',
            allFields: 'All Fields',
            formula: 'Formula',
            fieldExist: 'A field already exists in this name. Please enter a different name.',
            confirmText: 'A calculation field already exists in this name. Do you want to replace it?',
            noMatches: 'No matches',
            format: 'Summaries values by',
            edit: 'Edit',
            clear: 'Clear',
            formulaField: 'Drag and drop fields to formula',
            dragField: 'Drag field to formula',
            clearFilter: 'Clear',
            by: 'by',
            enterValue: 'Enter value',
            chooseDate: 'Enter date',
            all: 'All',
            multipleItems: 'Multiple items',
            /* tslint:disable */
            Equals: 'Equals',
            DoesNotEquals: 'Does Not Equal',
            BeginWith: 'Begins With',
            DoesNotBeginWith: 'Does Not Begin With',
            EndsWith: 'Ends With',
            DoesNotEndsWith: 'Does Not End With',
            Contains: 'Contains',
            DoesNotContains: 'Does Not Contain',
            GreaterThan: 'Greater Than',
            GreaterThanOrEqualTo: 'Greater Than Or Equal To',
            LessThan: 'Less Than',
            LessThanOrEqualTo: 'Less Than Or Equal To',
            Between: 'Between',
            NotBetween: 'Not Between',
            Before: 'Before',
            BeforeOrEqualTo: 'Before Or Equal To',
            After: 'After',
            AfterOrEqualTo: 'After Or Equal To',
            member: 'Member',
            label: 'Label',
            date: 'Date',
            value: 'Value',
            labelTextContent: 'Show the items for which the label',
            dateTextContent: 'Show the items for which the date',
            valueTextContent: 'Show the items for which',
            And: 'and',
            Sum: 'Sum',
            Count: 'Count',
            DistinctCount: 'Distinct Count',
            Product: 'Product',
            Avg: 'Avg',
            Min: 'Min',
            Max: 'Max',
            Index: 'Index',
            SampleStDev: 'Sample StDev',
            PopulationStDev: 'Population StDev',
            SampleVar: 'Sample Var',
            PopulationVar: 'Population Var',
            RunningTotals: 'Running Totals',
            DifferenceFrom: 'Difference From',
            PercentageOfDifferenceFrom: '% of Difference From',
            PercentageOfGrandTotal: '% of Grand Total',
            PercentageOfColumnTotal: '% of Column Total',
            PercentageOfRowTotal: '% of Row Total',
            PercentageOfParentTotal: '% of Parent Total',
            PercentageOfParentColumnTotal: '% of Parent Column Total',
            PercentageOfParentRowTotal: '% of Parent Row Total',
            MoreOption: 'More...',
            Years: 'Years',
            Quarters: 'Quarters',
            Months: 'Months',
            Days: 'Days',
            Hours: 'Hours',
            Minutes: 'Minutes',
            Seconds: 'Seconds',
            /* tslint:enable */
            apply: 'APPLY',
            valueFieldSettings: 'Value field settings',
            sourceName: 'Field name :',
            sourceCaption: 'Field caption :',
            summarizeValuesBy: 'Summarize values by :',
            baseField: 'Base field :',
            baseItem: 'Base item :',
            example: 'e.g:',
            editorDataLimitMsg: ' more items. Search to refine further.',
            deferLayoutUpdate: 'Defer Layout Update',
            null: 'null',
            undefined: 'undefined',
            groupOutOfRange: 'Out of Range',
            fieldDropErrorAction: 'The field you are moving cannot be placed in that area of the report',
            memberType: 'Field Type',
            selectedHierarchy: 'Parent Hierarchy',
            formatString: 'Format String',
            expressionField: 'Expression',
            olapDropText: 'Example: [Measures].[Order Quantity] + ([Measures].[Order Quantity] * 0.10)',
            customFormat: 'Enter custom format string',
            Measure: 'Measure',
            Dimension: 'Dimension',
            Standard: 'Standard',
            Currency: 'Currency',
            Percent: 'Percent',
            Custom: 'Custom',
            blank: '(Blank)',
            fieldTooltip: 'Drag and drop fields to create an expression. ' +
                'And, if you want to edit the existing the calculated fields! ' +
                'You can achieve it by simply selecting the field under "Calculated Members".',
            fieldTitle: 'Field Name',
            QuarterYear: 'Quarter Year',
            caption: 'Field Caption',
            copy: 'Copy',
            of: 'of',
            group: 'Group'
        };
        this.localeObj = new L10n(this.getModuleName(), this.defaultLocale, this.locale);
        this.isDragging = false;
        this.captionData = [];
        this.wireEvent();
    }
    /* tslint:disable-next-line:max-line-length */
    frameCustomProperties(fieldListData, fieldList) {
        if (this.pivotGridModule) {
            this.pivotGridModule.updatePageSettings(false);
        }
        let pageSettings = this.pivotGridModule ? this.pivotGridModule.pageSettings : undefined;
        let isDrillThrough = this.pivotGridModule ?
            (this.pivotGridModule.allowDrillThrough || this.pivotGridModule.editSettings.allowEditing) : true;
        let enableValueSorting = this.pivotGridModule ? this.pivotGridModule.enableValueSorting : undefined;
        let customProperties;
        if (this.dataType === 'olap') {
            customProperties = {
                mode: '',
                savedFieldList: fieldList ? fieldList : undefined,
                savedFieldListData: fieldListData ? fieldListData : undefined,
                pageSettings: pageSettings,
                enableValueSorting: enableValueSorting,
                isDrillThrough: isDrillThrough,
                localeObj: this.localeObj
            };
        }
        else {
            customProperties = {
                mode: '',
                savedFieldList: undefined,
                pageSettings: pageSettings,
                enableValueSorting: enableValueSorting,
                isDrillThrough: isDrillThrough,
                localeObj: this.localeObj
            };
        }
        return customProperties;
    }
    /**
     * Initialize the control rendering
     * @returns void
     * @private
     */
    render() {
        this.trigger(load, { dataSourceSettings: this.dataSourceSettings }, (observedArgs) => {
            if (isBlazor()) {
                observedArgs.dataSourceSettings.dataSource = this.dataSourceSettings.dataSource;
            }
            this.dataSourceSettings = observedArgs.dataSourceSettings;
            addClass([this.element], ROOT);
            if (this.enableRtl) {
                addClass([this.element], RTL);
            }
            else {
                removeClass([this.element], RTL);
            }
            if (this.isAdaptive) {
                addClass([this.element], DEVICE);
            }
            else {
                removeClass([this.element], DEVICE);
            }
            if (this.cssClass) {
                addClass([this.element], this.cssClass);
            }
            this.notify(initialLoad, {});
        });
        if (isBlazor()) {
            this.renderComplete();
        }
    }
    /**
     * Binding events to the Pivot Field List element.
     * @hidden
     */
    wireEvent() {
        this.on(initialLoad, this.generateData, this);
        this.on(dataReady, this.fieldListRender, this);
    }
    /**
     * Unbinding events from the element on widget destroy.
     * @hidden
     */
    unWireEvent() {
        if (this.pivotGridModule && this.pivotGridModule.isDestroyed) {
            return;
        }
        this.off(initialLoad, this.generateData);
        this.off(dataReady, this.fieldListRender);
    }
    /**
     * Get the properties to be maintained in the persisted state.
     * @return {string}
     */
    getPersistData() {
        let keyEntity = ['dataSourceSettings'];
        return this.addOnPersist(keyEntity);
    }
    /**
     * Get component name.
     * @returns string
     * @private
     */
    getModuleName() {
        return 'pivotfieldlist';
    }
    /**
     * Called internally if any of the property value changed.
     * @hidden
     */
    onPropertyChanged(newProp, oldProp) {
        let requireRefresh = false;
        for (let prop of Object.keys(newProp)) {
            switch (prop) {
                case 'locale':
                    this.refresh();
                    break;
                case 'enableRtl':
                    if (this.enableRtl) {
                        addClass([this.element], RTL);
                    }
                    else {
                        removeClass([this.element], RTL);
                    }
                    requireRefresh = true;
                    break;
            }
            if (requireRefresh) {
                this.fieldListRender();
            }
        }
    }
    /* tslint:disable */
    initEngine() {
        let args = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.dataSourceSettings)
        };
        this.trigger(enginePopulating, args, (observedArgs) => {
            PivotUtil.updateDataSourceSettings(this, observedArgs.dataSourceSettings);
            if (isBlazor()) {
                this.dataSourceSettings.dataSource = this.engineModule.data;
            }
            if (this.dataType === 'pivot') {
                if (this.dataSourceSettings.groupSettings && this.dataSourceSettings.groupSettings.length > 0) {
                    let pivotDataSet;
                    if (isBlazor()) {
                        pivotDataSet = this.engineModule.data;
                    }
                    else {
                        pivotDataSet = this.dataSourceSettings.dataSource;
                    }
                    this.clonedDataSet = (this.clonedDataSet ? this.clonedDataSet : PivotUtil.getClonedData(pivotDataSet));
                    this.setProperties({ dataSourceSettings: { dataSource: [] } }, true);
                    this.clonedReport = this.clonedReport ? this.clonedReport : extend({}, this.dataSourceSettings, null, true);
                    this.setProperties({ dataSourceSettings: { dataSource: pivotDataSet } }, true);
                }
                this.engineModule.renderEngine(this.dataSourceSettings, this.frameCustomProperties(), this.getValueCellInfo.bind(this));
                this.pivotFieldList = this.engineModule.fieldList;
                let eventArgs = {
                    pivotFieldList: this.pivotFieldList,
                    pivotValues: this.engineModule.pivotValues
                };
                const this$ = this;
                this.trigger(enginePopulated, eventArgs, (observedArgs) => {
                    this$.pivotFieldList = observedArgs.pivotFieldList;
                    this$.engineModule.pivotValues = isBlazor() ? this.engineModule.pivotValues : observedArgs.pivotValues;
                    this$.notify(dataReady, {});
                    this$.trigger(dataBound);
                });
            }
            else if (this.dataType === 'olap') {
                this.olapEngineModule.renderEngine(this.dataSourceSettings, this.frameCustomProperties(this.olapEngineModule.fieldListData, this.olapEngineModule.fieldList));
                this.pivotFieldList = this.olapEngineModule.fieldList;
                let eventArgs = {
                    pivotFieldList: this.pivotFieldList,
                    pivotValues: this.olapEngineModule.pivotValues
                };
                const this$ = this;
                this.trigger(enginePopulated, eventArgs, (observedArgs) => {
                    this$.pivotFieldList = observedArgs.pivotFieldList;
                    this$.olapEngineModule.pivotValues = isBlazor() ? this.engineModule.pivotValues : observedArgs.pivotValues;
                    this$.notify(dataReady, {});
                    this$.trigger(dataBound);
                });
            }
        });
    }
    /* tslint:enable */
    /* tslint:enable */
    generateData() {
        this.pivotFieldList = {};
        if (this.dataSourceSettings && (this.dataSourceSettings.dataSource || this.dataSourceSettings.url)) {
            if ((this.dataSourceSettings.url !== '' && this.dataType === 'olap') ||
                this.dataSourceSettings.dataSource.length > 0) {
                if (this.dataType === 'pivot') {
                    this.engineModule.data = this.dataSourceSettings.dataSource;
                }
                this.initEngine();
            }
            else if (this.dataSourceSettings.dataSource instanceof DataManager) {
                setTimeout(this.getData.bind(this), 100);
            }
        }
        else {
            this.notify(dataReady, {});
            this.trigger(dataBound);
        }
    }
    getValueCellInfo(aggregateObj) {
        let args = aggregateObj;
        this.trigger(aggregateCellInfo, args);
        return args;
    }
    getData() {
        this.dataSourceSettings.dataSource.executeQuery(new Query()).then(this.executeQuery.bind(this));
    }
    executeQuery(e) {
        this.engineModule.data = e.result;
        this.initEngine();
    }
    fieldListRender() {
        this.element.innerHTML = '';
        if (this.renderMode === 'Popup' && this.dialogRenderer.fieldListDialog && !this.dialogRenderer.fieldListDialog.isDestroyed) {
            this.dialogRenderer.fieldListDialog.destroy();
            remove(document.getElementById(this.element.id + '_Wrapper'));
        }
        this.renderModule.render();
        this.fieldListSpinnerElement = this.renderMode === 'Popup' ?
            this.dialogRenderer.fieldListDialog.element : this.element.querySelector('.e-pivotfieldlist-wrapper');
        if (this.spinnerTemplate) {
            createSpinner({ target: this.fieldListSpinnerElement, template: this.spinnerTemplate }, this.createElement);
        }
        else {
            createSpinner({ target: this.fieldListSpinnerElement }, this.createElement);
        }
        let args;
        args = {
            pivotEngine: this.dataType === 'olap' ? this.olapEngineModule : this.engineModule,
            dataSourceSettings: this.dataSourceSettings,
            id: this.element.id,
            element: document.getElementById(this.element.id + '_Wrapper'),
            moduleName: this.getModuleName(),
            enableRtl: this.enableRtl,
            isAdaptive: this.isAdaptive,
            renderMode: this.renderMode,
            localeObj: this.localeObj,
            dataType: this.dataType
        };
        this.pivotCommon = new PivotCommon(args);
        this.pivotCommon.control = this;
        if (this.allowDeferLayoutUpdate) {
            this.clonedDataSource = extend({}, this.dataSourceSettings, null, true);
            this.clonedFieldList = extend({}, this.pivotFieldList, null, true);
        }
    }
    getFieldCaption(dataSourceSettings) {
        this.getFields(dataSourceSettings);
        if (this.captionData.length > 0) {
            let lnt = this.captionData.length;
            let engineModule = this.dataType === 'olap' ? this.olapEngineModule : this.engineModule;
            while (lnt--) {
                if (this.captionData[lnt]) {
                    for (let obj of this.captionData[lnt]) {
                        if (obj) {
                            if (engineModule.fieldList[obj.name]) {
                                if (obj.caption) {
                                    engineModule.fieldList[obj.name].caption = obj.caption;
                                }
                                else {
                                    engineModule.fieldList[obj.name].caption = obj.name;
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            return;
        }
    }
    getFields(dataSourceSettings) {
        /* tslint:disable-next-line:max-line-length */
        this.captionData = [dataSourceSettings.rows, dataSourceSettings.columns, dataSourceSettings.values, dataSourceSettings.filters];
    }
    /* tslint:disable */
    /**
     * Updates the PivotEngine using dataSource from Pivot Field List component.
     * @method updateDataSource
     * @return {void}
     * @hidden
     */
    updateDataSource(isTreeViewRefresh, isEngineRefresh) {
        if (this.pivotGridModule) {
            this.pivotGridModule.showWaitingPopup();
        }
        showSpinner(this.fieldListSpinnerElement);
        let pivot = this;
        //setTimeout(() => {
        let isOlapDataRefreshed = false;
        let pageSettings = pivot.pivotGridModule && pivot.pivotGridModule.enableVirtualization ?
            pivot.pivotGridModule.pageSettings : undefined;
        let isCalcChange = Object.keys(pivot.lastCalcFieldInfo).length > 0 ? true : false;
        let isSorted = Object.keys(pivot.lastSortInfo).length > 0 ? true : false;
        let lastSortInfo = pivot.lastSortInfo;
        if (pivot.pivotGridModule && pivot.dataType === 'pivot') {
            pivot.pivotGridModule.lastSortInfo = {};
        }
        pivot.lastSortInfo = {};
        let isAggChange = Object.keys(pivot.lastAggregationInfo).length > 0 ? true : false;
        let isFiltered = Object.keys(pivot.lastFilterInfo).length > 0 ? true : false;
        let args = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(pivot.dataSourceSettings)
        };
        pivot.trigger(enginePopulating, args, (observedArgs) => {
            if (!(pageSettings && (isSorted || isFiltered || isAggChange || isCalcChange))) {
                PivotUtil.updateDataSourceSettings(pivot, observedArgs.dataSourceSettings);
                PivotUtil.updateDataSourceSettings(pivot.pivotGridModule, observedArgs.dataSourceSettings);
            }
            if (isNullOrUndefined(isEngineRefresh)) {
                if (pivot.dataType === 'pivot') {
                    let customProperties = pivot.frameCustomProperties();
                    customProperties.savedFieldList = pivot.pivotFieldList;
                    if (pageSettings && (isSorted || isFiltered || isAggChange || isCalcChange)) {
                        let interopArguments = {};
                        if (isSorted) {
                            pivot.pivotGridModule.setProperties({ dataSourceSettings: { valueSortSettings: { headerText: '' } } }, true);
                            if ((isBlazor())) {
                                interopArguments = { 'key': 'onSort', 'arg': lastSortInfo };
                            }
                            else {
                                pivot.engineModule.onSort(lastSortInfo);
                            }
                        }
                        if (isFiltered) {
                            if (isBlazor()) {
                                let dataArgs = window['ejsInterop'].copyWithoutCircularReferences([pivot.dataSourceSettings.filterSettings], pivot.dataSourceSettings.filterSettings);
                                interopArguments = {
                                    'key': 'onFilter',
                                    'arg': { 'lastFilterInfo': pivot.lastFilterInfo, 'filterSettings': dataArgs }
                                };
                            }
                            else {
                                pivot.engineModule.onFilter(pivot.lastFilterInfo, pivot.dataSourceSettings);
                            }
                            pivot.lastFilterInfo = {};
                        }
                        if (isAggChange) {
                            if (isBlazor()) {
                                interopArguments = { 'key': 'onAggregation', 'arg': pivot.lastAggregationInfo };
                            }
                            else {
                                pivot.engineModule.onAggregation(pivot.lastAggregationInfo);
                            }
                            pivot.lastAggregationInfo = {};
                        }
                        if (isCalcChange) {
                            if (isBlazor()) {
                                interopArguments = {
                                    'key': 'onCalcOperation',
                                    'arg': {
                                        lastCalcFieldInfo: pivot.lastCalcFieldInfo,
                                        values: pivot.dataSourceSettings.values,
                                        calculatedFieldSettings: pivot.dataSourceSettings.calculatedFieldSettings
                                    }
                                };
                            }
                            else {
                                pivot.engineModule.onCalcOperation(pivot.lastCalcFieldInfo);
                            }
                            pivot.lastCalcFieldInfo = {};
                        }
                        if (isBlazor()) {
                            let args = window['ejsInterop'].copyWithoutCircularReferences([interopArguments['arg']], interopArguments['arg']);
                            pivot.pivotGridModule.interopAdaptor.invokeMethodAsync("PivotInteropMethod", interopArguments['key'], args).then((data) => {
                                pivot.pivotGridModule.updateBlazorData(data, pivot.pivotGridModule);
                                pivot.getFieldCaption(pivot.dataSourceSettings);
                                pivot.enginePopulatedEventMethod(pivot, isTreeViewRefresh, isOlapDataRefreshed);
                                if (pivot.calculatedFieldModule && pivot.calculatedFieldModule.isRequireUpdate) {
                                    pivot.calculatedFieldModule.endDialog();
                                    pivot.calculatedFieldModule.isRequireUpdate = false;
                                }
                            });
                        }
                    }
                    else {
                        if (isBlazor() && pageSettings) {
                            let dataArgs = window['ejsInterop'].copyWithoutCircularReferences([pivot.dataSourceSettings.properties], pivot.dataSourceSettings.properties);
                            pivot.pivotGridModule.interopAdaptor.invokeMethodAsync("PivotInteropMethod", 'renderEngine', { 'dataSourceSettings': dataArgs, 'customProperties': customProperties }).then((data) => {
                                pivot.pivotGridModule.updateBlazorData(data, pivot.pivotGridModule);
                                pivot.getFieldCaption(pivot.dataSourceSettings);
                                pivot.enginePopulatedEventMethod(pivot, isTreeViewRefresh, isOlapDataRefreshed);
                            });
                        }
                        else {
                            /* tslint:disable-next-line:max-line-length */
                            pivot.engineModule.renderEngine(pivot.dataSourceSettings, customProperties, pivot.getValueCellInfo.bind(pivot));
                        }
                    }
                }
                else {
                    isOlapDataRefreshed = pivot.updateOlapDataSource(pivot, isSorted, isCalcChange, isOlapDataRefreshed);
                }
                if (!(isBlazor() && pageSettings)) {
                    pivot.getFieldCaption(pivot.dataSourceSettings);
                }
            }
            else {
                pivot.axisFieldModule.render();
                pivot.isRequiredUpdate = false;
            }
            if (!(isBlazor() && pageSettings)) {
                pivot.enginePopulatedEventMethod(pivot, isTreeViewRefresh, isOlapDataRefreshed);
            }
        });
        //});
    }
    enginePopulatedEventMethod(pivot, isTreeViewRefresh, isOlapDataRefreshed) {
        let eventArgs = {
            dataSourceSettings: pivot.dataSourceSettings,
            pivotFieldList: pivot.dataType === 'pivot' ? pivot.engineModule.fieldList : pivot.olapEngineModule.fieldList,
            pivotValues: pivot.dataType === 'pivot' ? pivot.engineModule.pivotValues : pivot.olapEngineModule.pivotValues
        };
        pivot.trigger(enginePopulated, eventArgs, (observedArgs) => {
            let dataSource = pivot.dataSourceSettings.dataSource;
            if (isBlazor() && observedArgs.dataSourceSettings.dataSource instanceof Object) {
                observedArgs.dataSourceSettings.dataSource = dataSource;
            }
            pivot.dataSourceSettings = observedArgs.dataSourceSettings;
            pivot.pivotCommon.dataSourceSettings = pivot.dataSourceSettings;
            pivot.pivotFieldList = observedArgs.pivotFieldList;
            if (pivot.dataType === 'olap') {
                pivot.olapEngineModule.pivotValues = isBlazor() ? pivot.olapEngineModule.pivotValues : observedArgs.pivotValues;
                pivot.pivotCommon.engineModule = pivot.olapEngineModule;
            }
            else {
                pivot.engineModule.pivotValues = isBlazor() ? pivot.engineModule.pivotValues : observedArgs.pivotValues;
                pivot.pivotCommon.engineModule = pivot.engineModule;
            }
            if (!isTreeViewRefresh && pivot.treeViewModule.fieldTable && !pivot.isAdaptive) {
                pivot.notify(treeViewUpdate, {});
            }
            if (pivot.isRequiredUpdate) {
                if (pivot.allowDeferLayoutUpdate) {
                    pivot.clonedDataSource = extend({}, pivot.dataSourceSettings, null, true);
                    pivot.clonedFieldList = extend({}, pivot.pivotFieldList, null, true);
                }
                pivot.updateView(pivot.pivotGridModule);
            }
            else if (pivot.renderMode === 'Popup' && pivot.allowDeferLayoutUpdate) {
                pivot.pivotGridModule.engineModule = pivot.engineModule;
                /* tslint:disable:align */
                pivot.pivotGridModule.setProperties({
                    dataSourceSettings: pivot.dataSourceSettings.properties
                }, true);
                pivot.pivotGridModule.notify(uiUpdate, pivot);
                hideSpinner(pivot.fieldListSpinnerElement);
            }
            if (pivot.renderMode === 'Popup' && pivot.pivotGridModule &&
                pivot.pivotGridModule.allowDeferLayoutUpdate && !pivot.isRequiredUpdate) {
                hideSpinner(pivot.fieldListSpinnerElement);
                pivot.pivotGridModule.hideWaitingPopup();
            }
            pivot.isRequiredUpdate = true;
            if (!pivot.pivotGridModule || isOlapDataRefreshed) {
                hideSpinner(pivot.fieldListSpinnerElement);
            }
            else {
                pivot.pivotGridModule.fieldListSpinnerElement = pivot.fieldListSpinnerElement;
            }
        });
    }
    /* tslint:enable */
    updateOlapDataSource(pivot, isSorted, isCalcChange, isOlapDataRefreshed) {
        let customProperties = pivot.frameCustomProperties(pivot.olapEngineModule.fieldListData, pivot.olapEngineModule.fieldList);
        customProperties.savedFieldList = pivot.pivotFieldList;
        if (isCalcChange || isSorted) {
            pivot.olapEngineModule.savedFieldList = pivot.pivotFieldList;
            pivot.olapEngineModule.savedFieldListData = pivot.olapEngineModule.fieldListData;
            if (isCalcChange) {
                pivot.olapEngineModule.updateCalcFields(pivot.dataSourceSettings, pivot.lastCalcFieldInfo);
                pivot.lastCalcFieldInfo = {};
                isOlapDataRefreshed = pivot.olapEngineModule.dataFields[pivot.lastCalcFieldInfo.name] ? false : true;
                if (pivot.pivotGridModule) {
                    pivot.pivotGridModule.hideWaitingPopup();
                }
            }
            else {
                pivot.olapEngineModule.onSort(pivot.dataSourceSettings);
            }
        }
        else {
            pivot.olapEngineModule.renderEngine(pivot.dataSourceSettings, customProperties);
        }
        return isOlapDataRefreshed;
    }
    /**
     * Updates the Pivot Field List component using dataSource from PivotView component.
     * @method updateControl
     * @return {void}
     */
    update(control) {
        if (isBlazor() && control !== undefined) {
            /* tslint:disable */
            let pivotId = control.ID;
            let pivotInstance = getInstance('#' + pivotId, PivotView);
            control = pivotInstance;
            /* tslint:enable */
        }
        if (control) {
            this.clonedDataSet = control.clonedDataSet;
            this.setProperties({ dataSourceSettings: control.dataSourceSettings }, true);
            this.engineModule = control.engineModule;
            this.olapEngineModule = control.olapEngineModule;
            this.dataType = control.dataType;
            this.pivotFieldList = this.dataType === 'olap' ? control.olapEngineModule.fieldList : control.engineModule.fieldList;
            if (this.renderMode === 'Popup') {
                this.pivotGridModule = control;
            }
            this.getFieldCaption(control.dataSourceSettings);
            this.pivotCommon.engineModule = this.dataType === 'olap' ? this.olapEngineModule : this.engineModule;
            this.pivotCommon.dataSourceSettings = this.dataSourceSettings;
            this.pivotCommon.control = this;
            if (this.treeViewModule.fieldTable && !this.isAdaptive) {
                this.notify(treeViewUpdate, {});
            }
            this.axisFieldModule.render();
            if (this.renderMode === 'Fixed' && this.allowDeferLayoutUpdate) {
                this.clonedDataSource = extend({}, this.dataSourceSettings, null, true);
                this.clonedFieldList = extend({}, this.pivotFieldList, null, true);
            }
        }
    }
    /**
     * Updates the PivotView component using dataSource from Pivot Field List component.
     * @method refreshTargetControl
     * @return {void}
     */
    updateView(control) {
        if (isBlazor() && control !== undefined) {
            /* tslint:disable */
            let pivotId = control.ID;
            let pivotInstance = getInstance('#' + pivotId, PivotView);
            control = pivotInstance;
            /* tslint:enable */
        }
        if (control) {
            control.clonedDataSet = this.clonedDataSet;
            if (isBlazor()) {
                PivotUtil.updateDataSourceSettings(control, PivotUtil.getClonedDataSourceSettings(this.dataSourceSettings));
            }
            else {
                control.setProperties({ dataSourceSettings: this.dataSourceSettings }, true);
            }
            control.engineModule = this.engineModule;
            control.olapEngineModule = this.olapEngineModule;
            control.dataType = this.dataType;
            control.pivotValues = this.dataType === 'olap' ? this.olapEngineModule.pivotValues : this.engineModule.pivotValues;
            let eventArgs = {
                dataSourceSettings: control.dataSourceSettings,
                pivotValues: control.pivotValues
            };
            control.trigger(fieldListRefreshed, eventArgs);
            if (control.enableVirtualization && isBlazor()) {
                control.renderPivotGrid();
            }
            else {
                control.dataBind();
            }
        }
    }
    /**
     * Called internally to trigger populate event.
     * @hidden
     */
    triggerPopulateEvent() {
        let eventArgs = {
            dataSourceSettings: this.dataSourceSettings,
            pivotFieldList: this.dataType === 'olap' ? this.olapEngineModule.fieldList : this.engineModule.fieldList,
            pivotValues: this.dataType === 'olap' ? this.olapEngineModule.pivotValues : this.engineModule.pivotValues
        };
        this.trigger(enginePopulated, eventArgs, (observedArgs) => {
            this.dataSourceSettings = observedArgs.dataSourceSettings;
            this.pivotFieldList = observedArgs.pivotFieldList;
            if (this.dataType === 'olap') {
                this.olapEngineModule.pivotValues = isBlazor() ? this.olapEngineModule.pivotValues : observedArgs.pivotValues;
            }
            else {
                this.engineModule.pivotValues = isBlazor() ? this.engineModule.pivotValues : observedArgs.pivotValues;
            }
        });
    }
    /**
     * Destroys the Field Table component.
     * @method destroy
     * @return {void}
     */
    destroy() {
        this.unWireEvent();
        if (this.treeViewModule) {
            this.treeViewModule.destroy();
        }
        if (this.pivotButtonModule) {
            this.pivotButtonModule.destroy();
        }
        if (this.allowDeferLayoutUpdate && this.dialogRenderer &&
            this.dialogRenderer.deferUpdateCheckBox && !this.dialogRenderer.deferUpdateCheckBox.isDestroyed) {
            this.dialogRenderer.deferUpdateCheckBox.destroy();
        }
        super.destroy();
        this.element.innerHTML = '';
        removeClass([this.element], ROOT);
        removeClass([this.element], RTL);
        removeClass([this.element], DEVICE);
        if (this.renderMode === 'Popup') {
            if (this.dialogRenderer.fieldListDialog && !this.dialogRenderer.fieldListDialog.isDestroyed) {
                this.dialogRenderer.fieldListDialog.destroy();
            }
            if (document.getElementById(this.element.id + '_Wrapper')) {
                remove(document.getElementById(this.element.id + '_Wrapper'));
            }
        }
    }
};
__decorate$4([
    Complex({}, DataSourceSettings)
], PivotFieldList.prototype, "dataSourceSettings", void 0);
__decorate$4([
    Property('Popup')
], PivotFieldList.prototype, "renderMode", void 0);
__decorate$4([
    Property()
], PivotFieldList.prototype, "target", void 0);
__decorate$4([
    Property('')
], PivotFieldList.prototype, "cssClass", void 0);
__decorate$4([
    Property(false)
], PivotFieldList.prototype, "allowCalculatedField", void 0);
__decorate$4([
    Property(false)
], PivotFieldList.prototype, "showValuesButton", void 0);
__decorate$4([
    Property(false)
], PivotFieldList.prototype, "allowDeferLayoutUpdate", void 0);
__decorate$4([
    Property(1000)
], PivotFieldList.prototype, "maxNodeLimitInMemberEditor", void 0);
__decorate$4([
    Property(true)
], PivotFieldList.prototype, "loadOnDemandInMemberEditor", void 0);
__decorate$4([
    Property()
], PivotFieldList.prototype, "spinnerTemplate", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "load", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "enginePopulating", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "memberFiltering", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "enginePopulated", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "onFieldDropped", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "fieldDrop", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "aggregateCellInfo", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "dataBound", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "created", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "destroyed", void 0);
PivotFieldList = __decorate$4([
    NotifyPropertyChanges
], PivotFieldList);

/**
 * Base export
 */
/** @hidden */

/**
 * Models
 */
/** @hidden */

/**
 * PivotGrid component exported items
 */
/** @hidden */

/**
 * Module to render Calculated Field Dialog
 */
const COUNT = 'Count';
const AVG = 'Avg';
const MIN = 'Min';
const MAX = 'Max';
const SUM = 'Sum';
const DISTINCTCOUNT = 'DistinctCount';
const PRODUCT = 'Product';
const STDEV = 'SampleStDev';
const STDEVP = 'PopulationStDev';
const VAR = 'SampleVar';
const VARP = 'PopulationVar';
const CALC = 'CalculatedField';
const AGRTYPE = 'AggregateType';
/** @hidden */
class CalculatedField {
    /** Constructor for calculatedfield module */
    constructor(parent) {
        /** @hidden */
        this.isFormula = false;
        /** @hidden */
        this.isRequireUpdate = false;
        this.parent = parent;
        this.existingReport = null;
        this.parent.calculatedFieldModule = this;
        this.removeEventListener();
        this.addEventListener();
        this.parentID = this.parent.element.id;
        this.dialog = null;
        this.inputObj = null;
        this.treeObj = null;
        this.droppable = null;
        this.menuObj = null;
        this.newFields = null;
        this.isFieldExist = true;
        this.formulaText = null;
        this.fieldText = null;
        this.isEdit = false;
        this.currentFieldName = null;
        this.confirmPopUp = null;
    }
    /**
     * To get module name.
     * @returns string
     */
    getModuleName() {
        return 'calculatedfield';
    }
    keyActionHandler(e) {
        let node = e.currentTarget.querySelector('.e-hover.e-node-focus');
        if (node) {
            switch (e.action) {
                case 'moveRight':
                    if (this.parent.dataType === 'pivot') {
                        this.displayMenu(node.previousSibling);
                    }
                    break;
                case 'enter':
                    let field = node.getAttribute('data-field');
                    let type = node.getAttribute('data-type');
                    let dropField = this.dialog.element.querySelector('#' + this.parentID + 'droppable');
                    if (this.parent.dataType === 'pivot') {
                        if (dropField.value === '') {
                            if (type === CALC) {
                                dropField.value = node.getAttribute('data-uid');
                            }
                            else {
                                dropField.value = '"' + type + '(' + field + ')' + '"';
                            }
                        }
                        else if (dropField.value !== '') {
                            if (type === CALC) {
                                dropField.value = dropField.value + node.getAttribute('data-uid');
                            }
                            else {
                                dropField.value = dropField.value + '"' + type + '(' + field + ')' + '"';
                            }
                        }
                    }
                    else {
                        if (this.parent.olapEngineModule && this.parent.olapEngineModule.fieldList[field] &&
                            this.parent.olapEngineModule.fieldList[field].isCalculatedField) {
                            field = this.parent.olapEngineModule.fieldList[field].tag;
                        }
                        if (dropField.value === '') {
                            dropField.value = field;
                        }
                        else if (dropField.value !== '') {
                            dropField.value = dropField.value + field;
                        }
                    }
                    break;
            }
        }
    }
    /**
     * Trigger while click treeview icon.
     * @param  {MouseEvent} e
     * @returns void
     */
    fieldClickHandler(e) {
        let node = e.event.target.parentElement;
        if (e.event.target.classList.contains(FORMAT) ||
            e.event.target.classList.contains(CALC_EDIT) ||
            e.event.target.classList.contains(CALC_EDITED)) {
            this.displayMenu(node.parentElement);
        }
    }
    clearFormula() {
        if (this.treeObj && this.treeObj.element.querySelector('li')) {
            removeClass(this.treeObj.element.querySelectorAll('li'), 'e-active');
            this.displayMenu(this.treeObj.element.querySelector('li'));
        }
    }
    /**
     * To display context menu.
     * @param  {HTMLElement} node
     * @returns void
     */
    displayMenu(node) {
        if (this.parent.dataType === 'pivot' &&
            document.querySelector('.' + this.parentID + 'calculatedmenu') !== null &&
            node.querySelector('.e-list-icon').classList.contains(ICON) &&
            !node.querySelector('.e-list-icon').classList.contains(CALC_EDITED) &&
            !node.querySelector('.e-list-icon').classList.contains(CALC_EDIT) && node.tagName === 'LI') {
            let fieldName = node.getAttribute('data-field');
            let isStringField = this.parent.engineModule.fieldList[fieldName].type !== 'number' ? 1 : 0;
            this.menuObj[isStringField].close();
            this.curMenu = node.querySelector('.' + LIST_TEXT_CLASS);
            this.openContextMenu(isStringField);
        }
        else if (node.tagName === 'LI' && (node.querySelector('.e-list-icon').classList.contains(CALC_EDIT) ||
            (this.parent.dataType === 'olap' && node.getAttribute('data-type') === CALC && node.classList.contains('e-active')))) {
            this.isEdit = true;
            let fieldName = node.getAttribute('data-field');
            let caption = node.getAttribute('data-caption');
            this.currentFieldName = fieldName;
            this.inputObj.value = caption;
            this.inputObj.dataBind();
            if (this.parent.dataType === 'olap') {
                let memberType = node.getAttribute('data-membertype');
                let parentHierarchy = node.getAttribute('data-hierarchy');
                let expression = node.getAttribute('data-formula');
                let formatString = node.getAttribute('data-formatString');
                let customString = node.getAttribute('data-customString');
                let dialogElement = this.dialog.element;
                /* tslint:disable */
                let fieldTitle = dialogElement.querySelector('#' + this.parentID + '_' + 'FieldNameTitle');
                let customFormat = getInstance(dialogElement.querySelector('#' + this.parentID + 'Custom_Format_Element'), MaskedTextBox);
                let memberTypeDrop = getInstance(dialogElement.querySelector('#' + this.parentID + 'Member_Type_Div'), DropDownList);
                let hierarchyDrop = getInstance(dialogElement.querySelector('#' + this.parentID + 'Hierarchy_List_Div'), DropDownList);
                let formatDrop = getInstance(dialogElement.querySelector('#' + this.parentID + 'Format_Div'), DropDownList);
                /* tslint:enable */
                fieldTitle.innerHTML = this.parent.localeObj.getConstant('caption');
                document.querySelector('#' + this.parentID + 'droppable').value = expression;
                memberTypeDrop.readonly = true;
                memberTypeDrop.value = memberType;
                memberTypeDrop.dataBind();
                if (memberType === 'Dimension') {
                    hierarchyDrop.value = parentHierarchy;
                }
                if (formatString !== '') {
                    formatDrop.value = formatString;
                    formatDrop.dataBind();
                }
                customFormat.value = customString;
                customFormat.dataBind();
            }
            else {
                addClass([node.querySelector('.e-list-icon')], CALC_EDITED);
                removeClass([node.querySelector('.e-list-icon')], CALC_EDIT);
                node.querySelector('.' + CALC_EDITED).setAttribute('title', this.parent.localeObj.getConstant('clear'));
                document.querySelector('#' + this.parentID + 'droppable').value = node.getAttribute('data-uid');
            }
        }
        else if (node.tagName === 'LI' && (node.querySelector('.e-list-icon').classList.contains(CALC_EDITED) ||
            (this.parent.dataType === 'olap' && !node.classList.contains('e-active')))) {
            this.isEdit = false;
            this.inputObj.value = '';
            this.inputObj.dataBind();
            if (this.parent.dataType === 'olap') {
                let dialogElement = this.dialog.element;
                /* tslint:disable */
                let hierarchyDrop = getInstance(dialogElement.querySelector('#' + this.parentID + 'Hierarchy_List_Div'), DropDownList);
                let formatDrop = getInstance(dialogElement.querySelector('#' + this.parentID + 'Format_Div'), DropDownList);
                let customFormat = getInstance(dialogElement.querySelector('#' + this.parentID + 'Custom_Format_Element'), MaskedTextBox);
                let memberTypeDrop = getInstance(dialogElement.querySelector('#' + this.parentID + 'Member_Type_Div'), DropDownList);
                let fieldTitle = dialogElement.querySelector('#' + this.parentID + '_' + 'FieldNameTitle');
                /* tslint:enable */
                fieldTitle.innerHTML = this.parent.localeObj.getConstant('fieldTitle');
                hierarchyDrop.index = 0;
                hierarchyDrop.dataBind();
                formatDrop.index = 0;
                formatDrop.dataBind();
                customFormat.value = '';
                customFormat.dataBind();
                memberTypeDrop.index = 0;
                memberTypeDrop.readonly = false;
                memberTypeDrop.dataBind();
            }
            else {
                addClass([node.querySelector('.e-list-icon')], CALC_EDIT);
                removeClass([node.querySelector('.e-list-icon')], CALC_EDITED);
                node.querySelector('.' + CALC_EDIT).setAttribute('title', this.parent.localeObj.getConstant('edit'));
            }
            document.querySelector('#' + this.parentID + 'droppable').value = '';
        }
    }
    /**
     * To set position for context menu.
     * @returns void
     */
    openContextMenu(isStringField) {
        let pos = this.curMenu.getBoundingClientRect();
        let offset = isStringField ? (window.scrollY || document.documentElement.scrollTop) : 30;
        if (this.parent.enableRtl) {
            this.menuObj[isStringField].open(pos.top + offset, pos.left - 100);
        }
        else {
            this.menuObj[isStringField].open(pos.top + offset, pos.left + 150);
        }
    }
    /**
     * Triggers while select menu.
     * @param  {MenuEventArgs} menu
     * @returns void
     */
    selectContextMenu(menu) {
        if (menu.element.textContent !== null) {
            let field = closest(this.curMenu, '.e-list-item').getAttribute('data-caption');
            closest(this.curMenu, '.e-list-item').setAttribute('data-type', menu.element.id.split('_').pop());
            this.curMenu.textContent = field + ' (' + menu.element.textContent + ')';
            addClass([this.curMenu.parentElement.parentElement], ['e-node-focus', 'e-hover']);
            this.curMenu.parentElement.parentElement.setAttribute('tabindex', '-1');
            this.curMenu.parentElement.parentElement.focus();
        }
    }
    /**
     * To create context menu.
     * @returns void
     */
    createMenu() {
        let menuItems = [];
        menuItems[0] = [
            { id: this.parent.element.id + '_Sum', text: this.parent.localeObj.getConstant('Sum') },
            { id: this.parent.element.id + '_Count', text: this.parent.localeObj.getConstant('Count') },
            { id: this.parent.element.id + '_DistinctCount', text: this.parent.localeObj.getConstant('DistinctCount') },
            { id: this.parent.element.id + '_Avg', text: this.parent.localeObj.getConstant('Avg') },
            { id: this.parent.element.id + '_Min', text: this.parent.localeObj.getConstant('Min') },
            { id: this.parent.element.id + '_Max', text: this.parent.localeObj.getConstant('Max') },
            { id: this.parent.element.id + '_Product', text: this.parent.localeObj.getConstant('Product') },
            { id: this.parent.element.id + '_SampleStDev', text: this.parent.localeObj.getConstant('SampleStDev') },
            { id: this.parent.element.id + '_SampleVar', text: this.parent.localeObj.getConstant('SampleVar') },
            { id: this.parent.element.id + '_PopulationStDev', text: this.parent.localeObj.getConstant('PopulationStDev') },
            { id: this.parent.element.id + '_PopulationVar', text: this.parent.localeObj.getConstant('PopulationVar') }
        ];
        menuItems[1] =
            [{ text: this.parent.localeObj.getConstant('Count'), id: this.parent.element.id + 'StringMenu_Count' },
                { text: this.parent.localeObj.getConstant('DistinctCount'), id: this.parent.element.id + 'StringMenu_DistinctCount' }];
        this.menuObj = [];
        for (let i = 0, noOfItem = menuItems.length; i < noOfItem; i++) {
            let menuOptions = {
                cssClass: this.parentID + 'calculatedmenu',
                items: menuItems[i],
                enableRtl: this.parent.enableRtl,
                beforeOpen: this.beforeMenuOpen.bind(this),
                select: this.selectContextMenu.bind(this)
            };
            let contextMenu = createElement('ul', {
                id: this.parentID + 'contextmenu' + (i ? '_StringMenu' : ''),
            });
            this.parent.element.appendChild(contextMenu);
            this.menuObj[i] = new ContextMenu$1(menuOptions);
            this.menuObj[i].isStringTemplate = true;
            this.menuObj[i].appendTo(contextMenu);
        }
    }
    /* tslint:disable */
    /**
     * Triggers while click OK button.
     * @returns void
     */
    applyFormula() {
        let currentObj = this;
        let isExist = false;
        removeClass([document.getElementById(this.parentID + 'ddlelement')], EMPTY_FIELD);
        if (currentObj.parent.dataType === 'olap') {
            let field = currentObj.inputObj.value;
            if (currentObj.parent.olapEngineModule.fieldList[field] &&
                currentObj.parent.olapEngineModule.fieldList[field].type !== 'CalculatedField') {
                isExist = true;
            }
        }
        else {
            for (let key of Object.keys(currentObj.parent.engineModule.fieldList)) {
                if (currentObj.inputObj.value && currentObj.inputObj.value === key &&
                    currentObj.parent.engineModule.fieldList[key].aggregateType !== 'CalculatedField') {
                    isExist = true;
                }
            }
        }
        if (isExist) {
            currentObj.parent.pivotCommon.errorDialog.createErrorDialog(currentObj.parent.localeObj.getConstant('error'), currentObj.parent.localeObj.getConstant('fieldExist'));
            return;
        }
        this.newFields =
            extend([], this.parent.dataSourceSettings.calculatedFieldSettings, null, true);
        this.existingReport = extend({}, this.parent.dataSourceSettings, null, true);
        let report = this.parent.dataSourceSettings;
        let dropField = document.querySelector('#' + this.parentID + 'droppable');
        if (this.inputObj.value !== null && this.inputObj.value !== '' && dropField.value !== '') {
            let field;
            if (this.parent.dataType === 'olap') {
                let dialogElement = this.parent.isAdaptive ? this.parent.dialogRenderer.adaptiveElement.element : this.dialog.element;
                let memberTypeDrop = getInstance(dialogElement.querySelector('#' + this.parentID + 'Member_Type_Div'), DropDownList);
                let customFormat = getInstance(dialogElement.querySelector('#' + this.parentID + 'Custom_Format_Element'), MaskedTextBox);
                let hierarchyDrop = getInstance(dialogElement.querySelector('#' + this.parentID + 'Hierarchy_List_Div'), DropDownList);
                let formatDrop = getInstance(dialogElement.querySelector('#' + this.parentID + 'Format_Div'), DropDownList);
                field = {
                    name: this.inputObj.value,
                    formula: dropField.value,
                    formatString: (formatDrop.value === 'Custom' ? customFormat.value : formatDrop.value)
                };
                if (memberTypeDrop.value === 'Dimension') {
                    field.hierarchyUniqueName = hierarchyDrop.value;
                }
                this.isFieldExist = false;
                if (!this.isEdit) {
                    for (let i = 0; i < report.calculatedFieldSettings.length; i++) {
                        if (report.calculatedFieldSettings[i].name === field.name) {
                            this.createConfirmDialog(currentObj.parent.localeObj.getConstant('alert'), currentObj.parent.localeObj.getConstant('confirmText'));
                            return;
                        }
                    }
                }
                else {
                    for (let i = 0; i < report.calculatedFieldSettings.length; i++) {
                        if (report.calculatedFieldSettings[i].name === this.currentFieldName && this.isEdit) {
                            if (memberTypeDrop.value === 'Dimension') {
                                report.calculatedFieldSettings[i].hierarchyUniqueName = field.hierarchyUniqueName;
                            }
                            this.parent.olapEngineModule.fieldList[this.currentFieldName].caption = this.inputObj.value;
                            report.calculatedFieldSettings[i].formatString = field.formatString;
                            report.calculatedFieldSettings[i].formula = field.formula;
                            field = report.calculatedFieldSettings[i];
                            this.isFieldExist = true;
                            break;
                        }
                    }
                    let axisFields = [report.rows, report.columns, report.values, report.filters];
                    let isFieldExist = false;
                    for (let fields of axisFields) {
                        for (let item of fields) {
                            if (item.isCalculatedField && this.currentFieldName !== null &&
                                item.name === this.currentFieldName && this.isEdit) {
                                item.caption = this.inputObj.value;
                                this.isFieldExist = true;
                                isFieldExist = true;
                                break;
                            }
                        }
                        if (isFieldExist) {
                            break;
                        }
                    }
                }
                if (!this.isFieldExist) {
                    report.calculatedFieldSettings.push(field);
                }
                this.parent.lastCalcFieldInfo = field;
            }
            else {
                field = {
                    name: this.inputObj.value,
                    type: 'CalculatedField'
                };
                let cField = {
                    name: this.inputObj.value,
                    formula: dropField.value
                };
                this.isFieldExist = true;
                if (!this.isEdit) {
                    for (let i = 0; i < report.values.length; i++) {
                        if (report.values[i].type === CALC && report.values[i].name === field.name) {
                            for (let j = 0; j < report.calculatedFieldSettings.length; j++) {
                                if (report.calculatedFieldSettings[j].name === field.name) {
                                    this.createConfirmDialog(currentObj.parent.localeObj.getConstant('alert'), currentObj.parent.localeObj.getConstant('confirmText'));
                                    return;
                                }
                            }
                            this.isFieldExist = false;
                        }
                    }
                }
                else {
                    for (let i = 0; i < report.values.length; i++) {
                        if (report.values[i].type === CALC && this.currentFieldName !== null &&
                            report.values[i].name === this.currentFieldName && this.isEdit) {
                            for (let j = 0; j < report.calculatedFieldSettings.length; j++) {
                                if (report.calculatedFieldSettings[j].name === this.currentFieldName) {
                                    report.values[i].caption = this.inputObj.value;
                                    report.calculatedFieldSettings[j].formula = dropField.value;
                                    this.parent.engineModule.fieldList[this.currentFieldName].caption = this.inputObj.value;
                                    this.isFieldExist = false;
                                }
                            }
                        }
                    }
                }
                if (this.isFieldExist) {
                    report.values.push(field);
                    report.calculatedFieldSettings.push(cField);
                }
                this.parent.lastCalcFieldInfo = cField;
            }
            this.addFormula(report, field.name);
        }
        else {
            if (this.inputObj.value === null || this.inputObj.value === '') {
                addClass([document.getElementById(this.parentID + 'ddlelement')], EMPTY_FIELD);
                document.getElementById(this.parentID + 'ddlelement').focus();
            }
            else {
                this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('error'), this.parent.localeObj.getConstant('invalidFormula'));
            }
        }
    }
    /* tslint:enable */
    addFormula(report, field) {
        this.isFormula = true;
        this.field = field;
        this.parent.setProperties({ dataSourceSettings: report }, true);
        if (this.parent.getModuleName() === 'pivotfieldlist' && this.parent.allowDeferLayoutUpdate) {
            this.parent.isRequiredUpdate = false;
        }
        try {
            this.parent.updateDataSource(false);
            let pivot = this.parent.getModuleName() === 'pivotfieldlist' ?
                this.parent.pivotGridModule : this.parent;
            if (!(isBlazor() && pivot && pivot.enableVirtualization)) {
                this.endDialog();
            }
            else {
                this.isRequireUpdate = true;
            }
        }
        catch (exception) {
            this.showError();
        }
    }
    /** @hidden */
    endDialog() {
        this.isEdit = false;
        if (this.dialog) {
            this.dialog.close();
        }
        else {
            this.inputObj.value = '';
            this.formulaText = null;
            this.fieldText = null;
            this.parent.
                dialogRenderer.parentElement.querySelector('.' + CALCINPUT).value = '';
            this.parent.
                dialogRenderer.parentElement.querySelector('#' + this.parentID + 'droppable').value = '';
        }
    }
    /** @hidden */
    showError() {
        if (this.parent.engineModule.fieldList[this.field]) {
            delete this.parent.engineModule.fieldList[this.field];
        }
        this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('error'), this.parent.localeObj.getConstant('invalidFormula'));
        this.parent.setProperties({ dataSourceSettings: this.existingReport }, true);
        this.parent.lastCalcFieldInfo = {};
        this.parent.updateDataSource(false);
        this.isFormula = false;
    }
    /**
     * To get treeview data
     * @param  {PivotGrid|PivotFieldList} parent
     * @returns Object
     */
    getFieldListData(parent) {
        let fields = [];
        if (this.parent.dataType === 'olap') {
            fields = PivotUtil.getClonedData(parent.olapEngineModule.fieldListData);
            for (let item of fields) {
                if (item.spriteCssClass &&
                    (item.spriteCssClass.indexOf('e-attributeCDB-icon') > -1 ||
                        item.spriteCssClass.indexOf('e-level-members') > -1)) {
                    item.hasChildren = true;
                }
                else if (item.spriteCssClass &&
                    (item.spriteCssClass.indexOf('e-namedSetCDB-icon') > -1)) {
                    item.hasChildren = false;
                }
            }
        }
        else {
            for (let key of Object.keys(parent.engineModule.fieldList)) {
                let type = null;
                let typeVal = null;
                if ((parent.engineModule.fieldList[key].type !== 'number' || parent.engineModule.fieldList[key].type === 'include' ||
                    parent.engineModule.fieldList[key].type === 'exclude') &&
                    (parent.engineModule.fieldList[key].aggregateType !== 'DistinctCount')) {
                    typeVal = COUNT;
                }
                else {
                    typeVal = parent.engineModule.fieldList[key].aggregateType !== undefined ?
                        (parent.engineModule.fieldList[key].aggregateType) : SUM;
                }
                type = this.parent.localeObj.getConstant(typeVal);
                fields.push({
                    index: parent.engineModule.fieldList[key].index,
                    name: parent.engineModule.fieldList[key].caption + ' (' + type + ')',
                    type: typeVal,
                    icon: FORMAT + ' ' + ICON,
                    formula: parent.engineModule.fieldList[key].formula,
                    field: key,
                    caption: parent.engineModule.fieldList[key].caption ? parent.engineModule.fieldList[key].caption : key
                });
            }
        }
        return fields;
    }
    /**
     * Triggers before menu opens.
     * @param  {BeforeOpenCloseMenuEventArgs} args
     * @returns void
     */
    beforeMenuOpen(args) {
        args.element.style.zIndex = (this.dialog.zIndex + 1).toString();
        args.element.style.display = 'inline';
    }
    /**
     * Trigger while drop node in formula field.
     * @param  {DragAndDropEventArgs} args
     * @returns void
     */
    fieldDropped(args) {
        args.cancel = true;
        let dropField = this.dialog.element.querySelector('#' + this.parentID + 'droppable');
        removeClass([dropField], 'e-copy-drop');
        removeClass([args.draggedNode.querySelector('.' + LIST_TEXT_CLASS)], SELECTED_NODE_CLASS);
        let field = args.draggedNode.getAttribute('data-field');
        if (this.parent.dataType === 'olap') {
            if (this.parent.olapEngineModule.fieldList[field] &&
                this.parent.olapEngineModule.fieldList[field].isCalculatedField) {
                field = this.parent.olapEngineModule.fieldList[field].tag;
            }
            if (args.target.id === this.parentID + 'droppable' && dropField.value === '') {
                dropField.value = field;
                dropField.focus();
            }
            else if (args.target.id === (this.parentID + 'droppable') && dropField.value !== '') {
                let textCovered;
                let currentValue = dropField.value;
                let cursorPos = dropField.selectionStart;
                let textAfterText = currentValue.substring(cursorPos, currentValue.length);
                let textBeforeText = currentValue.substring(0, cursorPos);
                textCovered = textBeforeText + field;
                dropField.value = textBeforeText + field + textAfterText;
                dropField.focus();
                dropField.setSelectionRange(textCovered.length, textCovered.length);
            }
            else {
                args.cancel = true;
            }
        }
        else {
            let type = args.draggedNode.getAttribute('data-type');
            if (args.target.id === this.parentID + 'droppable' && dropField.value === '') {
                if (type === CALC) {
                    dropField.value = args.draggedNodeData.id.toString();
                }
                else {
                    dropField.value = '"' + type + '(' + field + ')' + '"';
                }
                dropField.focus();
            }
            else if (args.target.id === (this.parentID + 'droppable') && dropField.value !== '') {
                let textCovered;
                let cursorPos = dropField.selectionStart;
                let currentValue = dropField.value;
                let textBeforeText = currentValue.substring(0, cursorPos);
                let textAfterText = currentValue.substring(cursorPos, currentValue.length);
                if (type === CALC) {
                    textCovered = textBeforeText + args.draggedNodeData.id.toString();
                    dropField.value = textBeforeText + args.draggedNodeData.id.toString() + textAfterText;
                }
                else {
                    textCovered = textBeforeText + '"' + type + '(' + field + ')' + '"';
                    dropField.value = textBeforeText + '"' + type + '(' + field + ')' + '"' + textAfterText;
                }
                dropField.focus();
                dropField.setSelectionRange(textCovered.length, textCovered.length);
            }
            else {
                args.cancel = true;
            }
        }
    }
    /**
     * To create dialog.
     * @returns void
     */
    createDialog() {
        if (document.querySelector('#' + this.parentID + 'calculateddialog') !== null) {
            remove(document.querySelector('#' + this.parentID + 'calculateddialog'));
            while (!isNullOrUndefined(document.querySelector('.' + this.parentID + 'calculatedmenu'))) {
                remove(document.querySelector('.' + this.parentID + 'calculatedmenu'));
            }
        }
        this.parent.element.appendChild(createElement('div', {
            id: this.parentID + 'calculateddialog',
            className: CALCDIALOG + ' ' + (this.parent.dataType === 'olap' ? OLAP_CALCDIALOG : '')
        }));
        let calcButtons = [
            {
                click: this.applyFormula.bind(this),
                buttonModel: {
                    content: this.parent.localeObj.getConstant('ok'),
                    isPrimary: true
                }
            },
            {
                click: this.cancelClick.bind(this),
                buttonModel: {
                    content: this.parent.localeObj.getConstant('cancel')
                }
            }
        ];
        if (this.parent.dataType === 'olap') {
            let clearButton = {
                click: this.clearFormula.bind(this),
                buttonModel: {
                    cssClass: 'e-calc-clear-btn',
                    content: this.parent.localeObj.getConstant('clear'),
                }
            };
            calcButtons.splice(0, 0, clearButton);
        }
        this.dialog = new Dialog({
            allowDragging: true,
            position: { X: 'center', Y: 'center' },
            buttons: calcButtons,
            close: this.closeDialog.bind(this),
            beforeOpen: this.beforeOpen.bind(this),
            open: () => {
                if (this.dialog.element.querySelector('#' + this.parentID + 'ddlelement')) {
                    this.dialog.element.querySelector('#' + this.parentID + 'ddlelement').focus();
                }
            },
            animationSettings: { effect: 'Zoom' },
            width: '25%',
            isModal: false,
            closeOnEscape: true,
            enableRtl: this.parent.enableRtl,
            showCloseIcon: true,
            header: this.parent.localeObj.getConstant('createCalculatedField'),
            target: document.body
        });
        this.dialog.isStringTemplate = true;
        this.dialog.appendTo('#' + this.parentID + 'calculateddialog');
    }
    cancelClick() {
        this.dialog.close();
        this.isEdit = false;
    }
    beforeOpen(args) {
        // this.dialog.element.querySelector('.e-dlg-header').innerHTML = this.parent.localeObj.getConstant('createCalculatedField');
        this.dialog.element.querySelector('.e-dlg-header').
            setAttribute('title', this.parent.localeObj.getConstant('createCalculatedField'));
    }
    closeDialog(args) {
        if (this.parent.getModuleName() === 'pivotfieldlist') {
            this.parent.axisFieldModule.render();
            if (this.parent.renderMode !== 'Fixed') {
                addClass([this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], ICON_HIDDEN);
                this.parent.dialogRenderer.fieldListDialog.show();
            }
        }
        this.treeObj.destroy();
        this.dialog.destroy();
        this.newFields = null;
        remove(document.getElementById(this.parentID + 'calculateddialog'));
        while (!isNullOrUndefined(document.querySelector('.' + this.parentID + 'calculatedmenu'))) {
            remove(document.querySelector('.' + this.parentID + 'calculatedmenu'));
        }
    }
    /* tslint:disable */
    /**
     * To render dialog elements.
     * @returns void
     */
    renderDialogElements() {
        let outerDiv = createElement('div', {
            id: this.parentID + 'outerDiv',
            className: (this.parent.dataType === 'olap' ? OLAP_CALCOUTERDIV + ' ' : '') + CALCOUTERDIV
        });
        let olapFieldTreeDiv = createElement('div', { id: this.parentID + 'Olap_Tree_Div', className: 'e-olap-field-tree-div' });
        let olapCalcDiv = createElement('div', { id: this.parentID + 'Olap_Calc_Div', className: 'e-olap-calculated-div' });
        if (this.parent.getModuleName() === 'pivotfieldlist' && this.parent.
            dialogRenderer.parentElement.querySelector('.' + FORMULA) !== null && this.parent.isAdaptive) {
            let accordDiv = createElement('div', { id: this.parentID + 'accordDiv', className: CALCACCORD });
            outerDiv.appendChild(accordDiv);
            let buttonDiv = createElement('div', { id: this.parentID + 'buttonDiv', className: CALCBUTTONDIV });
            let addBtn = createElement('button', {
                id: this.parentID + 'addBtn', innerHTML: this.parent.localeObj.getConstant('add'),
                className: CALCADDBTN
            });
            let cancelBtn = createElement('button', {
                id: this.parentID + 'cancelBtn', innerHTML: this.parent.localeObj.getConstant('cancel'),
                className: CALCCANCELBTN
            });
            buttonDiv.appendChild(cancelBtn);
            buttonDiv.appendChild(addBtn);
            outerDiv.appendChild(buttonDiv);
        }
        else {
            if (!this.parent.isAdaptive && this.parent.dataType === 'olap') {
                let formulaTitle = createElement('div', {
                    className: PIVOT_FIELD_TITLE_CLASS, id: this.parentID + '_' + 'FieldNameTitle',
                    innerHTML: this.parent.localeObj.getConstant('fieldTitle')
                });
                olapCalcDiv.appendChild(formulaTitle);
            }
            let inputDiv = createElement('div', { id: this.parentID + 'outerDiv', className: CALCINPUTDIV });
            let inputObj = createElement('input', {
                id: this.parentID + 'ddlelement',
                attrs: { 'type': 'text' },
                className: CALCINPUT
            });
            inputDiv.appendChild(inputObj);
            (this.parent.dataType === 'olap' && !this.parent.isAdaptive ? olapCalcDiv.appendChild(inputDiv) : outerDiv.appendChild(inputDiv));
            let wrapDiv = createElement('div', { id: this.parentID + 'control_wrapper', className: TREEVIEWOUTER });
            if (!this.parent.isAdaptive) {
                let fieldTitle = createElement('div', {
                    className: PIVOT_ALL_FIELD_TITLE_CLASS,
                    innerHTML: (this.parent.dataType === 'olap' ? this.parent.localeObj.getConstant('allFields') :
                        this.parent.localeObj.getConstant('formulaField'))
                });
                if (this.parent.dataType === 'olap') {
                    let headerWrapperDiv = createElement('div', { className: PIVOT_ALL_FIELD_TITLE_CLASS + '-wrapper' });
                    headerWrapperDiv.appendChild(fieldTitle);
                    let spanElement = createElement('span', {
                        attrs: {
                            'tabindex': '0',
                            'aria-disabled': 'false',
                            'aria-label': this.parent.localeObj.getConstant('fieldTooltip'),
                        },
                        className: ICON + ' ' + CALC_INFO
                    });
                    headerWrapperDiv.appendChild(spanElement);
                    let tooltip = new Tooltip({
                        content: this.parent.localeObj.getConstant('fieldTooltip'),
                        position: (this.parent.enableRtl ? 'RightCenter' : 'LeftCenter'),
                        target: '.' + CALC_INFO,
                        offsetY: (this.parent.enableRtl ? -10 : -10),
                        width: 220
                    });
                    tooltip.appendTo(headerWrapperDiv);
                    wrapDiv.appendChild(headerWrapperDiv);
                }
                else {
                    outerDiv.appendChild(fieldTitle);
                }
            }
            let treeOuterDiv = createElement('div', { className: TREEVIEW + '-outer-div' });
            wrapDiv.appendChild(treeOuterDiv);
            treeOuterDiv.appendChild(createElement('div', { id: this.parentID + 'tree', className: TREEVIEW }));
            (this.parent.dataType === 'olap' && !this.parent.isAdaptive ? olapFieldTreeDiv.appendChild(wrapDiv) : outerDiv.appendChild(wrapDiv));
            if (!this.parent.isAdaptive) {
                let formulaTitle = createElement('div', {
                    className: PIVOT_FORMULA_TITLE_CLASS,
                    innerHTML: (this.parent.dataType === 'olap' ? this.parent.localeObj.getConstant('expressionField') :
                        this.parent.localeObj.getConstant('formula'))
                });
                (this.parent.dataType === 'olap' ? olapCalcDiv.appendChild(formulaTitle) : outerDiv.appendChild(formulaTitle));
            }
            let dropDiv = createElement('textarea', {
                id: this.parentID + 'droppable',
                className: FORMULA,
                attrs: {
                    'placeholder': this.parent.isAdaptive ? this.parent.localeObj.getConstant('dropTextMobile') :
                        (this.parent.dataType === 'olap' ? this.parent.localeObj.getConstant('olapDropText') :
                            this.parent.localeObj.getConstant('dropText'))
                }
            });
            (this.parent.dataType === 'olap' && !this.parent.isAdaptive ? olapCalcDiv.appendChild(dropDiv) : outerDiv.appendChild(dropDiv));
            if (this.parent.isAdaptive) {
                let buttonDiv = createElement('div', { id: this.parentID + 'buttonDiv', className: CALCBUTTONDIV });
                let okBtn = createElement('button', {
                    id: this.parentID + 'okBtn', innerHTML: this.parent.localeObj.getConstant('apply'),
                    className: CALCOKBTN
                });
                buttonDiv.appendChild(okBtn);
                outerDiv.appendChild(buttonDiv);
            }
            if (this.parent.dataType === 'olap') {
                if (!this.parent.isAdaptive) {
                    let memberTypeTitle = createElement('div', {
                        className: OLAP_MEMBER_TITLE_CLASS,
                        innerHTML: this.parent.localeObj.getConstant('memberType')
                    });
                    olapCalcDiv.appendChild(memberTypeTitle);
                }
                let memberTypeDrop = createElement('div', { id: this.parentID + 'Member_Type_Div', className: CALC_MEMBER_TYPE_DIV });
                (this.parent.isAdaptive ? outerDiv.appendChild(memberTypeDrop) : olapCalcDiv.appendChild(memberTypeDrop));
                if (!this.parent.isAdaptive) {
                    let hierarchyTitle = createElement('div', {
                        className: OLAP_HIERARCHY_TITLE_CLASS,
                        innerHTML: this.parent.localeObj.getConstant('selectedHierarchy')
                    });
                    olapCalcDiv.appendChild(hierarchyTitle);
                }
                let hierarchyDrop = createElement('div', { id: this.parentID + 'Hierarchy_List_Div', className: CALC_HIERARCHY_LIST_DIV });
                (this.parent.isAdaptive ? outerDiv.appendChild(hierarchyDrop) : olapCalcDiv.appendChild(hierarchyDrop));
                if (!this.parent.isAdaptive) {
                    let formatTitle = createElement('div', {
                        className: OLAP_FORMAT_TITLE_CLASS,
                        innerHTML: this.parent.localeObj.getConstant('formatString')
                    });
                    olapCalcDiv.appendChild(formatTitle);
                }
                let formatDrop = createElement('div', { id: this.parentID + 'Format_Div', className: CALC_FORMAT_TYPE_DIV });
                (this.parent.isAdaptive ? outerDiv.appendChild(formatDrop) : olapCalcDiv.appendChild(formatDrop));
                let customFormatDiv = createElement('div', { id: this.parentID + 'custom_Format_Div', className: CALC_CUSTOM_FORMAT_INPUTDIV });
                let customFormatObj = createElement('input', {
                    id: this.parentID + 'Custom_Format_Element',
                    attrs: { 'type': 'text' },
                    className: CALC_FORMAT_INPUT
                });
                customFormatDiv.appendChild(customFormatObj);
                olapCalcDiv.appendChild(customFormatDiv);
                (this.parent.isAdaptive ? outerDiv.appendChild(customFormatDiv) : olapCalcDiv.appendChild(customFormatDiv));
                if (this.parent.getModuleName() === 'pivotfieldlist' && this.parent.
                    dialogRenderer.parentElement.querySelector('.' + FORMULA) === null && this.parent.isAdaptive) {
                    let okBtn = outerDiv.querySelector('.' + CALCOKBTN);
                    outerDiv.appendChild(okBtn);
                }
                else {
                    outerDiv.appendChild(olapFieldTreeDiv);
                    outerDiv.appendChild(olapCalcDiv);
                }
            }
        }
        return outerDiv;
    }
    /* tslint:enable */
    /**
     * To create calculated field adaptive layout.
     * @returns void
     */
    renderAdaptiveLayout() {
        if (document.querySelector('#' + this.parentID + 'droppable')) {
            this.formulaText = document.querySelector('#' + this.parentID + 'droppable').value;
            this.fieldText = this.inputObj.value;
        }
        this.renderMobileLayout(this.parent.dialogRenderer.adaptiveElement);
    }
    /**
     * To create treeview.
     * @returns void
     */
    createOlapDropElements() {
        let dialogElement = (this.parent.isAdaptive ?
            this.parent.dialogRenderer.parentElement : this.dialog.element);
        let mData = [];
        let fData = [];
        let fieldData = [];
        let memberTypeData = ['Measure', 'Dimension'];
        let formatStringData = ['Standard', 'Currency', 'Percent', 'Custom'];
        for (let type of memberTypeData) {
            mData.push({ value: type, text: this.parent.localeObj.getConstant(type) });
        }
        for (let format of formatStringData) {
            fData.push({ value: format, text: this.parent.localeObj.getConstant(format) });
        }
        let fields = PivotUtil.getClonedData(this.parent.olapEngineModule.fieldListData);
        for (let item of fields) {
            if (item.spriteCssClass &&
                (item.spriteCssClass.indexOf('e-attributeCDB-icon') > -1 ||
                    item.spriteCssClass.indexOf('e-hierarchyCDB-icon') > -1)) {
                fieldData.push({ value: item.id, text: item.caption });
            }
        }
        let memberTypeObj = new DropDownList({
            dataSource: mData, enableRtl: this.parent.enableRtl,
            fields: { value: 'value', text: 'text' }, index: 0,
            cssClass: MEMBER_OPTIONS_CLASS, width: '100%',
            change(args) {
                hierarchyListObj.enabled = args.value === 'Dimension' ? true : false;
                hierarchyListObj.dataBind();
            }
        });
        memberTypeObj.isStringTemplate = true;
        memberTypeObj.appendTo(dialogElement.querySelector('#' + this.parentID + 'Member_Type_Div'));
        let hierarchyListObj = new DropDownList({
            dataSource: fieldData, enableRtl: this.parent.enableRtl,
            allowFiltering: true, enabled: false,
            filterBarPlaceholder: this.parent.localeObj.getConstant('example') + ' ' + fieldData[0].text.toString(),
            fields: { value: 'value', text: 'text' }, index: 0,
            cssClass: MEMBER_OPTIONS_CLASS, width: '100%'
        });
        hierarchyListObj.isStringTemplate = true;
        hierarchyListObj.appendTo(dialogElement.querySelector('#' + this.parentID + 'Hierarchy_List_Div'));
        let formatStringObj = new DropDownList({
            dataSource: fData, enableRtl: this.parent.enableRtl,
            fields: { value: 'value', text: 'text' }, index: 0,
            cssClass: MEMBER_OPTIONS_CLASS, width: '100%',
            change(args) {
                customerFormatObj.enabled = args.value === 'Custom' ? true : false;
                customerFormatObj.dataBind();
            }
        });
        formatStringObj.isStringTemplate = true;
        formatStringObj.appendTo(dialogElement.querySelector('#' + this.parentID + 'Format_Div'));
        let customerFormatObj = new MaskedTextBox({
            placeholder: this.parent.localeObj.getConstant('customFormat'),
            enabled: false
        });
        customerFormatObj.isStringTemplate = true;
        customerFormatObj.appendTo('#' + this.parentID + 'Custom_Format_Element');
    }
    /**
     * To create treeview.
     * @returns void
     */
    createTreeView() {
        if (this.parent.dataType === 'olap') {
            this.treeObj = new TreeView({
                /* tslint:disable-next-line:max-line-length */
                fields: { dataSource: this.getFieldListData(this.parent), id: 'id', text: 'caption', parentID: 'pid', iconCss: 'spriteCssClass' },
                allowDragAndDrop: true,
                enableRtl: this.parent.enableRtl,
                nodeDragStart: this.dragStart.bind(this),
                nodeDragging: (e) => {
                    if (e.event.target && e.event.target.classList.contains(FORMULA)) {
                        removeClass([e.clonedNode], NO_DRAG_CLASS);
                        addClass([e.event.target], 'e-copy-drop');
                    }
                    else {
                        addClass([e.clonedNode], NO_DRAG_CLASS);
                        removeClass([e.event.target], 'e-copy-drop');
                        e.dropIndicator = 'e-no-drop';
                        addClass([e.clonedNode.querySelector('.' + ICON)], 'e-icon-expandable');
                        removeClass([e.clonedNode.querySelector('.' + ICON)], 'e-list-icon');
                    }
                },
                nodeClicked: this.fieldClickHandler.bind(this),
                nodeSelected: (args) => {
                    if (args.node.getAttribute('data-type') === CALC) {
                        this.displayMenu(args.node);
                    }
                    else {
                        removeClass([args.node], 'e-active');
                        args.cancel = true;
                    }
                },
                nodeDragStop: this.fieldDropped.bind(this),
                drawNode: this.drawTreeNode.bind(this),
                nodeExpanding: this.updateNodeIcon.bind(this),
                nodeCollapsed: this.updateNodeIcon.bind(this),
                sortOrder: 'None',
            });
        }
        else {
            this.treeObj = new TreeView({
                fields: { dataSource: this.getFieldListData(this.parent), id: 'formula', text: 'name', iconCss: 'icon' },
                allowDragAndDrop: true,
                enableRtl: this.parent.enableRtl,
                nodeCollapsing: this.nodeCollapsing.bind(this),
                nodeDragStart: this.dragStart.bind(this),
                nodeClicked: this.fieldClickHandler.bind(this),
                nodeDragStop: this.fieldDropped.bind(this),
                drawNode: this.drawTreeNode.bind(this),
                sortOrder: 'Ascending'
            });
        }
        this.treeObj.isStringTemplate = true;
        this.treeObj.appendTo('#' + this.parentID + 'tree');
    }
    updateNodeIcon(args) {
        if (args.node && args.node.querySelector('.e-list-icon') &&
            args.node.querySelector('.e-icon-expandable.e-process') &&
            (args.node.querySelector('.e-list-icon').className.indexOf('e-folderCDB-icon') > -1)) {
            let node = args.node.querySelector('.e-list-icon');
            removeClass([node], 'e-folderCDB-icon');
            addClass([node], 'e-folderCDB-open-icon');
        }
        else if (args.node && args.node.querySelector('.e-list-icon') &&
            args.node.querySelector('.e-icon-expandable') &&
            (args.node.querySelector('.e-list-icon').className.indexOf('e-folderCDB-open-icon') > -1)) {
            let node = args.node.querySelector('.e-list-icon');
            removeClass([node], 'e-folderCDB-open-icon');
            addClass([node], 'e-folderCDB-icon');
        }
        else {
            let curTreeData = this.treeObj.fields.dataSource;
            let fieldListData = curTreeData;
            let childNodes = [];
            for (let item of fieldListData) {
                if (item.pid === args.nodeData.id.toString()) {
                    childNodes.push(item);
                }
            }
            if (childNodes.length === 0) {
                this.parent.olapEngineModule.calcChildMembers = [];
                this.parent.olapEngineModule.getCalcChildMembers(this.parent.dataSourceSettings, args.nodeData.id.toString());
                childNodes = this.parent.olapEngineModule.calcChildMembers;
                this.parent.olapEngineModule.calcChildMembers = [];
                for (let node of childNodes) {
                    node.pid = args.nodeData.id.toString();
                    node.hasChildren = false;
                    node.spriteCssClass = 'e-level-members';
                    node.caption = (node.caption === '' ? this.parent.localeObj.getConstant('blank') : node.caption);
                    curTreeData.push(node);
                }
                this.treeObj.addNodes(childNodes, args.node);
            }
            else {
                return;
            }
        }
    }
    nodeCollapsing(args) {
        args.cancel = true;
    }
    dragStart(args) {
        let isDrag = false;
        let dragItem = args.clonedNode;
        if (dragItem && ((this.parent.dataType === 'olap' &&
            (dragItem.querySelector('.e-calc-dimension-icon,.e-calc-measure-icon,.e-measure-icon') ||
                dragItem.querySelector('.e-dimensionCDB-icon,.e-attributeCDB-icon,.e-hierarchyCDB-icon') ||
                dragItem.querySelector('.e-level-members,.e-namedSetCDB-icon'))) || (this.parent.dataType === 'pivot' &&
            args.event.target.classList.contains(DRAG_CLASS)))) {
            isDrag = true;
        }
        if (isDrag) {
            addClass([args.draggedNode.querySelector('.' + LIST_TEXT_CLASS)], SELECTED_NODE_CLASS);
            addClass([dragItem], PIVOTCALC);
            dragItem.style.zIndex = (this.dialog.zIndex + 1).toString();
            dragItem.style.display = 'inline';
        }
        else {
            args.cancel = true;
        }
    }
    /**
     * Trigger before treeview text append.
     * @param  {DrawNodeEventArgs} args
     * @returns void
     */
    drawTreeNode(args) {
        if (this.parent.dataType === 'olap') {
            if (args.node.querySelector('.e-measure-icon')) {
                args.node.querySelector('.e-list-icon').style.display = 'none';
            }
            let field = args.nodeData;
            args.node.setAttribute('data-field', field.id);
            args.node.setAttribute('data-caption', field.caption);
            let liTextElement = args.node.querySelector('.' + TEXT_CONTENT_CLASS);
            if (args.nodeData && args.nodeData.type === CALC &&
                liTextElement && args.node.querySelector('.e-list-icon.e-calc-member')) {
                args.node.setAttribute('data-type', field.type);
                args.node.setAttribute('data-membertype', field.fieldType);
                args.node.setAttribute('data-hierarchy', field.parentHierarchy ? field.parentHierarchy : '');
                args.node.setAttribute('data-formula', field.formula);
                let formatStringData = ['Standard', 'Currency', 'Percent'];
                let formatString;
                formatString = (field.formatString ? formatStringData.indexOf(field.formatString) > -1 ?
                    field.formatString : 'Custom' : '');
                args.node.setAttribute('data-formatString', formatString);
                args.node.setAttribute('data-customString', (formatString === 'Custom' ? field.formatString : ''));
                // if (!this.parent.isAdaptive) {
                //     let editElement: Node = args.node.querySelector('.e-list-icon.e-calc-member').cloneNode(true);
                //     let calcClasses: string[] = ['e-calc-measure-icon', 'e-calc-dimension-icon', 'e-calc-member'];
                //     removeClass([editElement as Element], calcClasses);
                //     addClass([editElement as Element], cls.CALC_EDIT);
                //     (editElement as Element).setAttribute('title', this.parent.localeObj.getConstant('edit'));
                //     liTextElement.insertBefore(editElement, args.node.querySelector('.e-list-icon'));
                // }
            }
            if (this.parent.isAdaptive) {
                let liTextElement = args.node.querySelector('.' + TEXT_CONTENT_CLASS);
                if (args.node && args.node.querySelector('.e-list-icon') && liTextElement) {
                    let liIconElement = args.node.querySelector('.e-list-icon');
                    liTextElement.insertBefore(liIconElement, args.node.querySelector('.e-list-text'));
                }
                if (args.node && args.node.querySelector('.e-calcMemberGroupCDB,.e-measureGroupCDB-icon,.e-folderCDB-icon')) {
                    args.node.querySelector('.e-checkbox-wrapper').style.display = 'none';
                }
                if (args.node && args.node.querySelector('.e-level-members')) {
                    args.node.querySelector('.e-list-icon').style.display = 'none';
                }
            }
        }
        else {
            let field = args.nodeData.field;
            args.node.setAttribute('data-field', field);
            args.node.setAttribute('data-caption', args.nodeData.caption);
            args.node.setAttribute('data-type', args.nodeData.type);
            let dragElement = createElement('span', {
                attrs: { 'tabindex': '-1', 'aria-disabled': 'false', 'title': this.parent.localeObj.getConstant('dragField') },
                className: ICON + ' e-drag'
            });
            prepend([dragElement], args.node.querySelector('.' + TEXT_CONTENT_CLASS));
            append([args.node.querySelector('.' + FORMAT)], args.node.querySelector('.' + TEXT_CONTENT_CLASS));
            // if (this.parent.engineModule.fieldList[field].type !== 'number' &&
            //     this.parent.engineModule.fieldList[field].aggregateType !== CALC) {
            //     removeClass([args.node.querySelector('.' + cls.FORMAT)], cls.ICON);
            // } else {
            args.node.querySelector('.' + FORMAT).setAttribute('title', this.parent.localeObj.getConstant('format'));
            // }
            if (this.parent.engineModule.fieldList[field].aggregateType === CALC) {
                args.node.querySelector('.' + FORMAT).setAttribute('title', this.parent.localeObj.getConstant('edit'));
                addClass([args.node.querySelector('.' + FORMAT)], CALC_EDIT);
                removeClass([args.node.querySelector('.' + FORMAT)], FORMAT);
            }
        }
    }
    /**
     * To create radio buttons.
     * @param  {string} key
     * @returns HTMLElement
     */
    createTypeContainer(key) {
        let wrapDiv = createElement('div', { id: this.parentID + 'control_wrapper', className: TREEVIEWOUTER });
        let type = this.parent.engineModule.fieldList[key].type !== 'number' ? [COUNT, DISTINCTCOUNT] :
            [SUM, COUNT, AVG, MIN, MAX, DISTINCTCOUNT, PRODUCT, STDEV, STDEVP, VAR, VARP];
        for (let i = 0; i < type.length; i++) {
            let input = createElement('input', {
                id: this.parentID + 'radio' + key + type[i],
                attrs: { 'type': 'radio', 'data-ftxt': key, 'data-value': type[i] },
                className: CALCRADIO
            });
            wrapDiv.appendChild(input);
        }
        return wrapDiv;
    }
    /**
     * To get Accordion Data.
     * @param  {PivotView | PivotFieldList} parent
     * @returns AccordionItemModel
     */
    getAccordionData(parent) {
        let data = [];
        let keys = Object.keys(parent.engineModule.fieldList);
        for (let index = 0, i = keys.length; index < i; index++) {
            let key = keys[index];
            data.push({
                header: '<input id=' + this.parentID + '_' + index + ' class=' + CALCCHECK + ' type="checkbox" data-field=' +
                    key + ' data-caption=' + this.parent.engineModule.fieldList[key].caption + ' data-type=' +
                    this.parent.engineModule.fieldList[key].type + '/>',
                content: this.parent.engineModule.fieldList[key].aggregateType === CALC ? '' :
                    this.createTypeContainer(key).outerHTML
            });
        }
        return data;
    }
    /**
     * To render mobile layout.
     * @param  {Tab} tabObj
     * @returns void
     */
    renderMobileLayout(tabObj) {
        tabObj.items[4].content = this.renderDialogElements().outerHTML;
        tabObj.dataBind();
        if (this.parent.dataType === 'olap' && this.parent.isAdaptive) {
            this.createOlapDropElements();
        }
        let cancelBtn = new Button({ cssClass: FLAT, isPrimary: true });
        cancelBtn.isStringTemplate = true;
        cancelBtn.appendTo('#' + this.parentID + 'cancelBtn');
        if (cancelBtn.element) {
            cancelBtn.element.onclick = this.cancelBtnClick.bind(this);
        }
        if (this.parent.
            dialogRenderer.parentElement.querySelector('.' + FORMULA) !== null && this.parent.isAdaptive) {
            let okBtn = new Button({ cssClass: FLAT + ' ' + OUTLINE_CLASS, isPrimary: true });
            okBtn.isStringTemplate = true;
            okBtn.appendTo('#' + this.parentID + 'okBtn');
            this.inputObj = new MaskedTextBox({
                placeholder: this.parent.localeObj.getConstant('fieldName')
            });
            this.inputObj.isStringTemplate = true;
            this.inputObj.appendTo('#' + this.parentID + 'ddlelement');
            if (this.formulaText !== null && this.parent.
                dialogRenderer.parentElement.querySelector('#' + this.parentID + 'droppable') !== null) {
                let drop = this.parent.
                    dialogRenderer.parentElement.querySelector('#' + this.parentID + 'droppable');
                drop.value = this.formulaText;
            }
            if (this.fieldText !== null && this.parent.
                dialogRenderer.parentElement.querySelector('.' + CALCINPUT) !== null) {
                this.parent.
                    dialogRenderer.parentElement.querySelector('.' + CALCINPUT).value = this.fieldText;
                this.inputObj.value = this.fieldText;
            }
            if (okBtn.element) {
                okBtn.element.onclick = this.applyFormula.bind(this);
            }
        }
        else if (this.parent.isAdaptive) {
            let addBtn = new Button({ cssClass: FLAT, isPrimary: true });
            addBtn.isStringTemplate = true;
            addBtn.appendTo('#' + this.parentID + 'addBtn');
            if (this.parent.dataType === 'olap') {
                this.treeObj = new TreeView({
                    /* tslint:disable-next-line:max-line-length */
                    fields: { dataSource: this.getFieldListData(this.parent), id: 'id', text: 'caption', parentID: 'pid', iconCss: 'spriteCssClass' },
                    showCheckBox: true,
                    autoCheck: false,
                    sortOrder: 'None',
                    enableRtl: this.parent.enableRtl,
                    drawNode: this.drawTreeNode.bind(this),
                    nodeExpanding: this.updateNodeIcon.bind(this),
                    nodeCollapsed: this.updateNodeIcon.bind(this)
                });
                this.treeObj.isStringTemplate = true;
                this.treeObj.appendTo('#' + this.parentID + 'accordDiv');
            }
            else {
                let accordion = new Accordion({
                    items: this.getAccordionData(this.parent),
                    enableRtl: this.parent.enableRtl,
                    expanding: this.accordionExpand.bind(this),
                });
                accordion.isStringTemplate = true;
                accordion.appendTo('#' + this.parentID + 'accordDiv');
                this.updateType();
            }
            if (addBtn.element) {
                addBtn.element.onclick = this.addBtnClick.bind(this);
            }
        }
    }
    accordionExpand(args) {
        if (args.element.querySelectorAll('.e-radio-wrapper').length === 0) {
            let keys = Object.keys(this.parent.engineModule.fieldList);
            for (let index = 0, i = keys.length; index < i; index++) {
                let key = keys[index];
                let type = this.parent.engineModule.fieldList[key].type !== 'number' ? [COUNT, DISTINCTCOUNT] :
                    [SUM, COUNT, AVG, MIN, MAX, DISTINCTCOUNT, PRODUCT, STDEV, STDEVP, VAR, VARP];
                let radiobutton;
                if (key === args.element.querySelector('[data-field').getAttribute('data-field')) {
                    for (let i = 0; i < type.length; i++) {
                        radiobutton = new RadioButton({
                            label: this.parent.localeObj.getConstant(type[i]),
                            name: AGRTYPE + key,
                            checked: args.element.querySelector('[data-type').getAttribute('data-type') === type[i],
                            change: this.onChange.bind(this),
                        });
                        radiobutton.isStringTemplate = true;
                        radiobutton.appendTo('#' + this.parentID + 'radio' + key + type[i]);
                    }
                }
            }
        }
    }
    onChange(args) {
        let type = args.event.target.parentElement.querySelector('.e-label')
            .innerText;
        let field = args.event.target.closest('.e-acrdn-item').
            querySelector('[data-field').getAttribute('data-caption');
        args.event.target.
            closest('.e-acrdn-item').querySelector('.e-label').
            innerText = field + ' (' + type + ')';
        args.event.target.closest('.e-acrdn-item').
            querySelector('[data-type').setAttribute('data-type', args.event.target.getAttribute('data-value'));
    }
    updateType() {
        let keys = Object.keys(this.parent.engineModule.fieldList);
        for (let index = 0, i = keys.length; index < i; index++) {
            let key = keys[index];
            let type = null;
            if ((this.parent.engineModule.fieldList[key].type !== 'number' ||
                this.parent.engineModule.fieldList[key].type === 'include' ||
                this.parent.engineModule.fieldList[key].type === 'exclude') &&
                (this.parent.engineModule.fieldList[key].aggregateType !== 'DistinctCount')) {
                type = COUNT;
            }
            else {
                type = this.parent.engineModule.fieldList[key].aggregateType !== undefined ?
                    this.parent.engineModule.fieldList[key].aggregateType : SUM;
            }
            let checkbox = new CheckBox({
                label: this.parent.engineModule.fieldList[key].caption + ' (' + this.parent.localeObj.getConstant(type) + ')'
            });
            checkbox.isStringTemplate = true;
            checkbox.appendTo('#' + this.parentID + '_' + index);
            document.querySelector('#' + this.parentID + '_' + index).setAttribute('data-field', key);
            document.querySelector('#' + this.parentID + '_' + index).setAttribute('data-type', type);
        }
    }
    /**
     * Trigger while click cancel button.
     * @returns void
     */
    cancelBtnClick() {
        this.renderMobileLayout(this.parent.dialogRenderer.adaptiveElement);
    }
    /**
     * Trigger while click add button.
     * @returns void
     */
    addBtnClick() {
        let fieldText = '';
        let field = null;
        let type = null;
        if (this.parent.dataType === 'pivot') {
            let node = document.querySelectorAll('.e-accordion .e-check');
            for (let i = 0; i < node.length; i++) {
                field = node[i].parentElement.querySelector('[data-field]').getAttribute('data-field');
                type = node[i].parentElement.querySelector('[data-field]').getAttribute('data-type');
                if (type.indexOf(CALC) === -1) {
                    fieldText = fieldText + ('"' + type + '(' + field + ')' + '"');
                }
                else {
                    for (let j = 0; j < this.parent.dataSourceSettings.calculatedFieldSettings.length; j++) {
                        if (this.parent.dataSourceSettings.calculatedFieldSettings[j].name === field) {
                            fieldText = fieldText + this.parent.dataSourceSettings.calculatedFieldSettings[j].formula;
                            break;
                        }
                    }
                }
            }
        }
        else {
            let nodes = this.treeObj.getAllCheckedNodes();
            let olapEngine = this.parent.olapEngineModule;
            for (let item of nodes) {
                fieldText = fieldText + (olapEngine.fieldList[item] &&
                    olapEngine.fieldList[item].type === CALC ? olapEngine.fieldList[item].tag : item);
            }
        }
        this.formulaText = this.formulaText !== null ? (this.formulaText + fieldText) : fieldText;
        this.renderMobileLayout(this.parent.dialogRenderer.adaptiveElement);
    }
    /**
     * To create calculated field dialog elements.
     * @returns void
     * @hidden
     */
    createCalculatedFieldDialog() {
        if (this.parent.isAdaptive && this.parent.getModuleName() === 'pivotfieldlist') {
            this.renderAdaptiveLayout();
        }
        else if (!this.parent.isAdaptive) {
            this.renderDialogLayout();
            this.dialog.element.style.top = parseInt(this.dialog.element.style.top, 10) < 0 ? '0px' : this.dialog.element.style.top;
        }
    }
    /**
     * To create calculated field desktop layout.
     * @returns void
     */
    renderDialogLayout() {
        this.newFields =
            extend([], this.parent.dataSourceSettings.calculatedFieldSettings, null, true);
        this.createDialog();
        this.dialog.content = this.renderDialogElements();
        this.dialog.refresh();
        this.inputObj = new MaskedTextBox({
            placeholder: this.parent.localeObj.getConstant('fieldName')
        });
        this.inputObj.isStringTemplate = true;
        this.inputObj.appendTo('#' + this.parentID + 'ddlelement');
        if (this.parent.dataType === 'olap' && !this.parent.isAdaptive) {
            this.createOlapDropElements();
        }
        this.createTreeView();
        this.createMenu();
        this.droppable = new Droppable(this.dialog.element.querySelector('#' + this.parentID + 'droppable'));
        this.keyboardEvents = new KeyboardEvents(this.parent.calculatedFieldModule.dialog.element, {
            keyAction: this.keyActionHandler.bind(this),
            keyConfigs: { moveRight: 'rightarrow', enter: 'enter' },
            eventName: 'keydown'
        });
    }
    /**
     * Creates the error dialog for the unexpected action done.
     * @method createConfirmDialog
     * @return {void}
     * @hidden
     */
    createConfirmDialog(title, description) {
        let errorDialog = createElement('div', {
            id: this.parentID + '_ErrorDialog',
            className: ERROR_DIALOG_CLASS
        });
        this.parent.element.appendChild(errorDialog);
        this.confirmPopUp = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: false,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            width: 'auto',
            height: 'auto',
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    click: this.replaceFormula.bind(this),
                    buttonModel: {
                        cssClass: OK_BUTTON_CLASS + ' ' + OUTLINE_CLASS,
                        content: this.parent.localeObj.getConstant('ok'), isPrimary: true
                    }
                },
                {
                    click: this.removeErrorDialog.bind(this),
                    buttonModel: {
                        cssClass: CANCEL_BUTTON_CLASS,
                        content: this.parent.localeObj.getConstant('cancel'), isPrimary: true
                    }
                }
            ],
            header: title,
            content: description,
            isModal: true,
            visible: true,
            closeOnEscape: true,
            target: document.body,
            close: this.removeErrorDialog.bind(this),
        });
        this.confirmPopUp.isStringTemplate = true;
        this.confirmPopUp.appendTo(errorDialog);
        // this.confirmPopUp.element.querySelector('.e-dlg-header').innerHTML = title;
    }
    replaceFormula() {
        let report = this.parent.dataSourceSettings;
        let dropField = document.querySelector('#' + this.parentID + 'droppable');
        if (this.parent.dataType === 'olap') {
            let dialogElement = this.dialog.element;
            /* tslint:disable */
            let customFormat = getInstance(dialogElement.querySelector('#' + this.parentID + 'Custom_Format_Element'), MaskedTextBox);
            let formatDrop = getInstance(dialogElement.querySelector('#' + this.parentID + 'Format_Div'), DropDownList);
            let memberTypeDrop = getInstance(dialogElement.querySelector('#' + this.parentID + 'Member_Type_Div'), DropDownList);
            let hierarchyDrop = getInstance(dialogElement.querySelector('#' + this.parentID + 'Hierarchy_List_Div'), DropDownList);
            /* tslint:enable */
            for (let j = 0; j < report.calculatedFieldSettings.length; j++) {
                if (report.calculatedFieldSettings[j].name === this.inputObj.value) {
                    if (memberTypeDrop.value === 'Dimension') {
                        report.calculatedFieldSettings[j].hierarchyUniqueName = hierarchyDrop.value;
                    }
                    report.calculatedFieldSettings[j].formatString =
                        (formatDrop.value === 'Custom' ? customFormat.value : formatDrop.value);
                    report.calculatedFieldSettings[j].formula = dropField.value;
                    this.parent.lastCalcFieldInfo = report.calculatedFieldSettings[j];
                    break;
                }
            }
        }
        else {
            for (let i = 0; i < report.values.length; i++) {
                if (report.values[i].type === CALC && report.values[i].name === this.inputObj.value) {
                    for (let j = 0; j < report.calculatedFieldSettings.length; j++) {
                        if (report.calculatedFieldSettings[j].name === this.inputObj.value) {
                            report.calculatedFieldSettings[j].formula = dropField.value;
                            this.parent.lastCalcFieldInfo = report.calculatedFieldSettings[j];
                        }
                    }
                }
            }
        }
        this.addFormula(report, this.inputObj.value);
        this.removeErrorDialog();
    }
    removeErrorDialog() {
        if (document.getElementById(this.parentID + '_ErrorDialog')) {
            remove(document.getElementById(this.parentID + '_ErrorDialog').parentElement);
        }
    }
    /**
     * To add event listener.
     * @returns void
     * @hidden
     */
    addEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(initCalculatedField, this.createCalculatedFieldDialog, this);
    }
    /**
     * To remove event listener.
     * @returns void
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(initCalculatedField, this.createCalculatedFieldDialog);
    }
    /**
     * To destroy the calculated field dialog
     * @returns void
     * @hidden
     */
    destroy() {
        this.removeEventListener();
    }
}

PivotFieldList.Inject(CalculatedField);
/**
 * Module for Field List rendering
 */
/** @hidden */
class FieldList {
    /** Constructor for Field List module */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * For internal use only - Get the module name.
     * @private
     */
    getModuleName() {
        return 'fieldlist';
    }
    initiateModule() {
        this.element = createElement('div', {
            id: this.parent.element.id + '_PivotFieldList',
            styles: 'position:' + (this.parent.enableRtl ? 'static' : 'absolute') + ';height:0;width:' + this.parent.element.style.width +
                ';display:none'
        });
        this.parent.element.parentElement.setAttribute('id', 'ContainerWrapper');
        this.parent.element.parentElement.appendChild(this.element);
        this.parent.element.parentElement.appendChild(this.parent.element);
        this.parent.pivotFieldListModule = new PivotFieldList({
            dataSourceSettings: {
                providerType: this.parent.dataSourceSettings.providerType,
                rows: [],
                columns: [],
                values: [],
                filters: []
            },
            spinnerTemplate: this.parent.spinnerTemplate,
            allowDeferLayoutUpdate: this.parent.allowDeferLayoutUpdate,
            renderMode: 'Popup',
            allowCalculatedField: this.parent.allowCalculatedField,
            showValuesButton: this.parent.showValuesButton,
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            target: this.parent.element.parentElement,
            maxNodeLimitInMemberEditor: this.parent.maxNodeLimitInMemberEditor,
            aggregateCellInfo: this.parent.bindTriggerEvents.bind(this.parent),
            enginePopulating: this.parent.bindTriggerEvents.bind(this.parent),
            enginePopulated: this.parent.bindTriggerEvents.bind(this.parent),
            onFieldDropped: this.parent.bindTriggerEvents.bind(this.parent),
            fieldDrop: this.parent.bindTriggerEvents.bind(this.parent),
        });
        this.parent.pivotFieldListModule.appendTo('#' + this.element.id);
    }
    updateControl() {
        if (this.element) {
            this.element.style.display = 'block';
            prepend([this.element], this.parent.element);
            if (this.parent.showGroupingBar && this.parent.groupingBarModule) {
                clearTimeout(this.timeOutObj);
                this.timeOutObj = setTimeout(this.update.bind(this));
            }
            else {
                setStyleAttribute(this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS), {
                    left: 'auto'
                });
                if (this.parent.enableRtl) {
                    removeClass([this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], 'e-fieldlist-left');
                }
                else {
                    addClass([this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], 'e-fieldlist-left');
                }
            }
            setStyleAttribute(this.element, {
                width: formatUnit(this.parent.element.offsetWidth)
            });
        }
        this.parent.pivotFieldListModule.update(this.parent);
    }
    update() {
        let currentWidth;
        if (this.parent.currentView !== 'Table') {
            currentWidth = this.parent.chart ? this.parent.chartModule.calculatedWidth : currentWidth;
        }
        else {
            currentWidth = this.parent.grid ? this.parent.grid.element.offsetWidth : currentWidth;
        }
        if (currentWidth) {
            let actualWidth = currentWidth < 400 ? 400 : currentWidth;
            setStyleAttribute(this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS), {
                left: formatUnit(this.parent.enableRtl ?
                    -Math.abs((actualWidth) -
                        this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS).offsetWidth) :
                    (actualWidth) -
                        this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS).offsetWidth)
            });
            if (this.parent.enableRtl) {
                addClass([this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], 'e-fieldlist-left');
            }
            else {
                removeClass([this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], 'e-fieldlist-left');
            }
        }
    }
    /**
     * @hidden
     */
    addEventListener() {
        this.handlers = {
            load: this.initiateModule,
            update: this.updateControl
        };
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(initSubComponent, this.handlers.load, this);
        this.parent.on(uiUpdate, this.handlers.update, this);
    }
    /**
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(initSubComponent, this.handlers.load);
        this.parent.off(uiUpdate, this.handlers.update);
    }
    /**
     * To destroy the Field List
     * @return {void}
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        if (this.parent.pivotFieldListModule) {
            this.parent.pivotFieldListModule.destroy();
        }
        else {
            return;
        }
    }
}

/**
 * Module for PivotCommon rendering
 */
/** @hidden */
class Common {
    /** Constructor for Common module */
    constructor(parent) {
        this.parent = parent;
        this.parent.commonModule = this;
        this.addEventListener();
    }
    /**
     * For internal use only - Get the module name.
     * @private
     */
    getModuleName() {
        return 'common';
    }
    initiateCommonModule() {
        if (!this.parent.pivotCommon) {
            let args = {
                pivotEngine: this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule,
                dataSourceSettings: this.parent.dataSourceSettings.properties ?
                    this.parent.dataSourceSettings.properties : this.parent.dataSourceSettings,
                id: this.parent.element.id,
                element: this.parent.element,
                moduleName: this.parent.getModuleName(),
                enableRtl: this.parent.enableRtl,
                isAdaptive: Browser.isDevice,
                renderMode: 'Popup',
                localeObj: this.parent.localeObj,
                dataType: this.parent.dataType
            };
            this.parent.pivotCommon = new PivotCommon(args);
        }
        else {
            this.parent.pivotCommon.element = this.parent.element;
            this.parent.pivotCommon.engineModule = this.parent.dataType === 'olap' ?
                this.parent.olapEngineModule : this.parent.engineModule;
            this.parent.pivotCommon.parentID = this.parent.element.id;
            this.parent.pivotCommon.dataSourceSettings = this.parent.dataSourceSettings.properties ?
                this.parent.dataSourceSettings.properties : this.parent.dataSourceSettings;
            this.parent.pivotCommon.moduleName = this.parent.getModuleName();
            this.parent.pivotCommon.enableRtl = this.parent.enableRtl;
            this.parent.pivotCommon.isAdaptive = Browser.isDevice;
            this.parent.pivotCommon.renderMode = 'Popup';
            this.parent.pivotCommon.localeObj = this.parent.localeObj;
            this.parent.pivotCommon.dataType = this.parent.dataType;
        }
        this.parent.pivotCommon.control = this.parent;
    }
    /**
     * @hidden
     */
    addEventListener() {
        this.handlers = {
            load: this.initiateCommonModule
        };
        if (this.parent.isDestroyed) {
            return;
        }
        if (this.parent.gridSettings.contextMenuItems) {
            if ((!this.parent.showFieldList) || (!this.parent.showGroupingBar)) {
                this.parent.on(initialLoad, this.handlers.load, this);
            }
        }
        this.parent.on(uiUpdate, this.handlers.load, this);
    }
    /**
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(uiUpdate, this.handlers.load);
    }
    /**
     * To destroy the groupingbar
     * @return {void}
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        if (this.parent.pivotCommon) {
            this.parent.pivotCommon.destroy();
        }
    }
}

/**
 * Module to render Axis Fields
 */
/** @hidden */
class AxisFields {
    /** Constructor for render module */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Initialize the pivot button rendering
     * @returns void
     * @private
     */
    render() {
        this.pivotButton = new PivotButton(this.parent);
        this.createPivotButtons();
        let pivotButtons = [];
        /* tslint:disable:no-any */
        for (let element of this.parent.element.querySelectorAll('.' + GROUP_ROW_CLASS)) {
            if (!element.classList.contains(GROUP_CHART_ROW)) {
                pivotButtons = pivotButtons.concat([].slice.call(element.querySelectorAll('.' + PIVOT_BUTTON_WRAPPER_CLASS)));
            }
        }
        let vlen = pivotButtons.length;
        for (let j = 0; j < vlen; j++) {
            let indentWidth = 24;
            let indentDiv = createElement('span', {
                className: 'e-indent-div',
                styles: 'width:' + j * indentWidth + 'px'
            });
            prepend([indentDiv], pivotButtons[j]);
        }
    }
    createPivotButtons() {
        let fields = [this.parent.dataSourceSettings.rows, this.parent.dataSourceSettings.columns,
            this.parent.dataSourceSettings.values, this.parent.dataSourceSettings.filters];
        for (let element of this.parent.element.querySelectorAll('.' + GROUP_ROW_CLASS + ',.' + GROUP_COLUMN_CLASS + ',.'
            + GROUP_VALUE_CLASS + ',.' + GROUP_FILTER_CLASS)) {
            if (this.parent.dataSourceSettings.values.length > 0 ? !element.classList.contains(GROUP_CHART_VALUE) : true) {
                element.innerHTML = '';
            }
        }
        let axis = ['rows', 'columns', 'values', 'filters'];
        for (let i = 0, lnt = fields.length; i < lnt; i++) {
            if (fields[i]) {
                let args = {
                    field: fields[i],
                    axis: axis[i].toString()
                };
                this.parent.notify(pivotButtonUpdate, args);
            }
        }
    }
}

PivotView.Inject(Common);
/**
 * Module for GroupingBar rendering
 */
/** @hidden */
class GroupingBar {
    /** Constructor for GroupingBar module */
    constructor(parent) {
        this.parent = parent;
        this.parent.groupingBarModule = this;
        this.resColWidth = (this.parent.isAdaptive ? 180 : 249);
        this.addEventListener();
        this.parent.axisFieldModule = new AxisFields(this.parent);
        this.touchObj = new Touch(this.parent.element, {
            tapHold: this.tapHoldHandler.bind(this)
        });
    }
    /**
     * For internal use only - Get the module name.
     * @private
     */
    getModuleName() {
        return 'groupingbar';
    }
    renderLayout() {
        this.groupingTable = createElement('div', { className: GROUPING_BAR_CLASS });
        this.leftAxisPanel = createElement('div', { className: LEFT_AXIS_PANEL_CLASS });
        this.rightAxisPanel = createElement('div', { className: RIGHT_AXIS_PANEL_CLASS });
        let rowAxisPanel = createElement('div', { className: AXIS_ROW_CLASS + ' ' + AXIS_ICON_CLASS + 'wrapper' });
        let columnAxisPanel = createElement('div', {
            className: AXIS_COLUMN_CLASS + ' ' + AXIS_ICON_CLASS + 'wrapper'
        });
        let valueAxisPanel = createElement('div', {
            className: AXIS_VALUE_CLASS + ' ' + AXIS_ICON_CLASS + 'wrapper'
        });
        let filterAxisPanel = createElement('div', {
            className: AXIS_FILTER_CLASS + ' ' + AXIS_ICON_CLASS + 'wrapper'
        });
        this.rowPanel = createElement('div', { className: GROUP_ROW_CLASS + ' ' + ROW_AXIS_CLASS });
        this.columnPanel = createElement('div', { className: GROUP_COLUMN_CLASS + ' ' + COLUMN_AXIS_CLASS });
        this.valuePanel = createElement('div', { className: GROUP_VALUE_CLASS + ' ' + VALUE_AXIS_CLASS });
        this.filterPanel = createElement('div', { className: GROUP_FILTER_CLASS + ' ' + FILTER_AXIS_CLASS });
        rowAxisPanel.appendChild(this.rowPanel);
        columnAxisPanel.appendChild(this.columnPanel);
        valueAxisPanel.appendChild(this.valuePanel);
        filterAxisPanel.appendChild(this.filterPanel);
        this.rowAxisPanel = rowAxisPanel;
        this.columnAxisPanel = columnAxisPanel;
        this.valueAxisPanel = valueAxisPanel;
        this.filterAxisPanel = filterAxisPanel;
        this.leftAxisPanel.appendChild(valueAxisPanel);
        this.leftAxisPanel.appendChild(rowAxisPanel);
        this.rightAxisPanel.appendChild(filterAxisPanel);
        this.rightAxisPanel.appendChild(columnAxisPanel);
        this.groupingTable.appendChild(this.leftAxisPanel);
        this.groupingTable.appendChild(this.rightAxisPanel);
        this.groupingTable.classList.add(GRID_GROUPING_BAR_CLASS);
        let axisPanels = [this.rowPanel, this.columnPanel, this.valuePanel, this.filterPanel];
        for (let element of axisPanels) {
            if (this.parent.groupingBarSettings.allowDragAndDrop) {
                new Droppable(element, {});
            }
            this.unWireEvent(element);
            this.wireEvent(element);
        }
        if (this.parent.displayOption.view !== 'Table' && this.parent.groupingBarSettings.displayMode !== 'Table') {
            this.groupingChartTable = this.groupingTable.cloneNode(true);
            this.groupingChartTable.classList.add(CHART_GROUPING_BAR_CLASS);
            this.groupingChartTable.classList.remove(GRID_GROUPING_BAR_CLASS);
            this.groupingChartTable.querySelector('.' + GROUP_ROW_CLASS).classList.add(GROUP_CHART_ROW);
            this.groupingChartTable.querySelector('.' + GROUP_COLUMN_CLASS).classList.add(GROUP_CHART_COLUMN);
            if (this.parent.chartSettings.enableMultiAxis) {
                this.groupingChartTable.querySelector('.' + GROUP_VALUE_CLASS).classList.add(GROUP_CHART_MULTI_VALUE);
            }
            else {
                this.groupingChartTable.querySelector('.' + GROUP_VALUE_CLASS).classList.add(GROUP_CHART_VALUE);
                this.groupingChartTable.querySelector('.' + GROUP_VALUE_CLASS).classList.remove(DROPPABLE_CLASS);
            }
            this.groupingChartTable.querySelector('.' + GROUP_FILTER_CLASS).classList.add(GROUP_CHART_FILTER);
        }
        else {
            this.groupingChartTable = undefined;
        }
        if (this.parent.displayOption.view === 'Chart' || this.parent.groupingBarSettings.displayMode === 'Chart') {
            this.groupingTable = undefined;
        }
    }
    /* tslint:disable:max-func-body-length */
    appendToElement() {
        if (this.parent.element.querySelector('.' + GRID_CLASS) || this.parent.element.querySelector('.' + PIVOTCHART)) {
            if (this.parent.showGroupingBar) {
                if (this.parent.element.querySelector('.' + GROUPING_BAR_CLASS)) {
                    /* tslint:disable:no-any */
                    for (let element of this.parent.element.querySelectorAll('.' + GROUPING_BAR_CLASS)) {
                        remove(element);
                    }
                }
                if (this.groupingChartTable) {
                    if (this.parent.element.querySelector('#' + this.parent.element.id + '_chart')) {
                        setStyleAttribute(this.groupingChartTable, {
                            width: formatUnit(this.parent.grid ? this.parent.getGridWidthAsNumber() : this.parent.getWidthAsNumber())
                        });
                        this.parent.element.insertBefore(this.groupingChartTable, this.parent.element.querySelector('#' + this.parent.element.id + '_chart'));
                    }
                    else {
                        this.groupingChartTable = undefined;
                    }
                }
                if (this.parent.displayOption.view !== 'Chart' && this.groupingTable) {
                    if (this.parent.isAdaptive) {
                        this.leftAxisPanel.style.minWidth = '180px';
                        this.valuePanel.style.minWidth = '180px';
                    }
                    if (this.parent.firstColWidth) {
                        this.leftAxisPanel.style.minWidth = 'auto';
                        this.valuePanel.style.minWidth = 'auto';
                    }
                    this.filterPanel.removeAttribute('style');
                    this.columnPanel.removeAttribute('style');
                    this.rowPanel.removeAttribute('style');
                    this.filterPanel.removeAttribute('style');
                    let emptyRowCount;
                    if (this.parent.dataType === 'olap') {
                        emptyRowCount = Object.keys(this.parent.olapEngineModule.headerContent).length;
                    }
                    else {
                        emptyRowCount = Object.keys(this.parent.engineModule.headerContent).length;
                    }
                    if (!isNullOrUndefined(emptyRowCount)) {
                        let emptyHeader = this.parent.element.querySelector('.e-frozenheader').querySelector('.e-columnheader');
                        addClass([emptyHeader], 'e-row');
                        emptyHeader.removeAttribute('style');
                        addClass([emptyHeader.querySelector('.e-headercell')], 'e-group-row');
                        emptyHeader.querySelector('.e-group-row').appendChild(this.rowAxisPanel);
                        emptyHeader.querySelector('.e-group-row').querySelector('.e-headercelldiv').style.display = 'none';
                        emptyHeader.querySelector('.e-group-row').querySelector('.e-sortfilterdiv').style.display = 'none';
                    }
                    this.parent.element.insertBefore(this.groupingTable, this.parent.element.querySelector('.' + GRID_CLASS));
                    setStyleAttribute(this.groupingTable, {
                        width: formatUnit(this.parent.grid ? this.parent.getGridWidthAsNumber() : this.parent.getWidthAsNumber())
                    });
                    this.groupingTable.style.minWidth = '400px';
                    this.parent.axisFieldModule.render();
                    this.setGridRowWidth();
                    let colGroupElement = this.parent.element.querySelector('.e-frozenheader').querySelector('colgroup').children[0];
                    let rightAxisPanelWidth = formatUnit(this.groupingTable.offsetWidth - parseInt(colGroupElement.style.width, 10));
                    setStyleAttribute(this.valuePanel, { width: colGroupElement.style.width });
                    setStyleAttribute(this.rightAxisPanel, { width: rightAxisPanelWidth });
                    let rightPanelHeight = (this.valuePanel.offsetHeight / 2);
                    if (rightPanelHeight > this.columnPanel.offsetHeight) {
                        setStyleAttribute(this.filterPanel, { height: formatUnit(rightPanelHeight) });
                        setStyleAttribute(this.columnPanel, { height: formatUnit(rightPanelHeight + 1) });
                    }
                    let topLeftHeight = this.parent.element.querySelector('.e-headercontent').offsetHeight;
                    setStyleAttribute(this.rowPanel, {
                        height: topLeftHeight + 'px'
                    });
                    if (this.parent.element.querySelector('.e-frozenheader').querySelector('.e-rhandler')) {
                        this.parent.element.querySelector('.e-frozenheader').querySelector('.e-rhandler').style.height =
                            topLeftHeight + 'px';
                    }
                    let colRows = [].slice.call(this.parent.element.querySelector('.e-movableheader').querySelector('thead').querySelectorAll('tr'));
                    let columnRows = colRows.filter((trCell) => {
                        return (trCell.childNodes.length > 0);
                    });
                    let colHeight = topLeftHeight / columnRows.length;
                    for (let element of columnRows) {
                        setStyleAttribute(element, { 'height': colHeight + 'px' });
                        let rowHeader = [].slice.call(element.querySelectorAll('.e-rhandler'));
                        for (let rhElement of rowHeader) {
                            setStyleAttribute(rhElement, { 'height': colHeight + 'px' });
                        }
                    }
                }
                else {
                    this.parent.axisFieldModule.render();
                }
                if (this.parent.showToolbar && this.parent.displayOption.view === 'Both') {
                    if (this.parent.currentView === 'Table') {
                        this.parent.element.querySelector('.e-chart-grouping-bar').style.display = 'none';
                    }
                    else {
                        this.parent.element.querySelector('.e-pivot-grouping-bar').style.display = 'none';
                    }
                }
            }
        }
    }
    /**
     * @hidden
     */
    refreshUI() {
        if (this.groupingChartTable) {
            setStyleAttribute(this.groupingChartTable, {
                width: formatUnit(this.parent.grid ? this.parent.getGridWidthAsNumber() : this.parent.getWidthAsNumber())
            });
        }
        if (this.groupingTable) {
            setStyleAttribute(this.groupingTable, {
                width: formatUnit(this.parent.grid ? this.parent.getGridWidthAsNumber() : this.parent.getWidthAsNumber())
            });
            this.groupingTable.style.minWidth = '400px';
            let colGroupElement = this.parent.element.querySelector('.e-frozenheader').querySelector('colgroup').children[0];
            let rightAxisWidth = formatUnit(this.groupingTable.offsetWidth - parseInt(colGroupElement.style.width, 10));
            setStyleAttribute(this.valuePanel, { width: colGroupElement.style.width });
            setStyleAttribute(this.rightAxisPanel, { width: rightAxisWidth });
            if (this.parent.showFieldList && this.parent.pivotFieldListModule && this.parent.pivotFieldListModule.element) {
                clearTimeout(this.timeOutObj);
                this.timeOutObj = setTimeout(this.alignIcon.bind(this));
            }
            if (!this.parent.grid.element.querySelector('.e-group-row')) {
                let emptyRowHeader = this.parent.element.querySelector('.e-frozenheader').querySelector('.e-columnheader');
                addClass([emptyRowHeader], 'e-row');
                addClass([emptyRowHeader.querySelector('.e-headercell')], 'e-group-row');
                setStyleAttribute(this.rowPanel, {
                    height: this.parent.element.querySelector('.e-headercontent').offsetHeight + 'px'
                });
                emptyRowHeader.querySelector('.e-group-row').appendChild(this.rowAxisPanel);
                setStyleAttribute(emptyRowHeader.querySelector('.e-group-row').querySelector('.e-headercelldiv'), {
                    display: 'none'
                });
                setStyleAttribute(emptyRowHeader.querySelector('.e-group-row').querySelector('.e-sortfilterdiv'), {
                    display: 'none'
                });
                let groupHeight = this.parent.element.querySelector('.e-headercontent').offsetHeight;
                setStyleAttribute(this.rowPanel, {
                    height: groupHeight + 'px'
                });
                if (this.parent.element.querySelector('.e-frozenheader').querySelector('.e-rhandler')) {
                    this.parent.element.querySelector('.e-frozenheader').querySelector('.e-rhandler').style.height =
                        groupHeight + 'px';
                }
                let colRowElements = [].slice.call(this.parent.element.querySelector('.e-movableheader').querySelector('thead').querySelectorAll('tr'));
                let columnRows = colRowElements.filter((trCell) => {
                    return (trCell.childNodes.length > 0);
                });
                let colHeight = groupHeight / columnRows.length;
                for (let element of columnRows) {
                    setStyleAttribute(element, { 'height': colHeight + 'px' });
                    let rowHeader = [].slice.call(element.querySelectorAll('.e-rhandler'));
                    for (let handlerElement of rowHeader) {
                        setStyleAttribute(handlerElement, { 'height': colHeight + 'px' });
                    }
                }
            }
        }
    }
    /** @hidden */
    alignIcon() {
        let element = this.parent.pivotFieldListModule.element;
        let currentWidth;
        if (this.parent.currentView === 'Table') {
            currentWidth = this.parent.grid ? this.parent.grid.element.offsetWidth : currentWidth;
        }
        else {
            currentWidth = this.parent.chart ? this.parent.chartModule.calculatedWidth : currentWidth;
        }
        if (currentWidth) {
            let actWidth = currentWidth < 400 ? 400 : currentWidth;
            setStyleAttribute(element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS), {
                left: formatUnit(this.parent.enableRtl ?
                    -Math.abs((actWidth) -
                        element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS).offsetWidth) :
                    (actWidth) -
                        element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS).offsetWidth)
            });
        }
    }
    /**
     * @hidden
     */
    setGridRowWidth() {
        let colGroupElement = this.parent.element.querySelector('.e-frozenheader').querySelector('colgroup').children[0];
        if (this.rowPanel.querySelector('.' + PIVOT_BUTTON_CLASS)) {
            if (!this.parent.isAdaptive) {
                let pivotButtons = [].slice.call(this.rowPanel.querySelectorAll('.' + PIVOT_BUTTON_WRAPPER_CLASS));
                let lastButton = pivotButtons[pivotButtons.length - 1];
                let lastButtonWidth = (lastButton.querySelector('.' + PIVOT_BUTTON_CLASS).offsetWidth +
                    lastButton.querySelector('.e-indent-div').offsetWidth + 20);
                let buttonWidth = formatUnit(lastButtonWidth < this.resColWidth ? this.resColWidth : lastButtonWidth);
                let rowHeaderTable = this.parent.element.querySelector('.e-frozenheader').querySelector('table');
                let rowContentTable = this.parent.element.querySelector('.e-frozencontent').querySelector('table');
                let rowContent = this.parent.element.querySelector('.e-frozencontent').querySelector('colgroup').children[0];
                let colwidth = parseInt(buttonWidth, 10);
                let gridColumn = this.parent.grid.columns;
                if (gridColumn && gridColumn.length > 0) {
                    /* tslint:disable:align */
                    gridColumn[0].width = (gridColumn[0].width >= this.resColWidth ?
                        (colwidth > this.resColWidth ? colwidth : this.resColWidth) :
                        (colwidth > this.resColWidth ? colwidth : this.resColWidth));
                }
                let valueColWidth;
                if (this.parent.dataType === 'olap') {
                    valueColWidth = this.parent.renderModule.calculateColWidth(this.parent.olapEngineModule.pivotValues.length > 0 ?
                        this.parent.olapEngineModule.pivotValues[0].length : 2);
                }
                else {
                    valueColWidth = this.parent.renderModule.calculateColWidth((this.parent.dataSourceSettings.values.length > 0 &&
                        this.parent.engineModule.pivotValues.length > 0) ?
                        this.parent.engineModule.pivotValues[0].length : 2);
                }
                for (let cCnt = 0; cCnt < gridColumn.length; cCnt++) {
                    if (cCnt !== 0) {
                        if (gridColumn[cCnt].columns) {
                            this.setColWidth(gridColumn[cCnt].columns, valueColWidth);
                        }
                        else {
                            gridColumn[cCnt].width = valueColWidth;
                            if (gridColumn[cCnt].width !== 'auto') {
                                let levelName = gridColumn[cCnt].customAttributes ?
                                    gridColumn[cCnt].customAttributes.cell.valueSort.levelName : '';
                                gridColumn[cCnt].width = this.parent.renderModule.setSavedWidth(levelName, valueColWidth);
                            }
                            else {
                                gridColumn[cCnt].minWidth = valueColWidth;
                            }
                        }
                    }
                }
                this.parent.posCount = 0;
                this.parent.setGridColumns(this.parent.grid.columns);
                this.parent.grid.headerModule.refreshUI();
                if (!this.parent.firstColWidth) {
                    colGroupElement.style.width = buttonWidth;
                    rowContent.style.width = buttonWidth;
                    rowHeaderTable.style.width = buttonWidth;
                    rowContentTable.style.width = buttonWidth;
                    setStyleAttribute(rowHeaderTable, { 'width': buttonWidth });
                    setStyleAttribute(rowContentTable, { 'width': buttonWidth });
                }
            }
            else {
                if (!this.parent.firstColWidth) {
                    let gridColumn = this.parent.grid.columns;
                    if (gridColumn && gridColumn.length > 0) {
                        gridColumn[0].width = this.resColWidth;
                    }
                    this.parent.posCount = 0;
                    this.parent.grid.headerModule.refreshUI();
                }
            }
        }
        else {
            if (this.parent.grid.columns && this.parent.grid.columns.length > 0) {
                this.parent.grid.columns[0].width = this.parent.grid.columns[0].width > this.resColWidth ?
                    this.parent.grid.columns[0].width : this.resColWidth;
            }
            this.parent.grid.headerModule.refreshUI();
        }
        if (this.groupingTable) {
            this.refreshUI();
        }
    }
    setColWidth(columns, width) {
        for (let cCnt = 0; cCnt < columns.length; cCnt++) {
            if (columns[cCnt].columns) {
                this.setColWidth(columns[cCnt].columns, width);
            }
            else {
                columns[cCnt].width = width;
            }
        }
    }
    wireEvent(element) {
        EventHandler.add(element, 'mouseover', this.dropIndicatorUpdate, this);
        EventHandler.add(element, 'mouseleave', this.dropIndicatorUpdate, this);
    }
    unWireEvent(element) {
        EventHandler.remove(element, 'mouseover', this.dropIndicatorUpdate);
        EventHandler.remove(element, 'mouseleave', this.dropIndicatorUpdate);
    }
    dropIndicatorUpdate(e) {
        if ((this.parent.isDragging && e.target.classList.contains(DROPPABLE_CLASS) && e.type === 'mouseover') ||
            e.type === 'mouseleave') {
            removeClass([].slice.call(this.parent.element.querySelectorAll('.' + DROP_INDICATOR_CLASS)), INDICATOR_HOVER_CLASS);
            removeClass([].slice.call(this.parent.element.querySelectorAll('.' + DROP_INDICATOR_CLASS + '-last')), INDICATOR_HOVER_CLASS);
        }
    }
    tapHoldHandler(e) {
        let target = closest(e.originalEvent.target, '.' + PIVOT_BUTTON_CLASS);
        if (!isNullOrUndefined(target) && this.parent.isAdaptive) {
            let pos = target.getBoundingClientRect();
            this.parent.contextMenuModule.fieldElement = target;
            this.parent.contextMenuModule.menuObj.open(pos.top, pos.left);
            return;
        }
    }
    /**
     * @hidden
     */
    addEventListener() {
        this.handlers = {
            load: this.renderLayout,
            end: this.appendToElement,
        };
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(initSubComponent, this.handlers.load, this); //For initial rendering
        this.parent.on(uiUpdate, this.handlers.end, this);
    }
    /**
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(uiUpdate, this.handlers.end);
        this.parent.off(initSubComponent, this.handlers.load);
    }
    /**
     * To destroy the groupingbar
     * @return {void}
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        if (this.parent.pivotButtonModule) {
            this.parent.pivotButtonModule.destroy();
            if (this.touchObj && !this.touchObj.isDestroyed) {
                this.touchObj.destroy();
            }
        }
        else {
            return;
        }
    }
}

/**
 * Module to render Conditional Formatting Dialog
 */
/** @hidden */
class ConditionalFormatting {
    /** Constructor for conditionalformatting module */
    constructor(parent) {
        this.parent = parent;
        this.parent.conditionalFormattingModule = this;
        this.parentID = this.parent.element.id;
        this.dialog = null;
        this.fieldsDropDown = [];
        this.conditionsDropDown = [];
        this.fontNameDropDown = [];
        this.fontSizeDropDown = [];
        this.fontColor = [];
        this.backgroundColor = [];
        this.newFormat = [];
    }
    /**
     * To get module name.
     * @returns string
     */
    getModuleName() {
        return 'conditionalformatting';
    }
    createDialog() {
        if (document.querySelector('#' + this.parentID + 'conditionalformatting') !== null) {
            remove(document.querySelector('#' + this.parentID + 'conditionalformatting'));
        }
        this.parent.element.appendChild(createElement('div', {
            id: this.parentID + 'conditionalformatting',
        }));
        let buttonModel = [
            {
                click: this.addButtonClick.bind(this),
                buttonModel: {
                    cssClass: this.parent.isAdaptive ? (FORMAT_ROUND_BUTTON + ' ' + FORMAT_CONDITION_BUTTON) :
                        FORMAT_CONDITION_BUTTON,
                    iconCss: ICON + ' ' + ADD_ICON_CLASS,
                    content: this.parent.isAdaptive ? '' : this.parent.localeObj.getConstant('condition'),
                }
            },
            {
                click: this.applyButtonClick.bind(this),
                buttonModel: {
                    cssClass: FLAT_CLASS + ' ' + FORMAT_APPLY_BUTTON,
                    content: this.parent.localeObj.getConstant('apply')
                }
            },
            {
                click: this.cancelButtonClick.bind(this),
                buttonModel: {
                    cssClass: FLAT_CLASS + ' ' + FORMAT_CANCEL_BUTTON,
                    content: this.parent.localeObj.getConstant('cancel')
                }
            }
        ];
        if (this.parent.isAdaptive) {
            this.dialog = new Dialog({
                animationSettings: { effect: 'Zoom' }, isModal: true, width: '100%', height: '100%',
                showCloseIcon: false, closeOnEscape: false, enableRtl: this.parent.enableRtl,
                position: { X: 'center', Y: 'center' }, allowDragging: true, buttons: buttonModel,
                beforeOpen: this.beforeOpen.bind(this),
                cssClass: FORMAT_DIALOG, header: this.parent.localeObj.getConstant('conditionalFormating'), target: document.body
            });
        }
        else {
            this.dialog = new Dialog({
                allowDragging: true, position: { X: 'center', Y: this.parent.element.offsetTop }, buttons: buttonModel,
                beforeOpen: this.beforeOpen.bind(this),
                cssClass: FORMAT_DIALOG, isModal: false, closeOnEscape: true, enableRtl: this.parent.enableRtl,
                showCloseIcon: true, header: this.parent.localeObj.getConstant('conditionalFormating'), target: this.parent.element
            });
        }
        this.dialog.isStringTemplate = true;
        this.dialog.appendTo('#' + this.parentID + 'conditionalformatting');
        // this.dialog.element.querySelector('.e-dlg-header').innerHTML = this.parent.localeObj.getConstant('conditionalFormating');
    }
    beforeOpen(args) {
        this.dialog.element.querySelector('.' + DIALOG_HEADER).
            setAttribute('title', this.parent.localeObj.getConstant('conditionalFormating'));
    }
    addButtonClick() {
        let format = {
            conditions: 'LessThan',
            value1: 0,
            applyGrandTotals: true,
            style: {
                backgroundColor: 'white',
                color: 'black',
                fontFamily: 'Arial',
                fontSize: '12px'
            }
        };
        let conditionalFormating = this;
        this.parent.trigger(conditionalFormatting, format, (observedArgs) => {
            conditionalFormating.refreshConditionValues();
            conditionalFormating.newFormat.push(observedArgs);
            conditionalFormating.addFormat();
        });
    }
    applyButtonClick() {
        if (this.refreshConditionValues()) {
            this.parent.setProperties({ dataSourceSettings: { conditionalFormatSettings: this.newFormat } }, true);
            this.parent.renderPivotGrid();
            this.destroy();
        }
    }
    cancelButtonClick() {
        this.destroy();
        this.newFormat = [];
    }
    refreshConditionValues() {
        for (let i = 0; i < this.newFormat.length; i++) {
            if (document.querySelector('#' + this.parentID + 'conditionvalue1' + i).value === '' ||
                document.querySelector('#' + this.parentID + 'conditionvalue2' + i).value === '') {
                document.querySelector('#' + this.parentID + 'conditionvalue1' + i).value === '' ?
                    document.querySelector('#' + this.parentID + 'conditionvalue1' + i).focus() :
                    document.querySelector('#' + this.parentID + 'conditionvalue2' + i).focus();
                return false;
            }
            this.newFormat[i].value1 =
                Number(document.querySelector('#' + this.parentID + 'conditionvalue1' + i).value);
            this.newFormat[i].value2 =
                Number(document.querySelector('#' + this.parentID + 'conditionvalue2' + i).value);
        }
        return true;
    }
    addFormat() {
        let format = createElement('div', { id: this.parentID + 'formatDiv', className: FORMAT_NEW });
        for (let i = 0; i < this.newFormat.length; i++) {
            format.appendChild(this.createDialogElements(i));
        }
        if (this.newFormat.length === 0) {
            let outerDiv = this.createDialogElements();
            let element = createElement('p', {
                id: this.parentID + 'emptyFormat',
                innerHTML: this.parent.localeObj.getConstant('emptyFormat'),
                styles: 'margin: 10px'
            });
            outerDiv.appendChild(element);
            format.appendChild(outerDiv);
        }
        this.dialog.setProperties({ 'content': format }, false);
        for (let i = 0; i < this.newFormat.length; i++) {
            this.renderDropDowns(i);
            this.renderColorPicker(i);
        }
    }
    createDialogElements(i) {
        let outerDiv = createElement('div', {
            id: this.parentID + 'outerDiv' + i, className: FORMAT_OUTER
        });
        if (i !== undefined) {
            let format = this.newFormat[i];
            let button = createElement('button', {
                id: this.parentID + 'removeButton' + i, className: FORMAT_DELETE_BUTTON,
                attrs: { 'title': this.parent.localeObj.getConstant('delete') }
            });
            outerDiv.appendChild(button);
            let innerDiv = createElement('div', { id: this.parentID + 'innerDiv', className: FORMAT_INNER });
            let table = createElement('table', { id: this.parentID + 'cftable', className: FORMAT_TABLE });
            let tRow = createElement('tr');
            let td = createElement('td');
            let valuelabel = createElement('span', {
                id: this.parentID + 'valuelabel' + i, className: FORMAT_VALUE_LABEL,
                innerHTML: this.parent.localeObj.getConstant('value')
            });
            td.appendChild(valuelabel);
            tRow.appendChild(td);
            table.appendChild(tRow);
            tRow = createElement('tr');
            td = createElement('td');
            let measureDropdown = createElement('div', { id: this.parentID + 'measure' + i });
            let measureInput = createElement('input', {
                id: this.parentID + 'measureinput' + i,
                attrs: { 'type': 'text', 'tabindex': '1' }
            });
            measureDropdown.appendChild(measureInput);
            td.appendChild(measureDropdown);
            tRow.appendChild(td);
            td = createElement('td');
            let conditionDropdown = createElement('div', { id: this.parentID + 'condition' });
            let conditionInput = createElement('input', {
                id: this.parentID + 'conditioninput' + i,
                attrs: { 'type': 'text', 'tabindex': '1' }
            });
            conditionDropdown.appendChild(conditionInput);
            td.appendChild(conditionDropdown);
            tRow.appendChild(td);
            td = createElement('td');
            let style = !(format.conditions === 'Between' || format.conditions === 'NotBetween') ? 'display:none; width:10px' : '';
            let value1 = createElement('input', {
                id: this.parentID + 'conditionvalue1' + i,
                attrs: {
                    'type': 'text', 'tabindex': '1', 'value': !isNullOrUndefined(format.value1) ? format.value1.toString() : '0',
                    'placeholder': this.parent.localeObj.getConstant('emptyInput')
                },
                styles: this.parent.isAdaptive ? style === '' ? 'width: 35%' : 'width: 100%' : style === '' ? 'width: 45px' :
                    'width: 120px',
                className: INPUT + ' ' + FORMAT_VALUE1
            });
            td.appendChild(value1);
            let valuespan = createElement('span', {
                id: this.parentID + 'valuespan' + i, className: FORMAT_VALUE_SPAN,
                innerHTML: '&', styles: style
            });
            td.appendChild(valuespan);
            let value2 = createElement('input', {
                id: this.parentID + 'conditionvalue2' + i,
                attrs: {
                    'type': 'text', 'tabindex': '1', 'value': !isNullOrUndefined(format.value2) ? format.value2.toString() : '0',
                    'placeholder': this.parent.localeObj.getConstant('emptyInput')
                },
                styles: (this.parent.isAdaptive && style === '') ? 'width: 35%' : style === '' ? 'width: 45px' : style,
                className: INPUT + ' ' + FORMAT_VALUE2
            });
            td.appendChild(value2);
            tRow.appendChild(td);
            table.appendChild(tRow);
            if (this.parent.isAdaptive) {
                innerDiv.appendChild(table);
                table = createElement('table', { id: this.parentID + 'cftable', className: FORMAT_TABLE });
            }
            tRow = createElement('tr');
            td = createElement('td');
            let formatlabel = createElement('span', {
                id: this.parentID + 'formatlabel' + i, className: FORMAT_LABEL,
                innerHTML: this.parent.localeObj.getConstant('formatLabel')
            });
            td.appendChild(formatlabel);
            tRow.appendChild(td);
            table.appendChild(tRow);
            tRow = createElement('tr');
            td = createElement('td');
            let fontNameDropdown = createElement('div', { id: this.parentID + 'fontname' });
            let fontNameInput = createElement('input', {
                id: this.parentID + 'fontnameinput' + i, attrs: { 'type': 'text', 'tabindex': '1' }
            });
            fontNameDropdown.appendChild(fontNameInput);
            td.appendChild(fontNameDropdown);
            tRow.appendChild(td);
            td = createElement('td');
            let fontSizeDropdown = createElement('div', { id: this.parentID + 'fontsize' });
            let fontSizeInput = createElement('input', {
                id: this.parentID + 'fontsizeinput' + i, attrs: { 'type': 'text', 'tabindex': '1' }
            });
            fontSizeDropdown.appendChild(fontSizeInput);
            td.appendChild(fontSizeDropdown);
            tRow.appendChild(td);
            if (this.parent.isAdaptive) {
                table.appendChild(tRow);
                tRow = createElement('tr');
                table.appendChild(tRow);
                tRow = createElement('tr');
            }
            td = createElement('td');
            let colorPicker1 = createElement('input', {
                id: this.parentID + 'fontcolor' + i, attrs: { 'type': 'color', 'tabindex': '1' }, className: FORMAT_FONT_COLOR
            });
            td.appendChild(colorPicker1);
            let colorPicker2 = createElement('input', {
                id: this.parentID + 'backgroundcolor' + i, attrs: { 'type': 'color', 'tabindex': '1' }, className: FORMAT_BACK_COLOR
            });
            td.appendChild(colorPicker2);
            tRow.appendChild(td);
            td = createElement('td');
            let valuePreview = createElement('div', {
                id: this.parentID + 'valuepreview' + i, className: INPUT + ' ' + FORMAT_VALUE_PREVIEW,
                innerHTML: '123.45',
            });
            td.appendChild(valuePreview);
            tRow.appendChild(td);
            table.appendChild(tRow);
            innerDiv.appendChild(table);
            outerDiv.appendChild(innerDiv);
        }
        return outerDiv;
    }
    renderDropDowns(i) {
        let format = this.newFormat[i];
        let fields = [];
        fields.push({
            index: 0, name: this.parent.localeObj.getConstant('AllValues'),
            field: this.parent.localeObj.getConstant('AllValues')
        });
        for (let i = 0; i < this.parent.dataSourceSettings.values.length; i++) {
            fields.push({
                index: i + 1,
                name: this.parent.dataSourceSettings.values[i].caption || this.parent.dataSourceSettings.values[i].name,
                field: this.parent.dataSourceSettings.values[i].name
            });
        }
        let value = isNullOrUndefined(format.measure) ? this.parent.localeObj.getConstant('AllValues') : format.measure;
        this.fieldsDropDown[i] = new DropDownList({
            dataSource: fields, fields: { text: 'name', value: 'field' },
            value: value, width: this.parent.isAdaptive ? '100%' : '120px',
            popupHeight: '200px', popupWidth: 'auto',
            change: this.measureChange.bind(this, i)
        });
        this.fieldsDropDown[i].isStringTemplate = true;
        this.fieldsDropDown[i].appendTo('#' + this.parentID + 'measureinput' + i);
        let conditions = [
            { value: 'LessThan', name: this.parent.localeObj.getConstant('LessThan') },
            { value: 'LessThanOrEqualTo', name: this.parent.localeObj.getConstant('LessThanOrEqualTo') },
            { value: 'GreaterThan', name: this.parent.localeObj.getConstant('GreaterThan') },
            { value: 'GreaterThanOrEqualTo', name: this.parent.localeObj.getConstant('GreaterThanOrEqualTo') },
            { value: 'Equals', name: this.parent.localeObj.getConstant('Equals') },
            { value: 'NotEquals', name: this.parent.localeObj.getConstant('NotEquals') },
            { value: 'Between', name: this.parent.localeObj.getConstant('Between') },
            { value: 'NotBetween', name: this.parent.localeObj.getConstant('NotBetween') }
        ];
        value = isNullOrUndefined(format.conditions) ? 'LessThan' : format.conditions;
        this.conditionsDropDown[i] = new DropDownList({
            dataSource: conditions, fields: { value: 'value', text: 'name' },
            value: value, width: this.parent.isAdaptive ? '100%' : '120px',
            popupHeight: '200px', popupWidth: 'auto',
            change: this.conditionChange.bind(this, i)
        });
        this.conditionsDropDown[i].isStringTemplate = true;
        this.conditionsDropDown[i].appendTo('#' + this.parentID + 'conditioninput' + i);
        let fontNames = [
            { index: 0, name: 'Arial' }, { index: 1, name: 'San Serif' }, { index: 2, name: 'Impact' },
            { index: 3, name: 'Trebuchet MS' }, { index: 4, name: 'Serif' }, { index: 5, name: 'Verdana' },
            { index: 6, name: 'Courier New' }, { index: 7, name: 'Times New Roman' }, { index: 8, name: 'Tahoma' },
            { index: 9, name: 'Gerogia' }
        ];
        value = isNullOrUndefined(format.style.fontFamily) ? 'Arial' : format.style.fontFamily;
        this.fontNameDropDown[i] = new DropDownList({
            dataSource: fontNames, fields: { text: 'name' },
            value: value, width: this.parent.isAdaptive ? '100%' : '120px',
            popupWidth: '150px', popupHeight: '200px',
            change: this.fontNameChange.bind(this, i)
        });
        this.fontNameDropDown[i].isStringTemplate = true;
        this.fontNameDropDown[i].appendTo('#' + this.parentID + 'fontnameinput' + i);
        let fontSize = [
            { index: 0, name: '9px' }, { index: 1, name: '10px' }, { index: 2, name: '11px' }, { index: 3, name: '12px' },
            { index: 4, name: '13px' }, { index: 5, name: '14px' }, { index: 6, name: '15px' }, { index: 6, name: '16px' }
        ];
        value = isNullOrUndefined(format.style.fontSize) ? '12px' : format.style.fontSize;
        this.fontSizeDropDown[i] = new DropDownList({
            dataSource: fontSize, fields: { text: 'name' }, popupHeight: '200px',
            value: value, width: this.parent.isAdaptive ? '100%' : '120px',
            change: this.fontSizeChange.bind(this, i)
        });
        this.fontSizeDropDown[i].isStringTemplate = true;
        this.fontSizeDropDown[i].appendTo('#' + this.parentID + 'fontsizeinput' + i);
    }
    conditionChange(i, args) {
        this.newFormat[i].conditions = args.value;
        if (args.value === 'Between' || args.value === 'NotBetween') {
            document.querySelector('#' + this.parentID + 'valuespan' + i).style.display = 'inline-block';
            document.querySelector('#' + this.parentID + 'valuespan' + i).style.width =
                this.parent.isAdaptive ? '10%' : '10px';
            document.querySelector('#' + this.parentID + 'conditionvalue2' + i).style.display = 'inline-block';
            document.querySelector('#' + this.parentID + 'conditionvalue2' + i).style.width =
                this.parent.isAdaptive ? '35%' : '45px';
            document.querySelector('#' + this.parentID + 'conditionvalue1' + i).style.width =
                this.parent.isAdaptive ? '35%' : '45px';
        }
        else {
            document.querySelector('#' + this.parentID + 'valuespan' + i).style.display = 'none';
            document.querySelector('#' + this.parentID + 'conditionvalue2' + i).style.display = 'none';
            document.querySelector('#' + this.parentID + 'conditionvalue1' + i).style.width =
                this.parent.isAdaptive ? '100%' : '120px';
        }
    }
    fontNameChange(i, args) {
        this.newFormat[i].style.fontFamily = args.value.toString();
        document.querySelector('#' + this.parentID + 'valuepreview' + i).style.fontFamily = args.value;
    }
    fontSizeChange(i, args) {
        this.newFormat[i].style.fontSize = args.value.toString();
        document.querySelector('#' + this.parentID + 'valuepreview' + i).style.fontSize = args.value;
    }
    measureChange(i, args) {
        this.newFormat[i].measure = args.value.toString() === this.parent.localeObj.getConstant('AllValues') ?
            undefined : args.value.toString();
    }
    renderColorPicker(i) {
        let format = this.newFormat[i];
        let value = isNullOrUndefined(format.style.color) ? 'black' : format.style.color;
        let color = this.isHex(value.substr(1)) ? value : this.colourNameToHex(value);
        document.querySelector('#' + this.parentID + 'valuepreview' + i).style.color = color;
        this.fontColor[i] = new ColorPicker({
            cssClass: FORMAT_COLOR_PICKER, value: color, mode: 'Palette',
            change: this.fontColorChange.bind(this, i)
        });
        this.fontColor[i].isStringTemplate = true;
        this.fontColor[i].appendTo('#' + this.parentID + 'fontcolor' + i);
        addClass([this.fontColor[i].element.nextElementSibling.querySelector('.' + SELECTED_COLOR)], ICON);
        value = isNullOrUndefined(format.style.backgroundColor) ? 'white' : format.style.backgroundColor;
        color = this.isHex(value.substr(1)) ? value : this.colourNameToHex(value);
        document.querySelector('#' + this.parentID + 'valuepreview' + i).style.backgroundColor = color;
        document.querySelector('#' + this.parentID + 'valuepreview' + i).style.fontFamily = format.style.fontFamily;
        document.querySelector('#' + this.parentID + 'valuepreview' + i).style.fontSize = format.style.fontSize;
        this.backgroundColor[i] = new ColorPicker({
            cssClass: FORMAT_COLOR_PICKER, value: color, mode: 'Palette',
            change: this.backColorChange.bind(this, i)
        });
        this.backgroundColor[i].isStringTemplate = true;
        this.backgroundColor[i].appendTo('#' + this.parentID + 'backgroundcolor' + i);
        addClass([this.backgroundColor[i].element.nextElementSibling.querySelector('.e-selected-color')], ICON);
        let toggleBtn = new Button({
            iconCss: ICON + ' ' + FORMAT_DELETE_ICON,
            cssClass: FLAT
        });
        toggleBtn.isStringTemplate = true;
        toggleBtn.appendTo('#' + this.parentID + 'removeButton' + i);
        toggleBtn.element.onclick = this.toggleButtonClick.bind(this, i);
    }
    backColorChange(i, args) {
        this.newFormat[i].style.backgroundColor = args.currentValue.hex;
        document.querySelector('#' + this.parentID + 'valuepreview' + i).style.backgroundColor =
            args.currentValue.hex;
    }
    fontColorChange(i, args) {
        this.newFormat[i].style.color = args.currentValue.hex;
        document.querySelector('#' + this.parentID + 'valuepreview' + i).style.color =
            args.currentValue.hex;
    }
    toggleButtonClick(i) {
        this.newFormat.splice(i, 1);
        this.addFormat();
    }
    /**
     * To check is Hex or not.
     * @returns boolean
     * @hidden
     */
    isHex(h) {
        let a = parseInt(h, 16);
        while (h.charAt(0) === '0') {
            h = h.substr(1);
        }
        return (a.toString(16) === h.toLowerCase() || (a === 0 && h === ''));
    }
    /**
     * To convert hex to RGB.
     * @returns { r: number, g: number, b: number } | null
     * @hidden
     */
    hexToRgb(hex) {
        let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }
    /**
     * To convert color to hex.
     * @returns string
     * @hidden
     */
    colourNameToHex(colour) {
        let colours = {
            'aliceblue': '#f0f8ff', 'antiquewhite': '#faebd7', 'aqua': '#00ffff', 'aquamarine': '#7fffd4',
            'azure': '#f0ffff', 'beige': '#f5f5dc', 'bisque': '#ffe4c4', 'black': '#000000',
            'blanchedalmond': '#ffebcd', 'blue': '#0000ff',
            'blueviolet': '#8a2be2', 'brown': '#a52a2a', 'burlywood': '#deb887', 'cadetblue': '#5f9ea0',
            'chartreuse': '#7fff00', 'chocolate': '#d2691e',
            'coral': '#ff7f50', 'cornflowerblue': '#6495ed', 'cornsilk': '#fff8dc', 'crimson': '#dc143c', 'cyan': '#00ffff',
            'darkblue': '#00008b', 'darkcyan': '#008b8b', 'darkgoldenrod': '#b8860b', 'darkgray': '#a9a9a9', 'darkgreen': '#006400',
            'darkkhaki': '#bdb76b', 'darkmagenta': '#8b008b', 'darkolivegreen': '#556b2f',
            'darkorange': '#ff8c00', 'darkorchid': '#9932cc', 'darkred': '#8b0000', 'darksalmon': '#e9967a', 'darkseagreen': '#8fbc8f',
            'darkslateblue': '#483d8b', 'darkslategray': '#2f4f4f', 'darkturquoise': '#00ced1',
            'darkviolet': '#9400d3', 'deeppink': '#ff1493', 'deepskyblue': '#00bfff', 'dimgray': '#696969', 'dodgerblue': '#1e90ff',
            'firebrick': '#b22222', 'floralwhite': '#fffaf0', 'forestgreen': '#228b22', 'fuchsia': '#ff00ff',
            'gainsboro': '#dcdcdc', 'ghostwhite': '#f8f8ff', 'gold': '#ffd700', 'goldenrod': '#daa520',
            'gray': '#808080', 'green': '#008000',
            'greenyellow': '#adff2f', 'honeydew': '#f0fff0', 'hotpink': '#ff69b4', 'indianred ': '#cd5c5c',
            'indigo': '#4b0082', 'ivory': '#fffff0',
            'khaki': '#f0e68c', 'lavender': '#e6e6fa', 'lavenderblush': '#fff0f5', 'lawngreen': '#7cfc00', 'lemonchiffon': '#fffacd',
            'lightblue': '#add8e6', 'lightcoral': '#f08080', 'lightcyan': '#e0ffff', 'lightgoldenrodyellow': '#fafad2',
            'lightgrey': '#d3d3d3', 'lightgreen': '#90ee90', 'lightpink': '#ffb6c1', 'lightsalmon': '#ffa07a', 'lightseagreen': '#20b2aa',
            'lightskyblue': '#87cefa', 'lightslategray': '#778899', 'lightsteelblue': '#b0c4de',
            'lightyellow': '#ffffe0', 'lime': '#00ff00', 'limegreen': '#32cd32', 'linen': '#faf0e6',
            'magenta': '#ff00ff', 'maroon': '#800000', 'mediumaquamarine': '#66cdaa', 'mediumblue': '#0000cd', 'mediumorchid': '#ba55d3',
            'mediumpurple': '#9370d8', 'mediumseagreen': '#3cb371', 'mediumslateblue': '#7b68ee',
            'mediumspringgreen': '#00fa9a', 'mediumturquoise': '#48d1cc', 'mediumvioletred': '#c71585', 'midnightblue': '#191970',
            'mintcream': '#f5fffa', 'mistyrose': '#ffe4e1', 'moccasin': '#ffe4b5', 'navajowhite': '#ffdead', 'navy': '#000080',
            'oldlace': '#fdf5e6', 'olive': '#808000', 'olivedrab': '#6b8e23', 'orange': '#ffa500', 'orangered': '#ff4500',
            'orchid': '#da70d6',
            'palegoldenrod': '#eee8aa', 'palegreen': '#98fb98', 'paleturquoise': '#afeeee', 'palevioletred': '#d87093',
            'papayawhip': '#ffefd5',
            'peachpuff': '#ffdab9', 'peru': '#cd853f', 'pink': '#ffc0cb', 'plum': '#dda0dd', 'powderblue': '#b0e0e6', 'purple': '#800080',
            'rebeccapurple': '#663399', 'red': '#ff0000', 'rosybrown': '#bc8f8f', 'royalblue': '#4169e1',
            'saddlebrown': '#8b4513', 'salmon': '#fa8072', 'sandybrown': '#f4a460', 'seagreen': '#2e8b57',
            'seashell': '#fff5ee', 'sienna': '#a0522d',
            'silver': '#c0c0c0', 'skyblue': '#87ceeb', 'slateblue': '#6a5acd', 'slategray': '#708090', 'snow': '#fffafa',
            'springgreen': '#00ff7f',
            'steelblue': '#4682b4', 'tan': '#d2b48c', 'teal': '#008080', 'thistle': '#d8bfd8', 'tomato': '#ff6347', 'turquoise': '#40e0d0',
            'violet': '#ee82ee', 'wheat': '#f5deb3', 'white': '#ffffff', 'whitesmoke': '#f5f5f5', 'yellow': '#ffff00',
            'yellowgreen': '#9acd32'
        };
        if (typeof colours[colour.toLowerCase()] !== 'undefined') {
            return colours[colour.toLowerCase()];
        }
        return '#d5d5d5';
    }
    /**
     * To create Conditional Formatting dialog.
     * @returns void
     */
    showConditionalFormattingDialog() {
        this.newFormat = [];
        for (let i = 0; i < this.parent.dataSourceSettings.conditionalFormatSettings.length; i++) {
            this.newFormat.push(extend({}, this.parent.dataSourceSettings.conditionalFormatSettings[i].properties, null, true));
        }
        this.createDialog();
        this.dialog.refresh();
        this.addFormat();
    }
    /**
     * To destroy the Conditional Formatting dialog
     * @returns void
     * @hidden
     */
    destroy() {
        if (this.dialog && !this.dialog.isDestroyed) {
            this.dialog.hide();
            for (let i = 0; i < this.newFormat.length; i++) {
                if (this.fontColor[i] && !this.fontColor[i].isDestroyed) {
                    this.fontColor[i].destroy();
                }
                if (this.backgroundColor[i] && !this.backgroundColor[i].isDestroyed) {
                    this.backgroundColor[i].destroy();
                }
            }
            this.dialog.destroy();
        }
        else {
            return;
        }
    }
}

PivotView.Inject(Common);
/**
 * Module for Toolbar
 */
/** @hidden */
class Toolbar$2 {
    constructor(parent) {
        this.currentReport = '';
        this.parent = parent;
        this.parent.toolbarModule = this;
        this.addEventListener();
    }
    /**
     * It returns the Module name.
     * @returns string
     * @hidden
     */
    getModuleName() {
        return 'toolbar';
    }
    createToolbar() {
        this.parent.isModified = false;
        this.renderDialog();
        if (document.querySelector('#' + this.parent.element.id + 'pivot-toolbar') !== null) {
            remove(document.querySelector('#' + this.parent.element.id + 'pivot-toolbar'));
        }
        let element = createElement('div', {
            id: this.parent.element.id + 'pivot-toolbar',
            className: GRID_TOOLBAR
        });
        if (this.parent.showFieldList && this.parent.element.querySelector('#' + this.parent.element.id + '_PivotFieldList')) {
            this.parent.element.insertBefore(element, this.parent.element.querySelector('#' + this.parent.element.id + '_PivotFieldList'));
        }
        else if (this.parent.showGroupingBar &&
            this.parent.element.querySelector('#' + this.parent.element.id + ' .' + 'e-pivot-grouping-bar')) {
            this.parent.element.insertBefore(element, this.parent.element.querySelector('#' + this.parent.element.id + ' .' + 'e-pivot-grouping-bar'));
        }
        else {
            this.parent.element.insertBefore(element, this.parent.element.querySelector('#' + this.parent.element.id + '_grid'));
        }
        this.toolbar = new Toolbar$1({
            created: this.create.bind(this),
            enableRtl: this.parent.enableRtl,
            items: this.getItems()
        });
        this.toolbar.isStringTemplate = true;
        this.toolbar.appendTo('#' + this.parent.element.id + 'pivot-toolbar');
        this.toolbar.width = this.parent.grid ? (this.parent.getGridWidthAsNumber() - 2) : (this.parent.getWidthAsNumber() - 2);
        if (this.parent.chart) {
            this.parent.chart.width = this.parent.grid ? this.parent.getGridWidthAsNumber().toString() :
                this.parent.getWidthAsNumber().toString();
        }
        if (this.parent.showGroupingBar && this.parent.groupingBarModule &&
            this.parent.element.querySelector('.' + GROUPING_BAR_CLASS)) {
            this.parent.groupingBarModule.refreshUI();
        }
    }
    fetchReports() {
        /* tslint:disable */
        let reports = { reportName: [] };
        /* tslint:enable */
        let tool = this;
        if (isBlazor()) {
            reports = this.fetchReportsArgs();
            /* tslint:disable */
            reports.then((e) => {
                /* tslint:enable */
                tool.reportList.dataSource = e.reportName;
                return e;
            });
        }
        this.parent.trigger(fetchReport, reports);
        return reports;
    }
    fetchReportsArgs() {
        let callbackPromise = new Deferred();
        let reports = { reportName: [] };
        this.parent.trigger(fetchReport, reports, (observedArgs) => {
            callbackPromise.resolve(observedArgs);
        });
        return callbackPromise;
    }
    /* tslint:disable */
    getItems() {
        let toolbar = this.parent.toolbar.filter((v, i, a) => a.indexOf(v) === i);
        let items = [];
        for (let item of toolbar) {
            switch (item) {
                case 'New':
                    items.push({
                        prefixIcon: GRID_NEW + ' ' + ICON, tooltipText: this.parent.localeObj.getConstant('new'),
                        click: this.actionClick.bind(this), id: this.parent.element.id + 'new'
                    });
                    break;
                case 'Save':
                    items.push({
                        prefixIcon: GRID_SAVE + ' ' + ICON, tooltipText: this.parent.localeObj.getConstant('save'),
                        click: this.actionClick.bind(this), id: this.parent.element.id + 'save'
                    });
                    break;
                case 'SaveAs':
                    items.push({
                        prefixIcon: GRID_SAVEAS + ' ' + ICON, tooltipText: this.parent.localeObj.getConstant('saveAs'),
                        click: this.actionClick.bind(this), id: this.parent.element.id + 'saveas'
                    });
                    break;
                case 'Rename':
                    items.push({
                        prefixIcon: GRID_RENAME + ' ' + ICON, tooltipText: this.parent.localeObj.getConstant('rename'),
                        click: this.actionClick.bind(this), id: this.parent.element.id + 'rename'
                    });
                    break;
                case 'Remove':
                    items.push({
                        prefixIcon: GRID_REMOVE + ' ' + ICON, tooltipText: this.parent.localeObj.getConstant('deleteReport'),
                        click: this.actionClick.bind(this), id: this.parent.element.id + 'remove'
                    });
                    break;
                case 'Load':
                    items.push({
                        template: '<div><input class=' + GRID_LOAD + ' id=' + this.parent.element.id + '_reportlist></input></div>',
                        click: this.actionClick.bind(this),
                        id: this.parent.element.id + 'load'
                    });
                    break;
                case 'Grid':
                    let toDisable = this.parent.displayOption.view === 'Chart';
                    items.push({
                        prefixIcon: TOOLBAR_GRID + ' ' + ICON, tooltipText: this.parent.localeObj.getConstant('grid'),
                        id: this.parent.element.id + 'grid', cssClass: toDisable ? MENU_DISABLE : '',
                        click: this.menuItemClick.bind(this)
                    });
                    break;
                case 'Chart':
                    items.push({
                        template: '<ul id="' + this.parent.element.id + 'chart_menu"></ul>',
                        id: this.parent.element.id + 'chartmenu'
                    });
                    break;
                case 'MDX':
                    if (this.parent.dataType == "olap") {
                        items.push({
                            prefixIcon: GRID_MDX + ' ' + ICON, id: this.parent.element.id + 'mdxQuery',
                            click: this.actionClick.bind(this), tooltipText: this.parent.localeObj.getConstant('mdxQuery')
                        });
                    }
                    break;
                case 'Export':
                    items.push({
                        template: '<ul id="' + this.parent.element.id + 'export_menu"></ul>',
                        id: this.parent.element.id + 'exportmenu'
                    });
                    break;
                case 'SubTotal':
                    items.push({
                        template: '<ul id="' + this.parent.element.id + 'subtotal_menu"></ul>',
                        id: this.parent.element.id + 'subtotalmenu'
                    });
                    break;
                case 'GrandTotal':
                    items.push({
                        template: '<ul id="' + this.parent.element.id + 'grandtotal_menu"></ul>',
                        id: this.parent.element.id + 'grandtotalmenu'
                    });
                    break;
                case 'ConditionalFormatting':
                    items.push({
                        prefixIcon: GRID_FORMATTING + ' ' + ICON, id: this.parent.element.id + 'formatting',
                        click: this.actionClick.bind(this), tooltipText: this.parent.localeObj.getConstant('toolbarFormatting')
                    });
                    break;
                case 'NumberFormatting':
                    items.push({
                        prefixIcon: FORMATTING_TOOLBAR + ' ' + ICON, id: this.parent.element.id + 'numberFormatting',
                        click: this.actionClick.bind(this), tooltipText: this.parent.localeObj.getConstant('numberFormat')
                    });
                    break;
                case 'Formatting':
                    items.push({
                        template: '<ul id="' + this.parent.element.id + 'formatting_menu"></ul>',
                        id: this.parent.element.id + 'formattingmenu'
                    });
                    break;
                case 'FieldList':
                    items.push({
                        prefixIcon: TOOLBAR_FIELDLIST + ' ' + ICON, tooltipText: this.parent.localeObj.getConstant('fieldList'),
                        click: this.actionClick.bind(this), align: 'Right', id: this.parent.element.id + 'fieldlist'
                    });
                    if (this.parent.element.querySelector('.e-toggle-field-list')) {
                        this.parent.element.querySelector('.e-toggle-field-list').style.display = 'none';
                    }
                    break;
            }
        }
        if (this.parent.showFieldList && toolbar.indexOf("FieldList") === -1 && this.parent.element.querySelector('#' + this.parent.element.id + '_PivotFieldList').style.display === 'none') {
            this.parent.element.querySelector('#' + this.parent.element.id + '_PivotFieldList').style.display = 'block';
        }
        let toolbarArgs = { customToolbar: items };
        this.parent.trigger(toolbarRender, toolbarArgs);
        return items;
    }
    /* tslint:enable */
    reportChange(args) {
        this.dropArgs = args;
        if (this.parent.isModified && this.currentReport !== '') {
            this.createConfirmDialog(this.parent.localeObj.getConstant('alert'), this.parent.localeObj.getConstant('newReportConfirm'));
        }
        else {
            this.reportLoad(args);
        }
    }
    reportLoad(args) {
        if (this.action !== 'Save' && this.action !== 'Rename' && this.action !== 'New') {
            let loadArgs = {
                reportName: args.itemData.value
            };
            this.parent.trigger(loadReport, loadArgs, (observedArgs) => {
                this.currentReport = observedArgs.reportName;
                this.parent.isModified = false;
            });
        }
    }
    saveReport(args) {
        if (this.currentReport && this.currentReport !== '' && args.item.id === (this.parent.element.id + 'save')) {
            let saveArgs = {
                report: this.parent.getPersistData(),
                reportName: this.currentReport
            };
            this.parent.trigger(saveReport, saveArgs);
            this.parent.isModified = false;
        }
        else {
            this.dialogShow(args, 'saveAs');
        }
    }
    mdxQueryDialog(args) {
        if (!(this.mdxDialog && !this.mdxDialog.isDestroyed)) {
            this.renderMDXDialog();
        }
        let outerDiv = createElement('div', {
            className: MDX_QUERY
        });
        let textarea = createElement('textarea', {
            className: MDX_QUERY_CONTENT,
            innerHTML: this.parent.olapEngineModule.getMDXQuery(this.parent.dataSourceSettings).trim(),
            attrs: { 'readonly': 'readonly' }
        });
        outerDiv.appendChild(textarea);
        this.mdxDialog.content = outerDiv;
        this.mdxDialog.show();
    }
    dialogShow(args, action) {
        this.dialog.header = args.item.tooltipText;
        let outerDiv = createElement('div', {
            className: GRID_REPORT_OUTER
        });
        let label = createElement('div', {
            className: GRID_REPORT_LABEL,
            innerHTML: this.parent.localeObj.getConstant('reportName')
        });
        let input = createElement('input', {
            className: GRID_REPORT_INPUT + ' ' + INPUT,
            innerHTML: (action && action === 'rename' ? this.currentReport : ''),
            attrs: {
                'placeholder': this.parent.localeObj.getConstant('emptyReportName'),
                'value': (action && action === 'rename' ? this.currentReport : '')
            },
        });
        input.setSelectionRange(input.textContent.length, input.textContent.length);
        outerDiv.appendChild(label);
        outerDiv.appendChild(input);
        this.dialog.content = outerDiv;
        this.dialog.refresh();
        this.dialog.show();
    }
    renameReport(args) {
        this.parent.trigger(toolbarClick, args);
        if (this.currentReport && this.currentReport !== '') {
            this.dialogShow(args, 'rename');
        }
        else {
            this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('error'), this.parent.localeObj.getConstant('emptyReport'));
            return;
        }
    }
    actionClick(args) {
        switch (args.item.id) {
            case (this.parent.element.id + 'save'):
            case (this.parent.element.id + 'saveas'):
                this.saveReport(args);
                break;
            case (this.parent.element.id + 'remove'):
                this.action = 'Remove';
                if (this.currentReport && this.currentReport !== '') {
                    this.createConfirmDialog(this.parent.localeObj.getConstant('alert'), this.parent.localeObj.getConstant('removeConfirm'));
                }
                else {
                    this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('error'), this.parent.localeObj.getConstant('emptyReport'));
                }
                return;
            case (this.parent.element.id + 'rename'):
                this.renameReport(args);
                break;
            case (this.parent.element.id + 'new'):
                this.action = 'New';
                if (this.parent.isModified) {
                    this.createConfirmDialog(this.parent.localeObj.getConstant('alert'), this.parent.localeObj.getConstant('newReportConfirm'));
                }
                else {
                    this.createNewReport();
                }
                break;
            case (this.parent.element.id + 'load'):
                this.action = 'Load';
                break;
            case (this.parent.element.id + 'fieldlist'):
                if (this.parent.pivotFieldListModule && this.parent.pivotFieldListModule.dialogRenderer) {
                    this.parent.pivotFieldListModule.dialogRenderer.fieldListDialog.show();
                }
                break;
            case (this.parent.element.id + 'formatting'):
                if (this.parent.conditionalFormattingModule) {
                    this.parent.conditionalFormattingModule.showConditionalFormattingDialog();
                }
                break;
            case (this.parent.element.id + 'mdxQuery'):
                this.mdxQueryDialog(args);
                break;
            case (this.parent.element.id + 'numberFormatting'):
                if (this.parent.numberFormattingModule) {
                    this.parent.numberFormattingModule.showNumberFormattingDialog();
                }
                break;
        }
    }
    renderDialog() {
        if (document.querySelector('#' + this.parent.element.id + 'report-dialog') !== null) {
            remove(document.querySelector('#' + this.parent.element.id + 'report-dialog'));
        }
        this.parent.element.appendChild(createElement('div', {
            id: this.parent.element.id + 'report-dialog',
            className: GRID_REPORT_DIALOG
        }));
        this.dialog = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: true,
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    click: this.okBtnClick.bind(this),
                    buttonModel: {
                        content: this.parent.localeObj.getConstant('ok'),
                        isPrimary: true
                    }
                },
                {
                    click: this.cancelBtnClick.bind(this),
                    buttonModel: {
                        content: this.parent.localeObj.getConstant('cancel')
                    }
                }
            ],
            isModal: true,
            visible: false,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            width: 'auto',
            height: 'auto',
            zIndex: 1000001,
            closeOnEscape: true,
            target: document.body
        });
        this.dialog.isStringTemplate = true;
        this.dialog.appendTo('#' + this.parent.element.id + 'report-dialog');
    }
    renderMDXDialog() {
        if (document.querySelector('#' + this.parent.element.id + 'mdx-dialog') !== null) {
            remove(document.querySelector('#' + this.parent.element.id + 'mdx-dialog'));
        }
        this.parent.element.appendChild(createElement('div', {
            id: this.parent.element.id + 'mdx-dialog',
            className: GRID_MDX_DIALOG
        }));
        this.mdxDialog = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: true,
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    click: this.copyMDXQuery.bind(this),
                    buttonModel: {
                        content: this.parent.localeObj.getConstant('copy'),
                        isPrimary: true
                    }
                }
            ],
            header: this.parent.localeObj.getConstant('mdxQuery'),
            isModal: true,
            visible: false,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            width: 'auto',
            height: 'auto',
            zIndex: 1000001,
            closeOnEscape: true,
            target: document.body
        });
        this.mdxDialog.isStringTemplate = true;
        this.mdxDialog.appendTo('#' + this.parent.element.id + 'mdx-dialog');
    }
    copyMDXQuery() {
        let textArea = this.mdxDialog.element.querySelector('.' + MDX_QUERY_CONTENT);
        try {
            textArea.select();
            document.execCommand('copy');
        }
        catch (err) {
            window.alert('Oops, unable to copy');
        }
        return;
    }
    okBtnClick() {
        let reportInput = this.dialog.element.querySelector('.' + GRID_REPORT_INPUT);
        if (reportInput && reportInput.value === '') {
            reportInput.focus();
            return;
        }
        let isNew = false;
        if ((this.dialog.header === this.parent.localeObj.getConstant('save') ||
            this.dialog.header === this.parent.localeObj.getConstant('saveAs')) &&
            reportInput.value && reportInput.value !== '') {
            if (this.action === 'New') {
                isNew = true;
            }
            else {
                this.action = 'Save';
            }
            this.currentReport = reportInput.value;
            let saveArgs = {
                report: this.parent.getPersistData(),
                reportName: reportInput.value
            };
            this.parent.trigger(saveReport, saveArgs);
            this.parent.isModified = false;
        }
        else if (this.dialog.header === this.parent.localeObj.getConstant('rename') && reportInput.value && reportInput.value !== '') {
            this.action = 'Rename';
            let renameArgs = {
                reportName: this.currentReport,
                rename: reportInput.value
            };
            this.parent.trigger(renameReport, renameArgs);
            this.currentReport = reportInput.value;
        }
        this.updateReportList();
        this.dialog.hide();
        if (isNew) {
            this.createNewReport();
        }
    }
    createNewReport() {
        this.currentReport = '';
        this.reportList.value = '';
        this.reportList.text = '';
        this.reportList.refresh();
        this.parent.trigger(newReport);
        this.parent.isModified = false;
    }
    cancelBtnClick() {
        this.dialog.hide();
    }
    createConfirmDialog(title, description) {
        if (document.getElementById(this.parent.element.id + '_ConfirmDialog')) {
            remove(document.getElementById(this.parent.element.id + '_ConfirmDialog').parentElement);
        }
        let errorDialog = createElement('div', {
            id: this.parent.element.id + '_ConfirmDialog',
            className: ERROR_DIALOG_CLASS
        });
        this.parent.element.appendChild(errorDialog);
        this.confirmPopUp = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: true,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            header: title,
            content: description,
            isModal: true,
            visible: true,
            closeOnEscape: true,
            target: document.body,
            width: 'auto',
            height: 'auto',
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    buttonModel: {
                        content: this.parent.localeObj.getConstant('ok'), isPrimary: true,
                        cssClass: OK_BUTTON_CLASS
                    },
                    click: this.okButtonClick.bind(this)
                },
                {
                    buttonModel: {
                        content: this.parent.localeObj.getConstant('cancel'),
                        cssClass: CANCEL_BUTTON_CLASS
                    },
                    click: this.cancelButtonClick.bind(this)
                }
            ]
        });
        this.confirmPopUp.isStringTemplate = true;
        this.confirmPopUp.appendTo(errorDialog);
        this.confirmPopUp.element.querySelector('.e-dlg-header').innerHTML = title;
    }
    okButtonClick() {
        if (this.action === 'Remove') {
            let removeArgs = {
                reportName: this.currentReport
            };
            this.parent.trigger(removeReport, removeArgs);
            this.currentReport = '';
            this.parent.isModified = false;
            this.action = '';
            this.updateReportList();
        }
        else if (this.action === 'New' || (this.action !== 'Save' && this.action !== 'Rename' && this.action !== 'New')) {
            if (this.currentReport && this.currentReport !== '') {
                let saveArgs = {
                    report: this.parent.getPersistData(),
                    reportName: this.currentReport
                };
                this.parent.trigger(saveReport, saveArgs);
                this.parent.isModified = false;
                if (this.action === 'New') {
                    this.createNewReport();
                }
                else {
                    this.reportLoad(this.dropArgs);
                }
            }
            else {
                this.dialogShow({ item: { tooltipText: this.parent.localeObj.getConstant('save') } });
            }
        }
        this.confirmPopUp.hide();
    }
    cancelButtonClick() {
        if (this.action === 'New') {
            this.createNewReport();
        }
        else if (this.dropArgs && this.action !== 'Remove') {
            this.reportLoad(this.dropArgs);
        }
        this.confirmPopUp.hide();
    }
    /* tslint:disable */
    create() {
        let toDisable = this.parent.displayOption.view === 'Table';
        if (this.parent.element.querySelector('#' + this.parent.element.id + 'chart_menu')) {
            let menu = [{
                    iconCss: TOOLBAR_CHART + ' ' + ICON,
                    items: toDisable ? [] : [
                        {
                            text: this.parent.localeObj.getConstant('column'),
                            id: this.parent.element.id + '_' + 'Column',
                        },
                        {
                            text: this.parent.localeObj.getConstant('bar'),
                            id: this.parent.element.id + '_' + 'Bar'
                        },
                        {
                            text: this.parent.localeObj.getConstant('line'),
                            id: this.parent.element.id + '_' + 'Line'
                        },
                        {
                            text: this.parent.localeObj.getConstant('area'),
                            id: this.parent.element.id + '_' + 'Area'
                        },
                        {
                            text: this.parent.localeObj.getConstant('scatter'),
                            id: this.parent.element.id + '_' + 'Scatter'
                        },
                        {
                            text: this.parent.localeObj.getConstant('polar'),
                            id: this.parent.element.id + '_' + 'Polar'
                        }
                    ]
                }];
            this.chartMenu = new Menu({
                items: menu, enableRtl: this.parent.enableRtl,
                select: this.menuItemClick.bind(this)
            });
            this.chartMenu.isStringTemplate = true;
            this.chartMenu.appendTo('#' + this.parent.element.id + 'chart_menu');
        }
        if (this.parent.element.querySelector('#' + this.parent.element.id + 'export_menu')) {
            let menu = [{
                    iconCss: GRID_EXPORT + ' ' + ICON,
                    items: [
                        {
                            text: this.parent.localeObj.getConstant('pdf'),
                            iconCss: GRID_PDF_EXPORT + ' ' + ICON,
                            id: this.parent.element.id + 'pdf'
                        },
                        {
                            text: this.parent.localeObj.getConstant('excel'),
                            iconCss: GRID_EXCEL_EXPORT + ' ' + ICON,
                            id: this.parent.element.id + 'excel'
                        },
                        {
                            text: this.parent.localeObj.getConstant('csv'),
                            iconCss: GRID_CSV_EXPORT + ' ' + ICON,
                            id: this.parent.element.id + 'csv'
                        },
                        {
                            text: this.parent.localeObj.getConstant('png'),
                            iconCss: GRID_PNG_EXPORT + ' ' + ICON,
                            id: this.parent.element.id + 'png'
                        },
                        {
                            text: this.parent.localeObj.getConstant('jpeg'),
                            iconCss: GRID_JPEG_EXPORT + ' ' + ICON,
                            id: this.parent.element.id + 'jpeg'
                        },
                        {
                            text: this.parent.localeObj.getConstant('svg'),
                            iconCss: GRID_SVG_EXPORT + ' ' + ICON,
                            id: this.parent.element.id + 'svg'
                        }
                    ]
                }];
            this.exportMenu = new Menu({
                items: menu, enableRtl: this.parent.enableRtl,
                select: this.menuItemClick.bind(this), beforeOpen: this.updateExportMenu.bind(this)
            });
            this.exportMenu.isStringTemplate = true;
            this.exportMenu.appendTo('#' + this.parent.element.id + 'export_menu');
        }
        if (this.parent.element.querySelector('#' + this.parent.element.id + 'subtotal_menu')) {
            let menu = [{
                    iconCss: GRID_SUB_TOTAL + ' ' + ICON,
                    items: [
                        {
                            text: this.parent.localeObj.getConstant('showSubTotals'),
                            id: this.parent.element.id + 'subtotal',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                        {
                            text: this.parent.localeObj.getConstant('doNotShowSubTotals'),
                            id: this.parent.element.id + 'notsubtotal',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                        {
                            text: this.parent.localeObj.getConstant('showSubTotalsRowsOnly'),
                            id: this.parent.element.id + 'subtotalrow',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                        {
                            text: this.parent.localeObj.getConstant('showSubTotalsColumnsOnly'),
                            id: this.parent.element.id + 'subtotalcolumn',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                    ]
                }];
            this.subTotalMenu = new Menu({
                items: menu, enableRtl: this.parent.enableRtl,
                select: this.menuItemClick.bind(this), beforeOpen: this.updateSubtotalSelection.bind(this)
            });
            this.subTotalMenu.isStringTemplate = true;
            this.subTotalMenu.appendTo('#' + this.parent.element.id + 'subtotal_menu');
        }
        if (this.parent.element.querySelector('#' + this.parent.element.id + 'grandtotal_menu')) {
            let menu = [{
                    iconCss: GRID_GRAND_TOTAL + ' ' + ICON,
                    items: [
                        {
                            text: this.parent.localeObj.getConstant('showGrandTotals'),
                            id: this.parent.element.id + 'grandtotal',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                        {
                            text: this.parent.localeObj.getConstant('doNotShowGrandTotals'),
                            id: this.parent.element.id + 'notgrandtotal',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                        {
                            text: this.parent.localeObj.getConstant('showGrandTotalsRowsOnly'),
                            id: this.parent.element.id + 'grandtotalrow',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                        {
                            text: this.parent.localeObj.getConstant('showGrandTotalsColumnsOnly'),
                            id: this.parent.element.id + 'grandtotalcolumn',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                    ]
                }];
            this.grandTotalMenu = new Menu({
                items: menu, enableRtl: this.parent.enableRtl,
                select: this.menuItemClick.bind(this), beforeOpen: this.updateGrandtotalSelection.bind(this)
            });
            this.grandTotalMenu.isStringTemplate = true;
            this.grandTotalMenu.appendTo('#' + this.parent.element.id + 'grandtotal_menu');
        }
        if (this.parent.element.querySelector('#' + this.parent.element.id + 'formatting_menu')) {
            let menu = [{
                    iconCss: FORMATTING_MENU + ' ' + ICON,
                    items: [
                        {
                            text: this.parent.localeObj.getConstant('numberFormat'),
                            iconCss: NUMBER_FORMATTING_MENU + ' ' + ICON,
                            id: this.parent.element.id + 'numberFormattingMenu'
                        },
                        {
                            text: this.parent.localeObj.getConstant('conditionalFormating'),
                            iconCss: CONDITIONAL_FORMATTING_MENU + ' ' + ICON,
                            id: this.parent.element.id + 'conditionalFormattingMenu'
                        }
                    ]
                }];
            this.formattingMenu = new Menu({
                items: menu, enableRtl: this.parent.enableRtl,
                select: this.menuItemClick.bind(this)
            });
            this.formattingMenu.isStringTemplate = true;
            this.formattingMenu.appendTo('#' + this.parent.element.id + 'formatting_menu');
        }
        if (this.parent.element.querySelector('#' + this.parent.element.id + '_reportlist')) {
            let saveArgs = {
                report: this.parent.getPersistData(),
                reportName: this.parent.localeObj.getConstant('defaultReport')
            };
            this.currentReport = this.parent.localeObj.getConstant('defaultReport');
            this.parent.trigger(saveReport, saveArgs);
            let reports = this.fetchReports();
            this.reportList = new DropDownList({
                dataSource: reports.reportName,
                width: '150px',
                popupHeight: '200px',
                placeholder: this.currentReport === '' ? this.parent.localeObj.getConstant('reportList') : '',
                enableRtl: this.parent.enableRtl,
                cssClass: REPORT_LIST_DROP,
                select: this.reportChange.bind(this),
                value: this.currentReport
            });
            this.reportList.isStringTemplate = true;
            this.reportList.appendTo('#' + this.parent.element.id + '_reportlist');
        }
    }
    updateExportMenu(args) {
        if (this.parent.currentView == "Table") {
            args.element.querySelector('#' + this.parent.element.id + 'png').remove();
            args.element.querySelector('#' + this.parent.element.id + 'jpeg').remove();
            args.element.querySelector('#' + this.parent.element.id + 'svg').remove();
        }
        else {
            args.element.querySelector('#' + this.parent.element.id + 'excel').remove();
            args.element.querySelector('#' + this.parent.element.id + 'csv').remove();
        }
    }
    updateSubtotalSelection(args) {
        if (!args.element.querySelector('#' + this.parent.element.id + 'subtotal' + ' .' + PIVOT_SELECT_ICON).classList.contains(PIVOT_DISABLE_ICON)) {
            args.element.querySelector('#' + this.parent.element.id + 'subtotal' + ' .' + PIVOT_SELECT_ICON).classList.add(PIVOT_DISABLE_ICON);
        }
        if (!args.element.querySelector('#' + this.parent.element.id + 'notsubtotal' + ' .' + PIVOT_SELECT_ICON).classList.contains(PIVOT_DISABLE_ICON)) {
            args.element.querySelector('#' + this.parent.element.id + 'notsubtotal' + ' .' + PIVOT_SELECT_ICON).classList.add(PIVOT_DISABLE_ICON);
        }
        if (!args.element.querySelector('#' + this.parent.element.id + 'subtotalrow' + ' .' + PIVOT_SELECT_ICON).classList.contains(PIVOT_DISABLE_ICON)) {
            args.element.querySelector('#' + this.parent.element.id + 'subtotalrow' + ' .' + PIVOT_SELECT_ICON).classList.add(PIVOT_DISABLE_ICON);
        }
        if (!args.element.querySelector('#' + this.parent.element.id + 'subtotalcolumn' + ' .' + PIVOT_SELECT_ICON).classList.contains(PIVOT_DISABLE_ICON)) {
            args.element.querySelector('#' + this.parent.element.id + 'subtotalcolumn' + ' .' + PIVOT_SELECT_ICON).classList.add(PIVOT_DISABLE_ICON);
        }
        if (this.parent.dataSourceSettings.showSubTotals && this.parent.dataSourceSettings.showRowSubTotals && !this.parent.dataSourceSettings.showColumnSubTotals) {
            args.element.querySelector('#' + this.parent.element.id + 'subtotalrow' + ' .' + PIVOT_SELECT_ICON).classList.remove(PIVOT_DISABLE_ICON);
        }
        else if (this.parent.dataSourceSettings.showSubTotals && !this.parent.dataSourceSettings.showRowSubTotals && this.parent.dataSourceSettings.showColumnSubTotals) {
            args.element.querySelector('#' + this.parent.element.id + 'subtotalcolumn' + ' .' + PIVOT_SELECT_ICON).classList.remove(PIVOT_DISABLE_ICON);
        }
        else if (this.parent.dataSourceSettings.showSubTotals && this.parent.dataSourceSettings.showRowSubTotals && this.parent.dataSourceSettings.showColumnSubTotals) {
            args.element.querySelector('#' + this.parent.element.id + 'subtotal' + ' .' + PIVOT_SELECT_ICON).classList.remove(PIVOT_DISABLE_ICON);
        }
        else if (!this.parent.dataSourceSettings.showSubTotals || (!this.parent.dataSourceSettings.showRowSubTotals && !this.parent.dataSourceSettings.showColumnSubTotals)) {
            args.element.querySelector('#' + this.parent.element.id + 'notsubtotal' + ' .' + PIVOT_SELECT_ICON).classList.remove(PIVOT_DISABLE_ICON);
        }
    }
    updateGrandtotalSelection(args) {
        if (!args.element.querySelector('#' + this.parent.element.id + 'grandtotal' + ' .' + PIVOT_SELECT_ICON).classList.contains(PIVOT_DISABLE_ICON)) {
            args.element.querySelector('#' + this.parent.element.id + 'grandtotal' + ' .' + PIVOT_SELECT_ICON).classList.add(PIVOT_DISABLE_ICON);
        }
        if (!args.element.querySelector('#' + this.parent.element.id + 'notgrandtotal' + ' .' + PIVOT_SELECT_ICON).classList.contains(PIVOT_DISABLE_ICON)) {
            args.element.querySelector('#' + this.parent.element.id + 'notgrandtotal' + ' .' + PIVOT_SELECT_ICON).classList.add(PIVOT_DISABLE_ICON);
        }
        if (!args.element.querySelector('#' + this.parent.element.id + 'grandtotalrow' + ' .' + PIVOT_SELECT_ICON).classList.contains(PIVOT_DISABLE_ICON)) {
            args.element.querySelector('#' + this.parent.element.id + 'grandtotalrow' + ' .' + PIVOT_SELECT_ICON).classList.add(PIVOT_DISABLE_ICON);
        }
        if (!args.element.querySelector('#' + this.parent.element.id + 'grandtotalcolumn' + ' .' + PIVOT_SELECT_ICON).classList.contains(PIVOT_DISABLE_ICON)) {
            args.element.querySelector('#' + this.parent.element.id + 'grandtotalcolumn' + ' .' + PIVOT_SELECT_ICON).classList.add(PIVOT_DISABLE_ICON);
        }
        if (this.parent.dataSourceSettings.showGrandTotals && this.parent.dataSourceSettings.showRowGrandTotals && !this.parent.dataSourceSettings.showColumnGrandTotals) {
            args.element.querySelector('#' + this.parent.element.id + 'grandtotalrow' + ' .' + PIVOT_SELECT_ICON).classList.remove(PIVOT_DISABLE_ICON);
        }
        else if (this.parent.dataSourceSettings.showGrandTotals && !this.parent.dataSourceSettings.showRowGrandTotals && this.parent.dataSourceSettings.showColumnGrandTotals) {
            args.element.querySelector('#' + this.parent.element.id + 'grandtotalcolumn' + ' .' + PIVOT_SELECT_ICON).classList.remove(PIVOT_DISABLE_ICON);
        }
        else if (this.parent.dataSourceSettings.showGrandTotals && this.parent.dataSourceSettings.showRowGrandTotals && this.parent.dataSourceSettings.showColumnGrandTotals) {
            args.element.querySelector('#' + this.parent.element.id + 'grandtotal' + ' .' + PIVOT_SELECT_ICON).classList.remove(PIVOT_DISABLE_ICON);
        }
        else if (!this.parent.dataSourceSettings.showGrandTotals || (!this.parent.dataSourceSettings.showRowGrandTotals && !this.parent.dataSourceSettings.showColumnGrandTotals)) {
            args.element.querySelector('#' + this.parent.element.id + 'notgrandtotal' + ' .' + PIVOT_SELECT_ICON).classList.remove(PIVOT_DISABLE_ICON);
        }
    }
    updateReportList() {
        let reports;
        if (isBlazor()) {
            reports = this.fetchReports();
            if (reports.reportName === undefined) {
                reports.reportName = this.reportList.dataSource;
            }
        }
        else {
            reports = this.fetchReports();
        }
        this.reportList.dataSource = reports.reportName;
        if (this.currentReport === '' && this.reportList.dataSource.length > 0) {
            this.reportList.value = this.reportList.dataSource[this.reportList.dataSource.length - 1];
            this.reportList.text = this.reportList.dataSource[this.reportList.dataSource.length - 1];
            this.currentReport = this.reportList.dataSource[this.reportList.dataSource.length - 1];
        }
        else {
            this.reportList.value = this.currentReport;
            this.reportList.text = this.currentReport;
        }
        this.reportList.refresh();
    }
    menuItemClick(args) {
        let exportArgs = {
            pdfExportProperties: undefined,
            isMultipleExport: undefined,
            pdfDoc: undefined,
            isBlob: undefined,
            excelExportProperties: undefined,
            workbook: undefined,
            type: undefined,
            fileName: undefined,
            orientation: undefined,
            width: undefined,
            height: undefined,
        };
        switch (args.item.id) {
            case (this.parent.element.id + 'grid'):
                if (this.parent.grid && this.parent.chart) {
                    this.parent.grid.element.style.display = '';
                    this.parent.chart.element.style.display = 'none';
                    this.parent.currentView = 'Table';
                    this.parent.setProperties({ displayOption: { primary: 'Table' } }, true);
                    if (this.parent.showGroupingBar) {
                        this.parent.element.querySelector('.e-pivot-grouping-bar').style.display = "";
                        this.parent.element.querySelector('.e-chart-grouping-bar').style.display = "none";
                    }
                    this.parent.layoutRefresh();
                }
                if (isBlazor() && this.parent.element.querySelector('.e-toggle-field-list') && this.parent.toolbar.indexOf('FieldList') !== -1) {
                    this.parent.element.querySelector('.e-toggle-field-list').style.display = 'none';
                }
                break;
            case (this.parent.element.id + '_' + 'Column'):
            case (this.parent.element.id + '_' + 'Bar'):
            case (this.parent.element.id + '_' + 'Line'):
            case (this.parent.element.id + '_' + 'Area'):
            case (this.parent.element.id + '_' + 'Scatter'):
            case (this.parent.element.id + '_' + 'Polar'):
                if (args.item && args.item.text) {
                    this.parent.chartSettings.chartSeries.type = args.item.id.split('_')[args.item.id.split('_').length - 1];
                    if (this.parent.grid && this.parent.chart) {
                        this.parent.grid.element.style.display = 'none';
                        this.parent.chart.element.style.display = '';
                        this.parent.currentView = 'Chart';
                        this.parent.setProperties({ displayOption: { primary: 'Chart' } }, true);
                        this.parent.chart.element.style.width = formatUnit(this.parent.grid ? this.parent.getGridWidthAsNumber() : this.parent.getWidthAsNumber());
                        this.parent.chart.width = formatUnit(this.parent.grid ? this.parent.getGridWidthAsNumber() : this.parent.getWidthAsNumber());
                        if (this.parent.showGroupingBar) {
                            this.parent.element.querySelector('.e-pivot-grouping-bar').style.display = "none";
                            this.parent.element.querySelector('.e-chart-grouping-bar').style.display = "";
                        }
                    }
                }
                if (isBlazor() && this.parent.element.querySelector('.e-toggle-field-list') && this.parent.toolbar.indexOf('FieldList') !== -1) {
                    this.parent.element.querySelector('.e-toggle-field-list').style.display = 'none';
                }
                break;
            case (this.parent.element.id + 'pdf'):
                if (this.parent.currentView == "Table") {
                    if (this.parent.pdfExportModule) {
                        this.parent.pdfExportModule.exportToPDF();
                    }
                    else {
                        this.parent.trigger(beforeExport, exportArgs);
                        this.parent.pdfExport(exportArgs.pdfExportProperties, exportArgs.isMultipleExport, exportArgs.pdfDoc, exportArgs.isBlob);
                    }
                }
                else {
                    this.parent.trigger(beforeExport, exportArgs);
                    this.parent.chartExport(exportArgs.type ? exportArgs.type : 'PDF', exportArgs.fileName ? exportArgs.fileName : 'result', exportArgs.orientation, exportArgs.width, exportArgs.height);
                }
                break;
            case (this.parent.element.id + 'excel'):
                if (this.parent.excelExportModule) {
                    this.parent.excelExportModule.exportToExcel('Excel');
                }
                else {
                    this.parent.trigger(beforeExport, exportArgs);
                    this.parent.excelExport(exportArgs.excelExportProperties, exportArgs.isMultipleExport, exportArgs.workbook, exportArgs.isBlob);
                }
                break;
            case (this.parent.element.id + 'csv'):
                if (this.parent.excelExportModule) {
                    this.parent.excelExportModule.exportToExcel('csv');
                }
                else {
                    this.parent.trigger(beforeExport, exportArgs);
                    this.parent.csvExport(exportArgs.excelExportProperties, exportArgs.isMultipleExport, exportArgs.workbook, exportArgs.isBlob);
                }
                break;
            case (this.parent.element.id + 'png'):
                this.parent.trigger(beforeExport, exportArgs);
                this.parent.chartExport(exportArgs.type ? exportArgs.type : 'PNG', exportArgs.fileName ? exportArgs.fileName : 'result', exportArgs.orientation, exportArgs.width, exportArgs.height);
                break;
            case (this.parent.element.id + 'jpeg'):
                this.parent.trigger(beforeExport, exportArgs);
                this.parent.chartExport(exportArgs.type ? exportArgs.type : 'JPEG', exportArgs.fileName ? exportArgs.fileName : 'result', exportArgs.orientation, exportArgs.width, exportArgs.height);
                break;
            case (this.parent.element.id + 'svg'):
                this.parent.trigger(beforeExport, exportArgs);
                this.parent.chartExport(exportArgs.type ? exportArgs.type : 'SVG', exportArgs.fileName ? exportArgs.fileName : 'result', exportArgs.orientation, exportArgs.width, exportArgs.height);
                break;
            case (this.parent.element.id + 'notsubtotal'):
                this.parent.dataSourceSettings.showSubTotals = false;
                this.parent.dataSourceSettings.showColumnSubTotals = false;
                this.parent.dataSourceSettings.showRowSubTotals = false;
                break;
            case (this.parent.element.id + 'subtotalrow'):
                this.parent.dataSourceSettings.showSubTotals = true;
                this.parent.dataSourceSettings.showColumnSubTotals = false;
                this.parent.dataSourceSettings.showRowSubTotals = true;
                break;
            case (this.parent.element.id + 'subtotalcolumn'):
                this.parent.dataSourceSettings.showSubTotals = true;
                this.parent.dataSourceSettings.showColumnSubTotals = true;
                this.parent.dataSourceSettings.showRowSubTotals = false;
                break;
            case (this.parent.element.id + 'subtotal'):
                this.parent.dataSourceSettings.showSubTotals = true;
                this.parent.dataSourceSettings.showColumnSubTotals = true;
                this.parent.dataSourceSettings.showRowSubTotals = true;
                break;
            case (this.parent.element.id + 'notgrandtotal'):
                this.parent.dataSourceSettings.showGrandTotals = false;
                this.parent.dataSourceSettings.showColumnGrandTotals = false;
                this.parent.dataSourceSettings.showRowGrandTotals = false;
                break;
            case (this.parent.element.id + 'grandtotalrow'):
                this.parent.dataSourceSettings.showGrandTotals = true;
                this.parent.dataSourceSettings.showColumnGrandTotals = false;
                this.parent.dataSourceSettings.showRowGrandTotals = true;
                break;
            case (this.parent.element.id + 'grandtotalcolumn'):
                this.parent.dataSourceSettings.showGrandTotals = true;
                this.parent.dataSourceSettings.showColumnGrandTotals = true;
                this.parent.dataSourceSettings.showRowGrandTotals = false;
                break;
            case (this.parent.element.id + 'grandtotal'):
                this.parent.dataSourceSettings.showGrandTotals = true;
                this.parent.dataSourceSettings.showColumnGrandTotals = true;
                this.parent.dataSourceSettings.showRowGrandTotals = true;
                break;
            case (this.parent.element.id + 'numberFormattingMenu'):
                if (this.parent.numberFormattingModule) {
                    this.parent.numberFormattingModule.showNumberFormattingDialog();
                }
                break;
            case (this.parent.element.id + 'conditionalFormattingMenu'):
                if (this.parent.conditionalFormattingModule) {
                    this.parent.conditionalFormattingModule.showConditionalFormattingDialog();
                }
                break;
        }
    }
    /**
     * @hidden
     */
    addEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(initToolbar, this.createToolbar, this);
    }
    /**
     * To refresh the toolbar
     * @return {void}
     * @hidden
     */
    refreshToolbar() {
        this.createToolbar();
    }
    /**
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(initToolbar, this.createToolbar);
    }
    /**
     * To destroy the toolbar
     * @return {void}
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        if (this.confirmPopUp && !this.confirmPopUp.isDestroyed) {
            this.confirmPopUp.destroy();
        }
        if (this.dialog && !this.dialog.isDestroyed) {
            this.dialog.destroy();
        }
        if (this.mdxDialog && !this.mdxDialog.isDestroyed) {
            this.mdxDialog.destroy();
        }
        if (this.chartMenu && !this.chartMenu.isDestroyed) {
            this.chartMenu.destroy();
        }
        if (this.exportMenu && !this.exportMenu.isDestroyed) {
            this.exportMenu.destroy();
        }
        if (this.subTotalMenu && !this.subTotalMenu.isDestroyed) {
            this.subTotalMenu.destroy();
        }
        if (this.grandTotalMenu && !this.grandTotalMenu.isDestroyed) {
            this.grandTotalMenu.destroy();
        }
        if (this.formattingMenu && !this.formattingMenu.isDestroyed) {
            this.formattingMenu.destroy();
        }
        if (this.reportList && !this.reportList.isDestroyed) {
            this.reportList.destroy();
        }
        if (this.toolbar && !this.toolbar.isDestroyed) {
            this.toolbar.destroy();
        }
    }
}

PivotView.Inject(Common);
/**
 * Module to render NumberFormatting Dialog
 */
class NumberFormatting {
    constructor(parent) {
        this.parent = parent;
        this.parent.numberFormattingModule = this;
        this.removeEventListener();
        this.addEventListener();
    }
    /**
     * To get module name.
     * @returns string
     */
    getModuleName() {
        return 'numberformatting';
    }
    /**
     * To show Number Formatting dialog.
     * @returns void
     */
    showNumberFormattingDialog() {
        let valueDialog = createElement('div', {
            id: this.parent.element.id + '_FormatDialog',
            className: FORMATTING_DIALOG
        });
        this.parent.element.appendChild(valueDialog);
        this.dialog = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: true,
            header: this.parent.localeObj.getConstant('numberFormat'),
            content: this.getDialogContent(),
            isModal: true,
            visible: true,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            width: 'auto',
            height: 'auto',
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    click: this.updateFormatting.bind(this),
                    buttonModel: { cssClass: OK_BUTTON_CLASS, content: this.parent.localeObj.getConstant('apply'), isPrimary: true }
                },
                {
                    click: () => { this.dialog.hide(); },
                    buttonModel: { cssClass: CANCEL_BUTTON_CLASS, content: this.parent.localeObj.getConstant('cancel') }
                }
            ],
            closeOnEscape: true,
            target: this.parent.element,
            overlayClick: () => { this.removeDialog(); },
            close: this.removeDialog.bind(this)
        });
        this.dialog.isStringTemplate = true;
        this.dialog.appendTo(valueDialog);
        this.dialog.element.querySelector('.' + DIALOG_HEADER).innerHTML = this.parent.localeObj.getConstant('numberFormat');
        this.renderControls();
    }
    getDialogContent() {
        let outerElement = createElement('div', {
            id: this.parent.element.id + '_FormatDialogOuter',
            className: FORMATTING_DIALOG_OUTER
        });
        let table = createElement('table', {
            id: this.parent.element.id + '_FormatTable',
            className: FORMATTING_TABLE,
            styles: 'width: 100%'
        });
        let tRow = createElement('tr');
        let tValue = createElement('td');
        let valueLable = createElement('div', {
            id: this.parent.element.id + '_FormatValueLable',
            className: FORMATTING_VALUE_LABLE,
            innerHTML: this.parent.localeObj.getConstant('values')
        });
        let valueDrop = createElement('div', {
            id: this.parent.element.id + '_FormatValueDrop'
        });
        tValue.appendChild(valueLable);
        tValue.appendChild(valueDrop);
        tRow.appendChild(tValue);
        table.appendChild(tRow);
        tRow = createElement('tr');
        tValue = createElement('td');
        let formatLable = createElement('div', {
            id: this.parent.element.id + '_FormatLable',
            className: FORMATTING_FORMAT_LABLE,
            innerHTML: this.parent.localeObj.getConstant('formatType')
        });
        let formatDrop = createElement('div', {
            id: this.parent.element.id + '_FormatDrop'
        });
        tValue.appendChild(formatLable);
        tValue.appendChild(formatDrop);
        tRow.appendChild(tValue);
        table.appendChild(tRow);
        tRow = createElement('tr');
        tValue = createElement('td');
        let groupingLable = createElement('div', {
            id: this.parent.element.id + '_GroupingLable',
            className: FORMATTING_GROUPING_LABLE,
            innerHTML: this.parent.localeObj.getConstant('grouping')
        });
        let groupingDrop = createElement('div', {
            id: this.parent.element.id + '_GroupingDrop'
        });
        tValue.appendChild(groupingLable);
        tValue.appendChild(groupingDrop);
        tRow.appendChild(tValue);
        table.appendChild(tRow);
        tRow = createElement('tr');
        tValue = createElement('td');
        let decimalLable = createElement('div', {
            id: this.parent.element.id + '_DecimalLable',
            className: FORMATTING_DECIMAL_LABLE,
            innerHTML: this.parent.localeObj.getConstant('decimalPlaces')
        });
        let decimalDrop = createElement('div', {
            id: this.parent.element.id + '_DecimalDrop'
        });
        tValue.appendChild(decimalLable);
        tValue.appendChild(decimalDrop);
        tRow.appendChild(tValue);
        table.appendChild(tRow);
        tRow = createElement('tr');
        tValue = createElement('td');
        this.customLable = createElement('div', {
            id: this.parent.element.id + '_CustomLable',
            className: FORMATTING_CUSTOM_LABLE,
            innerHTML: this.parent.localeObj.getConstant('customFormatString')
        });
        this.customText = createElement('input', {
            id: this.parent.element.id + '_CustomText',
            attrs: {
                'type': 'text', 'tabindex': '0'
            },
            className: INPUT + ' ' + FORMATTING_CUSTOM_TEXT
        });
        tValue.appendChild(this.customLable);
        tValue.appendChild(this.customText);
        tRow.appendChild(tValue);
        table.appendChild(tRow);
        tRow = createElement('tr');
        table.appendChild(tRow);
        outerElement.appendChild(table);
        return outerElement;
    }
    renderControls() {
        if (this.dialog.element.querySelector('#' + this.parent.element.id + '_FormatValueDrop')) {
            let valueFields = [];
            valueFields.push({
                index: 0, name: this.parent.localeObj.getConstant('AllValues'), field: this.parent.localeObj.getConstant('AllValues')
            });
            for (let i = 0; i < this.parent.dataSourceSettings.values.length; i++) {
                valueFields.push({
                    index: i + 1, name: this.parent.dataSourceSettings.values[i].caption || this.parent.dataSourceSettings.values[i].name,
                    field: this.parent.dataSourceSettings.values[i].name
                });
            }
            this.valuesDropDown = new DropDownList({
                dataSource: valueFields, fields: { text: 'name', value: 'field' }, enableRtl: this.parent.enableRtl,
                index: 0, cssClass: FORMATTING_VALUE_DROP, change: this.valueChange.bind(this), width: '100%'
            });
            this.valuesDropDown.isStringTemplate = true;
            this.valuesDropDown.appendTo('#' + this.parent.element.id + '_FormatValueDrop');
        }
        if (this.dialog.element.querySelector('#' + this.parent.element.id + '_FormatDrop')) {
            let fields = [
                { index: 0, name: this.parent.localeObj.getConstant('number') },
                { index: 1, name: this.parent.localeObj.getConstant('currency') },
                { index: 2, name: this.parent.localeObj.getConstant('percentage') },
                { index: 2, name: this.parent.localeObj.getConstant('Custom') }
            ];
            this.formatDropDown = new DropDownList({
                dataSource: fields, fields: { text: 'name', value: 'name' },
                index: 0, change: this.dropDownChange.bind(this), enableRtl: this.parent.enableRtl,
                cssClass: FORMATTING_FORMAT_DROP, width: '100%'
            });
            this.formatDropDown.isStringTemplate = true;
            this.formatDropDown.appendTo('#' + this.parent.element.id + '_FormatDrop');
        }
        if (this.dialog.element.querySelector('#' + this.parent.element.id + '_GroupingDrop')) {
            let fields = [
                { index: 0, name: this.parent.localeObj.getConstant('true') },
                { index: 1, name: this.parent.localeObj.getConstant('false') }
            ];
            this.groupingDropDown = new DropDownList({
                dataSource: fields, fields: { text: 'name', value: 'name' }, enableRtl: this.parent.enableRtl,
                index: 0, cssClass: FORMATTING_GROUPING_DROP, width: '100%'
            });
            this.groupingDropDown.isStringTemplate = true;
            this.groupingDropDown.appendTo('#' + this.parent.element.id + '_GroupingDrop');
        }
        if (this.dialog.element.querySelector('#' + this.parent.element.id + '_DecimalDrop')) {
            let fields = [
                { index: 0, name: 0 },
                { index: 1, name: 1 },
                { index: 2, name: 2 },
                { index: 3, name: 3 },
                { index: 4, name: 4 },
                { index: 5, name: 5 },
                { index: 6, name: 6 },
                { index: 7, name: 7 },
                { index: 8, name: 8 },
                { index: 9, name: 9 },
                { index: 10, name: 10 },
            ];
            this.decimalDropDown = new DropDownList({
                dataSource: fields, fields: { text: 'name', value: 'name' }, enableRtl: this.parent.enableRtl,
                index: 0, cssClass: FORMATTING_DECIMAL_DROP, popupHeight: 150, width: '100%'
            });
            this.decimalDropDown.isStringTemplate = true;
            this.decimalDropDown.appendTo('#' + this.parent.element.id + '_DecimalDrop');
        }
        if (this.formatDropDown.value !== this.parent.localeObj.getConstant('Custom')) {
            this.customText.disabled = true;
        }
    }
    valueChange(args) {
        let format = this.parent.dataSourceSettings.formatSettings;
        let isExist = false;
        for (let i = 0; i < format.length; i++) {
            if (format[i].name === args.value) {
                let fString = format[i].format;
                let first = fString.split('')[0].toLowerCase();
                if (fString.length === 2 && ['n', 'p', 'c'].indexOf(first) > -1) {
                    this.formatDropDown.value = first === 'n' ? this.parent.localeObj.getConstant('number') : first === 'p' ?
                        this.parent.localeObj.getConstant('percentage') : first === 'c' ? this.parent.localeObj.getConstant('currency') :
                        this.parent.localeObj.getConstant('number');
                    this.decimalDropDown.value = Number(fString.split('')[1]);
                    this.groupingDropDown.value = format[i].useGrouping ? this.parent.localeObj.getConstant('true') :
                        this.parent.localeObj.getConstant('false');
                }
                else {
                    this.formatDropDown.value = this.parent.localeObj.getConstant('Custom');
                    this.customText.value = fString;
                }
                isExist = true;
                break;
            }
        }
        if (!isExist) {
            this.formatDropDown.value = this.parent.localeObj.getConstant('number');
            this.decimalDropDown.value = 0;
            this.groupingDropDown.value = this.parent.localeObj.getConstant('true');
        }
    }
    dropDownChange(args) {
        if (args.value === this.parent.localeObj.getConstant('Custom')) {
            this.customText.disabled = false;
            this.groupingDropDown.enabled = false;
            this.decimalDropDown.enabled = false;
        }
        else {
            this.customText.disabled = true;
            this.groupingDropDown.enabled = true;
            this.decimalDropDown.enabled = true;
        }
    }
    removeDialog() {
        if (this.dialog && !this.dialog.isDestroyed) {
            this.dialog.destroy();
        }
        if (document.getElementById(this.parent.element.id + '_FormatDialog')) {
            remove(document.getElementById(this.parent.element.id + '_FormatDialog'));
        }
    }
    updateFormatting() {
        let text;
        if (this.formatDropDown.value === this.parent.localeObj.getConstant('number') ||
            this.formatDropDown.value === this.parent.localeObj.getConstant('percentage') ||
            this.formatDropDown.value === this.parent.localeObj.getConstant('currency')) {
            text = this.formatDropDown.value === this.parent.localeObj.getConstant('number') ? 'N' :
                this.formatDropDown.value === this.parent.localeObj.getConstant('currency') ? 'C' : 'P';
            text += this.decimalDropDown.value;
        }
        else {
            text = this.customText.value;
        }
        let format = extend([], this.parent.dataSourceSettings.formatSettings, true);
        if (this.valuesDropDown.value === this.parent.localeObj.getConstant('AllValues')) {
            let fieldList = this.parent.dataType === 'olap' ?
                this.parent.olapEngineModule.fieldList : this.parent.engineModule.fieldList;
            for (let key of Object.keys(fieldList)) {
                if (fieldList[key].type === 'number') {
                    this.insertFormat(key, text);
                }
            }
        }
        else {
            this.insertFormat(this.valuesDropDown.value.toString(), text);
        }
        try {
            this.parent.updateDataSource(false);
            this.dialog.close();
        }
        catch (exception) {
            this.parent.setProperties({ dataSourceSettings: { formatSettings: format } }, true);
            this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('error'), this.parent.localeObj.getConstant('invalidFormat'), this.dialog.element);
            this.parent.hideWaitingPopup();
        }
    }
    insertFormat(fieldName, text) {
        let isExist = false;
        let newFormat = {
            name: fieldName, format: text,
            useGrouping: this.groupingDropDown.value === this.parent.localeObj.getConstant('true') ? true : false
        };
        let format = this.parent.dataSourceSettings.formatSettings;
        for (let i = 0; i < format.length; i++) {
            if (format[i].name === fieldName) {
                format[i] = newFormat;
                isExist = true;
            }
        }
        if (!isExist) {
            format.push(newFormat);
        }
    }
    /**
     * To add event listener.
     * @returns void
     * @hidden
     */
    addEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(initFormatting, this.showNumberFormattingDialog, this);
    }
    /**
     * To remove event listener.
     * @returns void
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(initFormatting, this.showNumberFormattingDialog);
    }
    /**
     * To destroy the calculated field dialog
     * @returns void
     * @hidden
     */
    destroy() {
        if (this.dialog && !this.dialog.isDestroyed) {
            this.dialog.destroy();
        }
        this.removeEventListener();
    }
}

PivotView.Inject(Common);
/**
 * `Grouping` module to create grouping option for date, number and custom in popup.
 */
/** @hidden */
class Grouping {
    /**
     * Constructor for the group UI rendering.
     * @hidden
     */
    constructor(parent) {
        /* tslint:disable-next-line:max-line-length */
        this.dateGroup = /_date_group_years|_date_group_quarters|_date_group_quarterYear|_date_group_months|_date_group_days|_date_group_hours|_date_group_minutes|_date_group_seconds/g;
        this.parent = parent;
        this.parent.groupingModule = this;
        this.addEventListener();
    }
    /**
     * For internal use only - Get the module name.
     * @private
     */
    getModuleName() {
        return 'grouping';
    }
    render(args) {
        let target = args.target;
        let option = args.option;
        let parentElement = args.parentElement;
        this.parentElement = parentElement;
        this.selectedCellsInfo = [];
        this.isUpdate = false;
        let colIndex = Number(target.getAttribute('aria-colindex'));
        let rowIndex = Number(target.getAttribute('index'));
        let cell = this.parent.engineModule.pivotValues[rowIndex][colIndex];
        let fieldName = cell.valueSort.axis.toString();
        this.selectedCellsInfo = this.getSelectedCells(cell.axis, fieldName, cell.actualText.toString());
        this.selectedCellsInfo.push({ axis: cell.axis, fieldName: fieldName, name: cell.actualText.toString(), cellInfo: cell });
        if (option.replace(parentElement.id, '').indexOf('_custom_group') !== -1) {
            this.createGroupSettings(fieldName);
        }
        else {
            this.updateUnGroupSettings(fieldName);
        }
    }
    /**
     * Returns the selected members/headers by checing the valid members from the pivot table.
     * @method getSelectedOptions
     * @param  {SelectedCellsInfo[]} axis - Get the members name from the given selected cells information
     * @return {boolean}
     * @hidden
     */
    getSelectedOptions(selectedCellsInfo) {
        let selectedOptions = [];
        for (let option of selectedCellsInfo) {
            if (PivotUtil.inArray(option.name, selectedOptions) === -1) {
                selectedOptions.push(option.name);
            }
        }
        return selectedOptions;
    }
    createGroupSettings(fieldName) {
        let fieldList = this.parent.engineModule.fieldList[fieldName];
        let group = this.getGroupSettings(fieldName);
        if (this.selectedCellsInfo.length > 0) {
            let type;
            let isInvalid = false;
            if (fieldList.isCustomField) {
                if (!group) {
                    let dateGroup = this.getGroupSettings(fieldName.replace(this.dateGroup, ''));
                    let customGroup = this.getGroupSettings(fieldName.replace(/_custom_group/g, ''));
                    if (dateGroup) {
                        isInvalid = false;
                        type = 'date';
                        fieldName = fieldName.replace(this.dateGroup, '');
                    }
                    else if (customGroup) {
                        isInvalid = this.selectedCellsInfo.length === 1;
                        type = 'custom';
                    }
                }
                else if (group && group.type === 'Custom') {
                    if (this.selectedCellsInfo.length === 1) {
                        isInvalid = true;
                    }
                    else {
                        isInvalid = false;
                        type = 'custom';
                    }
                }
                else if (group && group.type === 'Number') {
                    isInvalid = false;
                    type = 'number';
                }
            }
            else {
                if (group) {
                    if (group.type === 'Number' || group.type === 'Date') {
                        isInvalid = false;
                        type = group.type === 'Date' ? 'date' : 'number';
                    }
                    else if (group.type === 'Custom') {
                        isInvalid = this.selectedCellsInfo.length === 1;
                        type = 'custom';
                    }
                }
                else {
                    if (fieldList.type === 'number' ||
                        (['datetime', 'date']).indexOf(fieldList.type) !== -1 || this.isDateType(fieldName)) {
                        isInvalid = false;
                        type = (this.selectedCellsInfo.length === 1 ? ((['datetime', 'date']).indexOf(fieldList.type) !== -1 ||
                            this.isDateType(fieldName)) ? 'date' : 'number' : 'custom');
                    }
                    else if (fieldList.type === 'string') {
                        isInvalid = this.selectedCellsInfo.length === 1;
                        type = 'custom';
                    }
                }
            }
            if (isInvalid) {
                /* tslint:disable-next-line:max-line-length */
                this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('warning'), this.parent.localeObj.getConstant('invalidSelection'));
                this.parent.grid.clearSelection();
            }
            else if (type && type !== '') {
                this.createGroupDialog(fieldName, type);
            }
        }
    }
    updateUnGroupSettings(fieldName) {
        let fieldList = this.parent.engineModule.fieldList[fieldName];
        let groupFields = PivotUtil.cloneGroupSettings(this.parent.dataSourceSettings.groupSettings);
        let group = this.getGroupSettings(fieldName);
        if (this.selectedCellsInfo.length > 0) {
            let type;
            if (fieldList.isCustomField) {
                if (!group) {
                    let dateGroup = this.getGroupSettings(fieldName.replace(this.dateGroup, ''));
                    let customGroup = this.getGroupSettings(fieldName.replace(/_custom_group/g, ''));
                    if (dateGroup) {
                        type = 'date';
                        fieldName = fieldName.replace(this.dateGroup, '');
                    }
                    else if (customGroup) {
                        type = 'custom';
                    }
                }
                else if (group.type === 'Custom') {
                    type = 'custom';
                }
            }
            else {
                if (group) {
                    if (group.type === 'Number' || group.type === 'Date') {
                        type = group.type === 'Date' ? 'date' : 'number';
                    }
                }
            }
            if (type === 'date' || type === 'number') {
                groupFields = this.validateSettings(fieldName, groupFields, type, []);
            }
            else if (type === 'custom') {
                let selectedOptions = this.getSelectedOptions(this.selectedCellsInfo);
                groupFields = this.validateSettings(fieldName, groupFields, type, selectedOptions);
            }
            this.updateDateSource(groupFields, type);
        }
    }
    updateDateSource(groupFields, type) {
        if (this.isUpdate) {
            if (isBlazor()) {
                PivotUtil.setPivotProperties(this.parent, { dataSourceSettings: { groupSettings: groupFields } });
            }
            else {
                this.parent.setProperties({ dataSourceSettings: { groupSettings: groupFields } }, true);
            }
            this.parent.updateGroupingReport(groupFields, (type === 'date' ? 'Date' : type === 'custom' ? 'Custom' : 'Number'));
            this.parent.notify(initialLoad, {});
        }
    }
    /* tslint:disable-next-line:max-line-length */
    removeGroupSettings(fieldName, selectedOptions, groupFields, groupNames, type) {
        let index = groupNames.indexOf(fieldName);
        if (index !== -1) {
            let field = groupFields[index];
            for (let j = 0, len = field.customGroups.length; j < len; j++) {
                if (field.customGroups[j]) {
                    let group = field.customGroups[j];
                    if (PivotUtil.inArray(group.groupName, selectedOptions) !== -1) {
                        groupFields = this.modifyParentGroupItems(fieldName, groupFields, [group.groupName], group.items, groupNames);
                        field.customGroups.splice(j, 1);
                        this.isUpdate = true;
                        j--;
                        len--;
                    }
                }
            }
        }
        return groupFields;
    }
    getGroupSettings(fieldName) {
        for (let group of this.parent.dataSourceSettings.groupSettings) {
            if (group.name === fieldName) {
                return group;
            }
        }
        return undefined;
    }
    isDateType(fieldName) {
        for (let format of this.parent.dataSourceSettings.formatSettings) {
            if (format.name === fieldName && format.type) {
                return true;
            }
        }
        return false;
    }
    /**
     * Returns the selected members/headers by checing the valid members from the pivot table.
     * @method getSelectedCells
     * @param  {string} axis - Spicifies the axis name for the given field.
     * @param  {string} fieldName - Gets selected members for the given field name.
     * @param  {string} name - specifies the selected member name for the given field.
     * @return {boolean}
     * @hidden
     */
    getSelectedCells(axis, fieldName, name) {
        let selectedCellsInfo = [];
        /* tslint:disable */
        let selectedElements = this.parent.element.querySelectorAll('.' + CELL_SELECTED_BGCOLOR + ',.' + SELECTED_BGCOLOR);
        /* tslint:enable */
        for (let element of selectedElements) {
            let colIndex = Number(element.getAttribute('aria-colindex'));
            let rowIndex = Number(element.getAttribute('index'));
            let cell = this.parent.engineModule.pivotValues[rowIndex][colIndex];
            if (cell && (cell.axis === axis) && !(cell.type === 'grand sum' || cell.type === 'sum') &&
                cell.valueSort.axis === fieldName && name !== cell.actualText.toString()) {
                selectedCellsInfo.push({
                    axis: cell.axis,
                    fieldName: cell.valueSort.axis.toString(),
                    name: cell.actualText.toString(),
                    cellInfo: cell
                });
            }
        }
        return selectedCellsInfo;
    }
    createGroupDialog(fieldName, type) {
        let groupDialog = createElement('div', {
            id: this.parentElement.id + '_GroupDialog',
            className: 'e-group-field-settings',
            attrs: { 'data-field': fieldName, 'data-type': type }
        });
        this.parentElement.appendChild(groupDialog);
        this.groupDialog = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: true,
            header: this.parent.localeObj.getConstant('grouping'),
            content: this.createGroupOptions(fieldName, type),
            isModal: true,
            visible: true,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            width: 300,
            height: 'auto',
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    click: this.updateGroupSettings.bind(this),
                    buttonModel: { cssClass: OK_BUTTON_CLASS, content: this.parent.localeObj.getConstant('ok'), isPrimary: true }
                },
                {
                    click: () => { this.groupDialog.hide(); },
                    buttonModel: { cssClass: CANCEL_BUTTON_CLASS, content: this.parent.localeObj.getConstant('cancel') }
                }
            ],
            overlayClick: () => { this.removeDialog(); },
            closeOnEscape: true,
            close: this.removeDialog.bind(this),
            target: this.parentElement
        });
        this.groupDialog.isStringTemplate = true;
        this.groupDialog.appendTo(groupDialog);
    }
    /* tslint:disable:all */
    createGroupOptions(fieldName, type) {
        let groupInstance = this;
        let mainDiv = createElement('div', {
            className: 'e-group-field-div-content', id: this.parentElement.id + '_group_field_div_content',
            attrs: { 'data-fieldName': fieldName, 'data-type': type }
        });
        let groupWrapperDiv1 = createElement('div', { className: 'e-group-option-wrapper' });
        mainDiv.appendChild(groupWrapperDiv1);
        // this.parentElement.appendChild(mainDiv);
        let dataSource = this.parent.dataSourceSettings;
        let groupField = PivotUtil.getFieldByName(fieldName, dataSource.groupSettings);
        switch (type) {
            case 'custom':
                {
                    let caption;
                    let dataFields = dataSource.rows;
                    dataFields = dataFields.concat(dataSource.columns, dataSource.values, dataSource.filters);
                    let actualField = PivotUtil.getFieldByName(fieldName.replace(/_custom_group/g, ''), dataFields);
                    let currentField = PivotUtil.getFieldByName(fieldName, dataFields);
                    let nextField = PivotUtil.getFieldByName(fieldName + '_custom_group', dataFields);
                    if (currentField) {
                        let newFieldName = fieldName + '_custom_group';
                        caption = nextField ? nextField.caption :
                            this.parent.engineModule.fieldList[actualField.name].caption + (newFieldName.match(/_custom_group/g).length + 1);
                    }
                    let captionInputTextDiv1 = createElement('div', {
                        className: 'e-caption-option-text', innerHTML: this.parent.localeObj.getConstant('groupFieldCaption')
                    });
                    let captionInputDiv1 = createElement('div', { className: 'e-group-caption-wrapper' });
                    let captionInputField1 = createElement('input', {
                        id: this.parentElement.id + 'group_caption_option',
                        className: 'e-group-caption-text',
                        attrs: { 'type': 'text' }
                    });
                    captionInputDiv1.appendChild(captionInputTextDiv1);
                    captionInputDiv1.appendChild(captionInputField1);
                    groupWrapperDiv1.appendChild(captionInputDiv1);
                    let inputTextDiv1 = createElement('div', {
                        className: 'e-input-option-text', innerHTML: this.parent.localeObj.getConstant('groupTitle')
                    });
                    let inputDiv1 = createElement('div', { className: 'e-group-input-wrapper' });
                    let inputField1 = createElement('input', {
                        id: this.parentElement.id + 'group_input_option',
                        className: 'e-group-input-text',
                        attrs: { 'type': 'text' }
                    });
                    inputDiv1.appendChild(inputTextDiv1);
                    inputDiv1.appendChild(inputField1);
                    groupWrapperDiv1.appendChild(inputDiv1);
                    let captionInputObj1 = new MaskedTextBox({
                        placeholder: this.parent.localeObj.getConstant('captionName'),
                        enableRtl: this.parent.enableRtl,
                        value: caption, width: '100%'
                    });
                    captionInputObj1.isStringTemplate = true;
                    captionInputObj1.appendTo(captionInputField1);
                    let inputObj1 = new MaskedTextBox({
                        placeholder: this.parent.localeObj.getConstant('groupName'),
                        enableRtl: this.parent.enableRtl,
                        width: '100%'
                    });
                    inputObj1.isStringTemplate = true;
                    inputObj1.appendTo(inputField1);
                }
                break;
            case 'date':
            case 'number':
                {
                    let startAtWrapper = createElement('div', {
                        className: 'e-group-start-option-wrapper'
                    });
                    let startAtOptionDiv1 = createElement('input', {
                        id: this.parentElement.id + 'group_start_option',
                        className: 'e-group_start_option',
                        attrs: { 'type': 'checkbox' }
                    });
                    let startAtInputField1 = createElement('input', {
                        id: this.parentElement.id + 'group_start_input',
                        className: 'e-group_start_input',
                        attrs: { 'type': 'text' }
                    });
                    startAtWrapper.appendChild(startAtOptionDiv1);
                    startAtWrapper.appendChild(startAtInputField1);
                    groupWrapperDiv1.appendChild(startAtWrapper);
                    let endAtWrapper = createElement('div', {
                        className: 'e-group-end-option-wrapper'
                    });
                    let endAtOptionDiv1 = createElement('input', {
                        id: this.parentElement.id + 'group_end_option',
                        className: 'e-group_end_option',
                        attrs: { 'type': 'checkbox' }
                    });
                    let endAtInputField1 = createElement('input', {
                        id: this.parentElement.id + 'group_end_input',
                        className: 'e-group_end_input',
                        attrs: { 'type': 'text' }
                    });
                    endAtWrapper.appendChild(endAtOptionDiv1);
                    endAtWrapper.appendChild(endAtInputField1);
                    groupWrapperDiv1.appendChild(endAtWrapper);
                    let intervalWrapper = createElement('div', {
                        className: 'e-group-interval-option-wrapper'
                    });
                    let intervalTextDiv1 = createElement('div', {
                        className: 'e-group-inerval-option-text', innerHTML: this.parent.localeObj.getConstant('groupBy')
                    });
                    let intervalInputField1 = createElement('input', {
                        id: this.parentElement.id + 'group_interval_input',
                        className: 'e-group_interval_input',
                        attrs: { 'type': 'text' }
                    });
                    intervalWrapper.appendChild(intervalTextDiv1);
                    intervalWrapper.appendChild(intervalInputField1);
                    groupWrapperDiv1.appendChild(intervalWrapper);
                    let startAt = undefined;
                    let endAt = undefined;
                    if (type === 'date') {
                        let selectedGroups = [];
                        let groupData = [
                            { value: 'Seconds', text: this.parent.localeObj.getConstant('Seconds') },
                            { value: 'Minutes', text: this.parent.localeObj.getConstant('Minutes') },
                            { value: 'Hours', text: this.parent.localeObj.getConstant('Hours') },
                            { value: 'Days', text: this.parent.localeObj.getConstant('Days') },
                            { value: 'Months', text: this.parent.localeObj.getConstant('Months') },
                            { value: 'QuarterYear', text: this.parent.localeObj.getConstant('QuarterYear') },
                            { value: 'Quarters', text: this.parent.localeObj.getConstant('Quarters') },
                            { value: 'Years', text: this.parent.localeObj.getConstant('Years') },
                        ];
                        if (groupField && groupField.type === 'Date') {
                            selectedGroups = groupField.groupInterval;
                            startAt = groupField.startingAt ? groupField.startingAt.toString() : undefined;
                            endAt = groupField.endingAt ? groupField.endingAt.toString() : undefined;
                        }
                        else {
                            selectedGroups = ['Months'];
                        }
                        let startAtInputObj = new DateTimePicker({
                            placeholder: this.parent.localeObj.getConstant('chooseDate'),
                            enableRtl: this.parent.enableRtl,
                            format: 'dd/MM/yyyy hh:mm:ss a',
                            enabled: !(startAt === undefined),
                            width: '100%',
                        });
                        startAtInputObj.isStringTemplate = true;
                        startAtInputObj.appendTo(startAtInputField1);
                        let endAtInputObj = new DateTimePicker({
                            placeholder: this.parent.localeObj.getConstant('chooseDate'),
                            enableRtl: this.parent.enableRtl,
                            format: 'dd/MM/yyyy hh:mm:ss a',
                            enabled: !(endAt === undefined),
                            width: '100%',
                        });
                        endAtInputObj.isStringTemplate = true;
                        endAtInputObj.appendTo(endAtInputField1);
                        MultiSelect.Inject(CheckBoxSelection);
                        let intervalObj = new MultiSelect({
                            dataSource: groupData,
                            value: selectedGroups,
                            fields: { text: 'text', value: 'value' },
                            mode: 'CheckBox',
                            showDropDownIcon: true,
                            enableSelectionOrder: false,
                            placeholder: this.parent.localeObj.getConstant('selectGroup'),
                            filterBarPlaceholder: this.parent.localeObj.getConstant('example') + ' ' + this.parent.localeObj.getConstant('Months'),
                            enableRtl: this.parent.enableRtl,
                            select: () => {
                                groupInstance.groupDialog.element.querySelector('.' + OK_BUTTON_CLASS).removeAttribute('disabled');
                            },
                            removed: () => {
                                /* tslint:disable */
                                if (intervalObj.checkBoxSelectionModule.activeLi.length === 0) {
                                    groupInstance.groupDialog.element.querySelector('.' + OK_BUTTON_CLASS).setAttribute('disabled', 'disabled');
                                }
                                /* tslint:enable */
                            }
                        });
                        intervalObj.isStringTemplate = true;
                        intervalObj.appendTo(intervalInputField1);
                        startAtInputObj.value = startAt === undefined ? null : new Date(startAt);
                        startAtInputObj.dataBind();
                        endAtInputObj.value = endAt === undefined ? null : new Date(endAt);
                        endAtInputObj.dataBind();
                    }
                    else {
                        let selectedInterval = undefined;
                        if (groupField && groupField.type === 'Number') {
                            selectedInterval = groupField.rangeInterval;
                            startAt = groupField.startingAt ? groupField.startingAt.toString() : undefined;
                            endAt = groupField.endingAt ? groupField.endingAt.toString() : undefined;
                        }
                        else {
                            selectedInterval = 2;
                        }
                        let startAtInputObj = new NumericTextBox({
                            placeholder: this.parent.localeObj.getConstant('enterValue'),
                            enableRtl: this.parent.enableRtl,
                            showClearButton: true,
                            format: '###',
                            value: startAt === undefined ? undefined : parseInt(startAt, 10),
                            enabled: !(startAt === undefined),
                            width: '100%',
                        });
                        startAtInputObj.isStringTemplate = true;
                        startAtInputObj.appendTo(startAtInputField1);
                        let endAtInputObj = new NumericTextBox({
                            placeholder: this.parent.localeObj.getConstant('enterValue'),
                            enableRtl: this.parent.enableRtl,
                            showClearButton: true,
                            format: '###',
                            value: endAt === undefined ? undefined : parseInt(endAt, 10),
                            enabled: !(endAt === undefined),
                            width: '100%'
                        });
                        endAtInputObj.isStringTemplate = true;
                        endAtInputObj.appendTo(endAtInputField1);
                        let intervalObj = new NumericTextBox({
                            placeholder: this.parent.localeObj.getConstant('enterValue'),
                            enableRtl: this.parent.enableRtl,
                            showClearButton: true,
                            format: '###',
                            min: 1,
                            value: selectedInterval,
                            width: '100%'
                        });
                        intervalObj.isStringTemplate = true;
                        intervalObj.appendTo(intervalInputField1);
                    }
                    let startAtObj = new CheckBox({
                        label: this.parent.localeObj.getConstant('startAt'),
                        checked: !(startAt === undefined),
                        enableRtl: this.parent.enableRtl,
                        change: (args) => {
                            let startAtObj = (type === 'date' ?
                                getInstance('#' + this.parentElement.id + 'group_start_input', DateTimePicker) :
                                getInstance('#' + this.parentElement.id + 'group_start_input', NumericTextBox));
                            startAtObj.enabled = args.checked;
                            startAtObj.dataBind();
                        }
                    });
                    startAtObj.isStringTemplate = true;
                    startAtObj.appendTo(startAtOptionDiv1);
                    let endAtObj = new CheckBox({
                        label: this.parent.localeObj.getConstant('endAt'),
                        checked: !(endAt === undefined),
                        enableRtl: this.parent.enableRtl,
                        change: (args) => {
                            let endAtObj = (type === 'date' ?
                                getInstance('#' + this.parentElement.id + 'group_end_input', DateTimePicker) :
                                getInstance('#' + this.parentElement.id + 'group_end_input', NumericTextBox));
                            endAtObj.enabled = args.checked;
                            endAtObj.dataBind();
                        }
                    });
                    endAtObj.isStringTemplate = true;
                    endAtObj.appendTo(endAtOptionDiv1);
                }
                break;
        }
        return mainDiv;
    }
    /* tslint:disable */
    updateGroupSettings() {
        let dialogElement = this.groupDialog.element;
        let groupType = dialogElement.getAttribute('data-type');
        let fieldName = dialogElement.getAttribute('data-field');
        let groupFields = PivotUtil.cloneGroupSettings(this.parent.dataSourceSettings.groupSettings);
        if (groupFields.length === 0 && !this.parent.clonedDataSet && !this.parent.clonedReport) {
            let dataSet = this.parent.engineModule.data;
            this.parent.clonedDataSet = PivotUtil.getClonedData(dataSet);
            this.parent.setProperties({ dataSourceSettings: { dataSource: [] } }, true);
            this.parent.clonedReport = extend({}, this.parent.dataSourceSettings, null, true);
            this.parent.setProperties({ dataSourceSettings: { dataSource: dataSet } }, true);
        }
        if (groupType === 'custom') {
            let inputInstance = getInstance('#' + this.parentElement.id + 'group_input_option', MaskedTextBox);
            let captionInputInstance = getInstance('#' + this.parentElement.id + 'group_caption_option', MaskedTextBox);
            removeClass([inputInstance.element], EMPTY_FIELD);
            if (inputInstance.value === null || inputInstance.value === '') {
                addClass([inputInstance.element], EMPTY_FIELD);
                inputInstance.element.focus();
                return;
            }
            let selectedOptions = this.getSelectedOptions(this.selectedCellsInfo);
            let customGroup = { groupName: inputInstance.value, items: selectedOptions };
            let splicedItems = [];
            let newItems = [];
            let field = { name: fieldName, caption: captionInputInstance.value, type: 'Custom', customGroups: [] };
            let isUpdated = false;
            for (let i = 0, len = groupFields.length; i < len; i++) {
                if (groupFields[i].name === fieldName) {
                    field = groupFields[i];
                    field.caption = captionInputInstance.value;
                    for (let j = 0, len = field.customGroups.length; j < len; j++) {
                        if (field.customGroups[j]) {
                            let group = field.customGroups[j];
                            if (group.items && PivotUtil.isContainCommonElements(group.items, selectedOptions)) {
                                splicedItems = this.mergeArray(splicedItems, [group.groupName]);
                                newItems = this.mergeArray(newItems, group.items);
                                field.customGroups.splice(j, 1);
                                j--;
                                len--;
                            }
                        }
                    }
                    for (let item of selectedOptions) {
                        let index = newItems.indexOf(item);
                        if (index !== -1) {
                            newItems.splice(index, 1);
                        }
                    }
                    newItems = this.mergeArray(newItems, [customGroup.groupName]);
                    field.customGroups.push(customGroup);
                    this.isUpdate = true;
                    isUpdated = true;
                    break;
                }
            }
            if (!isUpdated) {
                field.customGroups.push(customGroup);
                this.isUpdate = true;
                groupFields.push(field);
            }
            groupFields = this.validateSettings(fieldName, groupFields, groupType, (splicedItems.length === 0 ? customGroup.items : splicedItems), newItems);
        }
        else if (groupType === 'date' || groupType === 'number') {
            let startCheckBoxInstance = getInstance('#' + this.parentElement.id + 'group_start_option', CheckBox);
            let endCheckBoxInstance = getInstance('#' + this.parentElement.id + 'group_end_option', CheckBox);
            let startInputInstance = (groupType === 'date' ?
                getInstance('#' + this.parentElement.id + 'group_start_input', DateTimePicker) :
                getInstance('#' + this.parentElement.id + 'group_start_input', NumericTextBox));
            let endInputInstance = (groupType === 'date' ?
                getInstance('#' + this.parentElement.id + 'group_end_input', DateTimePicker) :
                getInstance('#' + this.parentElement.id + 'group_end_input', NumericTextBox));
            let intervalInstance = (groupType === 'date' ?
                getInstance('#' + this.parentElement.id + 'group_interval_input', MultiSelect) :
                getInstance('#' + this.parentElement.id + 'group_interval_input', NumericTextBox));
            let startAt = startCheckBoxInstance.checked ? startInputInstance.value.toString() : undefined;
            let endAt = endCheckBoxInstance.checked ? endInputInstance.value.toString() : undefined;
            let field = { name: fieldName, startingAt: startAt, endingAt: endAt };
            if (groupType === 'date') {
                let selectedItems = [];
                for (let list of intervalInstance.value) {
                    selectedItems.push(list);
                }
                field.type = 'Date';
                field.groupInterval = selectedItems;
            }
            else {
                field.type = 'Number';
                field.rangeInterval = intervalInstance.value;
            }
            let isUpdated = false;
            for (let i = 0, len = groupFields.length; i < len; i++) {
                if (groupFields[i].name === fieldName) {
                    groupFields.splice(i, 1, field);
                    this.isUpdate = true;
                    isUpdated = true;
                    break;
                }
            }
            if (!isUpdated) {
                this.isUpdate = true;
                groupFields.push(field);
            }
            groupFields = this.validateSettings(fieldName, groupFields, groupType, [], []);
        }
        this.groupDialog.close();
        this.updateDateSource(groupFields, groupType);
    }
    /* tslint:enable */
    getGroupBasedSettings(groupFields) {
        let groups = {};
        for (let group of groupFields) {
            if (groups[group.type]) {
                groups[group.type].push(group);
            }
            else {
                groups[group.type] = [group];
            }
        }
        return groups;
    }
    getGroupByName(groupFields) {
        let customFields = {};
        for (let field of groupFields) {
            let name = field.name.replace(/_custom_group/g, '');
            if (customFields[name]) {
                customFields[name].push(field);
            }
            else {
                customFields[name] = [field];
            }
        }
        return customFields;
    }
    /* tslint:disable-next-line:max-line-length */
    validateSettings(fieldName, groupFields, groupType, splicedItems, newItems) {
        let validatedSettings = [];
        let groups = this.getGroupBasedSettings(groupFields);
        let groupOrders = ['Date', 'Number', 'Custom'];
        if (groups[groupOrders[2]] && groupType === 'custom') {
            let customFields = this.getGroupByName(groups[groupOrders[2]]);
            if (customFields[fieldName.replace(/_custom_group/g, '')]) {
                let customGroups = customFields[fieldName.replace(/_custom_group/g, '')];
                let fields = customGroups.map((item, pos) => item.name);
                if (newItems) {
                    /* tslint:disable-next-line:max-line-length */
                    customGroups = this.modifyParentGroupItems(fieldName, customGroups, splicedItems, newItems, fields);
                }
                else {
                    customGroups = this.removeGroupSettings(fieldName.replace('_custom_group', ''), splicedItems, customGroups, fields);
                }
            }
            let orderedGroups = [];
            for (let field of Object.keys(customFields)) {
                let fields = customFields[field].map((item, pos) => item.name);
                orderedGroups = this.reOrderSettings(customFields[field], fields, orderedGroups, field);
            }
            groups[groupOrders[2]] = orderedGroups;
        }
        else if ((groupType === 'date' || groupType === 'number') && !newItems) {
            let groupFields = groupType === 'date' ? groups[groupOrders[0]] : groups[groupOrders[1]];
            if (groupType === 'date') {
                groups[groupOrders[0]] = groupFields.filter((field) => { return field.name !== fieldName; });
            }
            else {
                groups[groupOrders[1]] = groupFields.filter((field) => { return field.name !== fieldName; });
            }
            this.isUpdate = true;
        }
        for (let order of groupOrders) {
            if (groups[order]) {
                validatedSettings = validatedSettings.concat(groups[order]);
            }
        }
        return validatedSettings;
    }
    /* tslint:disable-next-line:max-line-length */
    reOrderSettings(customGroups, fields, orderedSettings, fieldName) {
        let index = fields.indexOf(fieldName);
        if (index > -1 && customGroups[index].customGroups && customGroups[index].customGroups.length > 0) {
            orderedSettings.push(customGroups[index]);
            this.reOrderSettings(customGroups, fields, orderedSettings, fieldName + '_custom_group');
        }
        return orderedSettings;
    }
    /* tslint:disable-next-line:max-line-length */
    modifyParentGroupItems(fieldName, groupFields, splicedItems, newItems, fields) {
        let index = fields.indexOf(fieldName + '_custom_group');
        if (index !== -1) {
            let field = groupFields[index];
            if (field.customGroups && field.customGroups.length > 0) {
                for (let i = 0, len = field.customGroups.length; i < len; i++) {
                    if (field.customGroups[i]) {
                        let isItemsUpdated = false;
                        let group = field.customGroups[i];
                        if (group.items) {
                            for (let item of splicedItems) {
                                let pos = group.items.indexOf(item);
                                if (pos !== -1) {
                                    group.items.splice(pos, 1);
                                    this.isUpdate = true;
                                    isItemsUpdated = true;
                                }
                            }
                            if (isItemsUpdated) {
                                group.items = this.mergeArray(group.items, newItems);
                            }
                        }
                    }
                }
            }
        }
        return groupFields;
    }
    mergeArray(collection1, collection2) {
        let resultArray = [];
        let array = collection1.concat(collection2);
        let len = array.length;
        let assoc = {};
        while (len--) {
            let item = String(array[len]);
            if (!assoc[item]) {
                resultArray.unshift(item);
                assoc[item] = true;
            }
        }
        return resultArray;
    }
    removeDialog() {
        if (this.parent.grid && this.parent.grid.isDestroyed) {
            return;
        }
        this.parent.grid.clearSelection();
        if (this.groupDialog && !this.groupDialog.isDestroyed) {
            this.groupDialog.destroy();
        }
        if (document.getElementById(this.parentElement.id + '_GroupDialog')) {
            remove(document.getElementById(this.parentElement.id + '_GroupDialog'));
        }
    }
    /**
     * @hidden
     */
    addEventListener() {
        this.handlers = {
            load: this.render
        };
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(initGrouping, this.handlers.load, this); //For initial rendering
    }
    /**
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeDialog();
        this.parent.off(initGrouping, this.handlers.load);
    }
    /**
     * To destroy the pivot button event listener
     * @return {void}
     * @hidden
     */
    destroy() {
        this.removeEventListener();
    }
}

/**
 * common exported items
 */

/**
 * olap engine exported items
 */

/**
 * Data modules
 */
/** @hidden */

/**
 * Export PivotGrid components
 */

export { GroupingBarSettings, CellEditSettings, ConditionalSettings, HyperlinkSettings, DisplayOption, PivotView, Render, ExcelExport$1 as ExcelExport, PDFExport, KeyboardInteraction, VirtualScroll$1 as VirtualScroll, DrillThrough, PivotChart, PivotFieldList, TreeViewRenderer, AxisFieldRenderer, AxisTableRenderer, DialogRenderer, EventBase, NodeStateModified, DataSourceUpdate, FieldList, CommonKeyboardInteraction, GroupingBar, CalculatedField, ConditionalFormatting, PivotCommon, load, enginePopulating, enginePopulated, onFieldDropped, fieldDrop, beforePivotTableRender, afterPivotTableRender, beforeExport, excelHeaderQueryCellInfo, pdfHeaderQueryCellInfo, excelQueryCellInfo, pdfQueryCellInfo, onPdfCellRender, dataBound, queryCellInfo, headerCellInfo, hyperlinkCellClick, resizing, resizeStop, cellClick, drillThrough, beforeColumnsRender, selected, cellSelecting, drill, cellSelected, cellDeselected, rowSelected, rowDeselected, beginDrillThrough, saveReport, fetchReport, loadReport, renameReport, removeReport, newReport, toolbarRender, toolbarClick, chartTooltipRender, chartLoaded, chartLoad, chartResized, chartAxisLabelRender, chartSeriesCreated, aggregateCellInfo, contextMenuClick, contextMenuOpen, fieldListRefreshed, conditionalFormatting, beforePdfExport, beforeExcelExport, memberFiltering, initialLoad, uiUpdate, scroll, contentReady, dataReady, initSubComponent, treeViewUpdate, pivotButtonUpdate, initCalculatedField, click, initToolbar, initFormatting, initGrouping, Theme, ErrorDialog, FilterDialog, PivotContextMenu, AggregateMenu, Toolbar$2 as Toolbar, NumberFormatting, Grouping, PivotEngine, PivotUtil, OlapEngine, MDXQuery };
//# sourceMappingURL=ej2-pivotview.es2015.js.map
