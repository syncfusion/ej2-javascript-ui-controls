import { Browser, ChildProperty, Component, Event, EventHandler, L10n, NotifyPropertyChanges, Property, classList, createElement, isBlazor, isNullOrUndefined } from '@syncfusion/ej2-base';
import { Save, StreamWriter, XmlWriter } from '@syncfusion/ej2-file-utils';
import { Button, CheckBox, RadioButton } from '@syncfusion/ej2-buttons';
import { ListView } from '@syncfusion/ej2-lists';
import { Dialog, DialogUtility, Popup, Tooltip, createSpinner, hideSpinner, showSpinner } from '@syncfusion/ej2-popups';
import { ContextMenu, Tab, Toolbar } from '@syncfusion/ej2-navigations';
import { ChartComponent } from '@syncfusion/ej2-office-chart';
import { DropDownButton, SplitButton } from '@syncfusion/ej2-splitbuttons';
import { ZipArchive, ZipArchiveItem } from '@syncfusion/ej2-compression';
import { ComboBox, DropDownList } from '@syncfusion/ej2-dropdowns';
import { ColorPicker, NumericTextBox } from '@syncfusion/ej2-inputs';
import { Query } from '@syncfusion/ej2-data';

/**
 * @private
 */
var Dictionary = /** @__PURE__ @class */ (function () {
    function Dictionary() {
        this.keysInternal = [];
        this.valuesInternal = [];
    }
    Object.defineProperty(Dictionary.prototype, "length", {
        /**
         * @private
         */
        get: function () {
            return this.keysInternal.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dictionary.prototype, "keys", {
        /**
         * @private
         */
        get: function () {
            return this.keysInternal;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    Dictionary.prototype.add = function (key, value) {
        if (isNullOrUndefined(key)) {
            throw new ReferenceError('Provided key or value is not valid.');
        }
        var index = this.keysInternal.indexOf(key);
        // if (index < 0 || index > this.keysInternal.length - 1) {
        if (index < 0) {
            this.keysInternal.push(key);
            this.valuesInternal.push(value);
        }
        return 1;
        // else {
        //     throw new RangeError('An item with the same key has already been added.');
        // }
    };
    /**
     * @private
     */
    Dictionary.prototype.get = function (key) {
        if (isNullOrUndefined(key)) {
            throw new ReferenceError('Provided key is not valid.');
        }
        var index = this.keysInternal.indexOf(key);
        if (index < 0 || index > this.keysInternal.length - 1) {
            throw new RangeError('No item with the specified key has been added.');
        }
        else {
            return this.valuesInternal[index];
        }
    };
    /**
     * @private
     */
    Dictionary.prototype.set = function (key, value) {
        if (isNullOrUndefined(key)) {
            throw new ReferenceError('Provided key is not valid.');
        }
        var index = this.keysInternal.indexOf(key);
        if (index < 0 || index > this.keysInternal.length - 1) {
            throw new RangeError('No item with the specified key has been added.');
        }
        else {
            this.valuesInternal[index] = value;
        }
    };
    /**
     * @private
     */
    Dictionary.prototype.remove = function (key) {
        if (isNullOrUndefined(key)) {
            throw new ReferenceError('Provided key is not valid.');
        }
        var index = this.keysInternal.indexOf(key);
        if (index < 0 || index > this.keysInternal.length - 1) {
            throw new RangeError('No item with the specified key has been added.');
        }
        else {
            this.keysInternal.splice(index, 1);
            this.valuesInternal.splice(index, 1);
            return true;
        }
    };
    /**
     * @private
     */
    Dictionary.prototype.containsKey = function (key) {
        if (isNullOrUndefined(key)) {
            throw new ReferenceError('Provided key is not valid.');
        }
        var index = this.keysInternal.indexOf(key);
        if (index < 0 || index > this.keysInternal.length - 1) {
            return false;
        }
        return true;
    };
    /**
     * @private
     */
    Dictionary.prototype.clear = function () {
        this.keysInternal = [];
        this.valuesInternal = [];
    };
    /**
     * @private
     */
    Dictionary.prototype.destroy = function () {
        this.clear();
        this.keysInternal = undefined;
        this.valuesInternal = undefined;
    };
    return Dictionary;
}());

/**
 * @private
 */
var WUniqueFormat = /** @__PURE__ @class */ (function () {
    function WUniqueFormat(type) {
        this.referenceCount = 0;
        this.uniqueFormatType = type;
        this.propertiesHash = new Dictionary();
    }
    /**
     * @private
     */
    WUniqueFormat.prototype.isEqual = function (source, property, modifiedValue) {
        var isEqual = false;
        switch (this.uniqueFormatType) {
            case 1:
                isEqual = this.isBorderEqual(source, property, modifiedValue);
                break;
            case 2:
                isEqual = this.isCharacterFormatEqual(source, property, modifiedValue);
                break;
            case 3:
                isEqual = this.isParagraphFormatEqual(source, property, modifiedValue);
                break;
            case 4:
                isEqual = this.isCellFormatEqual(source, property, modifiedValue);
                break;
            case 5:
                isEqual = this.isShadingEqual(source, property, modifiedValue);
                break;
            case 6:
                isEqual = this.isRowFormatEqual(source, property, modifiedValue);
                break;
            case 7:
                isEqual = this.isListFormatEqual(source, property, modifiedValue);
                break;
            case 8:
                isEqual = this.isTableFormatEqual(source, property, modifiedValue);
                break;
            case 9:
                isEqual = this.isListLevelEqual(source, property, modifiedValue);
                break;
            case 10:
                isEqual = this.isSectionFormatEqual(source, property, modifiedValue);
                break;
            default:
                break;
        }
        return isEqual;
    };
    // tslint:disable-next-line:max-line-length
    WUniqueFormat.prototype.isNotEqual = function (property, source, modifiedProperty, modifiedValue, uniqueFormatType) {
        var targetValue = undefined;
        var propertyType = WUniqueFormat.getPropertyType(uniqueFormatType, property);
        if (this.propertiesHash.containsKey(propertyType)) {
            targetValue = this.propertiesHash.get(propertyType);
        }
        var sourceValue = undefined;
        if (property === modifiedProperty) {
            sourceValue = modifiedValue;
        }
        else if (source.containsKey(propertyType)) {
            sourceValue = source.get(propertyType);
        }
        // tslint:disable-next-line:max-line-length
        if (!(targetValue === sourceValue || (!isNullOrUndefined(targetValue) && !isNullOrUndefined(sourceValue) && targetValue === sourceValue))) {
            return true;
        }
        return false;
    };
    /**
     * @private
     */
    WUniqueFormat.getPropertyType = function (uniqueFormatType, property) {
        var type = 0;
        switch (uniqueFormatType) {
            case 1:
                type = this.getBorderPropertyType(property);
                break;
            case 2:
                type = this.getCharacterFormatPropertyType(property);
                break;
            case 3:
                type = this.getParaFormatPropertyType(property);
                break;
            case 4:
                type = this.getCellFormatPropertyType(property);
                break;
            case 5:
                type = this.getShadingPropertyType(property);
                break;
            case 6:
                type = this.getRowFormatType(property);
                break;
            case 7:
                type = this.getListFormatType(property);
                break;
            case 8:
                type = this.getTableFormatType(property);
                break;
            case 9:
                type = this.getListLevelType(property);
                break;
            case 10:
                type = this.getSectionFormatType(property);
                break;
            default:
                break;
        }
        return type;
    };
    WUniqueFormat.getRowFormatType = function (property) {
        if (property === 'allowBreakAcrossPages') {
            return 1;
        }
        if (property === 'isHeader') {
            return 2;
        }
        if (property === 'height') {
            return 3;
        }
        if (property === 'heightType') {
            return 4;
        }
        if (property === 'gridBefore') {
            return 5;
        }
        if (property === 'gridBeforeWidth') {
            return 6;
        }
        if (property === 'gridBeforeWidthType') {
            return 7;
        }
        if (property === 'gridAfter') {
            return 8;
        }
        if (property === 'gridAfterWidth') {
            return 9;
        }
        if (property === 'gridAfterWidthType') {
            return 10;
        }
        if (property === 'leftMargin') {
            return 11;
        }
        if (property === 'topMargin') {
            return 12;
        }
        if (property === 'bottomMargin') {
            return 13;
        }
        if (property === 'rightMargin') {
            return 14;
        }
        if (property === 'leftIndent') {
            return 15;
        }
        return 0;
    };
    WUniqueFormat.getListFormatType = function (property) {
        if (property === 'listId') {
            return 1;
        }
        if (property === 'listLevelNumber') {
            return 2;
        }
        return 0;
    };
    WUniqueFormat.getTableFormatType = function (property) {
        if (property === 'leftMargin') {
            return 1;
        }
        if (property === 'rightMargin') {
            return 2;
        }
        if (property === 'topMargin') {
            return 3;
        }
        if (property === 'bottomMargin') {
            return 4;
        }
        if (property === 'cellSpacing') {
            return 5;
        }
        if (property === 'leftIndent') {
            return 6;
        }
        if (property === 'tableAlignment') {
            return 7;
        }
        if (property === 'preferredWidth') {
            return 8;
        }
        if (property === 'preferredWidthType') {
            return 9;
        }
        if (property === 'bidi') {
            return 10;
        }
        if (property === 'allowAutoFit') {
            return 11;
        }
        return 0;
    };
    WUniqueFormat.getListLevelType = function (property) {
        if (property === 'listLevelPattern') {
            return 1;
        }
        if (property === 'startAt') {
            return 2;
        }
        if (property === 'followCharacter') {
            return 3;
        }
        if (property === 'numberFormat') {
            return 4;
        }
        if (property === 'restartLevel') {
            return 5;
        }
        return 0;
    };
    WUniqueFormat.getShadingPropertyType = function (property) {
        if (property === 'backgroundColor') {
            return 1;
        }
        if (property === 'foregroundColor') {
            return 2;
        }
        if (property === 'textureStyle') {
            return 3;
        }
        return 0;
    };
    WUniqueFormat.getCellFormatPropertyType = function (property) {
        if (property === 'leftMargin') {
            return 1;
        }
        if (property === 'rightMargin') {
            return 2;
        }
        if (property === 'topMargin') {
            return 3;
        }
        if (property === 'bottomMargin') {
            return 4;
        }
        if (property === 'columnSpan') {
            return 5;
        }
        if (property === 'rowSpan') {
            return 6;
        }
        if (property === 'verticalAlignment') {
            return 7;
        }
        if (property === 'preferredWidthType') {
            return 8;
        }
        if (property === 'preferredWidth') {
            return 9;
        }
        if (property === 'cellWidth') {
            return 10;
        }
        return 0;
    };
    WUniqueFormat.getBorderPropertyType = function (property) {
        if (property === 'color') {
            return 1;
        }
        if (property === 'lineStyle') {
            return 2;
        }
        if (property === 'lineWidth') {
            return 3;
        }
        if (property === 'shadow') {
            return 4;
        }
        if (property === 'space') {
            return 5;
        }
        if (property === 'hasNoneStyle') {
            return 6;
        }
        return 0;
    };
    WUniqueFormat.getCharacterFormatPropertyType = function (property) {
        if (property === 'fontColor') {
            return 1;
        }
        if (property === 'fontFamily') {
            return 2;
        }
        if (property === 'fontSize') {
            return 3;
        }
        if (property === 'bold') {
            return 4;
        }
        if (property === 'italic') {
            return 5;
        }
        if (property === 'underline') {
            return 6;
        }
        if (property === 'strikethrough') {
            return 7;
        }
        if (property === 'baselineAlignment') {
            return 8;
        }
        if (property === 'highlightColor') {
            return 9;
        }
        if (property === 'bidi') {
            return 10;
        }
        if (property === 'bdo') {
            return 11;
        }
        if (property === 'boldBidi') {
            return 12;
        }
        if (property === 'italicBidi') {
            return 13;
        }
        if (property === 'fontFamilyBidi') {
            return 14;
        }
        if (property === 'fontSizeBidi') {
            return 15;
        }
        return 0;
    };
    WUniqueFormat.getParaFormatPropertyType = function (property) {
        if (property === 'leftIndent') {
            return 1;
        }
        if (property === 'rightIndent') {
            return 2;
        }
        if (property === 'firstLineIndent') {
            return 3;
        }
        if (property === 'textAlignment') {
            return 4;
        }
        if (property === 'beforeSpacing') {
            return 5;
        }
        if (property === 'afterSpacing') {
            return 6;
        }
        if (property === 'lineSpacing') {
            return 7;
        }
        if (property === 'lineSpacingType') {
            return 8;
        }
        if (property === 'outlineLevel') {
            return 9;
        }
        if (property === 'bidi') {
            return 10;
        }
        if (property === 'contextualSpacing') {
            return 11;
        }
        return 0;
    };
    WUniqueFormat.getSectionFormatType = function (property) {
        if (property === 'headerDistance') {
            return 1;
        }
        if (property === 'footerDistance') {
            return 2;
        }
        if (property === 'differentFirstPage') {
            return 3;
        }
        if (property === 'differentOddAndEvenPages') {
            return 4;
        }
        if (property === 'pageWidth') {
            return 5;
        }
        if (property === 'pageHeight') {
            return 6;
        }
        if (property === 'leftMargin') {
            return 7;
        }
        if (property === 'topMargin') {
            return 8;
        }
        if (property === 'rightMargin') {
            return 9;
        }
        if (property === 'bottomMargin') {
            return 10;
        }
        if (property === 'bidi') {
            return 11;
        }
        if (property === 'restartPageNumbering') {
            return 12;
        }
        if (property === 'pageStartingNumber') {
            return 13;
        }
        return 0;
    };
    /**
     * @private
     */
    WUniqueFormat.prototype.isBorderEqual = function (source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('color', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        if (this.isNotEqual('lineStyle', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        if (this.isNotEqual('lineWidth', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        if (this.isNotEqual('shadow', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        if (this.isNotEqual('space', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        if (this.isNotEqual('hasNoneStyle', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        return true;
    };
    /**
     * @private
     */
    WUniqueFormat.prototype.isCharacterFormatEqual = function (source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('fontColor', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('fontFamily', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('fontSize', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('bold', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('italic', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('underline', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('strikethrough', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('baselineAlignment', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('highlightColor', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('bidi', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('bdo', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('fontColor', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('fontFamilyBidi', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('fontSizeBidi', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('boldBidi', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('italicBidi', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        return true;
    };
    WUniqueFormat.prototype.isParagraphFormatEqual = function (source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('leftIndent', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('rightIndent', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('firstLineIndent', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('textAlignment', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('beforeSpacing', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('afterSpacing', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('lineSpacing', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('lineSpacingType', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('outlineLevel', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('bidi', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('contextualSpacing', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        return true;
    };
    /**
     * @private
     */
    WUniqueFormat.prototype.isCellFormatEqual = function (source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('leftMargin', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('rightMargin', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('topMargin', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('bottomMargin', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('columnSpan', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('rowSpan', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('verticalAlignment', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('preferredWidthType', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('preferredWidth', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('cellWidth', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        return true;
    };
    /**
     * @private
     */
    WUniqueFormat.prototype.isShadingEqual = function (source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('backgroundColor', source, modifiedProperty, modifiedValue, 5)) {
            return false;
        }
        if (this.isNotEqual('foregroundColor', source, modifiedProperty, modifiedValue, 5)) {
            return false;
        }
        if (this.isNotEqual('textureStyle', source, modifiedProperty, modifiedValue, 5)) {
            return false;
        }
        return true;
    };
    /**
     * @private
     */
    WUniqueFormat.prototype.isRowFormatEqual = function (source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('allowBreakAcrossPages', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('isHeader', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('height', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('heightType', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridBefore', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridBeforeWidth', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridBeforeWidthType', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridAfter', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridAfterWidth', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridAfterWidthType', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('leftMargin', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('topMargin', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('bottomMargin', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('rightMargin', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('leftIndent', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        return true;
    };
    /**
     * @private
     */
    WUniqueFormat.prototype.isListFormatEqual = function (source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('listId', source, modifiedProperty, modifiedValue, 7)) {
            return false;
        }
        if (this.isNotEqual('listLevelNumber', source, modifiedProperty, modifiedValue, 7)) {
            return false;
        }
        return true;
    };
    /**
     * @private
     */
    WUniqueFormat.prototype.isTableFormatEqual = function (source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('leftMargin', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('rightMargin', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('topMargin', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('bottomMargin', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('cellSpacing', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('leftIndent', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('tableAlignment', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('preferredWidth', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('preferredWidthType', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('bidi', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('allowAutoFit', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        return true;
    };
    /**
     * @private
     */
    WUniqueFormat.prototype.isListLevelEqual = function (source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('listLevelPattern', source, modifiedProperty, modifiedValue, 9)) {
            return false;
        }
        if (this.isNotEqual('startAt', source, modifiedProperty, modifiedValue, 9)) {
            return false;
        }
        if (this.isNotEqual('followCharacter', source, modifiedProperty, modifiedValue, 9)) {
            return false;
        }
        if (this.isNotEqual('numberFormat', source, modifiedProperty, modifiedValue, 9)) {
            return false;
        }
        if (this.isNotEqual('restartLevel', source, modifiedProperty, modifiedValue, 9)) {
            return false;
        }
        return true;
    };
    /**
     * @private
     */
    WUniqueFormat.prototype.isSectionFormatEqual = function (source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('headerDistance', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('footerDistance', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('differentFirstPage', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('differentOddAndEvenPages', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('pageWidth', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('pageHeight', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('leftMargin', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('topMargin', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('rightMargin', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('bottomMargin', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('bidi', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('restartPageNumbering', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('pageStartingNumber', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        return true;
    };
    /**
     * @private
     */
    WUniqueFormat.prototype.cloneItems = function (format, property, value, uniqueFormatType) {
        var propertyType = WUniqueFormat.getPropertyType(uniqueFormatType, property);
        var keys = format.propertiesHash.keys;
        for (var i = 0; i < keys.length; i++) {
            if (keys[i] === propertyType) {
                this.propertiesHash.add(propertyType, value);
            }
            else {
                this.propertiesHash.add(keys[i], format.propertiesHash.get(keys[i]));
            }
        }
        if (!format.propertiesHash.containsKey(propertyType)) {
            this.propertiesHash.add(propertyType, value);
        }
    };
    /**
     * @private
     */
    WUniqueFormat.prototype.mergeProperties = function (format) {
        var hash = format.cloneProperties();
        var keys = this.propertiesHash.keys;
        for (var i = 0; i < keys.length; i++) {
            if (!hash.containsKey(keys[i])) {
                hash.add(keys[i], this.propertiesHash.get(keys[i]));
            }
        }
        return hash;
    };
    /**
     * @private
     */
    WUniqueFormat.prototype.cloneProperties = function () {
        var hash = new Dictionary();
        var keys = this.propertiesHash.keys;
        for (var i = 0; i < keys.length; i++) {
            hash.add(keys[i], this.propertiesHash.get(keys[i]));
        }
        return hash;
    };
    // public cloneItemsInternal(format: WUniqueFormat): void {
    //     let keys: number[] = format.propertiesHash.getItem();
    //     for (let i: number = 0; i < keys.length; i++) {
    //         this.propertiesHash.add(keys[i], format.propertiesHash.get(keys[i]));
    //     }
    //     this.referenceCount = format.referenceCount;
    // }
    /**
     * @private
     */
    WUniqueFormat.prototype.destroy = function () {
        if (!isNullOrUndefined(this.propertiesHash)) {
            this.propertiesHash.destroy();
        }
        this.propertiesHash = undefined;
        this.referenceCount = undefined;
        this.uniqueFormatType = undefined;
    };
    return WUniqueFormat;
}());

/**
 * @private
 */
var WUniqueFormats = /** @__PURE__ @class */ (function () {
    function WUniqueFormats() {
        this.items = [];
    }
    /**
     * @private
     */
    WUniqueFormats.prototype.addUniqueFormat = function (format, type) {
        var matchedFormat = undefined;
        for (var i = 0; i < this.items.length; i++) {
            if (this.items[i].isEqual(format, undefined, undefined)) {
                matchedFormat = this.items[i];
                break;
            }
        }
        if (isNullOrUndefined(matchedFormat)) {
            matchedFormat = new WUniqueFormat(type);
            matchedFormat.propertiesHash = format;
            matchedFormat.referenceCount = 1;
            this.items.push(matchedFormat);
        }
        else {
            matchedFormat.referenceCount++;
        }
        return matchedFormat;
    };
    /**
     * @private
     */
    WUniqueFormats.prototype.updateUniqueFormat = function (uniqueFormat, property, value) {
        var matchedFormat = undefined;
        for (var i = 0; i < this.items.length; i++) {
            if (this.items[i].isEqual(uniqueFormat.propertiesHash, property, value)) {
                matchedFormat = this.items[i];
                break;
            }
        }
        if (isNullOrUndefined(matchedFormat)) {
            matchedFormat = new WUniqueFormat(uniqueFormat.uniqueFormatType);
            matchedFormat.cloneItems(uniqueFormat, property, value, uniqueFormat.uniqueFormatType);
            matchedFormat.referenceCount = 1;
            this.items.push(matchedFormat);
        }
        else {
            matchedFormat.referenceCount++;
        }
        this.remove(uniqueFormat);
        uniqueFormat = undefined;
        return matchedFormat;
    };
    /**
     * @private
     */
    WUniqueFormats.prototype.remove = function (uniqueFormat) {
        uniqueFormat.referenceCount--;
        if (uniqueFormat.referenceCount <= 0) {
            this.items.splice(this.items.indexOf(uniqueFormat), 1);
            uniqueFormat.destroy();
            uniqueFormat = undefined;
        }
    };
    /**
     * @private
     */
    WUniqueFormats.prototype.clear = function () {
        if (isNullOrUndefined(this.items)) {
            for (var i = 0; i < this.items.length; i++) {
                this.items[i].destroy();
            }
        }
        this.items = [];
    };
    /**
     * @private
     */
    WUniqueFormats.prototype.destroy = function () {
        this.clear();
        this.items = undefined;
    };
    return WUniqueFormats;
}());

/**
 * @private
 */
var XmlHttpRequestHandler = /** @__PURE__ @class */ (function () {
    function XmlHttpRequestHandler() {
        /**
         * A boolean value indicating whether the request should be sent asynchronous or not.
         * @default true
         */
        this.mode = true;
    }
    /**
     * Send the request to server
     * @param  {object} jsonObject - To send to service
     */
    XmlHttpRequestHandler.prototype.send = function (jsonObject) {
        var _this = this;
        this.xmlHttpRequest = new XMLHttpRequest();
        this.xmlHttpRequest.onreadystatechange = function () { _this.stateChange(_this); };
        this.xmlHttpRequest.onerror = function () { _this.error(_this); };
        if (!this.mode) {
            setTimeout(function () { _this.sendRequest(jsonObject); });
        }
        else {
            this.sendRequest(jsonObject);
        }
    };
    XmlHttpRequestHandler.prototype.sendRequest = function (jsonObj) {
        this.xmlHttpRequest.open('POST', this.url, true);
        if (this.contentType) {
            this.xmlHttpRequest.setRequestHeader('Content-Type', this.contentType);
        }
        this.setCustomAjaxHeaders();
        if (this.responseType) {
            this.xmlHttpRequest.responseType = this.responseType;
        }
        var data = jsonObj instanceof FormData ? jsonObj : JSON.stringify(jsonObj);
        this.xmlHttpRequest.send(data); // jshint ignore:line
    };
    XmlHttpRequestHandler.prototype.stateChange = function (proxyReq) {
        if (proxyReq.xmlHttpRequest.readyState === 4 && proxyReq.xmlHttpRequest.status === 200) {
            // tslint:disable-next-line
            var data = void 0;
            if (this.responseType) {
                data = proxyReq.xmlHttpRequest.response;
            }
            else {
                data = proxyReq.xmlHttpRequest.responseText;
            }
            // tslint:disable-next-line
            var result = {
                name: 'onSuccess',
                data: data,
                readyState: proxyReq.xmlHttpRequest.readyState,
                status: proxyReq.xmlHttpRequest.status
            };
            proxyReq.successHandler(result);
        }
        else if (proxyReq.xmlHttpRequest.readyState === 4 && proxyReq.xmlHttpRequest.status === 400) { // jshint ignore:line)
            // tslint:disable-next-line
            var result = {
                name: 'onFailure',
                status: proxyReq.xmlHttpRequest.status,
                statusText: proxyReq.xmlHttpRequest.statusText
            };
            proxyReq.failureHandler(result);
        }
    };
    XmlHttpRequestHandler.prototype.error = function (proxyReq) {
        // tslint:disable-next-line
        var result = {
            name: 'onError',
            status: this.xmlHttpRequest.status,
            statusText: this.xmlHttpRequest.statusText
        };
        proxyReq.errorHandler(result);
    };
    // tslint:disable-next-line
    XmlHttpRequestHandler.prototype.successHandler = function (response) {
        if (this.onSuccess) {
            this.onSuccess(response);
        }
        return response;
    };
    // tslint:disable-next-line
    XmlHttpRequestHandler.prototype.failureHandler = function (response) {
        if (this.onFailure) {
            this.onFailure(response);
        }
        return response;
    };
    // tslint:disable-next-line
    XmlHttpRequestHandler.prototype.errorHandler = function (response) {
        if (this.onError) {
            this.onError(response);
        }
        return response;
    };
    XmlHttpRequestHandler.prototype.setCustomAjaxHeaders = function () {
        for (var i = 0; i < this.customHeaders.length; i++) {
            var header = this.customHeaders[i];
            for (var _i = 0, _a = Object.keys(header); _i < _a.length; _i++) {
                var key = _a[_i];
                this.xmlHttpRequest.setRequestHeader(key, header[key]);
            }
        }
    };
    return XmlHttpRequestHandler;
}());

/**
 * @private
 */
var WSectionFormat = /** @__PURE__ @class */ (function () {
    function WSectionFormat(node) {
        this.uniqueSectionFormat = undefined;
        this.ownerBase = node;
    }
    Object.defineProperty(WSectionFormat.prototype, "headerDistance", {
        get: function () {
            return this.getPropertyValue('headerDistance');
        },
        set: function (value) {
            this.setPropertyValue('headerDistance', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WSectionFormat.prototype, "footerDistance", {
        get: function () {
            return this.getPropertyValue('footerDistance');
        },
        set: function (value) {
            this.setPropertyValue('footerDistance', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WSectionFormat.prototype, "differentFirstPage", {
        get: function () {
            return this.getPropertyValue('differentFirstPage');
        },
        set: function (value) {
            this.setPropertyValue('differentFirstPage', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WSectionFormat.prototype, "differentOddAndEvenPages", {
        get: function () {
            return this.getPropertyValue('differentOddAndEvenPages');
        },
        set: function (value) {
            this.setPropertyValue('differentOddAndEvenPages', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WSectionFormat.prototype, "pageHeight", {
        get: function () {
            return this.getPropertyValue('pageHeight');
        },
        set: function (value) {
            this.setPropertyValue('pageHeight', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WSectionFormat.prototype, "rightMargin", {
        get: function () {
            return this.getPropertyValue('rightMargin');
        },
        set: function (value) {
            this.setPropertyValue('rightMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WSectionFormat.prototype, "pageWidth", {
        get: function () {
            return this.getPropertyValue('pageWidth');
        },
        set: function (value) {
            this.setPropertyValue('pageWidth', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WSectionFormat.prototype, "leftMargin", {
        get: function () {
            return this.getPropertyValue('leftMargin');
        },
        set: function (value) {
            this.setPropertyValue('leftMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WSectionFormat.prototype, "bottomMargin", {
        get: function () {
            return this.getPropertyValue('bottomMargin');
        },
        set: function (value) {
            this.setPropertyValue('bottomMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WSectionFormat.prototype, "topMargin", {
        get: function () {
            return this.getPropertyValue('topMargin');
        },
        set: function (value) {
            this.setPropertyValue('topMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WSectionFormat.prototype, "bidi", {
        get: function () {
            return this.getPropertyValue('bidi');
        },
        set: function (value) {
            this.setPropertyValue('bidi', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WSectionFormat.prototype, "restartPageNumbering", {
        get: function () {
            return this.getPropertyValue('restartPageNumbering');
        },
        set: function (value) {
            this.setPropertyValue('restartPageNumbering', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WSectionFormat.prototype, "pageStartingNumber", {
        get: function () {
            return this.getPropertyValue('pageStartingNumber');
        },
        set: function (value) {
            this.setPropertyValue('pageStartingNumber', value);
        },
        enumerable: true,
        configurable: true
    });
    WSectionFormat.prototype.destroy = function () {
        if (!isNullOrUndefined(this.uniqueSectionFormat)) {
            WSectionFormat.uniqueSectionFormats.remove(this.uniqueSectionFormat);
        }
        this.uniqueSectionFormat = undefined;
    };
    WSectionFormat.prototype.hasValue = function (property) {
        if (!isNullOrUndefined(this.uniqueSectionFormat)) {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueSectionFormat.uniqueFormatType, property);
            return this.uniqueSectionFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    };
    WSectionFormat.getPropertyDefaultValue = function (property) {
        var value = undefined;
        switch (property) {
            case 'headerDistance':
                value = 36;
                break;
            case 'footerDistance':
                value = 36;
                break;
            case 'differentFirstPage':
                value = false;
                break;
            case 'differentOddAndEvenPages':
                value = false;
                break;
            case 'pageWidth':
                value = 612;
                break;
            case 'pageHeight':
                value = 792;
                break;
            case 'leftMargin':
                value = 72;
                break;
            case 'topMargin':
                value = 72;
                break;
            case 'rightMargin':
                value = 72;
                break;
            case 'bottomMargin':
                value = 72;
                break;
            case 'bidi':
                value = false;
                break;
            case 'restartPageNumbering':
                value = false;
                break;
            case 'pageStartingNumber':
                value = 0;
                break;
        }
        return value;
    };
    WSectionFormat.prototype.getPropertyValue = function (property) {
        var hasValue = this.hasValue(property);
        if (hasValue) {
            var propertyType = WUniqueFormat.getPropertyType(WSectionFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueSectionFormat) && this.uniqueSectionFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueSectionFormat.propertiesHash.get(propertyType);
            }
        }
        return WSectionFormat.getPropertyDefaultValue(property);
    };
    WSectionFormat.prototype.setPropertyValue = function (property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WSectionFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueSectionFormat)) {
            this.initializeUniqueSectionFormat(property, value);
        }
        else {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueSectionFormat.uniqueFormatType, property);
            if (this.uniqueSectionFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueSectionFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            // tslint:disable-next-line:max-line-length
            this.uniqueSectionFormat = WSectionFormat.uniqueSectionFormats.updateUniqueFormat(this.uniqueSectionFormat, property, value);
        }
    };
    WSectionFormat.prototype.initializeUniqueSectionFormat = function (property, propValue) {
        var uniqueSectionFormatTemp = new Dictionary();
        this.addUniqueSectionFormat('headerDistance', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('footerDistance', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('differentFirstPage', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('differentOddAndEvenPages', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('pageWidth', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('pageHeight', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('leftMargin', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('topMargin', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('rightMargin', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('bottomMargin', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('bidi', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('restartPageNumbering', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('pageStartingNumber', property, propValue, uniqueSectionFormatTemp);
        // tslint:disable-next-line:max-line-length
        this.uniqueSectionFormat = WSectionFormat.uniqueSectionFormats.addUniqueFormat(uniqueSectionFormatTemp, WSectionFormat.uniqueFormatType);
    };
    // tslint:disable-next-line:max-line-length
    WSectionFormat.prototype.addUniqueSectionFormat = function (property, modifiedProperty, propValue, uniqueSectionFormatTemp) {
        var propertyType;
        propertyType = WUniqueFormat.getPropertyType(WSectionFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueSectionFormatTemp.add(propertyType, propValue);
        }
        else {
            uniqueSectionFormatTemp.add(propertyType, WSectionFormat.getPropertyDefaultValue(property));
        }
    };
    WSectionFormat.prototype.copyFormat = function (format, history) {
        if (history && (history.isUndoing || history.isRedoing)) {
            this.uniqueSectionFormat = format.uniqueSectionFormat;
        }
        else {
            if (!isNullOrUndefined(format)) {
                if (!isNullOrUndefined(format.uniqueSectionFormat) && format.uniqueSectionFormat.propertiesHash) {
                    this.updateUniqueSectionFormat(format);
                }
            }
        }
    };
    WSectionFormat.prototype.updateUniqueSectionFormat = function (format) {
        var hash = undefined;
        if (this.uniqueSectionFormat) {
            hash = this.uniqueSectionFormat.mergeProperties(format.uniqueSectionFormat);
            if (this.uniqueSectionFormat.referenceCount === 0) {
                WSectionFormat.uniqueSectionFormats.remove(this.uniqueSectionFormat);
                this.uniqueSectionFormat = undefined;
            }
        }
        this.uniqueSectionFormat = new WUniqueFormat(WSectionFormat.uniqueFormatType);
        if (isNullOrUndefined(hash)) {
            hash = this.uniqueSectionFormat.mergeProperties(format.uniqueSectionFormat);
        }
        this.uniqueSectionFormat = WSectionFormat.uniqueSectionFormats.addUniqueFormat(hash, WSectionFormat.uniqueFormatType);
    };
    WSectionFormat.prototype.cloneFormat = function () {
        var format = new WSectionFormat();
        format.uniqueSectionFormat = this.uniqueSectionFormat;
        return format;
    };
    WSectionFormat.clear = function () {
        this.uniqueSectionFormats.clear();
    };
    WSectionFormat.uniqueSectionFormats = new WUniqueFormats();
    WSectionFormat.uniqueFormatType = 10;
    return WSectionFormat;
}());

/**
 * @private
 */
var WLevelOverride = /** @__PURE__ @class */ (function () {
    function WLevelOverride() {
    }
    WLevelOverride.prototype.destroy = function () {
        if (!isNullOrUndefined(this.overrideListLevel)) {
            this.overrideListLevel.destroy();
        }
        this.levelNumber = undefined;
        this.startAt = undefined;
        this.overrideListLevel = undefined;
    };
    WLevelOverride.prototype.clone = function () {
        var levelOverride = new WLevelOverride();
        levelOverride.startAt = this.startAt;
        levelOverride.levelNumber = this.levelNumber;
        if (!isNullOrUndefined(this.overrideListLevel)) {
            levelOverride.overrideListLevel = this.overrideListLevel.clone(levelOverride);
        }
        return levelOverride;
    };
    return WLevelOverride;
}());

/**
 * @private
 */
var WList = /** @__PURE__ @class */ (function () {
    function WList() {
        this.listId = -1;
        this.sourceListId = -1;
        this.abstractListId = -1;
        this.abstractList = undefined;
        this.levelOverrides = [];
    }
    WList.prototype.getListLevel = function (levelNumber) {
        var listLevel = undefined;
        var levelOverride = this.getLevelOverride(levelNumber);
        if (!isNullOrUndefined(levelOverride) && !isNullOrUndefined(levelOverride.overrideListLevel)) {
            listLevel = levelOverride.overrideListLevel;
        }
        else {
            listLevel = this.abstractList.levels[levelNumber];
        }
        return listLevel;
    };
    WList.prototype.getLevelOverride = function (levelNumber) {
        for (var i = 0; i < this.levelOverrides.length; i++) {
            if (this.levelOverrides[i] instanceof WLevelOverride) {
                var levelOverride = this.levelOverrides[i];
                if (levelOverride.levelNumber === levelNumber) {
                    return levelOverride;
                }
            }
        }
        return undefined;
    };
    WList.prototype.destroy = function () {
        if (!isNullOrUndefined(this.levelOverrides)) {
            this.levelOverrides = [];
        }
        this.abstractListId = undefined;
        this.listId = undefined;
        this.sourceListId = undefined;
        this.levelOverrides = undefined;
    };
    WList.prototype.mergeList = function (list) {
        if (!isNullOrUndefined(this.abstractListId) && this.abstractListId !== -1) {
            this.abstractListId = list.abstractListId;
        }
        if (!isNullOrUndefined(this.listId) && this.listId !== -1) {
            this.listId = list.listId;
        }
        if (!isNullOrUndefined(this.sourceListId) && this.sourceListId !== -1) {
            this.sourceListId = list.sourceListId;
        }
        if (!isNullOrUndefined(this.levelOverrides) && this.levelOverrides.length !== 0) {
            this.levelOverrides = list.levelOverrides;
        }
    };
    WList.prototype.clone = function () {
        var list = new WList();
        for (var i = 0; i < this.levelOverrides.length; i++) {
            list.levelOverrides.push(this.levelOverrides[i].clone());
        }
        return list;
    };
    return WList;
}());

/**
 * @private
 */
var WListFormat = /** @__PURE__ @class */ (function () {
    function WListFormat(node) {
        this.uniqueListFormat = undefined;
        this.ownerBase = undefined;
        this.baseStyle = undefined;
        this.list = undefined;
        this.ownerBase = node;
    }
    Object.defineProperty(WListFormat.prototype, "listId", {
        get: function () {
            return this.getPropertyValue('listId');
        },
        set: function (listId) {
            this.setPropertyValue('listId', listId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WListFormat.prototype, "listLevelNumber", {
        get: function () {
            return this.getPropertyValue('listLevelNumber');
        },
        set: function (value) {
            this.setPropertyValue('listLevelNumber', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WListFormat.prototype, "listLevel", {
        get: function () {
            var list = undefined;
            if (!isNullOrUndefined(this.list)) {
                list = this.list;
            }
            else {
                /* tslint:disable-next-line:no-any */
                var baseListStyle = this.baseStyle;
                while (!isNullOrUndefined(baseListStyle)) {
                    if (baseListStyle.paragraphFormat.listFormat.list) {
                        list = baseListStyle.paragraphFormat.listFormat.list;
                        break;
                    }
                    else {
                        baseListStyle = baseListStyle.basedOn;
                    }
                }
            }
            if (!isNullOrUndefined(list)) {
                return list.getListLevel(this.listLevelNumber);
            }
            else {
                return undefined;
            }
        },
        enumerable: true,
        configurable: true
    });
    WListFormat.prototype.getPropertyValue = function (property) {
        if (!this.hasValue(property)) {
            if (this.baseStyle instanceof WParagraphStyle) {
                /* tslint:disable-next-line:no-any */
                var baseStyle = this.baseStyle;
                while (!isNullOrUndefined(baseStyle)) {
                    if (baseStyle.paragraphFormat.listFormat.hasValue(property)) {
                        break;
                    }
                    else {
                        baseStyle = baseStyle.basedOn;
                    }
                }
                if (!isNullOrUndefined(baseStyle)) {
                    var propertyType = WUniqueFormat.getPropertyType(WListFormat.uniqueFormatType, property);
                    return baseStyle.paragraphFormat.listFormat.uniqueListFormat.propertiesHash.get(propertyType);
                }
            }
        }
        else {
            var propertyType = WUniqueFormat.getPropertyType(WListFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueListFormat) && this.uniqueListFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueListFormat.propertiesHash.get(propertyType);
            }
        }
        return WListFormat.getPropertyDefaultValue(property);
    };
    WListFormat.prototype.setPropertyValue = function (property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WListFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueListFormat)) {
            this.initializeUniqueListFormat(property, value);
        }
        else {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueListFormat.uniqueFormatType, property);
            if (this.uniqueListFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueListFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueListFormat = WListFormat.uniqueListFormats.updateUniqueFormat(this.uniqueListFormat, property, value);
        }
    };
    WListFormat.prototype.initializeUniqueListFormat = function (property, propValue) {
        var uniqueListFormatTemp = new Dictionary();
        this.addUniqueListFormat('listId', property, propValue, uniqueListFormatTemp);
        this.addUniqueListFormat('listLevelNumber', property, propValue, uniqueListFormatTemp);
        this.uniqueListFormat = WListFormat.uniqueListFormats.addUniqueFormat(uniqueListFormatTemp, WListFormat.uniqueFormatType);
    };
    // tslint:disable-next-line:max-line-length
    WListFormat.prototype.addUniqueListFormat = function (property, modifiedProperty, propValue, uniqueListFormatTemp) {
        var propertyType;
        propertyType = WUniqueFormat.getPropertyType(WListFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueListFormatTemp.add(propertyType, propValue);
        }
    };
    WListFormat.getPropertyDefaultValue = function (property) {
        var value = undefined;
        switch (property) {
            case 'listId':
                value = -1;
                break;
            case 'listLevelNumber':
                value = 0;
                break;
        }
        return value;
    };
    WListFormat.prototype.copyFormat = function (format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueListFormat)) {
                this.listId = format.listId;
                this.listLevelNumber = format.listLevelNumber;
            }
            if (!isNullOrUndefined(format.baseStyle)) {
                this.baseStyle = format.baseStyle;
            }
            if (!isNullOrUndefined(format.list)) {
                this.list = format.list;
            }
        }
    };
    WListFormat.prototype.hasValue = function (property) {
        if (!isNullOrUndefined(this.uniqueListFormat)) {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueListFormat.uniqueFormatType, property);
            return this.uniqueListFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    };
    WListFormat.prototype.clearFormat = function () {
        if (!isNullOrUndefined(this.uniqueListFormat) && this.uniqueListFormat.referenceCount === 0) {
            WListFormat.uniqueListFormats.remove(this.uniqueListFormat);
        }
        this.uniqueListFormat = undefined;
        this.list = undefined;
    };
    WListFormat.prototype.destroy = function () {
        this.clearFormat();
    };
    WListFormat.clear = function () {
        this.uniqueListFormats.clear();
    };
    WListFormat.prototype.ApplyStyle = function (baseStyle) {
        this.baseStyle = baseStyle;
    };
    /**
     * For internal use
     * @private
     */
    WListFormat.prototype.getValue = function (property) {
        return this.hasValue(property) ? this.getPropertyValue(property) : undefined;
    };
    /**
     * For internal use
     * @private
     */
    WListFormat.prototype.mergeFormat = function (format) {
        if (isNullOrUndefined(this.getValue('listId'))) {
            this.listId = format.getValue('listId');
        }
        if (isNullOrUndefined(this.getValue('listLevelNumber'))) {
            this.listLevelNumber = format.getValue('listLevelNumber');
        }
        if (!isNullOrUndefined(format.list)) {
            if (isNullOrUndefined(this.list)) {
                this.list = new WList();
            }
            this.list.mergeList(format.list);
        }
    };
    WListFormat.uniqueListFormats = new WUniqueFormats();
    WListFormat.uniqueFormatType = 7;
    return WListFormat;
}());

/**
 * @private
 */
var WTabStop = /** @__PURE__ @class */ (function () {
    function WTabStop() {
    }
    Object.defineProperty(WTabStop.prototype, "position", {
        get: function () {
            return this.positionIn;
        },
        set: function (value) {
            this.positionIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WTabStop.prototype, "deletePosition", {
        get: function () {
            return this.deletePositionIn;
        },
        set: function (value) {
            this.deletePositionIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WTabStop.prototype, "tabJustification", {
        get: function () {
            return this.justification;
        },
        set: function (value) {
            this.justification = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WTabStop.prototype, "tabLeader", {
        get: function () {
            return this.leader;
        },
        set: function (value) {
            this.leader = value;
        },
        enumerable: true,
        configurable: true
    });
    WTabStop.prototype.destroy = function () {
        this.position = undefined;
        this.deletePosition = undefined;
        this.tabJustification = undefined;
        this.leader = undefined;
    };
    return WTabStop;
}());
/**
 * @private
 */
var WParagraphFormat = /** @__PURE__ @class */ (function () {
    function WParagraphFormat(node) {
        this.uniqueParagraphFormat = undefined;
        this.ownerBase = undefined;
        this.baseStyle = undefined;
        this.tabs = undefined;
        this.ownerBase = node;
        this.listFormat = new WListFormat(this);
        this.tabs = [];
    }
    WParagraphFormat.prototype.getUpdatedTabs = function () {
        var inTabs = [];
        if (!isNullOrUndefined(this.baseStyle)) {
            /* tslint:disable-next-line:no-any */
            var baseStyle = this.baseStyle;
            var tabStops = new Dictionary();
            while (!isNullOrUndefined(baseStyle)) {
                for (var _i = 0, _a = baseStyle.paragraphFormat.tabs; _i < _a.length; _i++) {
                    var tab = _a[_i];
                    if (!tabStops.containsKey(tab.position)) {
                        tabStops.add(tab.position, tab);
                    }
                }
                baseStyle = baseStyle.basedOn;
            }
            for (var _b = 0, _c = tabStops.keys; _b < _c.length; _b++) {
                var key = _c[_b];
                if (!this.hasTabStop(parseFloat(key.toFixed(4)))) {
                    inTabs.push(tabStops.get(key));
                }
            }
            inTabs = inTabs.concat(this.tabs.filter(function (a) { return (a.position !== 0 && a.deletePosition === 0); }));
            inTabs = inTabs.sort(function (a, b) { return a.position - b.position; });
        }
        return inTabs;
    };
    WParagraphFormat.prototype.hasTabStop = function (position) {
        for (var i = 0; i < this.tabs.length; i++) {
            if (parseFloat(this.tabs[i].position.toFixed(4)) === position ||
                parseFloat(this.tabs[i].deletePosition.toFixed(4)) === position) {
                return true;
            }
        }
        return false;
    };
    Object.defineProperty(WParagraphFormat.prototype, "leftIndent", {
        get: function () {
            return this.getPropertyValue('leftIndent');
        },
        set: function (value) {
            this.setPropertyValue('leftIndent', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WParagraphFormat.prototype, "rightIndent", {
        get: function () {
            return this.getPropertyValue('rightIndent');
        },
        set: function (value) {
            this.setPropertyValue('rightIndent', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WParagraphFormat.prototype, "firstLineIndent", {
        get: function () {
            return this.getPropertyValue('firstLineIndent');
        },
        set: function (value) {
            this.setPropertyValue('firstLineIndent', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WParagraphFormat.prototype, "beforeSpacing", {
        get: function () {
            return this.getPropertyValue('beforeSpacing');
        },
        set: function (value) {
            this.setPropertyValue('beforeSpacing', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WParagraphFormat.prototype, "afterSpacing", {
        get: function () {
            return this.getPropertyValue('afterSpacing');
        },
        set: function (value) {
            this.setPropertyValue('afterSpacing', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WParagraphFormat.prototype, "lineSpacing", {
        get: function () {
            return this.getPropertyValue('lineSpacing');
        },
        set: function (value) {
            this.setPropertyValue('lineSpacing', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WParagraphFormat.prototype, "lineSpacingType", {
        get: function () {
            return this.getPropertyValue('lineSpacingType');
        },
        set: function (value) {
            this.setPropertyValue('lineSpacingType', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WParagraphFormat.prototype, "textAlignment", {
        get: function () {
            return this.getPropertyValue('textAlignment');
        },
        set: function (value) {
            this.setPropertyValue('textAlignment', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WParagraphFormat.prototype, "outlineLevel", {
        get: function () {
            return this.getPropertyValue('outlineLevel');
        },
        set: function (value) {
            this.setPropertyValue('outlineLevel', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WParagraphFormat.prototype, "bidi", {
        get: function () {
            return this.getPropertyValue('bidi');
        },
        set: function (value) {
            if (this.bidi !== value) {
                if (this.textAlignment === 'Left') {
                    this.textAlignment = 'Right';
                }
                else if (this.textAlignment === 'Right') {
                    this.textAlignment = 'Left';
                }
            }
            this.setPropertyValue('bidi', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WParagraphFormat.prototype, "contextualSpacing", {
        get: function () {
            return this.getPropertyValue('contextualSpacing');
        },
        set: function (value) {
            this.setPropertyValue('contextualSpacing', value);
        },
        enumerable: true,
        configurable: true
    });
    WParagraphFormat.prototype.getListFormatParagraphFormat = function (property) {
        var paragraphFormat = this.getListPargaraphFormat(property);
        if (!isNullOrUndefined(paragraphFormat)) {
            // tslint:disable-next-line:max-line-length
            return paragraphFormat.uniqueParagraphFormat.propertiesHash.get(WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property));
        }
        return undefined;
    };
    WParagraphFormat.prototype.getListPargaraphFormat = function (property) {
        if (this.listFormat.listId > -1 && this.listFormat.listLevelNumber > -1) {
            var level = this.listFormat.listLevel;
            var propertyType = WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(level) && !isNullOrUndefined(level.paragraphFormat.uniqueParagraphFormat) &&
                level.paragraphFormat.uniqueParagraphFormat.propertiesHash.containsKey(propertyType)) {
                return level.paragraphFormat;
            }
            else {
                return undefined;
            }
        }
        return undefined;
    };
    WParagraphFormat.prototype.getPropertyValue = function (property) {
        if (!this.hasValue(property)) {
            var formatInList = this.getListFormatParagraphFormat(property);
            if (this.baseStyle instanceof WParagraphStyle) {
                var currentFormat = this;
                /* tslint:disable-next-line:no-any */
                var baseStyle = this.baseStyle;
                while (!isNullOrUndefined(baseStyle)) {
                    var listParaFormat = baseStyle.paragraphFormat.getListPargaraphFormat(property);
                    if (baseStyle.paragraphFormat.hasValue(property)) {
                        currentFormat = baseStyle.paragraphFormat;
                        break;
                    }
                    else if (!isNullOrUndefined(listParaFormat) && listParaFormat.hasValue(property)) {
                        currentFormat = listParaFormat;
                        break;
                    }
                    else {
                        baseStyle = baseStyle.basedOn;
                    }
                }
                if (!isNullOrUndefined(baseStyle)) {
                    if (!isNullOrUndefined(formatInList) && this.listFormat.listId !== -1
                        && currentFormat.listFormat.listId === -1
                        || !isNullOrUndefined(formatInList) && this.listFormat.listId !== currentFormat.listFormat.listId) {
                        return formatInList;
                    }
                    var propertyType = WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property);
                    return currentFormat.uniqueParagraphFormat.propertiesHash.get(propertyType);
                }
            }
            if (!isNullOrUndefined(formatInList)) {
                return formatInList;
            }
        }
        else {
            var propertyType = WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueParagraphFormat) && this.uniqueParagraphFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueParagraphFormat.propertiesHash.get(propertyType);
            }
        }
        return this.getDefaultValue(property);
    };
    WParagraphFormat.prototype.getDefaultValue = function (property) {
        var propertyType = WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property);
        var docParagraphFormat = this.documentParagraphFormat();
        var isInsideBodyWidget = true;
        if (this.ownerBase && this.ownerBase instanceof ParagraphWidget) {
            isInsideBodyWidget = this.ownerBase.containerWidget instanceof BodyWidget;
        }
        if (isInsideBodyWidget && !isNullOrUndefined(docParagraphFormat) && !isNullOrUndefined(docParagraphFormat.uniqueParagraphFormat) &&
            docParagraphFormat.uniqueParagraphFormat.propertiesHash.containsKey(propertyType)) {
            return docParagraphFormat.uniqueParagraphFormat.propertiesHash.get(propertyType);
        }
        else {
            return WParagraphFormat.getPropertyDefaultValue(property);
        }
    };
    WParagraphFormat.prototype.documentParagraphFormat = function () {
        var docParagraphFormat;
        if (!isNullOrUndefined(this.ownerBase)) {
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(this.ownerBase.bodyWidget) && !isNullOrUndefined(this.ownerBase.bodyWidget.page)) {
                docParagraphFormat = this.ownerBase.bodyWidget.page.viewer.paragraphFormat;
            }
        }
        return docParagraphFormat;
    };
    WParagraphFormat.prototype.setPropertyValue = function (property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WParagraphFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueParagraphFormat)) {
            this.initializeUniqueParagraphFormat(property, value);
        }
        else {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueParagraphFormat.uniqueFormatType, property);
            if (this.uniqueParagraphFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueParagraphFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            // tslint:disable-next-line:max-line-length
            this.uniqueParagraphFormat = WParagraphFormat.uniqueParagraphFormats.updateUniqueFormat(this.uniqueParagraphFormat, property, value);
        }
    };
    WParagraphFormat.prototype.initializeUniqueParagraphFormat = function (property, propValue) {
        var uniqueParaFormatTemp = new Dictionary();
        this.addUniqueParaFormat('leftIndent', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('rightIndent', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('firstLineIndent', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('textAlignment', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('beforeSpacing', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('afterSpacing', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('lineSpacing', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('lineSpacingType', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('outlineLevel', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('bidi', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('contextualSpacing', property, propValue, uniqueParaFormatTemp);
        // tslint:disable-next-line:max-line-length
        this.uniqueParagraphFormat = WParagraphFormat.uniqueParagraphFormats.addUniqueFormat(uniqueParaFormatTemp, WParagraphFormat.uniqueFormatType);
    };
    // tslint:disable-next-line:max-line-length
    WParagraphFormat.prototype.addUniqueParaFormat = function (property, modifiedProperty, propValue, uniqueParaFormatTemp) {
        var propertyType;
        propertyType = WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueParaFormatTemp.add(propertyType, propValue);
        }
    };
    WParagraphFormat.getPropertyDefaultValue = function (property) {
        var value = undefined;
        switch (property) {
            case 'leftIndent':
                value = 0;
                break;
            case 'rightIndent':
                value = 0;
                break;
            case 'firstLineIndent':
                value = 0;
                break;
            case 'textAlignment':
                value = 'Left';
                break;
            case 'beforeSpacing':
                value = 0;
                break;
            case 'afterSpacing':
                value = 0;
                break;
            case 'lineSpacing':
                value = 1;
                break;
            case 'lineSpacingType':
                value = 'Multiple';
                break;
            case 'styleName':
                value = 'Normal';
                break;
            case 'outlineLevel':
                value = 'BodyText';
                break;
            case 'bidi':
                value = false;
                break;
            case 'contextualSpacing':
                value = false;
                break;
        }
        return value;
    };
    WParagraphFormat.prototype.clearFormat = function () {
        if (!isNullOrUndefined(this.listFormat)) {
            this.listFormat.clearFormat();
        }
        if (!isNullOrUndefined(this.uniqueParagraphFormat) && this.uniqueParagraphFormat.referenceCount === 0) {
            WParagraphFormat.uniqueParagraphFormats.remove(this.uniqueParagraphFormat);
        }
        this.uniqueParagraphFormat = undefined;
        this.baseStyle = undefined;
    };
    WParagraphFormat.prototype.destroy = function () {
        this.clearFormat();
        if (!isNullOrUndefined(this.listFormat)) {
            this.listFormat.destroy();
        }
        this.listFormat = undefined;
        if (this.tabs !== undefined) {
            for (var i = 0; i < this.tabs.length; i++) {
                this.tabs[i].destroy();
            }
            this.tabs = undefined;
        }
    };
    WParagraphFormat.prototype.copyFormat = function (format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueParagraphFormat)) {
                this.updateUniqueParagraphFormat(format);
            }
            if (!isNullOrUndefined(format.listFormat)) {
                this.listFormat.copyFormat(format.listFormat);
            }
            if (!isNullOrUndefined(format.baseStyle)) {
                this.baseStyle = format.baseStyle;
            }
            if (!isNullOrUndefined(format.tabs)) {
                for (var i = 0; i < format.tabs.length; i++) {
                    this.tabs[i] = format.tabs[i];
                }
            }
        }
    };
    WParagraphFormat.prototype.updateUniqueParagraphFormat = function (format) {
        var hash = undefined;
        if (this.uniqueParagraphFormat) {
            hash = this.uniqueParagraphFormat.mergeProperties(format.uniqueParagraphFormat);
            if (this.uniqueParagraphFormat.referenceCount === 0) {
                WParagraphFormat.uniqueParagraphFormats.remove(this.uniqueParagraphFormat);
                this.uniqueParagraphFormat = undefined;
            }
        }
        this.uniqueParagraphFormat = new WUniqueFormat(WParagraphFormat.uniqueFormatType);
        if (isNullOrUndefined(hash)) {
            hash = this.uniqueParagraphFormat.mergeProperties(format.uniqueParagraphFormat);
        }
        this.uniqueParagraphFormat = WParagraphFormat.uniqueParagraphFormats.addUniqueFormat(hash, WParagraphFormat.uniqueFormatType);
    };
    WParagraphFormat.prototype.cloneFormat = function () {
        var format = new WParagraphFormat(undefined);
        format.uniqueParagraphFormat = this.uniqueParagraphFormat;
        format.baseStyle = this.baseStyle;
        if (isNullOrUndefined(this.listFormat)) {
            format.listFormat = undefined;
        }
        else {
            format.listFormat = new WListFormat();
            format.listFormat.listId = this.listFormat.listId;
            format.listFormat.listLevelNumber = this.listFormat.listLevelNumber;
        }
        return format;
    };
    WParagraphFormat.prototype.hasValue = function (property) {
        if (!isNullOrUndefined(this.uniqueParagraphFormat) && !isNullOrUndefined(this.uniqueParagraphFormat.propertiesHash)) {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueParagraphFormat.uniqueFormatType, property);
            return this.uniqueParagraphFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    };
    WParagraphFormat.clear = function () {
        this.uniqueParagraphFormats.clear();
    };
    WParagraphFormat.prototype.ApplyStyle = function (baseStyle) {
        this.baseStyle = baseStyle;
        this.listFormat.ApplyStyle(this.baseStyle);
    };
    /**
     * For internal use
     * @private
     */
    WParagraphFormat.prototype.getValue = function (property) {
        return this.hasValue(property) ? this.getPropertyValue(property) : undefined;
    };
    /**
     * For internal use
     * @private
     */
    WParagraphFormat.prototype.mergeFormat = function (format, isStyle) {
        isStyle = isNullOrUndefined(isStyle) ? false : isStyle;
        if (isNullOrUndefined(this.getValue('leftIndent'))) {
            this.leftIndent = format.getValue('leftIndent');
        }
        if (isNullOrUndefined(this.getValue('rightIndent'))) {
            this.rightIndent = format.getValue('rightIndent');
        }
        if (isNullOrUndefined(this.getValue('firstLineIndent'))) {
            this.firstLineIndent = format.getValue('firstLineIndent');
        }
        if (isNullOrUndefined(this.getValue('beforeSpacing'))) {
            this.beforeSpacing = format.getValue('beforeSpacing');
        }
        if (isNullOrUndefined(this.getValue('afterSpacing'))) {
            this.afterSpacing = format.getValue('afterSpacing');
        }
        if (isNullOrUndefined(this.getValue('lineSpacing'))) {
            this.lineSpacing = format.getValue('lineSpacing');
        }
        if (isNullOrUndefined(this.getValue('lineSpacingType'))) {
            this.lineSpacingType = format.getValue('lineSpacingType');
        }
        if (isNullOrUndefined(this.getValue('textAlignment'))) {
            this.textAlignment = format.getValue('textAlignment');
        }
        if (isNullOrUndefined(this.getValue('outlineLevel'))) {
            this.outlineLevel = format.getValue('outlineLevel');
        }
        if (!isStyle && isNullOrUndefined(this.getValue('bidi'))) {
            this.bidi = format.getValue('bidi');
        }
        if (isNullOrUndefined(this.getValue('contextualSpacing'))) {
            this.contextualSpacing = format.getValue('contextualSpacing');
        }
        if (isNullOrUndefined(this.listFormat)) {
            this.listFormat.mergeFormat(format.listFormat);
        }
    };
    WParagraphFormat.uniqueParagraphFormats = new WUniqueFormats();
    WParagraphFormat.uniqueFormatType = 3;
    return WParagraphFormat;
}());

/**
 * @private
 */
var WCharacterFormat = /** @__PURE__ @class */ (function () {
    function WCharacterFormat(node) {
        this.uniqueCharacterFormat = undefined;
        this.ownerBase = undefined;
        this.baseCharStyle = undefined;
        this.ownerBase = node;
    }
    Object.defineProperty(WCharacterFormat.prototype, "bold", {
        get: function () {
            return this.getPropertyValue('bold');
        },
        set: function (value) {
            this.setPropertyValue('bold', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCharacterFormat.prototype, "italic", {
        get: function () {
            return this.getPropertyValue('italic');
        },
        set: function (value) {
            this.setPropertyValue('italic', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCharacterFormat.prototype, "fontSize", {
        get: function () {
            return this.getPropertyValue('fontSize');
        },
        set: function (value) {
            this.setPropertyValue('fontSize', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCharacterFormat.prototype, "fontFamily", {
        get: function () {
            return this.getPropertyValue('fontFamily');
        },
        set: function (value) {
            this.setPropertyValue('fontFamily', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCharacterFormat.prototype, "underline", {
        get: function () {
            return this.getPropertyValue('underline');
        },
        set: function (value) {
            this.setPropertyValue('underline', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCharacterFormat.prototype, "strikethrough", {
        get: function () {
            return this.getPropertyValue('strikethrough');
        },
        set: function (value) {
            this.setPropertyValue('strikethrough', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCharacterFormat.prototype, "baselineAlignment", {
        get: function () {
            return this.getPropertyValue('baselineAlignment');
        },
        set: function (value) {
            this.setPropertyValue('baselineAlignment', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCharacterFormat.prototype, "highlightColor", {
        get: function () {
            return this.getPropertyValue('highlightColor');
        },
        set: function (value) {
            this.setPropertyValue('highlightColor', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCharacterFormat.prototype, "fontColor", {
        get: function () {
            return this.getPropertyValue('fontColor');
        },
        set: function (value) {
            this.setPropertyValue('fontColor', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCharacterFormat.prototype, "bidi", {
        get: function () {
            return this.getPropertyValue('bidi');
        },
        set: function (value) {
            this.setPropertyValue('bidi', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCharacterFormat.prototype, "bdo", {
        get: function () {
            return this.getPropertyValue('bdo');
        },
        set: function (value) {
            this.setPropertyValue('bdo', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCharacterFormat.prototype, "boldBidi", {
        get: function () {
            return this.getPropertyValue('boldBidi');
        },
        set: function (value) {
            this.setPropertyValue('boldBidi', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCharacterFormat.prototype, "italicBidi", {
        get: function () {
            return this.getPropertyValue('italicBidi');
        },
        set: function (value) {
            this.setPropertyValue('italicBidi', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCharacterFormat.prototype, "fontSizeBidi", {
        get: function () {
            return this.getPropertyValue('fontSizeBidi');
        },
        set: function (value) {
            this.setPropertyValue('fontSizeBidi', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCharacterFormat.prototype, "fontFamilyBidi", {
        get: function () {
            return this.getPropertyValue('fontFamilyBidi');
        },
        set: function (value) {
            this.setPropertyValue('fontFamilyBidi', value);
        },
        enumerable: true,
        configurable: true
    });
    WCharacterFormat.prototype.getPropertyValue = function (property) {
        if (!this.hasValue(property)) {
            var charStyleValue = this.checkCharacterStyle(property);
            if (!isNullOrUndefined(charStyleValue)) {
                return charStyleValue;
            }
            else {
                if (!isNullOrUndefined(this.baseCharStyle)) {
                    /* tslint:disable-next-line:no-any */
                    var paragraph = this.ownerBase.paragraph;
                    var line = this.ownerBase.line;
                    if (!isNullOrUndefined(paragraph) && !isNullOrUndefined(line)) {
                        var length_1 = line.children.length;
                        for (var i = 0; i < length_1; i++) {
                            /* tslint:disable-next-line:no-any */
                            var element = this.ownerBase.line.children[i];
                            if (element instanceof TextElementBox) {
                                /* tslint:disable-next-line:no-any */
                                var text = element.text;
                                if (text.startsWith('HYPERLINK')) {
                                    var index = text.indexOf('_Toc');
                                    if (index !== -1) {
                                        this.baseCharStyle = this.ownerBase.paragraph.paragraphFormat.baseStyle;
                                    }
                                }
                            }
                        }
                    }
                }
                var baseStyleValue = this.checkBaseStyle(property);
                if (!isNullOrUndefined(baseStyleValue)) {
                    return baseStyleValue;
                }
            }
        }
        else {
            var propertyType = WUniqueFormat.getPropertyType(WCharacterFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueCharacterFormat) && this.uniqueCharacterFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueCharacterFormat.propertiesHash.get(propertyType);
            }
        }
        return this.getDefaultValue(property);
    };
    WCharacterFormat.prototype.getDefaultValue = function (property) {
        var propertyType = WUniqueFormat.getPropertyType(WCharacterFormat.uniqueFormatType, property);
        var docCharacterFormat = this.documentCharacterFormat();
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(docCharacterFormat) && !isNullOrUndefined(docCharacterFormat.uniqueCharacterFormat) && docCharacterFormat.uniqueCharacterFormat.propertiesHash.containsKey(propertyType)) {
            return docCharacterFormat.uniqueCharacterFormat.propertiesHash.get(propertyType);
        }
        else {
            return WCharacterFormat.getPropertyDefaultValue(property);
        }
    };
    WCharacterFormat.prototype.documentCharacterFormat = function () {
        var docCharacterFormat;
        if (!isNullOrUndefined(this.ownerBase)) {
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(this.ownerBase.paragraph) && !isNullOrUndefined(this.ownerBase.paragraph.bodyWidget)) {
                docCharacterFormat = this.ownerBase.paragraph.bodyWidget.page.viewer.characterFormat;
            }
            else {
                if (!isNullOrUndefined(this.ownerBase.bodyWidget)) {
                    docCharacterFormat = this.ownerBase.bodyWidget.page.viewer.characterFormat;
                }
            }
        }
        return docCharacterFormat;
    };
    WCharacterFormat.prototype.checkBaseStyle = function (property) {
        /* tslint:disable-next-line:no-any */
        var baseStyle;
        if (!isNullOrUndefined(this.ownerBase)) {
            if (!isNullOrUndefined(this.ownerBase.paragraph)) {
                baseStyle = this.ownerBase.paragraph.paragraphFormat.baseStyle;
            }
            else {
                // tslint:disable-next-line:max-line-length
                if ((this.ownerBase instanceof ParagraphWidget) && !isNullOrUndefined(this.ownerBase.paragraphFormat)) {
                    baseStyle = this.ownerBase.paragraphFormat.baseStyle;
                }
                else {
                    if (!isNullOrUndefined(this.ownerBase instanceof WParagraphStyle)) {
                        baseStyle = this.ownerBase.basedOn;
                    }
                }
            }
        }
        while (!isNullOrUndefined(baseStyle)) {
            if (baseStyle.characterFormat.hasValue(property)) {
                break;
            }
            else {
                baseStyle = baseStyle.basedOn;
            }
        }
        if (!isNullOrUndefined(baseStyle)) {
            var propertyType = WUniqueFormat.getPropertyType(WCharacterFormat.uniqueFormatType, property);
            return baseStyle.characterFormat.uniqueCharacterFormat.propertiesHash.get(propertyType);
        }
        return undefined;
    };
    WCharacterFormat.prototype.checkCharacterStyle = function (property) {
        /* tslint:disable-next-line:no-any */
        var baseStyle = this.baseCharStyle;
        if (!isNullOrUndefined(baseStyle)) {
            while (!isNullOrUndefined(baseStyle) && baseStyle.name !== 'Default Paragraph Font') {
                var hasKey = baseStyle.characterFormat.hasValue(property);
                if (hasKey) {
                    var returnPropertyType = WUniqueFormat.getPropertyType(WCharacterFormat.uniqueFormatType, property);
                    return baseStyle.characterFormat.uniqueCharacterFormat.propertiesHash.get(returnPropertyType);
                }
                else {
                    baseStyle = baseStyle.basedOn;
                }
            }
        }
        return undefined;
    };
    WCharacterFormat.prototype.setPropertyValue = function (property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WCharacterFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueCharacterFormat)) {
            this.initializeUniqueCharacterFormat(property, value);
        }
        else {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueCharacterFormat.uniqueFormatType, property);
            if (this.uniqueCharacterFormat.propertiesHash.containsKey(propertyType) &&
                // tslint:disable-next-line:max-line-length
                this.uniqueCharacterFormat.propertiesHash.get(propertyType) === value) { //Do nothing, since no change in property value and return
                return;
            }
            // tslint:disable-next-line:max-line-length
            this.uniqueCharacterFormat = WCharacterFormat.uniqueCharacterFormats.updateUniqueFormat(this.uniqueCharacterFormat, property, value);
        }
    };
    WCharacterFormat.prototype.initializeUniqueCharacterFormat = function (property, propValue) {
        var uniqueCharFormatTemp = new Dictionary();
        this.addUniqueCharacterFormat('fontColor', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('fontFamily', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('fontSize', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('bold', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('italic', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('underline', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('strikethrough', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('baselineAlignment', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('highlightColor', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('styleName', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('bidi', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('bdo', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('fontFamilyBidi', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('fontSizeBidi', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('boldBidi', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('italicBidi', property, propValue, uniqueCharFormatTemp);
        // tslint:disable-next-line:max-line-length
        this.uniqueCharacterFormat = WCharacterFormat.uniqueCharacterFormats.addUniqueFormat(uniqueCharFormatTemp, WCharacterFormat.uniqueFormatType);
    };
    // tslint:disable-next-line:max-line-length
    WCharacterFormat.prototype.addUniqueCharacterFormat = function (property, modifiedProperty, propValue, uniqueCharFormatTemp) {
        var propertyType;
        propertyType = WUniqueFormat.getPropertyType(WCharacterFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueCharFormatTemp.add(propertyType, propValue);
        }
    };
    WCharacterFormat.getPropertyDefaultValue = function (property) {
        var value = undefined;
        switch (property) {
            case 'bold':
                value = false;
                break;
            case 'italic':
                value = false;
                break;
            case 'fontSize':
                value = 11;
                break;
            case 'underline':
                value = 'None';
                break;
            case 'strikethrough':
                value = 'None';
                break;
            case 'baselineAlignment':
                value = 'Normal';
                break;
            case 'highlightColor':
                value = 'NoColor';
                break;
            case 'fontColor':
                value = '#000000';
                break;
            case 'fontFamily':
                value = 'Calibri';
                break;
            case 'styleName':
                value = 'Default Paragraph Font';
                break;
            case 'bidi':
                value = false;
                break;
            case 'bdo':
                value = 'None';
                break;
            case 'boldBidi':
                value = false;
                break;
            case 'italicBidi':
                value = false;
                break;
            case 'fontSizeBidi':
                value = 11;
                break;
            case 'fontFamilyBidi':
                value = 'Calibri';
                break;
        }
        return value;
    };
    WCharacterFormat.prototype.isEqualFormat = function (format) {
        return (this.fontSize === format.fontSize
            && this.fontFamily === format.fontFamily
            && this.bold === format.bold
            && this.italic === format.italic
            && this.baselineAlignment === format.baselineAlignment
            && this.underline === format.underline
            && this.fontColor === format.fontColor
            && this.strikethrough === format.strikethrough
            && this.highlightColor === format.highlightColor && this.bidi === format.bidi
            && this.bdo === format.bdo);
    };
    WCharacterFormat.prototype.isSameFormat = function (format) {
        return this.baseCharStyle === format.baseCharStyle &&
            this.uniqueCharacterFormat === format.uniqueCharacterFormat;
    };
    WCharacterFormat.prototype.cloneFormat = function () {
        var format = new WCharacterFormat(undefined);
        format.uniqueCharacterFormat = this.uniqueCharacterFormat;
        format.baseCharStyle = this.baseCharStyle;
        return format;
    };
    /**
     * @private
     */
    WCharacterFormat.prototype.hasValue = function (property) {
        if (!isNullOrUndefined(this.uniqueCharacterFormat) && !isNullOrUndefined(this.uniqueCharacterFormat.propertiesHash)) {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueCharacterFormat.uniqueFormatType, property);
            return this.uniqueCharacterFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    };
    WCharacterFormat.prototype.clearFormat = function () {
        if (!isNullOrUndefined(this.uniqueCharacterFormat) && this.uniqueCharacterFormat.referenceCount === 0) {
            WCharacterFormat.uniqueCharacterFormats.remove(this.uniqueCharacterFormat);
        }
        this.uniqueCharacterFormat = undefined;
        this.baseCharStyle = undefined;
    };
    WCharacterFormat.prototype.destroy = function () {
        this.clearFormat();
    };
    WCharacterFormat.prototype.copyFormat = function (format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueCharacterFormat) && format.uniqueCharacterFormat.propertiesHash) {
                this.updateUniqueCharacterFormat(format);
            }
            if (!isNullOrUndefined(format.baseCharStyle)) {
                this.baseCharStyle = format.baseCharStyle;
            }
        }
    };
    WCharacterFormat.prototype.updateUniqueCharacterFormat = function (format) {
        var hash = undefined;
        if (this.uniqueCharacterFormat) {
            hash = this.uniqueCharacterFormat.mergeProperties(format.uniqueCharacterFormat);
            if (this.uniqueCharacterFormat.referenceCount === 0) {
                WCharacterFormat.uniqueCharacterFormats.remove(this.uniqueCharacterFormat);
                this.uniqueCharacterFormat = undefined;
            }
        }
        this.uniqueCharacterFormat = new WUniqueFormat(WCharacterFormat.uniqueFormatType);
        if (isNullOrUndefined(hash)) {
            hash = this.uniqueCharacterFormat.mergeProperties(format.uniqueCharacterFormat);
        }
        this.uniqueCharacterFormat = WCharacterFormat.uniqueCharacterFormats.addUniqueFormat(hash, WCharacterFormat.uniqueFormatType);
    };
    WCharacterFormat.clear = function () {
        this.uniqueCharacterFormats.clear();
    };
    WCharacterFormat.prototype.ApplyStyle = function (baseCharStyle) {
        this.baseCharStyle = baseCharStyle;
    };
    /**
     * For internal use
     * @private
     */
    WCharacterFormat.prototype.getValue = function (property) {
        return this.hasValue(property) ? this.getPropertyValue(property) : undefined;
    };
    /**
     * For internal use
     * @private
     */
    WCharacterFormat.prototype.mergeFormat = function (format) {
        if (isNullOrUndefined(this.getValue('bold'))) {
            this.bold = format.getValue('bold');
        }
        if (isNullOrUndefined(this.getValue('italic'))) {
            this.italic = format.getValue('italic');
        }
        if (isNullOrUndefined(this.getValue('fontSize'))) {
            this.fontSize = format.getValue('fontSize');
        }
        if (isNullOrUndefined(this.getValue('fontFamily'))) {
            this.fontFamily = format.getValue('fontFamily');
        }
        if (isNullOrUndefined(this.getValue('underline'))) {
            this.underline = format.getValue('underline');
        }
        if (isNullOrUndefined(this.getValue('strikethrough'))) {
            this.strikethrough = format.getValue('strikethrough');
        }
        if (isNullOrUndefined(this.getValue('baselineAlignment'))) {
            this.baselineAlignment = format.getValue('baselineAlignment');
        }
        if (isNullOrUndefined(this.getValue('highlightColor'))) {
            this.highlightColor = format.getValue('highlightColor');
        }
        if (isNullOrUndefined(this.getValue('fontColor'))) {
            this.fontColor = format.getValue('fontColor');
        }
        if (isNullOrUndefined(this.getValue('bidi'))) {
            this.bidi = format.getValue('bidi');
        }
        if (isNullOrUndefined(this.getValue('bdo'))) {
            this.bdo = format.getValue('bdo');
        }
    };
    WCharacterFormat.uniqueCharacterFormats = new WUniqueFormats();
    WCharacterFormat.uniqueFormatType = 2;
    return WCharacterFormat;
}());

/**
 * @private
 */
var HelperMethods = /** @__PURE__ @class */ (function () {
    function HelperMethods() {
    }
    /**
     * Inserts text at specified index in string.
     * @param {string} spanText
     * @param {number} index
     * @param {string} text
     * @private
     */
    HelperMethods.insert = function (spanText, index, text) {
        if (index >= 0) {
            return [spanText.slice(0, index) + text + spanText.slice(index)].join('');
        }
        else {
            return text + this;
        }
    };
    /**
     * Removes text from specified index in string.
     * @param {string} text
     * @param {number} index
     * @param {number} length
     * @private
     */
    HelperMethods.remove = function (text, index, length) {
        if (index === 0) {
            return text.substring(index + 1, text.length);
        }
        else {
            return text.substring(0, index) + text.substring(index + 1, text.length);
        }
    };
    /**
     * Returns the index of word split character in a string.
     * @param {string} text
     * @param {string[]} wordSplitCharacter
     * @private
     */
    /* tslint:disable:no-any */
    HelperMethods.indexOfAny = function (text, wordSplitCharacter) {
        var index = undefined;
        for (var j = 0; j < wordSplitCharacter.length; j++) {
            var temp = text.indexOf(wordSplitCharacter[j]);
            if (temp !== -1 && isNullOrUndefined(index)) {
                index = temp;
            }
            else if (temp !== -1 && temp < index) {
                index = temp;
            }
        }
        return isNullOrUndefined(index) ? -1 : index;
    };
    /**
     * Returns the last index of word split character in a string.
     * @param {string} text
     * @param {string[]} wordSplitCharacter
     * @private
     */
    HelperMethods.lastIndexOfAny = function (text, wordSplitCharacter) {
        for (var i = text.length - 1; i >= 0; i--) {
            for (var j = 0; j <= wordSplitCharacter.length - 1; j++) {
                if (text[i] === wordSplitCharacter[j]) {
                    return i;
                }
            }
        }
        return -1;
    };
    /**
     * Adds css styles to document header.
     * @param {string} css
     * @private
     */
    HelperMethods.addCssStyle = function (css) {
        var style = document.createElement('style');
        if (style.style.cssText) {
            style.style.cssText = css;
        }
        else {
            style.appendChild(document.createTextNode(css));
        }
        document.getElementsByTagName('head')[0].appendChild(style);
    };
    /**
     * Gets highlight color code.
     * @param {HighlightColor} highlightColor
     * @private
     */
    HelperMethods.getHighlightColorCode = function (highlightColor) {
        var color = '#ffffff';
        switch (highlightColor) {
            case 'Yellow':
                color = '#ffff00';
                break;
            case 'BrightGreen':
                color = '#00ff00';
                break;
            case 'Turquoise':
                color = '#00ffff';
                break;
            case 'Pink':
                color = '#ff00ff';
                break;
            case 'Blue':
                color = '#0000ff';
                break;
            case 'Red':
                color = '#ff0000';
                break;
            case 'DarkBlue':
                color = '#000080';
                break;
            case 'Teal':
                color = '#008080';
                break;
            case 'Green':
                color = '#008000';
                break;
            case 'Violet':
                color = '#800080';
                break;
            case 'DarkRed':
                color = '#800000';
                break;
            case 'DarkYellow':
                color = '#808000';
                break;
            case 'Gray50':
                color = '#808080';
                break;
            case 'Gray25':
                color = '#c0c0c0';
                break;
            case 'Black':
                color = '#000000';
                break;
        }
        return color;
    };
    HelperMethods.getColor = function (color) {
        if (color.length > 0) {
            if (color[0] === '#') {
                if (color.length > 7) {
                    return color.substr(0, 7);
                }
            }
        }
        return color;
    };
    /**
     * Converts point to pixel.
     * @param {number} point
     * @private
     */
    HelperMethods.convertPointToPixel = function (point) {
        var pixel = HelperMethods.round((point * 96 / 72), 5);
        return pixel;
    };
    /**
     * Converts pixel to point.
     * @param {number} pixel
     * @private
     */
    HelperMethods.convertPixelToPoint = function (pixel) {
        var point = HelperMethods.round((pixel * 72 / 96), 5);
        return point;
    };
    /**
     * Return true if field linked
     * @private
     */
    HelperMethods.isLinkedFieldCharacter = function (inline) {
        if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            return !isNullOrUndefined(inline.fieldEnd);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 2) {
            return !isNullOrUndefined(inline.fieldBegin) && !isNullOrUndefined(inline.fieldEnd);
        }
        else {
            return !isNullOrUndefined(inline.fieldBegin);
        }
    };
    /**
     * Removes white space in a string.
     * @param {string} text
     * @private
     */
    HelperMethods.removeSpace = function (text) {
        if (!isNullOrUndefined(text) && text.length !== 0) {
            for (var i = 0; i < text.length; i++) {
                if (text.charAt(i) === ' ') {
                    //replace the space by empty string in string
                    text = text.replace(' ', '');
                }
            }
        }
        return text;
    };
    /**
     * Trims white space at start of the string.
     * @param {string} text
     * @private
     */
    HelperMethods.trimStart = function (text) {
        var i = 0;
        for (i; i < text.length; i++) {
            if (text[i] !== ' ') {
                break;
            }
        }
        return text.substring(i, text.length);
    };
    /**
     * Trims white space at end of the string.
     * @param {string} text
     * @private
     */
    HelperMethods.trimEnd = function (text) {
        var i = text.length - 1;
        for (i; i >= 0; i--) {
            if (text[i] !== ' ') {
                break;
            }
        }
        return text.substring(0, i + 1);
    };
    /**
     * Checks whether string ends with whitespace.
     * @param {string} text
     * @private
     */
    HelperMethods.endsWith = function (text) {
        if (!isNullOrUndefined(text) && text.length !== 0) {
            return text[text.length - 1] === ' ';
        }
        return false;
    };
    /**
     * Return specified number of string count
     * @private
     */
    HelperMethods.addSpace = function (length) {
        var str = '';
        if (length > 0) {
            for (var i = 0; i < length; i++) {
                str += ' ';
            }
        }
        return str;
    };
    /**
     * @private
     * Write Characterformat
     * @param {any} characterFormat
     * @param {boolean} isInline
     * @param {WCharacterFormat} format
     */
    HelperMethods.writeCharacterFormat = function (characterFormat, isInline, format) {
        characterFormat.bold = isInline ? format.bold : format.getValue('bold');
        characterFormat.italic = isInline ? format.italic : format.getValue('italic');
        characterFormat.fontSize = isInline ? this.toWriteInline(format, 'fontSize') : format.getValue('fontSize');
        characterFormat.fontFamily = isInline ? this.toWriteInline(format, 'fontFamily') : format.getValue('fontFamily');
        characterFormat.underline = isInline ? format.underline : format.getValue('underline');
        characterFormat.strikethrough = isInline ? format.strikethrough : format.getValue('strikethrough');
        characterFormat.baselineAlignment = isInline ? format.baselineAlignment : format.getValue('baselineAlignment');
        characterFormat.highlightColor = isInline ? format.highlightColor : format.getValue('highlightColor');
        characterFormat.fontColor = isInline ? this.toWriteInline(format, 'fontColor') : format.getValue('fontColor');
        characterFormat.styleName = !isNullOrUndefined(format.baseCharStyle) ? format.baseCharStyle.name : undefined;
        characterFormat.bidi = isInline ? format.bidi : format.getValue('bidi');
        characterFormat.bdo = isInline ? format.bdo : format.getValue('bdo');
        characterFormat.boldBidi = isInline ? format.boldBidi : format.getValue('boldBidi');
        characterFormat.italicBidi = isInline ? format.italicBidi : format.getValue('italicBidi');
        characterFormat.fontSizeBidi = isInline ? format.fontSizeBidi : format.getValue('fontSizeBidi');
        characterFormat.fontFamilyBidi = isInline ? format.fontFamilyBidi : format.getValue('fontFamilyBidi');
    };
    HelperMethods.toWriteInline = function (format, propertyName) {
        if (!isNullOrUndefined(format.ownerBase) && (format.ownerBase instanceof ElementBox)) {
            return format.hasValue(propertyName) ? format[propertyName] : format.getValue(propertyName);
        }
        else {
            return format[propertyName];
        }
    };
    /* tslint:enable:no-any */
    /**
     * Rounds the values with specified decimal digits.
     * @param {number} value
     * @param {number} decimalDigits
     * @private
     */
    HelperMethods.round = function (value, decimalDigits) {
        var temp = value;
        for (var i = 0; i < decimalDigits; i++) {
            temp = temp * 10;
        }
        temp = Math.round(temp);
        for (var i = 0; i < decimalDigits; i++) {
            temp = temp / 10;
        }
        return temp;
    };
    HelperMethods.ReverseString = function (text) {
        if (!isNullOrUndefined(text) && text !== '') {
            // return a new array
            var splitString = text.split('');
            // reverse the new created array
            var reverseString = splitString.reverse();
            // join all elements of the array into a string
            text = reverseString.join('');
        }
        return text;
    };
    /**
     * @private
     */
    HelperMethods.formatClippedString = function (base64ImageString) {
        var extension = '';
        var formatClippedString = '';
        if (this.startsWith(base64ImageString, 'data:image/bmp;base64,')) {
            extension = '.bmp';
            formatClippedString = base64ImageString.replace('data:image/bmp;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/x-emf;base64,')) {
            extension = '.emf';
            formatClippedString = base64ImageString.replace('data:image/x-emf;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/exif;base64,')) {
            extension = '.exif';
            formatClippedString = base64ImageString.replace('data:image/exif;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/gif;base64,')) {
            extension = '.gif';
            formatClippedString = base64ImageString.replace('data:image/gif;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/icon;base64,')) {
            extension = '.ico';
            formatClippedString = base64ImageString.replace('data:image/icon;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/jpeg;base64,')) {
            extension = '.jpeg';
            formatClippedString = base64ImageString.replace('data:image/jpeg;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/jpg;base64,')) {
            extension = '.jpg';
            formatClippedString = base64ImageString.replace('data:image/jpg;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/png;base64,')) {
            extension = '.png';
            formatClippedString = base64ImageString.replace('data:image/png;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/tiff;base64,')) {
            extension = '.tif';
            formatClippedString = base64ImageString.replace('data:image/tiff;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/x-wmf;base64,')) {
            extension = '.wmf';
            formatClippedString = base64ImageString.replace('data:image/x-wmf;base64,', '');
        }
        else {
            extension = '.jpeg';
        }
        return { 'extension': extension, 'formatClippedString': formatClippedString };
    };
    HelperMethods.startsWith = function (sourceString, startString) {
        return startString.length > 0 && sourceString.substring(0, startString.length) === startString;
    };
    /**
     * @private
     */
    HelperMethods.wordBefore = '\\b';
    /**
     * @private
     */
    HelperMethods.wordAfter = '\\b';
    /**
     * @private
     */
    HelperMethods.wordSplitCharacters = [' ', ',', '.', ':', ';', '<', '>', '=',
        '+', '-', '_', '{', '}', '[', ']', '`', '~', '!', '@', '#', '$', '%', '^', '&',
        '*', '(', ')', '"', '?', '/', '|', '\\', '', '', '', '', '', '', ''];
    return HelperMethods;
}());
/**
 * @private
 */
var Point = /** @__PURE__ @class */ (function () {
    function Point(xPosition, yPosition) {
        this.xIn = 0;
        this.yIn = 0;
        this.xIn = xPosition;
        this.yIn = yPosition;
    }
    Object.defineProperty(Point.prototype, "x", {
        /**
         * Gets or sets x value.
         * @private
         */
        get: function () {
            return this.xIn;
        },
        set: function (value) {
            this.xIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Point.prototype, "y", {
        /**
         * Gets or sets y value.
         * @private
         */
        get: function () {
            return this.yIn;
        },
        set: function (value) {
            this.yIn = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    Point.prototype.copy = function (point) {
        this.xIn = point.xIn;
        this.yIn = point.yIn;
    };
    /**
     * Destroys the internal objects maintained.
     * @returns void
     */
    Point.prototype.destroy = function () {
        this.xIn = undefined;
        this.yIn = undefined;
    };
    return Point;
}());
/**
 * @private
 */
var Base64 = /** @__PURE__ @class */ (function () {
    function Base64() {
        this.keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    }
    // public method for encoding
    Base64.prototype.encodeString = function (input) {
        var output = '';
        var chr1;
        var chr2;
        var chr3;
        var enc1;
        var enc2;
        var enc3;
        var enc4;
        var i = 0;
        input = this.unicodeEncode(input);
        while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            }
            else if (isNaN(chr3)) {
                enc4 = 64;
            }
            output = output +
                this.keyStr.charAt(enc1) + this.keyStr.charAt(enc2) +
                this.keyStr.charAt(enc3) + this.keyStr.charAt(enc4);
        }
        return output;
    };
    // private method for UTF-8 encoding
    Base64.prototype.unicodeEncode = function (input) {
        var tempInput = input.replace(/\r\n/g, '\n');
        var utftext = '';
        for (var n = 0; n < tempInput.length; n++) {
            var c = tempInput.charCodeAt(n);
            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if ((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
        }
        return utftext;
    };
    /**
     * @private
     */
    Base64.prototype.decodeString = function (input) {
        var chr1;
        var chr2;
        var chr3;
        var enc1;
        var enc2;
        var enc3;
        var enc4;
        var i = 0;
        var resultIndex = 0;
        /*let dataUrlPrefix: string = 'data:';*/
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
        var totalLength = input.length * 3 / 4;
        if (input.charAt(input.length - 1) === this.keyStr.charAt(64)) {
            totalLength--;
        }
        if (input.charAt(input.length - 2) === this.keyStr.charAt(64)) {
            totalLength--;
        }
        if (totalLength % 1 !== 0) {
            // totalLength is not an integer, the length does not match a valid
            // base64 content. That can happen if:
            // - the input is not a base64 content
            // - the input is *almost* a base64 content, with a extra chars at the
            // beginning or at the end
            // - the input uses a base64 variant (base64url for example)
            throw new Error('Invalid base64 input, bad content length.');
        }
        var output = new Uint8Array(totalLength | 0);
        while (i < input.length) {
            enc1 = this.keyStr.indexOf(input.charAt(i++));
            enc2 = this.keyStr.indexOf(input.charAt(i++));
            enc3 = this.keyStr.indexOf(input.charAt(i++));
            enc4 = this.keyStr.indexOf(input.charAt(i++));
            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            output[resultIndex++] = chr1;
            if (enc3 !== 64) {
                output[resultIndex++] = chr2;
            }
            if (enc4 !== 64) {
                output[resultIndex++] = chr3;
            }
        }
        return output;
    };
    return Base64;
}());

var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @private
 */
var WStyle = /** @__PURE__ @class */ (function () {
    function WStyle() {
    }
    return WStyle;
}());
/**
 * @private
 */
var WParagraphStyle = /** @__PURE__ @class */ (function (_super) {
    __extends$2(WParagraphStyle, _super);
    function WParagraphStyle(node) {
        var _this = _super.call(this) || this;
        _this.ownerBase = node;
        _this.paragraphFormat = new WParagraphFormat(_this);
        _this.characterFormat = new WCharacterFormat(_this);
        return _this;
    }
    WParagraphStyle.prototype.destroy = function () {
        this.characterFormat.destroy();
        this.paragraphFormat.destroy();
    };
    WParagraphStyle.prototype.copyStyle = function (paraStyle) {
        this.name = paraStyle.name;
        this.ownerBase = paraStyle.ownerBase;
        this.type = paraStyle.type;
        this.next = paraStyle.next;
        this.basedOn = paraStyle.basedOn;
        this.link = paraStyle.link;
        this.characterFormat.copyFormat(paraStyle.characterFormat);
        this.paragraphFormat.copyFormat(paraStyle.paragraphFormat);
    };
    return WParagraphStyle;
}(WStyle));
/**
 * @private
 */
var WCharacterStyle = /** @__PURE__ @class */ (function (_super) {
    __extends$2(WCharacterStyle, _super);
    function WCharacterStyle(node) {
        var _this = _super.call(this) || this;
        _this.ownerBase = node;
        _this.characterFormat = new WCharacterFormat(_this);
        return _this;
    }
    WCharacterStyle.prototype.destroy = function () {
        this.characterFormat.destroy();
    };
    WCharacterStyle.prototype.copyStyle = function (charStyle) {
        this.name = charStyle.name;
        this.ownerBase = charStyle.ownerBase;
        this.type = charStyle.type;
        this.next = charStyle.next;
        this.basedOn = charStyle.basedOn;
        this.characterFormat.copyFormat(charStyle.characterFormat);
    };
    return WCharacterStyle;
}(WStyle));
/**
 * @private
 */
var WStyles = /** @__PURE__ @class */ (function () {
    function WStyles() {
        this.collection = [];
        /* tslint:enable:no-any */
    }
    Object.defineProperty(WStyles.prototype, "length", {
        get: function () {
            return this.collection.length;
        },
        enumerable: true,
        configurable: true
    });
    WStyles.prototype.remove = function (item) {
        this.collection = this.collection.filter(function (a) { return (a.name !== item.name); });
    };
    WStyles.prototype.push = function (item) {
        if (item != null && item !== undefined) {
            this.collection.push(item);
        }
        return 1;
    };
    WStyles.prototype.getItem = function (index) {
        if (this.collection.length > index) {
            return this.collection[index];
        }
        return null;
    };
    WStyles.prototype.indexOf = function (item) {
        return this.collection.indexOf(item);
    };
    WStyles.prototype.contains = function (item) {
        var index = this.collection.indexOf(item);
        return index > -1 && index < this.collection.length;
    };
    WStyles.prototype.clear = function () {
        while (this.collection.length > 0) {
            this.collection.pop();
        }
    };
    WStyles.prototype.findByName = function (name, type) {
        var returnStyle;
        for (var _i = 0, _a = this.collection; _i < _a.length; _i++) {
            var value = _a[_i];
            if (value.name === name) {
                returnStyle = value;
                if (!isNullOrUndefined(type) && value.type === type) {
                    returnStyle = value;
                }
            }
        }
        return returnStyle;
    };
    WStyles.prototype.getStyleNames = function (type) {
        return this.collection.filter(function (a) { return (a.type === type); }).map(function (a) { return a.name; });
    };
    /* tslint:disable:no-any */
    WStyles.prototype.getStyles = function (type) {
        var styles = this.collection.filter(function (a) { return (a.type === type); }).map(function (a) { return a; });
        var styleObjects = [];
        for (var _i = 0, styles_1 = styles; _i < styles_1.length; _i++) {
            var style = styles_1[_i];
            var returnStyle = {};
            var returnStyleObject = {};
            returnStyleObject.characterFormat = {};
            HelperMethods.writeCharacterFormat(returnStyleObject.characterFormat, true, style.characterFormat);
            returnStyle.name = style.name;
            returnStyle.style = JSON.stringify(returnStyleObject);
            styleObjects.push(returnStyle);
        }
        return styleObjects;
    };
    return WStyles;
}());

/**
 * @private
 */
var WBorder = /** @__PURE__ @class */ (function () {
    function WBorder(node) {
        this.uniqueBorderFormat = undefined;
        this.ownerBase = undefined;
        this.ownerBase = node;
    }
    Object.defineProperty(WBorder.prototype, "color", {
        get: function () {
            return this.getPropertyValue('color');
        },
        set: function (value) {
            this.setPropertyValue('color', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WBorder.prototype, "lineStyle", {
        get: function () {
            return this.getPropertyValue('lineStyle');
        },
        set: function (value) {
            this.setPropertyValue('lineStyle', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WBorder.prototype, "lineWidth", {
        get: function () {
            return this.getPropertyValue('lineWidth');
        },
        set: function (value) {
            this.setPropertyValue('lineWidth', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WBorder.prototype, "shadow", {
        get: function () {
            return this.getPropertyValue('shadow');
        },
        set: function (value) {
            this.setPropertyValue('shadow', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WBorder.prototype, "space", {
        get: function () {
            return this.getPropertyValue('space');
        },
        set: function (value) {
            this.setPropertyValue('space', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WBorder.prototype, "hasNoneStyle", {
        get: function () {
            return this.getPropertyValue('hasNoneStyle');
        },
        set: function (value) {
            this.setPropertyValue('hasNoneStyle', value);
        },
        enumerable: true,
        configurable: true
    });
    WBorder.prototype.getPropertyValue = function (property) {
        var hasValue = this.hasValue(property);
        if (hasValue) {
            var propertyType = WUniqueFormat.getPropertyType(WBorder.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueBorderFormat) && this.uniqueBorderFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueBorderFormat.propertiesHash.get(propertyType);
            }
        }
        return WBorder.getPropertyDefaultValue(property);
    };
    WBorder.prototype.setPropertyValue = function (property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WBorder.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueBorderFormat)) {
            this.initializeUniqueBorder(property, value);
        }
        else {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueBorderFormat.uniqueFormatType, property);
            if (this.uniqueBorderFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueBorderFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueBorderFormat = WBorder.uniqueBorderFormats.updateUniqueFormat(this.uniqueBorderFormat, property, value);
        }
    };
    WBorder.prototype.initializeUniqueBorder = function (property, propValue) {
        var uniqueBorderFormatTemp = new Dictionary();
        this.addUniqueBorderFormat('color', property, propValue, uniqueBorderFormatTemp);
        this.addUniqueBorderFormat('lineStyle', property, propValue, uniqueBorderFormatTemp);
        this.addUniqueBorderFormat('lineWidth', property, propValue, uniqueBorderFormatTemp);
        this.addUniqueBorderFormat('shadow', property, propValue, uniqueBorderFormatTemp);
        this.addUniqueBorderFormat('space', property, propValue, uniqueBorderFormatTemp);
        this.addUniqueBorderFormat('hasNoneStyle', property, propValue, uniqueBorderFormatTemp);
        this.uniqueBorderFormat = WBorder.uniqueBorderFormats.addUniqueFormat(uniqueBorderFormatTemp, WBorder.uniqueFormatType);
    };
    // tslint:disable-next-line:max-line-length
    WBorder.prototype.addUniqueBorderFormat = function (property, modifiedProperty, propValue, uniqueBorderFormatTemp) {
        var propertyType;
        propertyType = WUniqueFormat.getPropertyType(WBorder.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueBorderFormatTemp.add(propertyType, propValue);
        }
    };
    WBorder.getPropertyDefaultValue = function (property) {
        var value = undefined;
        switch (property) {
            case 'color':
                value = '#000000';
                break;
            case 'lineStyle':
                value = 'None';
                break;
            case 'lineWidth':
                value = 0;
                break;
            case 'shadow':
                value = false;
                break;
            case 'space':
                value = 0;
                break;
            case 'hasNoneStyle':
                value = false;
                break;
        }
        return value;
    };
    WBorder.prototype.getLineWidth = function () {
        /* tslint:disable */
        switch (this.lineStyle) {
            case 'None':
            case 'Cleared':
                return 0;
            case 'Triple':
            case 'Double':
            case 'ThinThickSmallGap':
            case 'ThickThinSmallGap':
            case 'ThinThickThinSmallGap':
            case 'ThinThickMediumGap':
            case 'ThickThinMediumGap':
            case 'ThinThickThinMediumGap':
            case 'ThinThickLargeGap':
            case 'ThickThinLargeGap':
            case 'ThinThickThinLargeGap':
            case 'Emboss3D':
            case 'Engrave3D':
                {
                    var lineArray = this.getBorderLineWidthArray(this.lineStyle, this.lineWidth);
                    var width = 0;
                    for (var i = 0; i < lineArray.length; i++) {
                        width += lineArray[i];
                    }
                    return width;
                }
            case 'Single':
            case 'DashLargeGap':
            case 'DashSmallGap':
            case 'Dot':
            case 'DashDot':
            case 'DashDotDot':
            case 'Thick':
                return this.lineWidth;
            case 'SingleWavy':
                return (this.lineWidth === 1.5 ? 3 : 2.5); //Double wave border only draw with the fixed width
            case 'DoubleWavy':
                return (6.75); //Double wave border only draw with the fixed width
            case 'DashDotStroked':
            case 'Outset':
                return this.lineWidth;
        }
        return this.lineWidth;
        /* tslint:enable */
    };
    WBorder.prototype.getBorderLineWidthArray = function (lineStyle, lineWidth) {
        var borderLineArray = [lineWidth];
        switch (lineStyle) {
            case 'Double':
                borderLineArray = [1, 1, 1];
                break;
            case 'ThinThickSmallGap':
                borderLineArray = [1, -0.75, -0.75];
                break;
            case 'ThickThinSmallGap':
                borderLineArray = [-0.75, -0.75, 1];
                break;
            case 'ThinThickMediumGap':
                borderLineArray = [1, 0.5, 0.5];
                break;
            case 'ThickThinMediumGap':
                borderLineArray = [0.5, 0.5, 1];
                break;
            case 'ThinThickLargeGap':
                borderLineArray = [-1.5, 1, -0.75];
                break;
            case 'ThickThinLargeGap':
                borderLineArray = [-0.75, 1, -1.5];
                break;
            case 'Triple':
                borderLineArray = [1, 1, 1, 1, 1];
                break;
            case 'ThinThickThinSmallGap':
                borderLineArray = [-0.75, -0.75, 1, -0.75, -0.75];
                break;
            case 'ThinThickThinMediumGap':
                borderLineArray = [0.5, 0.5, 1, 0.5, 0.5];
                break;
            case 'ThinThickThinLargeGap':
                borderLineArray = [-0.75, 1, -1.5, 1, -0.75];
                break;
            case 'Emboss3D':
            case 'Engrave3D':
                borderLineArray = [0.25, 0, 1, 0, 0.25];
                break;
        }
        if (borderLineArray.length === 1) {
            return [lineWidth];
        }
        for (var i = 0; i < borderLineArray.length; i++) {
            if (borderLineArray[i] >= 0) {
                borderLineArray[i] = borderLineArray[i] * lineWidth;
            }
            else {
                borderLineArray[i] = Math.abs(borderLineArray[i]);
            }
        }
        return borderLineArray;
    };
    WBorder.prototype.getBorderWeight = function () {
        var weight = 0;
        var numberOfLines = this.getNumberOfLines();
        var borderNumber = this.getBorderNumber();
        switch (this.lineStyle) {
            case 'Single':
            case 'DashSmallGap':
            case 'DashDot':
            case 'DashDotDot':
            case 'Double':
            case 'Triple':
            case 'ThinThickSmallGap':
            case 'ThickThinSmallGap':
            case 'ThinThickThinSmallGap':
            case 'ThinThickMediumGap':
            case 'ThickThinMediumGap':
            case 'ThinThickThinMediumGap':
            case 'ThinThickLargeGap':
            case 'ThickThinLargeGap':
            case 'ThinThickThinLargeGap':
            case 'SingleWavy':
            case 'DoubleWavy':
            case 'DashDotStroked':
            case 'Emboss3D':
            case 'Engrave3D':
            case 'Outset':
            case 'Inset':
            case 'Thick':
                weight = numberOfLines * borderNumber;
                break;
            case 'Dot':
            case 'DashLargeGap':
                weight = 1;
                break;
        }
        return weight;
    };
    WBorder.prototype.getBorderNumber = function () {
        var borderNumber = 0;
        switch (this.lineStyle) {
            case 'Single':
                borderNumber = 1;
                break;
            case 'Thick':
                borderNumber = 2;
                break;
            case 'Double':
                borderNumber = 3;
                break;
            case 'Dot':
                borderNumber = 4;
                break;
            case 'DashLargeGap': //dashed.
                borderNumber = 5;
                break;
            case 'DashDot':
                borderNumber = 6;
                break;
            case 'DashDotDot':
                borderNumber = 7;
                break;
            case 'Triple':
                borderNumber = 8;
                break;
            case 'ThinThickSmallGap':
                borderNumber = 9;
                break;
            case 'ThickThinSmallGap':
                borderNumber = 10;
                break;
            case 'ThinThickThinSmallGap':
                borderNumber = 11;
                break;
            case 'ThinThickMediumGap':
                borderNumber = 12;
                break;
            case 'ThickThinMediumGap':
                borderNumber = 13;
                break;
            case 'ThinThickThinMediumGap':
                borderNumber = 14;
                break;
            case 'ThinThickLargeGap':
                borderNumber = 15;
                break;
            case 'ThickThinLargeGap':
                borderNumber = 16;
                break;
            case 'ThinThickThinLargeGap':
                borderNumber = 17;
                break;
            case 'SingleWavy': //wave.
                borderNumber = 18;
                break;
            case 'DoubleWavy':
                borderNumber = 19;
                break;
            case 'DashSmallGap':
                borderNumber = 20;
                break;
            case 'DashDotStroked':
                borderNumber = 21;
                break;
            case 'Emboss3D':
                borderNumber = 22;
                break;
            case 'Engrave3D':
                borderNumber = 23;
                break;
            case 'Outset':
                borderNumber = 24;
                break;
            case 'Inset':
                borderNumber = 25;
                break;
        }
        return borderNumber;
    };
    WBorder.prototype.getNumberOfLines = function () {
        //ToDo: Need to analyze more on this.
        var value = 0;
        switch (this.lineStyle) {
            case 'Single':
            case 'Dot':
            case 'DashSmallGap':
            case 'DashLargeGap':
            case 'DashDot':
            case 'DashDotDot':
                value = 1;
                break;
            case 'Double':
                value = 3;
                break;
            case 'Triple':
                value = 5;
                break;
            case 'ThinThickSmallGap':
                value = 3;
                break;
            case 'ThickThinSmallGap':
                value = 3;
                break;
            case 'ThinThickThinSmallGap':
                value = 5;
                break;
            case 'ThinThickMediumGap':
                value = 3;
                break;
            case 'ThickThinMediumGap':
                value = 3;
                break;
            case 'ThinThickThinMediumGap':
                value = 5;
                break;
            case 'ThinThickLargeGap':
                value = 3;
                break;
            case 'ThickThinLargeGap':
                value = 3;
                break;
            case 'ThinThickThinLargeGap':
                value = 5;
                break;
            case 'SingleWavy':
                value = 1;
                break;
            case 'DoubleWavy':
                value = 2;
                break;
            case 'DashDotStroked':
                value = 1;
                break;
            case 'Emboss3D':
            case 'Engrave3D':
                value = 3;
                break;
            case 'Outset':
            case 'Inset':
            case 'Thick':
                value = 1;
                break;
        }
        return value;
    };
    WBorder.prototype.getPrecedence = function () {
        var value = 0;
        switch (this.lineStyle) {
            case 'Single':
                value = 1;
                break;
            case 'Thick':
                value = 2;
                break;
            case 'Double':
                value = 3;
                break;
            case 'Dot':
                value = 4;
                break;
            case 'DashLargeGap': //dashed.
                value = 5;
                break;
            case 'DashDot':
                value = 6;
                break;
            case 'DashDotDot':
                value = 7;
                break;
            case 'Triple':
                value = 8;
                break;
            case 'ThinThickSmallGap':
                value = 9;
                break;
            case 'ThickThinSmallGap':
                value = 10;
                break;
            case 'ThinThickThinSmallGap':
                value = 11;
                break;
            case 'ThinThickMediumGap':
                value = 12;
                break;
            case 'ThickThinMediumGap':
                value = 13;
                break;
            case 'ThinThickThinMediumGap':
                value = 14;
                break;
            case 'ThinThickLargeGap':
                value = 15;
                break;
            case 'ThickThinLargeGap':
                value = 16;
                break;
            case 'ThinThickThinLargeGap':
                value = 17;
                break;
            case 'SingleWavy': //wave.
                value = 18;
                break;
            case 'DoubleWavy':
                value = 19;
                break;
            case 'DashSmallGap':
                value = 20;
                break;
            case 'DashDotStroked':
                value = 21;
                break;
            case 'Emboss3D':
                value = 22;
                break;
            case 'Engrave3D':
                value = 23;
                break;
            case 'Outset':
                value = 24;
                break;
            case 'Inset':
                value = 25;
                break;
        }
        return value;
    };
    /**
     * @private
     */
    WBorder.prototype.hasValue = function (property) {
        if (!isNullOrUndefined(this.uniqueBorderFormat)) {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueBorderFormat.uniqueFormatType, property);
            return this.uniqueBorderFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    };
    WBorder.prototype.cloneFormat = function () {
        var border = new WBorder(undefined);
        border.color = this.color;
        border.lineStyle = this.lineStyle;
        border.lineWidth = this.lineWidth;
        border.shadow = this.shadow;
        border.space = this.space;
        return border;
    };
    WBorder.prototype.destroy = function () {
        if (!isNullOrUndefined(this.uniqueBorderFormat)) {
            WBorder.uniqueBorderFormats.remove(this.uniqueBorderFormat);
        }
        this.uniqueBorderFormat = undefined;
    };
    WBorder.prototype.copyFormat = function (border) {
        if (!isNullOrUndefined(border) && !isNullOrUndefined(border.uniqueBorderFormat)) {
            if (border.hasValue('color')) {
                this.color = border.color;
            }
            if (border.hasValue('lineStyle')) {
                this.lineStyle = border.lineStyle;
            }
            if (border.hasValue('lineWidth')) {
                this.lineWidth = border.lineWidth;
            }
            if (border.hasValue('shadow')) {
                this.shadow = border.shadow;
            }
            if (border.hasValue('space')) {
                this.space = border.space;
            }
        }
    };
    WBorder.clear = function () {
        this.uniqueBorderFormats.clear();
    };
    WBorder.uniqueBorderFormats = new WUniqueFormats();
    WBorder.uniqueFormatType = 1;
    return WBorder;
}());

/**
 * @private
 */
var WBorders = /** @__PURE__ @class */ (function () {
    function WBorders(node) {
        this.leftIn = new WBorder(this);
        this.rightIn = new WBorder(this);
        this.topIn = new WBorder(this);
        this.bottomIn = new WBorder(this);
        this.horizontalIn = new WBorder(this);
        this.verticalIn = new WBorder(this);
        this.diagonalUpIn = new WBorder(this);
        this.diagonalDownIn = new WBorder(this);
        this.lineWidthIn = 0;
        this.ownerBase = node;
    }
    Object.defineProperty(WBorders.prototype, "left", {
        get: function () {
            return this.leftIn;
        },
        set: function (value) {
            this.leftIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WBorders.prototype, "right", {
        get: function () {
            return this.rightIn;
        },
        set: function (value) {
            this.rightIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WBorders.prototype, "top", {
        get: function () {
            return this.topIn;
        },
        set: function (value) {
            this.topIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WBorders.prototype, "bottom", {
        get: function () {
            return this.bottomIn;
        },
        set: function (value) {
            this.bottomIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WBorders.prototype, "horizontal", {
        get: function () {
            return this.horizontalIn;
        },
        set: function (value) {
            this.horizontalIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WBorders.prototype, "vertical", {
        get: function () {
            return this.verticalIn;
        },
        set: function (value) {
            this.verticalIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WBorders.prototype, "diagonalUp", {
        get: function () {
            return this.diagonalUpIn;
        },
        set: function (value) {
            this.diagonalUpIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WBorders.prototype, "diagonalDown", {
        get: function () {
            return this.diagonalDownIn;
        },
        set: function (value) {
            this.diagonalDownIn = value;
        },
        enumerable: true,
        configurable: true
    });
    WBorders.prototype.destroy = function () {
        if (!isNullOrUndefined(this.left)) {
            this.left.destroy();
        }
        if (!isNullOrUndefined(this.top)) {
            this.top.destroy();
        }
        if (!isNullOrUndefined(this.bottom)) {
            this.bottom.destroy();
        }
        if (!isNullOrUndefined(this.right)) {
            this.right.destroy();
        }
        if (!isNullOrUndefined(this.horizontal)) {
            this.horizontal.destroy();
        }
        if (!isNullOrUndefined(this.vertical)) {
            this.vertical.destroy();
        }
        if (!isNullOrUndefined(this.diagonalDown)) {
            this.diagonalDown.destroy();
        }
        if (!isNullOrUndefined(this.diagonalUp)) {
            this.diagonalUp.destroy();
        }
        this.topIn = undefined;
        this.bottomIn = undefined;
        this.leftIn = undefined;
        this.rightIn = undefined;
        this.horizontalIn = undefined;
        this.verticalIn = undefined;
        this.diagonalDownIn = undefined;
        this.diagonalUpIn = undefined;
        this.lineWidthIn = undefined;
        this.valueIn = undefined;
    };
    WBorders.prototype.cloneFormat = function () {
        var borders = new WBorders(undefined);
        borders.top = isNullOrUndefined(this.top) ? undefined : this.top.cloneFormat();
        borders.bottom = isNullOrUndefined(this.bottom) ? undefined : this.bottom.cloneFormat();
        borders.left = isNullOrUndefined(this.left) ? undefined : this.left.cloneFormat();
        borders.right = isNullOrUndefined(this.right) ? undefined : this.right.cloneFormat();
        borders.horizontal = isNullOrUndefined(this.horizontal) ? undefined : this.horizontal.cloneFormat();
        borders.vertical = isNullOrUndefined(this.vertical) ? undefined : this.vertical.cloneFormat();
        borders.diagonalUp = isNullOrUndefined(this.diagonalUp) ? undefined : this.diagonalUp.cloneFormat();
        borders.diagonalDown = isNullOrUndefined(this.diagonalDown) ? undefined : this.diagonalDown.cloneFormat();
        return borders;
    };
    WBorders.prototype.copyFormat = function (borders) {
        if (!isNullOrUndefined(borders.left) && borders.left instanceof WBorder) {
            this.left = new WBorder(this);
            this.left.copyFormat(borders.left);
        }
        if (!isNullOrUndefined(borders.right) && borders.right instanceof WBorder) {
            this.right = new WBorder(this);
            this.right.copyFormat(borders.right);
        }
        if (!isNullOrUndefined(borders.top) && borders.top instanceof WBorder) {
            this.top = new WBorder(this);
            this.top.copyFormat(borders.top);
        }
        if (!isNullOrUndefined(borders.bottom) && borders.bottom instanceof WBorder) {
            this.bottom = new WBorder(this);
            this.bottom.copyFormat(borders.bottom);
        }
        if (!isNullOrUndefined(borders.horizontal) && borders.horizontal instanceof WBorder) {
            this.horizontal = new WBorder(this);
            this.horizontal.copyFormat(borders.horizontal);
        }
        if (!isNullOrUndefined(borders.vertical) && borders.vertical instanceof WBorder) {
            this.vertical = new WBorder(this);
            this.vertical.copyFormat(borders.vertical);
        }
        if (!isNullOrUndefined(borders.diagonalDown) && borders.diagonalDown instanceof WBorder) {
            this.diagonalDown = new WBorder(this);
            this.diagonalDown.copyFormat(borders.diagonalDown);
        }
        if (!isNullOrUndefined(borders.diagonalUp) && borders.diagonalUp instanceof WBorder) {
            this.diagonalUp = new WBorder(this);
            this.diagonalUp.copyFormat(borders.diagonalUp);
        }
    };
    return WBorders;
}());

/**
 * @private
 */
var WShading = /** @__PURE__ @class */ (function () {
    function WShading(node) {
        this.uniqueShadingFormat = undefined;
        this.ownerBase = undefined;
        this.ownerBase = node;
    }
    Object.defineProperty(WShading.prototype, "backgroundColor", {
        get: function () {
            return this.getPropertyValue('backgroundColor');
        },
        set: function (value) {
            this.setPropertyValue('backgroundColor', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WShading.prototype, "foregroundColor", {
        get: function () {
            return this.getPropertyValue('foregroundColor');
        },
        set: function (value) {
            this.setPropertyValue('foregroundColor', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WShading.prototype, "textureStyle", {
        get: function () {
            return this.getPropertyValue('textureStyle');
        },
        set: function (value) {
            this.setPropertyValue('textureStyle', value);
        },
        enumerable: true,
        configurable: true
    });
    WShading.prototype.getPropertyValue = function (property) {
        var hasValue = this.hasValue(property);
        if (hasValue) {
            var propertyType = WUniqueFormat.getPropertyType(WShading.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueShadingFormat) && this.uniqueShadingFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueShadingFormat.propertiesHash.get(propertyType);
            }
        }
        return WShading.getPropertyDefaultValue(property);
    };
    WShading.prototype.setPropertyValue = function (property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WShading.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueShadingFormat)) {
            this.initializeUniqueShading(property, value);
        }
        else {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueShadingFormat.uniqueFormatType, property);
            if (this.uniqueShadingFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueShadingFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueShadingFormat = WShading.uniqueShadingFormats.updateUniqueFormat(this.uniqueShadingFormat, property, value);
        }
    };
    WShading.getPropertyDefaultValue = function (property) {
        var value = undefined;
        switch (property) {
            case 'backgroundColor':
                value = '#ffffff';
                break;
            case 'foregroundColor':
                value = 'empty';
                break;
            case 'textureStyle':
                value = 'TextureNone';
                break;
        }
        return value;
    };
    WShading.prototype.initializeUniqueShading = function (property, propValue) {
        var uniqueShadingTemp = new Dictionary();
        this.addUniqueShading('backgroundColor', property, propValue, uniqueShadingTemp);
        this.addUniqueShading('foregroundColor', property, propValue, uniqueShadingTemp);
        this.addUniqueShading('textureStyle', property, propValue, uniqueShadingTemp);
        // tslint:disable-next-line:max-line-length        
        this.uniqueShadingFormat = WShading.uniqueShadingFormats.addUniqueFormat(uniqueShadingTemp, WShading.uniqueFormatType);
    };
    // tslint:disable-next-line:max-line-length
    WShading.prototype.addUniqueShading = function (property, modifiedProperty, propValue, uniqueShadingTemp) {
        var propertyType;
        propertyType = WUniqueFormat.getPropertyType(WShading.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueShadingTemp.add(propertyType, propValue);
        }
        else {
            uniqueShadingTemp.add(propertyType, WShading.getPropertyDefaultValue(property));
        }
    };
    WShading.prototype.destroy = function () {
        if (!isNullOrUndefined(this.uniqueShadingFormat)) {
            WShading.uniqueShadingFormats.remove(this.uniqueShadingFormat);
        }
        this.uniqueShadingFormat = undefined;
    };
    WShading.prototype.cloneFormat = function () {
        var shading = new WShading(undefined);
        shading.backgroundColor = this.backgroundColor;
        shading.foregroundColor = this.foregroundColor;
        shading.textureStyle = this.textureStyle;
        return shading;
    };
    WShading.prototype.copyFormat = function (shading) {
        if (!isNullOrUndefined(shading) && !isNullOrUndefined(shading.uniqueShadingFormat)) {
            this.backgroundColor = shading.backgroundColor;
            this.foregroundColor = shading.foregroundColor;
            this.textureStyle = shading.textureStyle;
        }
    };
    /**
     * @private
     */
    WShading.prototype.hasValue = function (property) {
        if (!isNullOrUndefined(this.uniqueShadingFormat)) {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueShadingFormat.uniqueFormatType, property);
            return this.uniqueShadingFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    };
    WShading.clear = function () {
        this.uniqueShadingFormats.clear();
    };
    WShading.uniqueShadingFormats = new WUniqueFormats();
    WShading.uniqueFormatType = 5;
    return WShading;
}());

/**
 * @private
 */
var WTableFormat = /** @__PURE__ @class */ (function () {
    function WTableFormat(owner) {
        this.uniqueTableFormat = undefined;
        this.borders = new WBorders(this);
        this.shading = new WShading(this);
        this.ownerBase = undefined;
        this.ownerBase = owner;
        this.assignTableMarginValue(5.4, 0, 5.4, 0);
    }
    Object.defineProperty(WTableFormat.prototype, "allowAutoFit", {
        get: function () {
            return this.getPropertyValue('allowAutoFit');
        },
        set: function (value) {
            this.setPropertyValue('allowAutoFit', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WTableFormat.prototype, "cellSpacing", {
        get: function () {
            return this.getPropertyValue('cellSpacing');
        },
        set: function (value) {
            if (value < 0 || value > 264.6) {
                throw new RangeError('The measurement must be between 0 px and 264.6 px.');
            }
            this.setPropertyValue('cellSpacing', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WTableFormat.prototype, "leftMargin", {
        get: function () {
            return this.getPropertyValue('leftMargin');
        },
        set: function (value) {
            this.setPropertyValue('leftMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WTableFormat.prototype, "topMargin", {
        get: function () {
            return this.getPropertyValue('topMargin');
        },
        set: function (value) {
            this.setPropertyValue('topMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WTableFormat.prototype, "rightMargin", {
        get: function () {
            return this.getPropertyValue('rightMargin');
        },
        set: function (value) {
            this.setPropertyValue('rightMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WTableFormat.prototype, "bottomMargin", {
        get: function () {
            return this.getPropertyValue('bottomMargin');
        },
        set: function (value) {
            this.setPropertyValue('bottomMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WTableFormat.prototype, "leftIndent", {
        get: function () {
            return this.getPropertyValue('leftIndent');
        },
        set: function (value) {
            if (value < -1440 || value > 1440) {
                throw new RangeError('The measurement must be between -1440 px and 1440 px.');
            }
            this.setPropertyValue('leftIndent', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WTableFormat.prototype, "tableAlignment", {
        get: function () {
            return this.getPropertyValue('tableAlignment');
        },
        set: function (value) {
            this.setPropertyValue('tableAlignment', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WTableFormat.prototype, "preferredWidth", {
        get: function () {
            return this.getPropertyValue('preferredWidth');
        },
        set: function (value) {
            this.setPropertyValue('preferredWidth', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WTableFormat.prototype, "preferredWidthType", {
        get: function () {
            return this.getPropertyValue('preferredWidthType');
        },
        set: function (value) {
            this.setPropertyValue('preferredWidthType', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WTableFormat.prototype, "bidi", {
        get: function () {
            return this.getPropertyValue('bidi');
        },
        set: function (value) {
            this.setPropertyValue('bidi', value);
        },
        enumerable: true,
        configurable: true
    });
    WTableFormat.prototype.getPropertyValue = function (property) {
        var hasValue = this.hasValue(property);
        if (hasValue) {
            var propertyType = WUniqueFormat.getPropertyType(WTableFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueTableFormat) && this.uniqueTableFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueTableFormat.propertiesHash.get(propertyType);
            }
        }
        return WTableFormat.getPropertyDefaultValue(property);
    };
    WTableFormat.prototype.setPropertyValue = function (property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WTableFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueTableFormat)) {
            this.initializeUniqueTableFormat(property, value);
        }
        else {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueTableFormat.uniqueFormatType, property);
            if (this.uniqueTableFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueTableFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueTableFormat = WTableFormat.uniqueTableFormats.updateUniqueFormat(this.uniqueTableFormat, property, value);
        }
    };
    WTableFormat.prototype.initializeUniqueTableFormat = function (property, propValue) {
        var uniqueTableFormatTemp = new Dictionary();
        this.addUniqueTableFormat('allowAutoFit', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('cellSpacing', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('leftMargin', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('topMargin', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('bottomMargin', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('rightMargin', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('leftIndent', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('tableAlignment', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('preferredWidth', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('preferredWidthType', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('bidi', property, propValue, uniqueTableFormatTemp);
        this.uniqueTableFormat = WTableFormat.uniqueTableFormats.addUniqueFormat(uniqueTableFormatTemp, WTableFormat.uniqueFormatType);
    };
    // tslint:disable-next-line:max-line-length
    WTableFormat.prototype.addUniqueTableFormat = function (property, modifiedProperty, propValue, uniqueTableFormatTemp) {
        var propertyType;
        propertyType = WUniqueFormat.getPropertyType(WTableFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueTableFormatTemp.add(propertyType, propValue);
        }
    };
    WTableFormat.getPropertyDefaultValue = function (property) {
        var value = undefined;
        switch (property) {
            case 'allowAutoFit':
                value = false;
                break;
            case 'cellSpacing':
                value = 0;
                break;
            case 'leftMargin':
                value = 5.4;
                break;
            case 'topMargin':
                value = 0;
                break;
            case 'bottomMargin':
                value = 0;
                break;
            case 'rightMargin':
                value = 5.4;
                break;
            case 'leftIndent':
                value = 0;
                break;
            case 'tableAlignment':
                value = 'Left';
                break;
            case 'preferredWidth':
                value = 0;
                break;
            case 'preferredWidthType':
                value = 'Point';
                break;
            case 'bidi':
                value = false;
                break;
        }
        return value;
    };
    WTableFormat.prototype.assignTableMarginValue = function (left, top, right, bottom) {
        this.leftMargin = left;
        this.topMargin = top;
        this.rightMargin = right;
        this.bottomMargin = bottom;
    };
    WTableFormat.prototype.initializeTableBorders = function () {
        this.borders.left.lineStyle = 'Single';
        this.borders.left.lineWidth = 0.5;
        this.borders.right.lineStyle = 'Single';
        this.borders.right.lineWidth = 0.5;
        this.borders.top.lineStyle = 'Single';
        this.borders.top.lineWidth = 0.5;
        this.borders.bottom.lineStyle = 'Single';
        this.borders.bottom.lineWidth = 0.5;
        this.borders.horizontal.lineStyle = 'Single';
        this.borders.horizontal.lineWidth = 0.5;
        this.borders.vertical.lineStyle = 'Single';
        this.borders.vertical.lineWidth = 0.5;
    };
    WTableFormat.prototype.destroy = function () {
        if (!isNullOrUndefined(this.borders)) {
            this.borders.destroy();
        }
        if (!isNullOrUndefined(this.shading)) {
            this.shading.destroy();
        }
        if (!isNullOrUndefined(this.uniqueTableFormat)) {
            WTableFormat.uniqueTableFormats.remove(this.uniqueTableFormat);
        }
        this.uniqueTableFormat = undefined;
        this.borders = undefined;
        this.shading = undefined;
    };
    WTableFormat.prototype.cloneFormat = function () {
        var tableFormat = new WTableFormat(undefined);
        tableFormat.leftIndent = this.leftIndent;
        tableFormat.tableAlignment = this.tableAlignment;
        tableFormat.cellSpacing = this.cellSpacing;
        tableFormat.leftMargin = this.leftMargin;
        tableFormat.rightMargin = this.rightMargin;
        tableFormat.topMargin = this.topMargin;
        tableFormat.bottomMargin = this.bottomMargin;
        tableFormat.preferredWidth = this.preferredWidth;
        tableFormat.preferredWidthType = this.preferredWidthType;
        tableFormat.borders = isNullOrUndefined(this.borders) ? undefined : this.borders.cloneFormat();
        tableFormat.shading = isNullOrUndefined(this.shading) ? undefined : this.shading.cloneFormat();
        tableFormat.bidi = this.bidi;
        tableFormat.allowAutoFit = this.allowAutoFit;
        return tableFormat;
    };
    WTableFormat.prototype.hasValue = function (property) {
        if (!isNullOrUndefined(this.uniqueTableFormat)) {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueTableFormat.uniqueFormatType, property);
            return this.uniqueTableFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    };
    WTableFormat.prototype.copyFormat = function (format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueTableFormat)) {
                this.cellSpacing = format.cellSpacing;
                this.leftMargin = format.leftMargin;
                this.topMargin = format.topMargin;
                this.rightMargin = format.rightMargin;
                this.bottomMargin = format.bottomMargin;
                this.leftIndent = format.leftIndent;
                this.tableAlignment = format.tableAlignment;
                this.preferredWidth = format.preferredWidth;
                this.preferredWidthType = format.preferredWidthType;
                this.bidi = format.bidi;
                this.allowAutoFit = format.allowAutoFit;
            }
            if (!isNullOrUndefined(format.borders)) {
                this.borders = new WBorders(this);
                this.borders.copyFormat(format.borders);
            }
            if (!isNullOrUndefined(format.shading)) {
                this.shading = new WShading(this);
                this.shading.copyFormat(format.shading);
            }
        }
    };
    WTableFormat.clear = function () {
        this.uniqueTableFormats.clear();
    };
    WTableFormat.uniqueTableFormats = new WUniqueFormats();
    WTableFormat.uniqueFormatType = 8;
    return WTableFormat;
}());

/**
 * @private
 */
var WRowFormat = /** @__PURE__ @class */ (function () {
    function WRowFormat(node) {
        this.uniqueRowFormat = undefined;
        /**
         * @private
         */
        this.borders = new WBorders(this);
        /**
         * @private
         */
        this.ownerBase = undefined;
        /**
         * @private
         */
        this.beforeWidth = 0;
        /**
         * @private
         */
        this.afterWidth = 0;
        this.ownerBase = node;
    }
    Object.defineProperty(WRowFormat.prototype, "gridBefore", {
        get: function () {
            return this.getPropertyValue('gridBefore');
        },
        set: function (value) {
            this.setPropertyValue('gridBefore', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WRowFormat.prototype, "gridBeforeWidth", {
        get: function () {
            return this.getPropertyValue('gridBeforeWidth');
        },
        set: function (value) {
            this.setPropertyValue('gridBeforeWidth', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WRowFormat.prototype, "gridBeforeWidthType", {
        get: function () {
            return this.getPropertyValue('gridBeforeWidthType');
        },
        set: function (value) {
            this.setPropertyValue('gridBeforeWidthType', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WRowFormat.prototype, "gridAfter", {
        get: function () {
            return this.getPropertyValue('gridAfter');
        },
        set: function (value) {
            this.setPropertyValue('gridAfter', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WRowFormat.prototype, "gridAfterWidth", {
        get: function () {
            return this.getPropertyValue('gridAfterWidth');
        },
        set: function (value) {
            this.setPropertyValue('gridAfterWidth', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WRowFormat.prototype, "gridAfterWidthType", {
        get: function () {
            return this.getPropertyValue('gridAfterWidthType');
        },
        set: function (value) {
            this.setPropertyValue('gridAfterWidthType', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WRowFormat.prototype, "allowBreakAcrossPages", {
        get: function () {
            return this.getPropertyValue('allowBreakAcrossPages');
        },
        set: function (value) {
            this.setPropertyValue('allowBreakAcrossPages', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WRowFormat.prototype, "isHeader", {
        get: function () {
            return this.getPropertyValue('isHeader');
        },
        set: function (value) {
            this.setPropertyValue('isHeader', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WRowFormat.prototype, "rightMargin", {
        get: function () {
            return this.getPropertyValue('rightMargin');
        },
        set: function (value) {
            this.setPropertyValue('rightMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WRowFormat.prototype, "height", {
        get: function () {
            return this.getPropertyValue('height');
        },
        set: function (value) {
            if (value === 0 && (this.heightType === 'AtLeast' || this.heightType === 'Exactly')) {
                value = 1;
            }
            else if (this.heightType === 'Auto') {
                value = 0;
            }
            this.setPropertyValue('height', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WRowFormat.prototype, "heightType", {
        get: function () {
            return this.getPropertyValue('heightType');
        },
        set: function (value) {
            if (value === 'AtLeast' || value === 'Exactly') {
                this.height = 1;
            }
            else {
                this.height = 0;
            }
            this.setPropertyValue('heightType', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WRowFormat.prototype, "bottomMargin", {
        get: function () {
            return this.getPropertyValue('bottomMargin');
        },
        set: function (value) {
            this.setPropertyValue('bottomMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WRowFormat.prototype, "leftIndent", {
        get: function () {
            return this.getPropertyValue('leftIndent');
        },
        set: function (value) {
            this.setPropertyValue('leftIndent', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WRowFormat.prototype, "topMargin", {
        get: function () {
            return this.getPropertyValue('topMargin');
        },
        set: function (value) {
            this.setPropertyValue('topMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WRowFormat.prototype, "leftMargin", {
        get: function () {
            return this.getPropertyValue('leftMargin');
        },
        set: function (value) {
            this.setPropertyValue('leftMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    WRowFormat.prototype.getPropertyValue = function (property) {
        var hasValue = this.hasValue(property);
        if (hasValue) {
            var propertyType = WUniqueFormat.getPropertyType(WRowFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueRowFormat) && this.uniqueRowFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueRowFormat.propertiesHash.get(propertyType);
            }
        }
        return WRowFormat.getPropertyDefaultValue(property);
    };
    WRowFormat.prototype.setPropertyValue = function (property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WRowFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueRowFormat)) {
            this.initializeUniqueRowFormat(property, value);
        }
        else {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueRowFormat.uniqueFormatType, property);
            if (this.uniqueRowFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueRowFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueRowFormat = WRowFormat.uniqueRowFormats.updateUniqueFormat(this.uniqueRowFormat, property, value);
        }
    };
    WRowFormat.prototype.initializeUniqueRowFormat = function (property, propValue) {
        var uniqueRowFormatTemp = new Dictionary();
        this.addUniqueRowFormat('allowBreakAcrossPages', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('isHeader', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('height', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('heightType', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridBefore', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridBeforeWidth', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridBeforeWidthType', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridAfter', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridAfterWidth', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridgridAfterWidth', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridBeforeWidthType', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('leftMargin', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('rightMargin', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('topMargin', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('bottomMargin', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('leftIndent', property, propValue, uniqueRowFormatTemp);
        this.uniqueRowFormat = WRowFormat.uniqueRowFormats.addUniqueFormat(uniqueRowFormatTemp, WRowFormat.uniqueFormatType);
    };
    // tslint:disable-next-line:max-line-length
    WRowFormat.prototype.addUniqueRowFormat = function (property, modifiedProperty, propValue, uniqueRowFormatTemp) {
        var propertyType;
        propertyType = WUniqueFormat.getPropertyType(WRowFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueRowFormatTemp.add(propertyType, propValue);
        }
    };
    WRowFormat.getPropertyDefaultValue = function (property) {
        var value = undefined;
        switch (property) {
            case 'allowBreakAcrossPages':
                value = true;
                break;
            case 'isHeader':
                value = false;
                break;
            case 'height':
                value = 0;
                break;
            case 'heightType':
                value = 'Auto';
                break;
            case 'gridBefore':
                value = 0;
                break;
            case 'gridBeforeWidth':
                value = 0;
                break;
            case 'gridBeforeWidthType':
                value = 'Point';
                break;
            case 'gridAfter':
                value = 0;
                break;
            case 'gridAfterWidth':
                value = 0;
                break;
            case 'gridAfterWidthType':
                value = 'Point';
                break;
            case 'leftMargin':
                value = undefined;
                break;
            case 'topMargin':
                value = undefined;
                break;
            case 'bottomMargin':
                value = undefined;
                break;
            case 'rightMargin':
                value = undefined;
                break;
            case 'leftIndent':
                value = 0;
                break;
        }
        return value;
    };
    WRowFormat.prototype.containsMargins = function () {
        return (!isNullOrUndefined(this.leftMargin)
            || !isNullOrUndefined(this.rightMargin)
            || !isNullOrUndefined(this.bottomMargin)
            || !isNullOrUndefined(this.topMargin));
    };
    WRowFormat.prototype.cloneFormat = function () {
        var format = new WRowFormat();
        format.allowBreakAcrossPages = this.allowBreakAcrossPages;
        format.heightType = this.heightType;
        format.height = this.height;
        format.isHeader = this.isHeader;
        format.gridBefore = this.gridBefore;
        format.gridBeforeWidth = this.gridBeforeWidth;
        format.gridBeforeWidthType = this.gridBeforeWidthType;
        format.gridAfter = this.gridAfter;
        format.gridAfterWidth = this.gridAfterWidth;
        format.gridAfterWidthType = this.gridAfterWidthType;
        format.leftMargin = this.leftMargin;
        format.rightMargin = this.rightMargin;
        format.topMargin = this.topMargin;
        format.bottomMargin = this.bottomMargin;
        format.leftIndent = this.leftIndent;
        return format;
    };
    WRowFormat.prototype.hasValue = function (property) {
        if (!isNullOrUndefined(this.uniqueRowFormat)) {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueRowFormat.uniqueFormatType, property);
            return this.uniqueRowFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    };
    WRowFormat.prototype.copyFormat = function (format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueRowFormat)) {
                this.allowBreakAcrossPages = format.allowBreakAcrossPages;
                this.isHeader = format.isHeader;
                this.heightType = format.heightType;
                this.height = format.height;
                this.gridBefore = format.gridBefore;
                this.gridBeforeWidth = format.gridBeforeWidth;
                this.gridBeforeWidthType = format.gridBeforeWidthType;
                this.gridAfter = format.gridAfter;
                this.gridAfterWidth = format.gridAfterWidth;
                this.gridAfterWidthType = format.gridAfterWidthType;
                this.leftMargin = format.leftMargin;
                this.topMargin = format.topMargin;
                this.rightMargin = format.rightMargin;
                this.bottomMargin = format.bottomMargin;
                this.leftIndent = format.leftIndent;
            }
            if (!isNullOrUndefined(format.borders)) {
                this.borders = new WBorders(this);
                this.borders.ownerBase = format;
                this.borders.copyFormat(format.borders);
            }
        }
    };
    WRowFormat.prototype.destroy = function () {
        if (!isNullOrUndefined(this.borders)) {
            this.borders.destroy();
        }
        if (!isNullOrUndefined(this.uniqueRowFormat)) {
            WRowFormat.uniqueRowFormats.remove(this.uniqueRowFormat);
        }
        this.beforeWidth = undefined;
        this.afterWidth = undefined;
        this.borders = undefined;
        this.uniqueRowFormat = undefined;
    };
    WRowFormat.clear = function () {
        this.uniqueRowFormats.clear();
    };
    WRowFormat.uniqueRowFormats = new WUniqueFormats();
    WRowFormat.uniqueFormatType = 6;
    return WRowFormat;
}());

/**
 * @private
 */
var WCellFormat = /** @__PURE__ @class */ (function () {
    function WCellFormat(node) {
        this.uniqueCellFormat = undefined;
        this.borders = new WBorders(this);
        this.shading = new WShading(this);
        this.ownerBase = node;
        this.borders = new WBorders(this);
        this.shading = new WShading(this);
    }
    Object.defineProperty(WCellFormat.prototype, "leftMargin", {
        get: function () {
            return this.getPropertyValue('leftMargin');
        },
        set: function (value) {
            this.setPropertyValue('leftMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCellFormat.prototype, "rightMargin", {
        get: function () {
            return this.getPropertyValue('rightMargin');
        },
        set: function (value) {
            this.setPropertyValue('rightMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCellFormat.prototype, "topMargin", {
        get: function () {
            return this.getPropertyValue('topMargin');
        },
        set: function (value) {
            this.setPropertyValue('topMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCellFormat.prototype, "bottomMargin", {
        get: function () {
            return this.getPropertyValue('bottomMargin');
        },
        set: function (value) {
            this.setPropertyValue('bottomMargin', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCellFormat.prototype, "cellWidth", {
        get: function () {
            return this.getPropertyValue('cellWidth');
        },
        set: function (value) {
            this.setPropertyValue('cellWidth', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCellFormat.prototype, "columnSpan", {
        get: function () {
            return this.getPropertyValue('columnSpan');
        },
        set: function (value) {
            this.setPropertyValue('columnSpan', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCellFormat.prototype, "rowSpan", {
        get: function () {
            return this.getPropertyValue('rowSpan');
        },
        set: function (value) {
            this.setPropertyValue('rowSpan', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCellFormat.prototype, "preferredWidth", {
        get: function () {
            return this.getPropertyValue('preferredWidth');
        },
        set: function (value) {
            this.setPropertyValue('preferredWidth', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCellFormat.prototype, "verticalAlignment", {
        get: function () {
            return this.getPropertyValue('verticalAlignment');
        },
        set: function (value) {
            this.setPropertyValue('verticalAlignment', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WCellFormat.prototype, "preferredWidthType", {
        get: function () {
            return this.getPropertyValue('preferredWidthType');
        },
        set: function (value) {
            this.setPropertyValue('preferredWidthType', value);
        },
        enumerable: true,
        configurable: true
    });
    WCellFormat.prototype.getPropertyValue = function (property) {
        var hasValue = this.hasValue(property);
        if (hasValue) {
            var propertyType = WUniqueFormat.getPropertyType(WCellFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueCellFormat) && this.uniqueCellFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueCellFormat.propertiesHash.get(propertyType);
            }
        }
        return WCellFormat.getPropertyDefaultValue(property);
    };
    WCellFormat.prototype.setPropertyValue = function (property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WCellFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueCellFormat)) {
            this.initializeUniqueCellFormat(property, value);
        }
        else {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueCellFormat.uniqueFormatType, property);
            if (this.uniqueCellFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueCellFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueCellFormat = WCellFormat.uniqueCellFormats.updateUniqueFormat(this.uniqueCellFormat, property, value);
        }
    };
    WCellFormat.prototype.initializeUniqueCellFormat = function (property, propValue) {
        var uniqueCellFormatTemp = new Dictionary();
        this.addUniqueCellFormat('leftMargin', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('topMargin', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('bottomMargin', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('rightMargin', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('cellWidth', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('columnSpan', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('rowSpan', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('preferredWidth', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('verticalAlignment', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('preferredWidthType', property, propValue, uniqueCellFormatTemp);
        this.uniqueCellFormat = WCellFormat.uniqueCellFormats.addUniqueFormat(uniqueCellFormatTemp, WCellFormat.uniqueFormatType);
    };
    // tslint:disable-next-line:max-line-length
    WCellFormat.prototype.addUniqueCellFormat = function (property, modifiedProperty, propValue, uniqueCellFormatTemp) {
        var propertyType;
        propertyType = WUniqueFormat.getPropertyType(WCellFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueCellFormatTemp.add(propertyType, propValue);
        }
    };
    WCellFormat.getPropertyDefaultValue = function (property) {
        var value = undefined;
        switch (property) {
            case 'leftMargin':
                value = undefined;
                break;
            case 'topMargin':
                value = undefined;
                break;
            case 'bottomMargin':
                value = undefined;
                break;
            case 'rightMargin':
                value = undefined;
                break;
            case 'cellWidth':
                value = 0;
                break;
            case 'columnSpan':
                value = 1;
                break;
            case 'rowSpan':
                value = 1;
                break;
            case 'preferredWidth':
                value = 0;
                break;
            case 'verticalAlignment':
                value = 'Top';
                break;
            case 'preferredWidthType':
                value = 'Point';
                break;
        }
        return value;
    };
    WCellFormat.prototype.containsMargins = function () {
        return (!isNullOrUndefined(this.leftMargin)
            || !isNullOrUndefined(this.rightMargin)
            || !isNullOrUndefined(this.bottomMargin)
            || !isNullOrUndefined(this.topMargin));
    };
    WCellFormat.prototype.destroy = function () {
        if (!isNullOrUndefined(this.borders)) {
            this.borders.destroy();
        }
        if (!isNullOrUndefined(this.shading)) {
            this.shading.destroy();
        }
        if (!isNullOrUndefined(this.uniqueCellFormat)) {
            WCellFormat.uniqueCellFormats.remove(this.uniqueCellFormat);
        }
        this.uniqueCellFormat = undefined;
        this.borders = undefined;
        this.shading = undefined;
    };
    WCellFormat.prototype.cloneFormat = function () {
        var format = new WCellFormat(undefined);
        format.verticalAlignment = this.verticalAlignment;
        format.leftMargin = this.leftMargin;
        format.rightMargin = this.rightMargin;
        format.topMargin = this.topMargin;
        format.bottomMargin = this.bottomMargin;
        format.preferredWidth = this.preferredWidth;
        format.preferredWidthType = this.preferredWidthType;
        format.cellWidth = this.cellWidth;
        format.borders = isNullOrUndefined(this.borders) ? undefined : this.borders.cloneFormat();
        format.shading = isNullOrUndefined(this.shading) ? undefined : this.shading.cloneFormat();
        return format;
    };
    WCellFormat.prototype.hasValue = function (property) {
        if (!isNullOrUndefined(this.uniqueCellFormat)) {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueCellFormat.uniqueFormatType, property);
            return this.uniqueCellFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    };
    WCellFormat.prototype.copyFormat = function (format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueCellFormat)) {
                this.cellWidth = format.cellWidth;
                this.leftMargin = format.leftMargin;
                this.topMargin = format.topMargin;
                this.rightMargin = format.rightMargin;
                this.bottomMargin = format.bottomMargin;
                this.preferredWidth = format.preferredWidth;
                this.columnSpan = format.columnSpan;
                this.rowSpan = format.rowSpan;
                this.preferredWidthType = format.preferredWidthType;
                this.verticalAlignment = format.verticalAlignment;
            }
            if (!isNullOrUndefined(format.shading)) {
                this.shading = new WShading(this);
                this.shading.copyFormat(format.shading);
            }
            if (!isNullOrUndefined(format.borders)) {
                this.borders = new WBorders(this);
                this.borders.copyFormat(format.borders);
            }
        }
    };
    WCellFormat.clear = function () {
        this.uniqueCellFormats.clear();
    };
    WCellFormat.uniqueCellFormats = new WUniqueFormats();
    WCellFormat.uniqueFormatType = 4;
    return WCellFormat;
}());

/**
 * Formats Modules
 */

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @private
 */
var Rect = /** @__PURE__ @class */ (function () {
    function Rect(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    Object.defineProperty(Rect.prototype, "right", {
        /**
         * @private
         */
        get: function () {
            return this.x + this.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "bottom", {
        /**
         * @private
         */
        get: function () {
            return this.y + this.height;
        },
        enumerable: true,
        configurable: true
    });
    return Rect;
}());
/**
 * @private
 */
var Margin = /** @__PURE__ @class */ (function () {
    function Margin(leftMargin, topMargin, rightMargin, bottomMargin) {
        this.left = leftMargin;
        this.top = topMargin;
        this.right = rightMargin;
        this.bottom = bottomMargin;
    }
    /**
     * @private
     */
    Margin.prototype.clone = function () {
        return new Margin(this.left, this.top, this.right, this.bottom);
    };
    /**
     * @private
     */
    Margin.prototype.destroy = function () {
        this.left = undefined;
        this.right = undefined;
        this.top = undefined;
        this.bottom = undefined;
    };
    return Margin;
}());
/**
 * @private
 */
var Widget = /** @__PURE__ @class */ (function () {
    function Widget() {
        /**
         * @private
         */
        this.childWidgets = [];
        /**
         * @private
         */
        this.x = 0;
        /**
         * @private
         */
        this.y = 0;
        /**
         * @private
         */
        this.width = 0;
        /**
         * @private
         */
        this.height = 0;
        /**
         * @private
         */
        this.index = 0;
    }
    Object.defineProperty(Widget.prototype, "indexInOwner", {
        /**
         * @private
         */
        get: function () {
            if (this instanceof BodyWidget && this.page) {
                return this.page.bodyWidgets.indexOf(this);
            }
            else if (this.containerWidget && this.containerWidget.childWidgets) {
                return this.containerWidget.childWidgets.indexOf(this);
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "firstChild", {
        /**
         * @private
         */
        get: function () {
            return this.childWidgets.length > 0 ? this.childWidgets[0] : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "lastChild", {
        /**
         * @private
         */
        get: function () {
            if (this.childWidgets) {
                return this.childWidgets.length > 0 ?
                    this.childWidgets[this.childWidgets.length - 1] : undefined;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "previousWidget", {
        /**
         * @private
         */
        get: function () {
            var widget = this;
            var index = this.indexInOwner;
            if (widget instanceof BodyWidget) {
                widget = index > 0 ? widget.page.bodyWidgets[index - 1] : undefined;
            }
            else {
                widget = index > 0 ? widget.containerWidget.childWidgets[index - 1] : undefined;
            }
            return widget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "nextWidget", {
        /**
         * @private
         */
        get: function () {
            var widget = this;
            var index = this.indexInOwner;
            if (index === -1) {
                return undefined;
            }
            if (widget instanceof BodyWidget) {
                widget = index < widget.page.bodyWidgets.length - 1 ?
                    widget.page.bodyWidgets[index + 1] : undefined;
            }
            else {
                widget = index < widget.containerWidget.childWidgets.length - 1 ?
                    widget.containerWidget.childWidgets[index + 1] : undefined;
            }
            return widget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "previousRenderedWidget", {
        /**
         * @private
         */
        get: function () {
            var widget = this;
            var index = this.indexInOwner;
            if (index < 0) {
                return undefined;
            }
            if (widget instanceof BodyWidget) {
                if (index > 0) {
                    widget = widget.page.bodyWidgets[index - 1];
                }
                else {
                    var page = widget.page.previousPage;
                    widget = page && page.bodyWidgets.length > 0 ? page.bodyWidgets[page.bodyWidgets.length - 1] : undefined;
                }
            }
            else {
                if (index > 0) {
                    widget = widget.containerWidget.childWidgets[index - 1];
                }
                else {
                    var previousContainer = undefined;
                    if (widget.containerWidget instanceof TableCellWidget) {
                        previousContainer = widget.containerWidget.getPreviousSplitWidget();
                    }
                    else if (!(widget.containerWidget instanceof TableRowWidget
                        || widget.containerWidget instanceof HeaderFooterWidget)) {
                        // Since cells are lay outed left to right, we should not navigate to previous row.
                        previousContainer = widget.containerWidget.previousRenderedWidget;
                    }
                    while (previousContainer && previousContainer.childWidgets.length === 0) {
                        previousContainer = previousContainer.previousRenderedWidget;
                        if (isNullOrUndefined(previousContainer)) {
                            break;
                        }
                    }
                    widget = previousContainer && previousContainer.constructor === widget.containerWidget.constructor ?
                        previousContainer.lastChild : undefined;
                }
            }
            return widget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "nextRenderedWidget", {
        /**
         * @private
         */
        get: function () {
            var widget = this;
            var index = this.indexInOwner;
            if (index < 0) {
                return undefined;
            }
            if (widget instanceof BodyWidget) {
                if (index < widget.page.bodyWidgets.length - 1) {
                    widget = widget.page.bodyWidgets[index + 1];
                }
                else if (widget.page.allowNextPageRendering) {
                    var page = widget.page.nextPage;
                    widget = page && page.bodyWidgets.length > 0 ? page.bodyWidgets[0] : undefined;
                }
                else {
                    widget = undefined;
                }
            }
            else {
                if (index < widget.containerWidget.childWidgets.length - 1) {
                    widget = widget.containerWidget.childWidgets[index + 1];
                }
                else {
                    var nextContainer = undefined;
                    if (widget.containerWidget instanceof TableCellWidget) {
                        nextContainer = widget.containerWidget.getNextSplitWidget();
                    }
                    else if (!(widget.containerWidget instanceof TableRowWidget
                        || widget.containerWidget instanceof HeaderFooterWidget)) {
                        // Since cells are lay outed left to right, we should not navigate to next row.
                        nextContainer = widget.containerWidget.nextRenderedWidget;
                    }
                    while (nextContainer && nextContainer.childWidgets.length === 0 && !(nextContainer instanceof TableCellWidget)) {
                        nextContainer = nextContainer.nextRenderedWidget;
                        if (isNullOrUndefined(nextContainer)) {
                            break;
                        }
                    }
                    widget = nextContainer && nextContainer.constructor === widget.containerWidget.constructor ?
                        nextContainer.firstChild : undefined;
                }
            }
            return widget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "previousSplitWidget", {
        /**
         * @private
         */
        get: function () {
            var widget = this;
            if (widget instanceof TableCellWidget) {
                return widget.getPreviousSplitWidget();
            }
            else {
                var previous = widget.previousRenderedWidget;
                if (widget instanceof BodyWidget && previous instanceof BodyWidget && widget.equals(previous)) {
                    return previous;
                }
                else if (previous instanceof BlockWidget && widget.index === previous.index && widget.equals(previous)) {
                    return previous;
                }
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "nextSplitWidget", {
        /**
         * @private
         */
        get: function () {
            var widget = this;
            if (widget instanceof TableCellWidget) {
                return widget.getNextSplitWidget();
            }
            else {
                var next = widget.nextRenderedWidget;
                if (widget instanceof BodyWidget && next instanceof BodyWidget && widget.equals(next)) {
                    return next;
                }
                else if (next instanceof BlockWidget && widget.index === next.index && widget.equals(next)) {
                    return next;
                }
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    Widget.prototype.getPreviousSplitWidgets = function () {
        var widgets = [];
        var widget = this.previousSplitWidget;
        while (widget) {
            widgets.unshift(widget);
            widget = widget.previousSplitWidget;
        }
        return widgets;
    };
    /**
     * @private
     */
    Widget.prototype.getSplitWidgets = function () {
        var widgets = this.getPreviousSplitWidgets();
        var widget = this;
        while (widget) {
            widgets.push(widget);
            widget = widget.nextSplitWidget;
        }
        return widgets;
    };
    /**
     * @private
     */
    Widget.prototype.combineWidget = function (viewer) {
        var root = this;
        var widgets = this.getSplitWidgets();
        if (widgets.length > 1) {
            root = widgets.shift();
            while (widgets.length > 0) {
                var splitWidget = widgets.shift();
                root.combine(splitWidget, viewer);
            }
        }
        if (root instanceof TableWidget) {
            root.combineRows(viewer);
        }
        return root;
    };
    Widget.prototype.combine = function (widget, viewer) {
        if (widget.childWidgets.length > 0) {
            var lastChild = this.lastChild;
            if (lastChild instanceof TableWidget) {
                lastChild.combineWidget(viewer);
            }
            else {
                var firstChild = widget.firstChild;
                if (!(widget instanceof TableWidget) && lastChild instanceof Widget && firstChild instanceof Widget &&
                    lastChild.index === firstChild.index) {
                    lastChild.combine(widget.childWidgets.shift(), viewer);
                }
            }
            this.addWidgets(widget.childWidgets);
            widget.childWidgets = [];
        }
        widget.destroyInternal(viewer);
    };
    /**
     * @private
     */
    Widget.prototype.addWidgets = function (childWidgets) {
        while (childWidgets.length > 0) {
            var widget = childWidgets.shift();
            if (widget instanceof LineWidget && this instanceof ParagraphWidget) {
                widget.paragraph = this;
                this.height += widget.height;
            }
            else if (widget instanceof Widget) {
                var lastChild = this.lastChild;
                widget.containerWidget = this;
                widget.y = lastChild instanceof Widget ? lastChild.y + lastChild.height : this.y;
                this.height += widget.height;
            }
            this.childWidgets.push(widget);
        }
    };
    /**
     * @private
     */
    Widget.prototype.removeChild = function (index) {
        if (index > -1 && index < this.childWidgets.length) {
            this.childWidgets.splice(index, 1);
        }
    };
    /**
     * @private
     */
    Widget.prototype.destroy = function () {
        if (this.childWidgets) {
            while (this.childWidgets.length > 0) {
                var child = this.childWidgets.pop();
                if (child instanceof LineWidget || child instanceof Widget) {
                    child.destroy();
                }
            }
        }
        this.childWidgets = undefined;
        if (this.containerWidget) {
            this.containerWidget.removeChild(this.indexInOwner);
        }
        this.containerWidget = undefined;
        // if (this.margin) {
        //     this.margin.destroy();
        // }
        this.margin = undefined;
        this.x = undefined;
        this.y = undefined;
        this.width = undefined;
        this.height = undefined;
        this.index = undefined;
    };
    return Widget;
}());
/**
 * @private
 */
var BlockContainer = /** @__PURE__ @class */ (function (_super) {
    __extends$1(BlockContainer, _super);
    function BlockContainer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * @private
         */
        _this.sectionFormatIn = undefined;
        return _this;
    }
    Object.defineProperty(BlockContainer.prototype, "sectionFormat", {
        /**
         * @private
         */
        get: function () {
            var container = this;
            if (container instanceof BodyWidget) {
                return container.sectionFormatIn;
            }
            else if (container.page) {
                return container.page.bodyWidgets[0].sectionFormat;
            }
            return undefined;
        },
        /**
         * @private
         */
        set: function (value) {
            if (this instanceof BodyWidget) {
                this.sectionFormatIn = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlockContainer.prototype, "sectionIndex", {
        /**
         * @private
         */
        get: function () {
            var container = this;
            var index = 0;
            if (container instanceof BodyWidget) {
                index = container.index;
            }
            else if (container.page) {
                index = container.page.bodyWidgets[0].index;
            }
            return index;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    BlockContainer.prototype.getHierarchicalIndex = function (hierarchicalIndex) {
        var viewer = undefined;
        var node = this;
        if (node instanceof BodyWidget) {
            hierarchicalIndex = node.index + ';' + hierarchicalIndex;
        }
        else {
            if (node.headerFooterType.indexOf('Header') !== -1) {
                hierarchicalIndex = 'H' + ';' + hierarchicalIndex;
            }
            else {
                hierarchicalIndex = 'F' + ';' + hierarchicalIndex;
            }
        }
        if (!isNullOrUndefined(node.page)) {
            viewer = this.page.viewer;
            var pageIndex = viewer.pages.indexOf(this.page);
            return pageIndex + ';' + hierarchicalIndex;
        }
        return hierarchicalIndex;
    };
    return BlockContainer;
}(Widget));
/**
 * @private
 */
var BodyWidget = /** @__PURE__ @class */ (function (_super) {
    __extends$1(BodyWidget, _super);
    /**
     * Initialize the constructor of BodyWidget
     */
    function BodyWidget() {
        return _super.call(this) || this;
    }
    /**
     * @private
     */
    BodyWidget.prototype.equals = function (widget) {
        return widget instanceof BodyWidget && widget.sectionFormat === this.sectionFormat;
    };
    /**
     * @private
     */
    BodyWidget.prototype.getHierarchicalIndex = function (hierarchicalIndex) {
        var viewer = undefined;
        var node = this;
        hierarchicalIndex = node.index + ';' + hierarchicalIndex;
        if (!isNullOrUndefined(node.page)) {
            viewer = this.page.viewer;
            var pageIndex = viewer.pages.indexOf(this.page);
            return pageIndex + ';' + hierarchicalIndex;
        }
        return hierarchicalIndex;
    };
    /**
     * @private
     */
    BodyWidget.prototype.getTableCellWidget = function (touchPoint) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            if (this.childWidgets[i].y <= touchPoint.y
                && (this.childWidgets[i].y + this.childWidgets[i].height) >= touchPoint.y) {
                return this.childWidgets[i].getTableCellWidget(touchPoint);
            }
        }
        var tableCellWidget = undefined;
        if (this.childWidgets.length > 0) {
            if (this.childWidgets[0].y <= touchPoint.y) {
                tableCellWidget = this.childWidgets[this.childWidgets.length - 1].getTableCellWidget(touchPoint);
            }
            else {
                tableCellWidget = this.childWidgets[0].getTableCellWidget(touchPoint);
            }
        }
        return tableCellWidget;
    };
    /**
     * @private
     */
    BodyWidget.prototype.destroyInternal = function (viewer) {
        var height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (var n = 0; n < this.childWidgets.length; n++) {
                var chilgWidget = this.childWidgets[n];
                if (chilgWidget instanceof ParagraphWidget) {
                    chilgWidget.destroyInternal(viewer);
                }
                else {
                    chilgWidget.destroyInternal(viewer);
                }
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                n--;
            }
            this.childWidgets = undefined;
        }
        // if (this instanceof HeaderFooterWidget && ((this as HeaderFooterWidget).currentNode ))) {
        //     if (((this as HeaderFooterWidget).currentNode as WHeaderFooter).layoutedWidgets )) {
        //         let index: number = ((this as HeaderFooterWidget).currentNode as WHeaderFooter).layoutedWidgets.indexOf(this);
        //         ((this as HeaderFooterWidget).currentNode as WHeaderFooter).layoutedWidgets.splice(index, 1);
        //     }
        //     this.currentNode = undefined;
        /* tslint:disable: one-line */
        if (!isNullOrUndefined(this.page)) {
            var index = this.indexInOwner;
            if (this.indexInOwner > -1) {
                this.page.bodyWidgets.splice(index, 1);
                if (this.page.bodyWidgets.length === 0) {
                    this.page.destroy();
                    // }
                }
                else if ((this instanceof HeaderFooterWidget)
                    && this.page.headerWidget === this) {
                    this.page.headerWidget = undefined;
                }
                else if ((this instanceof HeaderFooterWidget)
                    && this.page.footerWidget === this) {
                    this.page.footerWidget = undefined;
                }
                this.page = undefined;
            }
        }
        this.destroy();
    };
    /**
     * @private
     */
    BodyWidget.prototype.destroy = function () {
        // if (this.sectionFormat) {
        //     this.sectionFormat.destroy();
        // }
        this.sectionFormat = undefined;
        this.page = undefined;
        _super.prototype.destroy.call(this);
    };
    return BodyWidget;
}(BlockContainer));
/**
 * @private
 */
var HeaderFooterWidget = /** @__PURE__ @class */ (function (_super) {
    __extends$1(HeaderFooterWidget, _super);
    function HeaderFooterWidget(type) {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.isEmpty = false;
        _this.headerFooterType = type;
        return _this;
    }
    /**
     * @private
     */
    HeaderFooterWidget.prototype.getTableCellWidget = function (point) {
        return undefined;
    };
    /**
     * @private
     */
    HeaderFooterWidget.prototype.equals = function (widget) {
        // Todo: Need to work
        return widget instanceof HeaderFooterWidget
            && widget.containerWidget === this.containerWidget;
    };
    /**
     * @private
     */
    HeaderFooterWidget.prototype.clone = function () {
        var headerFooter = new HeaderFooterWidget(this.headerFooterType);
        for (var i = 0; i < this.childWidgets.length; i++) {
            var block = this.childWidgets[i].clone();
            headerFooter.childWidgets.push(block);
            block.index = i;
            block.containerWidget = headerFooter;
        }
        headerFooter.isEmpty = this.isEmpty;
        headerFooter.x = this.x;
        headerFooter.y = this.y;
        headerFooter.height = 0;
        headerFooter.width = 0;
        return headerFooter;
    };
    /**
     * @private
     */
    HeaderFooterWidget.prototype.destroyInternal = function (viewer) {
        this.page = undefined;
        _super.prototype.destroy.call(this);
    };
    return HeaderFooterWidget;
}(BlockContainer));
/**
 * @private
 */
var BlockWidget = /** @__PURE__ @class */ (function (_super) {
    __extends$1(BlockWidget, _super);
    function BlockWidget() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BlockWidget.prototype, "bodyWidget", {
        /**
         * @private
         */
        get: function () {
            var widget = this;
            while (widget.containerWidget) {
                if (widget.containerWidget instanceof BlockContainer) {
                    return widget.containerWidget;
                }
                widget = widget.containerWidget;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlockWidget.prototype, "leftIndent", {
        /**
         * @private
         */
        get: function () {
            var blockAdv = this;
            if (blockAdv instanceof ParagraphWidget && blockAdv.paragraphFormat instanceof WParagraphFormat) {
                return blockAdv.paragraphFormat.leftIndent;
            }
            else if (blockAdv instanceof TableWidget && blockAdv.tableFormat instanceof WTableFormat) {
                return blockAdv.tableFormat.leftIndent;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlockWidget.prototype, "rightIndent", {
        /**
         * @private
         */
        get: function () {
            var blockAdv = this;
            if (blockAdv instanceof ParagraphWidget && blockAdv.paragraphFormat instanceof WParagraphFormat) {
                return blockAdv.paragraphFormat.rightIndent;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlockWidget.prototype, "isInsideTable", {
        /**
         * @private
         */
        get: function () {
            return this.containerWidget instanceof TableCellWidget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlockWidget.prototype, "isInHeaderFooter", {
        /**
         * @private
         */
        get: function () {
            return this.bodyWidget instanceof HeaderFooterWidget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlockWidget.prototype, "associatedCell", {
        /**
         * @private
         */
        get: function () {
            if (this.containerWidget instanceof TableCellWidget) {
                return this.containerWidget;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Check whether the paragraph contains only page break.
     * @private
     */
    BlockWidget.prototype.isPageBreak = function () {
        var isPageBreak = false;
        if (this instanceof ParagraphWidget) {
            var paragraph = this;
            if (paragraph != null && paragraph.childWidgets.length === 1 &&
                paragraph.firstChild.children.length === 1) {
                var pageBreak = paragraph.firstChild.children[0];
                isPageBreak = pageBreak.isPageBreak;
            }
        }
        return isPageBreak;
    };
    /**
     * @private
     */
    BlockWidget.prototype.getHierarchicalIndex = function (hierarchicalIndex) {
        var node = this;
        hierarchicalIndex = node.containerWidget.childWidgets.indexOf(node) + ';' + hierarchicalIndex;
        if (!isNullOrUndefined(node.containerWidget)) {
            if (node.containerWidget instanceof BlockWidget) {
                return node.containerWidget.getHierarchicalIndex(hierarchicalIndex);
            }
            else if (node.containerWidget instanceof BlockContainer) {
                hierarchicalIndex = node.containerWidget.getHierarchicalIndex(hierarchicalIndex);
            }
        }
        return hierarchicalIndex;
    };
    /**
     * @private
     */
    BlockWidget.prototype.getIndex = function () {
        if (this instanceof ParagraphWidget || this instanceof TableWidget) {
            return this.containerWidget.childWidgets.indexOf(this);
        }
        else if (this instanceof TableRowWidget) {
            return this.ownerTable.childWidgets.indexOf(this);
        }
        else if (this instanceof TableCellWidget) {
            return this.ownerRow.childWidgets.indexOf(this);
        }
        return 0;
    };
    /**
     * @private
     */
    BlockWidget.prototype.getContainerWidth = function () {
        if (this.isInsideTable) {
            return this.associatedCell.getCellWidth();
        }
        else {
            var bodyWidget = this.bodyWidget;
            var sectionFormat = bodyWidget.sectionFormat;
            return sectionFormat.pageWidth - (sectionFormat.leftMargin + sectionFormat.rightMargin);
        }
    };
    Object.defineProperty(BlockWidget.prototype, "bidi", {
        /**
         * @private
         */
        get: function () {
            if (this instanceof ParagraphWidget && this.paragraphFormat instanceof WParagraphFormat) {
                return this.paragraphFormat.bidi;
            }
            if (this instanceof TableWidget && this.tableFormat instanceof WTableFormat) {
                return this.tableFormat.bidi;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    return BlockWidget;
}(Widget));
/**
 * @private
 */
var ParagraphWidget = /** @__PURE__ @class */ (function (_super) {
    __extends$1(ParagraphWidget, _super);
    /**
     * Initialize the constructor of ParagraphWidget
     */
    function ParagraphWidget() {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.isChangeDetected = false;
        _this.paragraphFormat = new WParagraphFormat(_this);
        _this.characterFormat = new WCharacterFormat(_this);
        return _this;
    }
    Object.defineProperty(ParagraphWidget.prototype, "isEndsWithPageBreak", {
        /**
         * @private
         */
        get: function () {
            if (this.childWidgets.length > 0) {
                return this.lastChild.isEndsWithPageBreak;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ParagraphWidget.prototype.equals = function (widget) {
        return widget instanceof ParagraphWidget && widget.paragraphFormat === this.paragraphFormat;
    };
    /**
     * @private
     */
    ParagraphWidget.prototype.isEmpty = function () {
        if (isNullOrUndefined(this.childWidgets) || this.childWidgets.length === 0) {
            return true;
        }
        for (var j = 0; j < this.childWidgets.length; j++) {
            var inlineElement = this.childWidgets[j];
            for (var i = 0; i < inlineElement.children.length; i++) {
                var inline = inlineElement.children[i];
                if (inline.length === 0) {
                    continue;
                }
                if (inline instanceof TextElementBox || inline instanceof ImageElementBox || inline instanceof BookmarkElementBox
                    || inline instanceof EditRangeEndElementBox || inline instanceof EditRangeStartElementBox
                    || inline instanceof ChartElementBox
                    || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * @private
     */
    ParagraphWidget.prototype.getInline = function (offset, indexInInline) {
        var inline = undefined;
        var count = 0;
        var isStarted = false;
        var splittedWidget = this.getSplitWidgets();
        for (var k = 0; k < splittedWidget.length; k++) {
            var widget = splittedWidget[k];
            for (var j = 0; j < widget.childWidgets.length; j++) {
                var line = widget.childWidgets[j];
                for (var i = 0; i < line.children.length; i++) {
                    inline = line.children[i];
                    if (inline instanceof ListTextElementBox) {
                        continue;
                    }
                    if (!isStarted && (inline instanceof TextElementBox || inline instanceof ImageElementBox
                        || inline instanceof BookmarkElementBox || inline instanceof FieldElementBox
                        && HelperMethods.isLinkedFieldCharacter(inline))
                        || inline instanceof ChartElementBox) {
                        isStarted = true;
                    }
                    if (isStarted && offset <= count + inline.length) {
                        indexInInline = (offset - count);
                        return { 'element': inline, 'index': indexInInline };
                    }
                    count += inline.length;
                }
            }
        }
        if (offset > count) {
            indexInInline = isNullOrUndefined(inline) ? offset : inline.length;
        }
        return { 'element': inline, 'index': indexInInline };
    };
    /**
     * @private
     */
    ParagraphWidget.prototype.getLength = function () {
        var length = 0;
        for (var j = 0; j < this.childWidgets.length; j++) {
            var line = this.childWidgets[j];
            for (var i = 0; i < line.children.length; i++) {
                var element = line.children[i];
                if (element instanceof ListTextElementBox) {
                    continue;
                }
                length += element.length;
            }
        }
        return length;
    };
    /**
     * @private
     */
    ParagraphWidget.prototype.getTableCellWidget = function (point) {
        return undefined;
    };
    /**
     * @private
     */
    // tslint:disable-next-line:max-func-body-length
    ParagraphWidget.prototype.getMinimumAndMaximumWordWidth = function (minimumWordWidth, maximumWordWidth) {
        minimumWordWidth = HelperMethods.convertPointToPixel(minimumWordWidth);
        maximumWordWidth = HelperMethods.convertPointToPixel(maximumWordWidth);
        if (this.childWidgets.length > 0) {
            var element = this.childWidgets[0].children[0];
            var text = '';
            var elements = new Dictionary();
            var imageWidths = [];
            // tslint:disable-next-line:no-constant-condition
            do {
                if (element instanceof TextElementBox && element.text !== '') {
                    elements.add(element, text.length);
                    text += (element.text);
                }
                else if (element instanceof FieldElementBox && element.fieldType === 0) {
                    var fieldBegin = element;
                    // tslint:disable-next-line:max-line-length
                    if (!isNullOrUndefined(fieldBegin.fieldEnd)) {
                        element = isNullOrUndefined(fieldBegin.fieldSeparator) ? fieldBegin.fieldEnd : fieldBegin.fieldSeparator;
                    }
                }
                else if (element instanceof ImageElementBox) {
                    imageWidths.push(element.width);
                }
                if (isNullOrUndefined(element) || isNullOrUndefined(element.nextNode)) {
                    break;
                }
                element = element.nextNode;
            } while (true);
            var pattern = new RegExp('\\b\\w+\\b', 'g');
            var matches = [];
            var matchInfo = void 0;
            //tslint:disable no-conditional-assignment
            while (!isNullOrUndefined(matchInfo = pattern.exec(text))) {
                matches.push(matchInfo);
            }
            for (var i = 0; i < matches.length; i++) {
                var match = matches[i];
                var width = 0;
                text = '';
                var matchedValue = '';
                var wordStartIndex = 0;
                var wordEndIndex = match.index;
                var index = match.index;
                for (var j = 0; j < elements.keys.length; j++) {
                    var span = elements.keys[j];
                    var startIndex = elements.get(span);
                    var spanLength = span.length;
                    if (index <= startIndex + spanLength) {
                        wordStartIndex = index - startIndex;
                        if (match.index + match[0].length <= startIndex + spanLength) {
                            wordEndIndex = (match.index + match[0].length) - (startIndex + wordStartIndex);
                        }
                        else {
                            wordEndIndex = spanLength - wordStartIndex;
                            index += wordEndIndex;
                        }
                        text = span.text.substring(wordStartIndex, wordStartIndex + wordEndIndex);
                        matchedValue = matchedValue + text;
                    }
                    if (text !== '') {
                        width += this.bodyWidget.page.viewer.textHelper.getWidth(text, span.characterFormat);
                    }
                    if (matchedValue === match[0]) {
                        break;
                    }
                }
                if (width !== 0) {
                    if (minimumWordWidth === 0 || width > minimumWordWidth) {
                        minimumWordWidth = width;
                    }
                }
            }
            // Check the image widths present in the paragraph. Consider the maximum image width as minimum word width.
            var imageWidth = 0;
            if (imageWidths.length > 0) {
                imageWidth = Math.max.apply(null, imageWidths);
            }
            if (minimumWordWidth === 0 || imageWidth > minimumWordWidth) {
                minimumWordWidth = imageWidth;
            }
            var maximum = this.measureParagraph();
            if (maximumWordWidth === 0 || maximum > maximumWordWidth) {
                maximumWordWidth = maximum;
            }
        }
        return {
            'maximumWordWidth': HelperMethods.convertPixelToPoint(maximumWordWidth),
            'minimumWordWidth': HelperMethods.convertPixelToPoint(minimumWordWidth)
        };
    };
    ParagraphWidget.prototype.measureParagraph = function () {
        var width = 0;
        var element = this.childWidgets[0].children[0];
        // tslint:disable-next-line:no-constant-condition
        do {
            if (element instanceof TextElementBox && element.text !== '') {
                width += this.bodyWidget.page.viewer.textHelper.getWidth(element.text, element.characterFormat);
            }
            else if (element instanceof FieldElementBox && element.fieldType === 0) {
                var fieldBegin = element;
                if (fieldBegin.fieldEnd != null) {
                    element = isNullOrUndefined(fieldBegin.fieldSeparator) ? fieldBegin.fieldEnd : fieldBegin.fieldSeparator;
                }
            }
            else if (element instanceof ImageElementBox) {
                width += element.width;
            }
            if (isNullOrUndefined(element) || isNullOrUndefined(element.nextNode)) {
                break;
            }
            element = element.nextNode;
        } while (true);
        // Considered the left and right indent.
        if (this.leftIndent > 0) {
            width += this.leftIndent;
        }
        if (this.rightIndent > 0) {
            width += this.rightIndent;
        }
        return width;
    };
    /**
     * @private
     */
    ParagraphWidget.prototype.clone = function () {
        var paragraph = new ParagraphWidget();
        paragraph.paragraphFormat.copyFormat(this.paragraphFormat);
        paragraph.characterFormat.copyFormat(this.characterFormat);
        for (var i = 0; i < this.childWidgets.length; i++) {
            var line = this.childWidgets[i];
            var cloneLine = line.clone();
            paragraph.childWidgets.push(cloneLine);
            cloneLine.paragraph = paragraph;
        }
        paragraph.x = this.x;
        paragraph.y = this.y;
        paragraph.height = this.height;
        paragraph.width = this.width;
        return paragraph;
    };
    /**
     * @private
     */
    ParagraphWidget.prototype.destroyInternal = function (viewer) {
        var height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (var i = 0; i < this.childWidgets.length; i++) {
                var widget = this.childWidgets[i];
                widget.destroy();
                if (this.childWidgets.length === 1 && isNullOrUndefined(this.childWidgets[0].children)) {
                    this.childWidgets = undefined;
                }
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                i--;
            }
            this.childWidgets = undefined;
        }
        if (!isNullOrUndefined(this.containerWidget) && !isNullOrUndefined(this.containerWidget.childWidgets)
            && this.containerWidget.childWidgets.indexOf(this) !== -1) {
            this.containerWidget.childWidgets.splice(this.containerWidget.childWidgets.indexOf(this), 1);
            this.containerWidget.height -= height;
            // if ((isNullOrUndefined(this.containerWidget.childWidgets) || this.containerWidget.childWidgets.length === 0)
            //     && this.containerWidget instanceof BodyWidget) {
            //     // (this.containerWidget as BodyWidget).destroyInternal(viewer);
            // }
            this.containerWidget = undefined;
        }
        this.destroy();
    };
    /**
     * @private
     */
    ParagraphWidget.prototype.destroy = function () {
        // if (this.paragraphFormat) {
        //     this.paragraphFormat.destroy();
        // }
        this.paragraphFormat = undefined;
        // if (this.characterFormat) {
        //     this.characterFormat.destroy();
        // }
        this.characterFormat = undefined;
        _super.prototype.destroy.call(this);
    };
    return ParagraphWidget;
}(BlockWidget));
/**
 * @private
 */
var TableWidget = /** @__PURE__ @class */ (function (_super) {
    __extends$1(TableWidget, _super);
    function TableWidget() {
        var _this = _super.call(this) || this;
        _this.flags = 0;
        /**
         * @private
         */
        _this.leftMargin = 0;
        /**
         * @private
         */
        _this.topMargin = 0;
        /**
         * @private
         */
        _this.rightMargin = 0;
        /**
         * @private
         */
        _this.bottomMargin = 0;
        /**
         * @private
         */
        _this.isDefaultFormatUpdated = false;
        _this.margin = new Margin(_this.leftMargin, _this.topMargin, _this.rightMargin, _this.bottomMargin);
        _this.leftBorderWidth = 0;
        _this.rightBorderWidth = 0;
        _this.topBorderWidth = 0;
        _this.bottomBorderWidth = 0;
        _this.tableFormat = new WTableFormat(_this);
        _this.tableHolder = new WTableHolder();
        _this.spannedRowCollection = new Dictionary();
        return _this;
    }
    Object.defineProperty(TableWidget.prototype, "isGridUpdated", {
        /**
         * @private
         */
        get: function () {
            return ((this.flags & 0x4) >> 2) !== 0;
        },
        /**
         * @private
         */
        set: function (value) {
            this.flags = ((this.flags & 0xFB) | ((value ? 1 : 0) << 2));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableWidget.prototype, "continueHeader", {
        /**
         * @private
         */
        get: function () {
            return ((this.flags & 0x2) >> 1) !== 0;
        },
        /**
         * @private
         */
        set: function (value) {
            this.flags = ((this.flags & 0xFD) | ((value ? 1 : 0) << 1));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableWidget.prototype, "header", {
        /**
         * @private
         */
        get: function () {
            return (this.flags & 0x1) !== 0;
        },
        /**
         * @private
         */
        set: function (value) {
            this.flags = ((this.flags & 0xFE) | (value ? 1 : 0));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableWidget.prototype, "isBidiTable", {
        get: function () {
            return ((this.flags & 0x10) >> 4) !== 0;
        },
        set: function (value) {
            this.flags = ((this.flags & 0xEF) | ((value ? 1 : 0) << 4));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    TableWidget.prototype.equals = function (widget) {
        return widget instanceof TableWidget && widget.tableFormat === this.tableFormat;
    };
    /**
     * @private
     */
    TableWidget.prototype.combineRows = function (viewer) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            if (row.childWidgets.length === 0) {
                row.destroy();
                i--;
            }
            else {
                row.combineCells(viewer);
            }
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.contains = function (tableCell) {
        if (this.equals(tableCell.ownerTable)) {
            return true;
        }
        while (tableCell.ownerTable.isInsideTable) {
            if (this.equals(tableCell.ownerTable)) {
                return true;
            }
            tableCell = tableCell.ownerTable.associatedCell;
        }
        return this.equals(tableCell.ownerTable);
    };
    /**
     * @private
     */
    TableWidget.prototype.getOwnerWidth = function (isBasedOnViewer) {
        var width = this.getContainerWidth();
        // Left and right indents should be neglected.
        width = width - this.leftIndent - this.rightIndent;
        return width >= 0 ? width : 0;
    };
    /**
     * @private
     */
    TableWidget.prototype.getTableWidth = function () {
        var width = 0;
        for (var i = 0; i < this.childWidgets.length; i++) {
            var rowWidth = 0;
            var row = this.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                rowWidth += row.childWidgets[j].cellFormat.cellWidth;
            }
            if (width < rowWidth) {
                width = rowWidth;
            }
        }
        return width;
    };
    /**
     * @private
     */
    TableWidget.prototype.getTableClientWidth = function (clientWidth) {
        var tableWidth = clientWidth;
        if (this.tableFormat.preferredWidthType === 'Point'
            && this.tableFormat.preferredWidth > 0) {
            tableWidth = this.tableFormat.preferredWidth;
        }
        else {
            if (this.tableFormat.preferredWidthType === 'Percent'
                && this.tableFormat.preferredWidth > 0) {
                tableWidth = tableWidth * this.tableFormat.preferredWidth / 100;
            }
        }
        return tableWidth;
    };
    /**
     * @private
     */
    TableWidget.prototype.getCellWidth = function (preferredWidth, preferredWidthType, containerWidth, cell) {
        var cellWidth = preferredWidth;
        if (preferredWidthType === 'Percent') {
            cellWidth = (preferredWidth * containerWidth) / 100;
        }
        else if (preferredWidthType === 'Point') {
            cellWidth = preferredWidth;
        }
        // For grid before and grid after with auto width, no need to calculate minimum preferred width.
        else if (!isNullOrUndefined(cell)) {
            cellWidth = cell.getMinimumPreferredWidth();
        }
        return cellWidth;
    };
    /**
     * @private
     */
    TableWidget.prototype.fitCellsToClientArea = function (clientWidth) {
        var tableWidth = this.getTableWidth();
        var factor = clientWidth / tableWidth;
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            row.rowFormat.gridAfterWidth *= factor;
            row.rowFormat.gridBeforeWidth *= factor;
            for (var j = 0; j < row.childWidgets.length; j++) {
                row.childWidgets[j].cellFormat.cellWidth *= factor;
            }
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.getTableCellWidget = function (point) {
        var tableCellWidget = undefined;
        for (var i = 0; i < this.childWidgets.length; i++) {
            if (this.childWidgets[i].y <= point.y
                && (this.childWidgets[i].y + this.childWidgets[i].height) >= point.y) {
                tableCellWidget = this.childWidgets[i].getTableCellWidget(point);
                break;
            }
        }
        return tableCellWidget;
    };
    /**
     * @private
     */
    //tslint:disable: max-func-body-length
    TableWidget.prototype.calculateGrid = function () {
        var tempGrid = [];
        var spannedCells = [];
        var containerWidth = this.getOwnerWidth(true);
        var tableWidth = this.getTableClientWidth(containerWidth);
        this.tableCellInfo = new Dictionary();
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            var rowCellInfo = new Dictionary();
            var rowFormat = row.rowFormat;
            var cellWidth = 0;
            var columnSpan = row.rowFormat.gridBefore;
            var currOffset = 0;
            if (tempGrid.indexOf(currOffset) < 0) {
                tempGrid.push(currOffset);
            }
            //Converts the row grid before width from point to twips point by 15 factor.
            cellWidth = this.getCellWidth(rowFormat.gridBeforeWidth, rowFormat.gridBeforeWidthType, tableWidth, null);
            currOffset += cellWidth;
            var startOffset = parseFloat(currOffset.toFixed(2));
            if (tempGrid.indexOf(startOffset) < 0) {
                tempGrid.push(startOffset);
            }
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                for (var k = 0; k < spannedCells.length; k++) {
                    if (spannedCells[k].columnIndex < columnSpan) {
                        continue;
                    }
                    var rowSpan = spannedCells[k].cellFormat.rowSpan;
                    var removeSpannedCell = true;
                    if (spannedCells[k].columnIndex > columnSpan) {
                        {
                            removeSpannedCell = false;
                            // If the cell is the last cell in the row and the row has grid after value..
                            if (j === row.childWidgets.length - 1 && row.rowFormat.gridAfter > 0) {
                                // tslint:disable-next-line:max-line-length
                                cellWidth = this.getCellWidth(spannedCells[k].cellFormat.preferredWidth, spannedCells[k].cellFormat.preferredWidthType, tableWidth, null);
                                currOffset += cellWidth;
                            }
                        }
                    }
                    else {
                        // If the table gird alone calculted then column index of the rowspanned cell will be directly taken. 
                        // If the gird calculation is done from the UI level opearations such as resizing then table holder 
                        // will have the columns at that time we can get the column index from the table holder.
                        //Converts the cell width from point to twips point by 15 factor.
                        // tslint:disable-next-line:max-line-length
                        cellWidth = this.getCellWidth(spannedCells[k].cellFormat.preferredWidth, spannedCells[k].cellFormat.preferredWidthType, tableWidth, null);
                        currOffset += cellWidth;
                        columnSpan = spannedCells[k].columnIndex + spannedCells[k].cellFormat.columnSpan;
                    }
                    if (!removeSpannedCell && j === row.childWidgets.length - 1) {
                        removeSpannedCell = true;
                    }
                    if (removeSpannedCell && i - spannedCells[k].ownerRow.rowIndex === rowSpan - 1) {
                        spannedCells.splice(k, 1);
                        k--;
                    }
                }
                // At the start of each row, we will process the row spanned cells to get the start column index.
                // To calculate grid properly, we need the items in the spanned cells collection in the order of their column index
                if (cell.cellFormat.rowSpan > 1) {
                    if (spannedCells.length === 0 || spannedCells[spannedCells.length - 1].columnIndex <= columnSpan) {
                        spannedCells.push(cell);
                    }
                    else {
                        for (var m = spannedCells.length; m > 0; m--) {
                            if (spannedCells[m - 1].columnIndex > columnSpan) {
                                spannedCells.splice(m - 1, 0, cell);
                            }
                        }
                    }
                }
                // Add start offset of each cell based on its index
                if (!rowCellInfo.containsKey(cell.cellIndex)) {
                    rowCellInfo.add(cell.cellIndex, parseFloat((currOffset - startOffset).toFixed(2)));
                }
                columnSpan += cell.cellFormat.columnSpan;
                //Converts the cell width from pixel to twips point by 15 factor.
                cellWidth = this.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, tableWidth, null);
                currOffset += cellWidth;
                var offset = parseFloat(currOffset.toFixed(2));
                if (tempGrid.indexOf(offset) < 0) {
                    tempGrid.push(offset);
                }
                if (j === row.childWidgets.length - 1 && rowFormat.gridAfter > 0) {
                    cellWidth = this.getCellWidth(rowFormat.gridAfterWidth, 'Point', tableWidth, null);
                    currOffset += cellWidth;
                    if (tempGrid.indexOf(parseFloat(currOffset.toFixed(2))) < 0) {
                        tempGrid.push(parseFloat(currOffset.toFixed(2)));
                    }
                    columnSpan += rowFormat.gridAfter;
                }
                // Add rowindex and its cells info for each row
                if (!this.tableCellInfo.containsKey(row.rowIndex)) {
                    this.tableCellInfo.add(row.rowIndex, rowCellInfo);
                }
            }
        }
        tempGrid.sort(function (a, b) { return a - b; });
        if (this.tableHolder.columns.length > 0 && tempGrid.length - 1 !== this.tableHolder.columns.length) {
            this.updateColumnSpans(tempGrid, tableWidth);
        }
        this.tableCellInfo.clear();
        this.tableCellInfo = undefined;
    };
    TableWidget.prototype.updateColumnSpans = function (tempGrid, containerWidth) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            if (row.rowFormat.gridBeforeWidth >= 0) {
                row.rowFormat.gridBefore = row.getGridCount(tempGrid, undefined, -1, containerWidth);
            }
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                var columnSpan = row.getGridCount(tempGrid, cell, cell.getIndex(), containerWidth);
                if (columnSpan > 0 && cell.cellFormat.columnSpan !== columnSpan) {
                    cell.cellFormat.columnSpan = columnSpan;
                }
            }
            if (row.rowFormat.gridAfterWidth >= 0) {
                row.rowFormat.gridAfter = row.getGridCount(tempGrid, undefined, row.childWidgets.length, containerWidth);
            }
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.getMinimumAndMaximumWordWidth = function (minimumWordWidth, maximumWordWidth) {
        this.checkTableColumns();
        var tableWidth = this.tableHolder.getTotalWidth(0);
        if (tableWidth > minimumWordWidth) {
            minimumWordWidth = tableWidth;
        }
        if (tableWidth > maximumWordWidth) {
            maximumWordWidth = tableWidth;
        }
        return { 'minimumWordWidth': minimumWordWidth, 'maximumWordWidth': maximumWordWidth };
    };
    /**
     * @private
     */
    TableWidget.prototype.checkTableColumns = function () {
        if (this.isGridUpdated) {
            return;
        }
        var isAutoFit = this.isAutoFit();
        if (isAutoFit || this.tableHolder.columns.length === 0) {
            this.buildTableColumns();
        }
        this.isGridUpdated = true;
    };
    /**
     * @private
     */
    TableWidget.prototype.isAutoFit = function () {
        var bodyWidget = this.bodyWidget;
        if (!isNullOrUndefined(bodyWidget) && !isNullOrUndefined(bodyWidget.page)) {
            return bodyWidget.page.viewer.layout.getParentTable(this).tableFormat.allowAutoFit;
        }
        return false;
    };
    /**
     * @private
     */
    TableWidget.prototype.buildTableColumns = function () {
        if (this.isGridUpdated) {
            return;
        }
        // Clear existing columns in order to start creating columns freshly.
        this.tableHolder.resetColumns();
        var containerWidth = 0;
        var tableWidth = 0;
        var rowSpannedCells = [];
        var isAutoWidth = this.tableFormat.preferredWidthType === 'Auto';
        var isAutoFit = this.tableFormat.allowAutoFit;
        // For continuous layout, window width should be considered. 
        // If preferred width exceeds this limit, it can take upto maximum of 2112 pixels (1584 points will be assigned by Microsoft Word).
        containerWidth = this.getOwnerWidth(true);
        var isZeroWidth = (isAutoWidth && this.tableFormat.preferredWidth === 0 && !isAutoFit);
        tableWidth = this.getTableClientWidth(containerWidth);
        if (isZeroWidth && !this.isDefaultFormatUpdated) {
            this.splitWidthToTableCells(tableWidth, isZeroWidth);
        }
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            var rowFormat = row.rowFormat;
            var columnSpan = 0;
            var cellWidth = 0;
            var sizeInfo = new ColumnSizeInfo();
            var offset = 0;
            if (rowFormat.gridBefore > 0) {
                cellWidth = this.getCellWidth(rowFormat.gridBeforeWidth, row.rowFormat.gridAfterWidthType, tableWidth, null);
                sizeInfo.minimumWidth = cellWidth;
                this.tableHolder.addColumns(columnSpan, columnSpan = rowFormat.gridBefore, cellWidth, sizeInfo, offset = cellWidth);
            }
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                if (rowSpannedCells.length === 0) {
                    cell.columnIndex = columnSpan;
                }
                for (var k = 0; k < rowSpannedCells.length; k++) {
                    var rowSpannedCell = rowSpannedCells[k];
                    if (rowSpannedCell.columnIndex < columnSpan) {
                        cell.columnIndex = columnSpan;
                        continue;
                    }
                    var rowSpan = 1;
                    var removeSpannedCell = true;
                    rowSpan = rowSpannedCell.cellFormat.rowSpan;
                    if (rowSpannedCell.columnIndex > columnSpan) {
                        cell.columnIndex = columnSpan;
                        removeSpannedCell = false;
                    }
                    else {
                        // tslint:disable-next-line:max-line-length
                        cellWidth = this.getCellWidth(rowSpannedCell.cellFormat.preferredWidth, rowSpannedCell.cellFormat.preferredWidthType, tableWidth, rowSpannedCell);
                        sizeInfo = rowSpannedCell.getCellSizeInfo(isAutoFit);
                        // If the table gird alone calculated then column index of the rowspanned cell will be directly taken. 
                        // tslint:disable-next-line:max-line-length
                        // If the gird calculation is done from the UI level operations such as resizing then table holder will have the columns at that time we can get the column index from the table holder.
                        // tslint:disable-next-line:max-line-length
                        if (this.tableHolder.columns.length > 0) {
                            this.tableHolder.addColumns(columnSpan, columnSpan = this.tableHolder.columns.indexOf(rowSpannedCell.ownerColumn) + rowSpannedCell.cellFormat.columnSpan, cellWidth, sizeInfo, offset += cellWidth);
                            cell.columnIndex = columnSpan;
                        }
                        else {
                            // tslint:disable-next-line:max-line-length
                            this.tableHolder.addColumns(columnSpan, columnSpan = rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan, cellWidth, sizeInfo, offset += cellWidth);
                            cell.columnIndex = columnSpan;
                        }
                    }
                    if (!removeSpannedCell && j === row.childWidgets.length - 1) {
                        removeSpannedCell = true;
                    }
                    if (removeSpannedCell && i - rowSpannedCell.ownerRow.rowIndex === rowSpan - 1) {
                        rowSpannedCells.splice(k, 1);
                        k--;
                    }
                }
                // At the start of each row, we will process the row spanned cells to get the start column index.
                // To calculate grid properly, we need the items in the spanned cells collection in the order of their column index
                if (cell.cellFormat.rowSpan > 1) {
                    if (rowSpannedCells.length === 0 || rowSpannedCells[rowSpannedCells.length - 1].columnIndex <= columnSpan) {
                        rowSpannedCells.push(cell);
                    }
                    else {
                        for (var m = rowSpannedCells.length; m > 0; m--) {
                            if (rowSpannedCells[m - 1].columnIndex > columnSpan) {
                                rowSpannedCells.splice(m - 1, 0, cell);
                            }
                        }
                    }
                }
                cellWidth = this.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, tableWidth, cell);
                sizeInfo = cell.getCellSizeInfo(isAutoFit);
                this.tableHolder.addColumns(columnSpan, columnSpan += cell.cellFormat.columnSpan, cellWidth, sizeInfo, offset += cellWidth);
                if (j === row.childWidgets.length - 1 && rowFormat.gridAfterWidth > 0) {
                    cellWidth = this.getCellWidth(rowFormat.gridAfterWidth, 'Point', tableWidth, null);
                    this.tableHolder.addColumns(columnSpan, columnSpan += rowFormat.gridAfter, cellWidth, sizeInfo, offset += cellWidth);
                }
            }
        }
        if (isZeroWidth && !this.isDefaultFormatUpdated) {
            this.isDefaultFormatUpdated = true;
        }
        this.tableHolder.validateColumnWidths();
        if (isAutoFit) {
            // Fits the column width automatically based on contents.
            this.tableHolder.autoFitColumn(containerWidth, tableWidth, isAutoWidth, this.isInsideTable);
        }
        else {
            // Fits the column width based on preferred width. i.e. Fixed layout.
            this.tableHolder.fitColumns(containerWidth, tableWidth, isAutoWidth, this.leftIndent + this.rightIndent);
        }
        //Sets the width to cells
        this.setWidthToCells(tableWidth, isAutoWidth);
    };
    /**
     * @private
     */
    TableWidget.prototype.setWidthToCells = function (tableWidth, isAutoWidth) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            var rw = this.childWidgets[i];
            var rowFormat = rw.rowFormat;
            if (rowFormat.gridBefore > 0) {
                rowFormat.beforeWidth = this.tableHolder.getCellWidth(0, rowFormat.gridBefore, tableWidth);
            }
            for (var j = 0; j < rw.childWidgets.length; j++) {
                var cell = rw.childWidgets[j];
                // tslint:disable-next-line:max-line-length
                cell.cellFormat.cellWidth = this.tableHolder.getCellWidth(cell.columnIndex, cell.cellFormat.columnSpan, tableWidth);
                //By default, if cell preferred widthType is auto , width set based on table width and type is changed to 'Point'
            }
            if (rowFormat.gridAfter > 0) {
                rowFormat.afterWidth = this.tableHolder.getCellWidth(0, rowFormat.gridAfter, tableWidth);
            }
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.updateProperties = function (updateAllowAutoFit, currentSelectedTable, autoFitBehavior) {
        if (updateAllowAutoFit) {
            this.tableFormat.allowAutoFit = autoFitBehavior !== 'FixedColumnWidth';
        }
        if (this !== currentSelectedTable) {
            currentSelectedTable.updateProperties(false, currentSelectedTable, autoFitBehavior);
            return;
        }
        if (autoFitBehavior === 'FixedColumnWidth') {
            // Clear the table widths and set the preferred width for cells.
            this.tableFormat.preferredWidth = 0;
            this.tableFormat.preferredWidthType = 'Auto';
            for (var i = 0; i < this.childWidgets.length; i++) {
                var rowWidget = this.childWidgets[i];
                for (var j = 0; j < rowWidget.childWidgets.length; j++) {
                    var cellWidget = rowWidget.childWidgets[j];
                    cellWidget.cellFormat.preferredWidthType = 'Point';
                    cellWidget.cellFormat.preferredWidth = cellWidget.cellFormat.cellWidth;
                }
            }
        }
        else if (autoFitBehavior === 'FitToWindow') {
            // Set the preferred width for table and cells in percentage.
            var tableWidth = this.tableHolder.getTotalWidth(0);
            this.tableFormat.leftIndent = 0;
            this.tableFormat.preferredWidth = 100;
            this.tableFormat.preferredWidthType = 'Percent';
            for (var i = 0; i < this.childWidgets.length; i++) {
                var row = this.childWidgets[i];
                for (var z = 0; z < row.childWidgets.length; z++) {
                    var cell = row.childWidgets[z];
                    if (cell.cellFormat.preferredWidthType !== 'Percent') {
                        cell.cellFormat.preferredWidthType = 'Percent';
                        cell.cellFormat.preferredWidth = (cell.cellFormat.cellWidth / tableWidth) * 100;
                    }
                }
            }
        }
        else {
            // Clear the preferred width for table and cells.
            this.tableFormat.preferredWidth = 0;
            this.tableFormat.preferredWidthType = 'Auto';
            for (var i = 0; i < this.childWidgets.length; i++) {
                var row = this.childWidgets[i];
                row.rowFormat.beforeWidth = 0;
                row.rowFormat.gridBefore = 0;
                row.rowFormat.gridBeforeWidth = 0;
                row.rowFormat.gridBeforeWidthType = 'Auto';
                row.rowFormat.afterWidth = 0;
                row.rowFormat.gridAfter = 0;
                row.rowFormat.gridAfterWidth = 0;
                row.rowFormat.gridAfterWidthType = 'Auto';
                for (var j = 0; j < row.childWidgets.length; j++) {
                    var cell = row.childWidgets[j];
                    cell.cellFormat.preferredWidth = 0;
                    cell.cellFormat.preferredWidthType = 'Auto';
                }
            }
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.getMaxRowWidth = function (clientWidth) {
        var width = 0;
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            var rowWidth = 0;
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                rowWidth += this.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, clientWidth, cell);
            }
            if (width < rowWidth) {
                width = rowWidth;
            }
        }
        return width;
    };
    /**
     * @private
     */
    TableWidget.prototype.updateWidth = function (dragValue) {
        var totalPreferredWidth = this.tableHolder.getTotalWidth(0);
        var ownerWidth = this.getOwnerWidth(true);
        var containerWidth = this.getTableClientWidth(ownerWidth);
        if (containerWidth <= totalPreferredWidth) {
            if (this.tableFormat.preferredWidthType === 'Auto') {
                this.tableFormat.preferredWidthType = 'Point';
            }
        }
        if (this.tableFormat.preferredWidthType !== 'Auto') {
            if (this.tableFormat.preferredWidthType === 'Point') {
                this.tableFormat.preferredWidth = this.getMaxRowWidth(containerWidth);
            }
            else { //ToDo:Need to analyze more the Percentage calculation for table width.
                var value = (totalPreferredWidth / ownerWidth) * 100;
                this.tableFormat.preferredWidth = value;
            }
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.convertPointToPercent = function (tablePreferredWidth, ownerWidth) {
        var value = 0;
        value = (tablePreferredWidth / ownerWidth) * 100;
        value = Math.round(value);
        return value < 100 ? value : 100; // The value should be lesser than or equal to 100%;
    };
    TableWidget.prototype.updateChildWidgetLeft = function (left) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            var rowWidget = this.childWidgets[i];
            rowWidget.x = left;
            rowWidget.updateChildWidgetLeft(left);
        }
    };
    /**
     * Shift the widgets for right to left aligned table.
     * @private
     */
    TableWidget.prototype.shiftWidgetsForRtlTable = function (clientArea, tableWidget) {
        var clientAreaX = tableWidget.x;
        var clientAreaRight = clientArea.right;
        var cellSpace = 0;
        if (tableWidget.tableFormat && tableWidget.tableFormat.cellSpacing > 0) {
            cellSpace = tableWidget.tableFormat.cellSpacing;
        }
        for (var i = 0; i < tableWidget.childWidgets.length; i++) {
            var rowWidget = tableWidget.childWidgets[i];
            var rowX = rowWidget.x;
            var left = clientAreaRight - (rowX - clientAreaX);
            for (var j = 0; j < rowWidget.childWidgets.length; j++) {
                var cellWidget = rowWidget.childWidgets[j];
                left = left -
                    (cellWidget.width + cellWidget.margin.left + cellWidget.margin.right - cellWidget.rightBorderWidth + cellSpace);
                cellWidget.updateWidgetLeft(left + cellWidget.margin.left);
            }
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.clone = function () {
        var table = new TableWidget();
        table.tableHolder = this.tableHolder.clone();
        table.tableFormat.copyFormat(this.tableFormat);
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i].clone();
            table.childWidgets.push(row);
            row.containerWidget = table;
            row.index = i;
        }
        table.x = this.x;
        table.y = this.y;
        table.height = this.height;
        table.width = this.width;
        table.containerWidget = this.containerWidget;
        return table;
    };
    /**
     * @private
     */
    TableWidget.getTableOf = function (node) {
        if (node instanceof WBorders) {
            var row = TableRowWidget.getRowOf(node);
            if (!isNullOrUndefined(row)) {
                return row.ownerTable;
            }
            else if (node.ownerBase instanceof WTableFormat && node.ownerBase.ownerBase instanceof TableWidget) {
                return node.ownerBase.ownerBase;
            }
            else {
                return undefined;
            }
        }
        return undefined;
    };
    /**
     * @private
     */
    TableWidget.prototype.fitChildToClientArea = function () {
        var clientWidth = this.getContainerWidth();
        if (Math.round(clientWidth) < Math.round(this.getTableWidth())) {
            this.fitCellsToClientArea(clientWidth);
        }
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                for (var k = 0; k < cell.childWidgets.length; k++) {
                    if (cell.childWidgets[k] instanceof TableWidget) {
                        cell.childWidgets[k].fitChildToClientArea();
                    }
                }
            }
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.getColumnCellsForSelection = function (startCell, endCell) {
        var cells = [];
        var start = startCell.columnIndex;
        var end = endCell.columnIndex + endCell.cellFormat.columnSpan;
        for (var i = 0; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                var columnIndex = cell.columnIndex;
                var columnSpan = cell.cellFormat.columnSpan;
                if ((columnIndex + columnSpan > start && columnIndex + columnSpan < end) || (columnIndex > start && columnIndex < end)) {
                    if (cells.indexOf(cell) < 0) {
                        cells.push(cell);
                    }
                }
                else if ((columnIndex > start && columnIndex < end && columnIndex + columnSpan < end)
                    || (columnIndex < start && columnIndex + columnSpan > end)) {
                    if (cells.indexOf(cell) < 0) {
                        cells.push(cell);
                    }
                }
                else if (columnIndex === start || columnIndex + columnSpan === end) {
                    if (cells.indexOf(cell) < 0) {
                        cells.push(cell);
                    }
                }
            }
        }
        return cells;
    };
    /**
     * Splits width equally for all the cells.
     * @param tableClientWidth
     * @private
     */
    TableWidget.prototype.splitWidthToTableCells = function (tableClientWidth, isZeroWidth) {
        for (var row = 0; row < this.childWidgets.length; row++) {
            this.childWidgets[row].splitWidthToRowCells(tableClientWidth, isZeroWidth);
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.insertTableRowsInternal = function (tableRows, startIndex) {
        for (var i = tableRows.length - 1; i >= 0; i--) {
            var row = tableRows.splice(i, 1)[0];
            row.containerWidget = this;
            this.childWidgets.splice(startIndex, 0, row);
        }
        this.updateRowIndex(startIndex);
        this.isGridUpdated = false;
        this.buildTableColumns();
        this.isGridUpdated = true;
    };
    /**
     * @private
     */
    TableWidget.prototype.updateRowIndex = function (startIndex) {
        for (var i = startIndex; i < this.childWidgets.length; i++) {
            var row = this.childWidgets[i];
            row.index = i;
            for (var j = 0; j < row.childWidgets.length; j++) {
                row.childWidgets[j].index = j;
                row.childWidgets[j].rowIndex = row.rowIndex;
            }
            startIndex++;
        }
    };
    /**
     * @private
     */
    TableWidget.prototype.getCellStartOffset = function (cell) {
        var offset = 0;
        if (cell && this.tableCellInfo) {
            if (this.tableCellInfo.containsKey(cell.ownerRow.rowIndex)) {
                var rowCellInfo = this.tableCellInfo.get(cell.ownerRow.rowIndex);
                if (rowCellInfo.containsKey(cell.cellIndex)) {
                    offset = rowCellInfo.get(cell.cellIndex);
                }
            }
        }
        return offset;
    };
    /**
     * @private
     */
    TableWidget.prototype.destroyInternal = function (viewer) {
        var height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (var j = 0; j < this.childWidgets.length; j++) {
                var widget = undefined;
                var childWidget = this.childWidgets[j];
                widget = childWidget;
                if (!isNullOrUndefined(widget)) {
                    widget.destroyInternal(viewer);
                }
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                j--;
            }
            this.childWidgets = undefined;
        }
        if (!isNullOrUndefined(this.containerWidget)) {
            if (!isNullOrUndefined(this.containerWidget.childWidgets)) {
                if (this.containerWidget.childWidgets.indexOf(this) !== -1) {
                    this.containerWidget.childWidgets.splice(this.containerWidget.childWidgets.indexOf(this), 1);
                }
                this.containerWidget.height -= height;
                // if ((isNullOrUndefined(this.containerWidget.childWidgets) || this.containerWidget.childWidgets.length === 0)
                //     && this.containerWidget instanceof BodyWidget) {
                //     // (this.containerWidget as BodyWidget).destroyInternal(viewer);
                // }
            }
            this.containerWidget = undefined;
        }
        this.destroy();
    };
    /**
     * @private
     */
    TableWidget.prototype.destroy = function () {
        // if (this.tableFormat) {
        //     this.tableFormat.destroy();
        // }
        this.tableFormat = undefined;
        if (this.spannedRowCollection) {
            this.spannedRowCollection.destroy();
        }
        this.spannedRowCollection = undefined;
        // if (this.tableHolder) {
        //     this.tableHolder.destroy();
        // }
        this.tableHolder = undefined;
        this.flags = undefined;
        this.leftMargin = undefined;
        this.topMargin = undefined;
        this.rightMargin = undefined;
        this.bottomMargin = undefined;
        this.headerHeight = undefined;
        this.description = undefined;
        this.title = undefined;
        this.isDefaultFormatUpdated = undefined;
        _super.prototype.destroy.call(this);
    };
    return TableWidget;
}(BlockWidget));
/**
 * @private
 */
var TableRowWidget = /** @__PURE__ @class */ (function (_super) {
    __extends$1(TableRowWidget, _super);
    function TableRowWidget() {
        var _this = _super.call(this) || this;
        _this.topBorderWidth = 0;
        _this.bottomBorderWidth = 0;
        _this.rowFormat = new WRowFormat(_this);
        return _this;
    }
    Object.defineProperty(TableRowWidget.prototype, "rowIndex", {
        /**
         * @private
         */
        get: function () {
            if (this.containerWidget) {
                return this.containerWidget.childWidgets.indexOf(this);
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableRowWidget.prototype, "ownerTable", {
        /**
         * @private
         */
        get: function () {
            if (this.containerWidget instanceof TableWidget) {
                return this.containerWidget;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableRowWidget.prototype, "nextRow", {
        /**
         * @private
         */
        get: function () {
            var index = this.indexInOwner;
            if (index > -1 && index < this.ownerTable.childWidgets.length - 1) {
                return this.ownerTable.childWidgets[index + 1];
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    TableRowWidget.prototype.equals = function (widget) {
        return widget instanceof TableRowWidget && widget.rowFormat === this.rowFormat;
    };
    /**
     * @private
     */
    TableRowWidget.prototype.combineCells = function (viewer) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            var cell = this.childWidgets[i];
            cell.combineWidget(viewer);
            if (cell.cellFormat.rowSpan === 1) {
                var cellHeight = cell.height + cell.margin.top + cell.margin.bottom;
                if ((this.height - this.ownerTable.tableFormat.cellSpacing) < cell.height) {
                    this.height = this.ownerTable.tableFormat.cellSpacing + cell.height;
                }
            }
        }
    };
    /**
     * @private
     */
    TableRowWidget.getRowOf = function (node) {
        if (node instanceof WBorders) {
            var cell = TableCellWidget.getCellOf(node);
            if (!isNullOrUndefined(cell)) {
                return cell.ownerRow;
            }
            else if (node.ownerBase instanceof WRowFormat && node.ownerBase.ownerBase instanceof TableRowWidget) {
                return node.ownerBase.ownerBase;
            }
            else {
                return undefined;
            }
        }
        return undefined;
    };
    /**
     * @private
     */
    TableRowWidget.prototype.getCell = function (rowIndex, cellIndex) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            var cell = this.childWidgets[i];
            if (cell.rowIndex === rowIndex && cell.index === cellIndex) {
                return cell;
            }
        }
        return undefined;
    };
    /**
     * @private
     */
    TableRowWidget.prototype.splitWidthToRowCells = function (tableClientWidth, isZeroWidth) {
        var cells = this.childWidgets;
        var cellWidth = tableClientWidth / cells.length;
        for (var cell = 0; cell < cells.length; cell++) {
            if (isZeroWidth && cells[cell].cellFormat.preferredWidth === 0) {
                cells[cell].cellFormat.preferredWidth = cellWidth;
                this.ownerTable.isDefaultFormatUpdated = false;
            }
            else if (isZeroWidth) {
                this.ownerTable.isDefaultFormatUpdated = true;
                break;
            }
            else {
                cells[cell].cellFormat.preferredWidth = cellWidth;
            }
        }
    };
    /**
     * @private
     */
    TableRowWidget.prototype.getGridCount = function (tableGrid, cell, index, containerWidth) {
        var prevOffset = 0;
        var width = 0;
        var ownerTable = this.ownerTable;
        var rowFormat = this.rowFormat;
        if (index === -1) {
            width = ownerTable.getCellWidth(rowFormat.gridBeforeWidth, rowFormat.gridBeforeWidthType, containerWidth, null);
        }
        else {
            prevOffset += ownerTable.getCellWidth(rowFormat.gridBeforeWidth, rowFormat.gridBeforeWidthType, containerWidth, null);
            if (index >= 0) {
                prevOffset += ownerTable.getCellStartOffset(cell);
            }
            if (index < this.childWidgets.length) {
                width = ownerTable.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, containerWidth, null);
            }
            else {
                width = ownerTable.getCellWidth(rowFormat.gridAfterWidth, rowFormat.gridAfterWidthType, containerWidth, null);
            }
        }
        var gridStartIndex = this.getOffsetIndex(tableGrid, prevOffset);
        var gridEndIndex = this.getOffsetIndex(tableGrid, prevOffset + width);
        return gridEndIndex - gridStartIndex;
    };
    TableRowWidget.prototype.getOffsetIndex = function (tableGrid, offset) {
        offset = parseFloat(offset.toFixed(2));
        var index = 0;
        if (tableGrid.indexOf(offset) >= 0) {
            index = tableGrid.indexOf(offset);
        }
        else {
            for (var i = 0; i < tableGrid.length; i++) {
                if (tableGrid[i] > offset) {
                    return i;
                }
            }
            index = tableGrid.length - 1;
        }
        return index;
    };
    TableRowWidget.prototype.getCellOffset = function (index, containerWidth) {
        var prevOffset = 0;
        var ownerTable = this.ownerTable;
        for (var i = 0; i < this.childWidgets.length; i++) {
            var cellFormat = this.childWidgets[i].cellFormat;
            if (i === index) {
                break;
            }
            prevOffset += ownerTable.getCellWidth(cellFormat.preferredWidth, cellFormat.preferredWidthType, containerWidth, null);
        }
        return prevOffset;
    };
    /**
     * @private
     */
    TableRowWidget.prototype.updateRowBySpannedCells = function () {
        var rowSpannedCells = this.getPreviousRowSpannedCells();
        var currentRowIndex = this.rowIndex;
        for (var i = 0; i < rowSpannedCells.length; i++) {
            var spannedCell = rowSpannedCells[i];
            var rowSpanEnd = spannedCell.ownerRow.rowIndex + spannedCell.cellFormat.rowSpan - 1;
            // If current row is row span end or includes spanned cells. then, decrease the rowspan
            if (rowSpanEnd >= currentRowIndex) {
                spannedCell.cellFormat.rowSpan -= 1;
            }
        }
    };
    /**
     * @private
     */
    TableRowWidget.prototype.getPreviousRowSpannedCells = function (include) {
        var rowSpannedCells = [];
        var row = include ? this : this.previousWidget;
        while (!isNullOrUndefined(row)) {
            for (var i = 0; i < row.childWidgets.length; i++) {
                var cell = row.childWidgets[i];
                if (cell.cellFormat.rowSpan > 1) {
                    rowSpannedCells.splice(0, 0, cell);
                }
            }
            row = row.previousWidget;
        }
        return rowSpannedCells;
    };
    /**
     * @private
     */
    TableRowWidget.prototype.getTableCellWidget = function (point) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            var x = Math.round(this.childWidgets[i].x);
            if (x - this.childWidgets[i].margin.left - 1 <= point.x
                && (x + this.childWidgets[i].width) >= point.x) {
                return this.childWidgets[i];
            }
            else if (i === this.childWidgets.length - 1
                && (this.childWidgets[i].x + this.childWidgets[i].width) + 1 <= point.x) {
                return this.childWidgets[i];
            }
        }
        var cellWidget = undefined;
        if (this.childWidgets.length > 0) {
            if (this.childWidgets[0].x <= point.x) {
                cellWidget = this.childWidgets[this.childWidgets.length - 1].getTableCellWidget(point);
            }
            else {
                cellWidget = this.childWidgets[0].getTableCellWidget(point);
            }
        }
        return cellWidget;
    };
    /**
     * @private
     */
    TableRowWidget.prototype.getMinimumAndMaximumWordWidth = function (minimumWordWidth, maximumWordWidth) {
        return { 'minimumWordWidth': minimumWordWidth, 'maximumWordWidth': maximumWordWidth };
    };
    /**
     * @private
     */
    TableRowWidget.prototype.destroyInternal = function (viewer) {
        var height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (var i = 0; i < this.childWidgets.length; i++) {
                var widget = this.childWidgets[i];
                widget.destroyInternal(viewer);
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                i--;
            }
            this.childWidgets = undefined;
        }
        if (!isNullOrUndefined(this.containerWidget)) {
            if (!isNullOrUndefined(this.containerWidget.childWidgets)) {
                this.containerWidget.childWidgets.splice(this.containerWidget.childWidgets.indexOf(this), 1);
                if ((isNullOrUndefined(this.containerWidget.childWidgets) || this.containerWidget.childWidgets.length === 0)
                    && this.containerWidget instanceof TableWidget) {
                    this.containerWidget.destroyInternal(viewer);
                }
                else if (this.containerWidget.containerWidget instanceof BodyWidget) {
                    this.containerWidget.containerWidget.height -= height;
                }
                this.containerWidget.height -= height;
            }
        }
        this.destroy();
    };
    /**
     * @private
     */
    TableRowWidget.prototype.clone = function () {
        var row = new TableRowWidget();
        row.rowFormat.copyFormat(this.rowFormat);
        row.topBorderWidth = this.topBorderWidth;
        row.bottomBorderWidth = this.bottomBorderWidth;
        for (var i = 0; i < this.childWidgets.length; i++) {
            var cell = this.childWidgets[i].clone();
            row.childWidgets.push(cell);
            cell.containerWidget = row;
            cell.index = i;
            cell.rowIndex = this.rowIndex;
        }
        row.x = this.x;
        row.y = this.y;
        row.height = this.height;
        row.width = this.width;
        return row;
    };
    /**
     * Updates the child widgets left.
     * @param left
     * @private
     */
    TableRowWidget.prototype.updateChildWidgetLeft = function (left) {
        // TODO: Cell spacing calculation.
        var spacing = 0;
        if (this.ownerTable.tableFormat.cellSpacing > 0) {
            spacing = this.ownerTable.tableFormat.cellSpacing;
        }
        for (var i = 0; i < this.childWidgets.length; i++) {
            var cellWidget = this.childWidgets[i];
            left += spacing + cellWidget.margin.left;
            cellWidget.x = left;
            cellWidget.updateChildWidgetLeft(cellWidget.x);
            left += cellWidget.width + cellWidget.margin.right;
        }
    };
    /**
     * Shift the widgets for RTL table.
     * @param clientArea
     * @param tableWidget
     * @param rowWidget
     * @private
     */
    TableRowWidget.prototype.shiftWidgetForRtlTable = function (clientArea, tableWidget, rowWidget) {
        var clientAreaX = tableWidget.x;
        var cellSpace = 0;
        var tableWidth = 0;
        if (tableWidget.tableFormat != null && tableWidget.tableFormat.cellSpacing > 0) {
            cellSpace = tableWidget.tableFormat.cellSpacing;
        }
        tableWidth = HelperMethods.convertPointToPixel(tableWidget.getTableWidth());
        var rowX = rowWidget.x;
        var clientAreaRight = clientAreaX + tableWidth;
        var left = clientAreaRight - (rowX - clientAreaX);
        for (var j = 0; j < rowWidget.childWidgets.length; j++) {
            var cellWidget = rowWidget.childWidgets[j];
            left = left - (cellWidget.width + cellWidget.margin.left + cellWidget.margin.right - cellWidget.rightBorderWidth + cellSpace);
            cellWidget.updateWidgetLeft(left + cellWidget.margin.left);
        }
    };
    /**
     * @private
     */
    TableRowWidget.prototype.destroy = function () {
        // if (this.rowFormat) {
        //     this.rowFormat.destroy();
        // }
        this.rowFormat = undefined;
        this.rowFormat = undefined;
        this.topBorderWidth = undefined;
        this.bottomBorderWidth = undefined;
        _super.prototype.destroy.call(this);
    };
    return TableRowWidget;
}(BlockWidget));
/**
 * @private
 */
var TableCellWidget = /** @__PURE__ @class */ (function (_super) {
    __extends$1(TableCellWidget, _super);
    function TableCellWidget() {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.rowIndex = -1;
        _this.sizeInfoInternal = new ColumnSizeInfo();
        _this.margin = new Margin(_this.leftMargin, _this.topMargin, _this.rightMargin, _this.bottomMargin);
        _this.leftBorderWidth = 0;
        _this.rightBorderWidth = 0;
        _this.cellFormat = new WCellFormat(_this);
        return _this;
    }
    Object.defineProperty(TableCellWidget.prototype, "ownerColumn", {
        /**
         * @private
         */
        get: function () {
            return this.ownerTable.tableHolder.columns[this.columnIndex];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCellWidget.prototype, "leftMargin", {
        /**
         * @private
         */
        get: function () {
            if (this.cellFormat && this.cellFormat.containsMargins()) {
                return this.cellFormat.leftMargin;
            }
            else if (!isNullOrUndefined(this.ownerRow) && this.ownerRow.rowFormat.hasValue('leftMargin')) {
                return this.ownerRow.rowFormat.leftMargin;
            }
            else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
                return this.ownerTable.tableFormat.leftMargin;
            }
            else {
                return 0;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCellWidget.prototype, "topMargin", {
        /**
         * @private
         */
        get: function () {
            if (this.cellFormat && this.cellFormat.containsMargins()) {
                return this.cellFormat.topMargin;
            }
            else if (!isNullOrUndefined(this.ownerRow) && this.ownerRow.rowFormat.hasValue('topMargin')) {
                return this.ownerRow.rowFormat.topMargin;
            }
            else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
                return this.ownerTable.tableFormat.topMargin;
            }
            else {
                return 0;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCellWidget.prototype, "rightMargin", {
        /**
         * @private
         */
        get: function () {
            if (this.cellFormat && this.cellFormat.containsMargins()) {
                return this.cellFormat.rightMargin;
            }
            else if (!isNullOrUndefined(this.ownerRow) && this.ownerRow.rowFormat.hasValue('rightMargin')) {
                return this.ownerRow.rowFormat.rightMargin;
            }
            else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
                return this.ownerTable.tableFormat.rightMargin;
            }
            else {
                return 0;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCellWidget.prototype, "bottomMargin", {
        /**
         * @private
         */
        get: function () {
            if (this.cellFormat && this.cellFormat.containsMargins()) {
                return this.cellFormat.bottomMargin;
            }
            else if (!isNullOrUndefined(this.ownerRow) && this.ownerRow.rowFormat.hasValue('bottomMargin')) {
                return this.ownerRow.rowFormat.bottomMargin;
            }
            else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
                return this.ownerTable.tableFormat.bottomMargin;
            }
            else {
                return 0;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCellWidget.prototype, "cellIndex", {
        /**
         * @private
         */
        get: function () {
            if (this.ownerRow) {
                return this.ownerRow.childWidgets.indexOf(this);
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCellWidget.prototype, "ownerTable", {
        /**
         * @private
         */
        get: function () {
            if (this.containerWidget instanceof TableRowWidget) {
                return this.containerWidget.ownerTable;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCellWidget.prototype, "ownerRow", {
        /**
         * @private
         */
        get: function () {
            return this.containerWidget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableCellWidget.prototype, "sizeInfo", {
        /**
         * @private
         */
        get: function () {
            return this.sizeInfoInternal;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    TableCellWidget.prototype.equals = function (widget) {
        return widget instanceof TableCellWidget && widget.cellFormat === this.cellFormat;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getContainerTable = function () {
        var table = this.ownerTable;
        while (table instanceof TableWidget && table.associatedCell instanceof TableCellWidget) {
            table = table.associatedCell.getContainerTable();
        }
        return table;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getPreviousSplitWidget = function () {
        if (this.containerWidget instanceof TableRowWidget) {
            var row = this.containerWidget;
            do {
                row = row.previousRenderedWidget;
                if (isNullOrUndefined(row) || row.index < this.rowIndex) {
                    break;
                }
                var previousCell = row.getCell(this.rowIndex, this.index);
                if (previousCell && this.equals(previousCell)) {
                    return previousCell;
                }
            } while (row);
        }
        return undefined;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getNextSplitWidget = function () {
        var rowSpan = this.cellFormat.rowSpan;
        if (this.containerWidget instanceof TableRowWidget) {
            var row = this.containerWidget;
            do {
                row = row.nextRenderedWidget;
                if (isNullOrUndefined(row) || row.index > this.rowIndex + rowSpan) {
                    break;
                }
                var nextCell = row.getCell(this.rowIndex, this.index);
                if (nextCell && this.equals(nextCell)) {
                    return nextCell;
                }
            } while (row);
        }
        return undefined;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getTableCellWidget = function (point) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            if (this.childWidgets[i].y <= point.y
                && (this.childWidgets[i].y + this.childWidgets[i].height) >= point.y) {
                return this.childWidgets[i].getTableCellWidget(point);
            }
        }
        var tableCellWidget = undefined;
        if (this.childWidgets.length > 0) {
            if (this.childWidgets[0].y <= point.y) {
                tableCellWidget = this.childWidgets[this.childWidgets.length - 1].getTableCellWidget(point);
            }
            else {
                tableCellWidget = this.childWidgets[0].getTableCellWidget(point);
            }
        }
        return tableCellWidget;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.updateWidth = function (preferredWidth) {
        if (this.cellFormat.preferredWidthType === 'Point') {
            this.cellFormat.preferredWidth = preferredWidth;
        }
        else if (this.cellFormat.preferredWidthType === 'Percent') {
            this.cellFormat.preferredWidth = this.convertPointToPercent(preferredWidth);
        }
        this.cellFormat.cellWidth = preferredWidth;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getCellWidth = function () {
        var ownerTable = this.ownerTable;
        var containerWidth = ownerTable ? ownerTable.getTableClientWidth(ownerTable.getOwnerWidth(true)) : 0;
        var cellWidth = containerWidth;
        if (ownerTable && ownerTable.tableFormat.preferredWidthType === 'Auto' && ownerTable.tableFormat.allowAutoFit) {
            cellWidth = containerWidth;
        }
        else if (this.cellFormat.preferredWidthType === 'Percent') {
            cellWidth = (this.cellFormat.preferredWidth * containerWidth) / 100 - this.leftMargin - this.rightMargin;
        }
        else if (this.cellFormat.preferredWidthType === 'Point') {
            cellWidth = this.cellFormat.preferredWidth - this.leftMargin - this.rightMargin;
        }
        // For grid before and grid after with auto width, no need to calculate minimum preferred width.
        return cellWidth;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.convertPointToPercent = function (cellPreferredWidth) {
        var value = 0;
        var clientWidth = this.ownerTable.getOwnerWidth(true);
        var tableWidth = this.ownerTable.getTableClientWidth(clientWidth);
        value = (cellPreferredWidth / tableWidth) * 100;
        value = Math.round(value);
        return value < 100 ? value : 100; // The value should be lesser than or equal to 100%;
    };
    /**
     * @private
     */
    TableCellWidget.getCellLeftBorder = function (tableCell) {
        var leftBorder = undefined;
        var cellBorder = tableCell.cellFormat.borders;
        var rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        var tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.left)) {
            leftBorder = cellBorder.left;
        }
        if (isNullOrUndefined(leftBorder)) {
            leftBorder = tableCell.getLeftBorderToRenderByHierarchy(leftBorder, rowBorders, tableBorders);
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            leftBorder = tableCell.getLeftBorderToRenderByHierarchy(leftBorder, rowBorders, tableBorders);
        }
        else {
            var prevCell = undefined;
            if (!isNullOrUndefined(tableCell.previousWidget)) {
                // if the border is shared then choose the border based on Conflict Resolution algorithm.
                prevCell = tableCell.previousWidget;
            }
            else if ((tableCell.cellFormat.columnSpan > 1 || tableCell.columnIndex > 1) && tableCell.ownerRow.rowIndex > 0) {
                var previousRow = tableCell.ownerRow.previousWidget;
                while (!isNullOrUndefined(previousRow) && previousRow.childWidgets.length > 0) {
                    for (var i = 0; i < previousRow.childWidgets.length; i++) {
                        var prevRowCell = previousRow.childWidgets[i];
                        if (prevRowCell.columnIndex + prevRowCell.cellFormat.columnSpan === tableCell.columnIndex) {
                            prevCell = previousRow.childWidgets[i];
                            break;
                        }
                    }
                    if (!isNullOrUndefined(prevCell)) {
                        break;
                    }
                    previousRow = previousRow.previousWidget;
                }
            }
            leftBorder = tableCell.getPreviousCellLeftBorder(leftBorder, prevCell);
        }
        if (isNullOrUndefined(leftBorder)) {
            leftBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return leftBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getLeftBorderWidth = function () {
        var borderWidth = 0;
        // Added null condition check for asynchronous loading.
        if (this.cellFormat !== null && this.cellFormat.borders !== null) {
            // update the margins values respect to layouting of borders.
            // For normal table cells only left border is rendered. for last cell left and right border is rendered.
            // this border widths are not included in margins.
            borderWidth = TableCellWidget.getCellLeftBorder(this).getLineWidth();
            // tslint:disable-next-line:max-line-length
            // need to render rightBorder specifically for all the cells when the cellSpacing is greater than zero or for last cell of each row.
        }
        return borderWidth;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getRightBorderWidth = function () {
        var borderWidth = 0;
        var ownerTable = this.ownerTable;
        //Added null condition check for asynchronous loading.
        if (this.cellFormat !== null && this.cellFormat.borders !== null) {
            borderWidth = TableCellWidget.getCellRightBorder(this).getLineWidth();
        }
        return borderWidth;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getCellSpacing = function () {
        var actualCellSpacing = this.ownerTable && this.ownerTable.tableFormat ? this.ownerTable.tableFormat.cellSpacing : 0;
        var cellSpacingToLayout = actualCellSpacing;
        // Considers the left, right margins and border widths(only available for Layouted table) for Minimum width.
        if (this.ownerRow.childWidgets.length === 1) {
            cellSpacingToLayout = actualCellSpacing * 2;
        }
        else if (this.cellIndex === 0 || this.cellIndex === this.ownerRow.childWidgets.length - 1) {
            cellSpacingToLayout = actualCellSpacing + (actualCellSpacing / 2);
        }
        else {
            cellSpacingToLayout = actualCellSpacing;
        }
        return cellSpacingToLayout;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getCellSizeInfo = function (isAutoFit) {
        var contentChanged = false;
        // Gets the minimum preferred width for the table cell.
        if (!this.sizeInfo.hasMinimumWidth) {
            this.sizeInfo.minimumWidth = this.getMinimumPreferredWidth();
        }
        // Gets the minimum and maximum word widths.
        if (isAutoFit) {
            if (!this.sizeInfo.hasMinimumWordWidth || contentChanged) {
                var size = this.getMinimumAndMaximumWordWidth(0, 0);
                this.sizeInfo.minimumWordWidth = size.minimumWordWidth + this.sizeInfo.minimumWidth;
                this.sizeInfo.maximumWordWidth = size.maximumWordWidth + this.sizeInfo.minimumWidth;
                // if minimum and maximum width values are equal, set value as zero.
                // later, preferred width value is considered for all width values.
                // if (this.sizeInfo.minimumWidth === this.sizeInfo.minimumWordWidth
                //     && this.sizeInfo.minimumWordWidth === this.sizeInfo.maximumWordWidth) {
                //     this.sizeInfo.minimumWordWidth = 0;
                //     this.sizeInfo.maximumWordWidth = 0;
                //     this.sizeInfo.minimumWidth = 0;
                // }
            }
        }
        var sizeInfo = new ColumnSizeInfo();
        sizeInfo.minimumWidth = this.sizeInfo.minimumWidth;
        sizeInfo.minimumWordWidth = this.sizeInfo.minimumWordWidth;
        sizeInfo.maximumWordWidth = this.sizeInfo.maximumWordWidth;
        return sizeInfo;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getMinimumPreferredWidth = function () {
        var defaultWidth = 0;
        if (this.cellFormat.preferredWidth > 0) {
            return this.cellFormat.preferredWidth;
        }
        defaultWidth = this.leftMargin + this.rightMargin + this.getLeftBorderWidth() + this.getRightBorderWidth() + this.getCellSpacing();
        return defaultWidth;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getPreviousCellLeftBorder = function (leftBorder, previousCell) {
        // tslint:disable-next-line:max-line-length
        if ((isNullOrUndefined(previousCell) || (!isNullOrUndefined(leftBorder) && (leftBorder.lineStyle === 'None' && !leftBorder.hasNoneStyle)))) {
            if (!isNullOrUndefined(leftBorder) && !(leftBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                leftBorder = this.getLeftBorderToRenderByHierarchy(leftBorder, TableRowWidget.getRowOf(leftBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(leftBorder.ownerBase).tableFormat.borders);
            }
        }
        if (isNullOrUndefined(previousCell)) {
            return leftBorder;
        }
        else {
            var prevCellRightBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(previousCell.cellFormat.borders) && !isNullOrUndefined(previousCell.cellFormat.borders.right) && previousCell.cellFormat.borders.right.lineStyle !== 'None') {
                prevCellRightBorder = previousCell.cellFormat.borders.right;
            }
            if (!isNullOrUndefined(prevCellRightBorder) && prevCellRightBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(prevCellRightBorder, leftBorder);
            }
            else if (!isNullOrUndefined(leftBorder) && !(leftBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getLeftBorderToRenderByHierarchy(leftBorder, TableRowWidget.getRowOf(leftBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(leftBorder.ownerBase).tableFormat.borders);
            }
        }
        return leftBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getBorderBasedOnPriority = function (border, adjacentBorder) {
        // If the cell and its adjacent cell defined different borders then based on this algorithm the border choose to render.
        // Reference link :https://msdn.microsoft.com/en-us/library/office/documentformat.openxml.wordprocessing.tablecellborders.aspx
        if (isNullOrUndefined(border)) {
            return adjacentBorder;
        }
        else if (isNullOrUndefined(adjacentBorder)) {
            return border;
        }
        var borderWeight = border.getBorderWeight();
        var adjacentBorderWeight = adjacentBorder.getBorderWeight();
        //the border with higher wight  shall be displayed.
        if (borderWeight === adjacentBorderWeight) {
            //if the border is equal weight the based on the priority the border will be choosen to render.
            var borderPriority = border.getPrecedence();
            var adjacentBorderPriority = adjacentBorder.getPrecedence();
            if (borderPriority === adjacentBorderPriority) {
                //The color with the smaller brightness value shall be displayed.
                var borderColInRGB = this.convertHexToRGB(border.color);
                var R1 = borderColInRGB.r;
                var G1 = borderColInRGB.g;
                var B1 = borderColInRGB.b;
                var adjacentBorderColInRGB = this.convertHexToRGB(adjacentBorder.color);
                var R2 = adjacentBorderColInRGB.r;
                var G2 = adjacentBorderColInRGB.g;
                var B2 = adjacentBorderColInRGB.b;
                var borderBrightness = (R1 + B1 + (2 * G1));
                var adjacentBorderBrightness = (R2 + B2 + (2 * G2));
                if (borderBrightness === adjacentBorderBrightness) {
                    borderBrightness = (B1 + (2 * G1));
                    adjacentBorderBrightness = (B2 + (2 * G2));
                    if (borderBrightness === adjacentBorderBrightness) {
                        if (G1 === G2) {
                            return border;
                        }
                        else if (G1 > G2) {
                            return adjacentBorder;
                        }
                        else {
                            return border;
                        }
                    }
                    else if (borderBrightness > adjacentBorderBrightness) {
                        return adjacentBorder;
                    }
                    else {
                        return border;
                    }
                }
                else if (borderBrightness > adjacentBorderBrightness) {
                    return adjacentBorder;
                }
                else {
                    return border;
                }
            }
            else if (borderPriority > adjacentBorderPriority) {
                return border;
            }
            else {
                return adjacentBorder;
            }
        }
        else if (borderWeight > adjacentBorderWeight) {
            return border;
        }
        else {
            return adjacentBorder;
        }
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getLeftBorderToRenderByHierarchy = function (leftBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(leftBorder) && (leftBorder.lineStyle !== 'None' || (leftBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(leftBorder.lineStyle === 'None' && leftBorder.lineWidth === 0 && leftBorder.color === '#000000')))) {
            return leftBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(leftBorder) && (leftBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(leftBorder.ownerBase).columnIndex === 0) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.left)) {
                leftBorder = tableBorders.left;
            }
            return leftBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.vertical) && rowBorders.vertical.lineStyle !== 'None') {
            return leftBorder = rowBorders.vertical;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.vertical) && tableBorders.vertical.lineStyle !== 'None') {
            return leftBorder = tableBorders.vertical;
        }
        else {
            return leftBorder;
        }
    };
    /**
     * @private
     */
    TableCellWidget.getCellRightBorder = function (tableCell) {
        var rightBorder = undefined;
        var cellBorder = tableCell.cellFormat.borders;
        var rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        var tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.right)) {
            rightBorder = cellBorder.right;
        }
        if (isNullOrUndefined(rightBorder)) {
            rightBorder = tableCell.getRightBorderToRenderByHierarchy(rightBorder, rowBorders, tableBorders);
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            rightBorder = tableCell.getRightBorderToRenderByHierarchy(rightBorder, rowBorders, tableBorders);
        }
        else {
            var nextCell = undefined;
            if (!isNullOrUndefined(tableCell.nextWidget)) {
                nextCell = tableCell.nextWidget;
            }
            // if the border is shared then choose the border based on Conflict Resolution algorithm.
            rightBorder = tableCell.getAdjacentCellRightBorder(rightBorder, nextCell);
        }
        if (isNullOrUndefined(rightBorder)) {
            rightBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return rightBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getAdjacentCellRightBorder = function (rightBorder, nextCell) {
        // tslint:disable-next-line:max-line-length
        if (isNullOrUndefined(nextCell) || (!isNullOrUndefined(rightBorder) && (rightBorder.lineStyle === 'None' && !rightBorder.hasNoneStyle))) {
            if (!isNullOrUndefined(rightBorder) && !(rightBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                rightBorder = this.getRightBorderToRenderByHierarchy(rightBorder, TableRowWidget.getRowOf(rightBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(rightBorder.ownerBase).tableFormat.borders);
            }
        }
        if (isNullOrUndefined(nextCell)) {
            return rightBorder;
        }
        else {
            var nextCellLeftBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(nextCell.cellFormat.borders) && !isNullOrUndefined(nextCell.cellFormat.borders.left) && nextCell.cellFormat.borders.left.lineStyle !== 'None') {
                nextCellLeftBorder = nextCell.cellFormat.borders.left;
            }
            if (!isNullOrUndefined(nextCellLeftBorder) && nextCellLeftBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(rightBorder, nextCellLeftBorder);
            }
            else if (!isNullOrUndefined(rightBorder) && !(rightBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getRightBorderToRenderByHierarchy(rightBorder, TableRowWidget.getRowOf(rightBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(rightBorder.ownerBase).tableFormat.borders);
            }
        }
        return rightBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getRightBorderToRenderByHierarchy = function (rightBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(rightBorder) && (rightBorder.lineStyle !== 'None' || (rightBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(rightBorder.lineStyle === 'None' && rightBorder.lineWidth === 0 && rightBorder.color === '#000000')))) {
            return rightBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(rightBorder) && (rightBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(rightBorder.ownerBase).columnIndex === TableCellWidget.getCellOf(rightBorder.ownerBase).ownerRow.childWidgets.length - 1) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.right)) {
                rightBorder = tableBorders.right;
            }
            return rightBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.vertical) && rowBorders.vertical.lineStyle !== 'None') {
            return rightBorder = rowBorders.vertical;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.vertical) && tableBorders.vertical.lineStyle !== 'None') {
            return rightBorder = tableBorders.vertical;
        }
        else {
            return rightBorder;
        }
    };
    /**
     * @private
     */
    TableCellWidget.getCellTopBorder = function (tableCell) {
        var topBorder = undefined;
        var cellBorder = tableCell.cellFormat.borders;
        var rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        var tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.top)) {
            topBorder = cellBorder.top;
        }
        if (isNullOrUndefined(topBorder)) {
            topBorder = tableCell.getTopBorderToRenderByHierarchy(topBorder, rowBorders, tableBorders);
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            topBorder = tableCell.getTopBorderToRenderByHierarchy(topBorder, rowBorders, tableBorders);
        }
        else {
            var prevTopCell = undefined;
            //ToDo: Need to analyze more to get the previous cell.
            var prevRow = tableCell.ownerRow.previousWidget;
            while (!isNullOrUndefined(prevRow) && prevRow.childWidgets.length > 0) {
                for (var i = 0; i < prevRow.childWidgets.length; i++) {
                    var prevRowCell = prevRow.childWidgets[i];
                    if (prevRowCell.columnIndex + prevRowCell.cellFormat.columnSpan - 1 >= tableCell.columnIndex) {
                        prevTopCell = prevRow.childWidgets[i];
                        break;
                    }
                }
                if (!isNullOrUndefined(prevTopCell)) {
                    break;
                }
                prevRow = prevRow.previousWidget;
                //If all the previous rows checked and the previous top cell is null
                // then TableCell previus row matched column index cell is taken for border calculation.
                if (isNullOrUndefined(prevRow) && isNullOrUndefined(prevTopCell)) {
                    prevRow = tableCell.ownerRow.previousWidget;
                    if (tableCell.columnIndex < prevRow.childWidgets.length) {
                        for (var i = 0; i < prevRow.childWidgets.length; i++) {
                            var prevRowCell = prevRow.childWidgets[i];
                            if (prevRowCell.columnIndex === tableCell.columnIndex) {
                                prevTopCell = prevRow.childWidgets[i];
                                break;
                            }
                        }
                        //If table cell Column index is greater than previous row cells count then last cell is taken as previous top cell.
                    }
                    else {
                        // tslint:disable-next-line:max-line-length
                        prevTopCell = tableCell.ownerRow.previousWidget.childWidgets[tableCell.ownerRow.previousWidget.childWidgets.length - 1];
                    }
                }
            }
            //If the border is shared then choose the border based on Conflict Resolution algorithm.
            topBorder = tableCell.getPreviousCellTopBorder(topBorder, prevTopCell);
        }
        if (isNullOrUndefined(topBorder)) {
            topBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return topBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getPreviousCellTopBorder = function (topBorder, previousTopCell) {
        // tslint:disable-next-line:max-line-length
        if (isNullOrUndefined(previousTopCell) || (!isNullOrUndefined(topBorder) && (topBorder.lineStyle === 'None' && !topBorder.hasNoneStyle))) {
            if (!isNullOrUndefined(topBorder) && !(topBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                topBorder = this.getTopBorderToRenderByHierarchy(topBorder, TableRowWidget.getRowOf(topBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(topBorder.ownerBase).tableFormat.borders);
            }
        }
        if (isNullOrUndefined(previousTopCell)) {
            return topBorder;
        }
        else {
            var prevTopCellBottomBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(previousTopCell.cellFormat.borders) && !isNullOrUndefined(previousTopCell.cellFormat.borders.bottom) && previousTopCell.cellFormat.borders.bottom.lineStyle !== 'None') {
                prevTopCellBottomBorder = previousTopCell.cellFormat.borders.bottom;
            }
            if (!isNullOrUndefined(prevTopCellBottomBorder) && prevTopCellBottomBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(topBorder, prevTopCellBottomBorder);
            }
            else if (!isNullOrUndefined(topBorder) && !(topBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getTopBorderToRenderByHierarchy(topBorder, TableRowWidget.getRowOf(topBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(topBorder.ownerBase).tableFormat.borders);
            }
        }
        return topBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getTopBorderToRenderByHierarchy = function (topBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(topBorder) && (topBorder.lineStyle !== 'None' || (topBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(topBorder.lineStyle === 'None' && topBorder.lineWidth === 0 && topBorder.color === '#000000')))) {
            return topBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(topBorder) && (topBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(topBorder.ownerBase).ownerRow.rowIndex === 0) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.top)) {
                topBorder = tableBorders.top;
            }
            return topBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.horizontal) && rowBorders.horizontal.lineStyle !== 'None') {
            return topBorder = rowBorders.horizontal;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.horizontal) && tableBorders.horizontal.lineStyle !== 'None') {
            return topBorder = tableBorders.horizontal;
        }
        else {
            return topBorder;
        }
    };
    /**
     * @private
     */
    TableCellWidget.getCellBottomBorder = function (tableCell) {
        var bottomBorder = undefined;
        var cellBorder = tableCell.cellFormat.borders;
        var rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        var tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.bottom)) {
            bottomBorder = cellBorder.bottom;
        }
        if (isNullOrUndefined(bottomBorder)) {
            // tslint:disable-next-line:max-line-length
            bottomBorder = tableCell.getBottomBorderToRenderByHierarchy(bottomBorder, rowBorders, tableBorders); // select the left border based on heirarchy.
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            bottomBorder = tableCell.getBottomBorderToRenderByHierarchy(bottomBorder, rowBorders, tableBorders);
        }
        else {
            var nextBottomCell = undefined;
            var nextRow = tableCell.ownerRow.nextWidget;
            if (!isNullOrUndefined(nextRow) && tableCell.columnIndex < nextRow.childWidgets.length) {
                nextBottomCell = nextRow.childWidgets[tableCell.columnIndex];
            }
            //If the border is shared then choose the border based on Conflict Resolution algorithm.
            bottomBorder = tableCell.getAdjacentCellBottomBorder(bottomBorder, nextBottomCell);
        }
        if (isNullOrUndefined(bottomBorder)) {
            bottomBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return bottomBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getAdjacentCellBottomBorder = function (bottomBorder, nextBottomCell) {
        // tslint:disable-next-line:max-line-length
        if (isNullOrUndefined(nextBottomCell) || (!isNullOrUndefined(bottomBorder) && (bottomBorder.lineStyle === 'None' && !bottomBorder.hasNoneStyle))) {
            if (!isNullOrUndefined(bottomBorder) && !(bottomBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                bottomBorder = this.getBottomBorderToRenderByHierarchy(bottomBorder, TableRowWidget.getRowOf(bottomBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(bottomBorder.ownerBase).tableFormat.borders);
            }
        }
        if (isNullOrUndefined(nextBottomCell)) {
            return bottomBorder;
        }
        else {
            var prevBottomCellTopBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(nextBottomCell.cellFormat.borders) && !isNullOrUndefined(nextBottomCell.cellFormat.borders.top) && nextBottomCell.cellFormat.borders.top.lineStyle !== 'None') {
                prevBottomCellTopBorder = nextBottomCell.cellFormat.borders.top;
            }
            if (!isNullOrUndefined(prevBottomCellTopBorder) && prevBottomCellTopBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(bottomBorder, prevBottomCellTopBorder);
            }
            else if (!isNullOrUndefined(bottomBorder) && !(bottomBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getBottomBorderToRenderByHierarchy(bottomBorder, TableRowWidget.getRowOf(bottomBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(bottomBorder.ownerBase).tableFormat.borders);
            }
        }
        return bottomBorder;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getBottomBorderToRenderByHierarchy = function (bottomBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(bottomBorder) && (bottomBorder.lineStyle !== 'None' || (bottomBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(bottomBorder.lineStyle === 'None' && bottomBorder.lineWidth === 0 && bottomBorder.color === '#000000')))) {
            return bottomBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(bottomBorder) && (bottomBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(bottomBorder.ownerBase).ownerRow.rowIndex + TableCellWidget.getCellOf(bottomBorder.ownerBase).cellFormat.rowSpan === TableCellWidget.getCellOf(bottomBorder.ownerBase).ownerTable.childWidgets.length) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.bottom)) {
                bottomBorder = tableBorders.bottom;
            }
            return bottomBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.horizontal) && rowBorders.horizontal.lineStyle !== 'None') {
            return bottomBorder = rowBorders.horizontal;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.horizontal) && tableBorders.horizontal.lineStyle !== 'None') {
            return bottomBorder = tableBorders.horizontal;
        }
        else {
            return bottomBorder;
        }
    };
    TableCellWidget.prototype.convertHexToRGB = function (colorCode) {
        if (colorCode) {
            colorCode = colorCode.replace(/[^0-9A-F]/gi, ''); // To remove # from color code string.
            var colCodeNo = parseInt(colorCode, 16);
            var r = (colCodeNo >> 16) & 255;
            var g = (colCodeNo >> 8) & 255;
            var b = colCodeNo & 255;
            return { 'r': r, 'g': g, 'b': b };
        }
        return undefined;
    };
    /**
     * @private
     */
    TableCellWidget.getCellOf = function (node) {
        if (node instanceof WBorders) {
            if (node.ownerBase instanceof WCellFormat && node.ownerBase.ownerBase instanceof TableCellWidget) {
                return node.ownerBase.ownerBase;
            }
            else {
                return undefined;
            }
        }
        return undefined;
    };
    /**
     * Updates the Widget left.
     * @private
     */
    TableCellWidget.prototype.updateWidgetLeft = function (x) {
        this.x = x;
        this.updateChildWidgetLeft(x);
    };
    /**
     * @private
     */
    TableCellWidget.prototype.updateChildWidgetLeft = function (left) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            this.childWidgets[i].x = left;
            if (this.childWidgets[i] instanceof TableWidget) {
                var tableWidget = this.childWidgets[i];
                tableWidget.updateChildWidgetLeft(left);
                if (tableWidget.isBidiTable) {
                    var clientArea = new Rect(tableWidget.x, tableWidget.y, tableWidget.width, tableWidget.height);
                    tableWidget.shiftWidgetsForRtlTable(clientArea, tableWidget);
                }
            }
        }
    };
    /**
     * @private
     */
    TableCellWidget.prototype.getMinimumAndMaximumWordWidth = function (minimumWordWidth, maximumWordWidth) {
        for (var i = 0; i < this.childWidgets.length; i++) {
            var block = this.childWidgets[i];
            var widthInfo = block.getMinimumAndMaximumWordWidth(minimumWordWidth, maximumWordWidth);
            minimumWordWidth = widthInfo.minimumWordWidth;
            maximumWordWidth = widthInfo.maximumWordWidth;
        }
        return { 'minimumWordWidth': minimumWordWidth, 'maximumWordWidth': maximumWordWidth };
    };
    /**
     * @private
     */
    TableCellWidget.prototype.destroyInternal = function (viewer) {
        // let viewer: LayoutViewer = undefined;
        // let page: Page = this.getPage();
        // if (!isNullOrUndefined(page ))
        //     viewer = page.viewer;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (var i = 0; i < this.childWidgets.length; i++) {
                var widget = this.childWidgets[i];
                if (widget instanceof ParagraphWidget) {
                    widget.destroyInternal(viewer);
                }
                else {
                    widget.destroyInternal(viewer);
                }
                i--;
            }
            this.childWidgets = undefined;
        }
        this.destroy();
    };
    /**
     * @private
     */
    TableCellWidget.prototype.clone = function () {
        var cell = new TableCellWidget();
        cell.cellFormat.copyFormat(this.cellFormat);
        for (var i = 0; i < this.childWidgets.length; i++) {
            var block = this.childWidgets[i].clone();
            cell.childWidgets.push(block);
            block.containerWidget = cell;
            block.index = i;
        }
        cell.leftBorderWidth = this.leftBorderWidth;
        cell.rightBorderWidth = this.rightBorderWidth;
        if (this.margin) {
            cell.margin = this.margin.clone();
        }
        cell.columnIndex = this.columnIndex;
        cell.x = this.x;
        cell.y = this.y;
        cell.height = this.height;
        cell.width = this.width;
        return cell;
    };
    /**
     * @private
     */
    TableCellWidget.prototype.destroy = function () {
        // if (this.cellFormat) {
        //     this.cellFormat.destroy();
        // }
        this.cellFormat = undefined;
        this.rowIndex = undefined;
        this.columnIndex = undefined;
        _super.prototype.destroy.call(this);
    };
    return TableCellWidget;
}(BlockWidget));
/**
 * @private
 */
var LineWidget = /** @__PURE__ @class */ (function () {
    /**
     * Initialize the constructor of LineWidget
     */
    function LineWidget(paragraphWidget) {
        /**
         * @private
         */
        this.children = [];
        /**
         * @private
         */
        this.x = 0;
        /**
         * @private
         */
        this.y = 0;
        /**
         * @private
         */
        this.width = 0;
        /**
         * @private
         */
        this.height = 0;
        this.paragraph = paragraphWidget;
    }
    Object.defineProperty(LineWidget.prototype, "indexInOwner", {
        /**
         * @private
         */
        get: function () {
            if (this.paragraph && this.paragraph.childWidgets) {
                return this.paragraph.childWidgets.indexOf(this);
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineWidget.prototype, "nextLine", {
        /**
         * @private
         */
        get: function () {
            var paragraph = this.paragraph;
            var lineIndex = this.indexInOwner;
            if (lineIndex <= paragraph.childWidgets.length - 2) {
                return paragraph.childWidgets[lineIndex + 1];
            }
            else if (paragraph.nextSplitWidget) {
                var line = paragraph.nextSplitWidget.firstChild;
                if (line instanceof LineWidget && line.paragraph.equals(this.paragraph)) {
                    return line;
                }
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineWidget.prototype, "previousLine", {
        /**
         * @private
         */
        get: function () {
            var paragraph = this.paragraph;
            var lineIndex = this.indexInOwner;
            var splitParagraph = paragraph.previousSplitWidget;
            if (lineIndex > 0) {
                return paragraph.childWidgets[lineIndex - 1];
            }
            else if (splitParagraph instanceof ParagraphWidget) {
                var line = splitParagraph.lastChild;
                if (line instanceof LineWidget && line.paragraph.equals(this.paragraph)) {
                    return line;
                }
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineWidget.prototype, "isEndsWithPageBreak", {
        /**
         * @private
         */
        get: function () {
            if (this.children.length > 0) {
                var lastElement = this.children[this.children.length - 1];
                if (lastElement instanceof TextElementBox) {
                    return lastElement.isPageBreak;
                }
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    LineWidget.prototype.isFirstLine = function () {
        var index = this.indexInOwner;
        // tslint:disable-next-line:max-line-length
        if (index > -1 && (this.paragraph.previousSplitWidget === undefined || (this.paragraph.previousSplitWidget instanceof ParagraphWidget && this.paragraph.previousSplitWidget.isEndsWithPageBreak))) {
            return index === 0;
        }
        return false;
    };
    /**
     * @private
     */
    LineWidget.prototype.isLastLine = function () {
        var index = this.indexInOwner;
        if (index > -1 && this.paragraph.nextSplitWidget === undefined) {
            return index === this.paragraph.childWidgets.length - 1;
        }
        return false;
    };
    /**
     * @private
     */
    LineWidget.prototype.getOffset = function (inline, index) {
        if (isNullOrUndefined(inline)) {
            return index;
        }
        var textIndex = index;
        var line = inline.line;
        var lineIndex = inline.line.paragraph.childWidgets.indexOf(inline.line);
        var bidi = line.paragraph.bidi;
        if (!bidi) {
            for (var i = 0; i < line.children.length; i++) {
                var inlineElement = line.children[i];
                if (inline === inlineElement) {
                    break;
                }
                if (inlineElement instanceof ListTextElementBox) {
                    continue;
                }
                textIndex += inlineElement.length;
            }
        }
        else {
            var elementInfo = this.getInlineForOffset(textIndex, true, inline);
            textIndex = elementInfo.index;
        }
        return textIndex;
    };
    /**
     * @private
     */
    LineWidget.prototype.getEndOffset = function () {
        var startOffset = 0;
        var count = 0;
        // let line: LineWidget = this.line as LineWidget;
        // let lineIndex: number = thtis.line.paragraph.childWidgets.indexOf(inline.line);
        var bidi = this.paragraph.bidi;
        if (!bidi) {
            for (var i = 0; i < this.children.length; i++) {
                var inlineElement = this.children[i];
                if (inlineElement.length === 0) {
                    continue;
                }
                if (inlineElement instanceof ListTextElementBox) {
                    continue;
                }
                if (inlineElement instanceof TextElementBox || inlineElement instanceof EditRangeStartElementBox
                    || inlineElement instanceof ImageElementBox || inlineElement instanceof EditRangeEndElementBox
                    || inlineElement instanceof BookmarkElementBox || (inlineElement instanceof FieldElementBox
                    && HelperMethods.isLinkedFieldCharacter(inlineElement))) {
                    startOffset = count + inlineElement.length;
                }
                count += inlineElement.length;
            }
        }
        else {
            var elementInfo = this.getInlineForOffset(startOffset, false, this.children[0], true);
            startOffset = elementInfo.index;
        }
        return startOffset;
    };
    /**
     * @private
     * @param offset
     * @param isOffset
     * @param inline
     * @param isEndOffset
     */
    // tslint:disable-next-line:max-line-length
    LineWidget.prototype.getInlineForOffset = function (offset, isOffset, inline, isEndOffset, isPrevOffset, isNxtOffset) {
        var startElement = this.children[this.children.length - 1];
        var endElement;
        var element = startElement;
        var viewer = this.paragraph.bodyWidget.page.viewer;
        var textHelper = viewer.textHelper;
        var isApplied = false;
        var count = 0;
        var lineLength = viewer.selection.getLineLength(this);
        var validOffset = 0;
        while (element) {
            if (!endElement && !(element instanceof TabElementBox && element.text === '\t') &&
                (element instanceof TextElementBox && !textHelper.isRTLText(element.text)
                    || !(element instanceof TextElementBox))) {
                while (element.previousElement && (element.previousElement instanceof TextElementBox
                    && !textHelper.isRTLText(element.previousElement.text) || element.previousElement instanceof FieldElementBox
                    || element.previousElement instanceof BookmarkElementBox
                        && !isNullOrUndefined(element.previousElement.previousElement) &&
                        !(element.previousElement.previousElement instanceof BookmarkElementBox)
                    || element.previousElement instanceof BookmarkElementBox
                        && element.previousElement.previousElement instanceof BookmarkElementBox
                        && !isNullOrUndefined(element.previousElement.previousElement.previousElement)
                    || element instanceof BookmarkElementBox && element.previousElement instanceof BookmarkElementBox
                        && !isNullOrUndefined(element.previousElement.previousElement)
                    || element.previousElement instanceof ListTextElementBox
                    || element.previousElement instanceof EditRangeEndElementBox
                    || element.previousElement instanceof EditRangeStartElementBox
                    || element instanceof ImageElementBox)) {
                    isApplied = true;
                    element = element.previousElement;
                    continue;
                }
                if (element.previousElement && (isApplied
                    || (element.previousElement instanceof TextElementBox && textHelper.isRTLText(element.previousElement.text)))) {
                    endElement = element.previousElement;
                }
                else if (!element.previousElement) {
                    if (element instanceof ListTextElementBox) {
                        break;
                    }
                    endElement = element;
                }
                if (element instanceof ListTextElementBox && endElement) {
                    element = endElement;
                    endElement = undefined;
                }
            }
            if (isOffset && !isNullOrUndefined(inline)) {
                if (inline === element) {
                    return { 'element': element, 'index': offset };
                }
                offset += element.length;
            }
            else if (isEndOffset) {
                offset += element.length;
                if (offset === lineLength) {
                    return { 'element': element, 'index': offset };
                }
            }
            else if (isNxtOffset) {
                if (offset < count + element.length) {
                    if (element instanceof TextElementBox || element instanceof ImageElementBox
                        || (element instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(element))) {
                        return { 'element': element, 'index': (offset > count ? offset : count) + 1 };
                    }
                }
                count += element.length;
            }
            else {
                if (offset <= count + element.length) {
                    return {
                        'element': element, 'index': isPrevOffset ? (offset - 1 === count ? validOffset : offset - 1) : offset - count
                    };
                }
                if (isPrevOffset && (element instanceof TextElementBox || element instanceof ImageElementBox
                    || (element instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(element)))) {
                    validOffset = count + element.length;
                }
                count += element.length;
            }
            if (element.previousElement && (element instanceof TextElementBox && textHelper.isRTLText(element.text) ||
                (element instanceof TabElementBox && element.text === '\t' || (element instanceof BookmarkElementBox
                    && (element instanceof BookmarkElementBox && element.previousElement instanceof BookmarkElementBox
                        && !element.previousElement.previousElement
                        || element.bookmarkType === 1 && !element.previousElement))))) {
                if ((offset === count + 1 || offset > count + 1) && count === lineLength && !element.previousElement) {
                    break;
                }
                element = element.previousElement;
            }
            else {
                if (endElement && (!element.nextElement || element === startElement || element.nextElement instanceof TextElementBox
                    && textHelper.isRTLText(element.nextElement.text) || element.nextElement instanceof ListTextElementBox)) {
                    if (offset === count + 1 && count === lineLength) {
                        break;
                    }
                    element = endElement;
                    endElement = undefined;
                    isApplied = false;
                }
                else {
                    if ((endElement === element || offset === count + 1) && !element.previousElement && count === lineLength) {
                        break;
                    }
                    element = element.nextElement;
                }
            }
        }
        if (isNxtOffset) {
            return { 'element': element, 'index': offset };
        }
        else if (isPrevOffset) {
            return { 'element': element, 'index': -1 };
        }
        else {
            return { 'element': element, 'index': isEndOffset ? offset : 0 };
        }
    };
    /**
     * @private
     */
    LineWidget.prototype.getInline = function (offset, indexInInline, bidi, isInsert) {
        bidi = isNullOrUndefined(bidi) ? this.paragraph.bidi : bidi;
        var inlineElement = undefined;
        var count = 0;
        var isStarted = false;
        if (this.children.length === 0) {
            if (this.previousLine) {
                var elementBox = this.previousLine.children[this.previousLine.children.length - 1];
                if (elementBox instanceof TextElementBox && elementBox.text === '\v') {
                    inlineElement = this.previousLine.children[this.previousLine.children.length - 1];
                    indexInInline = 1;
                    return { 'element': inlineElement, 'index': indexInInline };
                }
            }
        }
        if (!bidi) {
            for (var i = 0; i < this.children.length; i++) {
                inlineElement = this.children[i];
                if (inlineElement instanceof ListTextElementBox) {
                    continue;
                }
                if (!isStarted && (inlineElement instanceof TextElementBox || inlineElement instanceof ImageElementBox
                    || inlineElement instanceof BookmarkElementBox || inlineElement instanceof EditRangeEndElementBox
                    || inlineElement instanceof EditRangeStartElementBox
                    || inlineElement instanceof FieldElementBox
                        && HelperMethods.isLinkedFieldCharacter(inlineElement))) {
                    isStarted = true;
                }
                if (isStarted && offset <= count + inlineElement.length) {
                    // if (inlineElement instanceof BookmarkElementBox) {
                    //     offset += inlineElement.length;
                    //     count += inlineElement.length;
                    //     continue;
                    // }
                    // tslint:disable-next-line:max-line-length
                    if (inlineElement instanceof TextElementBox && (inlineElement.text === ' ' && isInsert)) {
                        var currentElement = this.getNextTextElement(this, i + 1);
                        inlineElement = !isNullOrUndefined(currentElement) ? currentElement : inlineElement;
                        indexInInline = isNullOrUndefined(currentElement) ? (offset - count) : 0;
                        return { 'element': inlineElement, 'index': indexInInline };
                    }
                    else {
                        indexInInline = (offset - count);
                    }
                    return { 'element': inlineElement, 'index': indexInInline };
                }
                count += inlineElement.length;
            }
            if (offset > count) {
                indexInInline = isNullOrUndefined(inlineElement) ? offset : inlineElement.length;
            }
        }
        else {
            var elementInfo = this.getInlineForOffset(offset);
            inlineElement = elementInfo.element;
            indexInInline = elementInfo.index;
        }
        return { 'element': inlineElement, 'index': indexInInline };
    };
    /**
     * Method to retrieve next element
     * @param line
     * @param index
     */
    LineWidget.prototype.getNextTextElement = function (line, index) {
        if (index < line.children.length - 1 && line.children[index]) {
            return line.children[index];
        }
        return null;
    };
    /**
     * @private
     */
    LineWidget.prototype.getHierarchicalIndex = function (hierarchicalIndex) {
        var node = this;
        hierarchicalIndex = node.paragraph.childWidgets.indexOf(node) + ';' + hierarchicalIndex;
        if (node.paragraph instanceof BlockWidget) {
            return node.paragraph.getHierarchicalIndex(hierarchicalIndex);
        }
        return hierarchicalIndex;
    };
    /**
     * @private
     */
    LineWidget.prototype.clone = function () {
        var line = new LineWidget(undefined);
        for (var j = 0; j < this.children.length; j++) {
            var element = this.children[j];
            var clone = element.clone();
            line.children.push(clone);
            clone.line = line;
        }
        line.width = this.width;
        line.height = this.height;
        return line;
    };
    /**
     * @private
     */
    LineWidget.prototype.destroy = function () {
        if (!isNullOrUndefined(this.children)) {
            for (var i = 0; i < this.children.length; i++) {
                this.children[i].destroy();
            }
            this.children = [];
        }
        this.children = undefined;
        if (this.paragraph) {
            this.paragraph.removeChild(this.indexInOwner);
        }
        this.paragraph = undefined;
        this.x = undefined;
        this.y = undefined;
        this.width = undefined;
        this.height = undefined;
    };
    return LineWidget;
}());
/**
 * @private
 */
var ElementBox = /** @__PURE__ @class */ (function () {
    /**
     * Initialize the constructor of ElementBox
     */
    function ElementBox() {
        /**
         * @private
         */
        this.x = 0;
        /**
         * @private
         */
        this.y = 0;
        /**
         * @private
         */
        this.width = 0;
        /**
         * @private
         */
        this.height = 0;
        /**
         * @private
         */
        this.margin = new Margin(0, 0, 0, 0);
        /**
         * @private
         */
        this.characterFormat = undefined;
        /**
         * @private
         */
        this.isRightToLeft = false;
        /**
         * @private
         */
        this.canTrigger = false;
        /**
         * @private
         */
        this.ischangeDetected = false;
        /**
         * @private
         */
        this.isVisible = false;
        /**
         * @private
         */
        this.isSpellChecked = false;
        this.characterFormat = new WCharacterFormat(this);
        this.margin = new Margin(0, 0, 0, 0);
    }
    Object.defineProperty(ElementBox.prototype, "isPageBreak", {
        /**
         * @private
         */
        get: function () {
            if (this instanceof TextElementBox) {
                return this.text === '\f';
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ElementBox.prototype.linkFieldCharacter = function (viewer) {
        if (!(this instanceof FieldElementBox)) {
            return;
        }
        if (this.fieldType === 0) {
            var fieldBegin = this;
            if (isNullOrUndefined(fieldBegin.fieldEnd)) {
                this.linkFieldTraversingForward(this.line, fieldBegin, fieldBegin);
                if (viewer.fields.indexOf(fieldBegin) === -1) {
                    viewer.fields.push(fieldBegin);
                }
            }
        }
        else if (this.fieldType === 2) {
            var fieldSeparator = this;
            //Links the field begin for the current separator.
            if (isNullOrUndefined(fieldSeparator.fieldBegin)) {
                this.linkFieldTraversingBackwardSeparator(this.line, fieldSeparator, fieldSeparator);
            }
            if (!isNullOrUndefined(fieldSeparator.fieldBegin)) {
                fieldSeparator.fieldBegin.fieldSeparator = fieldSeparator;
                //Links to field end traversing from field separator.
                var isFieldEnd = this.linkFieldTraversingForward(this.line, fieldSeparator.fieldBegin, fieldSeparator);
                if (isNullOrUndefined(fieldSeparator.fieldEnd) && isFieldEnd) {
                    fieldSeparator.fieldEnd = fieldSeparator.fieldBegin.fieldEnd;
                }
                if (fieldSeparator.fieldEnd) {
                    fieldSeparator.fieldEnd.fieldSeparator = fieldSeparator;
                }
            }
        }
        else {
            var fieldEnd = this;
            //Links the field begin and separator for the current end.
            if (isNullOrUndefined(fieldEnd.fieldBegin)) {
                this.linkFieldTraversingBackward(this.line, fieldEnd, fieldEnd);
            }
        }
    };
    /**
     * @private
     */
    ElementBox.prototype.linkFieldTraversingBackward = function (line, fieldEnd, previousNode) {
        var k = line.children.length - 1;
        if (line.children.indexOf(previousNode) > -1) {
            k = line.children.indexOf(previousNode) - 1;
        }
        for (var j = k; j >= 0; j--) {
            var childNode = line.children[j];
            if (childNode instanceof FieldElementBox) {
                if (childNode.fieldType === 0) {
                    if (isNullOrUndefined(childNode.fieldEnd)) {
                        fieldEnd.fieldBegin = childNode;
                        if (isNullOrUndefined(childNode.fieldEnd)) {
                            childNode.fieldEnd = fieldEnd;
                        }
                        if (fieldEnd.fieldSeparator && isNullOrUndefined(fieldEnd.fieldSeparator.fieldBegin)) {
                            fieldEnd.fieldSeparator.fieldBegin = childNode;
                            if (isNullOrUndefined(childNode.fieldSeparator)) {
                                childNode.fieldSeparator = fieldEnd.fieldSeparator;
                            }
                        }
                    }
                    return !isNullOrUndefined(fieldEnd.fieldBegin);
                }
                else if (childNode.fieldType === 2 && isNullOrUndefined(childNode.fieldEnd)) {
                    fieldEnd.fieldSeparator = childNode;
                    childNode.fieldEnd = fieldEnd;
                    if (!isNullOrUndefined(childNode.fieldBegin)) {
                        fieldEnd.fieldBegin = childNode.fieldBegin;
                    }
                }
            }
        }
        if (line.previousLine) {
            this.linkFieldTraversingBackward(line.previousLine, fieldEnd, this);
        }
        else if (line.paragraph.previousRenderedWidget instanceof ParagraphWidget
            && line.paragraph.previousRenderedWidget.childWidgets.length > 0) {
            var prevParagraph = line.paragraph.previousRenderedWidget;
            // tslint:disable-next-line:max-line-length
            this.linkFieldTraversingBackward(prevParagraph.childWidgets[prevParagraph.childWidgets.length - 1], fieldEnd, this);
        }
        return true;
    };
    /**
     * @private
     */
    ElementBox.prototype.linkFieldTraversingForward = function (line, fieldBegin, previousNode) {
        var i = 0;
        if (line.children.indexOf(previousNode) > -1) {
            i = line.children.indexOf(previousNode) + 1;
        }
        for (var j = i; j < line.children.length; j++) {
            var node = line.children[j];
            if (node instanceof FieldElementBox) {
                if (node.fieldType === 1) {
                    if (isNullOrUndefined(node.fieldBegin)) {
                        fieldBegin.fieldEnd = node;
                    }
                    if (fieldBegin.fieldEnd && isNullOrUndefined(fieldBegin.fieldEnd.fieldBegin)) {
                        fieldBegin.fieldEnd.fieldBegin = fieldBegin;
                    }
                    return true;
                }
                else if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                    if (node.fieldType === 2 && isNullOrUndefined(node.fieldBegin)) {
                        fieldBegin.fieldSeparator = node;
                        if (!isNullOrUndefined(node.fieldEnd)) {
                            fieldBegin.fieldEnd = node.fieldEnd;
                            return true;
                        }
                    }
                    else {
                        return false;
                    }
                }
            }
        }
        if (line.nextLine) {
            this.linkFieldTraversingForward(line.nextLine, fieldBegin, this);
        }
        else if (line.paragraph.nextRenderedWidget instanceof ParagraphWidget
            && line.paragraph.nextRenderedWidget.childWidgets.length > 0) {
            this.linkFieldTraversingForward(line.paragraph.nextRenderedWidget.childWidgets[0], fieldBegin, this);
        }
        return true;
    };
    /**
     * @private
     */
    ElementBox.prototype.linkFieldTraversingBackwardSeparator = function (line, fieldSeparator, previousNode) {
        var index = line.children.length - 1;
        if (line.children.indexOf(previousNode) > -1) {
            index = line.children.indexOf(previousNode) - 1;
        }
        for (var i = index; i >= 0; i--) {
            var childElement = line.children[i];
            if (childElement instanceof FieldElementBox) {
                if (childElement instanceof FieldElementBox && childElement.fieldType === 0) {
                    if (isNullOrUndefined(childElement.fieldSeparator)) {
                        fieldSeparator.fieldBegin = childElement;
                    }
                    return !isNullOrUndefined(fieldSeparator.fieldBegin);
                }
            }
        }
        if (line.previousLine) {
            this.linkFieldTraversingBackwardSeparator(line.previousLine, fieldSeparator, this);
        }
        else if (line.paragraph.previousRenderedWidget instanceof ParagraphWidget
            && line.paragraph.previousRenderedWidget.childWidgets.length > 0) {
            // tslint:disable-next-line:max-line-length
            line = line.paragraph.previousRenderedWidget.childWidgets[line.paragraph.previousRenderedWidget.childWidgets.length - 1];
            this.linkFieldTraversingBackwardSeparator(line, fieldSeparator, this);
        }
        else {
            return true;
        }
        return true;
    };
    Object.defineProperty(ElementBox.prototype, "length", {
        /**
         * @private
         */
        get: function () {
            return this.getLength();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementBox.prototype, "indexInOwner", {
        /**
         * @private
         */
        get: function () {
            return this.line instanceof LineWidget && this.line.children ? this.line.children.indexOf(this) : -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementBox.prototype, "previousElement", {
        /**
         * @private
         */
        get: function () {
            var index = this.indexInOwner;
            if (index > 0 && index < this.line.children.length) {
                return this.line.children[index - 1];
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementBox.prototype, "nextElement", {
        /**
         * @private
         */
        get: function () {
            var index = this.indexInOwner;
            if (index > -1 && index < this.line.children.length - 1) {
                return this.line.children[index + 1];
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementBox.prototype, "nextNode", {
        /**
         * @private
         */
        get: function () {
            var index = this.line.children.indexOf(this);
            var lineIndex = this.line.paragraph.childWidgets.indexOf(this.line);
            if (index < this.line.children.length - 1) {
                return this.line.children[index + 1];
            }
            else if (lineIndex < this.line.paragraph.childWidgets.length - 1) {
                return this.line.paragraph.childWidgets[lineIndex + 1].children[0];
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementBox.prototype, "previousNode", {
        /**
         * @private
         */
        get: function () {
            var index = this.line.children.indexOf(this);
            var lineIndex = this.line.paragraph.childWidgets.indexOf(this.line);
            if (index > 0) {
                return this.line.children[index - 1];
            }
            else if (lineIndex > 0) {
                var lineWidget = this.line.paragraph.childWidgets[lineIndex - 1];
                return lineWidget.children[lineWidget.children.length - 1];
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementBox.prototype, "paragraph", {
        /**
         * @private
         */
        get: function () {
            if (this.line) {
                return this.line.paragraph;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ElementBox.prototype.destroy = function () {
        if (!isNullOrUndefined(this.line) && this.line.children && this.line.children.indexOf(this) > -1) {
            var index = this.line.children.indexOf(this);
            this.line.children.splice(index, 1);
        }
        this.line = undefined;
        if (this.characterFormat) {
            this.characterFormat.destroy();
        }
        this.characterFormat = undefined;
        if (this.margin) {
            this.margin.destroy();
        }
        this.margin = undefined;
        this.x = undefined;
        this.y = undefined;
        this.width = undefined;
        this.height = undefined;
    };
    /**
     * @private
     */
    ElementBox.objectCharacter = String.fromCharCode(65532);
    return ElementBox;
}());
/**
 * @private
 */
var FieldElementBox = /** @__PURE__ @class */ (function (_super) {
    __extends$1(FieldElementBox, _super);
    function FieldElementBox(type) {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.fieldType = 0;
        /**
         * @private
         */
        _this.fieldCodeType = '';
        /**
         * @private
         */
        _this.hasFieldEnd = false;
        _this.fieldBeginInternal = undefined;
        _this.fieldSeparatorInternal = undefined;
        _this.fieldEndInternal = undefined;
        _this.fieldType = type;
        return _this;
    }
    Object.defineProperty(FieldElementBox.prototype, "fieldBegin", {
        get: function () {
            return this.fieldBeginInternal;
        },
        set: function (field) {
            this.fieldBeginInternal = field;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FieldElementBox.prototype, "fieldSeparator", {
        get: function () {
            return this.fieldSeparatorInternal;
        },
        set: function (field) {
            this.fieldSeparatorInternal = field;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FieldElementBox.prototype, "fieldEnd", {
        get: function () {
            return this.fieldEndInternal;
        },
        set: function (field) {
            this.fieldEndInternal = field;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    FieldElementBox.prototype.getLength = function () {
        return 1;
    };
    /**
     * @private
     */
    FieldElementBox.prototype.clone = function () {
        var field = new FieldElementBox(this.fieldType);
        field.characterFormat.copyFormat(this.characterFormat);
        if (this.margin) {
            field.margin = this.margin.clone();
        }
        field.width = this.width;
        field.height = this.height;
        field.fieldCodeType = this.fieldCodeType;
        return field;
    };
    /**
     * @private
     */
    FieldElementBox.prototype.destroy = function () {
        this.fieldType = undefined;
        this.hasFieldEnd = undefined;
        this.fieldBeginInternal = undefined;
        this.fieldEndInternal = undefined;
        this.fieldSeparatorInternal = undefined;
        _super.prototype.destroy.call(this);
    };
    return FieldElementBox;
}(ElementBox));
/**
 * @private
 */
var TextElementBox = /** @__PURE__ @class */ (function (_super) {
    __extends$1(TextElementBox, _super);
    function TextElementBox() {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.baselineOffset = 0;
        /**
         * @private
         */
        _this.text = '';
        /**
         * @private
         */
        _this.ignoreOnceItems = [];
        /**
         * @private
         */
        _this.istextCombined = false;
        _this.errorCollection = [];
        return _this;
    }
    /**
     * @private
     */
    TextElementBox.prototype.getLength = function () {
        return this.text ? this.text.length : 0;
    };
    /**
     * @private
     */
    TextElementBox.prototype.clone = function () {
        var span = new TextElementBox();
        span.characterFormat.copyFormat(this.characterFormat);
        span.text = this.text;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.baselineOffset = this.baselineOffset;
        span.width = this.width;
        span.height = this.height;
        return span;
    };
    /**
     * @private
     */
    TextElementBox.prototype.destroy = function () {
        this.text = undefined;
        _super.prototype.destroy.call(this);
    };
    return TextElementBox;
}(ElementBox));
/**
 * @private
 */
var ErrorTextElementBox = /** @__PURE__ @class */ (function (_super) {
    __extends$1(ErrorTextElementBox, _super);
    function ErrorTextElementBox() {
        var _this = _super.call(this) || this;
        _this.startIn = undefined;
        _this.endIn = undefined;
        return _this;
    }
    Object.defineProperty(ErrorTextElementBox.prototype, "start", {
        get: function () {
            return this.startIn;
        },
        set: function (value) {
            this.startIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ErrorTextElementBox.prototype, "end", {
        get: function () {
            return this.endIn;
        },
        set: function (value) {
            this.endIn = value;
        },
        enumerable: true,
        configurable: true
    });
    ErrorTextElementBox.prototype.destroy = function () {
        this.start = undefined;
        this.end = undefined;
    };
    return ErrorTextElementBox;
}(TextElementBox));
/**
 * @private
 */
var FieldTextElementBox = /** @__PURE__ @class */ (function (_super) {
    __extends$1(FieldTextElementBox, _super);
    function FieldTextElementBox() {
        var _this = _super.call(this) || this;
        _this.fieldText = '';
        return _this;
    }
    Object.defineProperty(FieldTextElementBox.prototype, "text", {
        get: function () {
            return this.fieldText;
        },
        set: function (value) {
            this.fieldText = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    FieldTextElementBox.prototype.clone = function () {
        var span = new FieldTextElementBox();
        span.characterFormat.copyFormat(this.characterFormat);
        span.fieldBegin = this.fieldBegin;
        span.text = this.text;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.width = this.width;
        span.height = this.height;
        return span;
    };
    return FieldTextElementBox;
}(TextElementBox));
/**
 * @private
 */
var TabElementBox = /** @__PURE__ @class */ (function (_super) {
    __extends$1(TabElementBox, _super);
    function TabElementBox() {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.tabText = '';
        /**
         * @private
         */
        _this.tabLeader = 'None';
        return _this;
    }
    /**
     * @private
     */
    TabElementBox.prototype.destroy = function () {
        this.tabText = undefined;
        this.tabLeader = undefined;
    };
    /**
     * @private
     */
    TabElementBox.prototype.clone = function () {
        var span = new TabElementBox();
        span.characterFormat.copyFormat(this.characterFormat);
        span.tabText = this.tabText;
        span.tabLeader = this.tabLeader;
        span.text = this.text;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.width = this.width;
        span.height = this.height;
        return span;
    };
    return TabElementBox;
}(TextElementBox));
/**
 * @private
 */
var BookmarkElementBox = /** @__PURE__ @class */ (function (_super) {
    __extends$1(BookmarkElementBox, _super);
    function BookmarkElementBox(type) {
        var _this = _super.call(this) || this;
        _this.bookmarkTypeIn = 0;
        _this.refereneceIn = undefined;
        _this.nameIn = '';
        _this.bookmarkTypeIn = type;
        return _this;
    }
    Object.defineProperty(BookmarkElementBox.prototype, "bookmarkType", {
        /**
         * @private
         */
        get: function () {
            return this.bookmarkTypeIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BookmarkElementBox.prototype, "name", {
        /**
         * @private
         */
        get: function () {
            return this.nameIn;
        },
        /**
         * @private
         */
        set: function (name) {
            this.nameIn = name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BookmarkElementBox.prototype, "reference", {
        /**
         * @private
         */
        get: function () {
            return this.refereneceIn;
        },
        /**
         * @private
         */
        set: function (reference) {
            this.refereneceIn = reference;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    BookmarkElementBox.prototype.getLength = function () {
        return 1;
    };
    /**
     * @private
     */
    BookmarkElementBox.prototype.destroy = function () {
        this.name = undefined;
        this.reference = undefined;
        this.bookmarkTypeIn = undefined;
    };
    /**
     * Clones the bookmark element box.
     * @param element - book mark element
     */
    /**
     * @private
     */
    BookmarkElementBox.prototype.clone = function () {
        var span = new BookmarkElementBox(this.bookmarkType);
        span.name = this.name;
        span.reference = this.reference;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.width = this.width;
        span.height = this.height;
        return span;
    };
    return BookmarkElementBox;
}(ElementBox));
/**
 * @private
 */
var ImageElementBox = /** @__PURE__ @class */ (function (_super) {
    __extends$1(ImageElementBox, _super);
    function ImageElementBox(isInlineImage) {
        var _this = _super.call(this) || this;
        _this.imageStr = '';
        _this.imgElement = undefined;
        _this.isInlineImageIn = true;
        /**
         * @private
         */
        _this.isMetaFile = false;
        _this.isInlineImageIn = isInlineImage;
        return _this;
    }
    Object.defineProperty(ImageElementBox.prototype, "isInlineImage", {
        /**
         * @private
         */
        get: function () {
            return this.isInlineImageIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageElementBox.prototype, "element", {
        /**
         * @private
         */
        get: function () {
            if (isNullOrUndefined(this.imgElement)) {
                this.imgElement = document.createElement('img');
            }
            return this.imgElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageElementBox.prototype, "length", {
        /**
         * @private
         */
        get: function () {
            return 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageElementBox.prototype, "imageString", {
        /**
         * @private
         */
        get: function () {
            return this.imageStr;
        },
        /**
         * @private
         */
        set: function (value) {
            this.imageStr = value;
            if (!isNullOrUndefined(value)) {
                this.element.src = this.imageStr;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ImageElementBox.prototype.getLength = function () {
        return 1;
    };
    /**
     * @private
     */
    ImageElementBox.prototype.clone = function () {
        var image = new ImageElementBox(this.isInlineImage);
        image.characterFormat.copyFormat(this.characterFormat);
        image.imageString = this.imageString;
        image.isMetaFile = this.isMetaFile;
        image.width = this.width;
        image.height = this.height;
        if (this.margin) {
            image.margin = this.margin.clone();
        }
        return image;
    };
    /**
     * @private
     */
    ImageElementBox.prototype.destroy = function () {
        this.imgElement = undefined;
        this.imageString = undefined;
        this.isInlineImageIn = undefined;
        _super.prototype.destroy.call(this);
    };
    return ImageElementBox;
}(ElementBox));
/**
 * @private
 */
var ListTextElementBox = /** @__PURE__ @class */ (function (_super) {
    __extends$1(ListTextElementBox, _super);
    function ListTextElementBox(listLevel, isListFollowCharacter) {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.baselineOffset = 0;
        /**
         * @private
         */
        _this.isFollowCharacter = false;
        _this.listLevel = listLevel;
        _this.isFollowCharacter = isListFollowCharacter;
        return _this;
    }
    /**
     * @private
     */
    ListTextElementBox.prototype.getLength = function () {
        return this.text ? this.text.length : 0;
    };
    /**
     * @private
     */
    ListTextElementBox.prototype.clone = function () {
        var list = new ListTextElementBox(this.listLevel, this.isFollowCharacter);
        list.text = this.text;
        list.baselineOffset = this.baselineOffset;
        if (this.margin) {
            list.margin = this.margin.clone();
        }
        list.width = this.width;
        list.height = this.height;
        return list;
    };
    /**
     * @private
     */
    ListTextElementBox.prototype.destroy = function () {
        this.text = undefined;
        _super.prototype.destroy.call(this);
    };
    return ListTextElementBox;
}(ElementBox));
/**
 * @private
 */
var EditRangeEndElementBox = /** @__PURE__ @class */ (function (_super) {
    __extends$1(EditRangeEndElementBox, _super);
    function EditRangeEndElementBox() {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.editRangeStart = undefined;
        _this.editRangeId = -1;
        return _this;
    }
    /**
     * @private
     */
    EditRangeEndElementBox.prototype.getLength = function () {
        return 1;
    };
    /**
     * @private
     */
    EditRangeEndElementBox.prototype.destroy = function () {
        this.editRangeStart = undefined;
    };
    /**
     * @private
     */
    EditRangeEndElementBox.prototype.clone = function () {
        var end = new EditRangeEndElementBox();
        end.editRangeStart = this.editRangeStart;
        end.editRangeId = this.editRangeId;
        return end;
    };
    return EditRangeEndElementBox;
}(ElementBox));
/**
 * @private
 */
var EditRangeStartElementBox = /** @__PURE__ @class */ (function (_super) {
    __extends$1(EditRangeStartElementBox, _super);
    function EditRangeStartElementBox() {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.columnFirst = -1;
        /**
         * @private
         */
        _this.columnLast = -1;
        /**
         * @private
         */
        _this.user = '';
        /**
         * @private
         */
        _this.group = '';
        _this.editRangeId = -1;
        return _this;
    }
    /**
     * @private
     */
    EditRangeStartElementBox.prototype.getLength = function () {
        return 1;
    };
    /**
     * @private
     */
    EditRangeStartElementBox.prototype.destroy = function () {
        this.user = undefined;
        this.columnFirst = undefined;
        this.columnLast = undefined;
    };
    /**
     * @private
     */
    EditRangeStartElementBox.prototype.clone = function () {
        var start = new EditRangeStartElementBox();
        start.columnFirst = this.columnFirst;
        start.columnLast = this.columnLast;
        start.user = this.user;
        start.group = this.group;
        start.editRangeEnd = this.editRangeEnd;
        start.editRangeId = this.editRangeId;
        return start;
    };
    return EditRangeStartElementBox;
}(ElementBox));
/**
 * @private
 */
var ChartElementBox = /** @__PURE__ @class */ (function (_super) {
    __extends$1(ChartElementBox, _super);
    /**
     * @private
     */
    function ChartElementBox() {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.chartTitle = '';
        /**
         * @private
         */
        _this.chartType = '';
        /**
         * @private
         */
        _this.chartElement = undefined;
        /**
         * @private
         */
        _this.chartCategory = [];
        /**
         * @private
         */
        _this.chartSeries = [];
        _this.chartArea = new ChartArea();
        _this.chartPlotArea = new ChartArea();
        _this.chartTitleArea = new ChartTitleArea();
        _this.chartLegend = new ChartLegend();
        _this.chartPrimaryCategoryAxis = new ChartCategoryAxis();
        _this.chartPrimaryValueAxis = new ChartCategoryAxis();
        _this.chartDataTable = new ChartDataTable();
        return _this;
    }
    /**
     * @private
     */
    ChartElementBox.prototype.getLength = function () {
        return 1;
    };
    Object.defineProperty(ChartElementBox.prototype, "title", {
        /**
         * @private
         */
        get: function () {
            return this.chartTitle;
        },
        /**
         * @private
         */
        set: function (value) {
            this.chartTitle = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartElementBox.prototype, "type", {
        /**
         * @private
         */
        get: function () {
            return this.chartType;
        },
        /**
         * @private
         */
        set: function (value) {
            this.chartType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartElementBox.prototype, "chartGapWidth", {
        /**
         * @private
         */
        get: function () {
            return this.gapWidth;
        },
        /**
         * @private
         */
        set: function (value) {
            this.gapWidth = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartElementBox.prototype, "chartOverlap", {
        /**
         * @private
         */
        get: function () {
            return this.overlap;
        },
        /**
         * @private
         */
        set: function (value) {
            this.overlap = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartElementBox.prototype, "targetElement", {
        /**
         * @private
         */
        get: function () {
            if (isNullOrUndefined(this.div)) {
                this.div = createElement('div');
            }
            return this.div;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartElementBox.prototype, "officeChart", {
        /**
         * @private
         */
        get: function () {
            return this.officeChartInternal;
        },
        /**
         * @private
         */
        set: function (value) {
            if (value) {
                this.officeChartInternal = value;
                this.officeChartInternal.chart.loaded = this.onChartLoaded.bind(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    ChartElementBox.prototype.onChartLoaded = function () {
        var _this = this;
        this.officeChart.convertChartToImage(this.officeChart.chart, this.width, this.height).then(function (dataURL) {
            _this.imageString = dataURL;
        });
    };
    /**
     * @private
     */
    ChartElementBox.prototype.clone = function () {
        var chart = new ChartElementBox();
        chart.chartTitle = this.chartTitle;
        chart.chartType = this.chartType;
        chart.height = this.height;
        chart.width = this.width;
        chart.gapWidth = this.gapWidth;
        chart.overlap = this.overlap;
        for (var i = 0; i < this.chartCategory.length; i++) {
            var chartCategory = this.chartCategory[i].clone();
            chart.chartCategory.push(chartCategory);
        }
        for (var i = 0; i < this.chartSeries.length; i++) {
            var series = this.chartSeries[i].clone();
            chart.chartSeries.push(series);
        }
        chart.chartArea = this.chartArea.clone();
        chart.chartPlotArea = this.chartPlotArea.clone();
        chart.chartLegend = this.chartLegend.clone();
        chart.chartTitleArea = this.chartTitleArea.clone();
        chart.chartPrimaryCategoryAxis = this.chartPrimaryCategoryAxis.clone();
        chart.chartPrimaryValueAxis = this.chartPrimaryValueAxis.clone();
        chart.chartDataTable = this.chartDataTable.clone();
        return chart;
    };
    /**
     * @private
     */
    ChartElementBox.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (this.officeChartInternal) {
            this.officeChartInternal.chart.loaded = undefined;
            this.officeChartInternal.destroy();
            this.officeChartInternal = undefined;
        }
        if (this.div) {
            this.div = undefined;
        }
        this.chartTitle = undefined;
        this.chartType = undefined;
        this.chartArea = undefined;
        this.chartPlotArea = undefined;
        this.chartCategory = [];
        this.chartSeries = [];
        this.chartTitleArea = undefined;
        this.chartLegend = undefined;
        this.chartPrimaryCategoryAxis = undefined;
        this.chartPrimaryValueAxis = undefined;
        this.chartDataTable = undefined;
        this.chartElement = undefined;
    };
    return ChartElementBox;
}(ImageElementBox));
/**
 * @private
 */
var ChartArea = /** @__PURE__ @class */ (function () {
    function ChartArea() {
    }
    Object.defineProperty(ChartArea.prototype, "chartForeColor", {
        /**
         * @private
         */
        get: function () {
            return this.foreColor;
        },
        /**
         * @private
         */
        set: function (value) {
            this.foreColor = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ChartArea.prototype.clone = function () {
        var chart = new ChartArea();
        chart.foreColor = this.foreColor;
        return chart;
    };
    /**
     * @private
     */
    ChartArea.prototype.destroy = function () {
        this.foreColor = undefined;
    };
    return ChartArea;
}());
/**
 * @private
 */
var ChartCategory = /** @__PURE__ @class */ (function () {
    function ChartCategory() {
        /**
         * @private
         */
        this.categoryXName = '';
        /**
         * @private
         */
        this.chartData = [];
    }
    Object.defineProperty(ChartCategory.prototype, "xName", {
        /**
         * @private
         */
        get: function () {
            return this.categoryXName;
        },
        /**
         * @private
         */
        set: function (value) {
            this.categoryXName = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ChartCategory.prototype.clone = function () {
        var chart = new ChartCategory();
        chart.categoryXName = this.categoryXName;
        for (var i = 0; i < this.chartData.length; i++) {
            var chartData = this.chartData[i].clone();
            chart.chartData.push(chartData);
        }
        return chart;
    };
    /**
     * @private
     */
    ChartCategory.prototype.destroy = function () {
        this.categoryXName = undefined;
        this.chartData = [];
    };
    return ChartCategory;
}());
/**
 * @private
 */
var ChartData = /** @__PURE__ @class */ (function () {
    function ChartData() {
    }
    Object.defineProperty(ChartData.prototype, "yAxisValue", {
        /**
         * @private
         */
        get: function () {
            return this.yValue;
        },
        /**
         * @private
         */
        set: function (value) {
            this.yValue = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartData.prototype, "xAxisValue", {
        /**
         * @private
         */
        get: function () {
            return this.xValue;
        },
        /**
         * @private
         */
        set: function (value) {
            this.xValue = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartData.prototype, "bubbleSize", {
        /**
         * @private
         */
        get: function () {
            return this.size;
        },
        /**
         * @private
         */
        set: function (value) {
            this.size = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ChartData.prototype.clone = function () {
        var chart = new ChartData();
        chart.yValue = this.yValue;
        chart.xValue = this.xValue;
        chart.size = this.size;
        return chart;
    };
    /**
     * @private
     */
    ChartData.prototype.destroy = function () {
        this.xValue = undefined;
        this.yValue = undefined;
        this.size = undefined;
    };
    return ChartData;
}());
/**
 * @private
 */
var ChartLegend = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function ChartLegend() {
        this.chartTitleArea = new ChartTitleArea();
    }
    Object.defineProperty(ChartLegend.prototype, "chartLegendPostion", {
        /**
         * @private
         */
        get: function () {
            return this.legendPostion;
        },
        /**
         * @private
         */
        set: function (value) {
            this.legendPostion = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ChartLegend.prototype.clone = function () {
        var chart = new ChartLegend();
        chart.legendPostion = this.legendPostion;
        chart.chartTitleArea = this.chartTitleArea.clone();
        return chart;
    };
    /**
     * @private
     */
    ChartLegend.prototype.destroy = function () {
        this.legendPostion = undefined;
        this.chartTitleArea = undefined;
    };
    return ChartLegend;
}());
/**
 * @private
 */
var ChartSeries = /** @__PURE__ @class */ (function () {
    function ChartSeries() {
        /**
         * @private
         */
        this.chartDataFormat = [];
        /**
         * @private
         */
        this.trendLines = [];
        this.errorBar = new ChartErrorBar();
        this.dataLabels = new ChartDataLabels();
        this.seriesFormat = new ChartSeriesFormat();
    }
    Object.defineProperty(ChartSeries.prototype, "seriesName", {
        /**
         * @private
         */
        get: function () {
            return this.name;
        },
        /**
         * @private
         */
        set: function (value) {
            this.name = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartSeries.prototype, "firstSliceAngle", {
        /**
         * @private
         */
        get: function () {
            return this.sliceAngle;
        },
        /**
         * @private
         */
        set: function (value) {
            this.sliceAngle = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartSeries.prototype, "doughnutHoleSize", {
        /**
         * @private
         */
        get: function () {
            return this.holeSize;
        },
        /**
         * @private
         */
        set: function (value) {
            this.holeSize = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ChartSeries.prototype.clone = function () {
        var chart = new ChartSeries();
        chart.name = this.name;
        chart.sliceAngle = this.sliceAngle;
        chart.holeSize = this.holeSize;
        chart.errorBar = this.errorBar.clone();
        chart.dataLabels = this.dataLabels.clone();
        chart.seriesFormat = this.seriesFormat.clone();
        for (var i = 0; i < this.chartDataFormat.length; i++) {
            var format = (this.chartDataFormat[i].clone());
            chart.chartDataFormat.push(format);
        }
        for (var i = 0; i < this.trendLines.length; i++) {
            var trendLine = (this.trendLines[i].clone());
            chart.trendLines.push(trendLine);
        }
        return chart;
    };
    /**
     * @private
     */
    ChartSeries.prototype.destroy = function () {
        this.name = undefined;
        this.errorBar = undefined;
        this.trendLines = undefined;
        this.chartDataFormat = [];
    };
    return ChartSeries;
}());
/**
 * @private
 */
var ChartErrorBar = /** @__PURE__ @class */ (function () {
    function ChartErrorBar() {
    }
    Object.defineProperty(ChartErrorBar.prototype, "errorType", {
        /**
         * @private
         */
        get: function () {
            return this.type;
        },
        /**
         * @private
         */
        set: function (value) {
            this.type = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartErrorBar.prototype, "errorDirection", {
        /**
         * @private
         */
        get: function () {
            return this.direction;
        },
        /**
         * @private
         */
        set: function (value) {
            this.direction = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartErrorBar.prototype, "errorEndStyle", {
        /**
         * @private
         */
        get: function () {
            return this.endStyle;
        },
        /**
         * @private
         */
        set: function (value) {
            this.endStyle = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartErrorBar.prototype, "numberValue", {
        get: function () {
            return this.errorValue;
        },
        /**
         * @private
         */
        set: function (value) {
            this.errorValue = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ChartErrorBar.prototype.clone = function () {
        var chart = new ChartErrorBar();
        chart.type = this.type;
        chart.errorDirection = this.errorDirection;
        chart.endStyle = this.endStyle;
        chart.errorValue = this.errorValue;
        return chart;
    };
    /**
     * @private
     */
    ChartErrorBar.prototype.destroy = function () {
        this.type = undefined;
        this.errorDirection = undefined;
        this.endStyle = undefined;
    };
    return ChartErrorBar;
}());
/**
 * @private
 */
var ChartSeriesFormat = /** @__PURE__ @class */ (function () {
    function ChartSeriesFormat() {
    }
    Object.defineProperty(ChartSeriesFormat.prototype, "markerStyle", {
        /**
         * @private
         */
        get: function () {
            return this.style;
        },
        /**
         * @private
         */
        set: function (value) {
            this.style = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartSeriesFormat.prototype, "markerColor", {
        /**
         * @private
         */
        get: function () {
            return this.color;
        },
        /**
         * @private
         */
        set: function (value) {
            this.color = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartSeriesFormat.prototype, "numberValue", {
        /**
         * @private
         */
        get: function () {
            return this.size;
        },
        /**
         * @private
         */
        set: function (value) {
            this.size = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ChartSeriesFormat.prototype.clone = function () {
        var chart = new ChartSeriesFormat();
        chart.style = this.style;
        chart.color = this.color;
        chart.size = this.size;
        return chart;
    };
    /**
     * @private
     */
    ChartSeriesFormat.prototype.destroy = function () {
        this.style = undefined;
        this.color = undefined;
        this.size = undefined;
    };
    return ChartSeriesFormat;
}());
/**
 * @private
 */
var ChartDataLabels = /** @__PURE__ @class */ (function () {
    function ChartDataLabels() {
    }
    Object.defineProperty(ChartDataLabels.prototype, "labelPosition", {
        /**
         * @private
         */
        get: function () {
            return this.position;
        },
        /**
         * @private
         */
        set: function (value) {
            this.position = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartDataLabels.prototype, "fontName", {
        /**
         * @private
         */
        get: function () {
            return this.name;
        },
        /**
         * @private
         */
        set: function (value) {
            this.name = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartDataLabels.prototype, "fontColor", {
        /**
         * @private
         */
        get: function () {
            return this.color;
        },
        /**
         * @private
         */
        set: function (value) {
            this.color = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartDataLabels.prototype, "fontSize", {
        /**
         * @private
         */
        get: function () {
            return this.size;
        },
        /**
         * @private
         */
        set: function (value) {
            this.size = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartDataLabels.prototype, "isLegendKey", {
        /**
         * @private
         */
        get: function () {
            return this.isLegend;
        },
        /**
         * @private
         */
        set: function (value) {
            this.isLegend = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartDataLabels.prototype, "isBubbleSize", {
        /**
         * @private
         */
        get: function () {
            return this.isBubble;
        },
        /**
         * @private
         */
        set: function (value) {
            this.isBubble = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartDataLabels.prototype, "isCategoryName", {
        /**
         * @private
         */
        get: function () {
            return this.isCategory;
        },
        /**
         * @private
         */
        set: function (value) {
            this.isCategory = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartDataLabels.prototype, "isSeriesName", {
        /**
         * @private
         */
        get: function () {
            return this.isSeries;
        },
        /**
         * @private
         */
        set: function (value) {
            this.isSeries = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartDataLabels.prototype, "isValue", {
        /**
         * @private
         */
        get: function () {
            return this.isValueEnabled;
        },
        /**
         * @private
         */
        set: function (value) {
            this.isValueEnabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartDataLabels.prototype, "isPercentage", {
        /**
         * @private
         */
        get: function () {
            return this.isPercentageEnabled;
        },
        /**
         * @private
         */
        set: function (value) {
            this.isPercentageEnabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartDataLabels.prototype, "isLeaderLines", {
        /**
         * @private
         */
        get: function () {
            return this.showLeaderLines;
        },
        /**
         * @private
         */
        set: function (value) {
            this.showLeaderLines = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ChartDataLabels.prototype.clone = function () {
        var chart = new ChartDataLabels();
        chart.position = this.position;
        chart.name = this.name;
        chart.color = this.color;
        chart.size = this.size;
        chart.isBubble = this.isBubble;
        chart.isLegend = this.isLegend;
        chart.isCategory = this.isCategory;
        chart.isSeries = this.isSeries;
        chart.isValueEnabled = this.isValueEnabled;
        chart.isPercentageEnabled = this.isPercentageEnabled;
        chart.showLeaderLines = this.showLeaderLines;
        return chart;
    };
    /**
     * @private
     */
    ChartDataLabels.prototype.destroy = function () {
        this.position = undefined;
    };
    return ChartDataLabels;
}());
/**
 * @private
 */
var ChartTrendLines = /** @__PURE__ @class */ (function () {
    function ChartTrendLines() {
    }
    Object.defineProperty(ChartTrendLines.prototype, "trendLineType", {
        /**
         * @private
         */
        get: function () {
            return this.type;
        },
        /**
         * @private
         */
        set: function (value) {
            this.type = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartTrendLines.prototype, "trendLineName", {
        /**
         * @private
         */
        get: function () {
            return this.name;
        },
        /**
         * @private
         */
        set: function (value) {
            this.name = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartTrendLines.prototype, "interceptValue", {
        /**
         * @private
         */
        get: function () {
            return this.intercept;
        },
        /**
         * @private
         */
        set: function (value) {
            this.intercept = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartTrendLines.prototype, "forwardValue", {
        /**
         * @private
         */
        get: function () {
            return this.forward;
        },
        /**
         * @private
         */
        set: function (value) {
            this.forward = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartTrendLines.prototype, "backwardValue", {
        /**
         * @private
         */
        get: function () {
            return this.backward;
        },
        /**
         * @private
         */
        set: function (value) {
            this.backward = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartTrendLines.prototype, "isDisplayRSquared", {
        /**
         * @private
         */
        get: function () {
            return this.displayRSquared;
        },
        /**
         * @private
         */
        set: function (value) {
            this.displayRSquared = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartTrendLines.prototype, "isDisplayEquation", {
        /**
         * @private
         */
        get: function () {
            return this.displayEquation;
        },
        /**
         * @private
         */
        set: function (value) {
            this.displayEquation = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ChartTrendLines.prototype.clone = function () {
        var chart = new ChartTrendLines();
        chart.type = this.type;
        chart.name = this.name;
        chart.forward = this.forward;
        chart.backward = this.backward;
        chart.intercept = this.intercept;
        chart.displayEquation = this.displayEquation;
        chart.displayRSquared = this.displayRSquared;
        return chart;
    };
    /**
     * @private
     */
    ChartTrendLines.prototype.destroy = function () {
        this.type = undefined;
        this.name = undefined;
        this.forward = undefined;
        this.backward = undefined;
    };
    return ChartTrendLines;
}());
/**
 * @private
 */
var ChartTitleArea = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function ChartTitleArea() {
        this.dataFormat = new ChartDataFormat();
        this.layout = new ChartLayout();
    }
    Object.defineProperty(ChartTitleArea.prototype, "chartfontName", {
        /**
         * @private
         */
        get: function () {
            return this.fontName;
        },
        /**
         * @private
         */
        set: function (value) {
            this.fontName = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartTitleArea.prototype, "chartFontSize", {
        /**
         * @private
         */
        get: function () {
            return this.fontSize;
        },
        /**
         * @private
         */
        set: function (value) {
            this.fontSize = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ChartTitleArea.prototype.clone = function () {
        var chart = new ChartTitleArea();
        chart.fontName = this.fontName;
        chart.fontSize = this.fontSize;
        chart.dataFormat = this.dataFormat.clone();
        chart.layout = this.layout.clone();
        return chart;
    };
    /**
     * @private
     */
    ChartTitleArea.prototype.destroy = function () {
        this.fontName = undefined;
        this.fontSize = undefined;
        this.dataFormat = undefined;
        this.layout = undefined;
    };
    return ChartTitleArea;
}());
/**
 * @private
 */
var ChartDataFormat = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function ChartDataFormat() {
        this.fill = new ChartFill();
        this.line = new ChartFill();
    }
    /**
     * @private
     */
    ChartDataFormat.prototype.clone = function () {
        var chart = new ChartDataFormat();
        chart.fill = this.fill.clone();
        chart.line = this.line.clone();
        return chart;
    };
    /**
     * @private
     */
    ChartDataFormat.prototype.destroy = function () {
        this.fill = undefined;
        this.line = undefined;
    };
    return ChartDataFormat;
}());
/**
 * @private
 */
var ChartFill = /** @__PURE__ @class */ (function () {
    function ChartFill() {
    }
    Object.defineProperty(ChartFill.prototype, "color", {
        /**
         * @private
         */
        get: function () {
            return this.fillColor;
        },
        /**
         * @private
         */
        set: function (value) {
            this.fillColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartFill.prototype, "rgb", {
        /**
         * @private
         */
        get: function () {
            return this.fillRGB;
        },
        /**
         * @private
         */
        set: function (value) {
            this.fillRGB = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ChartFill.prototype.clone = function () {
        var chart = new ChartFill();
        chart.fillColor = this.fillColor;
        chart.fillRGB = this.fillRGB;
        return chart;
    };
    /**
     * @private
     */
    ChartFill.prototype.destroy = function () {
        this.fillColor = undefined;
        this.fillRGB = undefined;
    };
    return ChartFill;
}());
/**
 * @private
 */
var ChartLayout = /** @__PURE__ @class */ (function () {
    function ChartLayout() {
    }
    Object.defineProperty(ChartLayout.prototype, "chartLayoutLeft", {
        /**
         * @private
         */
        get: function () {
            return this.layoutX;
        },
        /**
         * @private
         */
        set: function (value) {
            this.layoutX = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartLayout.prototype, "chartLayoutTop", {
        /**
         * @private
         */
        get: function () {
            return this.layoutY;
        },
        /**
         * @private
         */
        set: function (value) {
            this.layoutY = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ChartLayout.prototype.clone = function () {
        var chart = new ChartLayout();
        chart.layoutX = this.layoutX;
        chart.layoutY = this.layoutY;
        return chart;
    };
    /**
     * @private
     */
    ChartLayout.prototype.destroy = function () {
        this.layoutX = undefined;
        this.layoutY = undefined;
    };
    return ChartLayout;
}());
/**
 * @private
 */
var ChartCategoryAxis = /** @__PURE__ @class */ (function () {
    function ChartCategoryAxis() {
        this.chartTitleArea = new ChartTitleArea();
    }
    Object.defineProperty(ChartCategoryAxis.prototype, "majorTick", {
        /**
         * @private
         */
        get: function () {
            return this.majorTickMark;
        },
        /**
         * @private
         */
        set: function (value) {
            this.majorTickMark = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartCategoryAxis.prototype, "minorTick", {
        /**
         * @private
         */
        get: function () {
            return this.minorTickMark;
        },
        /**
         * @private
         */
        set: function (value) {
            this.minorTickMark = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartCategoryAxis.prototype, "tickPosition", {
        /**
         * @private
         */
        get: function () {
            return this.tickLabelPostion;
        },
        /**
         * @private
         */
        set: function (value) {
            this.tickLabelPostion = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartCategoryAxis.prototype, "minorGridLines", {
        /**
         * @private
         */
        get: function () {
            return this.hasMinorGridLines;
        },
        /**
         * @private
         */
        set: function (value) {
            this.hasMinorGridLines = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartCategoryAxis.prototype, "majorGridLines", {
        /**
         * @private
         */
        get: function () {
            return this.hasMajorGridLines;
        },
        /**
         * @private
         */
        set: function (value) {
            this.hasMajorGridLines = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartCategoryAxis.prototype, "interval", {
        /**
         * @private
         */
        get: function () {
            return this.majorUnit;
        },
        /**
         * @private
         */
        set: function (value) {
            this.majorUnit = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartCategoryAxis.prototype, "max", {
        /**
         * @private
         */
        get: function () {
            return this.maximumValue;
        },
        /**
         * @private
         */
        set: function (value) {
            this.maximumValue = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartCategoryAxis.prototype, "min", {
        /**
         * @private
         */
        get: function () {
            return this.minimumValue;
        },
        /**
         * @private
         */
        set: function (value) {
            this.minimumValue = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartCategoryAxis.prototype, "categoryAxisTitle", {
        /**
         * @private
         */
        get: function () {
            return this.title;
        },
        /**
         * @private
         */
        set: function (value) {
            this.title = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartCategoryAxis.prototype, "categoryAxisType", {
        /**
         * @private
         */
        get: function () {
            return this.categoryType;
        },
        /**
         * @private
         */
        set: function (value) {
            this.categoryType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartCategoryAxis.prototype, "categoryNumberFormat", {
        /**
         * @private
         */
        get: function () {
            return this.numberFormat;
        },
        /**
         * @private
         */
        set: function (value) {
            this.numberFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartCategoryAxis.prototype, "axisFontSize", {
        /**
         * @private
         */
        get: function () {
            return this.fontSize;
        },
        /**
         * @private
         */
        set: function (value) {
            this.fontSize = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartCategoryAxis.prototype, "axisFontName", {
        /**
         * @private
         */
        get: function () {
            return this.fontName;
        },
        /**
         * @private
         */
        set: function (value) {
            this.fontName = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ChartCategoryAxis.prototype.clone = function () {
        var chart = new ChartCategoryAxis();
        chart.title = this.title;
        chart.categoryType = this.categoryType;
        chart.numberFormat = this.numberFormat;
        chart.fontSize = this.fontSize;
        chart.fontName = this.fontName;
        chart.hasMajorGridLines = this.hasMajorGridLines;
        chart.hasMinorGridLines = this.hasMinorGridLines;
        chart.minimumValue = this.minimumValue;
        chart.maximumValue = this.maximumValue;
        chart.majorUnit = this.majorUnit;
        chart.majorTickMark = this.majorTickMark;
        chart.minorTickMark = this.minorTickMark;
        chart.tickLabelPostion = this.tickLabelPostion;
        chart.chartTitleArea = this.chartTitleArea.clone();
        return chart;
    };
    /**
     * @private
     */
    ChartCategoryAxis.prototype.destroy = function () {
        this.title = undefined;
        this.categoryType = undefined;
        this.numberFormat = undefined;
        this.chartTitleArea = undefined;
        this.minimumValue = undefined;
        this.maximumValue = undefined;
        this.fontSize = undefined;
        this.fontName = undefined;
        this.majorUnit = undefined;
        this.majorTickMark = undefined;
        this.minorTickMark = undefined;
        this.tickLabelPostion = undefined;
    };
    return ChartCategoryAxis;
}());
/**
 * @private
 */
var ChartDataTable = /** @__PURE__ @class */ (function () {
    function ChartDataTable() {
    }
    Object.defineProperty(ChartDataTable.prototype, "showSeriesKeys", {
        /**
         * @private
         */
        get: function () {
            return this.isSeriesKeys;
        },
        /**
         * @private
         */
        set: function (value) {
            this.isSeriesKeys = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartDataTable.prototype, "hasHorzBorder", {
        /**
         * @private
         */
        get: function () {
            return this.isHorzBorder;
        },
        /**
         * @private
         */
        set: function (value) {
            this.isHorzBorder = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartDataTable.prototype, "hasVertBorder", {
        /**
         * @private
         */
        get: function () {
            return this.isVertBorder;
        },
        /**
         * @private
         */
        set: function (value) {
            this.isVertBorder = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartDataTable.prototype, "hasBorders", {
        /**
         * @private
         */
        get: function () {
            return this.isBorders;
        },
        /**
         * @private
         */
        set: function (value) {
            this.isBorders = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ChartDataTable.prototype.clone = function () {
        var chart = new ChartDataTable();
        chart.isSeriesKeys = this.isSeriesKeys;
        chart.isHorzBorder = this.isHorzBorder;
        chart.isVertBorder = this.isVertBorder;
        chart.isBorders = this.isBorders;
        return chart;
    };
    /**
     * @private
     */
    ChartDataTable.prototype.destroy = function () {
        this.isSeriesKeys = undefined;
        this.isHorzBorder = undefined;
        this.isVertBorder = undefined;
        this.isBorders = undefined;
    };
    return ChartDataTable;
}());
/**
 * @private
 */
var CommentCharacterElementBox = /** @__PURE__ @class */ (function (_super) {
    __extends$1(CommentCharacterElementBox, _super);
    function CommentCharacterElementBox(type) {
        var _this = _super.call(this) || this;
        _this.commentType = 0;
        _this.commentId = '';
        _this.commentType = type;
        return _this;
    }
    Object.defineProperty(CommentCharacterElementBox.prototype, "comment", {
        get: function () {
            return this.commentInternal;
        },
        set: function (value) {
            this.commentInternal = value;
        },
        enumerable: true,
        configurable: true
    });
    CommentCharacterElementBox.prototype.getLength = function () {
        return 1;
    };
    CommentCharacterElementBox.prototype.clone = function () {
        var comment = new CommentCharacterElementBox(this.commentType);
        comment.commentId = this.commentId;
        comment.commentType = this.commentType;
        return comment;
    };
    CommentCharacterElementBox.prototype.renderCommentMark = function () {
        if (this.commentType === 0 && isNullOrUndefined(this.commentMark)) {
            this.commentMark = document.createElement('div');
            this.commentMark.style.display = 'none';
            this.commentMark.classList.add('e-de-cmt-mark');
            var span = document.createElement('span');
            span.classList.add('e-icons');
            span.classList.add('e-de-cmt-mark-icon');
            this.commentMark.appendChild(span);
        }
        if (this.line && isNullOrUndefined(this.commentMark.parentElement)) {
            var viewer = this.line.paragraph.bodyWidget.page.viewer;
            viewer.pageContainer.appendChild(this.commentMark);
            this.commentMark.addEventListener('click', this.selectComment.bind(this));
        }
    };
    CommentCharacterElementBox.prototype.selectComment = function () {
        var viewer = this.line.paragraph.bodyWidget.page.viewer;
        if (viewer.owner) {
            if (!viewer.owner.commentReviewPane.commentPane.isEditMode) {
                viewer.selectComment(this.comment);
            }
            else {
                viewer.owner.showComments = true;
            }
        }
    };
    CommentCharacterElementBox.prototype.removeCommentMark = function () {
        if (this.commentMark && this.commentMark.parentElement) {
            this.commentMark.removeEventListener('click', this.selectComment.bind(this));
            this.commentMark.parentElement.removeChild(this.commentMark);
        }
    };
    CommentCharacterElementBox.prototype.destroy = function () {
        if (this.commentMark) {
            this.removeCommentMark();
        }
    };
    return CommentCharacterElementBox;
}(ElementBox));
/**
 * @private
 */
var CommentElementBox = /** @__PURE__ @class */ (function (_super) {
    __extends$1(CommentElementBox, _super);
    function CommentElementBox(date) {
        var _this = _super.call(this, 0) || this;
        _this.authorIn = '';
        _this.initialIn = '';
        _this.done = false;
        _this.textIn = '';
        _this.isReply = false;
        _this.ownerComment = undefined;
        _this.createdDate = date;
        _this.replyComments = [];
        return _this;
    }
    Object.defineProperty(CommentElementBox.prototype, "commentStart", {
        get: function () {
            return this.commentStartIn;
        },
        set: function (value) {
            this.commentStartIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommentElementBox.prototype, "commentEnd", {
        get: function () {
            return this.commentEndIn;
        },
        set: function (value) {
            this.commentEndIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommentElementBox.prototype, "author", {
        get: function () {
            return this.authorIn;
        },
        set: function (value) {
            this.authorIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommentElementBox.prototype, "initial", {
        get: function () {
            return this.initialIn;
        },
        set: function (value) {
            this.initialIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommentElementBox.prototype, "isResolved", {
        get: function () {
            return this.done;
        },
        set: function (value) {
            this.done = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommentElementBox.prototype, "date", {
        get: function () {
            return this.createdDate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommentElementBox.prototype, "text", {
        get: function () {
            return this.textIn;
        },
        set: function (value) {
            this.textIn = value;
        },
        enumerable: true,
        configurable: true
    });
    CommentElementBox.prototype.getLength = function () {
        return 1;
    };
    CommentElementBox.prototype.clone = function () {
        var comment = new CommentElementBox(this.date);
        comment.author = this.author;
        comment.initial = this.initial;
        comment.commentId = this.commentId;
        comment.replyComments = this.replyComments;
        comment.isResolved = this.isResolved;
        comment.text = this.text;
        return comment;
    };
    CommentElementBox.prototype.destroy = function () {
        this.ownerComment = undefined;
    };
    return CommentElementBox;
}(CommentCharacterElementBox));
/**
 * @private
 */
var Page = /** @__PURE__ @class */ (function () {
    /**
     * Initialize the constructor of Page
     */
    function Page() {
        /**
         * Specifies the Bonding Rectangle
         * @private
         */
        this.boundingRectangle = new Rect(96, 96, 816, 1056);
        /**
         * @private
         */
        this.repeatHeaderRowTableWidget = false;
        /**
         * Specifies the bodyWidgets
         * @default []
         * @private
         */
        this.bodyWidgets = [];
        /**
         * @private
         */
        this.headerWidget = undefined;
        /**
         * @private
         */
        this.footerWidget = undefined;
        /**
         * @private
         */
        this.currentPageNum = 0;
        /**
         *
         */
        this.allowNextPageRendering = true;
        // let text: string = 'DocumentEditor';
    }
    Object.defineProperty(Page.prototype, "index", {
        /**
         * @private
         */
        get: function () {
            if (this.viewer) {
                return this.viewer.pages.indexOf(this);
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "previousPage", {
        /**
         * @private
         */
        get: function () {
            var index = this.index;
            if (index > 0) {
                return this.viewer.pages[index - 1];
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "nextPage", {
        /**
         * @private
         */
        get: function () {
            var index = this.index;
            if (index < this.viewer.pages.length - 1) {
                return this.viewer.pages[index + 1];
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "sectionIndex", {
        /**
         * @private
         */
        get: function () {
            if (this.bodyWidgets.length > 0) {
                return this.bodyWidgets[0].index;
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Page.prototype.destroy = function () {
        if (this.headerWidget) {
            if (this.viewer && this.viewer.owner.editor) {
                this.viewer.owner.editor.removeFieldInWidget(this.headerWidget);
            }
            this.headerWidget.destroy();
        }
        this.headerWidget = undefined;
        if (this.footerWidget) {
            if (this.viewer && this.viewer.owner.editor) {
                this.viewer.owner.editor.removeFieldInWidget(this.footerWidget);
            }
            this.footerWidget.destroy();
        }
        this.footerWidget = undefined;
        this.bodyWidgets = [];
        this.bodyWidgets = undefined;
        if (!isNullOrUndefined(this.viewer)) {
            if (!isNullOrUndefined(this.viewer.pages)) {
                this.viewer.removePage(this);
            }
        }
        this.viewer = undefined;
    };
    return Page;
}());
/**
 * @private
 */
var WTableHolder = /** @__PURE__ @class */ (function () {
    function WTableHolder() {
        this.tableColumns = [];
        /**
         * @private
         */
        this.tableWidth = 0;
    }
    Object.defineProperty(WTableHolder.prototype, "columns", {
        get: function () {
            return this.tableColumns;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    WTableHolder.prototype.resetColumns = function () {
        for (var i = 0; i < this.tableColumns.length; i++) {
            this.tableColumns[i].destroy();
        }
        this.tableColumns = [];
    };
    /**
     * @private
     */
    WTableHolder.prototype.getPreviousSpannedCellWidth = function (previousColumnIndex, curColumnIndex) {
        var width = 0;
        for (var i = previousColumnIndex; i < curColumnIndex; i++) {
            width += this.tableColumns[i].preferredWidth;
        }
        return width;
    };
    /**
     * @private
     */
    WTableHolder.prototype.addColumns = function (currentColumnIndex, columnSpan, width, sizeInfo, offset) {
        for (var i = this.columns.length; i < columnSpan; i++) {
            this.columns.push(new WColumn());
        }
        var availableWidth = 0;
        for (var j = currentColumnIndex; j < columnSpan; j++) {
            availableWidth += this.columns[j].preferredWidth;
        }
        // If width to add is greater than preferred width, then preferred width will be increased.
        // In case of Grid span > 1, only last grid column width will be updated.
        var gridSpan = columnSpan - currentColumnIndex;
        if (!(gridSpan > 1) && availableWidth < width) {
            this.columns[columnSpan - 1].preferredWidth += (width - availableWidth);
        }
        if (sizeInfo.minimumWordWidth > this.columns[columnSpan - 1].minimumWordWidth) {
            this.columns[columnSpan - 1].minimumWordWidth = sizeInfo.minimumWordWidth;
        }
        if (sizeInfo.maximumWordWidth > this.columns[columnSpan - 1].maximumWordWidth) {
            this.columns[columnSpan - 1].maximumWordWidth = sizeInfo.maximumWordWidth;
        }
        if (sizeInfo.minimumWidth > this.columns[columnSpan - 1].minimumWidth) {
            this.columns[columnSpan - 1].minimumWidth = sizeInfo.minimumWidth;
        }
        if (offset > this.columns[columnSpan - 1].endOffset) {
            this.columns[columnSpan - 1].endOffset = offset;
        }
    };
    /**
     * @private
     */
    WTableHolder.prototype.getTotalWidth = function (type) {
        var width = 0;
        for (var i = 0; i < this.columns.length; i++) {
            var column = this.columns[i];
            width += type === 0 ? column.preferredWidth :
                type === 1 ? column.minimumWordWidth :
                    type === 2 ? column.maximumWordWidth : column.minimumWidth;
        }
        return width;
    };
    /**
     * @private
     */
    WTableHolder.prototype.isFitColumns = function (containerWidth, preferredTableWidth, isAutoWidth) {
        // Gets total preferred width.
        var totalColumnWidth = this.getTotalWidth(0);
        // If auto table width, based on total column widths, minimum value will be updated.
        if (isAutoWidth) {
            this.tableWidth = preferredTableWidth > totalColumnWidth ? totalColumnWidth : preferredTableWidth;
        }
        else {
            this.tableWidth = preferredTableWidth;
        }
        // If total columns width doesn't match table width, then all grid column widths will be updated by even factor.
        // If totalColumnWidth < TableWidth, all grid columns are enlarged. Otherwise shrinked.
        if (totalColumnWidth !== this.tableWidth) {
            var factor = this.tableWidth / totalColumnWidth;
            factor = isNaN(factor) ? 1 : factor;
            for (var i = 0; i < this.columns.length; i++) {
                var column = this.columns[i];
                //column.PreferredWidth = factor * column.PreferredWidth;
                if (factor * column.preferredWidth < column.minWidth) {
                    return false;
                }
            }
            return true;
        }
        else {
            return true;
        }
    };
    /**
     * @private
     */
    WTableHolder.prototype.autoFitColumn = function (containerWidth, preferredTableWidth, isAuto, isNestedTable) {
        // Cell's preferred width should be considered until the table width fits to the container width.
        var maxTotal = 0;
        var minTotal = 0;
        // For preferred width set as 0 pixels (not auto), then minimum word width only need to be considered.
        // But currently there is no way to find any one of cell in particular column has 0 px preferred width set.
        // If all columns are set as 0 pixels, then this will work.
        var remainingWidthTotal = 0;
        for (var i = 0; i < this.columns.length; i++) {
            var column = this.columns[i];
            // If preferred width of column is less than column minimum width and also column is empty, considered column preferred width
            if (column.minimumWordWidth === 0 && column.maximumWordWidth === 0 && column.minWidth === 0) {
                column.minimumWordWidth = column.preferredWidth;
                column.maximumWordWidth = column.preferredWidth;
                column.minWidth = column.preferredWidth;
            }
            maxTotal += column.preferredWidth > column.maximumWordWidth ? column.preferredWidth : column.maximumWordWidth;
            minTotal += column.preferredWidth > column.minimumWordWidth ? column.preferredWidth : column.minimumWordWidth;
            // tslint:disable-next-line:max-line-length
            var preferred = column.preferredWidth === 0 ? column.minimumWordWidth : column.preferredWidth > column.minimumWordWidth ? column.preferredWidth : column.minimumWordWidth;
            var difference = column.maximumWordWidth - preferred;
            remainingWidthTotal += difference > 0 ? difference : 0;
        }
        // Try to fit maximum word width to match preferredTableWidth.
        if (maxTotal <= preferredTableWidth) {
            for (var i = 0; i < this.columns.length; i++) {
                var column = this.columns[i];
                if (column.preferredWidth < column.maximumWordWidth) {
                    if (isNestedTable) {
                        column.preferredWidth = column.minimumWidth + column.minimumWordWidth;
                    }
                    else {
                        column.preferredWidth = column.maximumWordWidth;
                    }
                }
            }
            // If the width is defined for table(cells undefined) then fit the columns to preferred table width using FitColumns.
            if (!isAuto) {
                this.fitColumns(containerWidth, preferredTableWidth, isAuto);
            }
        }
        else {
            // If the table preferred table width is set, then check its greater than total minimum word width. 
            // tslint:disable-next-line:max-line-length
            // If yes then set table preferred table width as container width. Else, check whether the total minimum word width is less than container width.
            // If yes, then set total minimum word width as container width. Else, set the container width to container width.
            if (!isAuto) {
                var totalMinimumWordWidth = this.getTotalWidth(1);
                if (preferredTableWidth > totalMinimumWordWidth && totalMinimumWordWidth < containerWidth) {
                    this.fitColumns(containerWidth, preferredTableWidth, isAuto);
                    return;
                }
                // tslint:disable-next-line:max-line-length
                containerWidth = preferredTableWidth < totalMinimumWordWidth ? totalMinimumWordWidth < containerWidth ? totalMinimumWordWidth : containerWidth : preferredTableWidth;
            }
            // Try to fit minimum word width to match preferredTableWidth or containerWidth.
            if (minTotal <= preferredTableWidth || minTotal <= containerWidth) {
                var availableWidth = containerWidth > preferredTableWidth ? containerWidth : preferredTableWidth;
                availableWidth = availableWidth - minTotal;
                for (var i = 0; i < this.columns.length; i++) {
                    var column = this.columns[i];
                    if (column.preferredWidth === 0) {
                        column.preferredWidth = column.minimumWordWidth;
                    }
                    else {
                        if (column.preferredWidth < column.minimumWordWidth) {
                            column.preferredWidth = column.minimumWordWidth;
                        }
                        if (!isNestedTable) {
                            var difference = column.maximumWordWidth - column.preferredWidth;
                            difference = difference > 0 ? difference : 0;
                            var factor = availableWidth * (difference / remainingWidthTotal);
                            column.preferredWidth += isNaN(factor) ? 0 : factor;
                        }
                    }
                }
            }
            else {
                // Try to fit minimum width for each column and allot remaining space to columns based on their minimum word width.
                var totalMinimumWordWidth = this.getTotalWidth(1);
                var totalMinWidth = this.getTotalWidth(3);
                var totalPreferredWidth = this.getTotalWidth(0);
                if (totalMinWidth > 2112) {
                    var cellWidth = 2112 / this.columns.length;
                    for (var i = 0; i < this.columns.length; i++) {
                        this.columns[i].preferredWidth = cellWidth;
                    }
                }
                else {
                    var availableWidth = 0;
                    if (totalMinWidth < containerWidth) {
                        availableWidth = containerWidth - totalMinWidth;
                        for (var i = 0; i < this.columns.length; i++) {
                            var column = this.columns[i];
                            // The factor depends of current column's minimum word width and total minimum word width.
                            var factor = availableWidth * column.minimumWordWidth / totalMinimumWordWidth;
                            factor = isNaN(factor) ? 0 : factor;
                            if (column.preferredWidth <= column.minimumWidth) {
                                continue;
                            }
                            column.preferredWidth = column.minimumWidth + factor;
                        }
                        // table width exceeds container width
                    }
                    else if (totalPreferredWidth > containerWidth) {
                        var factor = containerWidth / totalPreferredWidth;
                        for (var i = 0; i < this.columns.length; i++) {
                            var column = this.columns[i];
                            column.preferredWidth = column.preferredWidth * factor;
                        }
                    }
                }
            }
        }
        this.tableWidth = this.getTotalWidth(0);
    };
    /**
     * @private
     */
    WTableHolder.prototype.fitColumns = function (containerWidth, preferredTableWidth, isAutoWidth, indent) {
        if (isNullOrUndefined(indent)) {
            indent = 0;
        }
        // Gets total preferred width.
        var totalColumnWidth = this.getTotalWidth(0);
        // Neglected left indent value, because in preferred table width left indent value is neglected
        if (isAutoWidth) {
            totalColumnWidth -= indent;
        }
        // If auto table width, based on total column widths, minimum value will be updated.
        if (isAutoWidth) {
            this.tableWidth = preferredTableWidth > totalColumnWidth ? totalColumnWidth : preferredTableWidth;
        }
        else {
            this.tableWidth = preferredTableWidth;
        }
        // If total columns width doesn't match table width, then all grid column widths will be updated by even factor.
        // If totalColumnWidth < TableWidth, all grid columns are enlarged. Otherwise shrinked.
        if (totalColumnWidth !== this.tableWidth) {
            var factor = this.tableWidth / totalColumnWidth;
            for (var i = 0; i < this.columns.length; i++) {
                var column = this.columns[i];
                column.preferredWidth = factor * column.preferredWidth;
            }
        }
    };
    /**
     * @private
     */
    WTableHolder.prototype.getCellWidth = function (columnIndex, columnSpan, preferredTableWidth) {
        var width = 0;
        for (var i = 0; i < columnSpan; i++) {
            width += this.tableColumns[i + columnIndex].preferredWidth;
        }
        return width;
    };
    /**
     * @private
     */
    WTableHolder.prototype.validateColumnWidths = function () {
        for (var i = 0; i < this.columns.length; i++) {
            if (i === 0) {
                if (this.columns[i].preferredWidth !== this.columns[i].endOffset) {
                    this.columns[i].preferredWidth = this.columns[i].endOffset;
                }
            }
            else {
                // If Previous column offset + current column preferred width is less than current column offset, 
                // Then current column preferred width is set to current column offset - previous column offset.
                if (this.columns[i - 1].endOffset + this.columns[i].preferredWidth < this.columns[i].endOffset) {
                    this.columns[i].preferredWidth = this.columns[i].endOffset - this.columns[i - 1].endOffset;
                }
            }
        }
    };
    /**
     * @private
     */
    WTableHolder.prototype.clone = function () {
        var tableHolder = new WTableHolder();
        tableHolder.tableWidth = this.tableWidth;
        for (var i = 0; i < this.columns.length; i++) {
            tableHolder.columns.push(this.columns[i].clone());
        }
        return tableHolder;
    };
    /**
     * @private
     */
    WTableHolder.prototype.destroy = function () {
        if (!isNullOrUndefined(this.tableColumns)) {
            for (var i = 0; i < this.tableColumns.length; i++) {
                var column = this.tableColumns[i];
                column.destroy();
            }
        }
        this.tableColumns = [];
        this.tableColumns = undefined;
        this.tableWidth = undefined;
    };
    return WTableHolder;
}());
/**
 * @private
 */
var WColumn = /** @__PURE__ @class */ (function () {
    function WColumn() {
        /**
         * @private
         */
        this.preferredWidth = 0;
        /**
         * @private
         */
        this.minWidth = 0;
        /**
         * @private
         */
        this.maxWidth = 0;
        /**
         * @private
         */
        this.endOffset = 0;
        /**
         * @private
         */
        this.minimumWordWidth = 0;
        /**
         * @private
         */
        this.maximumWordWidth = 0;
        /**
         * @private
         */
        this.minimumWidth = 0;
    }
    /**
     * @private
     */
    WColumn.prototype.clone = function () {
        var column = new WColumn();
        column.preferredWidth = this.preferredWidth;
        column.minWidth = this.minWidth;
        column.maxWidth = this.maxWidth;
        return column;
    };
    /**
     * @private
     */
    WColumn.prototype.destroy = function () {
        this.preferredWidth = undefined;
        this.minWidth = undefined;
        this.maxWidth = undefined;
    };
    return WColumn;
}());
/**
 * @private
 */
var ColumnSizeInfo = /** @__PURE__ @class */ (function () {
    function ColumnSizeInfo() {
        /**
         * @private
         */
        this.minimumWordWidth = 0;
        /**
         * @private
         */
        this.maximumWordWidth = 0;
        /**
         * @private
         */
        this.minimumWidth = 0;
        /**
         * @private
         */
        this.hasMinimumWidth = false;
        /**
         * @private
         */
        this.hasMinimumWordWidth = false;
        /**
         * @private
         */
        this.hasMaximumWordWidth = false;
    }
    return ColumnSizeInfo;
}());

/**
 * The spell checker module
 */
var SpellChecker = /** @__PURE__ @class */ (function () {
    /**
     *
     */
    function SpellChecker(viewer) {
        this.langIDInternal = 0;
        this.spellSuggestionInternal = true;
        /**
         * @private
         */
        this.uniqueKey = '';
        this.removeUnderlineInternal = false;
        /**
         * @default 1000
         */
        this.uniqueWordsCountInternal = 10000;
        this.performOptimizedCheck = false;
        this.viewer = viewer;
        this.errorWordCollection = new Dictionary();
        this.errorSuggestions = new Dictionary();
        this.ignoreAllItems = [];
        this.uniqueSpelledWords = [];
        this.uniqueKey = this.viewer.owner.element.id + '_' + this.createGuid();
    }
    /**
     * Gets module name.
     */
    SpellChecker.prototype.getModuleName = function () {
        return 'SpellChecker';
    };
    Object.defineProperty(SpellChecker.prototype, "enableOptimizedSpellCheck", {
        /**
         * Gets the boolean indicating whether optimized spell check to be performed.
         * @aspType bool
         * @blazorType bool
         */
        get: function () {
            return this.performOptimizedCheck;
        },
        /**
         * Sets the boolean indicating whether optimized spell check to be performed.
         * @aspType bool
         * @blazorType bool
         */
        set: function (value) {
            this.performOptimizedCheck = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpellChecker.prototype, "uniqueWordsCount", {
        /**
         * Gets the spell checked Unique words.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return isNullOrUndefined(this.uniqueWordsCountInternal) ? 0 : this.uniqueWordsCountInternal;
        },
        /**
         * Sets the spell checked Unique words.
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            this.uniqueWordsCountInternal = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpellChecker.prototype, "languageID", {
        /**
         * Gets the languageID.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return isNullOrUndefined(this.langIDInternal) ? 0 : this.langIDInternal;
        },
        /**
         * Sets the languageID.
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            this.langIDInternal = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpellChecker.prototype, "allowSpellCheckAndSuggestion", {
        /**
         * Getter indicates whether suggestion enabled.
         * @aspType bool
         * @blazorType bool
         */
        get: function () {
            return this.spellSuggestionInternal;
        },
        /**
         * Setter to enable or disable suggestion
         * @aspType bool
         * @blazorType bool
         */
        set: function (value) {
            this.spellSuggestionInternal = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpellChecker.prototype, "removeUnderline", {
        /**
         * Getter indicates whether underline removed for mis-spelled word.
         * @aspType bool
         * @blazorType bool
         */
        get: function () {
            return this.removeUnderlineInternal;
        },
        /**
         * Setter to enable or disable underline for mis-spelled word
         * @aspType bool
         * @blazorType bool
         */
        set: function (value) {
            this.removeUnderlineInternal = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Method to manage replace logic
     * @private
     */
    SpellChecker.prototype.manageReplace = function (content, dialogElement) {
        this.viewer.triggerSpellCheck = true;
        var exactText = '';
        if (!isNullOrUndefined(dialogElement) && dialogElement instanceof ErrorTextElementBox) {
            var exactText_1 = dialogElement.text;
            this.viewer.selection.start = dialogElement.start;
            this.viewer.selection.end = dialogElement.end;
            if (content !== 'Ignore Once') {
                content = this.manageSpecialCharacters(exactText_1, content);
                this.viewer.owner.editor.insertTextInternal(content, true);
                this.viewer.selection.start.setPositionInternal(this.viewer.selection.end);
                this.viewer.clearSelectionHighlight();
                return;
            }
            else {
                this.currentContextInfo = { 'text': exactText_1, 'element': dialogElement };
            }
        }
        if (!isNullOrUndefined(this.currentContextInfo) && this.currentContextInfo.element && content !== 'Ignore Once') {
            var elementBox = this.currentContextInfo.element;
            exactText = this.currentContextInfo.element.text;
            this.viewer.selection.start = elementBox.start;
            this.viewer.selection.end = elementBox.end;
        }
        else {
            this.handleReplace(content);
        }
        if (content !== 'Ignore Once') {
            this.viewer.owner.editor.insertTextInternal(content, true);
            if (!isNullOrUndefined(this.currentContextInfo)) {
                this.removeErrorsFromCollection(this.currentContextInfo);
            }
            this.viewer.selection.start.setPositionInternal(this.viewer.selection.end);
            this.viewer.clearSelectionHighlight();
        }
        //this.viewer.owner.errorWordCollection.remove(content);
        this.viewer.triggerSpellCheck = false;
    };
    /**
     * Method to handle replace logic
     * @param {string} content
     * @private
     */
    SpellChecker.prototype.handleReplace = function (content) {
        var startPosition = this.viewer.selection.start;
        var offset = startPosition.offset;
        var startIndex = 0;
        var startInlineObj = startPosition.currentWidget.getInline(offset, startIndex, false, true);
        var startOffset = startInlineObj.element.line.getOffset(startInlineObj.element, 0) + startInlineObj.element.length;
        if (startOffset === offset) {
            this.retrieveExactElementInfo(startInlineObj);
        }
        var exactText = startInlineObj.element.text;
        // tslint:disable-next-line:max-line-length
        var startPattern = new RegExp('^[#\\@\\!\\~\\$\\%\\^\\&\\*\\(\\)\\-\\_\\+\\=\\{\\}\\[\\]\\:\\;\\"\'\\,\\<\\.\\>\\/\\?\\`\\s]+', 'g');
        var matches = [];
        var matchInfo;
        //tslint:disable no-conditional-assignment
        while (!isNullOrUndefined(matchInfo = startPattern.exec(exactText))) {
            matches.push(matchInfo);
        }
        if (content === 'Ignore Once') {
            this.handleIgnoreOnce(startInlineObj);
            return;
        }
        startPosition.offset = offset - startInlineObj.index;
        if (!isNullOrUndefined(matches) && matches.length > 0) {
            startPosition.offset += matches[0].toString().length;
        }
        // tslint:disable-next-line:max-line-length
        startPosition.location = this.viewer.owner.selection.getPhysicalPositionInternal(startPosition.currentWidget, startPosition.offset, true);
        // tslint:disable-next-line:max-line-length
        startPosition = this.viewer.owner.searchModule.textSearch.getTextPosition(startPosition.currentWidget, startPosition.offset.toString());
        //startPosition.location = this.owner.selection.getPhysicalPositionInternal(span.line, offset, true);
        startPosition.setPositionParagraph(startPosition.currentWidget, startPosition.offset);
        var index = (startPosition.offset + startInlineObj.element.length) - startPosition.offset;
        var endOffset = startPosition.currentWidget.getOffset(startInlineObj.element, index);
        var lineWidget = startPosition.currentWidget;
        // tslint:disable-next-line:max-line-length
        var endPattern = new RegExp('[#\\@\\!\\~\\$\\%\\^\\&\\*\\(\\)\\-\\_\\+\\=\\{\\}\\[\\]\\:\\;\\"\'\\,\\<\\.\\>\\/\\?\\s\\`]+$', 'g');
        matches = [];
        //tslint:disable no-conditional-assignment
        while (!isNullOrUndefined(matchInfo = endPattern.exec(exactText))) {
            matches.push(matchInfo);
        }
        if (!isNullOrUndefined(matches) && matches.length > 0) {
            endOffset -= matches[0].toString().length;
        }
        // tslint:disable-next-line:max-line-length
        this.viewer.selection.end = this.viewer.owner.searchModule.textSearch.getTextPosition(lineWidget, endOffset.toString());
        // tslint:disable-next-line:max-line-length
        this.viewer.selection.end.location = this.viewer.owner.selection.getPhysicalPositionInternal(startPosition.currentWidget, endOffset, true);
        this.viewer.selection.end.setPositionParagraph(lineWidget, endOffset);
        this.currentContextInfo = { 'element': startInlineObj.element, 'text': startInlineObj.element.text };
    };
    /**
     * Method to retrieve exact element info
     * @param {ElementInfo} startInlineObj
     * @private
     */
    SpellChecker.prototype.retrieveExactElementInfo = function (startInlineObj) {
        var nextElement = startInlineObj.element.nextElement;
        // tslint:disable-next-line:max-line-length
        startInlineObj.element = (!isNullOrUndefined(nextElement) && nextElement instanceof TextElementBox) ? startInlineObj.element.nextElement : startInlineObj.element;
    };
    /**
     * Method to handle to ignore error Once
     * @param {ElementInfo} startInlineObj
     * @private
     */
    SpellChecker.prototype.handleIgnoreOnce = function (startInlineObj) {
        var textElement = startInlineObj.element;
        var exactText = '';
        if (!isNullOrUndefined(this.currentContextInfo) && this.currentContextInfo.element) {
            exactText = this.currentContextInfo.element.text;
        }
        else {
            exactText = textElement.text;
        }
        exactText = this.manageSpecialCharacters(exactText, undefined, true);
        if (textElement.ignoreOnceItems.indexOf(exactText) === -1) {
            textElement.ignoreOnceItems.push(exactText);
        }
        this.viewer.owner.editor.reLayout(this.viewer.selection);
    };
    /**
     * Method to handle ignore all items
     * @private
     */
    SpellChecker.prototype.handleIgnoreAllItems = function (contextElement) {
        var contextItem = (!isNullOrUndefined(contextElement)) ? contextElement : this.retriveText();
        var retrievedText = this.manageSpecialCharacters(contextItem.text, undefined, true);
        if (this.ignoreAllItems.indexOf(retrievedText) === -1) {
            this.ignoreAllItems.push(retrievedText);
            this.removeErrorsFromCollection(contextItem);
            this.viewer.triggerSpellCheck = true;
            this.viewer.owner.editor.reLayout(this.viewer.selection);
            this.viewer.triggerSpellCheck = false;
            this.viewer.clearSelectionHighlight();
        }
    };
    /**
     * Method to handle dictionary
     * @private
     */
    SpellChecker.prototype.handleAddToDictionary = function (contextElement) {
        var _this = this;
        var contextItem = (!isNullOrUndefined(contextElement)) ? contextElement : this.retriveText();
        var retrievedText = this.manageSpecialCharacters(contextItem.text, undefined, true);
        // tslint:disable-next-line:max-line-length
        /* tslint:disable:no-any */
        this.CallSpellChecker(this.languageID, retrievedText, false, false, true).then(function (data) {
            _this.viewer.triggerSpellCheck = true;
            _this.removeErrorsFromCollection(contextItem);
            _this.ignoreAllItems.push(retrievedText);
            _this.viewer.owner.editor.reLayout(_this.viewer.selection, true);
            _this.viewer.triggerSpellCheck = false;
        });
    };
    /**
     * Method to append/remove special characters
     * @param {string} exactText
     * @param {boolean} isRemove
     * @private
     */
    // tslint:disable-next-line:max-line-length
    SpellChecker.prototype.manageSpecialCharacters = function (exactText, replaceText, isRemove) {
        if (!isNullOrUndefined(exactText)) {
            if (isNullOrUndefined(replaceText)) {
                replaceText = exactText;
            }
            // tslint:disable-next-line:max-line-length
            var pattern = new RegExp('^[#\\@\\!\\~\\$\\%\\^\\&\\*\\(\\)\\-\\_\\+\\=\\{\\}\\[\\]\\:\\;\\"\\\'\\,\\<\\.\\>\\/\\?\\`\\s]+', 'g');
            var matches = [];
            var matchInfo = void 0;
            //tslint:disable no-conditional-assignment
            while (!isNullOrUndefined(matchInfo = pattern.exec(exactText))) {
                matches.push(matchInfo);
            }
            if (matches.length > 0) {
                for (var i = 0; i < matches.length; i++) {
                    /* tslint:disable:no-any */
                    var match = matches[i];
                    replaceText = (!isRemove) ? match[0] + replaceText : replaceText.replace(match[0], '');
                }
            }
            // tslint:disable-next-line:max-line-length
            var endPattern = new RegExp('[#\\@\\!\\~\\$\\%\\^\\&\\*\\(\\)\\-\\_\\+\\=\\{\\}\\[\\]\\:\\;\\"\\\'\\,\\<\\.\\>\\/\\?\\s\\`]+$', 'g');
            matches = [];
            //tslint:disable no-conditional-assignment
            while (!isNullOrUndefined(matchInfo = endPattern.exec(replaceText))) {
                matches.push(matchInfo);
            }
            if (matches.length > 0) {
                for (var i = 0; i < matches.length; i++) {
                    /* tslint:disable:no-any */
                    var match = matches[i];
                    replaceText = (!isRemove) ? replaceText + match[0] : replaceText.slice(0, match.index);
                }
            }
        }
        return replaceText;
    };
    /**
     * Method to remove errors
     * @param {ContextElementInfo} contextItem
     * @private
     */
    SpellChecker.prototype.removeErrorsFromCollection = function (contextItem) {
        if (this.errorWordCollection.containsKey(contextItem.text)) {
            var textElement = this.errorWordCollection.get(contextItem.text);
            if (textElement.indexOf(contextItem.element) >= 0) {
                textElement.splice(0, 1);
            }
            if (textElement.length === 0) {
                this.errorWordCollection.remove(contextItem.text);
            }
        }
    };
    /**
     * Method to retrieve exact text
     * @private
     */
    SpellChecker.prototype.retriveText = function () {
        var exactText;
        var currentElement;
        if (!isNullOrUndefined(this.currentContextInfo) && this.currentContextInfo.element) {
            currentElement = this.currentContextInfo.element;
            exactText = this.currentContextInfo.element.text;
            this.viewer.selection.start = currentElement.start;
            this.viewer.selection.end = currentElement.end;
        }
        else {
            var startPosition = this.viewer.selection.start;
            var offset = startPosition.offset;
            var startIndex = 0;
            var startInlineObj = startPosition.currentWidget.getInline(offset, startIndex);
            currentElement = startInlineObj.element;
            exactText = startInlineObj.element.text;
        }
        return { 'text': exactText, 'element': currentElement };
    };
    /**
     * Method to handle suggestions
     * @param {any} jsonObject
     * @param {PointerEvent} event
     * @private
     */
    /* tslint:disable:no-any */
    SpellChecker.prototype.handleSuggestions = function (allsuggestions) {
        this.spellCheckSuggestion = [];
        if (allsuggestions.length === 0) {
            this.spellCheckSuggestion.push('Add To Dictionary');
        }
        else {
            // tslint:disable-next-line:max-line-length
            allsuggestions = (allsuggestions.length === 5) ? this.constructInlineMenu(allsuggestions) : allsuggestions;
            this.spellCheckSuggestion.push('Add To Dictionary');
        }
        /* tslint:disable:no-any */
        var spellSuggestion = [];
        if (this.spellCheckSuggestion.length > 0) {
            for (var _i = 0, _a = this.spellCheckSuggestion; _i < _a.length; _i++) {
                var str = _a[_i];
                spellSuggestion.push({
                    text: str,
                    id: this.viewer.owner.element.id + '_contextmenu_otherSuggestions_spellcheck_' + str,
                    iconCss: ''
                });
            }
        }
        return spellSuggestion;
    };
    /**
     * Method to check whether text element has errors
     * @param {string} text
     * @param {any} element
     * @param {number} left
     * @private
     */
    SpellChecker.prototype.checktextElementHasErrors = function (text, element, left) {
        var hasError = false;
        var erroElements = [];
        text = text.replace(/[\s]+/g, '');
        if (!isNullOrUndefined(element.errorCollection) && element.errorCollection.length > 0) {
            // tslint:disable-next-line:max-line-length
            if (!this.viewer.isScrollHandler && (element.ischangeDetected || element.paragraph.isChangeDetected)) {
                this.updateStatusForGlobalErrors(element.errorCollection, element);
                element.errorCollection = [];
                element.ischangeDetected = true;
                return { 'errorFound': hasError, 'elements': erroElements };
            }
            for (var i = 0; i < element.errorCollection.length; i++) {
                if (this.handleErrorCollection(element.errorCollection[i])) {
                    hasError = true;
                    erroElements.push(element.errorCollection[i]);
                }
            }
        }
        else if (!this.viewer.isScrollHandler && element.paragraph.isChangeDetected) {
            element.ischangeDetected = true;
        }
        else if (!element.ischangeDetected && this.handleErrorCollection(element)) {
            hasError = true;
            erroElements.push(element);
        }
        return { 'errorFound': hasError, 'elements': erroElements };
    };
    /**
     * Method to update status for error elements
     * @param {ErrorTextElementBox[]} erroElements
     */
    SpellChecker.prototype.updateStatusForGlobalErrors = function (erroElements, parentElement) {
        if (erroElements.length > 0) {
            for (var i = 0; i < erroElements.length; i++) {
                var exactText = this.manageSpecialCharacters(erroElements[i].text, undefined, true);
                if (this.errorWordCollection.containsKey(exactText)) {
                    var elements = this.errorWordCollection.get(exactText);
                    for (var j = 0; j < elements.length; j++) {
                        if (elements[j] instanceof ErrorTextElementBox && elements[j] === erroElements[i]) {
                            elements[j].ischangeDetected = true;
                            // tslint:disable-next-line:max-line-length
                            elements[j].start.offset = parentElement.line.getOffset(parentElement.istextCombined ? this.getCombinedElement(parentElement) : parentElement, 0);
                            elements[j].line = parentElement.line;
                            break;
                        }
                    }
                }
            }
        }
    };
    /**
     * Method to handle document error collection.
     * @param {string} errorInElement
     * @private
     */
    SpellChecker.prototype.handleErrorCollection = function (errorInElement) {
        var errors = this.errorWordCollection;
        var exactText = this.manageSpecialCharacters(errorInElement.text, undefined, true);
        if (errors.containsKey(exactText) && errorInElement.length > 1) {
            var ignoreAllIndex = this.ignoreAllItems.indexOf(exactText);
            if (ignoreAllIndex > -1) {
                if (errors.containsKey(exactText)) {
                    errors.remove(exactText);
                }
                return false;
            }
            return true;
        }
        return false;
    };
    /**
     * Method to construct inline menu
     */
    /* tslint:disable:no-any */
    SpellChecker.prototype.constructInlineMenu = function (inlineSuggestion) {
        /* tslint:disable:no-any */
        for (var i = inlineSuggestion.length - 1; i > 0; i--) {
            if (inlineSuggestion.length > 3) {
                this.spellCheckSuggestion.push(inlineSuggestion[i]);
                inlineSuggestion.pop();
            }
        }
        return inlineSuggestion;
    };
    /**
     * Method to retrieve error element text
     * @private
     */
    SpellChecker.prototype.findCurretText = function () {
        var insertPosition = this.viewer.selection.start;
        /* tslint:disable:no-any */
        var element;
        /* tslint:disable:no-any */
        var inlineObj = insertPosition.currentWidget.getInline(this.viewer.selection.start.offset, 0);
        var text;
        if (!isNullOrUndefined(inlineObj.element)) {
            if (!isNullOrUndefined(inlineObj.element.errorCollection) && inlineObj.element.errorCollection.length > 0) {
                for (var i = 0; i < inlineObj.element.errorCollection.length; i++) {
                    var errorElement = inlineObj.element.errorCollection[i];
                    // tslint:disable-next-line:max-line-length
                    if (errorElement.start.location.x <= insertPosition.location.x && errorElement.end.location.x >= insertPosition.location.x) {
                        text = errorElement.text;
                        element = errorElement;
                        break;
                    }
                }
            }
            else {
                text = inlineObj.element.text;
            }
            if (text === ' ') {
                inlineObj = insertPosition.currentWidget.getInline(this.viewer.selection.start.offset + 1, 0);
                text = inlineObj.element.text;
            }
        }
        return { 'text': text, 'element': element };
    };
    /**
     * Method to add error word in document error collection
     * @param text
     * @param element
     */
    SpellChecker.prototype.addErrorCollection = function (text, elementToCompare, suggestions) {
        text = this.manageSpecialCharacters(text, undefined, true);
        if (this.errorWordCollection.containsKey(text)) {
            var errorElements = this.errorWordCollection.get(text);
            if (elementToCompare instanceof ErrorTextElementBox) {
                if (!this.compareErrorTextElement(elementToCompare, errorElements)) {
                    errorElements.push(elementToCompare);
                }
            }
            else if (elementToCompare instanceof TextElementBox) {
                if (!this.compareTextElement(elementToCompare, errorElements)) {
                    errorElements.push(elementToCompare);
                }
            }
        }
        else {
            if (!isNullOrUndefined(suggestions) && suggestions.length > 0) {
                this.errorSuggestions.add(text, suggestions);
            }
            this.errorWordCollection.add(text, [elementToCompare]);
        }
    };
    /**
     * Method to compare error text elements
     * @param {ErrorTextElementBox} errorElement
     * @param {ElementBox[]} errorCollection
     */
    SpellChecker.prototype.compareErrorTextElement = function (errorElement, errorCollection) {
        var copyElement = [];
        var isChanged = false;
        for (var i = 0; i < errorCollection.length; i++) {
            copyElement.push(errorCollection[i]);
        }
        var length = errorCollection.length;
        for (var i = 0; i < length; i++) {
            if (copyElement[i] instanceof ErrorTextElementBox) {
                if (copyElement[i].ischangeDetected) {
                    var exactText = this.manageSpecialCharacters(copyElement[i].text, undefined, true);
                    isChanged = true;
                    // tslint:disable-next-line:max-line-length
                    this.removeErrorsFromCollection({ 'element': copyElement[i], 'text': exactText });
                }
                else {
                    var currentElement = copyElement[i];
                    // tslint:disable-next-line:max-line-length
                    if (errorElement.start.offset === currentElement.start.offset && errorElement.end.offset === currentElement.end.offset) {
                        return true;
                    }
                }
            }
        }
        if (isChanged) {
            // tslint:disable-next-line:max-line-length
            this.errorWordCollection.add(this.manageSpecialCharacters(errorElement.text, undefined, true), [errorElement]);
        }
        return false;
    };
    /**
     * Method to compare text elements
     * @param {TextElementBox} errorElement
     * @param {ElementBox[]} errorCollection
     * @private
     */
    SpellChecker.prototype.compareTextElement = function (errorElement, errorCollection) {
        for (var i = 0; i < errorCollection.length; i++) {
            if (errorCollection[i] instanceof TextElementBox) {
                var currentElement = errorCollection[i];
                if (currentElement === errorElement) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Method to handle Word by word spell check
     * @param {any} jsonObject
     *  @param {TextElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     * @param {BaselineAlignment} baselineAlignment
     * @param {boolean} isSamePage
     * @private
     */
    // tslint:disable-next-line:max-line-length
    SpellChecker.prototype.handleWordByWordSpellCheck = function (jsonObject, elementBox, left, top, underlineY, baselineAlignment, isSamePage) {
        if (jsonObject.HasSpellingError && isSamePage) {
            this.addErrorCollection(elementBox.text, elementBox, jsonObject.Suggestions);
            // tslint:disable-next-line:max-line-length
            var backgroundColor = (elementBox.line.paragraph.containerWidget instanceof TableCellWidget) ? elementBox.line.paragraph.containerWidget.cellFormat.shading.backgroundColor : this.viewer.backgroundColor;
            this.viewer.render.renderWavyline(elementBox, left, top, underlineY, '#FF0000', 'Single', baselineAlignment, backgroundColor);
            elementBox.isSpellChecked = true;
        }
        else {
            elementBox.isSpellChecked = true;
        }
    };
    /**
     * Method to check errors for combined elements
     * @param {TextElementBox} elementBox
     * @param {number} underlineY
     * @private
     */
    // tslint:disable-next-line:max-line-length
    SpellChecker.prototype.checkElementCanBeCombined = function (elementBox, underlineY, beforeIndex, callSpellChecker, textToCombine, isNext, isPrevious, canCombine) {
        var currentText = isNullOrUndefined(textToCombine) ? '' : textToCombine;
        var isCombined = isNullOrUndefined(canCombine) ? false : canCombine;
        var checkPrevious = !isNullOrUndefined(isPrevious) ? isPrevious : true;
        var checkNext = !isNullOrUndefined(isNext) ? isNext : true;
        var combinedElements = [];
        var line = this.viewer.selection.getLineWidget(elementBox, 0);
        var index = line.children.indexOf(elementBox);
        var prevText = elementBox.text;
        combinedElements.push(elementBox);
        var difference = (isPrevious) ? 0 : 1;
        var prevCombined = false;
        var isPrevField = false;
        if (elementBox.text !== '\v') {
            if (checkPrevious) {
                var textElement = undefined;
                for (var i = index - difference; i >= 0; i--) {
                    textElement = line.children[i];
                    if (textElement instanceof TextElementBox && !isPrevField) {
                        if (prevText.indexOf(' ') !== 0 && textElement.text.lastIndexOf(' ') !== textElement.text.length - 1) {
                            prevCombined = !isNullOrUndefined(textToCombine) ? true : false;
                            currentText = textElement.text + currentText;
                            prevText = textElement.text;
                            isPrevField = false;
                            combinedElements.push(textElement);
                            isCombined = true;
                        }
                        else if (!isNullOrUndefined(textElement)) {
                            textElement = textElement.nextElement;
                            break;
                        }
                    }
                    else if (textElement instanceof FieldElementBox && textElement.fieldType !== 1) {
                        isPrevField = true;
                    }
                }
                var currentElement = (isCombined) ? textElement : elementBox;
                if (this.lookThroughPreviousLine(currentText, prevText, currentElement, underlineY, beforeIndex)) {
                    return true;
                }
            }
            if (isPrevious) {
                currentText = (prevCombined) ? currentText : elementBox.text + currentText;
            }
            else {
                currentText += elementBox.text;
            }
            isPrevField = false;
            var nextText = elementBox.text;
            if (checkNext) {
                var canCombine_1 = false;
                var element = undefined;
                for (var i = index + 1; i < line.children.length; i++) {
                    element = line.children[i];
                    if (element instanceof TextElementBox && !isPrevField) {
                        if (nextText.lastIndexOf(' ') !== nextText.length - 1 && element.text.indexOf(' ') !== 0) {
                            currentText += element.text;
                            nextText = element.text;
                            isPrevField = false;
                            combinedElements.push(element);
                            canCombine_1 = true;
                            isCombined = true;
                        }
                        else if (!isNullOrUndefined(element)) {
                            element = element.previousElement;
                            break;
                        }
                    }
                    else if (element instanceof FieldElementBox && element.fieldType !== 2) {
                        isPrevField = true;
                    }
                }
                var currentElement = (canCombine_1) ? element : elementBox;
                // tslint:disable-next-line:max-line-length
                if (currentElement.text !== '\f' && this.lookThroughNextLine(currentText, prevText, currentElement, underlineY, beforeIndex)) {
                    return true;
                }
            }
        }
        if (isCombined && callSpellChecker && !this.checkCombinedElementsBeIgnored(combinedElements, currentText)) {
            this.handleCombinedElements(elementBox, currentText, underlineY, beforeIndex);
        }
        return isCombined;
    };
    // tslint:disable-next-line:max-line-length
    SpellChecker.prototype.lookThroughPreviousLine = function (currentText, prevText, currentElement, underlineY, beforeIndex) {
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(currentElement) && currentElement.indexInOwner === 0 && !isNullOrUndefined(currentElement.line.previousLine)) {
            var previousLine = currentElement.line.previousLine;
            var index = previousLine.children.length - 1;
            if (!isNullOrUndefined(previousLine.children[index]) && previousLine.children[index] instanceof TextElementBox) {
                var firstElement = previousLine.children[index];
                if (currentElement.text.indexOf(' ') !== 0 && firstElement.text.lastIndexOf(' ') !== firstElement.text.length - 1) {
                    currentText = (currentText.length > 0) ? currentText : prevText;
                    this.checkElementCanBeCombined(firstElement, underlineY, beforeIndex, true, currentText, false, true, true);
                    return true;
                }
            }
        }
        return false;
    };
    // tslint:disable-next-line:max-line-length
    SpellChecker.prototype.lookThroughNextLine = function (currentText, prevText, elementBox, underlineY, beforeIndex) {
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(elementBox) && elementBox.indexInOwner === elementBox.line.children.length - 1 && !isNullOrUndefined(elementBox.line.nextLine)) {
            var nextLine = elementBox.line.nextLine;
            if (!isNullOrUndefined(nextLine.children[0]) && nextLine.children[0] instanceof TextElementBox) {
                var firstElement = nextLine.children[0];
                if (elementBox.text.lastIndexOf(' ') !== elementBox.text.length - 1 && firstElement.text.indexOf(' ') !== 0) {
                    currentText = (currentText.length > 0) ? currentText : prevText;
                    this.checkElementCanBeCombined(firstElement, underlineY, beforeIndex, true, currentText, true, false, true);
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Method to handle combined elements
     * @param {TextElementBox} elementBox
     * @param {string} currentText
     * @param {number} underlineY
     * @param {number} beforeIndex
     * @private
     */
    SpellChecker.prototype.handleCombinedElements = function (elementBox, currentText, underlineY, beforeIndex) {
        elementBox.istextCombined = true;
        var splittedText = currentText.split(/[\s]+/);
        // tslint:disable-next-line:max-line-length
        if (this.ignoreAllItems.indexOf(currentText) === -1 && elementBox instanceof TextElementBox && elementBox.ignoreOnceItems.indexOf(currentText) === -1) {
            if (splittedText.length > 1) {
                for (var i = 0; i < splittedText.length; i++) {
                    var currentText_1 = splittedText[i];
                    currentText_1 = this.manageSpecialCharacters(currentText_1, undefined, true);
                    // tslint:disable-next-line:max-line-length
                    this.viewer.render.handleUnorderdElements(currentText_1, elementBox, underlineY, i, 0, i === splittedText.length - 1, beforeIndex);
                }
            }
            else {
                currentText = this.manageSpecialCharacters(currentText, undefined, true);
                this.viewer.render.handleUnorderdElements(currentText, elementBox, underlineY, 0, 0, true, beforeIndex);
            }
        }
    };
    /**
     * Method to check error element collection has unique element
     * @param {ErrorTextElementBox[]} errorCollection
     * @param {ErrorTextElementBox} elementToCheck
     * @private
     */
    SpellChecker.prototype.CheckArrayHasSameElement = function (errorCollection, elementToCheck) {
        for (var i = 0; i < errorCollection.length; i++) {
            var errorText = errorCollection[i];
            // tslint:disable-next-line:max-line-length
            if ((errorText.start.location.x === elementToCheck.start.location.x) && (errorText.start.location.y === elementToCheck.start.location.y)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Method to handle splitted and combined words for spell check.
     * @param {any} jsonObject
     * @param {string} currentText
     * @param {ElementBox} elementBox
     * @param {boolean} isSamePage
     * @private
     */
    // tslint:disable-next-line:max-line-length
    SpellChecker.prototype.handleSplitWordSpellCheck = function (jsonObject, currentText, elementBox, isSamePage, underlineY, iteration, markIndex, isLastItem) {
        if (jsonObject.HasSpellingError && elementBox.text !== ' ' && isSamePage) {
            var matchResults = this.getMatchedResultsFromElement(elementBox, currentText);
            // tslint:disable-next-line:max-line-length
            markIndex = (elementBox.istextCombined) ? elementBox.line.getOffset(this.getCombinedElement(elementBox), 0) : markIndex;
            // tslint:disable-next-line:max-line-length
            this.viewer.owner.searchModule.textSearch.updateMatchedTextLocation(matchResults.matches, matchResults.textResults, matchResults.elementInfo, 0, elementBox, false, null, markIndex);
            this.handleMatchedResults(matchResults.textResults, elementBox, underlineY, iteration, jsonObject.Suggestions, isLastItem);
        }
        else if (isLastItem) {
            elementBox.isSpellChecked = true;
        }
    };
    /**
     * Method to include matched results in element box and to render it
     * @param {TextSearchResults} results
     * @param {TextElementBox} elementBox
     * @param {number} wavyLineY
     * @param {number} index
     */
    // tslint:disable-next-line:max-line-length
    SpellChecker.prototype.handleMatchedResults = function (results, elementBox, wavyLineY, index, suggestions, isLastItem) {
        if (results.length === 0 && isLastItem) {
            elementBox.isSpellChecked = true;
            return;
        }
        for (var i = 0; i < results.length; i++) {
            var span = this.createErrorElementWithInfo(results.innerList[i], elementBox);
            var color = '#FF0000';
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(elementBox.errorCollection) && !this.CheckArrayHasSameElement(elementBox.errorCollection, span)) {
                elementBox.errorCollection.splice(index, 0, span);
            }
            this.addErrorCollection(span.text, span, suggestions);
            // tslint:disable-next-line:max-line-length
            var backgroundColor = (elementBox.line.paragraph.containerWidget instanceof TableCellWidget) ? elementBox.paragraph.containerWidget.cellFormat.shading.backgroundColor : this.viewer.backgroundColor;
            this.viewer.render.renderWavyline(span, span.start.location.x, span.start.location.y - elementBox.margin.top, wavyLineY, color, 'Single', elementBox.characterFormat.baselineAlignment, backgroundColor);
            if (isLastItem) {
                elementBox.isSpellChecked = true;
            }
        }
    };
    /**
     * Calls the spell checker service
     * @param {number} languageID
     * @param {string} word
     * @param {boolean} checkSpellingAndSuggestion
     * @param {boolean} addWord
     * @private
     */
    /* tslint:disable:no-any */
    // tslint:disable-next-line:max-line-length
    SpellChecker.prototype.CallSpellChecker = function (languageID, word, checkSpelling, checkSuggestion, addWord, isByPage) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (!isNullOrUndefined(_this)) {
                var httpRequest_1 = new XMLHttpRequest();
                // tslint:disable-next-line:max-line-length
                var service = _this.viewer.owner.serviceUrl + _this.viewer.owner.serverActionSettings.spellCheck;
                service = (isByPage) ? service + 'ByPage' : service;
                httpRequest_1.open('POST', service, true);
                httpRequest_1.setRequestHeader('Content-Type', 'application/json');
                _this.setCustomHeaders(httpRequest_1);
                // tslint:disable-next-line:max-line-length
                /* tslint:disable:no-any */
                var spellCheckData = { LanguageID: languageID, TexttoCheck: word, CheckSpelling: checkSpelling, CheckSuggestion: checkSuggestion, AddWord: addWord };
                httpRequest_1.send(JSON.stringify(spellCheckData));
                httpRequest_1.onreadystatechange = function () {
                    if (httpRequest_1.readyState === 4) {
                        if (httpRequest_1.status === 200 || httpRequest_1.status === 304) {
                            resolve(httpRequest_1.response);
                        }
                        else {
                            reject(httpRequest_1.response);
                        }
                    }
                };
            }
        });
    };
    SpellChecker.prototype.setCustomHeaders = function (httpRequest) {
        for (var i = 0; i < this.viewer.owner.headers.length; i++) {
            var header = this.viewer.owner.headers[i];
            for (var _i = 0, _a = Object.keys(header); _i < _a.length; _i++) {
                var key = _a[_i];
                httpRequest.setRequestHeader(key, header[key]);
            }
        }
    };
    /**
     * Method to check for next error
     * @private
     */
    SpellChecker.prototype.checkForNextError = function () {
        if (!isNullOrUndefined(this.viewer)) {
            var errorWords = this.errorWordCollection;
            if (errorWords.length > 0) {
                for (var i = 0; i < errorWords.length; i++) {
                    var errorElements = errorWords.get(errorWords.keys[i]);
                    for (var j = 0; j < errorElements.length; j++) {
                        if (errorElements[j] instanceof ErrorTextElementBox && !errorElements[j].ischangeDetected) {
                            this.updateErrorElementTextBox(errorWords.keys[i], errorElements[j]);
                        }
                        else if (errorElements[j] instanceof TextElementBox) {
                            var matchResults = this.getMatchedResultsFromElement(errorElements[j]);
                            var results = matchResults.textResults;
                            // tslint:disable-next-line:max-line-length
                            var markIndex = (errorElements[j].ischangeDetected) ? errorElements[j].start.offset : errorElements[j].line.getOffset(errorElements[j], 0);
                            // tslint:disable-next-line:max-line-length
                            this.viewer.owner.searchModule.textSearch.updateMatchedTextLocation(matchResults.matches, results, matchResults.elementInfo, 0, errorElements[j], false, null, markIndex);
                            for (var i_1 = 0; i_1 < results.length; i_1++) {
                                var element = this.createErrorElementWithInfo(results.innerList[i_1], errorElements[j]);
                                this.updateErrorElementTextBox(element.text, element);
                                break;
                            }
                        }
                        break;
                    }
                    break;
                }
            }
            else {
                this.viewer.clearSelectionHighlight();
            }
        }
    };
    /**
     * Method to create error element with matched results
     * @param {TextSearchResult} result
     * @param {ElementBox} errorElement
     * @private
     */
    SpellChecker.prototype.createErrorElementWithInfo = function (result, errorElement) {
        var element = new ErrorTextElementBox();
        element.text = result.text;
        element.start = result.start;
        element.end = result.end;
        element.height = errorElement.height;
        element.canTrigger = errorElement.canTrigger;
        element.characterFormat.copyFormat(errorElement.characterFormat);
        element.width = this.viewer.textHelper.getWidth(element.text, errorElement.characterFormat);
        return element;
    };
    /**
     * Method to get matched results from element box
     * @param {ElementBox} errorElement
     * @private
     */
    SpellChecker.prototype.getMatchedResultsFromElement = function (errorElement, currentText) {
        var line = errorElement.line;
        // tslint:disable-next-line:max-line-length
        var pattern = this.viewer.owner.searchModule.textSearch.stringToRegex((isNullOrUndefined(currentText)) ? errorElement.text : currentText, 'CaseSensitive');
        this.viewer.owner.searchModule.textSearchResults.clearResults();
        // tslint:disable-next-line:max-line-length
        var results = this.viewer.owner.searchModule.textSearchResults;
        var textLineInfo = this.viewer.owner.searchModule.textSearch.getElementInfo(line.children[0], 0, false);
        var text = textLineInfo.fullText;
        var matches = [];
        var spans = textLineInfo.elementsWithOffset;
        var matchObject;
        //tslint:disable no-conditional-assignment
        while (!isNullOrUndefined(matchObject = pattern.exec(text))) {
            matches.push(matchObject);
        }
        return { 'matches': matches, 'elementInfo': spans, 'textResults': results };
    };
    /**
     * Method to update error element information
     * @param {string} error
     * @param {ErrorTextElementBox} errorElement
     * @private
     */
    SpellChecker.prototype.updateErrorElementTextBox = function (error, errorElement) {
        var element = errorElement;
        this.viewer.clearSelectionHighlight();
        this.viewer.selection.start = element.start;
        this.viewer.selection.end = element.end;
        this.viewer.selection.highlight(errorElement.start.paragraph, errorElement.start, errorElement.end);
        this.viewer.owner.spellCheckDialog.updateSuggestionDialog(error, element);
    };
    /**
     * Method to retrieve space information in a text
     * @param {string} text
     * @param {WCharacterFormat} characterFormat
     * @private
     */
    SpellChecker.prototype.getWhiteSpaceCharacterInfo = function (text, characterFormat) {
        /* tslint:disable:no-any */
        var matchedText = [];
        var width = 0;
        var length = 0;
        matchedText = text.match(/[\s]+/);
        if (!isNullOrUndefined(matchedText) && matchedText.length > 0) {
            for (var i = 0; i < matchedText.length; i++) {
                width += this.viewer.textHelper.getWidth(matchedText[i], characterFormat);
                length += matchedText[i].length;
            }
        }
        return { 'width': width, 'wordLength': length, 'isBeginning': (!isNullOrUndefined(matchedText) && matchedText.index === 0) };
    };
    /**
     * Retrieve Special character info
     * @param {string} text
     * @param {WCharacterFormat} characterFormat
     * @private
     */
    SpellChecker.prototype.getSpecialCharactersInfo = function (text, characterFormat) {
        /* tslint:disable:no-any */
        var matchedText = [];
        var beginingwidth = 0;
        var endWidth = 0;
        var length = 0;
        matchedText = text.match(/^[\#\@\!\~\$\%\^\&\*\(\)\-\_\+\=\{\}\[\]\:\;\"\'\,\<\.\>\/\?\`]*/);
        for (var i = 0; i < matchedText.length; i++) {
            if (!isNullOrUndefined(matchedText[i]) && matchedText[i].length > 0) {
                beginingwidth = this.viewer.textHelper.getWidth(matchedText[i], characterFormat);
            }
            length = matchedText.length;
        }
        matchedText = text.match(/[\#\@\!\~\$\%\^\&\*\(\)\-\_\+\=\{\}\[\]\:\;\"\'\,\<\.\>\/\?\`]*$/);
        for (var i = 0; i < matchedText.length; i++) {
            if (!isNullOrUndefined(matchedText[i]) && matchedText[i].length > 0) {
                endWidth = this.viewer.textHelper.getWidth(matchedText[i], characterFormat);
            }
            length = matchedText.length;
        }
        return { 'beginningWidth': beginingwidth, 'endWidth': endWidth, 'wordLength': length };
    };
    /**
     * Method to retrieve next available combined element
     * @param {ElementBox} element
     * @private
     */
    SpellChecker.prototype.getCombinedElement = function (element) {
        var prevElement = element;
        while (!isNullOrUndefined(element) && element instanceof TextElementBox && element.istextCombined) {
            prevElement = element;
            element = element.previousElement;
        }
        return prevElement;
    };
    /**
     * Method to retrieve next available combined element
     * @param {ElementBox} element
     */
    SpellChecker.prototype.checkCombinedElementsBeIgnored = function (elements, exactText) {
        exactText = this.manageSpecialCharacters(exactText, undefined, true);
        for (var i = 0; i < elements.length; i++) {
            if (elements[i].ignoreOnceItems.indexOf(exactText) !== -1) {
                return true;
            }
        }
        return false;
    };
    /**
     * Method to update error collection
     * @param {TextElementBox} currentElement
     * @param {TextElementBox} splittedElement
     * @private
     */
    SpellChecker.prototype.updateSplittedElementError = function (currentElement, splittedElement) {
        var errorCount = currentElement.errorCollection.length;
        if (errorCount > 0) {
            var errorCollection = [];
            for (var i = 0; i < errorCount; i++) {
                errorCollection.push(currentElement.errorCollection[i]);
            }
            for (var i = 0; i < errorCount; i++) {
                if (currentElement.text.indexOf(errorCollection[i].text) === -1) {
                    splittedElement.ischangeDetected = true;
                    currentElement.errorCollection.splice(0, 1);
                }
            }
        }
    };
    /**
     * @private
     */
    SpellChecker.prototype.getPageContent = function (page) {
        var content = '';
        if (this.viewer.owner.sfdtExportModule) {
            var sfdtExport = this.viewer.owner.sfdtExportModule;
            sfdtExport.Initialize();
            var document_1 = sfdtExport.writePage(page);
            if (this.viewer.owner.textExportModule) {
                var textExport = this.viewer.owner.textExportModule;
                textExport.pageContent = '';
                textExport.setDocument(document_1);
                textExport.writeInternal();
                content = textExport.pageContent;
            }
        }
        return content;
    };
    /**
     * @private
     * @param spelledWords
     */
    SpellChecker.prototype.updateUniqueWords = function (spelledWords) {
        if (!isNullOrUndefined(localStorage.getItem(this.uniqueKey))) {
            this.uniqueSpelledWords = JSON.parse(localStorage.getItem(this.uniqueKey));
        }
        var totalCount = spelledWords.length + this.uniqueSpelledWords.length;
        if (totalCount <= this.uniqueWordsCount) {
            for (var i = 0; i < spelledWords.length; i++) {
                this.checkForUniqueWords(spelledWords[i]);
            }
        }
        localStorage.setItem(this.uniqueKey, JSON.stringify(this.uniqueSpelledWords));
        this.uniqueSpelledWords = [];
    };
    SpellChecker.prototype.checkForUniqueWords = function (spellData) {
        var identityMatched = false;
        for (var i = 0; i < this.uniqueSpelledWords.length; i++) {
            if (this.uniqueSpelledWords[i].Text === spellData.Text) {
                identityMatched = true;
                break;
            }
        }
        if (!identityMatched) {
            this.uniqueSpelledWords.push(spellData);
        }
    };
    /**
     * Method to clear cached words for spell check
     */
    SpellChecker.prototype.clearCache = function () {
        if (!isNullOrUndefined(localStorage.getItem(this.uniqueKey))) {
            localStorage.removeItem(this.uniqueKey);
        }
    };
    /**
     * Method to create GUID
     */
    SpellChecker.prototype.createGuid = function () {
        var dateTime = new Date().getTime();
        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (char) {
            var randNo = (dateTime + Math.random() * 16) % 16 | 0;
            dateTime = Math.floor(dateTime / 16);
            return (char === 'x' ? randNo : (randNo & 0x3 | 0x8)).toString(16);
        });
        return uuid;
    };
    /**
     * Check spelling in page data
     * @private
     * @param {string} wordToCheck
     */
    SpellChecker.prototype.checkSpellingInPageInfo = function (wordToCheck) {
        var hasError = false;
        var elementPresent = false;
        /* tslint:disable:no-any */
        var uniqueWords = JSON.parse(localStorage.getItem(this.viewer.owner.spellChecker.uniqueKey));
        if (!isNullOrUndefined(uniqueWords)) {
            for (var i = 0; i < uniqueWords.length; i++) {
                if (uniqueWords[i].Text === wordToCheck) {
                    return { hasSpellError: uniqueWords[i].HasSpellError, isElementPresent: true };
                }
            }
        }
        return { hasSpellError: hasError, isElementPresent: elementPresent };
    };
    /**
     * @private
     */
    SpellChecker.prototype.destroy = function () {
        this.errorWordCollection = undefined;
        this.ignoreAllItems = undefined;
        this.errorSuggestions = undefined;
        this.uniqueSpelledWords = [];
        if (!isNullOrUndefined(localStorage.getItem(this.uniqueKey))) {
            localStorage.removeItem(this.uniqueKey);
        }
    };
    return SpellChecker;
}());

/**
 * Spell check dialog
 */
var SpellCheckDialog = /** @__PURE__ @class */ (function () {
    function SpellCheckDialog(viewer) {
        var _this = this;
        /* tslint:disable:no-any */
        this.selectHandler = function (args) {
            _this.selectedText = args.text;
        };
        /**
         * @private
         */
        this.onCancelButtonClick = function () {
            _this.owner.clearSelectionHighlight();
            _this.owner.dialog.hide();
        };
        /**
         * @private
         */
        this.onIgnoreClicked = function () {
            if (!isNullOrUndefined(_this.elementBox)) {
                showSpinner(_this.owner.dialog.element);
                _this.parent.spellChecker.manageReplace('Ignore Once', _this.elementBox);
                _this.removeErrors();
                _this.parent.spellChecker.checkForNextError();
            }
        };
        /**
         * @private
         */
        this.onIgnoreAllClicked = function () {
            if (!isNullOrUndefined(_this.elementBox)) {
                showSpinner(_this.owner.dialog.element);
                var text = _this.elementBox.text;
                _this.parent.spellChecker.handleIgnoreAllItems({ element: _this.elementBox, text: text });
                _this.parent.spellChecker.checkForNextError();
            }
        };
        /**
         * @private
         */
        this.addToDictClicked = function () {
            if (!isNullOrUndefined(_this.elementBox)) {
                showSpinner(_this.owner.dialog.element);
                // tslint:disable-next-line:max-line-length
                _this.parent.spellChecker.handleAddToDictionary({ element: _this.elementBox, text: _this.elementBox.text });
                if (_this.parent.spellChecker.errorWordCollection.containsKey(_this.errorText)) {
                    _this.parent.spellChecker.errorWordCollection.remove(_this.errorText);
                }
                _this.parent.spellChecker.checkForNextError();
            }
        };
        /**
         * @private
         */
        this.changeButtonClicked = function () {
            if (!isNullOrUndefined(_this.selectedText)) {
                _this.isSpellChecking = true;
                showSpinner(_this.owner.dialog.element);
                _this.parent.spellChecker.manageReplace(_this.selectedText, _this.elementBox);
                _this.removeErrors();
                _this.parent.spellChecker.checkForNextError();
                _this.owner.dialog.content = '';
            }
        };
        /**
         * @private
         */
        this.changeAllButtonClicked = function () {
            if (!isNullOrUndefined(_this.selectedText)) {
                _this.isSpellChecking = true;
                showSpinner(_this.owner.dialog.element);
                var elements = _this.parent.spellChecker.errorWordCollection.get(_this.errorText);
                for (var i = 0; i < elements.length; i++) {
                    if (elements[i] instanceof ErrorTextElementBox && !elements[i].ischangeDetected) {
                        _this.parent.spellChecker.manageReplace(_this.selectedText, elements[i]);
                    }
                    else if (elements[i] instanceof TextElementBox) {
                        var matchResults = _this.parent.spellChecker.getMatchedResultsFromElement(elements[i]);
                        var results = matchResults.textResults;
                        // tslint:disable-next-line:max-line-length
                        var markIndex = (elements[i].ischangeDetected) ? elements[i].start.offset : elements[i].line.getOffset(elements[i], 0);
                        // tslint:disable-next-line:max-line-length
                        _this.parent.searchModule.textSearch.updateMatchedTextLocation(matchResults.matches, results, matchResults.elementInfo, 0, elements[i], false, null, markIndex);
                        for (var j = 0; j < results.length; j++) {
                            var element = _this.parent.spellChecker.createErrorElementWithInfo(results.innerList[j], elements[i]);
                            _this.parent.spellChecker.manageReplace(_this.selectedText, element);
                        }
                    }
                }
                if (_this.parent.spellChecker.errorWordCollection.containsKey(_this.errorText)) {
                    _this.parent.spellChecker.errorWordCollection.remove(_this.errorText);
                }
                _this.parent.spellChecker.checkForNextError();
                _this.owner.dialog.content = '';
            }
        };
        this.owner = viewer;
        createSpinner({ target: this.owner.dialog.element, cssClass: 'e-spin-overlay' });
    }
    Object.defineProperty(SpellCheckDialog.prototype, "parent", {
        /**
         * Gets the spell checker
         * @private
         */
        get: function () {
            return this.owner.owner;
        },
        enumerable: true,
        configurable: true
    });
    SpellCheckDialog.prototype.getModuleName = function () {
        return 'SpellCheckDialog';
    };
    /**
     * Method to remove errors
     */
    SpellCheckDialog.prototype.removeErrors = function () {
        if (!isNullOrUndefined(this.errorText) && this.parent.spellChecker.errorWordCollection.containsKey(this.errorText)) {
            var textElement = this.parent.spellChecker.errorWordCollection.get(this.errorText);
            textElement.splice(0, 1);
            if (textElement.length === 0) {
                this.parent.spellChecker.errorWordCollection.remove(this.errorText);
            }
        }
        if (this.parent.spellChecker.errorWordCollection.length === 0) {
            this.owner.dialog.hide();
        }
    };
    /**
     * @private
     */
    SpellCheckDialog.prototype.show = function (error, elementbox, callSpellChecker) {
        this.target = undefined;
        this.localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        this.localValue.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.updateSuggestionDialog(error, elementbox, callSpellChecker);
        }
    };
    /**
     * @private
     */
    SpellCheckDialog.prototype.updateSuggestionDialog = function (error, elementBox, callSpellChecker) {
        var _this = this;
        this.elementBox = elementBox;
        var suggestions;
        if (this.isSpellChecking) {
            // tslint:disable-next-line:max-line-length
            /* tslint:disable:no-any */
            this.parent.spellChecker.CallSpellChecker(this.parent.spellChecker.languageID, error, false, true).then(function (data) {
                /* tslint:disable:no-any */
                var jsonObject = JSON.parse(data);
                suggestions = jsonObject.Suggestions;
                _this.isSpellChecking = false;
                _this.handleRetrievedSuggestion(error, suggestions);
            });
        }
        else {
            error = this.parent.spellChecker.manageSpecialCharacters(error, undefined, true);
            // tslint:disable-next-line:max-line-length
            suggestions = this.parent.spellChecker.errorSuggestions.containsKey(error) ? this.parent.spellChecker.errorSuggestions.get(error) : [];
            this.handleRetrievedSuggestion(error, suggestions);
        }
    };
    /**
     * Method to handle retrieved suggestions from server side
     * @param {string} error
     * @param {any} jsonObject
     */
    /* tslint:disable:no-any */
    SpellCheckDialog.prototype.handleRetrievedSuggestion = function (error, suggestions) {
        error = this.parent.spellChecker.manageSpecialCharacters(error, undefined, true);
        this.initSpellCheckDialog(this.localValue, error, suggestions);
        if (this.owner.selection.caret.style.display !== 'none') {
            this.owner.selection.caret.style.display = 'none';
        }
        this.owner.dialog.header = 'Spelling Editor';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.buttons = [{
                click: this.onCancelButtonClick,
                buttonModel: { content: this.localValue.getConstant('Cancel'), cssClass: 'e-control e-flat', isPrimary: true }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
        hideSpinner(this.owner.dialog.element);
    };
    /**
     * @private
     */
    SpellCheckDialog.prototype.initSpellCheckDialog = function (localValue, error, suggestion) {
        var id = this.owner.owner.containerId + '_add_SpellCheck';
        this.target = createElement('div', { id: id, className: 'e-de-insert-spellchecker' });
        this.errorText = error;
        var textContainer = createElement('div', {
            className: 'e-de-dlg-spellchecker-subheader', innerHTML: localValue.getConstant('Spelling')
        });
        this.target.appendChild(textContainer);
        var spellContainer = createElement('div', { className: 'e-de-spellcheck-error-container' });
        var listviewDiv = createElement('div', { className: 'e-de-dlg-spellcheck-listview', id: 'styles_listview' });
        spellContainer.appendChild(listviewDiv);
        this.spellingListView = new ListView({
            dataSource: [error],
            cssClass: 'e-dlg-spellcheck-listitem',
        });
        this.spellingListView.appendTo(listviewDiv);
        var buttonDiv = createElement('div', { className: 'e-de-spellcheck-btncontainer' });
        spellContainer.appendChild(buttonDiv);
        var ignoreButtonElement = createElement('button', { innerHTML: localValue.getConstant('Ignore'), id: 'ignore' });
        buttonDiv.appendChild(ignoreButtonElement);
        var ignorebutton = new Button({ cssClass: 'e-de-spellcheck-btn' });
        ignorebutton.appendTo(ignoreButtonElement);
        ignoreButtonElement.addEventListener('click', this.onIgnoreClicked);
        var ignoreAllButtonElement = createElement('button', { innerHTML: localValue.getConstant('Ignore all'), id: 'new' });
        buttonDiv.appendChild(ignoreAllButtonElement);
        var ignoreAllbutton = new Button({ cssClass: 'e-de-spellcheck-btn' });
        ignoreAllbutton.appendTo(ignoreAllButtonElement);
        ignoreAllButtonElement.addEventListener('click', this.onIgnoreAllClicked);
        // tslint:disable-next-line:max-line-length
        var addDictButtonElement = createElement('button', { innerHTML: localValue.getConstant('Add to Dictionary'), id: 'new' });
        buttonDiv.appendChild(addDictButtonElement);
        var addDictButton = new Button({ cssClass: 'e-de-spellcheck-btn' });
        addDictButton.appendTo(addDictButtonElement);
        addDictButtonElement.addEventListener('click', this.addToDictClicked);
        this.target.appendChild(spellContainer);
        var suggestionDiv = createElement('div', {
            className: 'e-de-dlg-spellchecker-subheaderbtm', innerHTML: localValue.getConstant('Suggestions')
        });
        this.target.appendChild(suggestionDiv);
        var suggestionContainer = createElement('div', { className: 'e-de-spellcheck-suggestion-container' });
        this.target.appendChild(suggestionContainer);
        var suggestListDiv = createElement('div', { className: 'e-de-dlg-spellcheck-listview' });
        suggestionContainer.appendChild(suggestListDiv);
        this.suggestionListView = new ListView({
            dataSource: suggestion,
            cssClass: 'e-dlg-spellcheck-listitem',
        });
        this.suggestionListView.appendTo(suggestListDiv);
        this.suggestionListView.addEventListener('select', this.selectHandler);
        var suggestBtnContainder = createElement('div', { className: 'e-de-spellcheck-btncontainer' });
        suggestionContainer.appendChild(suggestBtnContainder);
        var changeButtonElement = createElement('button', { innerHTML: localValue.getConstant('Change'), id: 'Change' });
        suggestBtnContainder.appendChild(changeButtonElement);
        var changeButton = new Button({ cssClass: 'e-de-spellcheck-btn' });
        changeButton.appendTo(changeButtonElement);
        changeButtonElement.addEventListener('click', this.changeButtonClicked);
        // tslint:disable-next-line:max-line-length
        var changeAllButtonElement = createElement('button', { innerHTML: localValue.getConstant('Change All'), id: 'Change All' });
        suggestBtnContainder.appendChild(changeAllButtonElement);
        var changeAllbutton = new Button({ cssClass: 'e-de-spellcheck-btn' });
        changeAllbutton.appendTo(changeAllButtonElement);
        changeAllButtonElement.addEventListener('click', this.changeAllButtonClicked);
        if (isNullOrUndefined(suggestion) || suggestion.length === 0) {
            changeButton.disabled = true;
            changeAllbutton.disabled = true;
        }
    };
    /**
     * @private
     */
    SpellCheckDialog.prototype.destroy = function () {
        if (this.target) {
            this.target.remove();
            this.target = undefined;
        }
        if (this.spellingListView) {
            this.spellingListView.destroy();
            this.spellingListView = undefined;
        }
        if (this.suggestionListView) {
            this.suggestionListView.destroy();
            this.suggestionListView = undefined;
        }
    };
    return SpellCheckDialog;
}());

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
// tslint:disable-next-line:max-line-length
/**
 * The Document editor component is used to draft, save or print rich text contents as page by page.
 */
var DocumentEditor = /** @__PURE__ @class */ (function (_super) {
    __extends(DocumentEditor, _super);
    /**
     * Initialize the constructor of DocumentEditor
     */
    function DocumentEditor(options, element) {
        var _this = _super.call(this, options, element) || this;
        //Internal Variable
        _this.enableHeaderFooterIn = false;
        /**
         * @private
         */
        _this.isShiftingEnabled = false;
        /**
         * @private
         */
        _this.isLayoutEnabled = true;
        /**
         * @private
         */
        _this.isPastingContent = false;
        /**
         * @private
         */
        _this.parser = undefined;
        _this.disableHistoryIn = false;
        /**
         * @private
         */
        _this.findResultsList = undefined;
        /**
         * @private
         */
        _this.tablePropertiesDialogModule = undefined;
        /**
         * @private
         */
        _this.bordersAndShadingDialogModule = undefined;
        /**
         * @private
         */
        _this.cellOptionsDialogModule = undefined;
        /**
         * @private
         */
        _this.tableOptionsDialogModule = undefined;
        /**
         * @private
         */
        _this.paragraphDialogModule = undefined;
        /**
         * @private
         */
        _this.imageResizerModule = undefined;
        /**
         * @private
         */
        _this.defaultLocale = {
            'Table': 'Table',
            'Row': 'Row',
            'Cell': 'Cell',
            'Ok': 'Ok',
            'Cancel': 'Cancel',
            'Size': 'Size',
            'Preferred Width': 'Preferred width',
            'Points': 'Points',
            'Percent': 'Percent',
            'Measure in': 'Measure in',
            'Alignment': 'Alignment',
            'Left': 'Left',
            'Center': 'Center',
            'Right': 'Right',
            'Justify': 'Justify',
            'Indent from left': 'Indent from left',
            'Borders and Shading': 'Borders and Shading',
            'Options': 'Options',
            'Specify height': 'Specify height',
            'At least': 'At least',
            'Exactly': 'Exactly',
            'Row height is': 'Row height is',
            'Allow row to break across pages': 'Allow row to break across pages',
            'Repeat as header row at the top of each page': 'Repeat as header row at the top of each page',
            'Vertical alignment': 'Vertical alignment',
            'Top': 'Top',
            'Bottom': 'Bottom',
            'Default cell margins': 'Default cell margins',
            'Default cell spacing': 'Default cell spacing',
            'Allow spacing between cells': 'Allow spacing between cells',
            'Cell margins': 'Cell margins',
            'Same as the whole table': 'Same as the whole table',
            'Borders': 'Borders',
            'None': 'None',
            'Style': 'Style',
            'Width': 'Width',
            'Height': 'Height',
            'Letter': 'Letter',
            'Tabloid': 'Tabloid',
            'Legal': 'Legal',
            'Statement': 'Statement',
            'Executive': 'Executive',
            'A3': 'A3',
            'A4': 'A4',
            'A5': 'A5',
            'B4': 'B4',
            'B5': 'B5',
            'Custom Size': 'Custom size',
            'Different odd and even': 'Different odd and even',
            'Different first page': 'Different first page',
            'From edge': 'From edge',
            'Header': 'Header',
            'Footer': 'Footer',
            'Margin': 'Margins',
            'Paper': 'Paper',
            'Layout': 'Layout',
            'Orientation': 'Orientation',
            'Landscape': 'Landscape',
            'Portrait': 'Portrait',
            'Show page numbers': 'Show page numbers',
            'Right align page numbers': 'Right align page numbers',
            'Nothing': 'Nothing',
            'Tab leader': 'Tab leader',
            'Show levels': 'Show levels',
            'Use hyperlinks instead of page numbers': 'Use hyperlinks instead of page numbers',
            'Build table of contents from': 'Build table of contents from',
            'Styles': 'Styles',
            'Available styles': 'Available styles',
            'TOC level': 'TOC level',
            'Heading': 'Heading',
            'Heading 1': 'Heading 1',
            'Heading 2': 'Heading 2',
            'Heading 3': 'Heading 3',
            'Heading 4': 'Heading 4',
            'Heading 5': 'Heading 5',
            'Heading 6': 'Heading 6',
            'List Paragraph': 'List Paragraph',
            'Normal': 'Normal',
            'Outline levels': 'Outline levels',
            'Table entry fields': 'Table entry fields',
            'Modify': 'Modify',
            'Color': 'Color',
            'Setting': 'Setting',
            'Box': 'Box',
            'All': 'All',
            'Custom': 'Custom',
            'Preview': 'Preview',
            'Shading': 'Shading',
            'Fill': 'Fill',
            'Apply To': 'Apply to',
            'Table Properties': 'Table Properties',
            'Cell Options': 'Cell Options',
            'Table Options': 'Table Options',
            'Insert Table': 'Insert Table',
            'Number of columns': 'Number of columns',
            'Number of rows': 'Number of rows',
            'Text to display': 'Text to display',
            'Address': 'Address',
            'Insert Hyperlink': 'Insert Hyperlink',
            'Edit Hyperlink': 'Edit Hyperlink',
            'Insert': 'Insert',
            'General': 'General',
            'Indentation': 'Indentation',
            'Before text': 'Before text',
            'Special': 'Special',
            'First line': 'First line',
            'Hanging': 'Hanging',
            'After text': 'After text',
            'By': 'By',
            'Before': 'Before',
            'Line Spacing': 'Line spacing',
            'After': 'After',
            'At': 'At',
            'Multiple': 'Multiple',
            'Spacing': 'Spacing',
            'Define new Multilevel list': 'Define new Multilevel list',
            'List level': 'List level',
            'Choose level to modify': 'Choose level to modify',
            'Level': 'Level',
            'Number format': 'Number format',
            'Number style for this level': 'Number style for this level',
            'Enter formatting for number': 'Enter formatting for number',
            'Start at': 'Start at',
            'Restart list after': 'Restart list after',
            'Position': 'Position',
            'Text indent at': 'Text indent at',
            'Aligned at': 'Aligned at',
            'Follow number with': 'Follow number with',
            'Tab character': 'Tab character',
            'Space': 'Space',
            'Arabic': 'Arabic',
            'UpRoman': 'UpRoman',
            'LowRoman': 'LowRoman',
            'UpLetter': 'UpLetter',
            'LowLetter': 'LowLetter',
            'Number': 'Number',
            'Leading zero': 'Leading zero',
            'Bullet': 'Bullet',
            'Ordinal': 'Ordinal',
            'Ordinal Text': 'Ordinal Text',
            'For East': 'For East',
            'No Restart': 'No Restart',
            'Font': 'Font',
            'Font style': 'Font style',
            'Underline style': 'Underline style',
            'Font color': 'Font color',
            'Effects': 'Effects',
            'Strikethrough': 'Strikethrough',
            'Superscript': 'Superscript',
            'Subscript': 'Subscript',
            'Double strikethrough': 'Double strikethrough',
            'Regular': 'Regular',
            'Bold': 'Bold',
            'Italic': 'Italic',
            'Cut': 'Cut',
            'Copy': 'Copy',
            'Paste': 'Paste',
            'Hyperlink': 'Hyperlink',
            'Open Hyperlink': 'Open Hyperlink',
            'Copy Hyperlink': 'Copy Hyperlink',
            'Remove Hyperlink': 'Remove Hyperlink',
            'Paragraph': 'Paragraph',
            'Linked Style': 'Linked(Paragraph and Character)',
            'Character': 'Character',
            'Merge Cells': 'Merge Cells',
            'Insert Above': 'Insert Above',
            'Insert Below': 'Insert Below',
            'Insert Left': 'Insert Left',
            'Insert Right': 'Insert Right',
            'Delete': 'Delete',
            'Delete Table': 'Delete Table',
            'Delete Row': 'Delete Row',
            'Delete Column': 'Delete Column',
            'File Name': 'File Name',
            'Format Type': 'Format Type',
            'Save': 'Save',
            'Navigation': 'Navigation',
            'Results': 'Results',
            'Replace': 'Replace',
            'Replace All': 'Replace All',
            'We replaced all': 'We replaced all',
            'Find': 'Find',
            'No matches': 'No matches',
            'All Done': 'All Done',
            'Result': 'Result',
            'of': 'of',
            'instances': 'instances',
            'with': 'with',
            'Click to follow link': 'Click to follow link',
            'Continue Numbering': 'Continue Numbering',
            'Bookmark name': 'Bookmark name',
            'Close': 'Close',
            'Restart At': 'Restart At',
            'Properties': 'Properties',
            'Name': 'Name',
            'Style type': 'Style type',
            'Style based on': 'Style based on',
            'Style for following paragraph': 'Style for following paragraph',
            'Formatting': 'Formatting',
            'Numbering and Bullets': 'Numbering and Bullets',
            'Numbering': 'Numbering',
            'Update Field': 'Update Field',
            'Edit Field': 'Edit Field',
            'Bookmark': 'Bookmark',
            'Page Setup': 'Page Setup',
            'No bookmarks found': 'No bookmarks found',
            'Number format tooltip information': 'Single-level number format: </br>[PREFIX]%[LEVELNUMBER][SUFFIX]</br>'
                + 'For example, "Chapter %1." will display numbering like</br>Chapter 1. Item</br>Chapter 2. Item</br>'
                + '</br>Chapter N. Item</br>'
                + '</br>Multilevel number format:</br>[PREFIX]%[LEVELNUMBER][SUFFIX]+[PREFIX]%[LEVELNUMBER][SUFFIX]'
                + '</br>For example, "%1.%2." will display numbering like</br>1.1. Item</br>1.2. Item</br></br>1.N. Item',
            'Format': 'Format',
            'Create New Style': 'Create New Style',
            'Modify Style': 'Modify Style',
            'New': 'New',
            'Bullets': 'Bullets',
            'Use bookmarks': 'Use bookmarks',
            'Table of Contents': 'Table of Contents',
            'AutoFit': 'AutoFit',
            'AutoFit to Contents': 'AutoFit to Contents',
            'AutoFit to Window': 'AutoFit to Window',
            'Fixed Column Width': 'Fixed Column Width',
            'Reset': 'Reset',
            'Match case': 'Match case',
            'Whole words': 'Whole words',
            'Add': 'Add',
            'Go To': 'Go To',
            'Search for': 'Search for',
            'Replace with': 'Replace with',
            'TOC 1': 'TOC 1',
            'TOC 2': 'TOC 2',
            'TOC 3': 'TOC 3',
            'TOC 4': 'TOC 4',
            'TOC 5': 'TOC 5',
            'TOC 6': 'TOC 6',
            'TOC 7': 'TOC 7',
            'TOC 8': 'TOC 8',
            'TOC 9': 'TOC 9',
            'Right-to-left': 'Right-to-left',
            'Left-to-right': 'Left-to-right',
            'Direction': 'Direction',
            'Table direction': 'Table direction',
            'Indent from right': 'Indent from right',
            /* tslint:disable */
            "Contextual Spacing": "Don't add space between the paragraphs of the same styles",
            "Password Mismatch": "The password don't match",
            /* tslint:enable */
            'Restrict Editing': 'Restrict Editing',
            'Formatting restrictions': 'Formatting restrictions',
            'Allow formatting': 'Allow formatting',
            'Editing restrictions': 'Editing restrictions',
            'Read only': 'Read only',
            'Exceptions Optional': 'Exceptions (optional)',
            // tslint:disable-next-line:max-line-length
            'Select Part Of Document And User': 'Select parts of the document and choose users who are allowed to freely edit them.',
            'Everyone': 'Everyone',
            'More users': 'More users',
            'Add Users': 'Add Users',
            'Enforcing Protection': 'Yes, Start Enforcing Protection',
            'Start Enforcing Protection': 'Start Enforcing Protection',
            'Enter User': 'Enter User',
            'Users': 'Users',
            'Enter new password': 'Enter new password',
            'Reenter new password to confirm': 'Reenter new password to confirm',
            'Your permissions': 'Your permissions',
            // tslint:disable-next-line:max-line-length
            'Protected Document': 'This document is protected from unintentional editing.You may edit in this region.',
            'You may format text only with certain styles': 'You may format text only with certain styles.',
            'Stop Protection': 'Stop Protection',
            'Password': 'Password',
            'Spelling Editor': 'Spelling Editor',
            'Spelling': 'Spelling',
            'Spell Check': 'Spell Check',
            'Underline errors': 'Underline errors',
            'Ignore': 'Ignore',
            'Ignore all': 'Ignore All',
            'Add to Dictionary': 'Add to Dictionary',
            'Change': 'Change',
            'Change All': 'Change All',
            'Suggestions': 'Suggestions',
            'The password is incorrect': 'The password is incorrect',
            'Error in establishing connection with web server': 'Error in establishing connection with web server',
            'Highlight the regions I can edit': 'Highlight the regions I can edit',
            'Show All Regions I Can Edit': 'Show All Regions I Can Edit',
            'Find Next Region I Can Edit': 'Find Next Region I Can Edit',
            'Keep source formatting': 'Keep source formatting',
            'Match destination formatting': 'Match destination formatting',
            'Text only': 'Text only',
            'Comments': 'Comments',
            'Type your comment': 'Type your comment',
            'Post': 'Post',
            'Reply': 'Reply',
            'New Comment': 'New Comment',
            'Edit': 'Edit',
            'Resolve': 'Resolve',
            'Reopen': 'Reopen',
            'No comments in this document': 'No comments in this document',
            'more': 'more',
            'Type your comment here': 'Type your comment here',
            'Next Comment': 'Next Comment',
            'Previous Comment': 'Previous Comment',
            'Un-posted comments': 'Un-posted comments',
            // tslint:disable-next-line:max-line-length
            'Discard Comment': 'Added comments not posted. If you continue, that comment will be discarded.',
            'No Headings': 'No Heading Found!',
            'Add Headings': 'This document has no headings. Please add headings and try again.'
        };
        _this.viewer = new PageLayoutViewer(_this);
        _this.parser = new SfdtReader(_this.viewer);
        return _this;
    }
    DocumentEditor_1 = DocumentEditor;
    Object.defineProperty(DocumentEditor.prototype, "enableHeaderAndFooter", {
        /**
         * @private
         */
        get: function () {
            return this.enableHeaderFooterIn;
        },
        set: function (value) {
            this.enableHeaderFooterIn = value;
            this.viewer.updateScrollBars();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentEditor.prototype, "pageCount", {
        /**
         * Gets the total number of pages.
         * @returns {number}
         */
        get: function () {
            if (!this.isDocumentLoaded || isNullOrUndefined(this.viewer)) {
                return 1;
            }
            return this.viewer.pages.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentEditor.prototype, "selection", {
        /**
         *  Gets the selection object of the document editor.
         * @aspType Selection
         * @blazorType Selection
         * @returns {Selection}
         * @default undefined
         */
        get: function () {
            return this.selectionModule;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentEditor.prototype, "editor", {
        /**
         *  Gets the editor object of the document editor.
         * @aspType Editor
         * @blazorType Editor
         * @returns {Editor}
         * @default undefined
         */
        get: function () {
            return this.editorModule;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentEditor.prototype, "editorHistory", {
        /**
         * Gets the editor history object of the document editor.
         * @aspType EditorHistory
         * @blazorType EditorHistory
         * @returns {EditorHistory}
         */
        get: function () {
            return this.editorHistoryModule;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentEditor.prototype, "search", {
        /**
         * Gets the search object of the document editor.
         * @aspType Search
         * @blazorType Search
         * @returns { Search }
         */
        get: function () {
            return this.searchModule;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentEditor.prototype, "contextMenu", {
        /**
         * Gets the context menu object of the document editor.
         * @aspType ContextMenu
         * @blazorType ContextMenu
         * @returns {ContextMenu}
         */
        get: function () {
            return this.contextMenuModule;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentEditor.prototype, "spellCheckDialog", {
        /**
         * Gets the spell check dialog object of the document editor.
         * @returns SpellCheckDialog
         */
        get: function () {
            return this.spellCheckDialogModule;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentEditor.prototype, "spellChecker", {
        /**
         * Gets the spell check object of the document editor.
         * @aspType SpellChecker
         * @blazorType SpellChecker
         * @returns SpellChecker
         */
        get: function () {
            return this.spellCheckerModule;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentEditor.prototype, "containerId", {
        /**
         * @private
         */
        get: function () {
            return this.element.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentEditor.prototype, "isDocumentLoaded", {
        /**
         * @private
         */
        get: function () {
            return this.isDocumentLoadedIn;
        },
        set: function (value) {
            this.isDocumentLoadedIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentEditor.prototype, "enableHistoryMode", {
        /**
         * Determines whether history needs to be enabled or not.
         * @default - false
         * @private
         */
        get: function () {
            return this.enableEditorHistory && !isNullOrUndefined(this.editorHistoryModule);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentEditor.prototype, "documentStart", {
        /**
         * Gets the start text position in the document.
         * @default undefined
         * @private
         */
        get: function () {
            if (!isNullOrUndefined(this.selectionModule)) {
                return this.selection.getDocumentStart();
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentEditor.prototype, "documentEnd", {
        /**
         * Gets the end text position in the document.
         * @default undefined
         * @private
         */
        get: function () {
            if (!isNullOrUndefined(this.selectionModule)) {
                return this.selection.getDocumentEnd();
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentEditor.prototype, "isReadOnlyMode", {
        /**
         * @private
         */
        get: function () {
            return this.isReadOnly || isNullOrUndefined(this.editorModule)
                || isNullOrUndefined(this.selectionModule) || !isNullOrUndefined(this.editor) && this.editor.restrictEditing;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentEditor.prototype, "enableImageResizerMode", {
        /**
         * Specifies to enable image resizer option
         * default - false
         * @private
         */
        get: function () {
            return this.enableImageResizer && !isNullOrUndefined(this.imageResizerModule);
        },
        enumerable: true,
        configurable: true
    });
    DocumentEditor.prototype.preRender = function () {
        this.findResultsList = [];
        //pre render section
    };
    DocumentEditor.prototype.render = function () {
        this.viewer.initializeComponents();
        this.openBlank();
        if (!isNullOrUndefined(this.element)) {
            var container = this.element;
            container.style.minHeight = '200px';
            container.style.minWidth = '200px';
        }
        this.renderComplete();
    };
    /**
     * Get component name
     * @private
     */
    DocumentEditor.prototype.getModuleName = function () {
        return 'DocumentEditor';
    };
    /**
     * Called internally if any of the property value changed.
     * @private
     */
    DocumentEditor.prototype.onPropertyChanged = function (model, oldProp) {
        for (var _i = 0, _a = Object.keys(model); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'zoomFactor':
                    if (this.viewer) {
                        this.viewer.zoomFactor = model.zoomFactor;
                    }
                    break;
                case 'locale':
                    this.localizeDialogs();
                    break;
                case 'isReadOnly':
                    if (!isNullOrUndefined(this.optionsPaneModule) && this.optionsPaneModule.isOptionsPaneShow) {
                        this.optionsPaneModule.showHideOptionsPane(false);
                    }
                    break;
                case 'currentUser':
                case 'userColor':
                    if (this.selection && this.viewer.isDocumentProtected) {
                        this.selection.highlightEditRegion();
                    }
                    break;
                case 'pageGap':
                case 'pageOutline':
                    this.viewer.updateScrollBars();
                    break;
                case 'zIndex':
                    if (this.viewer.dialog) {
                        this.viewer.dialog.zIndex = model.zIndex + 10;
                    }
                    if (this.viewer.dialog2) {
                        this.viewer.dialog2.zIndex = model.zIndex;
                    }
                    break;
                case 'showComments':
                    if (this.viewer) {
                        this.viewer.showComments(model.showComments);
                    }
                    break;
                case 'enableRtl':
                    this.localizeDialogs(model.enableRtl);
                    break;
                case 'enableComment':
                    if (this.viewer && this.showComments) {
                        this.showComments = this.showComments ? this.enableComment : false;
                        this.viewer.showComments(model.enableComment);
                    }
                    this.viewer.updateScrollBars();
                    break;
            }
        }
    };
    DocumentEditor.prototype.localizeDialogs = function (enableRtl) {
        if (this.locale !== '') {
            var l10n = new L10n('documenteditor', this.defaultLocale);
            l10n.setLocale(this.locale);
            if (!isNullOrUndefined(enableRtl)) {
                this.viewer.dialog.enableRtl = enableRtl;
                this.viewer.dialog2.enableRtl = enableRtl;
            }
            if (this.optionsPaneModule) {
                this.optionsPaneModule.initOptionsPane(l10n, enableRtl);
            }
            if (this.paragraphDialogModule) {
                this.paragraphDialogModule.initParagraphDialog(l10n);
            }
            if (this.pageSetupDialogModule) {
                this.pageSetupDialogModule.initPageSetupDialog(l10n, enableRtl);
            }
            if (this.fontDialogModule) {
                this.fontDialogModule.initFontDialog(l10n, enableRtl);
            }
            if (this.hyperlinkDialogModule) {
                this.hyperlinkDialogModule.initHyperlinkDialog(l10n, enableRtl);
            }
            if (this.contextMenuModule) {
                this.contextMenuModule.contextMenuInstance.destroy();
                this.contextMenuModule.initContextMenu(l10n, enableRtl);
            }
            if (this.listDialogModule) {
                this.listDialogModule.initListDialog(l10n, enableRtl);
            }
            if (this.tablePropertiesDialogModule) {
                this.tablePropertiesDialogModule.initTablePropertyDialog(l10n, enableRtl);
            }
            if (this.bordersAndShadingDialogModule) {
                this.bordersAndShadingDialogModule.initBordersAndShadingsDialog(l10n, enableRtl);
            }
            if (this.cellOptionsDialogModule) {
                this.cellOptionsDialogModule.initCellMarginsDialog(l10n, enableRtl);
            }
            if (this.tableOptionsDialogModule) {
                this.tableOptionsDialogModule.initTableOptionsDialog(l10n, enableRtl);
            }
            if (this.tableDialogModule) {
                this.tableDialogModule.initTableDialog(l10n);
            }
            if (this.styleDialogModule) {
                this.styleDialogModule.initStyleDialog(l10n, enableRtl);
            }
            if (this.tableOfContentsDialogModule) {
                this.tableOfContentsDialogModule.initTableOfContentDialog(l10n, enableRtl);
            }
            if (this.commentReviewPane && this.commentReviewPane.reviewPane) {
                if (this.enableRtl) {
                    classList(this.commentReviewPane.reviewPane, ['e-rtl'], []);
                }
                else {
                    classList(this.commentReviewPane.reviewPane, [], ['e-rtl']);
                }
            }
        }
    };
    /**
     * Set the default character format for document editor
     * @param characterFormat
     */
    DocumentEditor.prototype.setDefaultCharacterFormat = function (characterFormat) {
        this.characterFormat = characterFormat;
    };
    /**
     * Set the default paragraph format for document editor
     * @param paragraphFormat
     */
    DocumentEditor.prototype.setDefaultParagraphFormat = function (paragraphFormat) {
        this.paragraphFormat = paragraphFormat;
    };
    /**
     * Set the default section format for document editor
     * @param sectionFormat
     */
    DocumentEditor.prototype.setDefaultSectionFormat = function (sectionFormat) {
        this.sectionFormat = sectionFormat;
    };
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    DocumentEditor.prototype.getPersistData = function () {
        return 'documenteditor';
    };
    DocumentEditor.prototype.clearPreservedCollectionsInViewer = function () {
        if (this.viewer instanceof LayoutViewer) {
            this.viewer.clearDocumentItems();
        }
    };
    /**
     * @private
     */
    DocumentEditor.prototype.getDocumentEditorElement = function () {
        return this.element;
    };
    /**
     * @private
     */
    DocumentEditor.prototype.fireContentChange = function () {
        var eventArgs = { source: isBlazor() ? null : this };
        this.trigger('contentChange', eventArgs);
    };
    /**
     * @private
     */
    DocumentEditor.prototype.fireDocumentChange = function () {
        var eventArgs = { source: isBlazor() ? null : this };
        this.trigger('documentChange', eventArgs);
    };
    /**
     * @private
     */
    DocumentEditor.prototype.fireSelectionChange = function () {
        if (!this.viewer.isCompositionStart && Browser.isDevice && this.editorModule) {
            this.editorModule.predictText();
        }
        var eventArgs = { source: isBlazor() ? null : this };
        this.trigger('selectionChange', eventArgs);
    };
    /**
     * @private
     */
    DocumentEditor.prototype.fireZoomFactorChange = function () {
        var eventArgs = { source: isBlazor() ? null : this };
        this.trigger('zoomFactorChange', eventArgs);
    };
    /**
     * @private
     */
    DocumentEditor.prototype.fireViewChange = function () {
        if (this.viewer && this.viewer.pages.length > 0) {
            if (this.viewer.visiblePages.length > 0) {
                var pages = this.viewer.visiblePages;
                var eventArgs = {
                    startPage: pages[0].index + 1,
                    endPage: pages[pages.length - 1].index + 1,
                    source: isBlazor() ? null : this
                };
                this.trigger('viewChange', eventArgs);
            }
        }
    };
    /**
     * @private
     */
    DocumentEditor.prototype.fireCustomContextMenuSelect = function (item) {
        var eventArgs = { id: item };
        this.trigger('customContextMenuSelect', eventArgs);
    };
    /**
     * @private
     */
    DocumentEditor.prototype.fireCustomContextMenuBeforeOpen = function (item) {
        var eventArgs = { ids: item };
        this.trigger('customContextMenuBeforeOpen', eventArgs);
    };
    /**
     * Shows the Paragraph dialog
     * @private
     */
    DocumentEditor.prototype.showParagraphDialog = function (paragraphFormat) {
        if (this.paragraphDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.paragraphDialogModule.show(paragraphFormat);
        }
    };
    /**
     * Shows the margin dialog
     * @private
     */
    DocumentEditor.prototype.showPageSetupDialog = function () {
        if (this.pageSetupDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.pageSetupDialogModule.show();
        }
    };
    /**
     * Shows the font dialog
     * @private
     */
    DocumentEditor.prototype.showFontDialog = function (characterFormat) {
        if (this.fontDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.fontDialogModule.showFontDialog(characterFormat);
        }
    };
    /**
     * Shows the cell option dialog
     * @private
     */
    DocumentEditor.prototype.showCellOptionsDialog = function () {
        if (this.cellOptionsDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.cellOptionsDialogModule.show();
        }
    };
    /**
     * Shows the table options dialog.
     * @private
     */
    DocumentEditor.prototype.showTableOptionsDialog = function () {
        if (this.tableOptionsDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.tableOptionsDialogModule.show();
        }
    };
    /**
     * Shows insert table dialog
     * @private
     */
    DocumentEditor.prototype.showTableDialog = function () {
        if (this.tableDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.tableDialogModule.show();
        }
    };
    /**
     * Shows the table of content dialog
     * @private
     */
    DocumentEditor.prototype.showTableOfContentsDialog = function () {
        if (this.tableOfContentsDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.tableOfContentsDialogModule.show();
        }
    };
    /* tslint:enable:no-any */
    /**
     * Shows the style dialog
     * @private
     */
    DocumentEditor.prototype.showStyleDialog = function () {
        if (this.styleDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.styleDialogModule.show();
        }
    };
    /**
     * Shows the hyperlink dialog
     * @private
     */
    DocumentEditor.prototype.showHyperlinkDialog = function () {
        if (this.hyperlinkDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.hyperlinkDialogModule.show();
        }
    };
    /**
     * Shows the bookmark dialog.
     * @private
     */
    DocumentEditor.prototype.showBookmarkDialog = function () {
        if (this.bookmarkDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.bookmarkDialogModule.show();
        }
    };
    /**
     * Shows the styles dialog.
     * @private
     */
    DocumentEditor.prototype.showStylesDialog = function () {
        if (this.stylesDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.stylesDialogModule.show();
        }
    };
    /**
     * Shows the List dialog
     * @private
     */
    DocumentEditor.prototype.showListDialog = function () {
        if (this.listDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.listDialogModule.showListDialog();
        }
    };
    /**
     * Shows the table properties dialog
     * @private
     */
    DocumentEditor.prototype.showTablePropertiesDialog = function () {
        if (this.tablePropertiesDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.tablePropertiesDialogModule.show();
        }
    };
    /**
     * Shows the borders and shading dialog
     * @private
     */
    DocumentEditor.prototype.showBordersAndShadingDialog = function () {
        if (this.bordersAndShadingDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.bordersAndShadingDialogModule.show();
        }
    };
    //tslint:disable: max-func-body-length
    DocumentEditor.prototype.requiredModules = function () {
        var modules = [];
        if (this.enablePrint) {
            modules.push({
                member: 'Print', args: []
            });
        }
        if (this.enableSfdtExport || this.enableWordExport || this.enableTextExport || this.enableSelection || this.enableEditor) {
            modules.push({
                member: 'SfdtExport', args: [this.viewer]
            });
        }
        if (this.enableWordExport) {
            modules.push({
                member: 'WordExport', args: []
            });
        }
        if (this.enableTextExport) {
            modules.push({
                member: 'TextExport', args: []
            });
        }
        if (this.enableSelection || this.enableSearch || this.enableEditor) {
            modules.push({
                member: 'Selection', args: [this]
            });
            if (this.enableContextMenu) {
                modules.push({
                    member: 'ContextMenu', args: [this.viewer]
                });
            }
        }
        if (this.enableSearch) {
            modules.push({
                member: 'Search', args: [this]
            });
            if (this.enableOptionsPane) {
                modules.push({
                    member: 'OptionsPane', args: [this.viewer]
                });
            }
        }
        if (this.enableEditor) {
            modules.push({
                member: 'Editor', args: [this.viewer]
            });
            if (this.enableImageResizer) {
                modules.push({
                    member: 'ImageResizer', args: [this, this.viewer]
                });
            }
            if (this.enableEditorHistory) {
                modules.push({
                    member: 'EditorHistory', args: [this]
                });
            }
            if (this.enableHyperlinkDialog) {
                modules.push({
                    member: 'HyperlinkDialog', args: [this.viewer]
                });
            }
            if (this.enableTableDialog) {
                modules.push({
                    member: 'TableDialog', args: [this.viewer]
                });
            }
            if (this.enableBookmarkDialog) {
                modules.push({
                    member: 'BookmarkDialog', args: [this.viewer]
                });
            }
            if (this.enableTableOfContentsDialog) {
                modules.push({
                    member: 'TableOfContentsDialog', args: [this.viewer]
                });
            }
            if (this.enablePageSetupDialog) {
                modules.push({
                    member: 'PageSetupDialog', args: [this.viewer]
                });
            }
            if (this.enableStyleDialog) {
                modules.push({
                    member: 'StylesDialog', args: [this.viewer]
                });
                modules.push({
                    member: 'StyleDialog', args: [this.viewer]
                });
                modules.push({
                    member: 'BulletsAndNumberingDialog', args: [this.viewer]
                });
            }
            if (this.enableListDialog) {
                modules.push({
                    member: 'ListDialog', args: [this.viewer]
                });
            }
            if (this.enableParagraphDialog) {
                modules.push({
                    member: 'ParagraphDialog', args: [this.viewer]
                });
            }
            if (this.enableFontDialog) {
                modules.push({
                    member: 'FontDialog', args: [this.viewer]
                });
            }
            if (this.enableTablePropertiesDialog) {
                modules.push({
                    member: 'TablePropertiesDialog', args: [this.viewer]
                });
                modules.push({
                    member: 'CellOptionsDialog', args: [this.viewer]
                });
            }
            if (this.enableBordersAndShadingDialog) {
                modules.push({
                    member: 'BordersAndShadingDialog', args: [this.viewer]
                });
            }
            if (this.enableTableOptionsDialog) {
                modules.push({
                    member: 'TableOptionsDialog', args: [this.viewer]
                });
            }
            if (this.enableSpellCheck) {
                modules.push({
                    member: 'SpellChecker', args: [this.viewer]
                });
                modules.push({
                    member: 'SpellCheckDialog', args: [this.viewer]
                });
            }
        }
        return modules;
    };
    // Public Implementation Starts
    /**
     * Opens the given Sfdt text.
     * @param {string} sfdtText.
     */
    DocumentEditor.prototype.open = function (sfdtText) {
        if (!isNullOrUndefined(this.viewer)) {
            this.showComments = false;
            this.clearPreservedCollectionsInViewer();
            this.viewer.userCollection.push('Everyone');
            this.viewer.lists = [];
            this.viewer.abstractLists = [];
            this.viewer.styles = new WStyles();
            this.viewer.cachedPages = [];
            if (this.enableSpellCheck && !this.spellChecker.enableOptimizedSpellCheck) {
                this.viewer.triggerElementsOnLoading = true;
                this.viewer.triggerSpellCheck = true;
            }
            if (!isNullOrUndefined(sfdtText) && this.viewer) {
                this.viewer.onDocumentChanged(this.parser.convertJsonToDocument(sfdtText));
                if (this.editorModule) {
                    this.editorModule.intializeDefaultStyles();
                }
            }
            if (this.enableSpellCheck && !this.spellChecker.enableOptimizedSpellCheck) {
                this.viewer.triggerElementsOnLoading = false;
                this.viewer.triggerSpellCheck = false;
            }
        }
    };
    /**
     * Scrolls view to start of the given page number if exists.
     * @param  {number} pageNumber.
     * @returns void
     */
    DocumentEditor.prototype.scrollToPage = function (pageNumber) {
        if (isNullOrUndefined(this.viewer) || pageNumber < 1 || pageNumber > this.viewer.pages.length) {
            return false;
        }
        this.viewer.scrollToPage(pageNumber - 1);
        return true;
    };
    /**
     * Enables all the modules.
     * @returns void
     */
    DocumentEditor.prototype.enableAllModules = function () {
        this.enablePrint = this.enableSfdtExport = this.enableWordExport = this.enableTextExport
            = this.enableSelection = this.enableContextMenu = this.enableSearch = this.enableOptionsPane
                = this.enableEditor = this.enableImageResizer = this.enableEditorHistory
                    = this.enableHyperlinkDialog = this.enableTableDialog = this.enableBookmarkDialog
                        = this.enableTableOfContentsDialog = this.enablePageSetupDialog = this.enableStyleDialog
                            = this.enableListDialog = this.enableParagraphDialog = this.enableFontDialog
                                = this.enableTablePropertiesDialog = this.enableBordersAndShadingDialog
                                    = this.enableTableOptionsDialog = this.enableSpellCheck = true;
        // tslint:disable-next-line:max-line-length
        DocumentEditor_1.Inject(Print, SfdtExport, WordExport, TextExport, Selection, Search, Editor, ImageResizer, EditorHistory, ContextMenu$1, OptionsPane, HyperlinkDialog, TableDialog, BookmarkDialog, TableOfContentsDialog, PageSetupDialog, StyleDialog, ListDialog, ParagraphDialog, BulletsAndNumberingDialog, FontDialog, TablePropertiesDialog, BordersAndShadingDialog, TableOptionsDialog, CellOptionsDialog, StylesDialog, SpellChecker, SpellCheckDialog);
    };
    /**
     * Resizes the component and its sub elements based on given size or container size.
     * @param width
     * @param height
     */
    DocumentEditor.prototype.resize = function (width, height) {
        if (this.element) {
            if (!isNullOrUndefined(width) && width > 200) {
                this.element.style.width = width + 'px';
            }
            if (!isNullOrUndefined(height) && height > 200) {
                this.element.style.height = height + 'px';
            }
            if (this.viewer) {
                this.viewer.updateViewerSize();
            }
        }
    };
    /**
     * Shifts the focus to the document.
     */
    DocumentEditor.prototype.focusIn = function () {
        if (this.viewer) {
            this.viewer.updateFocus();
        }
    };
    /**
     * Fits the page based on given fit type.
     * @param  {PageFitType} pageFitType? - Default value of pageFitType parameter is 'None'
     * @returns void
     */
    DocumentEditor.prototype.fitPage = function (pageFitType) {
        if (isNullOrUndefined(pageFitType)) {
            pageFitType = 'None';
        }
        if (this.viewer) {
            this.viewer.pageFitType = pageFitType;
        }
    };
    /**
     * Prints the document.
     * @param  {Window} printWindow? - Default value of 'printWindow' parameter is undefined.
     */
    DocumentEditor.prototype.print = function (printWindow) {
        if (isNullOrUndefined(this.viewer)) {
            throw new Error('Invalid operation.');
        }
        if (this.printModule) {
            this.printModule.print(this.viewer, printWindow);
        }
        else {
            throw new Error('Invalid operation. Print is not enabled.');
        }
    };
    /**
     * Serialize the data to JSON string.
     */
    DocumentEditor.prototype.serialize = function () {
        var json = '';
        if (this.enableSfdtExport && this.sfdtExportModule instanceof SfdtExport) {
            json = this.sfdtExportModule.serialize();
        }
        else {
            throw new Error('Invalid operation. Sfdt export is not enabled.');
        }
        return json;
    };
    /**
     * Saves the document.
     * @param {string} fileName
     * @param {FormatType} formatType
     */
    DocumentEditor.prototype.save = function (fileName, formatType) {
        fileName = fileName || 'Untitled';
        if (isNullOrUndefined(this.viewer)) {
            throw new Error('Invalid operation.');
        }
        if (formatType === 'Docx' && this.wordExportModule) {
            if (this.wordExportModule) {
                this.wordExportModule.save(this.viewer, fileName);
            }
        }
        else if (formatType === 'Txt' && this.textExportModule) {
            this.textExportModule.save(this.viewer, fileName);
        }
        else if (formatType === 'Sfdt' && this.enableSfdtExport && this.sfdtExportModule) {
            var jsonString = this.serialize();
            var blob = new Blob([jsonString], {
                type: 'application/json'
            });
            Save.save(fileName + '.sfdt', blob);
        }
        else {
            throw new Error('Invalid operation. Specified export is not enabled.');
        }
    };
    /**
     * Saves the document as blob.
     * @param {FormatType} formatType
     */
    DocumentEditor.prototype.saveAsBlob = function (formatType) {
        var _this = this;
        if (isNullOrUndefined(this.viewer)) {
            throw new Error('Invalid operation');
        }
        return new Promise(function (resolve, reject) {
            if (formatType === 'Docx' && _this.wordExportModule) {
                resolve(_this.wordExportModule.saveAsBlob(_this.viewer));
            }
            else if (formatType === 'Txt' && _this.textExportModule) {
                resolve(_this.textExportModule.saveAsBlob(_this.viewer));
            }
            else if (formatType === 'Sfdt' && _this.enableSfdtExport && _this.sfdtExportModule) {
                resolve(_this.sfdtExportModule.saveAsBlob(_this.viewer));
            }
        });
    };
    /**
     * Opens a blank document.
     */
    DocumentEditor.prototype.openBlank = function () {
        var section = new BodyWidget();
        section.index = 0;
        section.sectionFormat = new WSectionFormat(section);
        if (this.sectionFormat) {
            this.parser.parseSectionFormat(this.sectionFormat, section.sectionFormat);
        }
        var paragraph = new ParagraphWidget();
        paragraph.index = 0;
        paragraph.paragraphFormat = new WParagraphFormat(paragraph);
        paragraph.characterFormat = new WCharacterFormat(paragraph);
        section.childWidgets.push(paragraph);
        paragraph.containerWidget = section;
        var sections = [];
        sections.push(section);
        // tslint:disable-next-line:max-line-length
        var hfs = this.parser.parseHeaderFooter({ header: {}, footer: {}, evenHeader: {}, evenFooter: {}, firstPageHeader: {}, firstPageFooter: {} }, undefined);
        if (this.viewer) {
            this.clearPreservedCollectionsInViewer();
            this.viewer.userCollection.push('Everyone');
            this.viewer.cachedPages = [];
            this.viewer.setDefaultDocumentFormat();
            this.viewer.headersFooters.push(hfs);
            this.viewer.onDocumentChanged(sections);
            if (this.editorModule) {
                this.editorModule.intializeDefaultStyles();
                var style = this.viewer.styles.findByName('Normal');
                paragraph.paragraphFormat.baseStyle = style;
                paragraph.paragraphFormat.listFormat.baseStyle = style;
            }
        }
    };
    /**
     * Gets the style names based on given style type.
     * @param styleType
     */
    DocumentEditor.prototype.getStyleNames = function (styleType) {
        if (this.viewer) {
            return this.viewer.styles.getStyleNames(styleType);
        }
        return [];
    };
    /**
     * Gets the style objects on given style type.
     * @param styleType
     */
    DocumentEditor.prototype.getStyles = function (styleType) {
        if (this.viewer) {
            return this.viewer.styles.getStyles(styleType);
        }
        return [];
    };
    /**
     * Gets the bookmarks.
     */
    DocumentEditor.prototype.getBookmarks = function () {
        var bookmarks = [];
        if (this.viewer) {
            bookmarks = this.viewer.getBookmarks(true);
        }
        return bookmarks;
    };
    /**
     * Shows the dialog.
     * @param {DialogType} dialogType
     * @returns void
     */
    DocumentEditor.prototype.showDialog = function (dialogType) {
        switch (dialogType) {
            case 'Hyperlink':
                this.showHyperlinkDialog();
                break;
            case 'Table':
                this.showTableDialog();
                break;
            case 'Bookmark':
                this.showBookmarkDialog();
                break;
            case 'TableOfContents':
                this.showTableOfContentsDialog();
                break;
            case 'PageSetup':
                this.showPageSetupDialog();
                break;
            case 'List':
                this.showListDialog();
                break;
            case 'Styles':
                this.showStylesDialog();
                break;
            case 'Style':
                this.showStyleDialog();
                break;
            case 'Paragraph':
                this.showParagraphDialog();
                break;
            case 'Font':
                this.showFontDialog();
                break;
            case 'TableProperties':
                this.showTablePropertiesDialog();
                break;
            case 'BordersAndShading':
                this.showBordersAndShadingDialog();
                break;
            case 'TableOptions':
                this.showTableOptionsDialog();
                break;
        }
    };
    /**
     * Shows the options pane.
     */
    DocumentEditor.prototype.showOptionsPane = function () {
        if (!isNullOrUndefined(this.optionsPaneModule) && !isNullOrUndefined(this.viewer)) {
            this.optionsPaneModule.showHideOptionsPane(true);
        }
    };
    /**
     * Destroys all managed resources used by this object.
     */
    DocumentEditor.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.destroyDependentModules();
        if (!isNullOrUndefined(this.viewer)) {
            this.viewer.destroy();
        }
        this.viewer = undefined;
        if (!isNullOrUndefined(this.element)) {
            this.element.classList.remove('e-documenteditor');
            this.element.innerHTML = '';
        }
        this.element = undefined;
        this.findResultsList = [];
        this.findResultsList = undefined;
    };
    /* tslint:disable */
    DocumentEditor.prototype.destroyDependentModules = function () {
        if (this.printModule) {
            this.printModule.destroy();
            this.printModule = undefined;
        }
        if (this.sfdtExportModule) {
            this.sfdtExportModule.destroy();
            this.sfdtExportModule = undefined;
        }
        if (this.optionsPaneModule) {
            this.optionsPaneModule.destroy();
            this.optionsPaneModule = undefined;
        }
        if (this.commentReviewPane) {
            this.commentReviewPane.destroy();
            this.commentReviewPane = undefined;
        }
        if (!isNullOrUndefined(this.hyperlinkDialogModule)) {
            this.hyperlinkDialogModule.destroy();
            this.hyperlinkDialogModule = undefined;
        }
        if (this.searchModule) {
            this.searchModule.destroy();
            this.searchModule = undefined;
        }
        if (this.contextMenuModule) {
            this.contextMenuModule.destroy();
            this.contextMenuModule = undefined;
        }
        if (this.editorModule) {
            this.editorModule.destroy();
            this.editorModule = undefined;
        }
        if (this.selectionModule) {
            this.selectionModule.destroy();
            this.selectionModule = undefined;
        }
        if (this.editorHistoryModule) {
            this.editorHistoryModule.destroy();
            this.editorHistoryModule = undefined;
        }
        if (!isNullOrUndefined(this.paragraphDialogModule)) {
            this.paragraphDialogModule.destroy();
            this.paragraphDialogModule = undefined;
        }
        if (this.pageSetupDialogModule) {
            this.pageSetupDialogModule.destroy();
            this.pageSetupDialogModule = undefined;
        }
        if (this.fontDialogModule) {
            this.fontDialogModule.destroy();
            this.fontDialogModule = undefined;
        }
        if (this.listDialogModule) {
            this.listDialogModule.destroy();
            this.listDialogModule = undefined;
        }
        if (this.imageResizerModule) {
            this.imageResizerModule.destroy();
            this.imageResizerModule = undefined;
        }
        if (this.tablePropertiesDialogModule) {
            this.tablePropertiesDialogModule.destroy();
            this.tablePropertiesDialogModule = undefined;
        }
        if (this.bordersAndShadingDialogModule) {
            this.bordersAndShadingDialogModule.destroy();
            this.bordersAndShadingDialogModule = undefined;
        }
        if (this.cellOptionsDialogModule) {
            this.cellOptionsDialogModule.destroy();
            this.cellOptionsDialogModule = undefined;
        }
        if (this.tableOptionsDialogModule) {
            this.tableOptionsDialogModule.destroy();
            this.tableOptionsDialogModule = undefined;
        }
        if (this.tableDialogModule) {
            this.tableDialogModule.destroy();
            this.tableDialogModule = undefined;
        }
        if (this.styleDialogModule) {
            this.styleDialogModule = undefined;
        }
        if (this.bookmarkDialogModule) {
            this.bookmarkDialogModule.destroy();
            this.bookmarkDialogModule = undefined;
        }
        if (this.styleDialogModule) {
            this.styleDialogModule.destroy();
            this.styleDialogModule = undefined;
        }
        if (this.textExportModule) {
            this.textExportModule.destroy();
            this.textExportModule = undefined;
        }
        if (this.wordExportModule) {
            this.wordExportModule.destroy();
            this.wordExportModule = undefined;
        }
        if (this.tableOfContentsDialogModule) {
            this.tableOfContentsDialogModule.destroy();
            this.tableOfContentsDialogModule = undefined;
        }
        if (this.spellCheckerModule) {
            this.spellCheckerModule.destroy();
            this.spellCheckerModule = undefined;
        }
    };
    var DocumentEditor_1;
    __decorate([
        Property('KeepSourceFormatting')
    ], DocumentEditor.prototype, "defaultPasteOption", void 0);
    __decorate([
        Property('')
    ], DocumentEditor.prototype, "currentUser", void 0);
    __decorate([
        Property('#FFFF00')
    ], DocumentEditor.prototype, "userColor", void 0);
    __decorate([
        Property(20)
    ], DocumentEditor.prototype, "pageGap", void 0);
    __decorate([
        Property('')
    ], DocumentEditor.prototype, "documentName", void 0);
    __decorate([
        Property('')
    ], DocumentEditor.prototype, "serviceUrl", void 0);
    __decorate([
        Property(1)
    ], DocumentEditor.prototype, "zoomFactor", void 0);
    __decorate([
        Property(2000)
    ], DocumentEditor.prototype, "zIndex", void 0);
    __decorate([
        Property(true)
    ], DocumentEditor.prototype, "isReadOnly", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enablePrint", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableSelection", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableEditor", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableEditorHistory", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableSfdtExport", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableWordExport", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableTextExport", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableOptionsPane", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableContextMenu", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableHyperlinkDialog", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableBookmarkDialog", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableTableOfContentsDialog", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableSearch", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableParagraphDialog", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableListDialog", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableTablePropertiesDialog", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableBordersAndShadingDialog", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enablePageSetupDialog", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableStyleDialog", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableFontDialog", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableTableOptionsDialog", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableTableDialog", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableImageResizer", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableSpellCheck", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableComment", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "acceptTab", void 0);
    __decorate([
        Property(true)
    ], DocumentEditor.prototype, "useCtrlClickToFollowHyperlink", void 0);
    __decorate([
        Property('#000000')
    ], DocumentEditor.prototype, "pageOutline", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableCursorOnReadOnly", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "enableLocalPaste", void 0);
    __decorate([
        Property({ systemClipboard: 'SystemClipboard', spellCheck: 'SpellCheck', restrictEditing: 'RestrictEditing' })
    ], DocumentEditor.prototype, "serverActionSettings", void 0);
    __decorate([
        Property([])
    ], DocumentEditor.prototype, "headers", void 0);
    __decorate([
        Property(false)
    ], DocumentEditor.prototype, "showComments", void 0);
    __decorate([
        Event()
    ], DocumentEditor.prototype, "documentChange", void 0);
    __decorate([
        Event()
    ], DocumentEditor.prototype, "viewChange", void 0);
    __decorate([
        Event()
    ], DocumentEditor.prototype, "zoomFactorChange", void 0);
    __decorate([
        Event()
    ], DocumentEditor.prototype, "selectionChange", void 0);
    __decorate([
        Event()
    ], DocumentEditor.prototype, "requestNavigate", void 0);
    __decorate([
        Event()
    ], DocumentEditor.prototype, "contentChange", void 0);
    __decorate([
        Event()
    ], DocumentEditor.prototype, "keyDown", void 0);
    __decorate([
        Event()
    ], DocumentEditor.prototype, "searchResultsChange", void 0);
    __decorate([
        Event()
    ], DocumentEditor.prototype, "created", void 0);
    __decorate([
        Event()
    ], DocumentEditor.prototype, "destroyed", void 0);
    __decorate([
        Event()
    ], DocumentEditor.prototype, "customContextMenuSelect", void 0);
    __decorate([
        Event()
    ], DocumentEditor.prototype, "customContextMenuBeforeOpen", void 0);
    __decorate([
        Event()
    ], DocumentEditor.prototype, "beforePaneSwitch", void 0);
    __decorate([
        Event()
    ], DocumentEditor.prototype, "commentBegin", void 0);
    __decorate([
        Event()
    ], DocumentEditor.prototype, "commentEnd", void 0);
    DocumentEditor = DocumentEditor_1 = __decorate([
        NotifyPropertyChanges
    ], DocumentEditor);
    return DocumentEditor;
}(Component));
/**
 * The `ServerActionSettings` module is used to provide the server action methods of Document Editor.
 */
var ServerActionSettings = /** @__PURE__ @class */ (function (_super) {
    __extends(ServerActionSettings, _super);
    function ServerActionSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        Property('SystemClipboard')
    ], ServerActionSettings.prototype, "systemClipboard", void 0);
    __decorate([
        Property('SpellCheck')
    ], ServerActionSettings.prototype, "spellCheck", void 0);
    __decorate([
        Property('RestrictEditing')
    ], ServerActionSettings.prototype, "restrictEditing", void 0);
    return ServerActionSettings;
}(ChildProperty));
/**
 * The `ServerActionSettings` module is used to provide the server action methods of Document Editor Container.
 */
var ContainerServerActionSettings = /** @__PURE__ @class */ (function (_super) {
    __extends(ContainerServerActionSettings, _super);
    function ContainerServerActionSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        Property('Import')
    ], ContainerServerActionSettings.prototype, "import", void 0);
    return ContainerServerActionSettings;
}(ServerActionSettings));

/**
 * Print class
 */
var Print = /** @__PURE__ @class */ (function () {
    function Print() {
    }
    /**
     * Gets module name.
     */
    Print.prototype.getModuleName = function () {
        return 'Print';
    };
    /**
     * Prints the current viewer
     * @param viewer
     * @param printWindow
     * @private
     */
    Print.prototype.print = function (viewer, printWindow) {
        this.printWindow(viewer, navigator.userAgent, printWindow);
    };
    /**
     * Opens print window and displays current page to print.
     * @private
     */
    Print.prototype.printWindow = function (viewer, browserUserAgent, printWindow) {
        var height = this.getPageHeight(viewer.pages);
        var width = this.getPageWidth(viewer.pages);
        var printElement = document.createElement('div');
        printElement.style.width = '100%';
        printElement.style.height = '100%';
        printElement.style.overflow = 'scroll';
        // Rendering canvas to print
        this.generatePrintContent(viewer, printElement);
        if (isNullOrUndefined(printWindow)) {
            printWindow = window.open('', 'print', 'height=452,width=1024,tabbar=no');
        }
        if ((browserUserAgent.indexOf('Chrome') !== -1) || (browserUserAgent.indexOf('Firefox')) !== -1) {
            // Chrome and Firefox
            printWindow.document.write('<!DOCTYPE html>');
            // tslint:disable-next-line:max-line-length
            printWindow.document.write('<html moznomarginboxes mozdisallowselectionprint><head><style>html, body { height: 100 %; } img { height: 100 %; width: 100 %; display: block;}img { box-sizing: border-box; }br, button { display: none; }@page{ margin: 0cm; size:' + width.toString() + 'px ' + height.toString() + 'px; }@media print{ body { margin: 0cm; }</style></head> <body><center>');
        }
        else {
            // Internet Explorer and Edge
            // tslint:disable-next-line:max-line-length
            printWindow.document.write('<html><head><style>@page{margin:0;size:' + width.toString() + 'px ' + height.toString() + 'px;}</style></head><body><center>');
        }
        // tslint:disable-next-line:max-line-length
        printWindow.document.write(printElement.innerHTML + '</center><script> (function() { window.ready = true; })(); </script></body></html>');
        printElement = undefined;
        printWindow.document.close();
        printWindow.focus();
        var interval = setInterval(function () {
            if (printWindow.ready) {
                printWindow.print();
                printWindow.close();
                clearInterval(interval);
            }
        }, 500);
    };
    /**
     * Generates print content.
     * @private
     */
    Print.prototype.generatePrintContent = function (viewer, element) {
        // Rendering canvas to print
        var htmlString = '';
        for (var i = 0; i < viewer.pages.length; i++) {
            var page = viewer.pages[i];
            var pageHeight = page.boundingRectangle.height;
            var pageWidth = page.boundingRectangle.width;
            viewer.render.isPrinting = true;
            viewer.render.renderWidgets(page, 0, 0, 0, 0);
            var canvasURL = viewer.render.pageCanvas.toDataURL();
            viewer.render.isPrinting = false;
            // tslint:disable-next-line:max-line-length
            htmlString += '<div><img src=' + canvasURL + ' style="margin:0px;display:block;width: ' + pageWidth.toString() + 'px; height:' + pageHeight.toString() + 'px; "/></div><br/>';
        }
        element.innerHTML = htmlString;
    };
    /**
     * Gets page width.
     * @param pages
     * @private
     */
    Print.prototype.getPageWidth = function (pages) {
        var width = 0;
        for (var i = 0; i < pages.length; i++) {
            if (width < pages[i].boundingRectangle.width) {
                width = pages[i].boundingRectangle.width;
            }
        }
        return width;
    };
    /**
     *  Gets page height.
     * @private
     */
    Print.prototype.getPageHeight = function (pages) {
        var height = 0;
        for (var i = 0; i < pages.length; i++) {
            if (height < pages[i].boundingRectangle.height) {
                height = pages[i].boundingRectangle.height;
            }
        }
        return height;
    };
    /**
     * @private
     */
    Print.prototype.destroy = function () {
        return;
    };
    return Print;
}());

var CONTEXTMENU_COPY = '_contextmenu_copy';
var CONTEXTMENU_CUT = '_contextmenu_cut';
var CONTEXTMENU_PASTE = '_contextmenu_paste';
var CONTEXTMENU_ADD_COMMENT = '_add_comment';
var CONTEXTMENU_UPDATE_FIELD = '_contextmenu_update_field';
var CONTEXTMENU_EDIT_FIELD = '_contextmenu_edit_field';
var CONTEXTMENU_HYPERLINK = '_contextmenu_hyperlink';
var CONTEXTMENU_OPEN_HYPERLINK = '_contextmenu_open_hyperlink';
var CONTEXTMENU_COPY_HYPERLINK = '_contextmenu_copy_hyperlink';
var CONTEXTMENU_REMOVE_HYPERLINK = '_contextmenu_remove_hyperlink';
var CONTEXTMENU_EDIT_HYPERLINK = '_contextmenu_edit_hyperlink';
var CONTEXTMENU_FONT_DIALOG = '_contextmenu_font_dialog';
var CONTEXTMENU_PARAGRAPH = '_contextmenu_paragraph_dialog';
var CONTEXTMENU_TABLE = '_contextmenu_table_dialog';
var CONTEXTMENU_INSERT_TABLE = '_contextmenu_insert_table';
var CONTEXTMENU_DELETE_TABLE = '_contextmenu_delete_table';
var CONTEXTMENU_INSERT_ABOVE = '_contextmenu_insert_above';
var CONTEXTMENU_INSERT_BELOW = '_contextmenu_insert_below';
var CONTEXTMENU_INSERT_RIGHT = '_contextmenu_insert_right';
var CONTEXTMENU_INSERT_LEFT = '_contextmenu_insert_left';
var CONTEXTMENU_COMPLETE_DELETE_TABLE = '_contextmenu_complete_table_delete';
var CONTEXTMENU_DELETE_ROW = '_contextmenu_delete_row';
var CONTEXTMENU_DELETE_COLUMN = '_contextmenu_delete_column';
var CONTEXTMENU_MERGE_CELL = '_contextmenu_merge_cell';
var CONTEXTMENU_AUTO_FIT = '_contextmenu_auto_fit';
var CONTEXTMENU_AUTO_FIT_TO_CONTENTS = '_contextmenu_auto_fit_contents';
var CONTEXTMENU_AUTO_FIT_TO_WINDOW = '_contextmenu_auto_fit_window';
var CONTEXTMENU_FIXED_COLUMN_WIDTH = '_contextmenu_fixed_column_width';
var CONTEXTMENU_CONTINUE_NUMBERING = '_contextmenu_continue_numbering';
var CONTEXTMENU_RESTART_AT = '_contextmenu_restart_at';
var CONTEXTMENU_SPELLING_DIALOG = '_contextmenu_spelling_dialog';
var CONTEXTMENU_SPELLCHECK_OTHERSUGGESTIONS = '_contextmenu_otherSuggestions_spellcheck_';
var CONTEXTMENU_NO_SUGGESTION = '_contextmenu_no_suggestion';
/**
 * Context Menu class
 */
var ContextMenu$1 = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function ContextMenu$$1(viewer) {
        var _this = this;
        /**
         * @private
         */
        this.contextMenuInstance = undefined;
        /**
         * @private
         */
        this.menuItems = [];
        /**
         * @private
         */
        this.customMenuItems = [];
        /**
         * @private
         */
        this.ids = [];
        this.spellContextItems = [];
        this.customItems = [];
        /**
         * Handles on context menu key pressed.
         * @param  {MouseEvent} event
         * @private
         */
        this.onContextMenuInternal = function (event) {
            var isTouch = !(event instanceof MouseEvent);
            if (_this.viewer.owner.enableSpellCheck && _this.spellChecker.allowSpellCheckAndSuggestion) {
                event.preventDefault();
                _this.currentContextInfo = _this.spellChecker.findCurretText();
                var splittedSuggestion_1;
                /* tslint:disable:no-any */
                var allSuggestions_1;
                var exactData_1 = _this.spellChecker.manageSpecialCharacters(_this.currentContextInfo.text, undefined, true);
                if (!isNullOrUndefined(exactData_1) && _this.spellChecker.errorWordCollection.containsKey(exactData_1)) {
                    _this.spellChecker.currentContextInfo = _this.currentContextInfo;
                    if (_this.spellChecker.errorSuggestions.containsKey(exactData_1)) {
                        allSuggestions_1 = _this.spellChecker.errorSuggestions.get(exactData_1).slice();
                        splittedSuggestion_1 = _this.spellChecker.handleSuggestions(allSuggestions_1);
                        _this.processSuggestions(allSuggestions_1, splittedSuggestion_1, isTouch ? event : event);
                    }
                    else {
                        if (_this.spellChecker.enableOptimizedSpellCheck) {
                            // tslint:disable-next-line:max-line-length
                            _this.spellChecker.CallSpellChecker(_this.spellChecker.languageID, exactData_1, false, true, false, false).then(function (data) {
                                /* tslint:disable:no-any */
                                var jsonObject = JSON.parse(data);
                                allSuggestions_1 = jsonObject.Suggestions;
                                if (!isNullOrUndefined(allSuggestions_1)) {
                                    _this.spellChecker.errorSuggestions.add(exactData_1, allSuggestions_1.slice());
                                    splittedSuggestion_1 = _this.spellChecker.handleSuggestions(allSuggestions_1);
                                }
                                // tslint:disable-next-line:max-line-length
                                _this.processSuggestions(allSuggestions_1, splittedSuggestion_1, isTouch ? event : event);
                            });
                        }
                        else {
                            // tslint:disable-next-line:max-line-length
                            _this.processSuggestions(allSuggestions_1, splittedSuggestion_1, isTouch ? event : event);
                        }
                    }
                }
                else {
                    _this.hideSpellContextItems();
                    _this.showContextMenuOnSel(isTouch ? event : event);
                }
            }
            else {
                _this.hideSpellContextItems();
                _this.showContextMenuOnSel(isTouch ? event : event);
            }
        };
        this.viewer = viewer;
        this.locale = new L10n('documenteditor', this.viewer.owner.defaultLocale);
        this.locale.setLocale(this.viewer.owner.locale);
        this.initContextMenu(this.locale, this.viewer.owner.enableRtl);
    }
    Object.defineProperty(ContextMenu$$1.prototype, "spellChecker", {
        /**
         * Gets the spell checker
         * @private
         */
        get: function () {
            return this.viewer.owner.spellChecker;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets module name.
     */
    ContextMenu$$1.prototype.getModuleName = function () {
        return 'ContextMenu';
    };
    /**
     * Initialize context menu.
     * @param localValue Localize value.
     * @private
     */
    // tslint:disable:max-func-body-length
    ContextMenu$$1.prototype.initContextMenu = function (localValue, isRtl) {
        var _this = this;
        var id = this.viewer.owner.element.id;
        this.contextMenu = document.createElement('div');
        this.contextMenu.id = this.viewer.owner.containerId + 'e-de-contextmenu';
        document.body.appendChild(this.contextMenu);
        var ul = document.createElement('ul');
        ul.style.width = 'auto';
        ul.id = this.viewer.owner.containerId + 'e-de-contextmenu-list';
        ul.style.listStyle = 'none';
        ul.style.margin = '0px';
        ul.style.maxHeight = 'auto';
        ul.oncontextmenu = this.disableBrowserContextmenu;
        this.contextMenu.appendChild(ul);
        this.menuItems = [
            {
                text: localValue.getConstant('Cut'),
                iconCss: 'e-icons e-de-cut',
                id: id + CONTEXTMENU_CUT
            },
            {
                text: localValue.getConstant('Copy'),
                iconCss: 'e-icons e-de-copy',
                id: id + CONTEXTMENU_COPY
            },
            {
                text: localValue.getConstant('Paste'),
                iconCss: 'e-icons e-de-paste',
                id: id + CONTEXTMENU_PASTE
            },
            {
                separator: true
            },
            {
                text: localValue.getConstant('New Comment'),
                iconCss: 'e-icons e-de-cmt-add',
                id: id + CONTEXTMENU_ADD_COMMENT
            },
            {
                separator: true
            },
            {
                text: localValue.getConstant('Update Field'),
                iconCss: 'e-icons e-de-update_field',
                id: id + CONTEXTMENU_UPDATE_FIELD
            },
            {
                text: localValue.getConstant('Edit Field'),
                iconCss: 'e-icons e-de-edit_field',
                id: id + CONTEXTMENU_EDIT_FIELD
            },
            {
                text: localValue.getConstant('Continue Numbering'),
                iconCss: 'e-icons e-de-continue-numbering',
                id: id + CONTEXTMENU_CONTINUE_NUMBERING
            },
            {
                text: localValue.getConstant('Restart At') + ' 1',
                iconCss: 'e-icons e-de-restart-at',
                id: id + CONTEXTMENU_RESTART_AT
            },
            {
                separator: true
            },
            {
                text: localValue.getConstant('Hyperlink'),
                iconCss: 'e-icons e-de-insertlink',
                id: id + CONTEXTMENU_HYPERLINK
            },
            {
                text: localValue.getConstant('Edit Hyperlink') + '...',
                iconCss: 'e-icons e-de-edit-hyperlink',
                id: id + CONTEXTMENU_EDIT_HYPERLINK
            },
            {
                text: localValue.getConstant('Open Hyperlink'),
                iconCss: 'e-icons e-de-open-hyperlink',
                id: id + CONTEXTMENU_OPEN_HYPERLINK
            },
            {
                text: localValue.getConstant('Copy Hyperlink'),
                iconCss: 'e-icons e-de-copy-hyperlink',
                id: id + CONTEXTMENU_COPY_HYPERLINK
            },
            {
                text: localValue.getConstant('Remove Hyperlink'),
                iconCss: 'e-icons e-de-remove-hyperlink',
                id: id + CONTEXTMENU_REMOVE_HYPERLINK
            },
            {
                separator: true
            },
            {
                text: localValue.getConstant('Font'),
                iconCss: 'e-icons e-de-fonts',
                id: id + CONTEXTMENU_FONT_DIALOG
            },
            {
                text: localValue.getConstant('Paragraph'),
                iconCss: 'e-icons e-de-paragraph',
                id: id + CONTEXTMENU_PARAGRAPH
            },
            {
                separator: true,
            },
            {
                text: localValue.getConstant('Table Properties'),
                id: id + CONTEXTMENU_TABLE,
                iconCss: 'e-icons e-de-table'
            },
            {
                text: localValue.getConstant('Merge Cells'),
                id: id + CONTEXTMENU_MERGE_CELL,
                iconCss: 'e-icons e-de-ctnr-mergecell'
            },
            {
                text: localValue.getConstant('AutoFit'),
                id: id + CONTEXTMENU_AUTO_FIT,
                iconCss: 'e-icons',
                items: [
                    {
                        text: localValue.getConstant('AutoFit to Contents'),
                        id: id + CONTEXTMENU_AUTO_FIT_TO_CONTENTS,
                        iconCss: 'e-icons e-de-icon-autofit e-de-autofit-contents'
                    },
                    {
                        text: localValue.getConstant('AutoFit to Window'),
                        id: id + CONTEXTMENU_AUTO_FIT_TO_WINDOW,
                        iconCss: 'e-icons e-de-icon-auto-fitwindow e-de-autofit-window'
                    },
                    {
                        text: localValue.getConstant('Fixed Column Width'),
                        id: id + CONTEXTMENU_FIXED_COLUMN_WIDTH,
                        iconCss: 'e-icons e-de-icon-fixed-columnwidth e-de-fixed-column'
                    }
                ]
            },
            {
                text: localValue.getConstant('Insert'),
                id: id + CONTEXTMENU_INSERT_TABLE,
                iconCss: 'e-icons',
                items: [
                    {
                        text: localValue.getConstant('Insert Above'),
                        id: id + CONTEXTMENU_INSERT_ABOVE,
                        iconCss: 'e-icons e-de-insertabove'
                    },
                    {
                        text: localValue.getConstant('Insert Below'),
                        id: id + CONTEXTMENU_INSERT_BELOW,
                        iconCss: 'e-icons e-de-insertbelow'
                    },
                    {
                        text: localValue.getConstant('Insert Left'),
                        id: id + CONTEXTMENU_INSERT_LEFT,
                        iconCss: 'e-icons e-de-insertleft'
                    },
                    {
                        text: localValue.getConstant('Insert Right'),
                        id: id + CONTEXTMENU_INSERT_RIGHT,
                        iconCss: 'e-icons e-de-insertright'
                    }
                ]
            },
            {
                text: localValue.getConstant('Delete'),
                id: id + CONTEXTMENU_DELETE_TABLE,
                iconCss: 'e-icons',
                items: [
                    {
                        text: localValue.getConstant('Delete Table'),
                        id: id + CONTEXTMENU_COMPLETE_DELETE_TABLE,
                        iconCss: 'e-icons e-de-delete-table'
                    },
                    {
                        text: localValue.getConstant('Delete Row'),
                        id: id + CONTEXTMENU_DELETE_ROW,
                        iconCss: 'e-icons e-de-deleterow'
                    },
                    {
                        text: localValue.getConstant('Delete Column'),
                        id: id + CONTEXTMENU_DELETE_COLUMN,
                        iconCss: 'e-icons e-de-deletecolumn'
                    }
                ]
            },
        ];
        var menuOptions = {
            target: '#' + this.viewer.owner.containerId + 'e-de-contextmenu',
            enableRtl: isRtl,
            items: this.addMenuItems(this.menuItems),
            select: function (args) {
                var item = args.element.id;
                _this.handleContextMenuItem(item);
            },
        };
        this.contextMenuInstance = new ContextMenu(menuOptions, '#' + this.viewer.owner.containerId + 'e-de-contextmenu-list');
        this.contextMenuInstance.beforeOpen = function () {
            for (var index = 0; index < _this.customMenuItems.length; index++) {
                if (typeof _this.customMenuItems[index].id !== 'undefined') {
                    _this.ids[index] = _this.customMenuItems[index].id;
                }
                else {
                    _this.ids[index] = _this.customMenuItems[index + 1].id;
                }
            }
            _this.viewer.owner.fireCustomContextMenuBeforeOpen(_this.ids);
            if (_this.enableCustomContextMenu) {
                for (var index = 0; index < _this.menuItems.length; index++) {
                    if (typeof _this.menuItems[index].id !== 'undefined') {
                        document.getElementById(_this.menuItems[index].id).style.display = 'none';
                    }
                    else {
                        document.getElementById(_this.menuItems[index - 1].id).nextSibling.style.display = 'none';
                    }
                }
            }
            if (_this.viewer && _this.viewer.selection) {
                classList(_this.viewer.selection.caret, [], ['e-de-cursor-animation']);
                _this.viewer.selection.showCaret();
            }
        };
        this.contextMenuInstance.onClose = function () {
            if (_this.viewer && _this.viewer.selection) {
                classList(_this.viewer.selection.caret, ['e-de-cursor-animation'], []);
                _this.viewer.updateFocus();
            }
        };
    };
    /**
     * Disable browser context menu.
     */
    ContextMenu$$1.prototype.disableBrowserContextmenu = function () {
        return false;
    };
    /**
     * Handles context menu items.
     * @param  {string} item Specifies which item is selected.
     * @private
     */
    ContextMenu$$1.prototype.handleContextMenuItem = function (item) {
        var id = this.viewer.owner.element.id;
        switch (item) {
            case id + CONTEXTMENU_COPY:
                this.viewer.selection.copy();
                break;
            case id + CONTEXTMENU_CUT:
                this.viewer.owner.editor.cut();
                break;
            case id + CONTEXTMENU_PASTE:
                if (!this.viewer.owner.isReadOnlyMode) {
                    this.viewer.owner.editorModule.pasteInternal(undefined);
                }
                break;
            case id + CONTEXTMENU_ADD_COMMENT:
                if (!this.viewer.owner.isReadOnlyMode) {
                    this.viewer.owner.editorModule.insertComment();
                }
                break;
            case id + CONTEXTMENU_UPDATE_FIELD:
                if (!this.viewer.owner.isReadOnlyMode) {
                    this.viewer.owner.editorModule.updateToc();
                }
                break;
            case id + CONTEXTMENU_EDIT_FIELD:
                if (!this.viewer.owner.isReadOnlyMode) {
                    this.viewer.owner.tableOfContentsDialogModule.show();
                }
                break;
            case id + CONTEXTMENU_FONT_DIALOG:
                if (this.viewer.owner.fontDialogModule) {
                    this.viewer.owner.fontDialogModule.showFontDialog();
                }
                break;
            case id + CONTEXTMENU_OPEN_HYPERLINK:
                this.viewer.selection.navigateHyperlink();
                break;
            case id + CONTEXTMENU_COPY_HYPERLINK:
                this.viewer.selection.copyHyperlink();
                break;
            case id + CONTEXTMENU_EDIT_HYPERLINK:
            case id + CONTEXTMENU_HYPERLINK:
                if (this.viewer.owner.hyperlinkDialogModule) {
                    this.viewer.owner.hyperlinkDialogModule.show();
                }
                break;
            case id + CONTEXTMENU_REMOVE_HYPERLINK:
                this.viewer.owner.editor.removeHyperlink();
                break;
            case id + CONTEXTMENU_PARAGRAPH:
                if (this.viewer.owner.paragraphDialogModule) {
                    this.viewer.owner.paragraphDialogModule.show();
                }
                break;
            case id + CONTEXTMENU_TABLE:
                this.viewer.owner.tablePropertiesDialogModule.show();
                break;
            case id + CONTEXTMENU_MERGE_CELL:
                this.viewer.owner.editor.mergeCells();
                break;
            case id + CONTEXTMENU_INSERT_ABOVE:
                this.viewer.owner.editor.insertRow(true);
                break;
            case id + CONTEXTMENU_INSERT_BELOW:
                this.viewer.owner.editor.insertRow(false);
                break;
            case id + CONTEXTMENU_INSERT_LEFT:
                this.viewer.owner.editor.insertColumn(true);
                break;
            case id + CONTEXTMENU_INSERT_RIGHT:
                this.viewer.owner.editor.insertColumn(false);
                break;
            case id + CONTEXTMENU_COMPLETE_DELETE_TABLE:
                this.viewer.owner.editor.deleteTable();
                break;
            case id + CONTEXTMENU_DELETE_ROW:
                this.viewer.owner.editor.deleteRow();
                break;
            case id + CONTEXTMENU_DELETE_COLUMN:
                this.viewer.owner.editor.deleteColumn();
                break;
            case id + CONTEXTMENU_CONTINUE_NUMBERING:
                this.viewer.owner.editorModule.applyContinueNumbering(this.viewer.selection);
                break;
            case id + CONTEXTMENU_RESTART_AT:
                this.viewer.owner.editorModule.applyRestartNumbering(this.viewer.selection);
                break;
            case id + CONTEXTMENU_AUTO_FIT_TO_CONTENTS:
                this.viewer.owner.editor.autoFitTable('FitToContents');
                break;
            case id + CONTEXTMENU_AUTO_FIT_TO_WINDOW:
                this.viewer.owner.editor.autoFitTable('FitToWindow');
                break;
            case id + CONTEXTMENU_FIXED_COLUMN_WIDTH:
                this.viewer.owner.editor.autoFitTable('FixedColumnWidth');
                break;
            case id + CONTEXTMENU_SPELLING_DIALOG:
                var contextInfo = this.spellChecker.retriveText();
                this.currentContextInfo = null;
                this.viewer.owner.spellCheckDialog.show(contextInfo.text, contextInfo.element);
                break;
            default:
                var expectedData = this.viewer.owner.element.id + CONTEXTMENU_SPELLCHECK_OTHERSUGGESTIONS;
                if (item.substring(0, expectedData.length) === expectedData) {
                    var content = item.substring(item.lastIndexOf('_') + 1);
                    this.callSelectedOption(content);
                    break;
                }
                else {
                    // fires customContextMenuSelect while selecting the added custom menu item
                    this.viewer.owner.fireCustomContextMenuSelect(item);
                    break;
                }
        }
    };
    /**
     * Method to call the selected item
     * @param {string} content
     */
    ContextMenu$$1.prototype.callSelectedOption = function (content) {
        if (content === 'Add To Dictionary') {
            this.spellChecker.handleAddToDictionary();
        }
        else if (content === 'Ignore All') {
            this.spellChecker.handleIgnoreAllItems();
        }
        else {
            this.spellChecker.manageReplace(content);
        }
    };
    /**
     * To add and customize custom context menu
     * @param {MenuItemModel[]} items - To add custom menu item
     * @param {boolean} isEnable - To hide existing menu item and show custom menu item alone
     * @param {boolean} isBottom - To show the custom menu item in bottom of the existing item
     */
    ContextMenu$$1.prototype.addCustomMenu = function (items, isEnable, isBottom) {
        var menuItems = JSON.parse(JSON.stringify(items));
        this.destroy();
        if (this.spellContextItems.length === 0) {
            this.customItems = items;
        }
        for (var index = 0; index < menuItems.length; index++) {
            this.customMenuItems.push(menuItems[index]);
            this.customMenuItems[index].id = this.viewer.owner.element.id + this.customMenuItems[index].id;
        }
        this.enableCustomContextMenu = isEnable;
        this.enableCustomContextMenuBottom = isBottom;
        this.initContextMenu(this.locale);
    };
    /**
     * Context Menu Items.
     * @param {MenuItemModel[]} menuItems - To add MenuItem to context menu
     * @private
     */
    ContextMenu$$1.prototype.addMenuItems = function (menuItems) {
        if (this.enableCustomContextMenuBottom) {
            return menuItems.concat(this.customMenuItems);
        }
        else {
            return this.customMenuItems.concat(menuItems);
        }
    };
    /**
     * Opens context menu.
     * @param {MouseEvent | TouchEvent} event
     */
    ContextMenu$$1.prototype.showContextMenuOnSel = function (event) {
        var isTouch = !(event instanceof MouseEvent);
        var xPos = 0;
        var yPos = 0;
        if (isTouch) {
            var point = this.viewer.getTouchOffsetValue(event);
            xPos = point.x;
            yPos = point.y;
        }
        else {
            yPos = event.y;
            xPos = event.x;
        }
        if (this.showHideElements(this.viewer.selection)) {
            if (isTouch) {
                this.viewer.isMouseDown = false;
            }
            this.contextMenuInstance.open(yPos, xPos);
            event.preventDefault();
        }
    };
    /**
     * Method to hide spell context items
     */
    ContextMenu$$1.prototype.hideSpellContextItems = function () {
        if (this.spellContextItems.length > 0) {
            for (var i = 0; i < this.spellContextItems.length; i++) {
                var item = document.getElementById(this.viewer.owner.element.id + this.spellContextItems[i].id);
                if (!isNullOrUndefined(item)) {
                    item.style.display = 'none';
                }
            }
        }
    };
    /**
     * Method to process suggestions to add in context menu
     * @param {any} allSuggestions
     * @param {string[]} splittedSuggestion
     * @param {MouseEvent} event
     * @private
     */
    /* tslint:disable:no-any */
    ContextMenu$$1.prototype.processSuggestions = function (allSuggestions, splittedSuggestion, event) {
        this.spellContextItems = this.constructContextmenu(allSuggestions, splittedSuggestion);
        this.addCustomMenu(this.spellContextItems);
        this.noSuggestion = document.getElementById(this.viewer.owner.element.id + CONTEXTMENU_NO_SUGGESTION);
        if (!isNullOrUndefined(this.noSuggestion)) {
            this.noSuggestion.style.display = 'block';
            classList(this.noSuggestion, ['e-disabled'], ['e-focused']);
        }
        this.showContextMenuOnSel(event);
    };
    /**
     * Method to add inline menu
     * @private
     */
    /* tslint:disable:no-any */
    ContextMenu$$1.prototype.constructContextmenu = function (allSuggestion, splittedSuggestion) {
        var contextMenuItems = this.customItems.length > 0 ? this.customItems.slice() : [];
        // classList(this.noSuggestion,['e-disabled'],[]);
        if (isNullOrUndefined(allSuggestion) || allSuggestion.length === 0) {
            contextMenuItems.push({ text: 'no suggestions', id: CONTEXTMENU_NO_SUGGESTION, classList: ['e-focused'], iconCss: '' });
        }
        else {
            for (var i = 0; i < allSuggestion.length; i++) {
                // tslint:disable-next-line:max-line-length
                contextMenuItems.push({ text: allSuggestion[i], id: CONTEXTMENU_SPELLCHECK_OTHERSUGGESTIONS + allSuggestion[i], iconCss: '' });
            }
        }
        contextMenuItems.push({ separator: true, id: '_contextmenu_suggestion_seperator' });
        if (!isNullOrUndefined(splittedSuggestion) && splittedSuggestion.length > 1) {
            contextMenuItems.push({ text: 'More Suggestion', items: splittedSuggestion });
            contextMenuItems.push({ separator: true, id: '_contextmenu_moreSuggestion_seperator' });
        }
        else {
            // tslint:disable-next-line:max-line-length
            contextMenuItems.push({ text: 'Add To Dictionary ', id: '_contextmenu_otherSuggestions_spellcheck_Add To Dictionary', iconCss: '' });
        }
        contextMenuItems.push({ text: 'Ignore Once', id: '_contextmenu_otherSuggestions_spellcheck_Ignore Once', iconCss: '' });
        contextMenuItems.push({ text: 'Ignore All', id: '_contextmenu_otherSuggestions_spellcheck_Ignore All', iconCss: '' });
        contextMenuItems.push({ separator: true, id: '_contextmenu_change_seperator' });
        // tslint:disable-next-line:max-line-length
        contextMenuItems.push({ text: this.locale.getConstant('Spelling'), id: CONTEXTMENU_SPELLING_DIALOG, iconCss: 'e-icons e-de-spellcheck', items: [] });
        contextMenuItems.push({ separator: true, id: '_contextmenu_spelling_seperator' });
        return contextMenuItems;
    };
    ContextMenu$$1.prototype.showHideElements = function (selection) {
        if (isNullOrUndefined(selection)) {
            return false;
        }
        selection.hideToolTip();
        var owner = this.viewer.owner;
        var id = owner.element.id;
        var copy = document.getElementById(id + CONTEXTMENU_COPY);
        var cut = document.getElementById(id + CONTEXTMENU_CUT);
        var paste = document.getElementById(id + CONTEXTMENU_PASTE);
        var updateField = document.getElementById(id + CONTEXTMENU_UPDATE_FIELD);
        var editField = document.getElementById(id + CONTEXTMENU_EDIT_FIELD);
        var font = document.getElementById(id + CONTEXTMENU_FONT_DIALOG);
        var paragraph = document.getElementById(id + CONTEXTMENU_PARAGRAPH);
        var tableProperties = document.getElementById(id + CONTEXTMENU_TABLE);
        var insertTable = document.getElementById(id + CONTEXTMENU_INSERT_TABLE);
        var deleteTable = document.getElementById(id + CONTEXTMENU_DELETE_TABLE);
        var mergeCells = document.getElementById(id + CONTEXTMENU_MERGE_CELL);
        var hyperlink = document.getElementById(id + CONTEXTMENU_HYPERLINK);
        var openHyperlink = document.getElementById(id + CONTEXTMENU_OPEN_HYPERLINK);
        var editHyperlink = document.getElementById(id + CONTEXTMENU_EDIT_HYPERLINK);
        var copyHyperlink = document.getElementById(id + CONTEXTMENU_COPY_HYPERLINK);
        var removeHyperlink = document.getElementById(id + CONTEXTMENU_REMOVE_HYPERLINK);
        var continueNumbering = document.getElementById(id + CONTEXTMENU_CONTINUE_NUMBERING);
        var restartAt = document.getElementById(id + CONTEXTMENU_RESTART_AT);
        var autoFitTable = document.getElementById(id + CONTEXTMENU_AUTO_FIT);
        var addComment = document.getElementById(id + CONTEXTMENU_ADD_COMMENT);
        cut.style.display = 'none';
        paste.style.display = 'none';
        paste.nextSibling.style.display = 'none';
        hyperlink.style.display = 'none';
        openHyperlink.style.display = 'none';
        copyHyperlink.style.display = 'none';
        editHyperlink.style.display = 'none';
        removeHyperlink.style.display = 'none';
        removeHyperlink.nextSibling.style.display = 'none';
        mergeCells.style.display = 'none';
        autoFitTable.style.display = 'none';
        font.style.display = 'none';
        paragraph.style.display = 'none';
        paragraph.nextSibling.style.display = 'none';
        insertTable.style.display = 'none';
        deleteTable.style.display = 'none';
        tableProperties.style.display = 'none';
        updateField.style.display = 'none';
        editField.style.display = 'none';
        continueNumbering.style.display = 'none';
        restartAt.style.display = 'none';
        restartAt.nextSibling.style.display = 'none';
        var isSelectionEmpty = selection.isEmpty;
        classList(cut, isSelectionEmpty ? ['e-disabled'] : [], !isSelectionEmpty ? ['e-disabled'] : []);
        classList(copy, isSelectionEmpty ? ['e-disabled'] : [], !isSelectionEmpty ? ['e-disabled'] : []);
        // tslint:disable-next-line:max-line-length
        var isHideComment = this.viewer.owner.isReadOnlyMode || this.viewer.owner.enableHeaderAndFooter || !this.viewer.owner.enableComment;
        addComment.style.display = isHideComment ? 'none' : 'block';
        addComment.previousSibling.style.display = isHideComment ? 'none' : 'block';
        addComment.nextSibling.style.display = isHideComment ? 'none' : 'block';
        if (owner.isReadOnlyMode) {
            return true;
        }
        if (this.viewer && this.viewer.owner && this.viewer.owner.commentReviewPane &&
            this.viewer.owner.commentReviewPane.commentPane.isEditMode) {
            classList(addComment, ['e-disabled'], []);
        }
        else {
            classList(addComment, [], ['e-disabled']);
        }
        cut.style.display = 'block';
        paste.style.display = 'block';
        paste.nextSibling.style.display = 'block';
        classList(insertTable, ['e-blankicon'], []);
        classList(deleteTable, ['e-blankicon'], []);
        classList(updateField, ['e-blankicon'], []);
        classList(editField, ['e-blankicon'], []);
        classList(autoFitTable, ['e-blankicon'], []);
        var enablePaste = (owner.enableLocalPaste && !isNullOrUndefined(owner.editor.copiedData));
        classList(paste, enablePaste ? [] : ['e-disabled'], enablePaste ? ['e-disabled'] : []);
        if (selection.contextType === 'TableOfContents') {
            updateField.style.display = 'block';
            editField.style.display = 'block';
        }
        else {
            var start = selection.start;
            var end = selection.end;
            if (selection.contextType === 'List'
                && owner.editorModule.getListLevel(start.paragraph).listLevelPattern !== 'Bullet') {
                continueNumbering.style.display = 'block';
                restartAt.style.display = 'block';
                restartAt.nextSibling.style.display = 'block';
            }
            var isCellOrRowSelected = start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
                || start.paragraph.associatedCell !== end.paragraph.associatedCell
                || selection.isCellSelected(start.paragraph.associatedCell, start, end));
            if (isCellOrRowSelected) {
                hyperlink.classList.add('e-disabled');
            }
            else {
                if (hyperlink.classList.contains('e-disabled')) {
                    hyperlink.classList.remove('e-disabled');
                }
            }
            var field = selection.getHyperlinkField();
            if (field instanceof FieldElementBox && !selection.isImageField()) {
                openHyperlink.style.display = 'block';
                copyHyperlink.style.display = 'block';
                if (owner.hyperlinkDialogModule) {
                    editHyperlink.style.display = 'block';
                }
                removeHyperlink.style.display = 'block';
                removeHyperlink.nextSibling.style.display = 'block';
            }
            else {
                if (owner.hyperlinkDialogModule) {
                    hyperlink.style.display = 'block';
                }
            }
        }
        if (this.viewer.owner.selection.start.paragraph.isInsideTable
            && this.viewer.owner.selection.end.paragraph.isInsideTable) {
            paragraph.nextSibling.style.display = 'block';
            if (owner.tablePropertiesDialogModule) {
                tableProperties.style.display = 'block';
            }
            insertTable.style.display = 'block';
            deleteTable.style.display = 'block';
            if (this.viewer.owner.editor.canMergeCells()) {
                mergeCells.style.display = 'block';
            }
            autoFitTable.style.display = this.viewer.selection.isTableSelected() ? 'block' : 'none';
        }
        else {
            if (this.viewer.owner.fontDialogModule) {
                font.style.display = 'block';
                font.previousSibling.style.display = 'block';
            }
            if (this.viewer.owner.paragraphDialogModule) {
                paragraph.style.display = 'block';
            }
        }
        if (selection.contextType === 'Image') {
            font.style.display = 'none';
            paragraph.style.display = 'none';
            removeHyperlink.nextSibling.style.display = 'none';
        }
        return true;
    };
    /**
     * Disposes the internal objects which are maintained.
     * @private
     */
    ContextMenu$$1.prototype.destroy = function () {
        if (this.contextMenuInstance) {
            this.contextMenuInstance.destroy();
        }
        if (this.contextMenu && this.contextMenu.parentElement) {
            this.contextMenu.parentElement.removeChild(this.contextMenu);
            this.contextMenu.innerHTML = '';
        }
        this.contextMenu = undefined;
        this.contextMenuInstance = undefined;
        this.menuItems = [];
        this.customMenuItems = [];
        this.ids = [];
    };
    return ContextMenu$$1;
}());

/**
 * @private
 */
var WAbstractList = /** @__PURE__ @class */ (function () {
    function WAbstractList() {
        this.abstractListIdIn = -1;
        this.levels = [];
    }
    Object.defineProperty(WAbstractList.prototype, "abstractListId", {
        get: function () {
            return this.abstractListIdIn;
        },
        set: function (abstractListId) {
            this.abstractListIdIn = abstractListId;
        },
        enumerable: true,
        configurable: true
    });
    WAbstractList.prototype.destroy = function () {
        if (!isNullOrUndefined(this.levels)) {
            for (var i = 0; i < this.levels.length; i++) {
                var listLevel = this.levels[i];
                listLevel.destroy();
                this.levels.splice(this.levels.indexOf(listLevel), 1);
                i--;
            }
            this.levels = [];
        }
        this.levels = undefined;
    };
    WAbstractList.prototype.clone = function () {
        var absList = new WAbstractList();
        for (var i = 0; i < this.levels.length; i++) {
            absList.levels.push(this.levels[i].clone(absList));
        }
        return absList;
    };
    return WAbstractList;
}());

/**
 * @private
 */
var WListLevel = /** @__PURE__ @class */ (function () {
    function WListLevel(node) {
        this.uniqueListLevel = undefined;
        this.paragraphFormat = undefined;
        this.characterFormat = undefined;
        if (node instanceof WAbstractList) {
            this.ownerBase = node;
        }
        else {
            this.ownerBase = node;
        }
        this.characterFormat = new WCharacterFormat(undefined);
        this.paragraphFormat = new WParagraphFormat(undefined);
    }
    Object.defineProperty(WListLevel.prototype, "listLevelPattern", {
        get: function () {
            return this.getPropertyValue('listLevelPattern');
        },
        set: function (listLevelPattern) {
            this.setPropertyValue('listLevelPattern', listLevelPattern);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WListLevel.prototype, "followCharacter", {
        get: function () {
            return this.getPropertyValue('followCharacter');
        },
        set: function (followCharacter) {
            this.setPropertyValue('followCharacter', followCharacter);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WListLevel.prototype, "startAt", {
        get: function () {
            return this.getPropertyValue('startAt');
        },
        set: function (startAt) {
            this.setPropertyValue('startAt', startAt);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WListLevel.prototype, "numberFormat", {
        get: function () {
            return this.getPropertyValue('numberFormat');
        },
        set: function (numberFormat) {
            this.setPropertyValue('numberFormat', numberFormat);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WListLevel.prototype, "restartLevel", {
        get: function () {
            return this.getPropertyValue('restartLevel');
        },
        set: function (restartLevel) {
            this.setPropertyValue('restartLevel', restartLevel);
        },
        enumerable: true,
        configurable: true
    });
    WListLevel.prototype.getPropertyValue = function (property) {
        var propertyType = WUniqueFormat.getPropertyType(WListLevel.uniqueFormatType, property);
        if (!isNullOrUndefined(this.uniqueListLevel) && this.uniqueListLevel.propertiesHash.containsKey(propertyType)) {
            return this.uniqueListLevel.propertiesHash.get(propertyType);
        }
        return WListLevel.getPropertyDefaultValue(property);
    };
    WListLevel.prototype.setPropertyValue = function (property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WListLevel.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueListLevel)) {
            this.initializeUniqueWListLevel(property, value);
        }
        else {
            var propertyType = WUniqueFormat.getPropertyType(this.uniqueListLevel.uniqueFormatType, property);
            if (this.uniqueListLevel.propertiesHash.containsKey(propertyType) &&
                // tslint:disable-next-line:max-line-length
                this.uniqueListLevel.propertiesHash.get(propertyType) === value) { //Do nothing, since no change in property value and return
                return;
            }
            // tslint:disable-next-line:max-line-length
            this.uniqueListLevel = WListLevel.uniqueListLevels.updateUniqueFormat(this.uniqueListLevel, property, value);
        }
    };
    WListLevel.prototype.initializeUniqueWListLevel = function (property, propValue) {
        var uniqueListLevelTemp = new Dictionary();
        this.addUniqueWListLevel('listLevelPattern', property, propValue, uniqueListLevelTemp);
        this.addUniqueWListLevel('startAt', property, propValue, uniqueListLevelTemp);
        this.addUniqueWListLevel('followCharacter', property, propValue, uniqueListLevelTemp);
        this.addUniqueWListLevel('numberFormat', property, propValue, uniqueListLevelTemp);
        this.addUniqueWListLevel('restartLevel', property, propValue, uniqueListLevelTemp);
        // tslint:disable-next-line:max-line-length    
        this.uniqueListLevel = WListLevel.uniqueListLevels.addUniqueFormat(uniqueListLevelTemp, WListLevel.uniqueFormatType);
    };
    // tslint:disable-next-line:max-line-length
    WListLevel.prototype.addUniqueWListLevel = function (property, modifiedProperty, propValue, uniqueCharFormatTemp) {
        var propertyType;
        propertyType = WUniqueFormat.getPropertyType(WListLevel.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueCharFormatTemp.add(propertyType, propValue);
        }
        else {
            uniqueCharFormatTemp.add(propertyType, WListLevel.getPropertyDefaultValue(property));
        }
    };
    WListLevel.getPropertyDefaultValue = function (property) {
        var value = undefined;
        switch (property) {
            case 'listLevelPattern':
                value = 'Arabic';
                break;
            case 'startAt':
                value = 0;
                break;
            case 'followCharacter':
                value = 'Tab';
                break;
            case 'numberFormat':
                value = '';
                break;
            case 'restartLevel':
                value = 0;
                break;
        }
        return value;
    };
    WListLevel.prototype.destroy = function () {
        if (!isNullOrUndefined(this.characterFormat)) {
            this.characterFormat.destroy();
        }
        if (!isNullOrUndefined(this.paragraphFormat)) {
            this.paragraphFormat.destroy();
        }
        if (!isNullOrUndefined(this.uniqueListLevel)) {
            WListLevel.uniqueListLevels.remove(this.uniqueListLevel);
        }
        this.uniqueListLevel = undefined;
        this.characterFormat = undefined;
        this.paragraphFormat = undefined;
    };
    WListLevel.clear = function () {
        this.uniqueListLevels.clear();
    };
    WListLevel.prototype.clone = function (node) {
        var listLevel = new WListLevel(node);
        listLevel.paragraphFormat = this.paragraphFormat.cloneFormat();
        listLevel.characterFormat = this.characterFormat.cloneFormat();
        if (this.uniqueListLevel) {
            listLevel.uniqueListLevel = this.uniqueListLevel;
            listLevel.uniqueListLevel.referenceCount++;
        }
        return listLevel;
    };
    WListLevel.dotBullet = '\uf0b7';
    WListLevel.squareBullet = '\uf0a7'; //Symbol font \u25aa.
    WListLevel.arrowBullet = '\u27a4';
    WListLevel.circleBullet = '\uf06f' + '\u0020';
    WListLevel.uniqueListLevels = new WUniqueFormats();
    WListLevel.uniqueFormatType = 9;
    return WListLevel;
}());

/**
 * List implementation
 */

/**
 * @private
 */
var Layout = /** @__PURE__ @class */ (function () {
    /**
     * viewer definition
     */
    function Layout(viewer) {
        /**
         * @private
         */
        this.allowLayout = true;
        /**
         * @private
         */
        this.isInitialLoad = true;
        this.fieldBegin = undefined;
        this.maxTextHeight = 0;
        this.maxBaseline = 0;
        this.maxTextBaseline = 0;
        this.isFieldCode = false;
        this.isRTLLayout = false;
        /**
         * @private
         */
        this.isBidiReLayout = false;
        /**
         * @private
         */
        this.defaultTabWidthPixel = 48;
        this.viewer = viewer;
    }
    Layout.prototype.isSameStyle = function (currentParagraph, isAfterSpacing) {
        var nextOrPrevSibling = undefined;
        if (isAfterSpacing) {
            if (currentParagraph.nextWidget instanceof ParagraphWidget) {
                nextOrPrevSibling = currentParagraph.nextWidget;
            }
        }
        else {
            if (currentParagraph.previousWidget instanceof ParagraphWidget) {
                nextOrPrevSibling = currentParagraph.previousWidget;
            }
        }
        if (isNullOrUndefined(nextOrPrevSibling)) {
            return false;
        }
        if (currentParagraph.paragraphFormat.baseStyle === nextOrPrevSibling.paragraphFormat.baseStyle) {
            return currentParagraph.paragraphFormat.contextualSpacing;
        }
        return false;
    };
    /**
     * @private
     */
    Layout.prototype.layout = function () {
        // Todo: Need to handle complete document layout(relayout).
        var page = this.viewer.pages[0];
        var body = page.bodyWidgets[0];
    };
    /**
     * Releases un-managed and - optionally - managed resources.
     */
    Layout.prototype.destroy = function () {
        this.viewer = undefined;
        this.value = undefined;
        this.allowLayout = undefined;
        this.isInitialLoad = undefined;
        this.fieldBegin = undefined;
        this.maxTextHeight = undefined;
        this.maxBaseline = undefined;
        this.maxTextBaseline = undefined;
        this.isFieldCode = undefined;
    };
    /**
     * Layouts the items
     * @private
     */
    Layout.prototype.layoutItems = function (sections) {
        var _this = this;
        var page;
        for (var i = 0; i < sections.length; i++) {
            var section = sections[i];
            page = this.viewer.createNewPage(section);
            this.addBodyWidget(this.viewer.clientActiveArea, section);
            if (this.viewer.pages.length > 1) {
                var pageIndex = 0;
                for (var i_1 = 0; i_1 < this.viewer.pages.length; i_1++) {
                    var prevPage = this.viewer.pages[i_1];
                    var prevSectionIndex = prevPage.sectionIndex;
                    var index = section.index;
                    if (prevSectionIndex > index || prevPage === page) {
                        break;
                    }
                    pageIndex++;
                }
                if (pageIndex < this.viewer.pages.length - 1) {
                    this.viewer.insertPage(pageIndex, page);
                }
            }
            this.layoutSection(section, 0, this.viewer);
        }
        this.layoutComments(this.viewer.comments);
        this.updateFieldElements();
        /* tslint:disable:align */
        setTimeout(function () {
            if (_this.viewer) {
                _this.viewer.isScrollHandler = true;
                if (_this.viewer.owner.enableSpellCheck && _this.viewer.owner.spellChecker.enableOptimizedSpellCheck) {
                    _this.viewer.triggerElementsOnLoading = true;
                }
                _this.viewer.updateScrollBars();
                _this.viewer.isScrollHandler = false;
                _this.isInitialLoad = false;
            }
        }, 50);
    };
    /**
     * Layouts the comments
     * @param comments
     * @private
     */
    Layout.prototype.layoutComments = function (comments) {
        if (!isNullOrUndefined(comments)) {
            this.viewer.owner.commentReviewPane.layoutComments();
        }
    };
    /**
     * Layouts the items
     * @param section
     * @param viewer
     * @private
     */
    Layout.prototype.layoutSection = function (section, index, viewer, ownerWidget) {
        var block = section.firstChild;
        var nextBlock;
        do {
            if (block instanceof TableWidget && block.tableFormat.preferredWidthType === 'Auto'
                && !block.tableFormat.allowAutoFit) {
                block.calculateGrid();
            }
            this.viewer.updateClientAreaForBlock(block, true);
            nextBlock = this.layoutBlock(block, index);
            index = 0;
            this.viewer.updateClientAreaForBlock(block, false);
            block = nextBlock;
        } while (block);
    };
    /**
     * Layouts the header footer items
     * @param section
     * @param viewer
     * @private
     */
    Layout.prototype.layoutHeaderFooter = function (section, viewer, page) {
        //Header layout
        var headerFooterWidget = viewer.getCurrentPageHeaderFooter(section, true);
        if (headerFooterWidget) {
            var header = headerFooterWidget.clone();
            header.page = page;
            viewer.updateHFClientArea(section.sectionFormat, true);
            page.headerWidget = this.layoutHeaderFooterItems(viewer, header);
            this.updateHeaderFooterToParent(header);
        }
        //Footer Layout
        headerFooterWidget = viewer.getCurrentPageHeaderFooter(section, false);
        if (headerFooterWidget) {
            var footer = headerFooterWidget.clone();
            footer.page = page;
            viewer.updateHFClientArea(section.sectionFormat, false);
            page.footerWidget = this.layoutHeaderFooterItems(viewer, footer);
            this.updateHeaderFooterToParent(footer);
        }
    };
    /**
     * @private
     */
    Layout.prototype.updateHeaderFooterToParent = function (node) {
        var sectionIndex = node.page.sectionIndex;
        var typeIndex = this.viewer.getHeaderFooter(node.headerFooterType);
        var clone = node.clone();
        this.viewer.headersFooters[sectionIndex][typeIndex] = clone;
        for (var j = 0; j < clone.childWidgets.length; j++) {
            var child = clone.childWidgets[j];
            if (child instanceof TableWidget) {
                this.clearTableWidget(child, false, true);
            }
        }
        return clone;
    };
    Layout.prototype.linkFieldInHeaderFooter = function (widget) {
        var firstChild = widget.firstChild;
        do {
            if (firstChild instanceof ParagraphWidget) {
                this.linkFieldInParagraph(firstChild);
            }
            else {
                this.linkFieldInTable(firstChild);
            }
            //tslint:disable:no-conditional-assignment
        } while (firstChild = firstChild.nextWidget);
    };
    /**
     * @private
     */
    Layout.prototype.linkFieldInParagraph = function (widget) {
        for (var j = 0; j < widget.childWidgets.length; j++) {
            var line = widget.childWidgets[j];
            for (var i = 0; i < line.children.length; i++) {
                var element = line.children[i];
                if (element instanceof FieldElementBox && element.fieldType !== 0) {
                    element.linkFieldCharacter(this.viewer);
                }
            }
        }
    };
    /**
     * @private
     */
    Layout.prototype.linkFieldInTable = function (widget) {
        for (var i = 0; i < widget.childWidgets.length; i++) {
            var row = widget.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                for (var k = 0; k < cell.childWidgets.length; k++) {
                    var block = cell.childWidgets[k];
                    if (block instanceof ParagraphWidget) {
                        this.linkFieldInParagraph(block);
                    }
                    else {
                        this.linkFieldInTable(block);
                    }
                }
            }
        }
    };
    /**
     * Layouts the header footer items.
     * @param viewer
     * @param hfModule
     * @private
     */
    Layout.prototype.layoutHeaderFooterItems = function (viewer, widget) {
        this.viewer.updateClientAreaLocation(widget, viewer.clientActiveArea);
        if (widget.childWidgets.length === 0) {
            var pargaraph = new ParagraphWidget();
            var line = new LineWidget(pargaraph);
            pargaraph.childWidgets.push(line);
            widget.childWidgets.push(pargaraph);
            pargaraph.containerWidget = widget;
        }
        this.linkFieldInHeaderFooter(widget);
        for (var i = 0; i < widget.childWidgets.length; i++) {
            var block = widget.childWidgets[i];
            if (block instanceof TableWidget && block.tableFormat.preferredWidthType === 'Auto'
                && !block.tableFormat.allowAutoFit && !block.isGridUpdated) {
                block.calculateGrid();
            }
            viewer.updateClientAreaForBlock(block, true);
            this.layoutBlock(block, 0);
            viewer.updateClientAreaForBlock(block, false);
        }
        var type = widget.headerFooterType;
        if (type === 'OddFooter' || type === 'EvenFooter' || type === 'FirstPageFooter') {
            this.shiftChildLocation(viewer.clientArea.y - viewer.clientActiveArea.y, widget);
        }
        return widget;
    };
    /**
     * Shifts the child location
     * @param shiftTop
     * @param bodyWidget
     */
    Layout.prototype.shiftChildLocation = function (shiftTop, bodyWidget) {
        var widgetTop = bodyWidget.y + shiftTop;
        var footerMaxHeight = bodyWidget.page.boundingRectangle.height - (bodyWidget.page.boundingRectangle.height / 100) * 40;
        widgetTop = Math.max(widgetTop, footerMaxHeight);
        shiftTop = widgetTop - bodyWidget.y;
        var childTop = bodyWidget.y = widgetTop;
        for (var i = 0; i < bodyWidget.childWidgets.length; i++) {
            var childWidget = bodyWidget.childWidgets[i];
            if (childWidget instanceof ParagraphWidget) {
                childWidget.x = childWidget.x;
                childWidget.y = i === 0 ? childWidget.y + shiftTop : childTop;
                childTop += childWidget.height;
            }
            else {
                this.shiftChildLocationForTableWidget(childWidget, shiftTop);
            }
        }
    };
    /**
     * Shifts the child location for table widget.
     * @param tableWidget
     * @param shiftTop
     */
    Layout.prototype.shiftChildLocationForTableWidget = function (tableWidget, shiftTop) {
        tableWidget.y = tableWidget.y + shiftTop;
        for (var i = 0; i < tableWidget.childWidgets.length; i++) {
            var childWidget = tableWidget.childWidgets[i];
            if (childWidget instanceof TableRowWidget) {
                this.shiftChildLocationForTableRowWidget(childWidget, shiftTop);
            }
        }
    };
    /**
     * Shifts the child location for table row widget.
     * @param rowWidget
     * @param shiftTop
     */
    Layout.prototype.shiftChildLocationForTableRowWidget = function (rowWidget, shiftTop) {
        rowWidget.y = rowWidget.y + shiftTop;
        for (var i = 0; i < rowWidget.childWidgets.length; i++) {
            this.shiftChildLocationForTableCellWidget(rowWidget.childWidgets[i], shiftTop);
        }
    };
    /**
     * Shifts the child location for table cell widget.
     * @param cellWidget
     * @param shiftTop
     */
    Layout.prototype.shiftChildLocationForTableCellWidget = function (cellWidget, shiftTop) {
        cellWidget.y = cellWidget.y + shiftTop;
        for (var i = 0; i < cellWidget.childWidgets.length; i++) {
            if (cellWidget.childWidgets[i] instanceof ParagraphWidget) {
                cellWidget.childWidgets[i].x = cellWidget.childWidgets[i].x;
                cellWidget.childWidgets[i].y = cellWidget.childWidgets[i].y + shiftTop;
            }
            else {
                this.shiftChildLocationForTableWidget(cellWidget.childWidgets[i], shiftTop);
            }
        }
    };
    /**
     * Layouts specified block.
     * @param block
     * @private
     */
    Layout.prototype.layoutBlock = function (block, index, moveToLine) {
        var nextBlock;
        if (block instanceof ParagraphWidget) {
            nextBlock = this.layoutParagraph(block, index);
        }
        else {
            nextBlock = this.layoutTable(block, index);
        }
        return nextBlock.nextRenderedWidget;
    };
    /**
     * Adds paragraph widget.
     * @param area
     */
    Layout.prototype.addParagraphWidget = function (area, paragraphWidget) {
        if (paragraphWidget.isEmpty() && !isNullOrUndefined(paragraphWidget.paragraphFormat) &&
            (paragraphWidget.paragraphFormat.textAlignment === 'Center' || paragraphWidget.paragraphFormat.textAlignment === 'Right') &&
            paragraphWidget.paragraphFormat.listFormat.listId === -1) {
            var width = this.viewer.textHelper.getParagraphMarkWidth(paragraphWidget.characterFormat);
            var left = area.x;
            if (paragraphWidget.paragraphFormat.textAlignment === 'Center') {
                left += (area.width - width) / 2;
            }
            else {
                left += area.width - width;
            }
            paragraphWidget.width = width;
            paragraphWidget.x = left;
            paragraphWidget.y = area.y;
        }
        else {
            paragraphWidget.width = area.width;
            paragraphWidget.x = area.x;
            paragraphWidget.y = area.y;
        }
        return paragraphWidget;
    };
    /**
     * Adds line widget.
     * @param paragraph
     */
    Layout.prototype.addLineWidget = function (paragraphWidget) {
        var line = undefined;
        line = new LineWidget(paragraphWidget);
        line.width = paragraphWidget.width;
        paragraphWidget.childWidgets.push(line);
        line.paragraph = paragraphWidget;
        return line;
    };
    Layout.prototype.isFirstElementWithPageBreak = function (paragraphWidget) {
        var isPageBreak = false;
        var lineWidget = paragraphWidget.childWidgets[0];
        if (lineWidget) {
            var element = lineWidget.children[0];
            while (element) {
                if (element instanceof BookmarkElementBox && element.name.indexOf('_') >= 0) {
                    element = element.nextElement;
                    continue;
                }
                if (element instanceof TextElementBox && element.text === '\f') {
                    isPageBreak = true;
                }
                break;
            }
        }
        return isPageBreak;
    };
    
    /**
     * Layouts specified paragraph.
     * @private
     * @param paragraph
     */
    Layout.prototype.layoutParagraph = function (paragraph, lineIndex) {
        this.addParagraphWidget(this.viewer.clientActiveArea, paragraph);
        var isListLayout = true;
        var isFirstElmIsparagraph = this.isFirstElementWithPageBreak(paragraph);
        if (!isFirstElmIsparagraph) {
            this.layoutListItems(paragraph);
            isListLayout = false;
        }
        if (paragraph.isEmpty()) {
            this.layoutEmptyLineWidget(paragraph, true);
        }
        else {
            var line = lineIndex < paragraph.childWidgets.length ?
                paragraph.childWidgets[lineIndex] : undefined;
            while (line instanceof LineWidget) {
                if (paragraph !== line.paragraph && line.indexInOwner === 0 && isListLayout) {
                    this.layoutListItems(line.paragraph);
                }
                if (line.isFirstLine() && isNullOrUndefined(this.fieldBegin)) {
                    if (!isNullOrUndefined(paragraph.paragraphFormat)) {
                        // tslint:disable-next-line:max-line-length
                        var firstLineIndent = -HelperMethods.convertPointToPixel(paragraph.paragraphFormat.firstLineIndent);
                        this.viewer.updateClientWidth(firstLineIndent);
                    }
                }
                line = this.layoutLine(line, 0);
                paragraph = line.paragraph;
                line = line.nextLine;
            }
        }
        this.updateWidgetToPage(this.viewer, paragraph);
        return paragraph;
    };
    Layout.prototype.clearLineMeasures = function () {
        this.maxBaseline = 0;
        this.maxTextBaseline = 0;
        this.maxTextHeight = 0;
    };
    Layout.prototype.moveElementFromNextLine = function (line) {
        var nextLine = line.nextLine;
        while (nextLine instanceof LineWidget) {
            if (nextLine.children.length > 0) {
                var element = nextLine.children.splice(0, 1)[0];
                line.children.push(element);
                element.line = line;
                break;
            }
            else {
                if (nextLine.paragraph.childWidgets.length === 1) {
                    nextLine.paragraph.destroy();
                }
                else {
                    nextLine.destroy();
                }
                nextLine = line.nextLine;
            }
        }
    };
    Layout.prototype.layoutLine = function (line, count) {
        var paragraph = line.paragraph;
        if (line.children.length === 0) {
            this.moveElementFromNextLine(line);
        }
        var element = line.children[count];
        this.clearLineMeasures();
        while (element instanceof ElementBox) {
            this.layoutElement(element, paragraph);
            line = element.line;
            if (element instanceof TextElementBox) {
                var textElement = element;
                if (!isNullOrUndefined(textElement.errorCollection) && textElement.errorCollection.length > 0) {
                    textElement.ischangeDetected = true;
                }
            }
            if (!this.isRTLLayout) {
                element = element.nextElement;
            }
            else {
                element = undefined;
                this.isRTLLayout = false;
            }
        }
        return line;
    };
    // tslint:disable:max-func-body-length
    Layout.prototype.layoutElement = function (element, paragraph) {
        var line = element.line;
        var text = '';
        var index = element.indexInOwner;
        if (element instanceof FieldElementBox) {
            if (element.fieldType === 0 && this.viewer.fields.indexOf(element) === -1) {
                this.viewer.fields.push(element);
            }
            this.layoutFieldCharacters(element);
            if (element.line.isLastLine() && isNullOrUndefined(element.nextNode) && !this.isFieldCode) {
                if (isNullOrUndefined(element.fieldSeparator)) {
                    this.layoutEmptyLineWidget(paragraph, false, element.line);
                }
                this.moveToNextLine(line);
            }
            else if (isNullOrUndefined(element.nextElement) && this.viewer.clientActiveArea.width > 0 && !element.line.isLastLine()) {
                this.moveElementFromNextLine(line);
            }
            else if (isNullOrUndefined(element.nextElement) && this.viewer.clientActiveArea.width === 0) {
                this.moveToNextLine(line);
                if (line.paragraph.lastChild === line && !isNullOrUndefined(line.nextLine) &&
                    this.viewer.clientActiveArea.height >= 0) {
                    this.moveFromNextPage(line);
                }
            }
            return;
        }
        if (element instanceof ListTextElementBox || this.isFieldCode || element instanceof BookmarkElementBox ||
            element instanceof EditRangeEndElementBox || element instanceof EditRangeStartElementBox) {
            if (element instanceof BookmarkElementBox) {
                if (element.bookmarkType === 0 && !this.viewer.bookmarks.containsKey(element.name)) {
                    this.viewer.bookmarks.add(element.name, element);
                }
                else if (element.bookmarkType === 1 && this.viewer.bookmarks.containsKey(element.name)) {
                    var bookmrkElement = this.viewer.bookmarks.get(element.name);
                    if (isNullOrUndefined(bookmrkElement.reference)) {
                        bookmrkElement.reference = element;
                        element.reference = bookmrkElement;
                    }
                }
            }
            if (isNullOrUndefined(element.nextElement) && this.viewer.clientActiveArea.width > 0 && !element.line.isLastLine()) {
                this.moveElementFromNextLine(line);
            }
            if (element.line.isLastLine() && isNullOrUndefined(element.nextElement)) {
                if (this.hasValidElement(line.paragraph)) {
                    this.moveToNextLine(line);
                }
                else {
                    this.layoutEmptyLineWidget(line.paragraph, false, line, false);
                }
            }
            return;
        }
        var width = element.width;
        if (element instanceof FieldTextElementBox) {
            text = this.viewer.getFieldResult(element.fieldBegin, element.paragraph.bodyWidget.page);
            if (text !== '') {
                element.text = text;
            }
            else {
                text = element.text;
            }
        }
        else if (element instanceof TextElementBox) {
            this.checkAndSplitTabOrLineBreakCharacter(element.text, element);
            this.splitBySpecialCharacters(element);
            text = element.text;
        }
        // Here field code width and height update need to skipped based on the hidden property.
        if (element instanceof TextElementBox) {
            width = this.viewer.textHelper.getTextSize(element, element.characterFormat);
            if (element.text === '\t') {
                element.width = this.getTabWidth(paragraph, this.viewer, index, line, element);
            }
        }
        if (this.viewer instanceof PageLayoutViewer
            && this.viewer.clientActiveArea.height < element.height && this.viewer.clientActiveArea.y !== this.viewer.clientArea.y) {
            this.moveToNextPage(this.viewer, line);
            if (element instanceof FieldTextElementBox) {
                this.updateFieldText(element);
            }
            if (element.previousElement) {
                this.cutClientWidth(element.previousElement);
            }
        }
        if (parseFloat(width.toFixed(4)) <= parseFloat(this.viewer.clientActiveArea.width.toFixed(4)) || !this.viewer.textWrap) {
            //Fits the text in current line.
            this.addElementToLine(paragraph, element);
            if (isNullOrUndefined(element.nextElement) && this.viewer.clientActiveArea.width > 0 && !element.line.isLastLine()) {
                this.moveElementFromNextLine(line);
            }
            else if (!element.line.isLastLine() && isNullOrUndefined(element.nextElement) && this.viewer.clientActiveArea.width === 0) {
                this.moveToNextLine(line);
                if (line.paragraph.lastChild === line && this.viewer.clientActiveArea.height >= 0) {
                    this.moveFromNextPage(line);
                }
            }
        }
        else if (element instanceof TextElementBox) {
            if (element.text === '\t') {
                var currentLine = element.line;
                this.addSplittedLineWidget(currentLine, currentLine.children.indexOf(element) - 1);
                this.moveToNextLine(currentLine);
                // Recalculates tab width based on new client active area X position
                element.width = this.getTabWidth(paragraph, this.viewer, index, element.line, element);
                this.addElementToLine(paragraph, element);
            }
            else {
                //Splits the text and arrange line by line, till end of text.
                do {
                    line = element.line;
                    this.splitTextForClientArea(line, element, element.text, element.width, element.characterFormat);
                    this.checkLineWidgetWithClientArea(line, element);
                    if (element instanceof FieldTextElementBox) {
                        this.updateFieldText(element);
                    }
                } while (element.line !== line && this.cutClientWidth(element));
            }
        }
        else {
            do {
                line = element.line;
                this.splitElementForClientArea(paragraph, element);
                this.checkLineWidgetWithClientArea(line, element);
                if (element instanceof FieldTextElementBox) {
                    this.updateFieldText(element);
                }
            } while (element.line !== line && this.cutClientWidth(element));
        }
        if (text === '\v' || text === '\f') {
            var elementIndex = line.children.indexOf(element);
            if (elementIndex > -1) {
                this.addSplittedLineWidget(line, elementIndex);
            }
        }
        if (element.line.isLastLine() && isNullOrUndefined(element.nextElement) || text === '\v' || text === '\f') {
            this.moveToNextLine(element.line);
            if (text === '\v' && isNullOrUndefined(element.nextNode)) {
                this.layoutEmptyLineWidget(paragraph, true, line, true);
            }
            else if (text === '\f') {
                if (isNullOrUndefined(element.nextNode)) {
                    this.moveToNextPage(this.viewer, element.line, true);
                }
                else {
                    this.moveToNextPage(this.viewer, element.line.nextLine, false);
                }
            }
        }
    };
    /**
     * Return true if paragraph has valid inline
     * @private
     */
    Layout.prototype.hasValidElement = function (paragraph) {
        var line = paragraph.firstChild;
        if (line && !isNullOrUndefined(this.viewer.selection)) {
            var elementBox = line.children[0];
            while (elementBox) {
                if (elementBox instanceof FieldElementBox) {
                    elementBox = this.viewer.selection.getNextValidElementForField(elementBox);
                    if (!elementBox.line.paragraph.equals(paragraph)) {
                        return false;
                    }
                }
                if (elementBox instanceof TextElementBox || elementBox instanceof ImageElementBox) {
                    return true;
                }
                elementBox = elementBox.nextNode;
            }
        }
        return false;
    };
    Layout.prototype.updateFieldText = function (element) {
        // tslint:disable-next-line:max-line-length
        var text = this.viewer.getFieldResult(element.fieldBegin, element.paragraph.bodyWidget.page);
        if (text !== '') {
            element.text = text;
            this.viewer.textHelper.getTextSize(element, element.characterFormat);
        }
    };
    Layout.prototype.checkLineWidgetWithClientArea = function (line, element) {
        if (line !== element.line || element.line === line && isNullOrUndefined(element.nextElement)
            && !element.line.isLastLine()) {
            this.moveToNextLine(line);
            if (line !== element.line) {
                this.isRTLLayout = false;
            }
        }
        if (element.line !== line && this.viewer instanceof PageLayoutViewer
            && this.viewer.clientActiveArea.height < element.height &&
            this.viewer.clientActiveArea.y !== this.viewer.clientArea.y) {
            this.moveToNextPage(this.viewer, element.line);
        }
        else if (element.line === line && isNullOrUndefined(element.nextElement)
            && line.paragraph.lastChild === line && !line.isLastLine() && this.viewer.clientActiveArea.height >= 0) {
            this.moveFromNextPage(line);
        }
    };
    Layout.prototype.checkAndSplitTabOrLineBreakCharacter = function (text, element) {
        var char = ['\t', '\v', '\f'];
        var index = HelperMethods.indexOfAny(text, char);
        if (index > -1) {
            var character = text[index];
            if ((character === '\t' && text !== '\t') || (character === '\v' && text !== '\v')
                || (character === '\f' && text !== '\f')) {
                this.splitByLineBreakOrTab(this.viewer, element, index, character);
            }
        }
    };
    Layout.prototype.splitBySpecialCharacters = function (span) {
        if (this.viewer.textHelper.isRTLText(span.text) && this.viewer.textHelper.containsSpecialChar(span.text)) {
            var inlineIndex = span.line.children.indexOf(span);
            var text = span.text;
            var specialChars = '*|.\:[]{}`\;()@&$#%!~';
            var textToReplace = '';
            var spanTextUpdated = false;
            for (var i = 0; i < text.length; i++) {
                if (specialChars.indexOf(text.charAt(i)) !== -1) {
                    if (spanTextUpdated && textToReplace !== '') {
                        var newSpan1 = new TextElementBox();
                        newSpan1.line = span.line;
                        newSpan1.characterFormat.copyFormat(span.characterFormat);
                        span.line.children.splice(inlineIndex = inlineIndex + 1, 0, newSpan1);
                        newSpan1.text = textToReplace;
                    }
                    var newSpan = new TextElementBox();
                    newSpan.line = span.line;
                    newSpan.characterFormat.copyFormat(span.characterFormat);
                    span.line.children.splice(inlineIndex = inlineIndex + 1, 0, newSpan);
                    newSpan.text = text.charAt(i);
                    if (!spanTextUpdated) {
                        span.text = textToReplace;
                        spanTextUpdated = true;
                    }
                    textToReplace = '';
                }
                else {
                    textToReplace += text.charAt(i);
                }
            }
            if (spanTextUpdated && textToReplace !== '') {
                var newSpan2 = new TextElementBox();
                newSpan2.line = span.line;
                newSpan2.characterFormat.copyFormat(span.characterFormat);
                span.line.children.splice(inlineIndex = inlineIndex + 1, 0, newSpan2);
                newSpan2.text = textToReplace;
            }
        }
    };
    /**
     * @private
     */
    Layout.prototype.moveFromNextPage = function (line) {
        var nextLine = line.nextLine;
        if (nextLine && line.paragraph.childWidgets.indexOf(nextLine) === -1) {
            nextLine.paragraph.childWidgets.splice(nextLine.indexInOwner, 1);
            line.paragraph.childWidgets.push(nextLine);
            nextLine.paragraph = line.paragraph;
        }
    };
    Layout.prototype.cutClientWidth = function (currentElement) {
        this.clearLineMeasures();
        var line = currentElement.line;
        var width = 0;
        for (var i = 0; i < line.children.length; i++) {
            var element = line.children[i];
            width += element.width;
            if (currentElement === element) {
                break;
            }
        }
        var splitCurrentWidget = this.viewer.clientActiveArea.width - width < 0;
        if (!splitCurrentWidget) {
            this.viewer.cutFromLeft(this.viewer.clientActiveArea.x + width);
            if (currentElement.line.paragraph.paragraphFormat.textAlignment === 'Justify' &&
                currentElement instanceof TextElementBox) {
                this.splitTextElementWordByWord(currentElement);
            }
            if (isNullOrUndefined(currentElement.nextElement) && this.viewer.clientActiveArea.width > 0
                && !currentElement.line.isLastLine()) {
                this.moveElementFromNextLine(line);
            }
        }
        else if (currentElement.previousElement) {
            this.cutClientWidth(currentElement.previousElement);
        }
        return splitCurrentWidget;
    };
    Layout.prototype.layoutFieldCharacters = function (element) {
        if (element.fieldType === 0) {
            if (!this.isFieldCode && (!isNullOrUndefined(element.fieldEnd) || element.hasFieldEnd)) {
                this.viewer.fieldStacks.push(element);
                this.isFieldCode = true;
                element.hasFieldEnd = true;
            }
        }
        else if (this.viewer.fieldStacks.length > 0) {
            if (element.fieldType === 2) {
                var field = this.viewer.fieldStacks[this.viewer.fieldStacks.length - 1];
                if (field.fieldSeparator === element && (!isNullOrUndefined(field.fieldEnd) || field.hasFieldEnd)) {
                    this.isFieldCode = false;
                }
            }
            else {
                var field = this.viewer.fieldStacks[this.viewer.fieldStacks.length - 1];
                if (element === field.fieldEnd) {
                    this.viewer.fieldStacks.pop();
                    this.isFieldCode = false;
                }
            }
        }
    };
    /**
     * Layouts empty line widget.
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.layoutEmptyLineWidget = function (paragraph, isEmptyLine, line, isShiftEnter) {
        var paraFormat = paragraph.paragraphFormat;
        var subWidth = 0;
        var whiteSpaceCount = 0;
        isShiftEnter = isNullOrUndefined(isShiftEnter) ? false : isShiftEnter;
        //Calculate line height and descent based on formatting defined in paragraph.
        var paragraphMarkSize = this.viewer.textHelper.getParagraphMarkSize(paragraph.characterFormat);
        var maxHeight = paragraphMarkSize.Height;
        var beforeSpacing = this.getBeforeSpacing(paragraph);
        var lineWidget;
        if (paragraph.childWidgets.length > 0 && !isShiftEnter) {
            lineWidget = paragraph.childWidgets[0];
            if (lineWidget.children.length > 0) {
                if (!this.isBidiReLayout && (paraFormat.bidi || this.isContainsRtl(lineWidget))) {
                    this.reArrangeElementsForRtl(lineWidget, paraFormat.bidi);
                }
                var isParagraphStart = lineWidget.isFirstLine();
                var isParagraphEnd = lineWidget.isLastLine();
                var firstLineIndent = 0;
                if (isParagraphStart) {
                    beforeSpacing = this.getBeforeSpacing(paragraph);
                    firstLineIndent = HelperMethods.convertPointToPixel(paraFormat.firstLineIndent);
                }
                var textAlignment = paraFormat.textAlignment;
                if (textAlignment !== 'Left' && this.viewer.textWrap
                    && (!(textAlignment === 'Justify' && isParagraphEnd)
                        || (textAlignment === 'Justify' && paraFormat.bidi))) {
                    // tslint:disable-next-line:max-line-length
                    var getWidthAndSpace = this.getSubWidth(lineWidget, textAlignment === 'Justify', whiteSpaceCount, firstLineIndent, isParagraphEnd);
                    subWidth = getWidthAndSpace.subWidth;
                    whiteSpaceCount = getWidthAndSpace.spaceCount;
                }
            }
        }
        else {
            lineWidget = isEmptyLine ? this.addLineWidget(paragraph) : line;
        }
        //isNullOrUndefined(this.viewer.currentHeaderFooter) && 
        if (this.viewer instanceof PageLayoutViewer
            && this.viewer.clientActiveArea.height < beforeSpacing + maxHeight
            && this.viewer.clientActiveArea.y !== this.viewer.clientArea.y) {
            this.moveToNextPage(this.viewer, lineWidget);
        }
        //Gets line spacing.
        var lineSpacing = this.getLineSpacing(paragraph, maxHeight);
        var maxDescent = maxHeight - paragraphMarkSize.BaselineOffset;
        //Calculate the bottom position of current line - max height + line spacing.
        if (!isNaN(this.maxTextHeight)
            && maxHeight < this.maxTextHeight) {
            maxHeight = this.maxTextHeight;
            maxDescent = maxHeight - this.maxTextBaseline;
        }
        var topMargin = 0;
        var bottomMargin = 0;
        var leftMargin = 0;
        var height = maxHeight;
        var lineSpacingType = paragraph.paragraphFormat.lineSpacingType;
        if (lineSpacingType === 'Multiple') {
            if (lineSpacing > maxHeight) {
                bottomMargin += lineSpacing - maxHeight;
            }
            else {
                topMargin += lineSpacing - maxHeight;
            }
        }
        else if (lineSpacingType === 'Exactly') {
            topMargin += lineSpacing - (topMargin + height + bottomMargin);
        }
        else if (lineSpacing > topMargin + height + bottomMargin) {
            topMargin += lineSpacing - (topMargin + height + bottomMargin);
        }
        topMargin += beforeSpacing;
        bottomMargin += HelperMethods.convertPointToPixel(this.getAfterSpacing(paragraph));
        for (var i = 0; i < lineWidget.children.length; i++) {
            var element = lineWidget.children[i];
            if (i === 0 && element instanceof ListTextElementBox) {
                var textAlignment = paragraph.paragraphFormat.textAlignment;
                if (textAlignment === 'Right') { //Aligns the text as right justified.
                    leftMargin = subWidth;
                }
                else if (textAlignment === 'Center') { //Aligns the text as center justified.
                    leftMargin = subWidth / 2;
                }
                element.margin = new Margin(leftMargin, topMargin, 0, bottomMargin);
                element.line = lineWidget;
                lineWidget.height = topMargin + height + bottomMargin;
            }
        }
        lineWidget.height = topMargin + height + bottomMargin;
        this.viewer.cutFromTop(this.viewer.clientActiveArea.y + lineWidget.height);
        //Clears the previous line elements from collection.     
    };
    /**
     * @private
     */
    Layout.prototype.layoutListItems = function (paragraph) {
        if (!this.isFieldCode) {
            if (!isNullOrUndefined(paragraph.paragraphFormat)
                && !isNullOrUndefined(paragraph.paragraphFormat.listFormat)
                && !isNullOrUndefined(this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId)) &&
                paragraph.paragraphFormat.listFormat.listLevelNumber >= 0
                && paragraph.paragraphFormat.listFormat.listLevelNumber < 9) {
                this.clearListElementBox(paragraph);
                this.layoutList(paragraph, this.viewer);
            }
            else if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId === -1) {
                this.clearListElementBox(paragraph);
            }
        }
    };
    /**
     * Layouts list.
     * @param viewer
     */
    Layout.prototype.layoutList = function (paragraph, viewer) {
        var list = viewer.getListById(paragraph.paragraphFormat.listFormat.listId);
        viewer.updateClientWidth(-HelperMethods.convertPointToPixel(paragraph.paragraphFormat.firstLineIndent));
        var currentListLevel = this.getListLevel(list, paragraph.paragraphFormat.listFormat.listLevelNumber);
        // if (isNullOrUndefined(currentListLevel)) {
        //     return;
        // }
        var lineWidget = paragraph.childWidgets[0];
        if (isNullOrUndefined(lineWidget)) {
            lineWidget = new LineWidget(paragraph);
            paragraph.childWidgets.push(lineWidget);
        }
        var element = new ListTextElementBox(currentListLevel, false);
        element.line = lineWidget;
        if (currentListLevel.listLevelPattern === 'Bullet') {
            element.text = currentListLevel.numberFormat;
        }
        else {
            element.text = this.getListNumber(paragraph.paragraphFormat.listFormat);
        }
        if (this.viewer.isIosDevice) {
            var text = element.text;
            text = text === '\uf0b7' ? '\u25CF' : text === '\uf06f' + '\u0020' ? '\u25CB' : text;
            if (text !== element.text) {
                element.text = text;
                element.listLevel.characterFormat.fontFamily = '';
            }
        }
        viewer.textHelper.updateTextSize(element, paragraph);
        var moveToNextPage;
        if (this.viewer instanceof PageLayoutViewer
            && this.viewer.clientActiveArea.height < element.height && this.viewer.clientActiveArea.y !== this.viewer.clientArea.y) {
            moveToNextPage = true;
        }
        viewer.cutFromLeft(viewer.clientActiveArea.x + element.width);
        //Adds the text element to the line
        lineWidget.children.splice(0, 0, element);
        if (currentListLevel.followCharacter !== 'None') {
            element = new ListTextElementBox(currentListLevel, true);
            if (currentListLevel.followCharacter === 'Tab') {
                element.text = '\t';
                var index = lineWidget.children.indexOf(element);
                element.width = this.getTabWidth(paragraph, viewer, index, lineWidget, element);
            }
            else {
                element.text = ' ';
                viewer.textHelper.updateTextSize(element, paragraph);
            }
            viewer.cutFromLeft(viewer.clientActiveArea.x + element.width);
            //Adds the tabSpace to the line
            lineWidget.children.splice(1, 0, element);
            element.line = lineWidget;
        }
        if (moveToNextPage) {
            this.moveToNextPage(this.viewer, lineWidget);
            this.cutClientWidth(element);
            return;
        }
        if (currentListLevel.followCharacter !== 'None') {
            viewer.updateClientWidth(HelperMethods.convertPointToPixel(paragraph.paragraphFormat.firstLineIndent));
        }
    };
    /**
     * Adds body widget.
     * @param area
     * @param section
     * @private
     */
    Layout.prototype.addBodyWidget = function (area, widget) {
        var bodyWidget;
        if (widget) {
            bodyWidget = widget;
        }
        else {
            bodyWidget = new BodyWidget();
        }
        bodyWidget.width = area.width;
        bodyWidget.x = area.x;
        bodyWidget.y = area.y;
        // this.addSectionInDictionary(this.viewer, section, bodyWidget);
        return bodyWidget;
    };
    /**
     * Adds list level.
     * @param abstractList
     */
    Layout.prototype.addListLevels = function (abstractList) {
        for (var i = abstractList.levels.length; i < 9; i++) {
            var listLevel = new WListLevel(abstractList);
            var val = i % 3;
            if (abstractList.levels[0].listLevelPattern === 'Bullet') {
                listLevel.listLevelPattern = 'Bullet';
                listLevel.numberFormat = val === 0 ? '\uf0b7' : val === 1 ? '\uf0a7' : '\uf0d8';
                listLevel.characterFormat.fontFamily = listLevel.numberFormat === '\uf0a7' || '\uf0d8' ? 'Wingdings' : 'Symbol';
            }
            else {
                listLevel.listLevelPattern = this.getListLevelPattern(val);
                listLevel.numberFormat = '%' + (i + 1).toString() + '.';
                listLevel.startAt = 1;
                listLevel.restartLevel = i;
            }
            listLevel.paragraphFormat = new WParagraphFormat(undefined);
            listLevel.paragraphFormat.leftIndent = 48 * (i + 1);
            listLevel.paragraphFormat.firstLineIndent = -24;
            abstractList.levels.push(listLevel);
        }
    };
    Layout.prototype.addSplittedLineWidget = function (lineWidget, elementIndex, splittedElementBox) {
        var paragraph = lineWidget.paragraph;
        var movedElementBox = [];
        var lineIndex = paragraph.childWidgets.indexOf(lineWidget);
        if (!isNullOrUndefined(splittedElementBox)) {
            movedElementBox.push(splittedElementBox);
        }
        var newLineWidget = undefined;
        //Move Next element box to temp collection
        for (var i = elementIndex + 1; i < lineWidget.children.length; i++) {
            movedElementBox.push(lineWidget.children[i]);
        }
        if (movedElementBox.length > 0) {
            if (lineIndex === paragraph.childWidgets.length - 1) {
                newLineWidget = new LineWidget(paragraph);
            }
            else {
                newLineWidget = paragraph.childWidgets[lineIndex + 1];
            }
            for (var j = 0; j < movedElementBox.length; j++) {
                movedElementBox[j].line = newLineWidget;
            }
            lineWidget.children.splice(elementIndex + 1, lineWidget.children.length - 1);
            newLineWidget.children = movedElementBox.concat(newLineWidget.children);
            if (paragraph.childWidgets.indexOf(newLineWidget) === -1) {
                paragraph.childWidgets.splice(lineIndex + 1, 0, newLineWidget);
            }
        }
    };
    /**
     * Adds element to line.
     * @param element
     */
    Layout.prototype.addElementToLine = function (paragraph, element) {
        this.viewer.cutFromLeft(this.viewer.clientActiveArea.x + element.width);
        if (paragraph.paragraphFormat.textAlignment === 'Justify' && element instanceof TextElementBox) {
            this.splitTextElementWordByWord(element);
        }
    };
    /**
     * Splits element for client area.
     * @param element
     */
    Layout.prototype.splitElementForClientArea = function (paragraph, element) {
        var line = element.line;
        if (element.line.children.length > 0) {
            var previousElement = element.previousElement;
            var index = element.indexInOwner;
            // if line widget contain only single image element box need to skip this from splitting
            // else move element to next line
            if (element.line.children.length > 1) {
                if (previousElement && this.viewer.clientActiveArea.x !== this.viewer.clientArea.x) {
                    index -= 1;
                }
            }
            this.addSplittedLineWidget(element.line, index);
        }
    };
    /**
     * Splits by word
     * @param elementBox
     * @param text
     * @param width
     * @param characterFormat
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.splitByWord = function (lineWidget, paragraph, elementBox, text, width, characterFormat) {
        var index = this.getSplitIndexByWord(this.viewer.clientActiveArea.width, text, width, characterFormat);
        if (index > 0 && index < elementBox.length) {
            var indexOf = lineWidget.children.indexOf(elementBox);
            var lineIndex = paragraph.childWidgets.indexOf(lineWidget);
            var splittedElementBox = new TextElementBox();
            text = text.substring(index);
            splittedElementBox.text = text;
            if (text[0] === ' ') {
                var prevLength = text.length;
                text = HelperMethods.trimStart(text); //To trim white space at starting of the text.
                index += prevLength - text.length;
            }
            splittedElementBox.characterFormat.copyFormat(elementBox.characterFormat);
            splittedElementBox.width = this.viewer.textHelper.getWidth(splittedElementBox.text, characterFormat);
            elementBox.text = elementBox.text.substr(0, index);
            elementBox.width -= splittedElementBox.width;
            splittedElementBox.height = elementBox.height;
            splittedElementBox.baselineOffset = elementBox.baselineOffset;
            this.splitErrorCollection(elementBox, splittedElementBox);
            this.addSplittedLineWidget(lineWidget, indexOf, splittedElementBox);
            this.addElementToLine(paragraph, elementBox);
            if (elementBox.width === 0) {
                lineWidget.children.splice(indexOf, 1);
            }
        }
    };
    /**
     * Method to include error collection on splitted element
     * @private
     * @param {ElementBox} elementBox
     * @param {ElementBox} splittedBox
     */
    Layout.prototype.splitErrorCollection = function (elementBox, splittedBox) {
        if (elementBox.errorCollection.length > 0) {
            var errorCollection = [];
            var ignoreItems = elementBox.ignoreOnceItems;
            for (var i = 0; i < elementBox.errorCollection.length; i++) {
                errorCollection.push(elementBox.errorCollection[i]);
            }
            for (var j = 0; j < elementBox.errorCollection.length; j++) {
                var index = elementBox.text.indexOf(elementBox.errorCollection[j].text);
                var textElement = elementBox.errorCollection[j];
                if (index < 0) {
                    errorCollection.splice(0, 1);
                    splittedBox.errorCollection.push(textElement);
                }
                else if (splittedBox.text.indexOf(textElement.text) > 0) {
                    splittedBox.errorCollection.push(textElement);
                }
            }
            splittedBox.ignoreOnceItems = ignoreItems;
            elementBox.ignoreOnceItems = [];
            elementBox.errorCollection = errorCollection;
        }
    };
    /**
     * Splits by character.
     * @param textElement
     * @param text
     * @param width
     * @param characterFormat
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.splitByCharacter = function (lineWidget, textElement, text, width, characterFormat) {
        var paragraph = lineWidget.paragraph;
        // tslint:disable-next-line:max-line-length
        var index = this.getTextSplitIndexByCharacter(this.viewer.clientArea.width, this.viewer.clientActiveArea.width, text, width, characterFormat);
        var splitWidth = 0;
        if (index < textElement.length) {
            splitWidth = this.viewer.textHelper.measureTextExcludingSpaceAtEnd(text.substring(0, index), characterFormat);
            text = text.substring(index);
        }
        if (splitWidth > this.viewer.clientActiveArea.width && textElement.indexInOwner > 0) {
            this.addSplittedLineWidget(lineWidget, textElement.indexInOwner - 1);
            return;
        }
        var indexOf = lineWidget.children.indexOf(textElement);
        if (index < textElement.length) {
            var lineIndex = paragraph.childWidgets.indexOf(lineWidget);
            var splittedElement = new TextElementBox();
            splittedElement.text = text;
            splittedElement.errorCollection = textElement.errorCollection;
            textElement.text = textElement.text.substr(0, index);
            splittedElement.characterFormat.copyFormat(textElement.characterFormat);
            splittedElement.width = this.viewer.textHelper.getWidth(splittedElement.text, characterFormat);
            textElement.width -= splittedElement.width;
            splittedElement.height = textElement.height;
            splittedElement.baselineOffset = textElement.baselineOffset;
            lineWidget.children.splice(textElement.indexInOwner + 1, 0, splittedElement);
            this.addSplittedLineWidget(lineWidget, indexOf);
            this.addElementToLine(paragraph, textElement);
            if (textElement.width === 0) {
                lineWidget.children.splice(indexOf, 1);
            }
        }
        else {
            //Adds the last text element on inline to line elements collection. 
            this.addSplittedLineWidget(lineWidget, indexOf);
            this.addElementToLine(paragraph, textElement);
        }
    };
    /**
     * Splits text element word by word.
     * @param textElement
     */
    Layout.prototype.splitTextElementWordByWord = function (textElement) {
        var lineWidget = textElement.line;
        var indexOf = lineWidget.children.indexOf(textElement);
        var text = textElement.text;
        var format;
        var characterUptoWs = text.trim().indexOf(' ');
        if (characterUptoWs >= 0) {
            lineWidget.children.splice(indexOf, 1);
            format = textElement.characterFormat;
            var fontSize = format.fontSize;
            var index = textElement.length - HelperMethods.trimStart(text).length; //Trim start
            while (index < textElement.length) {
                index = this.getTextIndexAfterSpace(text, index);
                if (index === 0 || index === textElement.length) {
                    break;
                }
                if (index < textElement.length) {
                    var splittedElement = new TextElementBox();
                    var splittedText = text.substring(0, index);
                    text = text.substring(index);
                    if (text.substring(0, 1) === ' ') {
                        // start of the text is trimmed and its length is reduced from text length.                        
                        index += text.length - HelperMethods.trimStart(text).length;
                    }
                    splittedElement.text = splittedText;
                    splittedElement.characterFormat.copyFormat(textElement.characterFormat);
                    splittedElement.line = lineWidget;
                    splittedElement.width = this.viewer.textHelper.getWidth(splittedElement.text, format);
                    splittedElement.height = textElement.height;
                    splittedElement.baselineOffset = textElement.baselineOffset;
                    lineWidget.children.splice(indexOf, 0, splittedElement);
                    textElement.text = text;
                    textElement.width -= splittedElement.width;
                    if (textElement.width === 0) {
                        lineWidget.children.splice(lineWidget.children.indexOf(textElement), 1);
                    }
                    index = 0;
                    indexOf++;
                }
            }
            textElement.text = text;
            lineWidget.children.splice(indexOf, 0, textElement);
        }
    };
    /**
     * Splits text for client area.
     * @param element
     * @param text
     * @param width
     * @param characterFormat
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.splitTextForClientArea = function (lineWidget, element, text, width, characterFormat) {
        var paragraph = lineWidget.paragraph;
        var isSplitByWord = true;
        var index = -1;
        if (!(text.substring(0, 1) === ' ')) {
            var textWidth = width;
            var characterUptoWS = 0;
            characterUptoWS = HelperMethods.trimEnd(text).indexOf(' ') + 1;
            index = characterUptoWS;
            //Checks whether text not starts with white space. If starts with white space, no need to check previous text blocks.
            if (index > 0) {
                textWidth = this.viewer.textHelper.measureTextExcludingSpaceAtEnd(text.slice(0, index), characterFormat);
            }
            if (this.viewer.clientActiveArea.width < textWidth) {
                //Check and split the previous text elements to next line.            
                isSplitByWord = this.checkPreviousElement(lineWidget, lineWidget.children.indexOf(element), characterFormat);
                if (isSplitByWord) {
                    //lineWidget = paragraph.childWidgets[paragraph.childWidgets.indexOf(lineWidget) + 1] as LineWidget;
                    //isSplitByWord = textWidth <= this.viewer.clientActiveArea.width;
                    return;
                }
            }
        }
        else {
            index = 1;
        }
        if (width <= this.viewer.clientActiveArea.width) {
            //Fits the text in current line.
            this.addElementToLine(paragraph, element);
        }
        else if (isSplitByWord && (index > 0 || text.indexOf(' ') !== -1)) {
            this.splitByWord(lineWidget, paragraph, element, text, width, characterFormat);
        }
        else {
            this.splitByCharacter(lineWidget, element, text, width, characterFormat);
        }
    };
    /**
     * Handle tab or line break character splitting
     * @param  {LayoutViewer} viewer
     * @param  {TextElementBox} span
     * @param  {number} index
     * @param  {string} spiltBy
     * @private
     */
    Layout.prototype.splitByLineBreakOrTab = function (viewer, span, index, spiltBy) {
        // Splits tab character to separate SpanAdv
        var inlineIndex = span.line.children.indexOf(span);
        var value = span.text;
        var remainder = value.substring(index);
        var newSpan = spiltBy === '\t' ? new TabElementBox() : new TextElementBox();
        newSpan.line = span.line;
        newSpan.characterFormat.copyFormat(span.characterFormat);
        span.line.children.splice(inlineIndex + 1, 0, newSpan);
        if (index > 0 && remainder.length === 1) {
            newSpan.text = value.substring(index);
            span.text = value.substring(0, index);
        }
        else if (index > 0) {
            newSpan.text = spiltBy;
            var newText = new TextElementBox();
            newText.line = span.line;
            newText.text = value.substring(index + 1);
            newText.characterFormat.copyFormat(span.characterFormat);
            span.line.children.splice(inlineIndex + 2, 0, newText);
            span.text = value.substring(0, index);
        }
        else if (remainder !== '') {
            newSpan.text = value.substring(index + 1);
            span.text = spiltBy;
        }
    };
    /**
     * Moves to next line.
     */
    Layout.prototype.moveToNextLine = function (line) {
        var paragraph = line.paragraph;
        var paraFormat = paragraph.paragraphFormat;
        var isParagraphStart = line.isFirstLine();
        var isParagraphEnd = line.isLastLine();
        var height = 0;
        var maxDescent = 0;
        var afterSpacing = 0;
        var beforeSpacing = 0;
        var lineSpacing = 0;
        var firstLineIndent = 0;
        this.updateLineWidget(line);
        height = this.maxTextHeight;
        maxDescent = height - this.maxTextBaseline;
        //Updates before spacing at the top of Paragraph first line.
        if (isParagraphStart) {
            beforeSpacing = this.getBeforeSpacing(paragraph);
            firstLineIndent = HelperMethods.convertPointToPixel(paraFormat.firstLineIndent);
        }
        //Updates after spacing at the bottom of Paragraph last line.
        if (isParagraphEnd) {
            afterSpacing = HelperMethods.convertPointToPixel(this.getAfterSpacing(paragraph));
        }
        if (!this.isBidiReLayout && (paraFormat.bidi || this.isContainsRtl(line))) {
            this.reArrangeElementsForRtl(line, paraFormat.bidi);
            this.isRTLLayout = true;
        }
        if (isNaN(this.maxTextHeight)) {
            //Calculate line height and descent based on formatting defined in paragraph.
            var measurement = this.viewer.textHelper.measureText('a', paragraph.characterFormat);
            height = measurement.Height;
            maxDescent = height - measurement.BaselineOffset;
        }
        else {
            height = this.maxTextHeight;
            maxDescent = height - this.maxTextBaseline;
        }
        // Gets line spacing.
        lineSpacing = this.getLineSpacing(paragraph, height);
        if (paraFormat.lineSpacingType === 'Exactly'
            && lineSpacing < maxDescent + this.maxBaseline) {
            lineSpacing = maxDescent + this.maxBaseline;
        }
        var subWidth = 0;
        var whiteSpaceCount = 0;
        var textAlignment = paraFormat.textAlignment;
        // calculates the sub width, for text alignments - Center, Right, Justify.
        // if the element is paragraph end and para bidi is true and text alignment is justify
        // we need to calculate subwidth and add it to the left margin of the element.
        if (textAlignment !== 'Left' && this.viewer.textWrap && (!(textAlignment === 'Justify' && isParagraphEnd)
            || (textAlignment === 'Justify' && paraFormat.bidi))) {
            // tslint:disable-next-line:max-line-length
            var getWidthAndSpace = this.getSubWidth(line, textAlignment === 'Justify', whiteSpaceCount, firstLineIndent, isParagraphEnd);
            subWidth = getWidthAndSpace.subWidth;
            whiteSpaceCount = getWidthAndSpace.spaceCount;
        }
        var addSubWidth = false;
        var lineSpacingType = paraFormat.lineSpacingType;
        for (var i = 0; i < line.children.length; i++) {
            var topMargin = 0;
            var bottomMargin = 0;
            var leftMargin = 0;
            var elementBox = line.children[i];
            // tslint:disable-next-line:max-line-length
            var alignElements = this.alignLineElements(elementBox, topMargin, bottomMargin, maxDescent, addSubWidth, subWidth, textAlignment, whiteSpaceCount, i === line.children.length - 1);
            topMargin = alignElements.topMargin;
            bottomMargin = alignElements.bottomMargin;
            addSubWidth = alignElements.addSubWidth;
            whiteSpaceCount = alignElements.whiteSpaceCount;
            //Updates line spacing, paragraph after/ before spacing and aligns the text to base line offset.
            if (lineSpacingType === 'Multiple') {
                if (lineSpacing > height) {
                    bottomMargin += lineSpacing - height;
                }
                else {
                    topMargin += lineSpacing - height;
                }
            }
            else if (lineSpacingType === 'Exactly') {
                topMargin += lineSpacing - (topMargin + elementBox.height + bottomMargin);
            }
            else if (lineSpacing > topMargin + elementBox.height + bottomMargin) {
                topMargin += lineSpacing - (topMargin + elementBox.height + bottomMargin);
            }
            topMargin += beforeSpacing;
            bottomMargin += afterSpacing;
            if (i === 0) {
                line.height = topMargin + elementBox.height + bottomMargin;
                if (textAlignment === 'Right' || (textAlignment === 'Justify' && paraFormat.bidi && isParagraphEnd)) {
                    //Aligns the text as right justified and consider subwidth for bidirectional paragrph with justify.
                    leftMargin = subWidth;
                }
                else if (textAlignment === 'Center') {
                    //Aligns the text as center justified.
                    leftMargin = subWidth / 2;
                }
            }
            elementBox.margin = new Margin(leftMargin, topMargin, 0, bottomMargin);
            elementBox.line = line;
        }
        this.viewer.cutFromTop(this.viewer.clientActiveArea.y + line.height);
    };
    Layout.prototype.updateLineWidget = function (line) {
        for (var i = 0; i < line.children.length; i++) {
            var element = line.children[i];
            if (element instanceof TextElementBox || element instanceof ListTextElementBox) {
                if (this.maxTextHeight < element.height) {
                    this.maxTextHeight = element.height;
                    this.maxTextBaseline = element.baselineOffset;
                }
                if (this.maxBaseline < this.maxTextBaseline) {
                    this.maxBaseline = this.maxTextBaseline;
                }
            }
            else if (this.maxBaseline < element.height) {
                this.maxBaseline = element.height;
            }
        }
    };
    /**
     * @param viewer
     */
    Layout.prototype.moveToNextPage = function (viewer, line, isPageBreak) {
        var paragraphWidget = line.paragraph;
        var index = 0;
        if (!isNullOrUndefined(line)) {
            index = paragraphWidget.childWidgets.indexOf(line);
            if (index > 0 || isPageBreak) {
                paragraphWidget.height = viewer.clientActiveArea.y - paragraphWidget.y;
            }
        }
        var nextBody = this.moveBlocksToNextPage(paragraphWidget);
        this.viewer.updateClientArea(nextBody.sectionFormat, nextBody.page);
        this.viewer.updateClientAreaForBlock(paragraphWidget, true);
        if (index > 0) {
            if (line.isLastLine() && isPageBreak) {
                return;
            }
            var nextParagraph = void 0;
            if (nextBody.firstChild instanceof ParagraphWidget && nextBody.firstChild.equals(paragraphWidget)) {
                nextParagraph = nextBody.firstChild;
            }
            else {
                nextParagraph = new ParagraphWidget();
            }
            nextParagraph = this.addParagraphWidget(this.viewer.clientActiveArea, nextParagraph);
            nextParagraph.index = paragraphWidget.index;
            var insertIndex = 0;
            for (var i = index; i < paragraphWidget.childWidgets.length; i++) {
                var lineWidget = paragraphWidget.childWidgets[i];
                lineWidget.paragraph = nextParagraph;
                nextParagraph.childWidgets.splice(insertIndex, 0, lineWidget);
                lineWidget.paragraph = nextParagraph;
                insertIndex++;
            }
            nextParagraph.paragraphFormat = paragraphWidget.paragraphFormat;
            nextParagraph.characterFormat = paragraphWidget.characterFormat;
            paragraphWidget.childWidgets.splice(index);
            paragraphWidget = nextParagraph;
        }
        else if (!isPageBreak) {
            paragraphWidget.containerWidget.removeChild(paragraphWidget.indexInOwner);
        }
        if (!isPageBreak) {
            if (nextBody.childWidgets.indexOf(paragraphWidget) === -1) {
                nextBody.childWidgets.splice(0, 0, paragraphWidget);
            }
            paragraphWidget.containerWidget = nextBody;
            this.viewer.updateClientAreaLocation(paragraphWidget, this.viewer.clientActiveArea);
            if (index === 0) {
                var firstLineIndent = -HelperMethods.convertPointToPixel(paragraphWidget.paragraphFormat.firstLineIndent);
                this.viewer.updateClientWidth(firstLineIndent);
            }
        }
    };
    /**
     * Aligns line elements
     * @param element
     * @param topMargin
     * @param bottomMargin
     * @param maxDescent
     * @param addSubWidth
     * @param subWidth
     * @param textAlignment
     * @param whiteSpaceCount
     * @param isLastElement
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.alignLineElements = function (element, topMargin, bottomMargin, maxDescent, addSubWidth, subWidth, textAlignment, whiteSpaceCount, isLastElement) {
        if (element instanceof TextElementBox || element instanceof ListTextElementBox) {
            var textElement = element instanceof TextElementBox ? element : undefined;
            //Updates the text to base line offset.
            // tslint:disable-next-line:max-line-length
            var baselineOffset = element instanceof TextElementBox ? textElement.baselineOffset : element.baselineOffset;
            topMargin += this.maxBaseline - baselineOffset;
            bottomMargin += maxDescent - (element.height - baselineOffset);
            //Updates the text to base line offset.
            if (!isNullOrUndefined(textElement) && textAlignment === 'Justify' && whiteSpaceCount > 0) {
                //Aligns the text as Justified.
                var width = textElement.width;
                var text = textElement.text;
                if (!addSubWidth) {
                    text = HelperMethods.trimStart(text); // trim start
                    addSubWidth = (text.length > 0);
                }
                if (addSubWidth) {
                    var spaceCount = text.length - HelperMethods.removeSpace(text).length;
                    if (isLastElement) {
                        spaceCount -= text.length - HelperMethods.trimEnd(text).length;
                    }
                    if (whiteSpaceCount < spaceCount) {
                        width = this.viewer.textHelper.measureTextExcludingSpaceAtEnd(text, textElement.characterFormat);
                        spaceCount = whiteSpaceCount;
                    }
                    if (spaceCount > 0) {
                        textElement.width = width + subWidth * spaceCount;
                        whiteSpaceCount -= spaceCount;
                    }
                }
            }
        }
        else {
            addSubWidth = true;
            //Updates the Image/UIElement to base line offset.
            topMargin += this.maxBaseline - element.height;
            bottomMargin += maxDescent;
        }
        return { 'topMargin': topMargin, 'bottomMargin': bottomMargin, 'addSubWidth': addSubWidth, 'whiteSpaceCount': whiteSpaceCount };
    };
    /**
     * Updates widget to page.
     * @param viewer
     * @param block
     * @private
     */
    Layout.prototype.updateWidgetToPage = function (viewer, paragraphWidget) {
        if (paragraphWidget.isInsideTable) {
            var cellWidget = paragraphWidget.associatedCell;
            paragraphWidget.height = viewer.clientActiveArea.y - paragraphWidget.y;
            // if (viewer instanceof PageLayoutViewer) {
            if (isNullOrUndefined(paragraphWidget.associatedCell) || isNullOrUndefined(paragraphWidget.associatedCell.ownerRow)
                || isNullOrUndefined(paragraphWidget.associatedCell.ownerRow.rowFormat)) {
                return;
            }
            if (paragraphWidget.associatedCell.ownerRow.rowFormat.heightType === 'Exactly') {
                cellWidget.height = HelperMethods.convertPointToPixel(paragraphWidget.associatedCell.ownerRow.rowFormat.height);
            }
            else {
                // tslint:disable-next-line:max-line-length
                if ([cellWidget].length <= 1 && paragraphWidget.associatedCell.ownerRow.rowFormat.heightType === 'AtLeast') {
                    cellWidget.height = Math.max(HelperMethods.convertPointToPixel(paragraphWidget.associatedCell.ownerRow.rowFormat.height), this.getCellContentHeight(cellWidget));
                }
                else {
                    cellWidget.height = cellWidget.height + paragraphWidget.height;
                }
            }
            // } else {
            //     cellWidget.height = cellWidget.height + paragraphWidget.height;
            // }
            // cellWidget.childWidgets.push(paragraphWidget);
            paragraphWidget.containerWidget = cellWidget;
        }
        else {
            if (!paragraphWidget.isEndsWithPageBreak) {
                paragraphWidget.height = viewer.clientActiveArea.y - paragraphWidget.y;
            }
            //Adds the paragraph widget to the Header Footer/ Body widget.
            // this.updateWidgetsToBody(paragraphWidget, viewer, paragraphWidget);
            //For canvas no need to render paragraph widget here. In case of div, need to render paragraph here.
            // tslint:disable-next-line:max-line-length             
            // this.render.renderParagraphWidget((paragraphWidget.containerWidget as BodyWidget).page, paragraphWidget);
        }
        if (paragraphWidget.bodyWidget instanceof HeaderFooterWidget) {
            if (!paragraphWidget.isInsideTable) {
                paragraphWidget.containerWidget.height += paragraphWidget.height;
            }
            if (this.viewer.owner.enableHeaderAndFooter && paragraphWidget.bodyWidget.headerFooterType.indexOf('Footer') !== -1) {
                this.shiftFooterChildLocation(paragraphWidget.bodyWidget, this.viewer);
            }
        }
    };
    /**
     * @private
     */
    Layout.prototype.shiftFooterChildLocation = function (widget, viewer) {
        var pageHeight = widget.page.bodyWidgets[0].sectionFormat.pageHeight;
        if (widget.headerFooterType.indexOf('Footer') !== -1) {
            var footerDistance = widget.page.bodyWidgets[0].sectionFormat.footerDistance;
            var height = HelperMethods.convertPointToPixel(pageHeight - footerDistance);
            var top_2;
            if (widget.y + widget.height > height) {
                top_2 = height - (widget.y + widget.height);
            }
            else if (widget.y + widget.height < height) {
                top_2 = (widget.y + widget.height) - height;
            }
            if (!isNullOrUndefined(top_2)) {
                top_2 = height - (widget.y + widget.height);
                this.shiftChildLocation(top_2, widget);
                viewer.clientActiveArea.y += top_2;
            }
        }
    };
    /**
     * Checks previous element.
     * @param characterFormat
     */
    Layout.prototype.checkPreviousElement = function (line, index, characterFormat) {
        var paragraph = line.paragraph;
        var isSplitByWord = false;
        var lastTextElement = 0;
        for (var i = index - 1; i >= 0; i--) {
            var textElement = line.children[i];
            if (textElement instanceof TextElementBox) {
                var text = textElement.text;
                lastTextElement = i;
                if (text.length > 0 && text[text.length - 1] === ' ') {
                    if (i === index - 1) {
                        this.addSplittedLineWidget(line, index - 1);
                        return true;
                    }
                    isSplitByWord = true;
                    break;
                }
                else if (text === '\t') {
                    return false;
                }
                else if (text.indexOf(' ') >= 0) {
                    isSplitByWord = true;
                    var index_1 = text.lastIndexOf(' ') + 1;
                    //Splits the text element by space.
                    var splittedElement = new TextElementBox();
                    splittedElement.text = text.substr(index_1);
                    splittedElement.characterFormat.copyFormat(textElement.characterFormat);
                    textElement.text = text.substr(0, index_1);
                    this.viewer.textHelper.getTextSize(splittedElement, characterFormat);
                    textElement.width -= splittedElement.width;
                    textElement.height = splittedElement.height;
                    if (textElement.width === 0) {
                        line.children.splice(i, 1);
                    }
                    //Adds the text element to the line
                    line.children.splice(i + 1, 0, splittedElement);
                    break;
                }
            }
            else if (!(textElement instanceof ListTextElementBox)) {
                //Handled for inline images/UIelements.
                lastTextElement = i;
                isSplitByWord = true;
                break;
            }
        }
        if (isSplitByWord) {
            lastTextElement++;
            if (lastTextElement < line.children.length) {
                var splitWidth = 0;
                for (var i = lastTextElement; i < line.children.length; i++) {
                    splitWidth += line.children[i].width;
                    this.addSplittedLineWidget(line, i - 1);
                    i--;
                }
                this.viewer.updateClientWidth(splitWidth);
            }
        }
        return isSplitByWord;
    };
    /**
     * @private
     */
    Layout.prototype.clearListElementBox = function (paragraph) {
        if (paragraph.childWidgets.length === 0) {
            return;
        }
        var line = paragraph.childWidgets[0];
        if (isNullOrUndefined(line.children)) {
            return;
        }
        for (var i = line.children.length - 1; i > 0; i--) {
            if (line.children[i] instanceof ListTextElementBox) {
                line.children.splice(i, 1);
            }
            else {
                break;
            }
        }
        for (var i = 0; i < line.children.length; i++) {
            if (line.children[i] instanceof ListTextElementBox) {
                line.children.splice(i, 1);
                i--;
            }
            else {
                break;
            }
        }
    };
    /**
     * Gets list number.
     * @param listFormat
     * @param document
     * @private
     */
    Layout.prototype.getListNumber = function (listFormat, isAutoList) {
        var list = this.viewer.getListById(listFormat.listId);
        var levelNumber = listFormat.listLevelNumber;
        var listLevel = this.getListLevel(list, listFormat.listLevelNumber);
        // tslint:disable-next-line:max-line-length
        var levelOverride = !isNullOrUndefined(list.levelOverrides) ? list.levelOverrides[levelNumber] : undefined;
        // If LevelOverride exists and have either override list level or StartAtOverride, then only list numbering will be restarted.
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(levelOverride) && this.viewer.renderedLevelOverrides.indexOf(levelOverride) === -1 && isNullOrUndefined(levelOverride.overrideListLevel)) {
            //Add List Override style
            this.viewer.renderedLevelOverrides.push(levelOverride);
            if (this.viewer.renderedLists.containsKey(this.viewer.getAbstractListById(list.abstractListId))) {
                // tslint:disable-next-line:max-line-length
                var levels = this.viewer.renderedLists.get(this.viewer.getAbstractListById(list.abstractListId));
                if (levels.containsKey(levelNumber)) {
                    levels.remove(levelNumber);
                }
            }
        }
        if (isNullOrUndefined(isAutoList)) {
            this.updateListValues(list, levelNumber);
        }
        return this.getListText(list, levelNumber, listLevel);
    };
    /**
     * Gets list start value
     * @param listLevelNumber
     * @param list
     * @private
     */
    Layout.prototype.getListStartValue = function (listLevelNumber, list) {
        // tslint:disable-next-line:max-line-length
        var levelOverride = !isNullOrUndefined(list.levelOverrides) ? list.levelOverrides[listLevelNumber] : undefined;
        if (!isNullOrUndefined(levelOverride) && isNullOrUndefined(levelOverride.overrideListLevel)) {
            return levelOverride.startAt;
        }
        var listLevel = this.getListLevel(list, listLevelNumber);
        if (isNullOrUndefined(listLevel)) {
            return 0;
        }
        else {
            return listLevel.startAt;
        }
    };
    /**
     * Updates list values.
     * @param list
     * @param listLevelNumber
     * @param document
     */
    Layout.prototype.updateListValues = function (list, listLevelNumber) {
        if (!this.viewer.renderedLists.containsKey(this.viewer.getAbstractListById(list.abstractListId))) {
            var startVal = new Dictionary();
            this.viewer.renderedLists.add(this.viewer.getAbstractListById(list.abstractListId), startVal);
            var listLevel = this.getListLevel(list, listLevelNumber);
            for (var i = 0; i <= listLevelNumber; i++) {
                startVal.add(i, this.getListStartValue(i, list));
            }
        }
        else {
            // tslint:disable-next-line:max-line-length
            var levels = this.viewer.renderedLists.get(this.viewer.getAbstractListById(list.abstractListId));
            if (levels.containsKey(listLevelNumber)) {
                var startAt = levels.get(listLevelNumber);
                levels.set(listLevelNumber, startAt + 1);
                var levelNumber = listLevelNumber + 1;
                while (levelNumber < this.viewer.getAbstractListById(list.abstractListId).levels.length) {
                    var listLevel = this.getListLevel(list, levelNumber);
                    // if (!isNullOrUndefined(listLevel)) {
                    if (levels.containsKey(levelNumber) && listLevel.restartLevel > listLevelNumber) {
                        levels.remove(levelNumber);
                        // if (document.renderedListLevels.indexOf(listLevel) > -1) {
                        //     document.renderedListLevels.pop();
                        // }
                    }
                    // }
                    levelNumber++;
                }
            }
            else {
                var levelNumber = listLevelNumber;
                while (!levels.containsKey(levelNumber - 1) && levelNumber > 0) {
                    var listLevel = this.getListLevel(list, levelNumber - 1);
                    // if (!isNullOrUndefined(listLevel)) {
                    levels.add(levelNumber - 1, this.getListStartValue(levelNumber - 1, list));
                    // if (document.renderedListLevels.indexOf(listLevel) !== -1) {
                    //     document.renderedListLevels.push(listLevel);
                    // }
                    // }
                    levelNumber--;
                }
                var startAt = this.getListStartValue(listLevelNumber, list);
                levels.add(listLevelNumber, startAt);
            }
        }
    };
    /**
     * Gets list text
     * @param listAdv
     * @param listLevelNumber
     * @param currentListLevel
     * @param document
     */
    Layout.prototype.getListText = function (listAdv, listLevelNumber, currentListLevel) {
        var listText = currentListLevel.numberFormat;
        // tslint:disable-next-line:max-line-length
        if (this.viewer.renderedLists.containsKey(this.viewer.getAbstractListById(listAdv.abstractListId))) {
            var levels = this.viewer.renderedLists.get(this.viewer.getAbstractListById(listAdv.abstractListId));
            var keys = levels.keys;
            for (var i = 0; i < keys.length; i++) {
                var levelNumber = keys[i];
                var levelKey = '%' + (levelNumber + 1).toString();
                var listLevel = this.getListLevel(listAdv, levelNumber);
                if (listText.match(levelKey)) {
                    if (levelNumber > listLevelNumber) {
                        return '';
                    }
                    else if (levels.containsKey(levelNumber) && !isNullOrUndefined(listLevel)) {
                        listText = listText.replace(levelKey, this.getListTextListLevel(listLevel, levels.get(levelNumber)));
                    }
                    else {
                        listText = listText.replace(levelKey, '0');
                    }
                }
            }
        }
        return listText;
    };
    /**
     * Gets the roman letter.
     * @param number
     * @private
     */
    Layout.prototype.getAsLetter = function (number) {
        // if (number <= 0) {
        //     return '';
        // }
        var quotient = number / 26;
        var remainder = number % 26;
        if (remainder === 0) {
            //If number denotes the factor of 26, then reduce quotient by 1 and set remainder as 26.
            remainder = 26;
            quotient--;
        }
        //Index of A char in the ASCII table.     
        var letter = String.fromCharCode(65 - 1 + remainder);
        var listValue = '';
        while (quotient >= 0) {
            listValue = listValue + letter.toString();
            quotient--;
        }
        return listValue;
    };
    /**
     * Gets list text using list level pattern.
     * @param listLevel
     * @param listValue
     * @private
     */
    Layout.prototype.getListTextListLevel = function (listLevel, listValue) {
        switch (listLevel.listLevelPattern) {
            case 'UpRoman':
                return this.getAsRoman(listValue).toUpperCase();
            case 'LowRoman':
                return this.getAsRoman(listValue).toLowerCase();
            case 'UpLetter':
                return this.getAsLetter(listValue).toUpperCase();
            case 'LowLetter':
                return this.getAsLetter(listValue).toLowerCase();
            case 'Arabic':
                return (listValue).toString();
            case 'LeadingZero':
                return this.getAsLeadingZero(listValue);
            case 'Number':
                return (listValue).toString();
            case 'OrdinalText':
                return (listValue).toString();
            case 'Ordinal':
                return (listValue).toString();
            case 'FarEast':
                return (listValue).toString();
            case 'Special':
                return (listValue).toString();
            default:
                return '';
        }
    };
    /**
     * Generate roman number for the specified number.
     * @param number
     * @param magnitude
     * @param letter
     */
    Layout.prototype.generateNumber = function (number, magnitude, letter) {
        var numberstring = '';
        while (number >= magnitude) {
            number -= magnitude;
            numberstring += letter;
            this.value = number;
        }
        return numberstring.toString();
    };
    /**
     * Gets list value prefixed with zero, if less than 10
     * @param listValue
     */
    Layout.prototype.getAsLeadingZero = function (listValue) {
        if (listValue < 10) {
            return '0' + listValue.toString();
        }
        else {
            return listValue.toString();
        }
    };
    /**
     * Gets the roman number
     * @param number
     * @private
     */
    Layout.prototype.getAsRoman = function (number) {
        var retval = '';
        this.value = number;
        retval += this.generateNumber(this.value, 1000, 'M');
        retval += this.generateNumber(this.value, 900, 'CM');
        retval += this.generateNumber(this.value, 500, 'D');
        retval += this.generateNumber(this.value, 400, 'CD');
        retval += this.generateNumber(this.value, 100, 'C');
        retval += this.generateNumber(this.value, 90, 'XC');
        retval += this.generateNumber(this.value, 50, 'L');
        retval += this.generateNumber(this.value, 40, 'XL');
        retval += this.generateNumber(this.value, 10, 'X');
        retval += this.generateNumber(this.value, 9, 'IX');
        retval += this.generateNumber(this.value, 5, 'V');
        retval += this.generateNumber(this.value, 4, 'IV');
        retval += this.generateNumber(this.value, 1, 'I');
        return retval.toString();
    };
    /**
     * Gets the list level
     * @param list
     * @param listLevelNumber
     * @private
     */
    Layout.prototype.getListLevel = function (list, listLevelNumber) {
        if (!isNullOrUndefined(list)) {
            var abstractList = this.viewer.getAbstractListById(list.abstractListId);
            if (!isNullOrUndefined(list) && abstractList.levels.length <= listLevelNumber
                && listLevelNumber >= 0 && listLevelNumber < 9) {
                this.addListLevels(abstractList);
            }
            var levelOverrideAdv = undefined;
            var level = false;
            level = (!isNullOrUndefined(list.levelOverrides))
                && !isNullOrUndefined(((levelOverrideAdv = list.levelOverrides[listLevelNumber])))
                && (!isNullOrUndefined(levelOverrideAdv.overrideListLevel));
            if (level) {
                return levelOverrideAdv.overrideListLevel;
            }
            else if (!isNullOrUndefined(abstractList) && listLevelNumber >= 0 && listLevelNumber < abstractList.levels.length) {
                return abstractList.levels[listLevelNumber];
            }
        }
        return undefined;
    };
    /**
     * Gets tab width
     * @param paragraph
     * @param viewer
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.getTabWidth = function (paragraph, viewer, index, lineWidget, element) {
        var elementWidth = element ? this.viewer.textHelper.getTextSize(element, element.characterFormat) : 0;
        var fPosition = 0;
        var isCustomTab = false;
        var tabs = paragraph.paragraphFormat.getUpdatedTabs();
        var isList = false;
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(paragraph.paragraphFormat.listFormat.listLevel) && !isNullOrUndefined(paragraph.paragraphFormat.listFormat.listLevel.paragraphFormat)) {
            var listFormat = paragraph.paragraphFormat.listFormat.listLevel.paragraphFormat;
            if (paragraph.paragraphFormat.leftIndent !== listFormat.leftIndent) {
                isList = true;
            }
        }
        var clientWidth = 0;
        var clientActiveX = viewer.clientActiveArea.x;
        var firstLineIndent = HelperMethods.convertPointToPixel(paragraph.paragraphFormat.firstLineIndent);
        if (!isNullOrUndefined(element) && lineWidget.isFirstLine()) {
            clientWidth = this.viewer.clientArea.x + firstLineIndent;
            clientActiveX = clientActiveX + firstLineIndent;
        }
        else {
            clientWidth = this.viewer.clientArea.x;
        }
        if (clientActiveX < clientWidth) {
            return viewer.clientArea.x - viewer.clientActiveArea.x;
        }
        // Calculates tabwidth based on pageleftmargin and defaulttabwidth property
        var leftIndent = HelperMethods.convertPointToPixel(paragraph.paragraphFormat.leftIndent);
        var position = viewer.clientActiveArea.x -
            (viewer.clientArea.x - HelperMethods.convertPointToPixel(paragraph.paragraphFormat.leftIndent));
        var defaultTabWidth = HelperMethods.convertPointToPixel(viewer.defaultTabWidth);
        if (tabs.length === 0) {
            if (position > 0 && defaultTabWidth > position && isList ||
                defaultTabWidth === this.defaultTabWidthPixel && defaultTabWidth > position) {
                return defaultTabWidth - position;
            }
            return defaultTabWidth;
        }
        else {
            if (tabs.length > 0) {
                for (var i = 0; i < tabs.length; i++) {
                    var tabStop = tabs[i];
                    var tabPosition = HelperMethods.convertPointToPixel(tabs[i].position);
                    if ((position + elementWidth) < tabPosition) {
                        isCustomTab = true;
                        if (tabStop.tabJustification === 'Left' || tabStop.tabJustification === 'List') {
                            fPosition = tabPosition;
                            if (element instanceof TabElementBox) {
                                element.tabLeader = tabs[i].tabLeader;
                                element.tabText = '';
                            }
                            break;
                        }
                        else {
                            var tabWidth = tabPosition - position;
                            var width = this.getRightTabWidth(element.indexInOwner + 1, lineWidget, paragraph);
                            if (width < tabWidth) {
                                if (tabStop.tabJustification === 'Right') {
                                    defaultTabWidth = tabWidth - width;
                                    var areaWidth = this.viewer.clientActiveArea.width - defaultTabWidth;
                                    if (areaWidth < 0) {
                                        defaultTabWidth += areaWidth - width;
                                    }
                                    else if (width > areaWidth) {
                                        defaultTabWidth -= width - areaWidth;
                                    }
                                }
                                else {
                                    defaultTabWidth = tabWidth - width / 2;
                                }
                            }
                            else if (tabStop.tabJustification === 'Center' && (width / 2) < tabWidth) {
                                defaultTabWidth = tabWidth - width / 2;
                            }
                            else {
                                defaultTabWidth = tabStop.tabJustification === 'Right' ? 0 : elementWidth;
                            }
                            fPosition = position;
                            if (element instanceof TabElementBox) {
                                element.tabLeader = tabs[i].tabLeader;
                                element.tabText = '';
                            }
                            break;
                        }
                    }
                }
            }
            if (!isCustomTab) {
                var diff = ((Math.round(position) * 100) % (Math.round(defaultTabWidth) * 100)) / 100;
                var cnt = (Math.round(position) - diff) / Math.round(defaultTabWidth);
                fPosition = (cnt + 1) * defaultTabWidth;
            }
            return (fPosition - position) > 0 ? fPosition - position : defaultTabWidth;
        }
    };
    /**
     * Returns the right tab width
     * @param index - index of starting inline
     * @param lineWidget - current line widget
     * @param paragraph - current paragraph widget
     */
    Layout.prototype.getRightTabWidth = function (index, lineWidget, paragraph) {
        var width = 0;
        var isFieldCode = false;
        var elementBox = lineWidget.children[index];
        while (elementBox) {
            if ((elementBox instanceof FieldElementBox) || (elementBox instanceof BookmarkElementBox) || isFieldCode) {
                if (elementBox instanceof FieldElementBox) {
                    if (elementBox.fieldType === 0) {
                        isFieldCode = true;
                    }
                    else if (elementBox.fieldType === 2) {
                        isFieldCode = false;
                    }
                }
                elementBox.width = 0;
            }
            else {
                if (elementBox instanceof TextElementBox) {
                    this.viewer.textHelper.getTextSize(elementBox, elementBox.characterFormat);
                }
            }
            if (elementBox instanceof TextElementBox && elementBox.text === '\t') {
                return width;
            }
            else {
                width = width + elementBox.width;
            }
            elementBox = elementBox.nextNode;
        }
        return width;
    };
    /**
     * Gets split index by word.
     * @param clientActiveWidth
     * @param text
     * @param width
     * @param characterFormat
     */
    Layout.prototype.getSplitIndexByWord = function (clientActiveWidth, text, width, characterFormat) {
        var index = 0;
        var length = text.length;
        while (index < length) {
            var nextIndex = this.getTextIndexAfterSpace(text, index);
            if (nextIndex === 0 || nextIndex === length) {
                nextIndex = length - 1;
            }
            var splitWidth = width;
            if ((nextIndex < length - 1 || (nextIndex === length - 1 && text[nextIndex - 1] === ' ')) && index !== nextIndex) {
                splitWidth = this.viewer.textHelper.measureTextExcludingSpaceAtEnd(text.slice(0, nextIndex), characterFormat);
            }
            if (splitWidth <= clientActiveWidth) {
                index = nextIndex;
            }
            else {
                if (index === 0 && text[0] === ' ') {
                    index = this.getTextIndexAfterSpace(text, 0);
                }
                break;
            }
        }
        return index;
    };
    /**
     * Gets split index by character
     * @param totalClientWidth
     * @param clientActiveAreaWidth
     * @param text
     * @param width
     * @param characterFormat
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.getTextSplitIndexByCharacter = function (totalClientWidth, clientActiveAreaWidth, text, width, characterFormat) {
        var length = text.length;
        for (var i = 0; i < length; i++) {
            var splitWidth = width;
            if (i + 1 < length) {
                splitWidth = this.viewer.textHelper.measureTextExcludingSpaceAtEnd(text.substring(0, i + 1), characterFormat);
            }
            if (splitWidth > clientActiveAreaWidth) {
                if (i === 0 && splitWidth > totalClientWidth) {
                    //Handle for cell/section having client width less than a character's width.
                    return (length > 1 && text[1] === ' ') ? this.getTextIndexAfterSpace(text, 1) : 1;
                }
                return i;
            }
        }
        return 0;
    };
    /**
     * Gets sub width.
     * @param justify
     * @param spaceCount
     * @param firstLineIndent
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.getSubWidth = function (lineWidget, justify, spaceCount, firstLineIndent, isParagraphEnd) {
        var width = 0;
        var trimSpace = true;
        var lineText = '';
        for (var i = lineWidget.children.length - 1; i >= 0; i--) {
            var element = lineWidget.children[i];
            if (element instanceof TextElementBox) {
                var elementText = element.text;
                lineText = elementText + lineText;
                if (trimSpace && (elementText.trim() !== '' || elementText === '\t')) {
                    if (HelperMethods.endsWith(elementText)) {
                        width += this.viewer.textHelper.measureTextExcludingSpaceAtEnd(elementText, element.characterFormat);
                    }
                    else {
                        width += element.width;
                    }
                    trimSpace = false;
                }
                else if (!trimSpace) {
                    width += element.width;
                }
            }
            else {
                lineText = 'a' + lineText;
                trimSpace = false;
                width += element.width;
            }
            if (!justify) {
                width = Math.round(width);
            }
        }
        lineText = lineText.trim();
        spaceCount = lineText.length - HelperMethods.removeSpace(lineText).length;
        var subWidth = (this.viewer.clientArea.width - firstLineIndent - width);
        if (subWidth <= 0 || (spaceCount === 0 && justify && !lineWidget.paragraph.paragraphFormat.bidi)) {
            spaceCount = 0;
            subWidth = 0;
        }
        else if (justify) {
            // For justify alignment, element width will be updated based space count value.
            // So when the element is paragraph end, need to set space count to zero.
            if (!isParagraphEnd && spaceCount > 0) {
                subWidth = subWidth / spaceCount;
            }
            else {
                spaceCount = 0;
            }
        }
        return { 'subWidth': subWidth, 'spaceCount': spaceCount };
    };
    /**
     * Gets before spacing.
     * @param paragraph
     * @private
     */
    Layout.prototype.getBeforeSpacing = function (paragraph) {
        var beforeSpacing = 0;
        if (paragraph.previousWidget instanceof ParagraphWidget) {
            var afterSpacing = this.getAfterSpacing(paragraph.previousWidget);
            if (afterSpacing < paragraph.paragraphFormat.beforeSpacing) {
                // tslint:disable-next-line:max-line-length
                beforeSpacing = paragraph.paragraphFormat.beforeSpacing - afterSpacing;
            }
        }
        else {
            beforeSpacing = paragraph.paragraphFormat.beforeSpacing;
        }
        if (this.isSameStyle(paragraph, false)) {
            return 0;
        }
        else {
            return beforeSpacing;
        }
    };
    Layout.prototype.getAfterSpacing = function (paragraph) {
        var afterSpacing = paragraph.paragraphFormat.afterSpacing;
        if (this.isSameStyle(paragraph, true)) {
            return 0;
        }
        else {
            return afterSpacing;
        }
    };
    /**
     * Gets line spacing.
     * @param paragraph
     * @param maxHeight
     * @private
     */
    Layout.prototype.getLineSpacing = function (paragraph, maxHeight) {
        if (isNullOrUndefined(paragraph.paragraphFormat)) {
            return 0;
        }
        var lineSpacing = 0;
        switch (paragraph.paragraphFormat.lineSpacingType) {
            case 'AtLeast':
            case 'Exactly':
                lineSpacing = paragraph.paragraphFormat.lineSpacing;
                break;
            default:
                lineSpacing = paragraph.paragraphFormat.lineSpacing * maxHeight;
                break;
        }
        return lineSpacing;
    };
    /**
     * Checks whether current line is first line in a paragraph.
     * @param paragraph
     */
    Layout.prototype.isParagraphFirstLine = function (paragraph, line) {
        var widget = paragraph;
        if (isNullOrUndefined(widget.childWidgets) || widget.childWidgets.indexOf(line) === 0) {
            //If the line elements conatins the elements from previous paragraph then need to retun false.
            //Example scenario, Field start and field end in different paragraphs.
            if (line.children.length > 0 && !isNullOrUndefined(paragraph.previousWidget)
                && paragraph.previousWidget instanceof ParagraphWidget) {
                return line.paragraph.index !== paragraph.previousWidget.index;
            }
            return true; //If the line elements count is zero then also need to return true.
        }
        return false;
    };
    /**
     * Checks whether current line is last line in a paragraph.
     * @param paragraph
     */
    Layout.prototype.isParagraphLastLine = function (element) {
        var paragraph = element.line.paragraph;
        var lastLineWidget = paragraph.childWidgets[paragraph.childWidgets.length - 1];
        var lastInline = lastLineWidget.children[lastLineWidget.children.length - 1];
        if (element === lastInline) {
            // tslint:disable-next-line:max-line-length            
            return (lastInline instanceof FieldElementBox) || ((!(lastInline instanceof TextElementBox && lastInline.text === '\v')));
        }
        return false;
    };
    /**
     * Gets text index after space.
     * @param text
     * @param startIndex
     */
    Layout.prototype.getTextIndexAfterSpace = function (text, startIndex) {
        var length = text.length;
        var index = 0;
        index = text.indexOf(' ', startIndex) + 1;
        var nextIndex = index;
        if (nextIndex === 0 || nextIndex === length) {
            return nextIndex;
        }
        while (text[nextIndex] === ' ') {
            nextIndex++;
            if (nextIndex === length) {
                break;
            }
        }
        return nextIndex;
    };
    //#region Table
    /**
     * @private
     */
    Layout.prototype.moveNextWidgetsToTable = function (tableWidget, rowWidgets, moveFromNext) {
        var currentRow = moveFromNext ? rowWidgets[rowWidgets.length - 2] : rowWidgets[rowWidgets.length - 1];
        var rowIndex = currentRow.indexInOwner;
        var currentTable = tableWidget[tableWidget.length - 1];
        if (moveFromNext) {
            rowIndex += 1;
        }
        var nextWidgets = currentRow.containerWidget.childWidgets.splice(rowIndex);
        for (var i = 0; i < nextWidgets.length; i++) {
            currentTable.childWidgets.push(nextWidgets[i]);
            nextWidgets[i].containerWidget = currentTable;
        }
    };
    /**
     * Adds table cell widget.
     * @param cell
     * @param area
     * @param maxCellMarginTop
     * @param maxCellMarginBottom
     */
    Layout.prototype.addTableCellWidget = function (cell, area, maxCellMarginTop, maxCellMarginBottom) {
        //let tableCellWidget: TableCellWidget = new TableCellWidget(cell);
        var prevColumnIndex = 0;
        var cellspace = 0;
        var left = 0;
        var top = maxCellMarginTop;
        var right = 0;
        var bottom = maxCellMarginBottom;
        if (!isNullOrUndefined(cell.cellFormat)) {
            if (cell.cellFormat.containsMargins()) {
                // tslint:disable-next-line:max-line-length
                left = isNullOrUndefined(cell.cellFormat.leftMargin) ? HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.leftMargin) : HelperMethods.convertPointToPixel(cell.cellFormat.leftMargin);
                right = isNullOrUndefined(cell.cellFormat.rightMargin) ? HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.rightMargin) : HelperMethods.convertPointToPixel(cell.cellFormat.rightMargin);
            }
            else {
                if (cell.columnIndex === 0 && cell.ownerRow.rowFormat.hasValue('leftMargin')) {
                    left = HelperMethods.convertPointToPixel(cell.ownerRow.rowFormat.leftMargin);
                }
                else {
                    left = HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.leftMargin);
                }
                if (cell.columnIndex === cell.ownerTable.tableHolder.columns.length - 1 &&
                    cell.ownerRow.rowFormat.hasValue('rightMargin')) {
                    right = HelperMethods.convertPointToPixel(cell.ownerRow.rowFormat.rightMargin);
                }
                else {
                    right = HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.rightMargin);
                }
            }
        }
        cell.margin = new Margin(left, top, right, bottom);
        cell.width = HelperMethods.convertPointToPixel(cell.cellFormat.cellWidth);
        if (!isNullOrUndefined(cell.previousWidget)) {
            // tslint:disable-next-line:max-line-length
            prevColumnIndex = cell.previousWidget.columnIndex + cell.previousWidget.cellFormat.columnSpan;
        }
        // tslint:disable-next-line:max-line-length
        cellspace = !isNullOrUndefined(cell.ownerTable) && !isNullOrUndefined(cell.ownerTable.tableFormat) ? HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.cellSpacing) : 0;
        var prevSpannedCellWidth = 0;
        if (prevColumnIndex < cell.columnIndex) {
            // tslint:disable-next-line:max-line-length
            prevSpannedCellWidth = HelperMethods.convertPointToPixel(cell.ownerTable.tableHolder.getPreviousSpannedCellWidth(prevColumnIndex, cell.columnIndex));
            if (prevColumnIndex === 0) {
                prevSpannedCellWidth = prevSpannedCellWidth - cellspace / 2;
            }
        }
        cell.x = area.x + prevSpannedCellWidth + cell.margin.left;
        cell.y = area.y + cell.margin.top + cellspace;
        cell.width = cell.width - cell.margin.left - cell.margin.right;
        if (cellspace > 0) {
            cell.x += cellspace;
            if (cell.ownerTable.tableHolder.columns.length === 1) {
                cell.width -= cellspace * 2;
            }
            else if (cell.columnIndex === 0 || cell.columnIndex === cell.ownerTable.tableHolder.columns.length - 1) {
                cell.width -= ((cellspace * 2) - cellspace / 2);
            }
            else {
                cell.width -= cellspace;
            }
        }
        var leftBorderWidth = HelperMethods.convertPointToPixel(TableCellWidget.getCellLeftBorder(cell).getLineWidth());
        var rightBorderWidth = HelperMethods.convertPointToPixel(TableCellWidget.getCellRightBorder(cell).getLineWidth());
        // update the margins values respect to layouting of borders.
        // for normal table cells only left border is rendred. for last cell left and right border is rendred.
        // this border widths are not included in margins.
        cell.leftBorderWidth = !cell.ownerTable.isBidiTable ? leftBorderWidth : rightBorderWidth;
        var isLeftStyleNone = (cell.cellFormat.borders.left.lineStyle === 'None');
        var isRightStyleNone = (cell.cellFormat.borders.right.lineStyle === 'None');
        cell.x += (!isLeftStyleNone) ? 0 : (cell.leftBorderWidth > 0) ? 0 : cell.leftBorderWidth;
        cell.width -= (!isLeftStyleNone) ? 0 : (cell.leftBorderWidth > 0) ? 0 : cell.leftBorderWidth;
        var lastCell = !cell.ownerTable.isBidiTable ? cell.cellIndex === cell.ownerRow.childWidgets.length - 1
            : cell.cellIndex === 0;
        if (cellspace > 0 || cell.cellIndex === cell.ownerRow.childWidgets.length - 1) {
            cell.rightBorderWidth = !cell.ownerTable.isBidiTable ? rightBorderWidth : leftBorderWidth;
            if (!cell.ownerTable.tableFormat.allowAutoFit) {
                cell.width -= cell.rightBorderWidth;
            }
        }
        //Add the border widths to respective margin side.
        cell.margin.left += (isLeftStyleNone) ? 0 : (cell.leftBorderWidth);
        cell.margin.right += (isRightStyleNone) ? 0 : (cell.rightBorderWidth);
        //cell.ownerWidget = owner;
        return cell;
    };
    /**
     * Adds specified row widget to table.
     * @param viewer
     * @param tableRowWidget
     * @param row
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.addWidgetToTable = function (viewer, tableCollection, rowCollection, row, endRowWidget, isInitialLayout) {
        //Adds table row widget to owner table widget.
        var tableWidget = tableCollection[0];
        var index = tableWidget.childWidgets.length;
        var prevWidget = undefined;
        var rowWidgetIndex = rowCollection.indexOf(row);
        if (rowWidgetIndex > 0) {
            prevWidget = rowCollection[rowWidgetIndex - 1];
            // Need to update on this further
        }
        else if (row.previousRenderedWidget instanceof TableRowWidget &&
            row.previousRenderedWidget.ownerTable.equals(row.ownerTable)) {
            // Need to update on this further
            prevWidget = row.previousRenderedWidget;
        }
        if (!isNullOrUndefined(prevWidget)) {
            tableWidget = prevWidget.containerWidget;
            // index = tableWidget.childWidgets.length;
            index = tableWidget.childWidgets.indexOf(prevWidget) + 1;
            if (Math.round(row.y) !== Math.round(prevWidget.y + prevWidget.height)) {
                var prevIndex = tableCollection.indexOf(tableWidget);
                if (prevIndex + 1 >= tableCollection.length) {
                    //Creates new table widget for splitted rows.
                    this.addTableWidget(viewer.clientActiveArea, tableCollection, true);
                }
                tableWidget = tableCollection[prevIndex + 1];
                index = tableWidget.childWidgets.length;
            }
            if (rowWidgetIndex > 0) {
                index = 0;
            }
        }
        this.updateRowHeightBySpannedCell(tableWidget, row, index);
        this.updateRowHeightByCellSpacing(tableCollection, row, viewer);
        //Remove widget from previous container after splitteing
        if (row.containerWidget && row.containerWidget !== tableWidget &&
            row.containerWidget.childWidgets.indexOf(row) !== -1) {
            row.containerWidget.childWidgets.splice(row.containerWidget.childWidgets.indexOf(row), 1);
        }
        if (tableWidget.childWidgets.indexOf(row) === -1) {
            tableWidget.childWidgets.splice(index, 0, row);
        }
        row.containerWidget = tableWidget;
        tableWidget.height = tableWidget.height + row.height;
        // Shift the widgets for Right to left directed table.
        if (tableWidget.isBidiTable) {
            row.shiftWidgetForRtlTable(this.viewer.clientArea, tableWidget, row);
        }
        if (!isNullOrUndefined(tableWidget.containerWidget)
            && tableWidget.containerWidget.childWidgets.indexOf(tableWidget) >= 0 &&
            !(tableWidget.containerWidget instanceof HeaderFooterWidget)) {
            tableWidget.containerWidget.height += row.height;
        }
        this.updateHeightForRowWidget(viewer, false, tableCollection, rowCollection, row, false, endRowWidget, isInitialLayout);
        viewer.cutFromTop(row.y + row.height);
    };
    /**
     * Updates row height by spanned cell.
     * @param tableWidget
     * @param rowWidget
     * @param insertIndex
     * @param row
     * @private
     */
    Layout.prototype.updateRowHeightBySpannedCell = function (tableWidget, row, insertIndex) {
        var rowSpan = 1;
        if (tableWidget.childWidgets.length === 0 || insertIndex === 0) {
            this.updateRowHeight(row, row);
            return;
        }
        for (var i = 0; i < row.childWidgets.length; i++) {
            var cellWidget = row.childWidgets[i];
            // tslint:disable-next-line:max-line-length
            rowSpan = (isNullOrUndefined(cellWidget) || isNullOrUndefined(cellWidget.cellFormat)) ? rowSpan : cellWidget.cellFormat.rowSpan;
            this.updateSpannedRowCollection(rowSpan, row, cellWidget);
        }
        if (!isNullOrUndefined(row.ownerTable)) {
            for (var i = 0; i < row.ownerTable.spannedRowCollection.length; i++) {
                if (row.ownerTable.spannedRowCollection.keys[i] === row.index) {
                    // Back track to previous table row widgets and update it height if vertical merge ends with this row.
                    for (var j = 0; j < insertIndex; j++) {
                        var prevRowWidget = tableWidget.childWidgets[j];
                        this.updateRowHeight(prevRowWidget, row);
                    }
                    row.ownerTable.spannedRowCollection.remove(row.ownerTable.spannedRowCollection.keys[i]);
                    break;
                }
            }
        }
    };
    /**
     * Updates row height.
     * @param prevRowWidget
     * @param rowWidget
     * @param row
     */
    Layout.prototype.updateRowHeight = function (prevRowWidget, row) {
        var rowIndex = row.index;
        var rowSpan = 1;
        for (var i = 0; i < prevRowWidget.childWidgets.length; i++) {
            var cellWidget = prevRowWidget.childWidgets[i];
            // tslint:disable-next-line:max-line-length
            rowSpan = (isNullOrUndefined(cellWidget) || isNullOrUndefined(cellWidget.cellFormat)) ? rowSpan : cellWidget.cellFormat.rowSpan;
            //To update Row height- if row has row span value greater than 1, need to add it in spannedRowCollection            
            this.updateSpannedRowCollection(rowSpan, row, cellWidget);
            if (rowIndex - cellWidget.rowIndex === rowSpan - 1) {
                var mergedCellHeight = cellWidget.y + cellWidget.height + cellWidget.margin.bottom - row.y;
                if (row.height < mergedCellHeight) {
                    row.height = mergedCellHeight;
                }
            }
        }
    };
    //if row has row span value greater than 1, need to add it in spannedRowCollection
    Layout.prototype.updateSpannedRowCollection = function (rowSpan, row, cellWidget) {
        if (rowSpan > 1 && !isNullOrUndefined(row.ownerTable)) {
            //Checks the rowspan is already exist in the list
            if (!row.ownerTable.spannedRowCollection.containsKey(row.index + rowSpan - 1)) {
                row.ownerTable.spannedRowCollection.add(row.index + rowSpan - 1, row.index);
            }
        }
    };
    /**
     * Updates row height by cell spacing
     * @param rowWidget
     * @param viewer
     * @param row
     */
    Layout.prototype.updateRowHeightByCellSpacing = function (tableCollection, row, viewer) {
        if (row.ownerTable.tableFormat.cellSpacing > 0) {
            // In the Case of tableWidget is greater than one and rowWidget is start at the Top Position of the page. 
            // In such case we have update the row height with half of cell spacing.
            // Remaining cases we have to update the entire hight
            // tslint:disable-next-line:max-line-length
            if (tableCollection.length > 1 && row.y === viewer.clientArea.y && viewer instanceof PageLayoutViewer) {
                row.height = row.height - HelperMethods.convertPointToPixel(row.ownerTable.tableFormat.cellSpacing) / 2;
            }
        }
    };
    /**
     * Checks whether row span is end.
     * @param row
     * @param viewer
     */
    Layout.prototype.isRowSpanEnd = function (row, viewer) {
        var rowIndex = row.index;
        var rowSpan = 1;
        for (var i = 0; i < viewer.splittedCellWidgets.length; i++) {
            var splittedCell = viewer.splittedCellWidgets[i];
            // tslint:disable-next-line:max-line-length
            rowSpan = (isNullOrUndefined(splittedCell) || isNullOrUndefined(splittedCell.cellFormat)) ? rowSpan : splittedCell.cellFormat.rowSpan;
            if (rowIndex - splittedCell.rowIndex === rowSpan - 1) {
                return true;
            }
        }
        return false;
    };
    /**
     * Checks whether vertical merged cell to continue or not.
     * @param row
     * @private
     */
    Layout.prototype.isVerticalMergedCellContinue = function (row) {
        var colIndex = 0;
        for (var i = 0; i < row.childWidgets.length; i++) {
            var cell = row.childWidgets[i];
            if (colIndex < cell.columnIndex) {
                return true;
            }
            colIndex += cell.cellFormat.columnSpan;
        }
        return colIndex < row.ownerTable.tableHolder.columns.length;
    };
    /**
     * Splits widgets.
     * @param tableRowWidget
     * @param viewer
     * @param splittedWidget
     * @param row
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.splitWidgets = function (tableRowWidget, viewer, tableCollection, rowCollection, splittedWidget, isLastRow) {
        if (this.isFirstLineFitForRow(viewer.clientArea.bottom, tableRowWidget) && tableRowWidget.childWidgets.length > 0) {
            splittedWidget = this.getSplittedWidgetForRow(viewer.clientArea.bottom, tableCollection, rowCollection, tableRowWidget);
            if (viewer.splittedCellWidgets.length > 0 || splittedWidget !== tableRowWidget) {
                if (isLastRow) {
                    for (var i = 0; i < splittedWidget.childWidgets.length; i++) {
                        var cell = splittedWidget.childWidgets[i];
                        if (cell.rowIndex !== splittedWidget.index) {
                            splittedWidget.childWidgets.splice(i, 1);
                            i--;
                        }
                    }
                }
                //Adds the splitted widget of a vertical merged cell, to next row widget in the next page.
                this.insertSplittedCellWidgets(viewer, tableCollection, splittedWidget, tableRowWidget.indexInOwner - 1);
            }
        }
        else {
            //Adds the splitted widget of a vertical merged cell, to next row widget in the next page.
            this.insertSplittedCellWidgets(viewer, tableCollection, splittedWidget, tableRowWidget.indexInOwner - 1);
        }
        return splittedWidget;
    };
    /**
     * Gets splitted widget for row.
     * @param bottom
     * @param tableRowWidget
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.getSplittedWidgetForRow = function (bottom, tableCollection, rowCollection, tableRowWidget) {
        var splittedWidget = undefined;
        var rowIndex = tableRowWidget.index;
        for (var i = 0; i < tableRowWidget.childWidgets.length; i++) {
            var cellWidget = tableRowWidget.childWidgets[i];
            var splittedCell = this.getSplittedWidget(bottom, true, tableCollection, rowCollection, cellWidget);
            if (!isNullOrUndefined(splittedCell)) {
                if (splittedCell === cellWidget) {
                    //Returns if the whole content of the row does not fit in current page.
                    return tableRowWidget;
                }
                if (tableRowWidget.childWidgets.indexOf(splittedCell) !== -1) {
                    tableRowWidget.childWidgets.splice(tableRowWidget.childWidgets.indexOf(splittedCell), 1);
                }
                if (i === 0 || tableRowWidget.height < cellWidget.height + cellWidget.margin.top + cellWidget.margin.bottom) {
                    tableRowWidget.height = cellWidget.height + cellWidget.margin.top + cellWidget.margin.bottom;
                }
                if (isNullOrUndefined(splittedWidget)) {
                    //Creates new widget, to hold the splitted contents.
                    splittedWidget = new TableRowWidget();
                    splittedWidget.containerWidget = tableRowWidget.containerWidget;
                    splittedWidget.index = tableRowWidget.index;
                    splittedWidget.rowFormat = tableRowWidget.rowFormat;
                    this.updateWidgetLocation(tableRowWidget, splittedWidget);
                    // splittedWidget.height = 0;
                    rowCollection.push(splittedWidget);
                }
                var rowSpan = 1;
                // tslint:disable-next-line:max-line-length
                rowSpan = (isNullOrUndefined(splittedCell) || isNullOrUndefined(splittedCell.cellFormat)) ? rowSpan : splittedCell.cellFormat.rowSpan;
                if (rowIndex - splittedCell.rowIndex === rowSpan - 1
                    && splittedWidget.height < splittedCell.height + splittedCell.margin.top + splittedCell.margin.bottom) {
                    splittedWidget.height = splittedCell.height + splittedCell.margin.top + splittedCell.margin.bottom;
                }
                else {
                    if (tableRowWidget.rowFormat.heightType !== 'Auto') {
                        //Sets the height for row widget if height type is exact or at least.
                        splittedWidget.height = tableRowWidget.rowFormat.height;
                    }
                }
                splittedWidget.childWidgets.push(splittedCell);
                splittedCell.containerWidget = splittedWidget;
            }
        }
        return splittedWidget;
    };
    /**
     * Updates widget to table.
     * @param row
     * @param viewer
     */
    /* tslint:disable */
    Layout.prototype.updateWidgetsToTable = function (tableWidgets, rowWidgets, row) {
        var rowHeight = this.getRowHeight(row, [row]);
        var viewer = this.viewer;
        //initializing row properties with default values.
        var isHeader = row.rowFormat.isHeader;
        var isAllowBreakAcrossPages = row.rowFormat.allowBreakAcrossPages;
        var heightType = row.rowFormat.heightType;
        var cellSpacing = 0;
        var count = 0;
        var tableRowWidget = row;
        var moveRowToNextTable = false;
        if (row.ownerTable.continueHeader && !isHeader) {
            row.ownerTable.continueHeader = false;
        }
        var isInitialLayout = row.ownerTable.isInsideTable;
        var isLastRow = false;
        cellSpacing = (!isNullOrUndefined(row.ownerTable) && !isNullOrUndefined(row.ownerTable.tableFormat)) ? HelperMethods.convertPointToPixel(row.ownerTable.tableFormat.cellSpacing) : 0;
        while (count < rowWidgets.length) {
            count = rowWidgets.length;
            if (row.ownerTable.isInsideTable || (viewer.splittedCellWidgets.length === 0 && tableRowWidget.y + tableRowWidget.height + cellSpacing <= viewer.clientArea.bottom)) {
                if (this.isVerticalMergedCellContinue(row) && (tableRowWidget.y === viewer.clientArea.y
                    || tableRowWidget.y === this.viewer.clientArea.y + tableRowWidget.ownerTable.headerHeight)) {
                    this.insertSplittedCellWidgets(viewer, tableWidgets, tableRowWidget, tableRowWidget.index - 1);
                }
                this.addWidgetToTable(viewer, tableWidgets, rowWidgets, tableRowWidget, undefined, isInitialLayout);
                if (viewer.splittedCellWidgets.length > 0 && isNullOrUndefined(rowWidgets[rowWidgets.length - 1].nextRow)) {
                    count--;
                    isLastRow = true;
                }
                isInitialLayout = false;
            }
            else {
                isInitialLayout = false;
                //Split widget for next page
                if (viewer.splittedCellWidgets.length > 0 && tableRowWidget.y + tableRowWidget.height <= viewer.clientArea.bottom) {
                    var isRowSpanEnd = this.isRowSpanEnd(row, viewer);
                    if (!isRowSpanEnd) {
                        if (this.isVerticalMergedCellContinue(row) && (tableRowWidget.y === viewer.clientArea.y
                            || tableRowWidget.y === this.viewer.clientArea.y + tableRowWidget.ownerTable.headerHeight)) {
                            this.insertSplittedCellWidgets(viewer, tableWidgets, tableRowWidget, tableRowWidget.indexInOwner - 1);
                        }
                        this.addWidgetToTable(viewer, tableWidgets, rowWidgets, tableRowWidget);
                        continue;
                    }
                }
                var splittedWidget = tableRowWidget;
                var tableWidget = tableWidgets[tableWidgets.length - 1];
                if (rowHeight + tableRowWidget.y > viewer.clientArea.bottom) {
                    // tslint:disable-next-line:max-line-length
                    if (!isAllowBreakAcrossPages || (isHeader && row.ownerTable.continueHeader) || (heightType === 'AtLeast' && HelperMethods.convertPointToPixel(row.rowFormat.height) < viewer.clientArea.bottom)) {
                        // tslint:disable-next-line:max-line-length
                        if ((heightType === 'AtLeast' && HelperMethods.convertPointToPixel(row.rowFormat.height) < viewer.clientActiveArea.height && isAllowBreakAcrossPages) || (heightType !== 'Exactly' && tableRowWidget.y === viewer.clientArea.y) || (heightType === 'Auto' && isAllowBreakAcrossPages)) {
                            splittedWidget = this.splitWidgets(tableRowWidget, viewer, tableWidgets, rowWidgets, splittedWidget, isLastRow);
                        }
                        if (heightType === 'Exactly' && tableRowWidget.y === viewer.clientArea.y) {
                            this.addWidgetToTable(viewer, tableWidgets, rowWidgets, tableRowWidget);
                            count++;
                        }
                        if (isHeader && row.ownerTable.continueHeader) {
                            row.ownerTable.header = false;
                            row.ownerTable.continueHeader = false;
                            row.ownerTable.headerHeight = 0;
                            var pages = undefined;
                            // if (viewer instanceof PageLayoutViewer) {
                            pages = viewer.pages;
                            // }
                            if (!isNullOrUndefined(pages)) {
                                for (var i = 0; i < pages.length; i++) {
                                    if (pages[i].repeatHeaderRowTableWidget) {
                                        pages[i].repeatHeaderRowTableWidget = false;
                                    }
                                }
                            }
                        }
                    }
                    else {
                        if ((heightType === 'Auto' || heightType === 'AtLeast') && isAllowBreakAcrossPages) {
                            // tslint:disable-next-line:max-line-length
                            if (!(HelperMethods.convertPointToPixel(row.rowFormat.height) > viewer.clientArea.bottom) || tableRowWidget.y === viewer.clientArea.y) {
                                splittedWidget = this.splitWidgets(tableRowWidget, viewer, tableWidgets, rowWidgets, splittedWidget, isLastRow);
                            }
                        }
                        else if (heightType === 'Exactly' && tableRowWidget.y === viewer.clientArea.y) {
                            this.addWidgetToTable(viewer, tableWidgets, rowWidgets, tableRowWidget);
                            count++;
                        }
                    }
                }
                else {
                    var isInsertSplittedWidgets = false;
                    // Splitting handled for the merged cell with allowRowBreakAcross pages. 
                    if (this.isVerticalMergedCellContinue(row) && (isAllowBreakAcrossPages ||
                        (isInsertSplittedWidgets = (tableRowWidget.y === viewer.clientArea.y
                            || tableRowWidget.y === this.viewer.clientArea.y + tableRowWidget.ownerTable.headerHeight)))) {
                        if (isInsertSplittedWidgets) {
                            this.insertSplittedCellWidgets(viewer, tableWidgets, splittedWidget, tableRowWidget.indexInOwner - 1);
                        }
                        else {
                            splittedWidget = this.splitWidgets(tableRowWidget, viewer, tableWidgets, rowWidgets, splittedWidget, isLastRow);
                        }
                    }
                    else if (isLastRow && !isAllowBreakAcrossPages) {
                        splittedWidget = this.splitWidgets(tableRowWidget, viewer, tableWidgets, rowWidgets, splittedWidget, isLastRow);
                    }
                }
                //Create New table for splitted widget
                if (!isNullOrUndefined(splittedWidget)) {
                    if (splittedWidget !== tableRowWidget) {
                        this.addWidgetToTable(viewer, tableWidgets, rowWidgets, tableRowWidget, tableRowWidget.nextRow);
                        //Updates the fitted table rows to current page.
                        this.updateWidgetsToPage(tableWidgets, rowWidgets, row.ownerTable, tableRowWidget.nextRow);
                        var index_2 = tableWidgets.indexOf(tableRowWidget.containerWidget);
                        if (index_2 + 1 >= tableWidgets.length) {
                            //Creates new table widget for splitted rows.
                            this.addTableWidget(viewer.clientActiveArea, tableWidgets, true);
                        }
                        tableRowWidget = splittedWidget;
                    }
                    else {
                        if (row.index > 0) {
                            //Updates the fitted table rows to current page.
                            this.updateWidgetsToPage(tableWidgets, rowWidgets, row.ownerTable, row);
                            // Need to update on this further
                            if (row.previousRenderedWidget instanceof TableRowWidget) {
                                // Need to update on this further
                                var prevWidget = row.previousRenderedWidget;
                                if (HelperMethods.round(tableRowWidget.y, 2) === HelperMethods.round(prevWidget.y + prevWidget.height, 2)) {
                                    var prevIndex = tableWidgets.indexOf(prevWidget.containerWidget);
                                    if (prevIndex + 1 >= tableWidgets.length) {
                                        //Creates new table widget for splitted rows.
                                        this.addTableWidget(viewer.clientActiveArea, tableWidgets, true);
                                    }
                                }
                                else {
                                    //Creates new table widget for splitted rows.
                                    this.addTableWidget(viewer.clientActiveArea, tableWidgets, true);
                                }
                            }
                            else {
                                //Creates new table widget for splitted rows.
                                this.addTableWidget(viewer.clientActiveArea, tableWidgets, true);
                            }
                        }
                        moveRowToNextTable = true;
                        count--;
                    }
                    tableWidget = tableWidgets[tableWidgets.length - 1];
                    var prevBodyWidget = undefined;
                    if (tableWidgets.length > 1) {
                        //Get Previous Splitted Widget container
                        prevBodyWidget = tableWidgets[tableWidgets.length - 2].containerWidget;
                    }
                    else {
                        var previousBlock = row.ownerTable.previousRenderedWidget;
                        prevBodyWidget = previousBlock.containerWidget;
                    }
                    var pageIndex = 0;
                    if (!isNullOrUndefined(prevBodyWidget)) {
                        pageIndex = viewer.pages.indexOf(prevBodyWidget.page);
                    }
                    var index = row.ownerTable.containerWidget.index;
                    var bodyWidget = void 0;
                    var block = void 0;
                    if (moveRowToNextTable && tableWidgets.length === 1) {
                        block = tableWidgets[tableWidgets.length - 1];
                    }
                    else {
                        block = tableWidgets[tableWidgets.length - 2];
                    }
                    bodyWidget = this.moveBlocksToNextPage(block);
                    var curretTable = tableWidgets[tableWidgets.length - 1];
                    //Move Next RowWidge to next page
                    if (moveRowToNextTable) {
                        // tslint:disable-next-line:max-line-length
                        if (row.index === 0 && curretTable.containerWidget && curretTable.containerWidget.childWidgets.indexOf(curretTable) !== -1) {
                            curretTable.containerWidget.childWidgets.splice(curretTable.containerWidget.childWidgets.indexOf(curretTable), 1);
                        }
                    }
                    if (bodyWidget.childWidgets.indexOf(curretTable) !== -1) {
                        bodyWidget.childWidgets.splice(bodyWidget.childWidgets.indexOf(curretTable), 1);
                    }
                    bodyWidget.childWidgets.unshift(curretTable);
                    curretTable.containerWidget = bodyWidget;
                    if (moveRowToNextTable && row.index > 0 || rowWidgets.length > 1) {
                        this.moveNextWidgetsToTable(tableWidgets, rowWidgets, !moveRowToNextTable);
                    }
                    moveRowToNextTable = false;
                    if (row.ownerTable.header && tableRowWidget.height < viewer.clientArea.bottom) {
                        // if (viewer instanceof PageLayoutViewer) {
                        viewer.currentRenderingPage.repeatHeaderRowTableWidget = true;
                        // }
                        //Updates table widgets location.
                        viewer.updateClientAreaForBlock(row.ownerTable, true, tableWidgets);
                        // tslint:disable-next-line:max-line-length
                        //Update splitted row widget location. if header is repeated update the y position of splitted widget to header height.
                        splittedWidget.x = splittedWidget.x;
                        splittedWidget.y = tableWidget.y + row.ownerTable.headerHeight;
                        // let cellspace: number = viewer instanceof PageLayoutViewer ? cellspacing / 2 : cellspacing;
                        var cellspace = cellSpacing / 2;
                        this.updateChildLocationForRow(tableWidget.y + row.ownerTable.headerHeight - cellspace, splittedWidget);
                    }
                    else {
                        //Updates table widgets location.
                        viewer.updateClientAreaForBlock(row.ownerTable, true, tableWidgets);
                        // tslint:disable-next-line:max-line-length
                        //Update splitted row widget location. if header is repeated update the y position of splitted widget to header height.
                        splittedWidget.x = splittedWidget.x;
                        splittedWidget.y = tableWidget.y;
                        // let cellspace: number = viewer instanceof PageLayoutViewer ? cellspacing / 2 : cellspacing;
                        var cellspace = cellSpacing / 2;
                        this.updateChildLocationForRow(tableWidget.y - cellspace, splittedWidget);
                    }
                }
                isLastRow = false;
            }
            if (isHeader && row.ownerTable.continueHeader) {
                row.ownerTable.header = true;
                row.ownerTable.headerHeight = rowHeight + row.ownerTable.headerHeight;
            }
            if (isHeader && !isNullOrUndefined(this.getHeader(row.ownerTable)) && row.index === this.getHeader(row.ownerTable).index) {
                var headerHeight = this.getHeaderHeight(row.ownerTable, row, rowWidgets);
                if (headerHeight > row.ownerTable.headerHeight || headerHeight > row.ownerTable.headerHeight) {
                    row.ownerTable.headerHeight = headerHeight;
                }
                if (row.ownerTable.headerHeight > viewer.clientArea.height) {
                    row.ownerTable.header = false;
                    row.ownerTable.continueHeader = false;
                    row.ownerTable.headerHeight = 0;
                    var pages = viewer.pages;
                    for (var i = 0; i < pages.length; i++) {
                        if (pages[i].repeatHeaderRowTableWidget) {
                            pages[i].repeatHeaderRowTableWidget = false;
                        }
                    }
                }
            }
            if (tableWidgets.length > 2 && row.ownerTable.header && tableRowWidget.height < viewer.clientActiveArea.bottom &&
                !viewer.currentRenderingPage.repeatHeaderRowTableWidget) {
                viewer.currentRenderingPage.repeatHeaderRowTableWidget = true;
            }
        }
    };
    /* tslint:enable */
    /**
     * Gets header.
     * @param table
     * @private
     */
    Layout.prototype.getHeader = function (table) {
        var header = undefined;
        var flag = true;
        table = table.getSplitWidgets()[0];
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            if (row.rowFormat.isHeader) {
                header = row;
            }
            else {
                flag = false;
            }
            if (!flag) {
                break;
            }
        }
        return header;
    };
    /**
     * Gets header height.
     * @param ownerTable
     * @param row
     */
    Layout.prototype.getHeaderHeight = function (ownerTable, row, rowCollection) {
        var height = 0;
        if (row.ownerTable.childWidgets.length > 0 && ownerTable.childWidgets[0].rowFormat.isHeader) {
            for (var i = 0; i < ownerTable.childWidgets.length; i++) {
                var row_1 = ownerTable.childWidgets[i];
                if (row_1.rowFormat.isHeader) {
                    height = height + this.getRowHeight(row_1, rowCollection);
                }
                else {
                    break;
                }
            }
        }
        return height;
    };
    /**
     * Updates widgets to row.
     * @param cell
     */
    Layout.prototype.updateWidgetToRow = function (cell) {
        var viewer = this.viewer;
        //Adds table cell widget to owner row widget.
        var rowWidget = cell.ownerRow;
        var cellLeft = rowWidget.x;
        if (rowWidget.childWidgets.length > 0) {
            var lastWidget = rowWidget.childWidgets[rowWidget.childWidgets.length - 1];
            cellLeft = lastWidget.x + lastWidget.width + lastWidget.margin.right;
        }
        // rowWidget.childWidgets.push(cell);
        cell.containerWidget = rowWidget;
        //If the row height is set as Atleast then height is set to atleast height for the first cell of the row.
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(cell.ownerRow) && cell.ownerRow.rowFormat.heightType !== 'Exactly' && HelperMethods.convertPointToPixel(cell.ownerRow.rowFormat.height) > 0 && cell.cellIndex === 0) {
            rowWidget.height = rowWidget.height + HelperMethods.convertPointToPixel(cell.ownerRow.rowFormat.height);
        }
        //Add condition not cell merged vertically.
        if (cell.cellFormat.rowSpan === 1) {
            var cellHeight = cell.height + cell.margin.top + cell.margin.bottom;
            if (rowWidget.height - HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.cellSpacing) < cellHeight) {
                rowWidget.height = cellHeight + HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.cellSpacing);
            }
        }
    };
    /**
     * Updates height for row widget.
     * @param viewer
     * @param isUpdateVerticalPosition
     * @param rowWidget
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.updateHeightForRowWidget = function (viewer, isUpdateVerticalPosition, tableCollection, rowCollection, rowWidget, isLayouted, endRowWidget, isInitialLayout) {
        for (var i = 0; i < rowWidget.childWidgets.length; i++) {
            var cellspacing = 0;
            var cellWidget = undefined;
            var childWidget = rowWidget.childWidgets[i];
            // if (childWidget instanceof TableCellWidget) {
            cellWidget = childWidget;
            // }
            var rowSpan = 1;
            rowSpan = cellWidget.cellFormat.rowSpan;
            cellspacing = HelperMethods.convertPointToPixel(cellWidget.ownerTable.tableFormat.cellSpacing);
            if (rowSpan > 1) {
                var currentRowWidgetIndex = rowWidget.containerWidget.childWidgets.indexOf(rowWidget);
                // tslint:disable-next-line:max-line-length
                var rowSpanWidgetEndIndex = currentRowWidgetIndex + rowSpan - 1 - (rowWidget.index - cellWidget.rowIndex);
                if (!isInitialLayout && (viewer.clientArea.bottom < cellWidget.y + cellWidget.height + cellWidget.margin.bottom
                    || rowSpanWidgetEndIndex >= currentRowWidgetIndex + 1)) {
                    this.splitSpannedCellWidget(cellWidget, tableCollection, rowCollection, viewer);
                }
                var spanEndRowWidget = rowWidget;
                if (rowSpanWidgetEndIndex > 0) {
                    if (rowSpanWidgetEndIndex < rowWidget.containerWidget.childWidgets.length) {
                        var childWidget_1 = rowWidget.containerWidget.childWidgets[rowSpanWidgetEndIndex];
                        if (childWidget_1 instanceof TableRowWidget) {
                            spanEndRowWidget = childWidget_1;
                            if (spanEndRowWidget === endRowWidget) {
                                spanEndRowWidget = rowWidget;
                            }
                        }
                    }
                    else {
                        // tslint:disable-next-line:max-line-length
                        spanEndRowWidget = rowWidget.containerWidget.childWidgets[rowWidget.containerWidget.childWidgets.length - 1];
                    }
                }
                if (cellWidget.y + cellWidget.height + cellWidget.margin.bottom < spanEndRowWidget.y + spanEndRowWidget.height) {
                    cellWidget.height = spanEndRowWidget.y + spanEndRowWidget.height - cellWidget.y - cellWidget.margin.bottom;
                    // tslint:disable-next-line:max-line-length
                }
                else if (isLayouted && spanEndRowWidget && (spanEndRowWidget.y !== 0 && spanEndRowWidget.height !== 0) && cellWidget.y + cellWidget.height + cellWidget.margin.bottom > spanEndRowWidget.y + spanEndRowWidget.height) {
                    spanEndRowWidget.height = cellWidget.y + cellWidget.height + cellWidget.margin.bottom - spanEndRowWidget.y;
                    // tslint:disable-next-line:max-line-length
                    //Update the next rowlayout widget location. Reason for the updation is previous row height is updated when cell height is greater. So already layouted next row location has to be updated again.
                    // if (rowWidget === spanEndRowWidget && rowWidget.nextWidget instanceof TableRowWidget) {
                    //     let nextRow: TableRowWidget = rowWidget.nextWidget as TableRowWidget;
                    //     // Need to update on this further
                    //     // if (viewer.renderedElements.containsKey(nextRow)) {
                    //     //     let nextWidget: TableRowWidget[] = viewer.renderedElements.get(nextRow) as TableRowWidget[];
                    //     //     if (nextWidget.length > 0) {
                    //     //         nextWidget[0].x = nextWidget[0].x;
                    //     //         nextWidget[0].y = rowWidget.y + rowWidget.height;
                    //     //     }
                    //     // }
                    // }
                }
            }
            else {
                if (cellspacing > 0) {
                    // In the Case of tableWidget is greater than one and rowWidget is start at the Top Position of the page. 
                    // In such case we have update the cell height with half of cell spacing.
                    // Remaining cases we have to update the entire hight
                    // tslint:disable-next-line:max-line-length
                    if (tableCollection.length > 1 && rowWidget.y === viewer.clientArea.y && viewer instanceof PageLayoutViewer) {
                        cellspacing = cellspacing / 2;
                    }
                }
                cellWidget.height = rowWidget.height - cellWidget.margin.top - cellWidget.margin.bottom - cellspacing;
            }
            this.updateHeightForCellWidget(viewer, tableCollection, rowCollection, cellWidget);
            var widget = rowWidget.containerWidget;
            while (widget.containerWidget instanceof Widget) {
                widget = widget.containerWidget;
            }
            var page = undefined;
            if (widget instanceof BodyWidget) {
                page = widget.page;
            }
            // tslint:disable-next-line:max-line-length
            if ((viewer instanceof PageLayoutViewer && viewer.visiblePages.indexOf(page) !== -1) || isUpdateVerticalPosition) {
                this.updateCellVerticalPosition(cellWidget, false, false);
            }
            //Renders the current table row contents, after relayout based on editing.
            // if (viewer instanceof PageLayoutViewer && (viewer as PageLayoutViewer).visiblePages.indexOf(page) !== -1) {
            //     //Added proper undefined condition check for Asynchronous operation.
            //     if (!isNullOrUndefined(rowWidget.tableRow) && !isNullOrUndefined(rowWidget.tableRow.rowFormat)) {
            //         this.viewer.updateScrollBars();
            //         //this.render.renderTableCellWidget(page, cellWidget);
            //     }
            // }
        }
    };
    /**
     * Updates height for cell widget.
     * @param viewer
     * @param cellWidget
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.updateHeightForCellWidget = function (viewer, tableWidget, rowCollection, cellWidget) {
        for (var i = 0; i < cellWidget.childWidgets.length; i++) {
            if (cellWidget.childWidgets[i] instanceof TableWidget) {
                this.updateHeightForTableWidget(tableWidget, rowCollection, cellWidget.childWidgets[i]);
            }
        }
    };
    /**
     * Gets row height.
     * @param row
     * @private
     */
    Layout.prototype.getRowHeight = function (row, rowCollection) {
        var height = 0;
        if (row.rowFormat.heightType === 'Exactly') {
            height = row.rowFormat.height;
        }
        else {
            for (var i = 0; i < rowCollection.length; i++) {
                if (rowCollection[i] instanceof TableRowWidget) {
                    height = rowCollection[i].height + height;
                }
            }
            height = Math.max(height, row.rowFormat.height);
        }
        return height;
    };
    /**
     * splits spanned cell widget.
     * @param cellWidget
     * @param viewer
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.splitSpannedCellWidget = function (cellWidget, tableCollection, rowCollection, viewer) {
        var splittedCell = this.getSplittedWidget(viewer.clientArea.bottom, false, tableCollection, rowCollection, cellWidget);
        if (!isNullOrUndefined(splittedCell)) {
            //Adds the splitted contents of a vertical merged cell, in order preserve in next page.
            viewer.splittedCellWidgets.push(splittedCell);
        }
    };
    /**
     * Inserts splitted cell widgets.
     * @param viewer
     * @param rowWidget
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.insertSplittedCellWidgets = function (viewer, tableCollection, rowWidget, previousRowIndex) {
        var left = rowWidget.x;
        var tableWidth = 0;
        tableWidth = HelperMethods.convertPointToPixel(rowWidget.ownerTable.tableHolder.tableWidth);
        for (var i = 0; i < rowWidget.childWidgets.length; i++) {
            var cellWidget = rowWidget.childWidgets[i];
            if (Math.round(left) < Math.round(cellWidget.x - cellWidget.margin.left)) {
                if (this.insertRowSpannedWidget(rowWidget, viewer, left, i)) {
                    i--;
                    continue;
                }
                var length_1 = rowWidget.childWidgets.length;
                this.insertEmptySplittedCellWidget(rowWidget, tableCollection, left, i, previousRowIndex);
                if (length_1 < rowWidget.childWidgets.length) {
                    i--;
                    continue;
                }
            }
            left += cellWidget.margin.left + cellWidget.width + cellWidget.margin.right;
            if (i === rowWidget.childWidgets.length - 1 && Math.round(left) < Math.round(rowWidget.x + tableWidth)) {
                if (this.insertRowSpannedWidget(rowWidget, viewer, left, i + 1)) {
                    continue;
                }
                this.insertEmptySplittedCellWidget(rowWidget, tableCollection, left, i + 1, previousRowIndex);
                continue;
            }
        }
        // tslint:disable-next-line:max-line-length
        // Special case: when the child widgets of row is equal to 0 then the splitted widgets in the viewer is added in the table row widgets. 
        if ((isNullOrUndefined(rowWidget.childWidgets) || rowWidget.childWidgets.length === 0) && viewer.splittedCellWidgets.length > 0) {
            for (var j = 0; j < viewer.splittedCellWidgets.length; j++) {
                var widget = viewer.splittedCellWidgets[j];
                if (Math.round(left) <= Math.round(widget.x - widget.margin.left)) {
                    if (this.insertRowSpannedWidget(rowWidget, viewer, left, j)) {
                        j--;
                        continue;
                    }
                    var count = rowWidget.childWidgets.length;
                    this.insertEmptySplittedCellWidget(rowWidget, tableCollection, left, j, previousRowIndex);
                    if (count < rowWidget.childWidgets.length) {
                        j--;
                        continue;
                    }
                }
                left += widget.margin.left + widget.width + widget.margin.right;
                if (j === rowWidget.childWidgets.length - 1 && Math.round(left) <
                    Math.round(rowWidget.x + tableWidth)) {
                    if (this.insertRowSpannedWidget(rowWidget, viewer, left, j + 1)) {
                        continue;
                    }
                    this.insertEmptySplittedCellWidget(rowWidget, tableCollection, left, j + 1, previousRowIndex);
                    continue;
                }
            }
        }
        if (viewer.splittedCellWidgets.length > 0) {
            viewer.splittedCellWidgets = [];
        }
    };
    /**
     * Inserts spanned row widget.
     * @param rowWidget
     * @param viewer
     * @param left
     * @param index
     */
    Layout.prototype.insertRowSpannedWidget = function (rowWidget, viewer, left, index) {
        var cellSpacing = 0;
        if (rowWidget.ownerTable.tableFormat.cellSpacing > 0) {
            cellSpacing = HelperMethods.convertPointToPixel(rowWidget.ownerTable.tableFormat.cellSpacing);
        }
        for (var i = 0; i < viewer.splittedCellWidgets.length; i++) {
            var splittedCell = viewer.splittedCellWidgets[i];
            if (Math.round(left) === Math.round(splittedCell.x - splittedCell.margin.left)) {
                rowWidget.childWidgets.splice(index, 0, splittedCell);
                splittedCell.containerWidget = rowWidget;
                //If the splitted cell location differs from expected location update the location of row child widgets.
                if (splittedCell.y !== rowWidget.y + splittedCell.margin.top + cellSpacing) {
                    this.updateChildLocationForRow(rowWidget.y, rowWidget);
                }
                viewer.splittedCellWidgets.splice(i, 1);
                return true;
            }
        }
        return false;
    };
    /**
     * Inserts empty splitted cell widgets.
     * @param rowWidget
     * @param left
     * @param index
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.insertEmptySplittedCellWidget = function (currentRow, tableCollection, left, index, previousRowIndex) {
        var tableWidget = tableCollection[tableCollection.length - 1];
        var previousRow;
        for (var j = tableCollection.length - 1; j >= 0; j--) {
            var table = tableCollection[j];
            for (var z = table.childWidgets.length - 1; z >= 0; z--) {
                var row = table.childWidgets[z];
                if (row.index === previousRowIndex) {
                    previousRow = row;
                    break;
                }
            }
        }
        if (previousRow) {
            tableWidget = previousRow.ownerTable;
            previousRowIndex = previousRow.indexInOwner;
        }
        for (var i = previousRowIndex; i >= 0; i--) {
            var rowWidget = tableWidget.childWidgets[i];
            var previousLeft = rowWidget.x;
            for (var j = 0; j < rowWidget.childWidgets.length; j++) {
                var rowSpan = 1;
                var cellWidget = rowWidget.childWidgets[j];
                if (Math.round(left) === Math.round(previousLeft)) {
                    rowSpan = (isNullOrUndefined(cellWidget) || isNullOrUndefined(cellWidget.cellFormat)) ? rowSpan :
                        cellWidget.cellFormat.rowSpan;
                    if (rowSpan > 1) {
                        var emptyCellWidget = this.createCellWidget(cellWidget);
                        currentRow.childWidgets.splice(index, 0, emptyCellWidget);
                        emptyCellWidget.containerWidget = currentRow;
                        this.updateChildLocationForRow(currentRow.y, currentRow);
                        return;
                    }
                }
                previousLeft += cellWidget.margin.left + cellWidget.width + cellWidget.margin.right;
            }
        }
    };
    /**
     * Gets spllited widget.
     * @param bottom
     * @param splitMinimalWidget
     * @param cellWidget
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.getSplittedWidget = function (bottom, splitMinimalWidget, tableCollection, rowCollection, cellWidget) {
        var splittedWidget = undefined;
        if (cellWidget.y + cellWidget.height > bottom - cellWidget.margin.bottom) {
            for (var i = 0; i < cellWidget.childWidgets.length; i++) {
                if (cellWidget.childWidgets[i] instanceof ParagraphWidget) {
                    var paragraphWidget = cellWidget.childWidgets[i];
                    var splittedPara = this.getSplittedWidgetForPara(bottom - cellWidget.margin.bottom, paragraphWidget);
                    if (!isNullOrUndefined(splittedPara)) {
                        if (i === 0 && splittedPara === paragraphWidget) {
                            //Returns if the whole content of the cell does not fit in current page.
                            return cellWidget;
                        }
                        if (cellWidget.childWidgets.indexOf(splittedPara) !== -1) {
                            cellWidget.childWidgets.splice(cellWidget.childWidgets.indexOf(splittedPara), 1);
                            i--;
                        }
                        cellWidget.height -= splittedPara.height;
                        if (isNullOrUndefined(splittedWidget)) {
                            //Creates new widget, to hold the splitted contents.
                            splittedWidget = this.createCellWidget(cellWidget);
                        }
                        splittedWidget.height += splittedPara.height;
                        splittedWidget.childWidgets.push(splittedPara);
                        splittedPara.containerWidget = splittedWidget;
                    }
                }
                else {
                    var tableWidget = cellWidget.childWidgets[i];
                    var tableCol = [tableWidget];
                    //Check for nested table.
                    if (bottom - cellWidget.margin.bottom < tableWidget.y + tableWidget.height) {
                        var tableHeight = tableWidget.height;
                        // tslint:disable-next-line:max-line-length
                        var splittedTable = this.getSplittedWidgetForTable(bottom - cellWidget.margin.bottom, tableCol, tableWidget);
                        if (!isNullOrUndefined(splittedTable)) {
                            if (i === 0 && splittedTable === tableWidget) {
                                //Returns if the whole table does not fit in current page.
                                return cellWidget;
                            }
                            if (cellWidget.childWidgets.indexOf(splittedTable) !== -1) {
                                cellWidget.childWidgets.splice(cellWidget.childWidgets.indexOf(splittedTable), 1);
                                i--;
                                cellWidget.height -= splittedTable.height;
                            }
                            else {
                                cellWidget.height -= tableHeight - tableWidget.height;
                            }
                            if (isNullOrUndefined(splittedWidget)) {
                                //Creates new widget, to hold the splitted contents.
                                splittedWidget = this.createCellWidget(cellWidget);
                            }
                            splittedWidget.height += splittedTable.height;
                            splittedWidget.childWidgets.push(splittedTable);
                            splittedTable.containerWidget = splittedWidget;
                        }
                    }
                }
            }
        }
        if (isNullOrUndefined(splittedWidget) && splitMinimalWidget) {
            //Creates new widget, to hold the splitted contents.
            splittedWidget = this.createCellWidget(cellWidget);
        }
        return splittedWidget;
    };
    /**
     * Gets list level pattern
     * @param value
     * @private
     */
    Layout.prototype.getListLevelPattern = function (value) {
        switch (value) {
            case 0:
                return 'Arabic';
            case 1:
                return 'UpRoman';
            case 2:
                return 'LowRoman';
            case 3:
                return 'UpLetter';
            case 4:
                return 'LowLetter';
            case 5:
                return 'Ordinal';
            case 6:
                return 'Number';
            case 7:
                return 'OrdinalText';
            case 8:
                return 'LeadingZero';
            case 9:
                return 'Bullet';
            case 10:
                return 'FarEast';
            case 11:
                return 'Special';
            default:
                return 'None';
        }
    };
    /**
     * Creates cell widget.
     * @param cell
     */
    Layout.prototype.createCellWidget = function (cell) {
        var cellWidget = new TableCellWidget();
        cellWidget.cellFormat = cell.cellFormat;
        cellWidget.index = cell.index;
        cellWidget.rowIndex = cell.rowIndex;
        cellWidget.columnIndex = cell.columnIndex;
        cellWidget.containerWidget = cell.containerWidget;
        this.updateWidgetLocation(cell, cellWidget);
        cellWidget.margin = cell.margin;
        cellWidget.leftBorderWidth = HelperMethods.convertPointToPixel(cell.leftBorderWidth);
        cellWidget.rightBorderWidth = HelperMethods.convertPointToPixel(cell.rightBorderWidth);
        return cellWidget;
    };
    /**
     * Create Table Widget
     */
    Layout.prototype.createTableWidget = function (table) {
        var newTable = new TableWidget();
        if (table.header) {
            newTable.header = table.header;
            newTable.headerHeight = table.headerHeight;
        }
        newTable.index = table.index;
        newTable.tableFormat = table.tableFormat;
        newTable.tableHolder = table.tableHolder;
        newTable.isGridUpdated = table.isGridUpdated;
        return newTable;
    };
    /**
     * Gets splitted widget for paragraph.
     * @param bottom
     * @param paragraphWidget
     */
    Layout.prototype.getSplittedWidgetForPara = function (bottom, paragraphWidget) {
        var lineBottom = paragraphWidget.y;
        var splittedWidget = undefined;
        for (var i = 0; i < paragraphWidget.childWidgets.length; i++) {
            var lineWidget = paragraphWidget.childWidgets[i];
            if (bottom < lineBottom + lineWidget.height) {
                if (i === 0) {
                    if (lineWidget.paragraph.containerWidget instanceof TableCellWidget) {
                        //checks first line of the page is exceed the page height
                        if (lineWidget.paragraph.containerWidget.y === paragraphWidget.y) {
                            lineBottom += lineWidget.height;
                            continue;
                        }
                    }
                    splittedWidget = paragraphWidget;
                    break;
                }
                if (paragraphWidget.childWidgets.indexOf(lineWidget) !== -1) {
                    paragraphWidget.childWidgets.splice(paragraphWidget.childWidgets.indexOf(lineWidget), 1);
                    i--;
                }
                paragraphWidget.height -= lineWidget.height;
                if (isNullOrUndefined(splittedWidget)) {
                    //Creates new widget, to hold the splitted contents.
                    splittedWidget = new ParagraphWidget();
                    splittedWidget.characterFormat = paragraphWidget.characterFormat;
                    splittedWidget.paragraphFormat = paragraphWidget.paragraphFormat;
                    splittedWidget.index = paragraphWidget.index;
                    this.updateWidgetLocation(paragraphWidget, splittedWidget);
                    splittedWidget.height = lineWidget.height;
                }
                else {
                    splittedWidget.height += lineWidget.height;
                }
                splittedWidget.childWidgets.push(lineWidget);
                lineWidget.paragraph = splittedWidget;
            }
            lineBottom += lineWidget.height;
        }
        return splittedWidget;
    };
    /**
     * Gets splitted table widget.
     * @param bottom
     * @param tableWidget
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.getSplittedWidgetForTable = function (bottom, tableCollection, tableWidget) {
        var rowBottom = tableWidget.y;
        var splittedWidget = undefined;
        for (var i = 0; i < tableWidget.childWidgets.length; i++) {
            var rowWidget = undefined;
            var childWidget = tableWidget.childWidgets[i];
            // if (childWidget instanceof TableRowWidget) {
            rowWidget = childWidget;
            // }
            var rowHeight = rowWidget.height;
            if (bottom < rowBottom + rowHeight || !isNullOrUndefined(splittedWidget)) {
                //ToDo: Check whether row included in vertical merge or AllowRowSplitbyPage is true, if so split row.
                //Checks if atleast first line fits in the client area.                
                var splittedRow = undefined;
                var allowRowBreakAcrossPages = true;
                if (!isNullOrUndefined(rowWidget) && !isNullOrUndefined(rowWidget.rowFormat)) {
                    allowRowBreakAcrossPages = rowWidget.rowFormat.allowBreakAcrossPages;
                }
                if (allowRowBreakAcrossPages) {
                    // tslint:disable-next-line:max-line-length
                    splittedRow = (isNullOrUndefined(splittedWidget) && this.isFirstLineFitForRow(bottom, rowWidget)) ? this.getSplittedWidgetForRow(bottom, tableCollection, [rowWidget], rowWidget) : rowWidget;
                }
                if (!isNullOrUndefined(splittedRow)) {
                    if (i === 0 && splittedRow === rowWidget) {
                        //Returns if the whole table does not fit in current page.
                        return tableWidget;
                    }
                    if (tableWidget.childWidgets.indexOf(splittedRow) !== -1) {
                        tableWidget.childWidgets.splice(tableWidget.childWidgets.indexOf(splittedRow), 1);
                        i--;
                        tableWidget.height -= splittedRow.height;
                    }
                    else {
                        tableWidget.height -= rowHeight - rowWidget.height;
                    }
                    if (isNullOrUndefined(splittedWidget)) {
                        //Creates new widget, to hold the splitted contents.
                        splittedWidget = this.createTableWidget(tableWidget);
                        this.updateWidgetLocation(tableWidget, splittedWidget);
                        splittedWidget.height = splittedRow.height;
                    }
                    else {
                        splittedWidget.height += splittedRow.height;
                    }
                    splittedWidget.childWidgets.push(splittedRow);
                    splittedRow.containerWidget = splittedWidget;
                }
            }
            rowBottom += rowWidget.height;
        }
        return splittedWidget;
    };
    /**
     * Checks whether first line fits for paragraph or not.
     * @param bottom
     * @param paraWidget
     */
    Layout.prototype.isFirstLineFitForPara = function (bottom, paraWidget) {
        var lineWidget = paraWidget.childWidgets[0];
        var cellwidget = lineWidget.paragraph.containerWidget;
        // let document: WordDocument = undefined;
        // if (!isNullOrUndefined(lineWidget.paragraph.currentNode) && !isNullOrUndefined(cellwidget.containerWidget)) {
        //     document = WordDocument.getDocumentOf(lineWidget.paragraph.currentNode);
        // }
        //checks first line of the page is exceed the page height
        if (this.viewer.isFirstLineFitInShiftWidgets) {
            if (this.viewer.clientActiveArea.y === this.viewer.clientArea.y && paraWidget.y + lineWidget.height >= bottom) {
                return true;
            }
        }
        else {
            // For nested tables,
            if (cellwidget.ownerTable.isInsideTable) {
                // Gets the container cell widgets, consider it as client area for the cell widget.
                var containerCellWidget = undefined;
                if (cellwidget.containerWidget instanceof TableRowWidget &&
                    cellwidget.containerWidget.containerWidget instanceof TableWidget
                    && cellwidget.containerWidget.containerWidget.containerWidget instanceof TableCellWidget) {
                    containerCellWidget = cellwidget.containerWidget.containerWidget.containerWidget;
                }
                if (!isNullOrUndefined(containerCellWidget) && cellwidget.containerWidget.y === containerCellWidget.y
                    && paraWidget.y + lineWidget.height >= bottom) {
                    return true;
                }
            }
            else if (cellwidget.containerWidget.y === this.viewer.clientArea.y && paraWidget.y + lineWidget.height >= bottom) {
                return true;
            }
        }
        return (paraWidget.y + lineWidget.height <= bottom);
    };
    /**
     * Checks whether first line fits for table or not.
     * @param bottom
     * @param tableWidget
     * @private
     */
    Layout.prototype.isFirstLineFitForTable = function (bottom, tableWidget) {
        var rowWidget = undefined;
        var isFit = false;
        var childWidget = tableWidget.childWidgets[0];
        // if (childWidget instanceof TableRowWidget) {
        rowWidget = childWidget;
        // }
        if (!isNullOrUndefined(rowWidget)) {
            isFit = this.isFirstLineFitForRow(bottom, rowWidget);
        }
        return isFit;
    };
    /**
     * Checks whether first line fits for row or not.
     * @param bottom
     * @param rowWidget
     */
    Layout.prototype.isFirstLineFitForRow = function (bottom, rowWidget) {
        for (var i = 0; i < rowWidget.childWidgets.length; i++) {
            var cellWidget = rowWidget.childWidgets[i];
            if (!this.isFirstLineFitForCell(bottom, cellWidget)) {
                return false;
            }
        }
        return true;
    };
    /**
     * Checks whether first line fits for cell or not.
     * @param bottom
     * @param cellWidget
     */
    Layout.prototype.isFirstLineFitForCell = function (bottom, cellWidget) {
        if (cellWidget.childWidgets.length === 0) {
            return true;
        }
        if (cellWidget.childWidgets[0] instanceof ParagraphWidget) {
            var paraWidget = cellWidget.childWidgets[0];
            return this.isFirstLineFitForPara(bottom - cellWidget.margin.bottom, paraWidget);
        }
        else {
            var tableWidget = cellWidget.childWidgets[0];
            return this.isFirstLineFitForTable(bottom - cellWidget.margin.bottom, tableWidget);
        }
    };
    /**
     * Updates widget location.
     * @param widget
     * @param table
     */
    Layout.prototype.updateWidgetLocation = function (widget, table) {
        table.x = widget.x;
        table.y = widget.y;
        table.width = widget.width;
    };
    /**
     * Updates child location for table.
     * @param top
     * @param tableWidget
     * @private
     */
    Layout.prototype.updateChildLocationForTable = function (top, tableWidget) {
        for (var i = 0; i < tableWidget.childWidgets.length; i++) {
            var rowWidget = tableWidget.childWidgets[i];
            rowWidget.x = rowWidget.x;
            rowWidget.y = top;
            this.updateChildLocationForRow(top, rowWidget);
            top += rowWidget.height;
        }
    };
    /**
     * Updates child location for row.
     * @param top
     * @param rowWidget
     * @private
     */
    Layout.prototype.updateChildLocationForRow = function (top, rowWidget) {
        var spacing = 0;
        if (rowWidget.ownerTable.tableFormat.cellSpacing > 0) {
            spacing = HelperMethods.convertPointToPixel(rowWidget.ownerTable.tableFormat.cellSpacing);
        }
        for (var i = 0; i < rowWidget.childWidgets.length; i++) {
            var cellWidget = rowWidget.childWidgets[i];
            cellWidget.x = cellWidget.x;
            cellWidget.y = top + cellWidget.margin.top + spacing;
            this.updateChildLocationForCell(cellWidget.y, cellWidget);
        }
    };
    /**
     * Updates child location for cell.
     * @param top
     * @param cellWidget
     */
    Layout.prototype.updateChildLocationForCell = function (top, cellWidget) {
        for (var i = 0; i < cellWidget.childWidgets.length; i++) {
            cellWidget.childWidgets[i].x = cellWidget.childWidgets[i].x;
            cellWidget.childWidgets[i].y = top;
            if (cellWidget.childWidgets[i] instanceof TableWidget) {
                this.updateChildLocationForTable(top, cellWidget.childWidgets[i]);
            }
            top += cellWidget.childWidgets[i].height;
        }
    };
    /**
     * Updates cell vertical position.
     * @param cellWidget
     * @param isUpdateToTop
     * @param isInsideTable
     * @private
     */
    Layout.prototype.updateCellVerticalPosition = function (cellWidget, isUpdateToTop, isInsideTable) {
        if (cellWidget.ownerTable.containerWidget instanceof BodyWidget || isInsideTable) {
            var displacement = this.getDisplacement(cellWidget, isUpdateToTop);
            //Update Y position alone for the child widget of cell
            this.updateCellContentVerticalPosition(cellWidget, displacement, isUpdateToTop);
        }
    };
    /**
     * Updates cell content vertical position.
     * @param cellWidget
     * @param displacement
     * @param isUpdateToTop
     */
    Layout.prototype.updateCellContentVerticalPosition = function (cellWidget, displacement, isUpdateToTop) {
        if (displacement === 0) {
            return;
        }
        var location = cellWidget.y + displacement;
        for (var i = 0; i < cellWidget.childWidgets.length; i++) {
            if (cellWidget.childWidgets[i] instanceof ParagraphWidget) {
                cellWidget.childWidgets[i].y = location;
            }
            else {
                location = this.updateTableWidgetLocation(cellWidget.childWidgets[i], location, isUpdateToTop);
            }
            location = location + cellWidget.childWidgets[i].height;
        }
    };
    /**
     * Updates table widget location.
     * @param tableWidget
     * @param location
     * @param isUpdateToTop
     */
    Layout.prototype.updateTableWidgetLocation = function (tableWidget, location, isUpdateToTop) {
        tableWidget.y = location = location + tableWidget.topBorderWidth;
        var cellSpacing = 0;
        for (var i = 0; i < tableWidget.childWidgets.length; i++) {
            var rowWidget = tableWidget.childWidgets[i];
            rowWidget.y = location;
            for (var j = 0; j < rowWidget.childWidgets.length; j++) {
                var cellWidget = rowWidget.childWidgets[j];
                cellWidget.y = location + cellWidget.margin.top + cellSpacing;
                this.updateCellVerticalPosition(cellWidget, isUpdateToTop, true);
            }
            location = location + rowWidget.height;
        }
        return location;
    };
    /**
     * Gets displacement.
     * @param cellWidget
     * @param isUpdateToTop
     */
    Layout.prototype.getDisplacement = function (cellWidget, isUpdateToTop) {
        //Gets the height of row
        var rowHeight = 0;
        var rowWidget = cellWidget.containerWidget;
        var padding = cellWidget.margin.top + cellWidget.margin.bottom;
        if (!isNullOrUndefined(cellWidget.cellFormat) && cellWidget.cellFormat.rowSpan > 1) {
            rowHeight = cellWidget.height;
        }
        else {
            rowHeight = ((!isNullOrUndefined(rowWidget) ? rowWidget.height : 0) - padding);
        }
        //Gets the height of content within the cell
        var cellContentHeight = this.getCellContentHeight(cellWidget);
        //Displacement field holds the value which has reduced from rowHeight and cellContentHeight
        var displacement = 0;
        if (rowHeight > cellContentHeight) {
            displacement = rowHeight - cellContentHeight;
            if (cellWidget.cellFormat.verticalAlignment === 'Center') {
                displacement = displacement / 2;
            }
            else if ((cellWidget.cellFormat.verticalAlignment === 'Top' || isUpdateToTop)) {
                displacement = 0;
            }
        }
        return displacement;
    };
    /**
     * Gets cell content height.
     * @param cellWidget
     */
    Layout.prototype.getCellContentHeight = function (cellWidget) {
        if (isNullOrUndefined(cellWidget.childWidgets)) {
            return 0;
        }
        var contentHeight = 0;
        for (var i = 0; i < cellWidget.childWidgets.length; i++) {
            if (cellWidget.childWidgets[i] instanceof ParagraphWidget) {
                contentHeight += cellWidget.childWidgets[i].height;
            }
            else {
                contentHeight += cellWidget.childWidgets[i].height;
            }
        }
        return contentHeight;
    };
    /**
     * Gets table left borders.
     * @param borders
     * @private
     */
    Layout.prototype.getTableLeftBorder = function (borders) {
        if (!isNullOrUndefined(borders.left)) {
            return borders.left;
        }
        else {
            var border = new WBorder(borders);
            border.lineStyle = 'Single';
            border.lineWidth = 0.66;
            return border;
        }
    };
    /**
     * Gets table right border.
     * @param borders
     * @private
     */
    Layout.prototype.getTableRightBorder = function (borders) {
        if (!isNullOrUndefined(borders.right)) {
            return borders.right;
        }
        else {
            var border = new WBorder(borders);
            border.lineStyle = 'Single';
            border.lineWidth = 0.66;
            return border;
        }
    };
    /**
     * Get table top border.
     * @param borders
     * @private
     */
    Layout.prototype.getTableTopBorder = function (borders) {
        if (!isNullOrUndefined(borders.top)) {
            return borders.top;
        }
        else {
            var border = new WBorder(borders);
            border.lineStyle = 'Single';
            border.lineWidth = 0.66;
            return border;
        }
    };
    /**
     * Gets table bottom border.
     * @param borders
     * @private
     */
    Layout.prototype.getTableBottomBorder = function (borders) {
        if (!isNullOrUndefined(borders.bottom)) {
            return borders.bottom;
        }
        else {
            var border = new WBorder(borders);
            border.lineStyle = 'Single';
            border.lineWidth = 0.66;
            return border;
        }
    };
    /**
     * Get diagonal cell up border.
     * @param tableCell
     * @private
     */
    Layout.prototype.getCellDiagonalUpBorder = function (tableCell) {
        var diagonalUpBorder = undefined;
        var cellBorder = undefined;
        cellBorder = tableCell.cellFormat.borders;
        diagonalUpBorder = cellBorder.diagonalUp;
        return diagonalUpBorder;
    };
    /**
     * Gets diagonal cell down border
     * @param tableCell
     * @private
     */
    Layout.prototype.getCellDiagonalDownBorder = function (tableCell) {
        var diagonalDownBorder = undefined;
        var cellBorder = undefined;
        cellBorder = tableCell.cellFormat.borders;
        diagonalDownBorder = cellBorder.diagonalDown;
        return diagonalDownBorder;
    };
    /**
     * Gets table width.
     * @param table
     * @private
     */
    Layout.prototype.getTableWidth = function (table) {
        var width = 0;
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            var rowWidth = 0;
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                rowWidth += HelperMethods.convertPointToPixel(cell.cellFormat.cellWidth);
            }
            if (width < rowWidth) {
                width = rowWidth;
            }
        }
        return width;
    };
    //#region shifting
    /**
     * @private
     */
    Layout.prototype.layoutNextItemsBlock = function (blockAdv, viewer) {
        var sectionIndex = blockAdv.bodyWidget.sectionIndex;
        var block = blockAdv;
        var splittedWidget = block.getSplitWidgets();
        var nextBlock = splittedWidget[splittedWidget.length - 1].nextRenderedWidget;
        if (isNullOrUndefined(nextBlock) || this.viewer.blockToShift === block) {
            this.viewer.blockToShift = undefined;
        }
        var updateNextBlockList = true;
        while (nextBlock instanceof BlockWidget && nextBlock.bodyWidget.sectionIndex === sectionIndex) {
            var currentWidget = undefined;
            var blocks = block.getSplitWidgets();
            currentWidget = blocks[blocks.length - 1];
            // if (viewer.fieldEndParagraph === block) {
            //     //Sets field end paragraph to undefined, inorder to hold reLayouting with this paragraph.
            //     viewer.fieldEndParagraph = undefined;
            // }
            block = nextBlock;
            if (viewer.blockToShift === block) {
                viewer.blockToShift = undefined;
            }
            updateNextBlockList = false;
            var nextWidget = undefined;
            nextWidget = block.getSplitWidgets()[0];
            // tslint:disable-next-line:max-line-length
            if (viewer.fieldStacks.length === 0 && !isNullOrUndefined(nextWidget) && currentWidget.containerWidget === nextWidget.containerWidget
                && (HelperMethods.round(nextWidget.y, 2) === HelperMethods.round(currentWidget.y + currentWidget.height, 2))) {
                if (!isNullOrUndefined(viewer.blockToShift)) {
                    viewer.blockToShift = block;
                }
                break;
            }
            updateNextBlockList = true;
            if (viewer.owner.isShiftingEnabled && viewer.fieldStacks.length === 0) {
                viewer.blockToShift = block;
                break;
            }
            else if (isNullOrUndefined(this.viewer.owner.editorModule) || !this.viewer.owner.editorModule.isInsertingTOC) {
                block = block.combineWidget(this.viewer);
                var paragraph = void 0;
                if (currentWidget.containerWidget !== block.containerWidget) {
                    if (!(currentWidget instanceof ParagraphWidget) ||
                        (currentWidget instanceof ParagraphWidget) && !currentWidget.isEndsWithPageBreak) {
                        // tslint:disable-next-line:max-line-length
                        this.updateContainerWidget(block, currentWidget.containerWidget, currentWidget.indexInOwner + 1, false);
                    }
                }
                if (block instanceof TableWidget) {
                    this.clearTableWidget(block, true, true);
                    block.isGridUpdated = false;
                    paragraph = this.viewer.selection.getFirstParagraphInFirstCell(block);
                }
                else {
                    paragraph = block;
                }
                if ((this.viewer.owner.isDocumentLoaded) && this.viewer.owner.editorModule) {
                    this.viewer.owner.editorModule.updateWholeListItems(paragraph);
                }
                viewer.updateClientAreaForBlock(block, true);
                this.viewer.layout.layoutBlock(block, 0);
                viewer.updateClientAreaForBlock(block, false);
            }
            splittedWidget = nextBlock.getSplitWidgets();
            nextBlock = splittedWidget[splittedWidget.length - 1].nextRenderedWidget;
        }
        if (!viewer.owner.isShiftingEnabled || (this.viewer.blockToShift !== block)) {
            this.viewer.owner.editorModule.updateListItemsTillEnd(block, updateNextBlockList);
        }
    };
    /**
     * @private
     */
    Layout.prototype.updateClientAreaForLine = function (paragraph, startLineWidget, elementIndex) {
        //Clears the line widget starting from current line.
        var top = this.viewer.selection.getTop(startLineWidget);
        var left = this.viewer.clientArea.x;
        this.viewer.cutFromTop(top);
        this.viewer.cutFromLeft(left);
    };
    /**
     * @private
     */
    Layout.prototype.getParentTable = function (block) {
        var widget = block;
        while (widget.containerWidget) {
            if (widget.containerWidget instanceof BlockContainer) {
                return widget;
            }
            widget = widget.containerWidget;
        }
        return undefined;
    };
    /**
     * @private
     */
    Layout.prototype.reLayoutParagraph = function (paragraphWidget, lineIndex, elementBoxIndex, isBidi) {
        isBidi = isNullOrUndefined(isBidi) ? false : isBidi;
        if (this.viewer.blockToShift === paragraphWidget) {
            this.layoutBodyWidgetCollection(paragraphWidget.index, paragraphWidget.containerWidget, paragraphWidget, false);
            this.isBidiReLayout = true;
        }
        else {
            if (this.isBidiReLayout) {
                this.isBidiReLayout = false;
            }
        }
        // let isElementMoved: boolean = elementBoxIndex > 0;
        if (paragraphWidget.isInsideTable) {
            this.isBidiReLayout = true;
            this.reLayoutTable(paragraphWidget);
            this.isBidiReLayout = false;
        }
        else {
            this.reLayoutLine(paragraphWidget, lineIndex, isBidi);
        }
        if (paragraphWidget.bodyWidget instanceof HeaderFooterWidget &&
            paragraphWidget.bodyWidget.headerFooterType.indexOf('Footer') !== -1) {
            this.shiftFooterChildLocation(paragraphWidget.bodyWidget, this.viewer);
        }
    };
    /**
     * @private
     */
    Layout.prototype.reLayoutTable = function (block) {
        //Get Top level owner of block
        var table = this.getParentTable(block);
        //Combine splitted table in to single table
        var currentTable = table.combineWidget(this.viewer);
        var bodyWidget = currentTable.containerWidget;
        if (this.viewer.owner.enableHeaderAndFooter || block.isInHeaderFooter) {
            block.bodyWidget.isEmpty = false;
            bodyWidget.height -= currentTable.height;
            // tslint:disable-next-line:max-line-length
            this.viewer.updateHCFClientAreaWithTop(table.bodyWidget.sectionFormat, this.viewer.isBlockInHeader(table), bodyWidget.page);
        }
        else {
            this.viewer.updateClientArea(bodyWidget.sectionFormat, bodyWidget.page);
        }
        //Clear Hieght for all the content 
        if (this.viewer.owner.isDocumentLoaded && this.viewer.owner.editorModule) {
            var block_1 = this.viewer.selection.getFirstParagraphInFirstCell(currentTable);
            this.viewer.owner.editorModule.updateWholeListItems(block_1);
        }
        this.viewer.updateClientAreaForBlock(currentTable, true);
        //Remove border width
        currentTable.x -= currentTable.leftBorderWidth;
        currentTable.y -= currentTable.topBorderWidth;
        //Update Client area for current position
        this.viewer.cutFromTop(currentTable.y);
        this.clearTableWidget(currentTable, true, true, true);
        this.layoutBlock(currentTable, 0, true);
        this.viewer.updateClientAreaForBlock(currentTable, false);
        this.layoutNextItemsBlock(currentTable, this.viewer);
    };
    /**
     * @private
     */
    Layout.prototype.clearTableWidget = function (table, clearPosition, clearHeight, clearGrid) {
        table.height = 0;
        if (clearGrid) {
            table.isGridUpdated = false;
        }
        if (clearPosition) {
            table.y = 0;
            table.x = 0;
        }
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            this.clearRowWidget(row, clearPosition, clearHeight, clearGrid);
        }
    };
    /**
     * @private
     */
    Layout.prototype.clearRowWidget = function (row, clearPosition, clearHeight, clearGrid) {
        row.height = 0;
        if (clearPosition) {
            row.y = 0;
            row.x = 0;
        }
        for (var i = 0; i < row.childWidgets.length; i++) {
            var cell = row.childWidgets[i];
            this.clearCellWidget(cell, clearPosition, clearHeight, clearGrid);
        }
    };
    /**
     * @private
     */
    Layout.prototype.clearCellWidget = function (cell, clearPosition, clearHeight, clearGrid) {
        cell.height = 0;
        if (clearPosition) {
            cell.y = 0;
            cell.x = 0;
        }
        for (var i = 0; i < cell.childWidgets.length; i++) {
            var block = cell.childWidgets[i];
            if (block instanceof ParagraphWidget) {
                if (clearHeight) {
                    block.height = 0;
                }
            }
            else {
                this.clearTableWidget(block, clearPosition, clearHeight, clearGrid);
            }
        }
    };
    /**
     * @param blockIndex
     * @param bodyWidget
     * @param block
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.layoutBodyWidgetCollection = function (blockIndex, bodyWidget, block, shiftNextWidget, isSkipShifting) {
        if (!isNullOrUndefined(this.viewer.owner)
            && this.viewer.owner.isLayoutEnabled) {
            if (bodyWidget instanceof BlockContainer) {
                var curretBlock = this.checkAndGetBlock(bodyWidget, blockIndex);
                if (isNullOrUndefined(curretBlock)) {
                    return;
                }
                if (bodyWidget instanceof HeaderFooterWidget) {
                    bodyWidget.isEmpty = false;
                    // tslint:disable-next-line:max-line-length
                    this.viewer.updateHCFClientAreaWithTop(bodyWidget.sectionFormat, bodyWidget.headerFooterType.indexOf('Header') !== -1, bodyWidget.page);
                    curretBlock.containerWidget.height -= curretBlock.height;
                }
                else {
                    this.viewer.updateClientArea(bodyWidget.sectionFormat, bodyWidget.page);
                }
                if (blockIndex > 0) {
                    var prevWidget = curretBlock.getSplitWidgets()[0].previousRenderedWidget;
                    if (!(prevWidget instanceof ParagraphWidget) ||
                        (prevWidget instanceof ParagraphWidget) && !prevWidget.isEndsWithPageBreak) {
                        this.viewer.cutFromTop(prevWidget.y + prevWidget.height);
                        if (isNullOrUndefined(isSkipShifting) && curretBlock.containerWidget !== prevWidget.containerWidget) {
                            // tslint:disable-next-line:max-line-length
                            this.updateContainerWidget(curretBlock, prevWidget.containerWidget, prevWidget.indexInOwner + 1, false);
                        }
                    }
                    else if (prevWidget instanceof ParagraphWidget && prevWidget.isEndsWithPageBreak &&
                        prevWidget.containerWidget === curretBlock.containerWidget) {
                        this.moveBlocksToNextPage(prevWidget);
                    }
                }
                var currentParagraph = void 0;
                curretBlock = curretBlock.combineWidget(this.viewer);
                if (curretBlock instanceof TableWidget) {
                    this.clearTableWidget(curretBlock, true, true);
                    curretBlock.isGridUpdated = false;
                    currentParagraph = this.viewer.selection.getFirstParagraphInFirstCell(curretBlock);
                }
                else {
                    currentParagraph = curretBlock;
                }
                if ((this.viewer.owner.isDocumentLoaded) && this.viewer.owner.editorModule) {
                    this.viewer.owner.editorModule.updateWholeListItems(currentParagraph);
                }
                this.viewer.updateClientAreaForBlock(curretBlock, true);
                this.viewer.layout.layoutBlock(curretBlock, 0, true);
                this.viewer.updateClientAreaForBlock(curretBlock, false);
                if (shiftNextWidget) {
                    this.shiftNextWidgets(curretBlock);
                }
                else {
                    this.layoutNextItemsBlock(curretBlock, this.viewer);
                }
            }
            else if (bodyWidget instanceof TableCellWidget) {
                var table = this.viewer.layout.getParentTable(bodyWidget.ownerTable).getSplitWidgets()[0];
                this.reLayoutTable(bodyWidget.ownerTable);
                this.layoutNextItemsBlock(table, this.viewer);
            }
        }
    };
    Layout.prototype.checkAndGetBlock = function (containerWidget, blockIndex) {
        var sectionIndex = containerWidget.index;
        while (containerWidget && containerWidget.index === sectionIndex) {
            if (containerWidget.childWidgets.length > 0 && containerWidget.firstChild.index <= blockIndex &&
                containerWidget.lastChild.index >= blockIndex) {
                for (var i = 0; i < containerWidget.childWidgets.length; i++) {
                    var block = containerWidget.childWidgets[i];
                    if (block.index === blockIndex) {
                        return block;
                    }
                }
            }
            if (containerWidget instanceof BodyWidget) {
                containerWidget = containerWidget.nextRenderedWidget;
            }
            else {
                break;
            }
        }
        return undefined;
    };
    //#endregion
    //#region Table
    /**
     * Layouts table.
     * @param table
     * @private
     */
    Layout.prototype.layoutTable = function (table, startIndex) {
        table.isBidiTable = table.bidi;
        if (!table.isGridUpdated) {
            table.buildTableColumns();
            table.isGridUpdated = true;
        }
        var tableView = [table];
        this.addTableWidget(this.viewer.clientActiveArea, tableView);
        this.viewer.updateClientAreaTopOrLeft(table, true);
        var isHeader = table.childWidgets[0].rowFormat.isHeader;
        if (table.childWidgets.length > 0) {
            table.header = isHeader;
            table.continueHeader = isHeader;
            table.headerHeight = 0;
        }
        var row = table.childWidgets[startIndex];
        while (row) {
            row = this.layoutRow(tableView, row);
            row = row.nextRow;
        }
        this.updateWidgetsToPage(tableView, [], table);
        return tableView[tableView.length - 1];
    };
    /**
     * Adds table widget.
     * @param area
     * @param table
     * @private
     */
    Layout.prototype.addTableWidget = function (area, table, create) {
        var tableWidget = table[table.length - 1];
        if (create) {
            tableWidget = this.createTableWidget(tableWidget);
            table.push(tableWidget);
        }
        tableWidget.width = area.width;
        tableWidget.x = area.x;
        tableWidget.y = area.y;
        //Update the table height of tableWidget when cell spacing has been defined. 
        if (tableWidget.tableFormat.cellSpacing > 0) {
            tableWidget.height = tableWidget.height + HelperMethods.convertPointToPixel(tableWidget.tableFormat.cellSpacing);
            if (!tableWidget.isBidiTable) {
                // tslint:disable-next-line:max-line-length
                tableWidget.leftBorderWidth = HelperMethods.convertPointToPixel(this.getTableLeftBorder(tableWidget.tableFormat.borders).getLineWidth());
                tableWidget.rightBorderWidth = HelperMethods.convertPointToPixel(this.getTableRightBorder(tableWidget.tableFormat.borders).getLineWidth());
            }
            else { // Right to left direction table.
                // tslint:disable-next-line:max-line-length
                tableWidget.leftBorderWidth = HelperMethods.convertPointToPixel(this.getTableRightBorder(tableWidget.tableFormat.borders).getLineWidth());
                tableWidget.rightBorderWidth = HelperMethods.convertPointToPixel(this.getTableLeftBorder(tableWidget.tableFormat.borders).getLineWidth());
            }
            // tslint:disable-next-line:max-line-length
            tableWidget.topBorderWidth = HelperMethods.convertPointToPixel(this.getTableTopBorder(tableWidget.tableFormat.borders).getLineWidth());
            tableWidget.bottomBorderWidth = HelperMethods.convertPointToPixel(this.getTableBottomBorder(tableWidget.tableFormat.borders).getLineWidth());
            tableWidget.x += tableWidget.leftBorderWidth;
            tableWidget.y += tableWidget.topBorderWidth;
            tableWidget.width -= tableWidget.leftBorderWidth;
            tableWidget.width -= tableWidget.rightBorderWidth;
            tableWidget.height += tableWidget.bottomBorderWidth;
        }
        return tableWidget;
    };
    /**
     * Updates widget to page.
     * @param table
     * @private
     */
    Layout.prototype.updateWidgetsToPage = function (tables, rows, table, endRowWidget) {
        var viewer = this.viewer;
        var tableWidget = tables[tables.length - 1];
        if (!table.isInsideTable) {
            for (var i = 0; i < tables.length; i++) {
                this.updateHeightForTableWidget(tables, rows, tables[i], endRowWidget);
            }
            if (tableWidget.childWidgets.length > 0 && tableWidget.y !== tableWidget.childWidgets[0].y) {
                tableWidget.y = tableWidget.childWidgets[0].y;
            }
            // Need to update on this further
            //Adds the table widget to owner cell widget.
            // tslint:disable-next-line:max-line-length
            // (viewer.renderedElements.get(table.associatedCell)[viewer.renderedElements.get(table.associatedCell).length - 1] as TableCellWidget).childWidgets.push(tableWidget);
            // tableWidget.containerWidget = viewer.renderedElements.get(table.associatedCell)[viewer.renderedElements.get(table.associatedCell).length - 1] as BodyWidget;
            // tslint:disable-next-line:max-line-length
            // (viewer.renderedElements.get(table.associatedCell)[viewer.renderedElements.get(table.associatedCell).length - 1] as TableCellWidget).height = (viewer.renderedElements.get(table.associatedCell)[viewer.renderedElements.get(table.associatedCell).length - 1] as TableCellWidget).height + tableWidget.height;
        }
        if (table.tableFormat.cellSpacing > 0) {
            // tslint:disable-next-line:max-line-length
            if (tableWidget.y + tableWidget.height + HelperMethods.convertPointToPixel(table.tableFormat.cellSpacing) > viewer.clientArea.bottom && viewer instanceof PageLayoutViewer) {
                //update the table height when split to next page. Which is equivalent Ms Word Behaviour. 
                //In Ms Word if the Table Split to next page the bottom spacing of the table will be half of the current spacing.
                //And the Remaining space will be used in next page top of the table.
                tableWidget.height = tableWidget.height - HelperMethods.convertPointToPixel(table.tableFormat.cellSpacing) / 2;
            }
            //Update the current Y position of current clientactivearea.
            viewer.cutFromTop(tableWidget.y + tableWidget.height);
        }
        if (table.bodyWidget instanceof HeaderFooterWidget) {
            table.containerWidget.height += table.height;
            if (this.viewer.owner.enableHeaderAndFooter && table.bodyWidget.headerFooterType.indexOf('Footer') !== -1) {
                this.shiftFooterChildLocation(table.bodyWidget, this.viewer);
            }
        }
    };
    /**
     * Updates height for table widget.
     * @param viewer
     * @param tableWidget
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Layout.prototype.updateHeightForTableWidget = function (tables, rows, tableWidget, endRowWidget) {
        for (var i = 0; i < tableWidget.childWidgets.length; i++) {
            var rowWidget = tableWidget.childWidgets[i];
            if (rowWidget === endRowWidget) {
                break;
            }
            this.updateHeightForRowWidget(this.viewer, true, tables, rows, rowWidget, true, endRowWidget);
        }
    };
    //#endregion
    //#region Row
    /**
     * Layouts table row.
     * @param row
     * @private
     */
    Layout.prototype.layoutRow = function (tableWidget, row) {
        var viewer = this.viewer;
        var rowWidgets = [row];
        var widget = this.addTableRowWidget(viewer.clientActiveArea, rowWidgets);
        viewer.updateClientAreaForRow(row, true);
        var topMargin = this.getMaxTopCellMargin(row);
        var bottomMargin = this.getMaxBottomCellMargin(row);
        for (var i = 0; i < row.childWidgets.length; i++) {
            var cell = row.childWidgets[i];
            // tslint:disable-next-line:max-line-length
            this.layoutCell(cell, topMargin + row.topBorderWidth, bottomMargin + row.bottomBorderWidth, widget);
        }
        viewer.updateClientAreaForRow(row, false);
        var rows = [row];
        this.updateWidgetsToTable(tableWidget, rows, row);
        return rows[rows.length - 1];
    };
    /**
     * @param area
     * @param row
     */
    Layout.prototype.addTableRowWidget = function (area, row) {
        var rowWidget = row[row.length - 1];
        rowWidget.x = area.x + rowWidget.rowFormat.gridBeforeWidth;
        rowWidget.y = area.y;
        rowWidget.width = area.width;
        var borderWidth = 0;
        if (!isNullOrUndefined(rowWidget.ownerTable) && !isNullOrUndefined(rowWidget.ownerTable.tableFormat)
            && rowWidget.ownerTable.tableFormat.cellSpacing > 0) {
            rowWidget.height = rowWidget.height + HelperMethods.convertPointToPixel(rowWidget.ownerTable.tableFormat.cellSpacing);
            //Update the table height with the border width to layout the border when the cell spacing is defined..
            for (var j = 0; j < rowWidget.childWidgets.length; j++) {
                if (!isNullOrUndefined(rowWidget.childWidgets[j].cellFormat)
                    && !isNullOrUndefined(rowWidget.childWidgets[j].cellFormat.borders)) {
                    // tslint:disable-next-line:max-line-length
                    var width = TableCellWidget.getCellBottomBorder(rowWidget.childWidgets[j]).getLineWidth();
                    if (width > borderWidth) {
                        borderWidth = width;
                    }
                }
            }
            //Maximum border width is calculated and hold it in a variable to add with the padding of the cells.
            rowWidget.bottomBorderWidth = HelperMethods.convertPointToPixel(borderWidth);
            if (rowWidget.index > 0 && !isNullOrUndefined(rowWidget.previousWidget)) {
                var prevRow = rowWidget.previousWidget;
                borderWidth = 0;
                for (var i = 0; i < prevRow.childWidgets.length; i++) {
                    // tslint:disable-next-line:max-line-length
                    if (!isNullOrUndefined(prevRow.childWidgets[i].cellFormat) && !isNullOrUndefined(prevRow.childWidgets[i].cellFormat.borders)) {
                        var value = TableCellWidget.getCellBottomBorder(prevRow.childWidgets[i]).getLineWidth();
                        if (value > borderWidth) {
                            borderWidth = value;
                        }
                    }
                }
                //Maximum border width is calculated and hold it in a variable to add with the padding of the cells.
                rowWidget.topBorderWidth = HelperMethods.convertPointToPixel(borderWidth);
            }
        }
        if (!isNullOrUndefined(rowWidget.childWidgets)) {
            for (var i = 0; i < rowWidget.childWidgets.length; i++) {
                // tslint:disable-next-line:max-line-length
                if (!isNullOrUndefined(rowWidget.childWidgets[i].cellFormat) && !isNullOrUndefined(rowWidget.childWidgets[i].cellFormat.borders)) {
                    var value = TableCellWidget.getCellTopBorder(rowWidget.childWidgets[i]).getLineWidth();
                    if (value > borderWidth) {
                        borderWidth = value;
                    }
                }
            }
        }
        //Maximum border width is calculated and hold it in a variable to add with the padding of the cells.
        rowWidget.topBorderWidth = HelperMethods.convertPointToPixel(borderWidth);
        //Update the table height of tableWidget when cell spacing has been defined. 
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(rowWidget.ownerTable) && !isNullOrUndefined(rowWidget.ownerTable.tableFormat) && rowWidget.ownerTable.tableFormat.cellSpacing <= 0 && rowWidget.rowIndex === rowWidget.ownerTable.childWidgets.length - 1) {
            // Update the bottom width for last row .
            for (var i = 0; i < rowWidget.childWidgets.length; i++) {
                // tslint:disable-next-line:max-line-length
                if (!isNullOrUndefined(rowWidget.childWidgets[i].cellFormat) && !isNullOrUndefined(rowWidget.childWidgets[i].cellFormat.borders)) {
                    var value = TableCellWidget.getCellBottomBorder(rowWidget.childWidgets[i]).getLineWidth();
                    if (value > borderWidth) {
                        borderWidth = value;
                    }
                }
            }
            //Maximum border width is calculated and hold it in a variable to add with the padding of the cells.
            rowWidget.bottomBorderWidth = HelperMethods.convertPointToPixel(borderWidth);
        }
        //tableRowWidget.ownerWidget = owner;
        return rowWidget;
    };
    /**
     * Gets maximum top cell margin.
     * @param row
     * @param topOrBottom
     */
    Layout.prototype.getMaxTopCellMargin = function (row) {
        if (isNullOrUndefined(row.childWidgets)) {
            return 0;
        }
        var value = 0;
        for (var i = 0; i < row.childWidgets.length; i++) {
            var cell = row.childWidgets[i];
            var topMargin = 0;
            if (cell.cellFormat.hasValue('topMargin')) {
                topMargin = HelperMethods.convertPointToPixel(cell.cellFormat.topMargin);
            }
            else if (row.rowFormat.hasValue('topMargin')) {
                topMargin = HelperMethods.convertPointToPixel(row.rowFormat.topMargin);
            }
            else {
                topMargin = HelperMethods.convertPointToPixel(row.ownerTable.tableFormat.topMargin);
            }
            if (topMargin > value) {
                value = topMargin;
            }
        }
        return value;
    };
    /**
     * Gets maximum bottom cell margin.
     * @param row
     * @param topOrBottom
     */
    Layout.prototype.getMaxBottomCellMargin = function (row) {
        if (isNullOrUndefined(row.childWidgets)) {
            return 0;
        }
        var value = 0;
        for (var i = 0; i < row.childWidgets.length; i++) {
            var cell = row.childWidgets[i];
            var bottomMargin = 0;
            if (cell.cellFormat.hasValue('bottomMargin')) {
                bottomMargin = HelperMethods.convertPointToPixel(cell.cellFormat.bottomMargin);
            }
            else if (row.rowFormat.hasValue('bottomMargin')) {
                bottomMargin = HelperMethods.convertPointToPixel(row.rowFormat.bottomMargin);
            }
            else {
                bottomMargin = HelperMethods.convertPointToPixel(row.ownerTable.tableFormat.bottomMargin);
            }
            if (bottomMargin > value) {
                value = bottomMargin;
            }
        }
        return value;
    };
    //#endregion Row
    //#region cell
    /**
     * Layouts cell
     * @param cell
     * @param maxCellMarginTop
     * @param maxCellMarginBottom
     */
    Layout.prototype.layoutCell = function (cell, maxCellMarginTop, maxCellMarginBottom, owner) {
        var viewer = this.viewer;
        this.addTableCellWidget(cell, viewer.clientActiveArea, maxCellMarginTop, maxCellMarginBottom);
        viewer.updateClientAreaForCell(cell, true);
        if (cell.childWidgets.length === 0) {
            var paragraphWidget = new ParagraphWidget();
            paragraphWidget.characterFormat = new WCharacterFormat();
            paragraphWidget.paragraphFormat = new WParagraphFormat();
            paragraphWidget.index = 0;
            var lineWidget = new LineWidget(undefined);
            paragraphWidget.childWidgets.push(lineWidget);
            cell.childWidgets.push(paragraphWidget);
        }
        for (var i = 0; i < cell.childWidgets.length; i++) {
            var block = cell.childWidgets[i];
            viewer.updateClientAreaForBlock(block, true);
            block.containerWidget = cell;
            this.layoutBlock(block, 0);
            viewer.updateClientAreaForBlock(block, false);
        }
        this.updateWidgetToRow(cell);
        viewer.updateClientAreaForCell(cell, false);
    };
    //endregion cell
    //#region Shifting
    /**
     * @private
     */
    Layout.prototype.shiftLayoutedItems = function () {
        if (isNullOrUndefined(this.viewer.blockToShift) || isNullOrUndefined(this.viewer.blockToShift.containerWidget)) {
            this.viewer.blockToShift = undefined;
            return;
        }
        var block = this.viewer.blockToShift;
        var sectionIndex = block.bodyWidget.index;
        this.reLayoutOrShiftWidgets(block, this.viewer);
        var updateNextBlockList = true;
        // If flow layout, then all sections are in single page. Hence need to update till last block of last section.
        // Todo: For page layout and section break continuous, need to handle the same.
        var splittedWidget = block.getSplitWidgets();
        var nextBlock = splittedWidget[splittedWidget.length - 1].nextRenderedWidget;
        while (nextBlock instanceof BlockWidget && nextBlock.bodyWidget.index === sectionIndex) {
            var currentWidget = undefined;
            var blocks = block.getSplitWidgets();
            currentWidget = blocks[blocks.length - 1];
            block = nextBlock;
            updateNextBlockList = false;
            var nextWidget = undefined;
            blocks = block.getSplitWidgets();
            if (block instanceof ParagraphWidget) {
                nextWidget = blocks[0];
            }
            else {
                if (block instanceof TableWidget) {
                    nextWidget = blocks[0];
                }
            }
            if (currentWidget.containerWidget === nextWidget.containerWidget
                && (HelperMethods.round(nextWidget.y, 2) === HelperMethods.round(this.viewer.clientActiveArea.y, 2)) &&
                isNullOrUndefined(nextWidget.nextWidget)) {
                break;
            }
            updateNextBlockList = true;
            this.reLayoutOrShiftWidgets(block, this.viewer);
            splittedWidget = block.getSplitWidgets();
            nextBlock = splittedWidget[splittedWidget.length - 1].nextRenderedWidget;
        }
        if (this.viewer.owner.editorModule) {
            this.viewer.owner.editorModule.updateListItemsTillEnd(block, updateNextBlockList);
        }
        this.viewer.blockToShift = undefined;
        var viewer = this.viewer;
        // if (viewer instanceof PageLayoutViewer) {
        viewer.removeEmptyPages();
        this.updateFieldElements();
        viewer.updateScrollBars();
        // }
    };
    /**
     * @private
     */
    Layout.prototype.updateFieldElements = function () {
        for (var i = 0; i < this.viewer.fields.length; i++) {
            var fieldBegin = this.viewer.fields[i];
            if (!isNullOrUndefined(this.viewer.selection)) {
                var fieldCode = this.viewer.selection.getFieldCode(fieldBegin);
                // tslint:disable-next-line:max-line-length
                if (!isNullOrUndefined(fieldCode) && (fieldCode.toLowerCase().match('numpages') || fieldCode.toLowerCase().match('sectionpages')) && !isNullOrUndefined(fieldBegin.fieldSeparator)) {
                    var textElement = fieldBegin.fieldSeparator.nextNode;
                    if (!isNullOrUndefined(textElement)) {
                        var prevPageNum = textElement.text;
                        textElement.text = this.viewer.pages.length.toString();
                        var paragraph = fieldBegin.line.paragraph;
                        if (!isNullOrUndefined(paragraph.bodyWidget) && !isNullOrUndefined(paragraph.bodyWidget.page)
                            && prevPageNum !== textElement.text) {
                            var lineIndex = paragraph.childWidgets.indexOf(fieldBegin.line);
                            var elementIndex = fieldBegin.line.children.indexOf(textElement);
                            this.reLayoutParagraph(paragraph, lineIndex, elementIndex);
                        }
                    }
                }
            }
        }
    };
    Layout.prototype.reLayoutOrShiftWidgets = function (blockAdv, viewer) {
        var block = blockAdv;
        // if (block instanceof ParagraphWidget) {
        //     reLayoutItems = viewer.renderedElements.get(block as ParagraphWidget).length === 0;
        // } else {
        //     reLayoutItems = viewer.renderedElements.get(block as TableWidget).length === 0;
        // }
        // if (reLayoutItems) {
        //     //Handle layouting the block.
        //     viewer.updateClientAreaForBlock(block, true);
        //     this.layoutMod.layoutBlock(block);
        //     viewer.updateClientAreaForBlock(block, false);
        // } else {
        //Handled to check client area and shift layouted widget.
        this.shiftWidgetsBlock(block, viewer);
        //Updates the list value of the rendered paragraph.
        if (this.viewer.owner.editorModule) {
            this.viewer.owner.editorModule.updateRenderedListItems(block);
        }
        // }
    };
    Layout.prototype.shiftWidgetsBlock = function (block, viewer) {
        if (block instanceof ParagraphWidget) {
            this.shiftWidgetsForPara(block, viewer);
        }
        else if (block instanceof TableWidget) {
            this.shiftWidgetsForTable(block, viewer);
        }
    };
    Layout.prototype.shiftWidgetsForPara = function (paragraph, viewer) {
        if (paragraph.height > viewer.clientArea.height) {
            return;
        }
        var prevBodyObj = this.getBodyWidgetOfPreviousBlock(paragraph, 0);
        var prevBodyWidget = prevBodyObj.bodyWidget;
        var index = prevBodyObj.index;
        var prevWidget = undefined;
        for (var i = 0; i < paragraph.getSplitWidgets().length; i++) {
            var widget = paragraph.getSplitWidgets()[i];
            if (!isNullOrUndefined(prevWidget)) {
                var isPageBreak = prevWidget.lastChild ? prevWidget.lastChild.isEndsWithPageBreak : false;
                this.shiftToPreviousWidget(widget, viewer, prevWidget, isPageBreak);
                if ((isNullOrUndefined(widget.childWidgets) || widget.childWidgets.length === 0) && !isPageBreak) {
                    i--;
                    continue;
                }
                prevWidget = undefined;
                if (prevBodyWidget !== widget.containerWidget) {
                    prevBodyWidget = widget.containerWidget;
                    if (isPageBreak) {
                        viewer.updateClientAreaByWidget(widget);
                    }
                }
            }
            if (this.isFitInClientArea(widget, viewer)) {
                //Check whether this widget is moved to previous container widget.
                prevWidget = widget;
                widget.y = viewer.clientActiveArea.y;
                viewer.cutFromTop(viewer.clientActiveArea.y + widget.height);
                //Moves the paragraph widget to previous body widget.
                if (!isNullOrUndefined(prevBodyWidget) && prevBodyWidget !== widget.containerWidget) {
                    index++;
                    if (!prevBodyWidget.lastChild.isEndsWithPageBreak) {
                        this.updateContainerWidget(widget, prevBodyWidget, index, true);
                    }
                }
                if (widget.isEndsWithPageBreak) {
                    var nextBodyWidget = this.createOrGetNextBodyWidget(prevBodyWidget, this.viewer);
                    nextBodyWidget = this.moveBlocksToNextPage(widget);
                    viewer.updateClientArea(nextBodyWidget.sectionFormat, nextBodyWidget.page);
                }
            }
            else {
                var previousBlock = widget.previousRenderedWidget;
                var isPageBreak = false;
                if (previousBlock instanceof ParagraphWidget && previousBlock.isEndsWithPageBreak) {
                    isPageBreak = true;
                }
                var isSplittedToNewPage = this.splitWidget(widget, viewer, prevBodyWidget, index + 1, isPageBreak);
                prevWidget = undefined;
                if (prevBodyWidget !== widget.containerWidget) {
                    prevBodyWidget = widget.containerWidget;
                    i--;
                }
                index = prevBodyWidget.childWidgets.indexOf(widget);
                if (isSplittedToNewPage) {
                    prevBodyWidget = paragraph.getSplitWidgets()[i + 1].containerWidget;
                }
            }
        }
    };
    /**
     * @private
     */
    Layout.prototype.shiftTableWidget = function (table, viewer) {
        var tables = [table];
        this.addTableWidget(this.viewer.clientActiveArea, tables);
        this.viewer.updateClientAreaTopOrLeft(table, true);
        var row = table.childWidgets[0];
        while (row) {
            row = this.shiftRowWidget(tables, row);
            row = row.nextRow;
        }
        this.updateWidgetsToPage(tables, [], table);
        return tables[tables.length - 1];
    };
    /**
     * @private
     */
    Layout.prototype.shiftRowWidget = function (tables, row) {
        var viewer = this.viewer;
        var rows = [row];
        var widget = this.addTableRowWidget(viewer.clientActiveArea, rows);
        viewer.updateClientAreaForRow(row, true);
        for (var i = 0; i < row.childWidgets.length; i++) {
            var cell = row.childWidgets[i];
            // tslint:disable-next-line:max-line-length
            this.shiftCellWidget(cell, this.getMaxTopCellMargin(row) + row.topBorderWidth, this.getMaxBottomCellMargin(row) + row.bottomBorderWidth);
        }
        viewer.updateClientAreaForRow(row, false);
        this.updateWidgetsToTable(tables, rows, row);
        return rows[rows.length - 1];
    };
    /**
     * @private
     */
    Layout.prototype.shiftCellWidget = function (cell, maxCellMarginTop, maxCellMarginBottom) {
        var viewer = this.viewer;
        this.addTableCellWidget(cell, viewer.clientActiveArea, maxCellMarginTop, maxCellMarginBottom);
        viewer.updateClientAreaForCell(cell, true);
        for (var i = 0; i < cell.childWidgets.length; i++) {
            var block = cell.childWidgets[i];
            viewer.updateClientAreaForBlock(block, true);
            if (block instanceof ParagraphWidget) {
                this.shiftParagraphWidget(block);
            }
            else {
                this.shiftTableWidget(block, viewer);
            }
            viewer.updateClientAreaForBlock(block, false);
        }
        this.updateWidgetToRow(cell);
        viewer.updateClientAreaForCell(cell, false);
    };
    /**
     * @private
     */
    Layout.prototype.shiftParagraphWidget = function (paragraph) {
        this.addParagraphWidget(this.viewer.clientActiveArea, paragraph);
        this.viewer.cutFromTop(this.viewer.clientActiveArea.y + paragraph.height);
        this.updateWidgetToPage(this.viewer, paragraph);
    };
    Layout.prototype.shiftWidgetsForTable = function (table, viewer) {
        var prevObj = this.getBodyWidgetOfPreviousBlock(table, 0);
        var prevBodyWidget = prevObj.bodyWidget;
        var index = prevObj.index;
        var isPageBreak = prevBodyWidget.lastChild.lastChild.isEndsWithPageBreak;
        if (prevBodyWidget !== table.containerWidget) {
            if (!isPageBreak) {
                this.updateContainerWidget(table, prevBodyWidget, index + 1, true);
            }
            else {
                viewer.updateClientArea(table.bodyWidget.sectionFormat, table.bodyWidget.page);
            }
        }
        if (table.isInHeaderFooter) {
            table.containerWidget.height -= table.height;
        }
        this.viewer.updateClientAreaForBlock(table, true);
        this.updateVerticalPositionToTop(table, true);
        var combinedTable = table.combineWidget(this.viewer);
        this.viewer.layout.updateChildLocationForTable(combinedTable.y, combinedTable);
        this.clearTableWidget(combinedTable, true, false);
        this.shiftTableWidget(combinedTable, this.viewer);
        this.updateVerticalPositionToTop(table, false);
    };
    Layout.prototype.updateVerticalPositionToTop = function (table, isUpdateTop) {
        //Iterate the tableWidgets counts
        for (var i = 0; i < table.getSplitWidgets().length; i++) {
            var tablewidget = table.getSplitWidgets()[i];
            //Iterate the tableWidget child items
            for (var j = 0; j < tablewidget.childWidgets.length; j++) {
                var rowWidget = tablewidget.childWidgets[j];
                //Iterate the RowWidgets child items
                for (var k = 0; k < rowWidget.childWidgets.length; k++) {
                    var cellWidget = rowWidget.childWidgets[k];
                    //Iterate the RowWidgets child items
                    this.viewer.layout.updateCellVerticalPosition(cellWidget, isUpdateTop, false);
                }
            }
        }
    };
    // tslint:disable-next-line:max-line-length
    Layout.prototype.splitWidget = function (paragraphWidget, viewer, previousBodyWidget, index, isPageBreak) {
        var firstLine = paragraphWidget.childWidgets[0];
        var maxElementHeight = this.getMaxElementHeight(firstLine, viewer);
        var paragraphView = paragraphWidget.getSplitWidgets();
        var nextBodyWidget = paragraphWidget.containerWidget;
        if (viewer.clientActiveArea.height >= maxElementHeight && !isPageBreak) {
            var splittedWidget = undefined;
            var widgetIndex = paragraphView.indexOf(paragraphWidget);
            if (widgetIndex < (paragraphView.length - 1)) {
                splittedWidget = paragraphView[widgetIndex + 1];
                nextBodyWidget = splittedWidget.containerWidget;
            }
            else {
                splittedWidget = new ParagraphWidget();
                splittedWidget.index = paragraphWidget.index;
                splittedWidget.characterFormat = paragraphWidget.characterFormat;
                splittedWidget.paragraphFormat = paragraphWidget.paragraphFormat;
                splittedWidget.width = paragraphWidget.width;
                splittedWidget.x = paragraphWidget.x;
                splittedWidget.y = paragraphWidget.y;
                paragraphView.push(splittedWidget);
            }
            if (previousBodyWidget !== paragraphWidget.containerWidget) {
                this.updateContainerWidget(paragraphWidget, previousBodyWidget, index, true);
            }
            for (var i = paragraphWidget.childWidgets.length - 1; i > 0; i--) {
                if (this.isFitInClientArea(paragraphWidget, viewer)) {
                    break;
                }
                else {
                    var line = paragraphWidget.childWidgets[i];
                    //Moves the line widget to next widget.
                    this.updateParagraphWidgetInternal(line, splittedWidget, 0);
                }
            }
            if (isNullOrUndefined(splittedWidget.containerWidget) && splittedWidget.childWidgets.length > 0) {
                var y = viewer.clientActiveArea.y;
                // tslint:disable-next-line:max-line-length
                var clientArea = new Rect(viewer.clientArea.x, viewer.clientArea.y, viewer.clientArea.width, viewer.clientArea.height);
                var activeArea = new Rect(viewer.clientActiveArea.x, viewer.clientActiveArea.y, viewer.clientActiveArea.width, viewer.clientActiveArea.height);
                //Checks whether next node exists, else adds new page.
                nextBodyWidget = this.moveBlocksToNextPage(paragraphWidget);
                // nextBodyWidget = this.createOrGetNextBodyWidget(previousBodyWidget, viewer);
                nextBodyWidget.childWidgets.splice(0, 0, splittedWidget);
                nextBodyWidget.height += splittedWidget.height;
                splittedWidget.containerWidget = nextBodyWidget;
                if (nextBodyWidget.childWidgets.length === 1 && nextBodyWidget.firstChild instanceof ParagraphWidget &&
                    nextBodyWidget.firstChild.equals(paragraphWidget)) {
                    paragraphWidget.x = paragraphWidget.x;
                    paragraphWidget.y = y;
                    return true;
                }
                else {
                    //Resetting Client area
                    viewer.clientArea = clientArea;
                    viewer.clientActiveArea = activeArea;
                }
            }
        }
        else {
            nextBodyWidget = this.createOrGetNextBodyWidget(previousBodyWidget, this.viewer);
            if (paragraphWidget.containerWidget !== nextBodyWidget) {
                nextBodyWidget = this.moveBlocksToNextPage(paragraphWidget);
                this.updateContainerWidget(paragraphWidget, nextBodyWidget, 0, true);
            }
        }
        if (previousBodyWidget === paragraphWidget.containerWidget) {
            paragraphWidget.y = viewer.clientActiveArea.y;
            viewer.cutFromTop(viewer.clientActiveArea.y + paragraphWidget.height);
        }
        else {
            //Updates client area based on next body widget.
            viewer.updateClientArea(nextBodyWidget.sectionFormat, nextBodyWidget.page);
        }
        return false;
    };
    Layout.prototype.getMaxElementHeight = function (lineWidget, viewer) {
        var height = 0;
        // tslint:disable-next-line:max-line-length
        if (lineWidget.children.length === 0 || ((lineWidget.children.length === 1 && lineWidget.children[0] instanceof ListTextElementBox) || (lineWidget.children.length === 2 && lineWidget.children[0] instanceof ListTextElementBox && lineWidget.children[1] instanceof ListTextElementBox))) {
            var topMargin = 0;
            var bottomMargin = 0;
            height = viewer.selection.getParagraphMarkSize(lineWidget.paragraph, topMargin, bottomMargin).height;
            height += topMargin;
            if (lineWidget.children.length > 0) {
                var element = lineWidget.children[0];
                if (height < element.margin.top + element.height) {
                    height = element.margin.top + element.height;
                }
            }
        }
        else {
            for (var i = 0; i < lineWidget.children.length; i++) {
                var element = lineWidget.children[i];
                if (height < element.margin.top + element.height) {
                    height = element.margin.top + element.height;
                }
            }
        }
        return height;
    };
    Layout.prototype.createOrGetNextBodyWidget = function (bodyWidget, viewer) {
        var nextBodyWidget = undefined;
        var pageIndex = 0;
        pageIndex = viewer.pages.indexOf(bodyWidget.page);
        var page = undefined;
        var index = undefined;
        index = bodyWidget.index;
        if (pageIndex === viewer.pages.length - 1
            || viewer.pages[pageIndex + 1].sectionIndex !== index) {
            var currentWidget = new BodyWidget();
            currentWidget.sectionFormat = bodyWidget.sectionFormat;
            currentWidget.index = bodyWidget.index;
            page = viewer.createNewPage(currentWidget);
            if (viewer.pages[pageIndex + 1].sectionIndex !== index) {
                viewer.insertPage(pageIndex + 1, page);
            }
            nextBodyWidget = page.bodyWidgets[0];
        }
        else {
            page = viewer.pages[pageIndex + 1];
            nextBodyWidget = page.bodyWidgets[0];
        }
        return nextBodyWidget;
    };
    Layout.prototype.isFitInClientArea = function (paragraphWidget, viewer) {
        var lastLine = paragraphWidget.childWidgets[paragraphWidget.childWidgets.length - 1];
        var height = paragraphWidget.height;
        var maxElementHeight = this.getMaxElementHeight(lastLine, viewer);
        if (lastLine.height > maxElementHeight) {
            height -= lastLine.height - maxElementHeight;
        }
        return viewer.clientActiveArea.height >= height;
    };
    // tslint:disable-next-line:max-line-length
    Layout.prototype.shiftToPreviousWidget = function (paragraphWidget, viewer, previousWidget, isPageBreak) {
        for (var i = 0; i < paragraphWidget.childWidgets.length; i++) {
            var line = paragraphWidget.childWidgets[i];
            var maxElementHeight = this.getMaxElementHeight(line, viewer);
            if (viewer.clientActiveArea.height >= maxElementHeight && !isPageBreak) {
                //Moves the line widget to previous widget.
                this.updateParagraphWidgetInternal(line, previousWidget, previousWidget.childWidgets.length);
                i--;
                viewer.cutFromTop(viewer.clientActiveArea.y + line.height);
                if (isNullOrUndefined(paragraphWidget.childWidgets)) {
                    break;
                }
            }
            else {
                var bodyWidget = previousWidget.containerWidget;
                var nextBodyWidget = this.createOrGetNextBodyWidget(bodyWidget, viewer);
                if (paragraphWidget.containerWidget !== nextBodyWidget) {
                    nextBodyWidget = this.moveBlocksToNextPage(paragraphWidget);
                }
                if (bodyWidget !== nextBodyWidget) {
                    this.updateContainerWidget(paragraphWidget, nextBodyWidget, 0, true);
                }
                //Updates client area based on next page.
                viewer.updateClientArea(nextBodyWidget.sectionFormat, nextBodyWidget.page);
                break;
            }
        }
    };
    Layout.prototype.updateParagraphWidgetInternal = function (lineWidget, newParagraphWidget, index) {
        if (!isNullOrUndefined(lineWidget.paragraph)) {
            lineWidget.paragraph.childWidgets.splice(lineWidget.paragraph.childWidgets.indexOf(lineWidget), 1);
            lineWidget.paragraph.height -= lineWidget.height;
            if (!isNullOrUndefined(lineWidget.paragraph.containerWidget)) {
                lineWidget.paragraph.containerWidget.height -= lineWidget.height;
            }
            // tslint:disable-next-line:max-line-length
            if (isNullOrUndefined(lineWidget.paragraph.childWidgets) || lineWidget.paragraph.childWidgets.length === 0) {
                lineWidget.paragraph.destroyInternal(this.viewer);
            }
        }
        newParagraphWidget.childWidgets.splice(index, 0, lineWidget);
        lineWidget.paragraph = newParagraphWidget;
        newParagraphWidget.height += lineWidget.height;
        if (!isNullOrUndefined(newParagraphWidget.containerWidget)) {
            newParagraphWidget.containerWidget.height += lineWidget.height;
        }
    };
    Layout.prototype.shiftNextWidgets = function (blockAdv) {
        var block = blockAdv;
        while (block.nextWidget instanceof BlockWidget) {
            block = block.nextWidget;
            this.reLayoutOrShiftWidgets(block, this.viewer);
        }
    };
    /**
     * @private
     */
    Layout.prototype.updateContainerWidget = function (widget, bodyWidget, index, destroyAndScroll) {
        if (!isNullOrUndefined(widget.containerWidget)) {
            widget.containerWidget.childWidgets.splice(widget.containerWidget.childWidgets.indexOf(widget), 1);
            widget.containerWidget.height -= bodyWidget.height;
            if ((isNullOrUndefined(widget.containerWidget.childWidgets) || widget.containerWidget.childWidgets.length === 0)
                && widget.containerWidget instanceof BodyWidget && widget.containerWidget !== bodyWidget && destroyAndScroll) {
                var page = widget.containerWidget.page;
                if (this.viewer.pages[this.viewer.pages.length - 1] === page &&
                    this.viewer.visiblePages.indexOf(page) !== -1) {
                    this.viewer.scrollToBottom();
                }
                if (isNullOrUndefined(page.nextPage) || page.nextPage.bodyWidgets[0].index !== widget.containerWidget.index) {
                    widget.containerWidget.destroyInternal(this.viewer);
                }
            }
        }
        bodyWidget.childWidgets.splice(index, 0, widget);
        bodyWidget.height += bodyWidget.height;
        widget.containerWidget = bodyWidget;
    };
    Layout.prototype.getBodyWidgetOfPreviousBlock = function (block, index) {
        index = 0;
        var prevBodyWidget = undefined;
        var previousBlock = block.previousRenderedWidget;
        prevBodyWidget = (previousBlock && previousBlock.containerWidget.equals(block.containerWidget)) ?
            previousBlock.containerWidget : block.containerWidget;
        index = previousBlock && previousBlock.containerWidget.equals(block.containerWidget) ?
            prevBodyWidget.childWidgets.indexOf(previousBlock) : block.containerWidget.childWidgets.indexOf(block);
        return { bodyWidget: prevBodyWidget, index: index };
    };
    /**
     * @private
     */
    Layout.prototype.moveBlocksToNextPage = function (block) {
        var body = block.bodyWidget;
        var page = body.page;
        var pageIndex = page.index + 1;
        var nextPage = undefined;
        var nextBody = undefined;
        var insertPage = false;
        if (this.viewer.pages.length > pageIndex) {
            nextPage = this.viewer.pages[pageIndex];
            if (nextPage.bodyWidgets.length === 0 || !body.equals(nextPage.bodyWidgets[0])) {
                nextPage = undefined;
                insertPage = true;
            }
            else {
                nextBody = nextPage.bodyWidgets[0];
                this.viewer.updateClientArea(nextBody.sectionFormat, nextBody.page);
            }
        }
        if (isNullOrUndefined(nextPage)) {
            nextBody = this.createSplitBody(body);
            nextPage = this.viewer.createNewPage(nextBody, pageIndex);
            if (insertPage) {
                this.viewer.insertPage(pageIndex, nextPage);
            }
        }
        //tslint:disable :no-constant-condition
        do {
            var lastBlock = body.lastChild;
            if (block === lastBlock) {
                break;
            }
            body.childWidgets.pop();
            nextBody.childWidgets.splice(0, 0, lastBlock);
            lastBlock.containerWidget = nextBody;
            nextBody.height += lastBlock.height;
        } while (true);
        return nextBody;
    };
    Layout.prototype.createSplitBody = function (body) {
        var newBody = this.addBodyWidget(this.viewer.clientActiveArea);
        newBody.sectionFormat = body.sectionFormat;
        newBody.index = body.index;
        return newBody;
    };
    //endregion
    //#region Relayout Parargaph 
    /**
     * Relayout Paragraph from specified line widget
     * @param paragraph Paragraph to reLayout
     * @param lineIndex start line index to reLayout
     * @private
     */
    Layout.prototype.reLayoutLine = function (paragraph, lineIndex, isBidi) {
        if (this.viewer.owner.isDocumentLoaded && this.viewer.owner.editorModule) {
            this.viewer.owner.editorModule.updateWholeListItems(paragraph);
        }
        var lineWidget;
        if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId !== -1) {
            lineWidget = paragraph.getSplitWidgets()[0].firstChild;
        }
        else {
            lineWidget = paragraph.childWidgets[lineIndex];
        }
        if (!this.isBidiReLayout && (paragraph.paragraphFormat.bidi || this.isContainsRtl(lineWidget))) {
            var newLineIndex = lineIndex <= 0 ? 0 : lineIndex - 1;
            for (var i = newLineIndex; i < paragraph.childWidgets.length; i++) {
                if (isBidi || !(paragraph.paragraphFormat.bidi && this.isContainsRtl(lineWidget))) {
                    if (i === lineIndex) {
                        continue;
                    }
                }
                this.reArrangeElementsForRtl(paragraph.childWidgets[i], paragraph.paragraphFormat.bidi);
            }
        }
        var lineToLayout = lineWidget.previousLine;
        if (isNullOrUndefined(lineToLayout)) {
            lineToLayout = lineWidget;
        }
        var currentParagraph = lineToLayout.paragraph;
        var bodyWidget = paragraph.containerWidget;
        bodyWidget.height -= paragraph.height;
        if (this.viewer.owner.enableHeaderAndFooter || paragraph.isInHeaderFooter) {
            paragraph.bodyWidget.isEmpty = false;
            // tslint:disable-next-line:max-line-length
            this.viewer.updateHCFClientAreaWithTop(paragraph.bodyWidget.sectionFormat, this.viewer.isBlockInHeader(paragraph), bodyWidget.page);
        }
        else {
            this.viewer.updateClientArea(bodyWidget.sectionFormat, bodyWidget.page);
        }
        this.viewer.updateClientAreaForBlock(paragraph, true);
        if (lineToLayout.paragraph.isEmpty()) {
            this.viewer.cutFromTop(paragraph.y);
            this.layoutParagraph(paragraph, 0);
        }
        else {
            this.updateClientAreaForLine(lineToLayout.paragraph, lineToLayout, 0);
            this.layoutListItems(lineToLayout.paragraph);
            if (lineToLayout.isFirstLine() && !isNullOrUndefined(paragraph.paragraphFormat)) {
                var firstLineIndent = -HelperMethods.convertPointToPixel(paragraph.paragraphFormat.firstLineIndent);
                this.viewer.updateClientWidth(firstLineIndent);
            }
            do {
                lineToLayout = this.layoutLine(lineToLayout, 0);
                paragraph = lineToLayout.paragraph;
                lineToLayout = lineToLayout.nextLine;
            } while (lineToLayout);
            this.updateWidgetToPage(this.viewer, paragraph);
            this.viewer.updateClientAreaForBlock(paragraph, false);
        }
        this.layoutNextItemsBlock(paragraph, this.viewer);
    };
    //#endregion
    //RTL Feature layout start
    Layout.prototype.isContainsRtl = function (lineWidget) {
        var isContainsRTL = false;
        for (var i = 0; i < lineWidget.children.length; i++) {
            if (lineWidget.children[i] instanceof TextElementBox) {
                isContainsRTL = lineWidget.children[i].characterFormat.bidi || lineWidget.children[i].characterFormat.bdo === 'RTL'
                    || this.viewer.textHelper.isRTLText(lineWidget.children[i].text);
                if (isContainsRTL) {
                    break;
                }
            }
        }
        return isContainsRTL;
    };
    // Re arranges the elements for Right to left layotuing.
    // tslint:disable:max-func-body-length    
    Layout.prototype.reArrangeElementsForRtl = function (line, isParaBidi) {
        if (line.children.length === 0) {
            return;
        }
        var isFieldCode = false;
        var lastAddedElementIsRtl = false;
        var lastAddedRtlElementIndex = -1;
        var tempElements = [];
        for (var i = 0; i < line.children.length; i++) {
            var element = line.children[i];
            var elementCharacterFormat = undefined;
            if (element.characterFormat) {
                elementCharacterFormat = element.characterFormat;
            }
            var isRtl = false;
            var text = '';
            var containsSpecchrs = false;
            if (element instanceof BookmarkElementBox) {
                if (isParaBidi) {
                    if (lastAddedElementIsRtl || element.bookmarkType === 0 && element.nextElement
                        && element.nextElement.nextElement instanceof TextElementBox
                        && this.viewer.textHelper.isRTLText(element.nextElement.nextElement.text)
                        || element.bookmarkType === 1 && element.nextElement instanceof TextElementBox
                            && this.viewer.textHelper.isRTLText(element.nextElement.text)) {
                        tempElements.splice(0, 0, element);
                    }
                    else {
                        tempElements.splice(lastAddedElementIsRtl ? lastAddedRtlElementIndex : lastAddedRtlElementIndex + 1, 0, element);
                    }
                    lastAddedRtlElementIndex = tempElements.indexOf(element);
                }
                else {
                    tempElements.push(element);
                }
                continue;
            }
            if (element instanceof TextElementBox) {
                text = element.text;
                containsSpecchrs = this.viewer.textHelper.containsSpecialCharAlone(text);
                if (containsSpecchrs) {
                    if (text.length > 1 && elementCharacterFormat.bidi) {
                        text = HelperMethods.ReverseString(text);
                        element.text = text;
                    }
                }
            }
            // The list element box shold be added in the last position in line widget for the RTL paragraph 
            // and first in the line widget for LTR paragrph.
            if (element instanceof ListTextElementBox) {
                isRtl = isParaBidi;
            }
            else { // For Text element box we need to check the character format and unicode of text to detect the RTL text. 
                isRtl = this.viewer.textHelper.isRTLText(text) || elementCharacterFormat.bidi
                    || elementCharacterFormat.bdo === 'RTL';
            }
            if (element instanceof FieldElementBox || isFieldCode) {
                if (element.fieldType === 0) {
                    isFieldCode = true;
                }
                else if (element.fieldType === 1) {
                    isFieldCode = false;
                }
                isRtl = false;
            }
            // If the text element box contains only whitespaces, then need to check the previous and next elements.
            if (!isRtl && !isNullOrUndefined(text) && text !== '' && ((text !== '' && text.trim() === '') || containsSpecchrs)) {
                var elements = line.children;
                //Checks whether the langugae is RTL.
                if (elementCharacterFormat.bidi) {
                    // If the last added element is rtl then current text element box also considered as RTL for WhiteSpaces.
                    if (lastAddedElementIsRtl) {
                        isRtl = true;
                        // Else, Check for next element.
                    }
                    else if (i + 1 < line.children.length && line.children[i + 1] instanceof TextElementBox) {
                        text = elements[i + 1].text;
                        isRtl = this.viewer.textHelper.isRTLText(text) || elements[i + 1].characterFormat.bidi
                            || elements[i + 1].characterFormat.bdo === 'RTL';
                    } // If the last added element is rtl then current text element box also considered as RTL for WhiteSpaces.
                }
                else if (lastAddedElementIsRtl) {
                    isRtl = true;
                }
            }
            // Preserve the isRTL value, to reuse it for navigation and selection.
            element.isRightToLeft = isRtl;
            //Adds the text element to the line
            if (isRtl && elementCharacterFormat.bdo !== 'LTR') {
                if (lastAddedElementIsRtl) {
                    tempElements.splice(lastAddedRtlElementIndex, 0, element);
                }
                else {
                    if (!isParaBidi) {
                        tempElements.push(element);
                    }
                    else {
                        tempElements.splice(0, 0, element);
                    }
                    lastAddedElementIsRtl = true;
                    lastAddedRtlElementIndex = tempElements.indexOf(element);
                }
            }
            else {
                if (lastAddedElementIsRtl && element instanceof ImageElementBox) {
                    if (elementCharacterFormat.bidi) {
                        tempElements.splice(lastAddedRtlElementIndex + 1, 0, element);
                    }
                    else {
                        tempElements.splice(lastAddedRtlElementIndex, 0, element);
                    }
                }
                else {
                    if (!isParaBidi) {
                        tempElements.push(element);
                    }
                    else {
                        if (lastAddedElementIsRtl) {
                            tempElements.splice(0, 0, element);
                        }
                        else {
                            tempElements.splice(lastAddedRtlElementIndex + 1, 0, element);
                        }
                        lastAddedRtlElementIndex = tempElements.indexOf(element);
                    }
                    lastAddedElementIsRtl = false;
                }
            }
        }
        // Clear the elemnts and reassign the arranged elements.
        line.children = [];
        line.children = tempElements;
    };
    return Layout;
}());

// tslint:disable-next-line:max-line-length
/**
 * @private
 */
var Renderer = /** @__PURE__ @class */ (function () {
    function Renderer(viewer) {
        this.isPrinting = false;
        this.pageLeft = 0;
        this.pageTop = 0;
        this.pageIndex = -1;
        this.isFieldCode = false;
        this.leftPosition = 0;
        this.topPosition = 0;
        this.viewer = viewer;
    }
    Object.defineProperty(Renderer.prototype, "pageCanvas", {
        /**
         * Gets page canvas.
         * @private
         */
        get: function () {
            if (this.isPrinting) {
                if (isNullOrUndefined(this.pageCanvasIn)) {
                    this.pageCanvasIn = document.createElement('canvas');
                    this.pageCanvasIn.getContext('2d').save();
                }
                return this.pageCanvasIn;
            }
            return isNullOrUndefined(this.viewer) ? undefined : this.viewer.containerCanvas;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderer.prototype, "spellChecker", {
        /**
         * Gets the spell checker
         * @private
         */
        get: function () {
            return this.viewer.owner.spellChecker;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderer.prototype, "selectionCanvas", {
        /**
         * Gets selection canvas.
         */
        get: function () {
            return isNullOrUndefined(this.viewer) ? undefined : this.viewer.selectionCanvas;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderer.prototype, "pageContext", {
        /**
         * Gets page context.
         */
        get: function () {
            return this.pageCanvas.getContext('2d');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Renderer.prototype, "selectionContext", {
        /**
         * Gets selection context.
         */
        get: function () {
            return this.selectionCanvas.getContext('2d');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Renders widgets.
     * @param {Page} page
     * @param {number} left
     * @param {number} top
     * @param {number} width
     * @param {number} height
     * @private
     */
    Renderer.prototype.renderWidgets = function (page, left, top, width, height) {
        if (isNullOrUndefined(this.pageCanvas) || isNullOrUndefined(page)) {
            return;
        }
        this.pageContext.fillStyle = HelperMethods.getColor(this.viewer.backgroundColor);
        this.pageContext.beginPath();
        this.pageContext.fillRect(left, top, width, height);
        this.pageContext.closePath();
        this.pageContext.strokeStyle = this.viewer.owner.pageOutline;
        this.pageContext.strokeRect(left, top, width, height);
        this.pageLeft = left;
        this.pageTop = top;
        this.pageIndex = page.index;
        if (this.isPrinting) {
            this.setPageSize(page);
        }
        else {
            this.pageContext.beginPath();
            this.pageContext.save();
            this.pageContext.rect(left, top, width, height);
            this.pageContext.clip();
        }
        if (page.headerWidget) {
            this.renderHFWidgets(page, page.headerWidget, width, true);
        }
        if (page.footerWidget) {
            this.renderHFWidgets(page, page.footerWidget, width, false);
        }
        for (var i = 0; i < page.bodyWidgets.length; i++) {
            this.render(page, page.bodyWidgets[i]);
        }
        if (this.viewer.owner.enableHeaderAndFooter && !this.isPrinting) {
            this.renderHeaderSeparator(page, this.pageLeft, this.pageTop, page.headerWidget);
        }
        this.pageLeft = 0;
        this.pageTop = 0;
        this.pageContext.restore();
    };
    /**
     * Sets page size.
     * @param {Page} page
     */
    Renderer.prototype.setPageSize = function (page) {
        this.pageContext.clearRect(0, 0, this.pageCanvas.width, this.pageCanvas.height);
        this.selectionContext.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
        this.pageContext.restore();
        this.selectionContext.restore();
        var width = page.boundingRectangle.width;
        var height = page.boundingRectangle.height;
        var dpr = Math.max(1, window.devicePixelRatio || 1);
        if (this.pageCanvas.width !== width * dpr || this.pageCanvas.height !== height * dpr) {
            this.pageCanvas.height = height * dpr;
            this.pageCanvas.width = width * dpr;
            this.pageCanvas.style.height = height + 'px';
            this.pageCanvas.style.width = width + 'px';
            this.pageContext.globalAlpha = 1;
            this.pageContext.scale(dpr, dpr);
        }
    };
    /**
     * Renders header footer widget.
     * @param {Page} page
     * @param {HeaderFooterWidget} headFootWidget
     */
    Renderer.prototype.renderHFWidgets = function (page, widget, width, isHeader) {
        if (!this.isPrinting) {
            this.pageContext.globalAlpha = this.viewer.owner.enableHeaderAndFooter ? 1 : 0.65;
        }
        var cliped = false;
        var height = 0;
        var pageHt = 0;
        var headerFooterHeight = page.boundingRectangle.height / 100 * 40;
        if (isHeader) {
            var topMargin = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.topMargin);
            var widgetHeight = Math.max((widget.y + widget.height), topMargin);
            if (widgetHeight > headerFooterHeight) {
                cliped = true;
                this.pageContext.beginPath();
                this.pageContext.save();
                this.pageContext.rect(this.pageLeft, this.pageTop, width, this.getScaledValue(headerFooterHeight));
                this.pageContext.clip();
            }
        }
        else {
            var footerDistance = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.footerDistance);
            // tslint:disable-next-line:max-line-length
            var footerHeight = this.getScaledValue(page.boundingRectangle.height) -
                this.getScaledValue(Math.max(page.footerWidget.height + footerDistance, HelperMethods.convertPointToPixel(page.footerWidget.sectionFormat.bottomMargin)));
            height = Math.max((this.getScaledValue(page.boundingRectangle.height) - headerFooterHeight), footerHeight);
            pageHt = this.getScaledValue(page.boundingRectangle.height) - footerDistance;
        }
        for (var i = 0; i < widget.childWidgets.length; i++) {
            var block = widget.childWidgets[i];
            if (!isHeader) {
                height += block.height;
            }
            if (isHeader || !isHeader && height <= pageHt) {
                this.renderWidget(page, block);
            }
        }
        if (cliped) {
            this.pageContext.restore();
        }
        if (!this.isPrinting) {
            this.pageContext.globalAlpha = this.viewer.owner.enableHeaderAndFooter ? 0.65 : 1;
        }
    };
    Renderer.prototype.renderHeaderSeparator = function (page, left, top, widget) {
        //Header Widget
        var topMargin = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.topMargin);
        var y = this.getScaledValue(Math.max((widget.y + widget.height), topMargin));
        var pageWidth = this.getScaledValue(page.boundingRectangle.width);
        var ctx = this.pageContext;
        ctx.save();
        ctx.globalAlpha = 0.65;
        var headerFooterHeight = (this.getScaledValue(page.boundingRectangle.height) / 100) * 40;
        //Maximum header height limit       
        y = Math.min(y, headerFooterHeight);
        //Dash line Separator
        this.renderDashLine(ctx, left, top + y, pageWidth, '#000000', false);
        var type = this.getHeaderFooterType(page, true);
        ctx.font = '9pt Arial';
        var width = ctx.measureText(type).width;
        this.renderHeaderFooterMark(ctx, left + 5, top + y, width + 10, 20);
        this.renderHeaderFooterMarkText(ctx, type, left + 10, y + top + 15);
        if (page.footerWidget) {
            //Footer Widget
            var footerDistance = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.footerDistance);
            // tslint:disable-next-line:max-line-length
            var footerHeight = this.getScaledValue(page.boundingRectangle.height) -
                this.getScaledValue(Math.max(page.footerWidget.height + footerDistance, HelperMethods.convertPointToPixel(page.footerWidget.sectionFormat.bottomMargin)));
            //Maximum footer height limit     
            footerHeight = Math.max((this.getScaledValue(page.boundingRectangle.height) - headerFooterHeight), footerHeight);
            this.renderDashLine(ctx, left, top + footerHeight, pageWidth, '#000000', false);
            type = this.getHeaderFooterType(page, false);
            width = ctx.measureText(type).width;
            this.renderHeaderFooterMark(ctx, left + 5, top + footerHeight - 20, width + 10, 20);
            this.renderHeaderFooterMarkText(ctx, type, left + 10, top + footerHeight - 5);
            ctx.restore();
        }
    };
    Renderer.prototype.getHeaderFooterType = function (page, isHeader) {
        var type;
        type = isHeader ? 'Header' : 'Footer';
        if (page.bodyWidgets[0].sectionFormat.differentFirstPage &&
            (isNullOrUndefined(page.previousPage) || page.sectionIndex !== page.previousPage.sectionIndex)) {
            type = isHeader ? 'First Page Header' : 'First Page Footer';
        }
        else if (page.bodyWidgets[0].sectionFormat.differentOddAndEvenPages) {
            if ((this.viewer.pages.indexOf(page) + 1) % 2 === 0) {
                type = isHeader ? 'Even Page Header' : 'Even Page Footer';
            }
            else {
                type = isHeader ? 'Odd Page Header' : 'Odd Page Footer';
            }
        }
        return type;
    };
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Renderer.prototype.renderDashLine = function (ctx, x, y, width, fillStyle, isSmallDash) {
        ctx.beginPath();
        ctx.strokeStyle = fillStyle;
        ctx.lineWidth = 1;
        if (isSmallDash) {
            ctx.setLineDash([3, 2]);
        }
        else {
            ctx.setLineDash([6, 4]);
        }
        ctx.moveTo(x, y);
        ctx.lineTo(x + width, y);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.closePath();
    };
    Renderer.prototype.renderHeaderFooterMark = function (ctx, x, y, w, h) {
        ctx.beginPath();
        ctx.fillStyle = 'lightgray';
        ctx.fillRect(x, y, w, h);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(x, y, w, h);
        ctx.closePath();
    };
    Renderer.prototype.renderHeaderFooterMarkText = function (ctx, content, x, y) {
        ctx.beginPath();
        ctx.fillStyle = '#000000';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText(content, x, y);
        ctx.closePath();
    };
    /**
     * Renders body widget.
     * @param {Page} page
     * @param {BodyWidget} bodyWidget
     */
    Renderer.prototype.render = function (page, bodyWidget) {
        for (var i = 0; i < bodyWidget.childWidgets.length; i++) {
            var widget = bodyWidget.childWidgets[i];
            if (i === 0 && bodyWidget.childWidgets[0] instanceof TableWidget && page.repeatHeaderRowTableWidget) {
                // tslint:disable-next-line:max-line-length
                this.renderHeader(page, widget, this.viewer.layout.getHeader(bodyWidget.childWidgets[0]));
            }
            this.renderWidget(page, widget);
        }
    };
    /**
     * Renders block widget.
     * @param {Page} page
     * @param {Widget} widget
     */
    Renderer.prototype.renderWidget = function (page, widget) {
        if (widget instanceof ParagraphWidget) {
            this.renderParagraphWidget(page, widget);
        }
        else {
            this.renderTableWidget(page, widget);
        }
    };
    /**
     * Renders header.
     * @param {Page} page
     * @param {TableWidget} widget
     * @param {WRow} header
     * @private
     */
    Renderer.prototype.renderHeader = function (page, widget, header) {
        if (isNullOrUndefined(header)) {
            return;
        }
        //Updated client area for current page
        page.viewer.updateClientArea(page.bodyWidgets[0].sectionFormat, page);
        var top = page.viewer.clientArea.y;
        var parentTable = header.ownerTable.getSplitWidgets()[0];
        for (var i = 0; i <= header.rowIndex; i++) {
            if (parentTable.childWidgets.length === 0) {
                return;
            }
            var row = parentTable.childWidgets[i];
            var headerWidget = row.clone();
            headerWidget.containerWidget = row.containerWidget;
            // tslint:disable-next-line:max-line-length
            page.viewer.updateClientAreaLocation(headerWidget, new Rect(page.viewer.clientArea.x, top, headerWidget.width, headerWidget.height));
            page.viewer.layout.updateChildLocationForRow(top, headerWidget);
            var cell = undefined;
            //Renders table cell outline rectangle - Border and background color.
            for (var j = 0; j < headerWidget.childWidgets.length; j++) {
                cell = headerWidget.childWidgets[j];
                this.renderTableCellWidget(page, cell);
            }
            top += headerWidget.height;
        }
        if (widget.y !== top) {
            //this.Location.Y = top;
            page.viewer.layout.updateChildLocationForTable(top, widget);
        }
    };
    /**
     * Renders paragraph widget.
     * @param {Page} page
     * @param {ParagraphWidget} paraWidget
     */
    Renderer.prototype.renderParagraphWidget = function (page, paraWidget) {
        var top = paraWidget.y;
        var left = paraWidget.x;
        for (var i = 0; i < paraWidget.childWidgets.length; i++) {
            var widget = paraWidget.childWidgets[i];
            this.renderLine(widget, page, left, top);
            top += widget.height;
        }
    };
    /**
     * Renders table widget.
     * @param {Page} page
     * @param {TableWidget} tableWidget
     */
    Renderer.prototype.renderTableWidget = function (page, tableWidget) {
        for (var i = 0; i < tableWidget.childWidgets.length; i++) {
            var widget = tableWidget.childWidgets[i];
            this.renderTableRowWidget(page, widget);
            if (tableWidget.tableFormat.cellSpacing > 0) {
                this.renderTableOutline(tableWidget);
            }
        }
    };
    /**
     * Renders table row widget.
     * @param {Page} page
     * @param {Widget} rowWidget
     */
    Renderer.prototype.renderTableRowWidget = function (page, rowWidget) {
        for (var i = 0; i < rowWidget.childWidgets.length; i++) {
            var widget = rowWidget.childWidgets[i];
            this.renderTableCellWidget(page, widget);
        }
    };
    /**
     * Renders table cell widget.
     * @param {Page} page
     * @param {TableCellWidget} cellWidget
     */
    Renderer.prototype.renderTableCellWidget = function (page, cellWidget) {
        if (!this.isPrinting) {
            if (this.getScaledValue(cellWidget.y, 2) + cellWidget.height * this.viewer.zoomFactor < 0 ||
                this.getScaledValue(cellWidget.y, 2) > this.viewer.visibleBounds.height) {
                return;
            }
        }
        if (!this.isPrinting && page.viewer.owner.selection && page.viewer.owner.selection.selectedWidgets.length > 0) {
            page.viewer.owner.selection.addSelectionHighlightTable(this.selectionContext, cellWidget);
        }
        this.renderTableCellOutline(page.viewer, cellWidget);
        for (var i = 0; i < cellWidget.childWidgets.length; i++) {
            var widget = cellWidget.childWidgets[i];
            var width = cellWidget.width + cellWidget.margin.left - cellWidget.leftBorderWidth;
            this.clipRect(cellWidget.x, cellWidget.y, this.getScaledValue(width), this.getScaledValue(cellWidget.height));
            this.renderWidget(page, widget);
            this.pageContext.restore();
        }
    };
    /**
     * Renders line widget.
     * @param {LineWidget} lineWidget
     * @param {Page} page
     * @param {number} left
     * @param {number} top
     */
    Renderer.prototype.renderLine = function (lineWidget, page, left, top) {
        // tslint:disable-next-line:max-line-length
        if (!this.isPrinting && page.viewer.owner.selection && !this.viewer.isScrollToSpellCheck && page.viewer.owner.selection.selectedWidgets.length > 0) {
            page.viewer.owner.selection.addSelectionHighlight(this.selectionContext, lineWidget, top);
        }
        var paraFormat = lineWidget.paragraph.paragraphFormat;
        if (lineWidget.isFirstLine() && !paraFormat.bidi) {
            left += HelperMethods.convertPointToPixel(paraFormat.firstLineIndent);
        }
        if (this.viewer.owner.searchModule) {
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(page.viewer.owner.searchModule.searchHighlighters) && page.viewer.owner.searchModule.searchHighlighters.containsKey(lineWidget)) {
                var widgetInfo = page.viewer.owner.searchModule.searchHighlighters.get(lineWidget);
                for (var i = 0; i < widgetInfo.length; i++) {
                    this.pageContext.fillStyle = '#ffe97f';
                    // tslint:disable-next-line:max-line-length
                    this.pageContext.fillRect(this.getScaledValue(widgetInfo[i].left, 1), this.getScaledValue(top, 2), this.getScaledValue(widgetInfo[i].width), this.getScaledValue(lineWidget.height));
                }
            }
        }
        // EditRegion highlight 
        if (page.viewer.selection && !isNullOrUndefined(page.viewer.selection.editRegionHighlighters)
            && page.viewer.selection.editRegionHighlighters.containsKey(lineWidget)) {
            var widgetInfo = page.viewer.selection.editRegionHighlighters.get(lineWidget);
            for (var i = 0; i < widgetInfo.length; i++) {
                this.pageContext.fillStyle = widgetInfo[i].color !== '' ? widgetInfo[i].color : '#add8e6';
                // tslint:disable-next-line:max-line-length
                this.pageContext.fillRect(this.getScaledValue(widgetInfo[i].left, 1), this.getScaledValue(top, 2), this.getScaledValue(widgetInfo[i].width), this.getScaledValue(lineWidget.height));
            }
        }
        var isCommentMark = false;
        for (var i = 0; i < lineWidget.children.length; i++) {
            var elementBox = lineWidget.children[i];
            if (elementBox instanceof CommentCharacterElementBox &&
                elementBox.commentType === 0 && this.viewer.owner.selectionModule) {
                if (this.viewer.owner.enableComment && !isCommentMark) {
                    isCommentMark = true;
                    elementBox.renderCommentMark();
                    var pageGap = 0;
                    if (this.viewer instanceof PageLayoutViewer) {
                        pageGap = this.viewer.pageGap;
                    }
                    var style = 'display:block;position:absolute;';
                    elementBox.commentMark.style.display = 'block';
                    elementBox.commentMark.style.position = 'absolute';
                    var rightMargin = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.rightMargin);
                    var pageWidth = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.pageWidth);
                    // tslint:disable-next-line:max-line-length
                    var leftPosition = page.boundingRectangle.x + this.getScaledValue((pageWidth - rightMargin) + (rightMargin / 4)) + 'px;';
                    var topPosition = this.getScaledValue(top + (page.boundingRectangle.y - (pageGap * (page.index + 1)))) + (pageGap * (page.index + 1)) + 'px;';
                    style = style + 'left:' + leftPosition + 'top:' + topPosition;
                    elementBox.commentMark.setAttribute('style', style);
                }
                else {
                    if (elementBox.commentMark) {
                        elementBox.commentMark.setAttribute('style', 'display:none');
                    }
                }
            }
            if (elementBox instanceof FieldElementBox || this.isFieldCode ||
                (elementBox.width === 0 && elementBox.height === 0)) {
                if (this.isFieldCode) {
                    elementBox.width = 0;
                }
                left += elementBox.width + elementBox.margin.left;
                this.toSkipFieldCode(elementBox);
                continue;
            }
            var underlineY = this.getUnderlineYPosition(lineWidget);
            if (!this.isPrinting) {
                if (this.getScaledValue(top + elementBox.margin.top, 2) + elementBox.height * this.viewer.zoomFactor < 0 ||
                    this.getScaledValue(top + elementBox.margin.top, 2) > this.viewer.visibleBounds.height) {
                    left += elementBox.width + elementBox.margin.left;
                    if (elementBox instanceof TextElementBox) {
                        elementBox.canTrigger = true;
                        elementBox.isVisible = false;
                        if (!elementBox.isSpellChecked || elementBox.line.paragraph.isChangeDetected) {
                            elementBox.ischangeDetected = true;
                        }
                    }
                    continue;
                }
            }
            if (elementBox instanceof ListTextElementBox) {
                this.renderListTextElementBox(elementBox, left, top, underlineY);
            }
            else if (elementBox instanceof ImageElementBox) {
                this.renderImageElementBox(elementBox, left, top, underlineY);
            }
            else {
                elementBox.isVisible = true;
                this.renderTextElementBox(elementBox, left, top, underlineY);
            }
            left += elementBox.width + elementBox.margin.left;
        }
    };
    Renderer.prototype.toSkipFieldCode = function (element) {
        if (element instanceof FieldElementBox) {
            if (element.fieldType === 0) {
                if ((!isNullOrUndefined(element.fieldEnd) || element.hasFieldEnd)) {
                    this.isFieldCode = true;
                }
            }
            else if (element.fieldType === 2 || element.fieldType === 1) {
                this.isFieldCode = false;
            }
        }
    };
    /**
     * Gets underline y position.
     * @param {LineWidget} lineWidget
     * @private
     */
    Renderer.prototype.getUnderlineYPosition = function (lineWidget) {
        var height = 0;
        var lineHeight = 0;
        for (var i = 0; i < lineWidget.children.length; i++) {
            if (lineWidget.children[i] instanceof FieldElementBox ||
                (lineWidget.children[i].width === 0 && lineWidget.children[i].height === 0)) {
                continue;
            }
            if (height < lineWidget.children[i].height + lineWidget.children[i].margin.top) {
                height = lineWidget.children[i].margin.top + lineWidget.children[i].height;
                lineHeight = lineWidget.children[i].height / 20;
            }
        }
        return height - 2 * lineHeight;
    };
    /**
     * Renders list element box
     * @param {ListTextElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     */
    Renderer.prototype.renderListTextElementBox = function (elementBox, left, top, underlineY) {
        var topMargin = elementBox.margin.top;
        var leftMargin = elementBox.margin.left;
        var format = elementBox.listLevel.characterFormat;
        var breakCharacterFormat = elementBox.line.paragraph.characterFormat;
        var color = format.fontColor === '#000000' ? breakCharacterFormat.fontColor : format.fontColor;
        this.pageContext.textBaseline = 'alphabetic';
        var bold = '';
        var italic = '';
        var fontFamily = format.hasValue('fontFamily') ? format.fontFamily : breakCharacterFormat.fontFamily;
        var fontSize = format.fontSize === 11 ? breakCharacterFormat.fontSize : format.fontSize;
        // tslint:disable-next-line:max-line-length
        var baselineAlignment = format.baselineAlignment === 'Normal' ? breakCharacterFormat.baselineAlignment : format.baselineAlignment;
        bold = format.bold ? 'bold' : breakCharacterFormat.bold ? 'bold' : '';
        italic = format.italic ? 'italic' : breakCharacterFormat.italic ? 'italic' : '';
        fontSize = fontSize === 0 ? 0.5 : fontSize / (baselineAlignment === 'Normal' ? 1 : 1.5);
        fontSize = this.isPrinting ? fontSize : fontSize * this.viewer.zoomFactor;
        var strikethrough = format.strikethrough === 'None' ? breakCharacterFormat.strikethrough : format.strikethrough;
        var highlightColor = format.highlightColor === 'NoColor' ? breakCharacterFormat.highlightColor :
            format.highlightColor;
        if (highlightColor !== 'NoColor') {
            if (highlightColor.substring(0, 1) !== '#') {
                this.pageContext.fillStyle = HelperMethods.getHighlightColorCode(highlightColor);
            }
            else {
                this.pageContext.fillStyle = HelperMethods.getColor(highlightColor);
            }
            // tslint:disable-next-line:max-line-length
            this.pageContext.fillRect(this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), this.getScaledValue(elementBox.width), this.getScaledValue(elementBox.height));
        }
        this.pageContext.font = bold + ' ' + italic + ' ' + fontSize + 'pt' + ' ' + fontFamily;
        if (baselineAlignment === 'Subscript') {
            topMargin += elementBox.height - elementBox.height / 1.5;
        }
        var baselineOffset = elementBox.baselineOffset;
        topMargin = (format.baselineAlignment === 'Normal') ? topMargin + baselineOffset : (topMargin + (baselineOffset / 1.5));
        var text = elementBox.text;
        var followCharacter = text === '\t' || text === ' ';
        if (!followCharacter && (format.bidi || elementBox.line.paragraph.paragraphFormat.bidi)) {
            var index = text.indexOf('.');
            text = text.substr(index) + text.substring(0, index);
        }
        this.pageContext.fillStyle = HelperMethods.getColor(color);
        // tslint:disable-next-line:max-line-length
        this.pageContext.fillText(text, this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), this.getScaledValue(elementBox.width));
        if (format.underline !== 'None' && !isNullOrUndefined(format.underline)) {
            this.renderUnderline(elementBox, left, top, underlineY, color, format.underline, baselineAlignment);
        }
        if (strikethrough !== 'None') {
            this.renderStrikeThrough(elementBox, left, top, format.strikethrough, color, baselineAlignment);
        }
    };
    /**
     * Renders text element box.
     * @param {TextElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     */
    // tslint:disable-next-line:max-line-length
    Renderer.prototype.renderTextElementBox = function (elementBox, left, top, underlineY) {
        var isHeightType = false;
        var containerWidget = elementBox.line.paragraph.containerWidget;
        if (containerWidget instanceof TableCellWidget) {
            isHeightType = (containerWidget.ownerRow.rowFormat.heightType === 'Exactly');
        }
        var topMargin = elementBox.margin.top;
        var leftMargin = elementBox.margin.left;
        if (isHeightType) {
            // tslint:disable-next-line:max-line-length
            this.clipRect(containerWidget.x, containerWidget.y, this.getScaledValue(containerWidget.width), this.getScaledValue(containerWidget.height));
        }
        var format = elementBox.characterFormat;
        if (format.highlightColor !== 'NoColor') {
            if (format.highlightColor.substring(0, 1) !== '#') {
                this.pageContext.fillStyle = HelperMethods.getHighlightColorCode(format.highlightColor);
            }
            else {
                this.pageContext.fillStyle = HelperMethods.getColor(format.highlightColor);
            }
            // tslint:disable-next-line:max-line-length
            this.pageContext.fillRect(this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), this.getScaledValue(elementBox.width), this.getScaledValue(elementBox.height));
        }
        var color = format.fontColor;
        this.pageContext.textBaseline = 'alphabetic';
        var bold = '';
        var italic = '';
        var fontSize = 11;
        bold = format.bold ? 'bold' : '';
        italic = format.italic ? 'italic' : '';
        fontSize = format.fontSize === 0 ? 0.5 : format.fontSize / (format.baselineAlignment === 'Normal' ? 1 : 1.5);
        fontSize = this.isPrinting ? fontSize : fontSize * this.viewer.zoomFactor;
        this.pageContext.font = bold + ' ' + italic + ' ' + fontSize + 'pt' + ' ' + format.fontFamily;
        if (format.baselineAlignment === 'Subscript') {
            topMargin += elementBox.height - elementBox.height / 1.5;
        }
        var baselineOffset = elementBox.baselineOffset;
        topMargin = (format.baselineAlignment === 'Normal') ? topMargin + baselineOffset : (topMargin + (baselineOffset / 1.5));
        this.pageContext.fillStyle = HelperMethods.getColor(color);
        var scaledWidth = this.getScaledValue(elementBox.width);
        var text = elementBox.text;
        if (elementBox instanceof TabElementBox) {
            var tabElement = elementBox;
            if (tabElement.tabText === '' && !isNullOrUndefined(tabElement.tabLeader) && tabElement.tabLeader !== 'None') {
                text = this.getTabLeader(elementBox);
                tabElement.tabText = text;
            }
            else if (tabElement.tabText !== '') {
                text = tabElement.tabText;
            }
        }
        var isRTL = format.bidi || this.viewer.textHelper.isRTLText(elementBox.text);
        text = this.viewer.textHelper.setText(text, isRTL, format.bdo, true);
        // tslint:disable-next-line:max-line-length
        this.pageContext.fillText(text, this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), scaledWidth);
        // tslint:disable-next-line:max-line-length
        if ((this.viewer.owner.enableSpellCheck && !this.spellChecker.removeUnderline) && (this.viewer.triggerSpellCheck || elementBox.canTrigger) && elementBox.text !== ' ' && !this.viewer.isScrollHandler && (isNullOrUndefined(elementBox.previousNode) || !(elementBox.previousNode instanceof FieldElementBox))) {
            elementBox.canTrigger = true;
            this.leftPosition = this.pageLeft;
            this.topPosition = this.pageTop;
            var errorDetails = this.spellChecker.checktextElementHasErrors(elementBox.text, elementBox, left);
            if (errorDetails.errorFound) {
                color = '#FF0000';
                for (var i = 0; i < errorDetails.elements.length; i++) {
                    var currentElement = errorDetails.elements[i];
                    // tslint:disable-next-line:max-line-length
                    if (elementBox.ignoreOnceItems.indexOf(this.spellChecker.manageSpecialCharacters(currentElement.text, undefined, true)) === -1) {
                        // tslint:disable-next-line:max-line-length
                        var backgroundColor = (containerWidget instanceof TableCellWidget) ? containerWidget.cellFormat.shading.backgroundColor : this.viewer.backgroundColor;
                        // tslint:disable-next-line:max-line-length
                        this.renderWavyline(currentElement, (isNullOrUndefined(currentElement.start)) ? left : currentElement.start.location.x, (isNullOrUndefined(currentElement.start)) ? top : currentElement.start.location.y - elementBox.margin.top, underlineY, color, 'Single', format.baselineAlignment, backgroundColor);
                    }
                }
            }
            else if (elementBox.ischangeDetected || this.viewer.triggerElementsOnLoading) {
                elementBox.ischangeDetected = false;
                this.handleChangeDetectedElements(elementBox, underlineY, left, top, format.baselineAlignment);
            }
        }
        if (format.underline !== 'None' && !isNullOrUndefined(format.underline)) {
            // tslint:disable-next-line:max-line-length
            this.renderUnderline(elementBox, left, top, underlineY, color, format.underline, format.baselineAlignment);
        }
        if (format.strikethrough !== 'None' && !isNullOrUndefined(format.strikethrough)) {
            this.renderStrikeThrough(elementBox, left, top, format.strikethrough, color, format.baselineAlignment);
        }
        if (isHeightType) {
            this.pageContext.restore();
        }
    };
    /**
     * Method to handle spell check for modified or newly added elements
     * @param {TextElementBox} elementBox
     * @param {number} underlineY
     * @param {number} left
     * @param {number} top
     * @param {number} baselineAlignment
     */
    // tslint:disable-next-line:max-line-length
    Renderer.prototype.handleChangeDetectedElements = function (elementBox, underlineY, left, top, baselineAlignment) {
        var _this = this;
        var checkText = elementBox.text.trim();
        var beforeIndex = this.pageIndex;
        if (elementBox.text === '\v') {
            return;
        }
        if (!this.spellChecker.checkElementCanBeCombined(elementBox, underlineY, beforeIndex, true)) {
            /* tslint:disable:no-any */
            var splittedText = checkText.split(/[\s]+/);
            var markindex = elementBox.line.getOffset(elementBox, 0);
            var spaceValue = 1;
            if (splittedText.length > 1) {
                for (var i = 0; i < splittedText.length; i++) {
                    var currentText = splittedText[i];
                    var retrievedText = this.spellChecker.manageSpecialCharacters(currentText, undefined, true);
                    // tslint:disable-next-line:max-line-length
                    if (this.spellChecker.ignoreAllItems.indexOf(retrievedText) === -1 && elementBox.ignoreOnceItems.indexOf(retrievedText) === -1) {
                        this.handleUnorderdElements(retrievedText, elementBox, underlineY, i, markindex, i === splittedText.length - 1, beforeIndex);
                        markindex += currentText.length + spaceValue;
                    }
                }
            }
            else {
                var retrievedText = this.spellChecker.manageSpecialCharacters(checkText, undefined, true);
                if (checkText.length > 0) {
                    // tslint:disable-next-line:max-line-length
                    if (this.spellChecker.ignoreAllItems.indexOf(retrievedText) === -1 && elementBox.ignoreOnceItems.indexOf(retrievedText) === -1) {
                        var indexInLine_1 = elementBox.indexInOwner;
                        var indexinParagraph_1 = elementBox.line.paragraph.indexInOwner;
                        var spellInfo = this.spellChecker.checkSpellingInPageInfo(retrievedText);
                        if (spellInfo.isElementPresent && this.spellChecker.enableOptimizedSpellCheck) {
                            var jsonObject = JSON.parse('{\"HasSpellingError\":' + spellInfo.hasSpellError + '}');
                            // tslint:disable-next-line:max-line-length
                            this.spellChecker.handleWordByWordSpellCheck(jsonObject, elementBox, left, top, underlineY, baselineAlignment, true);
                        }
                        else {
                            /* tslint:disable:no-any */
                            // tslint:disable-next-line:max-line-length
                            this.spellChecker.CallSpellChecker(this.spellChecker.languageID, checkText, true, this.spellChecker.allowSpellCheckAndSuggestion).then(function (data) {
                                /* tslint:disable:no-any */
                                var jsonObject = JSON.parse(data);
                                // tslint:disable-next-line:max-line-length
                                var canUpdate = (beforeIndex === _this.pageIndex || elementBox.isVisible) && (indexInLine_1 === elementBox.indexInOwner) && (indexinParagraph_1 === elementBox.line.paragraph.indexInOwner);
                                // tslint:disable-next-line:max-line-length
                                _this.spellChecker.handleWordByWordSpellCheck(jsonObject, elementBox, left, top, underlineY, baselineAlignment, canUpdate);
                            });
                        }
                    }
                }
            }
        }
    };
    /**
     * Method to handle spell check combine and splitted text elements
     * @param {string} currentText
     * @param {TextElementBox} elementBox
     * @param {number} underlineY
     * @param {number} iteration
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Renderer.prototype.handleUnorderdElements = function (currentText, elementBox, underlineY, iteration, markindex, isLastItem, beforeIndex) {
        var _this = this;
        var indexInLine = elementBox.indexInOwner;
        var indexinParagraph = elementBox.line.paragraph.indexInOwner;
        if (currentText.length > 0) {
            var spellInfo = this.spellChecker.checkSpellingInPageInfo(currentText);
            if (spellInfo.isElementPresent && this.spellChecker.enableOptimizedSpellCheck) {
                var jsonObject = JSON.parse('{\"HasSpellingError\":' + spellInfo.hasSpellError + '}');
                // tslint:disable-next-line:max-line-length
                this.spellChecker.handleSplitWordSpellCheck(jsonObject, currentText, elementBox, true, underlineY, iteration, markindex, isLastItem);
            }
            else {
                /* tslint:disable:no-any */
                // tslint:disable-next-line:max-line-length
                this.spellChecker.CallSpellChecker(this.spellChecker.languageID, currentText, true, this.spellChecker.allowSpellCheckAndSuggestion).then(function (data) {
                    /* tslint:disable:no-any */
                    var jsonObject = JSON.parse(data);
                    // tslint:disable-next-line:max-line-length
                    var canUpdate = (elementBox.isVisible) && (indexInLine === elementBox.indexInOwner) && (indexinParagraph === elementBox.line.paragraph.indexInOwner);
                    // tslint:disable-next-line:max-line-length
                    _this.spellChecker.handleSplitWordSpellCheck(jsonObject, currentText, elementBox, canUpdate, underlineY, iteration, markindex, isLastItem);
                });
            }
        }
    };
    /**
     * Render Wavy Line
     * @param {ElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     * @param {string} color
     * @param {Underline} underline
     * @param {BaselineAlignment} baselineAlignment
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Renderer.prototype.renderWavyline = function (elementBox, left, top, underlineY, color, underline, baselineAlignment, backgroundColor) {
        if (elementBox.text.length > 1) {
            var renderedHeight = elementBox.height / (baselineAlignment === 'Normal' ? 1 : 1.5);
            var topMargin = elementBox.margin.top;
            var underlineHeight = renderedHeight / 20;
            var frequencyRange = 0.5;
            var amplitudeRange = 1.0;
            var stepToCover = .7;
            var y = 0;
            if (baselineAlignment === 'Subscript' || elementBox instanceof ListTextElementBox) {
                y = (renderedHeight - 2 * underlineHeight) + top;
                topMargin += elementBox.height - renderedHeight;
                y += topMargin > 0 ? topMargin : 0;
            }
            else {
                y = underlineY + top;
            }
            // tslint:disable-next-line:max-line-length
            var specialCharacter = this.spellChecker.getSpecialCharactersInfo(elementBox.text, elementBox.characterFormat);
            // tslint:disable-next-line:max-line-length
            var whiteSpaceData = this.spellChecker.getWhiteSpaceCharacterInfo(elementBox.text, elementBox.characterFormat);
            // tslint:disable-next-line:max-line-length
            var x = left + specialCharacter.beginningWidth + ((whiteSpaceData.isBeginning) ? whiteSpaceData.width : 0) + elementBox.margin.left;
            var x1 = x * this.viewer.zoomFactor + this.leftPosition;
            var y1 = y * this.viewer.zoomFactor + this.topPosition;
            // tslint:disable-next-line:max-line-length
            var x2 = x1 + this.getScaledValue(elementBox.width - (specialCharacter.beginningWidth + specialCharacter.endWidth) - whiteSpaceData.width);
            var startingPoint = new Point(x1, y1);
            var endingPoint = new Point(x2, y1);
            // tslint:disable-next-line:max-line-length
            this.drawWavy(startingPoint, endingPoint, (x2 - x1) * frequencyRange, amplitudeRange, stepToCover, color, elementBox.height, backgroundColor);
        }
    };
    /**
     * Draw wavy line
     * @param {Point} from
     * @param {Point} to
     * @param {Number} frequency
     * @param {Number} amplitude
     * @param {Number} step
     * @param {string} color
     * @param {Number} negative
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Renderer.prototype.drawWavy = function (from, to, frequency, amplitude, step, color, height, backColor, negative) {
        this.pageContext.save();
        this.pageContext.fillStyle = (!isNullOrUndefined(backColor) ? backColor : this.viewer.backgroundColor);
        this.pageContext.fillRect(from.x, from.y - amplitude, (to.x - from.x), amplitude * 3);
        this.pageContext.restore();
        this.pageContext.lineWidth = 1;
        this.pageContext.lineCap = 'round';
        this.pageContext.strokeStyle = color;
        this.pageContext.beginPath();
        //this.pageContext.save();
        var cx = 0;
        var cy = 0;
        var fx = from.x;
        var fy = from.y;
        var tx = to.x;
        var ty = to.y;
        var i = 0;
        var waveOffsetLength = 0;
        var ang = Math.atan2(ty - fy, tx - fx);
        var distance = Math.sqrt((fx - tx) * (fx - tx) + (fy - ty) * (fy - ty));
        var a = amplitude * 1;
        var f = Math.PI * frequency;
        for (i; i <= distance; i += step) {
            waveOffsetLength = Math.sin((i / distance) * f) * a;
            cx = from.x + Math.cos(ang) * i + Math.cos(ang - Math.PI / 2) * waveOffsetLength;
            cy = from.y + Math.sin(ang) * i + Math.sin(ang - Math.PI / 2) * waveOffsetLength;
            i > 0 ? this.pageContext.lineTo(cx, cy) : this.pageContext.moveTo(cx, cy);
        }
        this.pageContext.stroke();
        this.pageContext.restore();
    };
    /**
     * Returns tab leader
     */
    Renderer.prototype.getTabLeader = function (elementBox) {
        var textWidth = 0;
        var tabString = this.getTabLeaderString(elementBox.tabLeader);
        var tabText = tabString;
        textWidth = this.viewer.textHelper.getWidth(tabText, elementBox.characterFormat);
        var count = Math.floor(elementBox.width / textWidth);
        for (var i = 0; i <= count; i++) {
            tabText += tabString;
        }
        return tabText.slice(0, -1);
    };
    /**
     * Returns tab leader string.
     */
    Renderer.prototype.getTabLeaderString = function (tabLeader) {
        var tabString = '';
        switch (tabLeader) {
            case 'Dot':
                tabString = '.';
                break;
            case 'Hyphen':
                tabString = '-';
                break;
            case 'Underscore':
                tabString = '_';
                break;
        }
        return tabString;
    };
    /**
     * Clips the rectangle with specified position.
     * @param {number} xPos
     * @param {number} yPos
     * @param {number} width
     * @param {number} height
     */
    Renderer.prototype.clipRect = function (xPos, yPos, width, height) {
        this.pageContext.beginPath();
        this.pageContext.save();
        this.pageContext.rect(this.getScaledValue(xPos, 1), this.getScaledValue(yPos, 2), width, height);
        this.pageContext.clip();
    };
    /**
     * Renders underline.
     * @param {ElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     * @param {string} color
     * @param {Underline} underline
     * @param {BaselineAlignment} baselineAlignment
     */
    // tslint:disable-next-line:max-line-length
    Renderer.prototype.renderUnderline = function (elementBox, left, top, underlineY, color, underline, baselineAlignment) {
        var renderedHeight = elementBox.height / (baselineAlignment === 'Normal' ? 1 : 1.5);
        var topMargin = elementBox.margin.top;
        var underlineHeight = renderedHeight / 20;
        var y = 0;
        if (baselineAlignment === 'Subscript' || elementBox instanceof ListTextElementBox) {
            y = (renderedHeight - 2 * underlineHeight) + top;
            topMargin += elementBox.height - renderedHeight;
            y += topMargin > 0 ? topMargin : 0;
        }
        else {
            y = underlineY + top;
        }
        // tslint:disable-next-line:max-line-length
        this.pageContext.fillRect(this.getScaledValue(left + elementBox.margin.left, 1), this.getScaledValue(y, 2), this.getScaledValue(elementBox.width), this.getScaledValue(underlineHeight));
    };
    /**
     * Renders strike through.
     * @param {ElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {Strikethrough} strikethrough
     * @param {string} color
     * @param {BaselineAlignment} baselineAlignment
     */
    // tslint:disable-next-line:max-line-length
    Renderer.prototype.renderStrikeThrough = function (elementBox, left, top, strikethrough, color, baselineAlignment) {
        var renderedHeight = elementBox.height / (baselineAlignment === 'Normal' ? 1 : 1.5);
        var topMargin = elementBox.margin.top;
        if (baselineAlignment === 'Subscript') {
            topMargin += elementBox.height - renderedHeight;
        }
        top += topMargin > 0 ? topMargin : 0;
        var lineHeight = renderedHeight / 20;
        var y = (renderedHeight / 2) + (0.5 * lineHeight);
        var lineCount = 0;
        if (strikethrough === 'DoubleStrike') {
            y -= lineHeight;
        }
        while (lineCount < (strikethrough === 'DoubleStrike' ? 2 : 1)) {
            lineCount++;
            // tslint:disable-next-line:max-line-length
            this.pageContext.fillRect(this.getScaledValue(left + elementBox.margin.left, 1), this.getScaledValue(y + top, 2), this.getScaledValue(elementBox.width), this.getScaledValue(lineHeight));
            y += 2 * lineHeight;
        }
    };
    /**
     * Renders image element box.
     * @param {ImageElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     */
    // tslint:disable-next-line:max-line-length
    Renderer.prototype.renderImageElementBox = function (elementBox, left, top, underlineY) {
        var topMargin = elementBox.margin.top;
        var leftMargin = elementBox.margin.left;
        this.pageContext.textBaseline = 'top';
        var widgetWidth = 0;
        var isClipped = false;
        if (topMargin < 0 || elementBox.line.paragraph.width < elementBox.width) {
            var containerWid = elementBox.line.paragraph.containerWidget;
            // if (containerWid instanceof BodyWidget) {
            //     widgetWidth = containerWid.width + containerWid.x;
            // } else 
            if (containerWid instanceof TableCellWidget) {
                var leftIndent = 0;
                if (containerWid.childWidgets[0] instanceof ParagraphWidget) {
                    var paraAdv = containerWid.childWidgets[0];
                    leftIndent = paraAdv.paragraphFormat.leftIndent;
                }
                widgetWidth = containerWid.width + containerWid.margin.left - containerWid.leftBorderWidth - leftIndent;
                isClipped = true;
                // tslint:disable-next-line:max-line-length
                this.clipRect(left + leftMargin, top + topMargin, this.getScaledValue(widgetWidth), this.getScaledValue(containerWid.height));
            }
        }
        if (elementBox.isMetaFile) {
            /* tslint:disable:no-empty */
        }
        else {
            try {
                // tslint:disable-next-line:max-line-length
                this.pageContext.drawImage(elementBox.element, this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), this.getScaledValue(elementBox.width), this.getScaledValue(elementBox.height));
            }
            catch (e) {
                // tslint:disable-next-line:max-line-length
                elementBox.imageString = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAMAAAAJbSJIAAAAgVBMVEX///8AAADgAADY2Njl5eVcXFxjY2NZWVl/f3+wsLCmpqb4+PiioqKpqam7u7vV1dX2uLj2wsLhFRXzpKT3vb30sbHhCwv74+P40dH+9vbkIyO2trbBwcHLy8tsbGycnJz529v4zMzrbGzlLS3qZmblNzfrdXXoRkbvi4vvgYHlHh7CZsBOAAADpUlEQVR4nO3da1faQBSF4ekAUQlUEFs14AXxVv7/D6yaQiZx5mSEYXF2ut+PNKzyyK5diYDmR9czx34AB49C/CjE759w3jvvWr15Tdgz3atXE54f++EcIArxoxA/CvGjED8K8aMQPwrxoxA/CvGLEeZ9jPJdhfk4GyCUjb3ECGE/Q6m/q3DwfudjP0ERZYN9hKdn2hvd3+0jHJz5/kBVuTk96bbQUEjhYR9ckiikUH8UUqg/CinUH4UU6o9CCvVHIYX6o5BC/VFIof4opFB/FFKoPwop1B+FFOqPQgrjyxfjVC38Lxk9tnAxGqZqdKtSOE4GHA5/fuNJpDCtcNHbv4VqYYqPLjgfUViPQgrjozA2CptRSGF8/59w+Wrt+rr1btNna1cPzg0wwuXavncxabnX7PfHYYXzlYARvlobQZyUR9mXm+1NMEK7SSLONgcVV9vb8IQXv4J3KSeKKlxXxNCzONkeYp8AV3p9UT1+P3FWHVAsq5thhGZSEb1DrSZq7dS5HUdoLiuBZ6jORG3tCwAkNJfCUJ2Jrqe1P0ESCkMNTdSACYNDDU7UoAkDQw1P1MAJvUMVJmrwhJ6hShM1gMIvQxUnahCFjaHKEzWQQneoxR95ogZTWBuqPFEDKnSHKk/UoArdoYoTNbDC5lBDEzW4QjMpYiZqgIXG/S76JhwHK5zVVipcnkIVuv/RW/HyFKhwYhuFr6NiCmdNoDBUSGFjovJQEYXuRN9ahwoorJ8uSZenPsMTNk+X2q6jwgm/ntHL11HhhL4zenmoYEL/Gb04VCxh6KKTNFQoYfiikzBUJKF00Sk8VCChfF00OFQcYdt10dBQYYRT5xn0n9G7Q0X8GfCzNNEyZ6iPgD/HlydaVg11DfhajJaJlm2HugIUrlomWrYZKuJKHz6vHhbSM/hROdRnxNe1meuXYvW0DB6+aflYrB7dlzDiCM3N1dVN6GDhMCDhjlHYjEIK46MwNgqbUUhhfJ/vA07wO8N1vw94ONo/3e/lTpVOYfc/UyG//ZmqW52fi/FuTNW3/lZ+eguF+qOQQv1RSKH+KKRQfxRSqD8KKdQfhRTqj0IK9UchhfqjkEL9UUih/iikUH8UUqg/CmXh6Hsv3jlK+wnvD/vgkrSHMMuyu1P9ZdmuwnycDQYn+svG3n9KEUKT9zHyf6+IEWJHIX4U4kchfhTiRyF+FOJHIX4U4kchfnVhijeZa6sunCf4ZdPamteEHY5C/CjEr/vCv0ec0g+AtS1QAAAAAElFTkSuQmCC';
                // tslint:disable-next-line:max-line-length
                this.pageContext.drawImage(elementBox.element, this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), this.getScaledValue(elementBox.width), this.getScaledValue(elementBox.height));
            }
        }
        if (isClipped) {
            this.pageContext.restore();
        }
    };
    /**
     * Renders table outline.
     * @param {TableWidget} tableWidget
     */
    Renderer.prototype.renderTableOutline = function (tableWidget) {
        var layout = new Layout(this.viewer);
        var table = tableWidget;
        tableWidget.width = this.viewer.layout.getTableWidth(table);
        var border = !table.isBidiTable ? layout.getTableLeftBorder(table.tableFormat.borders)
            : layout.getTableRightBorder(table.tableFormat.borders);
        var lineWidth = 0;
        //ToDo: Need to draw the borders based on the line style.
        // if (!isNullOrUndefined(border )) {
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, tableWidget.x - tableWidget.margin.left - lineWidth / 2, tableWidget.y, tableWidget.x - tableWidget.margin.left - lineWidth / 2, tableWidget.y + tableWidget.height, lineWidth);
        // }
        border = layout.getTableTopBorder(table.tableFormat.borders);
        lineWidth = 0;
        // if (!isNullOrUndefined(border )) {
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, tableWidget.x - tableWidget.margin.left - lineWidth, tableWidget.y - lineWidth / 2, tableWidget.x + tableWidget.width + lineWidth + tableWidget.margin.right, tableWidget.y - lineWidth / 2, lineWidth);
        // }
        border = !table.isBidiTable ? layout.getTableRightBorder(table.tableFormat.borders)
            : layout.getTableLeftBorder(table.tableFormat.borders);
        lineWidth = 0;
        // if (!isNullOrUndefined(border )) {
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, tableWidget.x + tableWidget.width + tableWidget.margin.right + lineWidth / 2, tableWidget.y, tableWidget.x + tableWidget.width + tableWidget.margin.right + lineWidth / 2, tableWidget.y + tableWidget.height, lineWidth);
        // }
        border = layout.getTableBottomBorder(table.tableFormat.borders);
        lineWidth = 0;
        // if (!isNullOrUndefined(border )) {
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, tableWidget.x - tableWidget.margin.left - lineWidth, tableWidget.y + tableWidget.height - lineWidth / 2, tableWidget.x + tableWidget.width + lineWidth + tableWidget.margin.right, tableWidget.y + tableWidget.height - lineWidth / 2, lineWidth);
        // }
    };
    /**
     * Renders table cell outline.
     * @param {LayoutViewer} viewer
     * @param {TableCellWidget} cellWidget
     */
    // tslint:disable: max-func-body-length
    Renderer.prototype.renderTableCellOutline = function (viewer, cellWidget) {
        var layout = viewer.layout;
        var borders = undefined;
        var tableCell = cellWidget;
        var cellTopMargin = 0;
        var cellBottomMargin = 0;
        var cellLeftMargin = 0;
        var cellRightMargin = 0;
        var height = 0;
        var isBidiTable = cellWidget.ownerTable.isBidiTable;
        borders = tableCell.cellFormat.borders;
        if (cellWidget.containerWidget instanceof TableRowWidget) {
            cellBottomMargin = cellWidget.margin.bottom - cellWidget.containerWidget.bottomBorderWidth;
            cellTopMargin = cellWidget.margin.top - cellWidget.containerWidget.topBorderWidth;
        }
        cellLeftMargin = cellWidget.margin.left - cellWidget.leftBorderWidth;
        cellRightMargin = cellWidget.margin.right - cellWidget.rightBorderWidth;
        if (!isNullOrUndefined(tableCell.ownerRow) && tableCell.ownerRow.rowFormat.heightType === 'Exactly') {
            height = HelperMethods.convertPointToPixel(tableCell.ownerRow.rowFormat.height) + cellTopMargin + cellBottomMargin;
        }
        else {
            if (!isNullOrUndefined(tableCell.ownerRow) && [tableCell.ownerRow].length <= 1) {
                // tslint:disable-next-line:max-line-length
                height = Math.max(HelperMethods.convertPointToPixel(tableCell.ownerRow.rowFormat.height), cellWidget.height) + cellTopMargin + cellBottomMargin;
            }
            else {
                height = cellWidget.height + cellTopMargin + cellBottomMargin;
            }
        }
        var border = !isBidiTable ? TableCellWidget.getCellLeftBorder(tableCell) : TableCellWidget.getCellRightBorder(tableCell);
        var lineWidth = 0;
        // if (!isNullOrUndefined(border )) {
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth()); //Renders the cell left border.
        this.renderCellBackground(height, cellWidget, cellLeftMargin, lineWidth);
        var leftBorderWidth = lineWidth;
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, cellWidget.x - cellLeftMargin - lineWidth, cellWidget.y - cellTopMargin, cellWidget.x - cellLeftMargin - lineWidth, cellWidget.y + cellWidget.height + cellBottomMargin, lineWidth);
        // }
        border = TableCellWidget.getCellTopBorder(tableCell);
        // if (!isNullOrUndefined(border )) { //Renders the cell top border.        
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, cellWidget.x - cellWidget.margin.left - leftBorderWidth / 2, cellWidget.y - cellWidget.margin.top + lineWidth / 2, cellWidget.x + cellWidget.width + cellWidget.margin.right, cellWidget.y - cellWidget.margin.top + lineWidth / 2, lineWidth);
        // }
        var isLastCell = false;
        if (!isBidiTable) {
            isLastCell = tableCell.cellIndex === tableCell.ownerRow.childWidgets.length - 1;
        }
        else {
            isLastCell = tableCell.cellIndex === 0;
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0 || isLastCell) {
            border = isBidiTable ? TableCellWidget.getCellLeftBorder(tableCell) : TableCellWidget.getCellRightBorder(tableCell);
            // if (!isNullOrUndefined(border )) { //Renders the cell right border.           
            lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
            // tslint:disable-next-line:max-line-length
            this.renderSingleBorder(border, cellWidget.x + cellWidget.width + cellWidget.margin.right - lineWidth / 2, cellWidget.y - cellTopMargin, cellWidget.x + cellWidget.width + cellWidget.margin.right - lineWidth / 2, cellWidget.y + cellWidget.height + cellBottomMargin, lineWidth);
            // }
        }
        var nextRow = tableCell.ownerRow.nextWidget;
        //Specifies the next row is within the current table widget.
        //True means current row is not rendered at page end; Otherwise False.
        var nextRowIsInCurrentTableWidget = false;
        if (!isNullOrUndefined(nextRow)) {
            var nextRowWidget = undefined;
            // if (viewer.renderedElements.containsKey(nextRow) && viewer.renderedElements.get(nextRow).length > 0) {
            nextRowWidget = nextRow;
            // }
            if (nextRowWidget instanceof TableRowWidget) {
                // tslint:disable-next-line:max-line-length
                if (cellWidget.containerWidget instanceof TableRowWidget && cellWidget.containerWidget.containerWidget instanceof TableWidget) {
                    nextRowIsInCurrentTableWidget = cellWidget.containerWidget.containerWidget.childWidgets.indexOf(nextRowWidget) !== -1;
                }
            }
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0 || tableCell.ownerRow.rowIndex === tableCell.ownerTable.childWidgets.length - 1
            || (tableCell.cellFormat.rowSpan > 1
                && tableCell.ownerRow.rowIndex + tableCell.cellFormat.rowSpan >= tableCell.ownerTable.childWidgets.length) ||
            !nextRowIsInCurrentTableWidget) {
            // tslint:disable-next-line:max-line-length
            border = (tableCell.cellFormat.rowSpan > 1 && tableCell.ownerRow.rowIndex + tableCell.cellFormat.rowSpan === tableCell.ownerTable.childWidgets.length) ?
                //true part for vertically merged cells specifically.
                tableCell.getBorderBasedOnPriority(tableCell.cellFormat.borders.bottom, TableCellWidget.getCellBottomBorder(tableCell))
                //false part for remaining cases that has been handled inside method. 
                : TableCellWidget.getCellBottomBorder(tableCell);
            // if (!isNullOrUndefined(border )) {
            //Renders the cell bottom border.
            lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
            // tslint:disable-next-line:max-line-length
            this.renderSingleBorder(border, cellWidget.x - cellWidget.margin.left - leftBorderWidth / 2, cellWidget.y + cellWidget.height + cellBottomMargin + lineWidth / 2, cellWidget.x + cellWidget.width + cellWidget.margin.right, cellWidget.y + cellWidget.height + cellBottomMargin + lineWidth / 2, lineWidth);
            // }
        }
        border = layout.getCellDiagonalUpBorder(tableCell);
        // if (!isNullOrUndefined(border )) {
        //Renders the cell diagonal up border.
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        if (lineWidth > 0) {
            // tslint:disable-next-line:max-line-length
            this.renderSingleBorder(border, cellWidget.x - cellLeftMargin, cellWidget.y + cellWidget.height + cellBottomMargin, cellWidget.x + cellWidget.width + cellRightMargin, cellWidget.y - cellTopMargin, lineWidth);
            // }
        }
        border = layout.getCellDiagonalDownBorder(tableCell);
        // if (!isNullOrUndefined(border )) {
        //Renders the cell diagonal down border.
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        if (lineWidth > 0) {
            // tslint:disable-next-line:max-line-length
            this.renderSingleBorder(border, cellWidget.x - cellLeftMargin, cellWidget.y - cellTopMargin, cellWidget.x + cellWidget.width + cellRightMargin, cellWidget.y + cellWidget.height + cellBottomMargin, lineWidth);
        }
        // }
    };
    /**
     * Renders cell background.
     * @param {number} height
     * @param {TableCellWidget} cellWidget
     */
    Renderer.prototype.renderCellBackground = function (height, cellWidget, leftMargin, lineWidth) {
        var cellFormat = cellWidget.cellFormat;
        var bgColor = cellFormat.shading.backgroundColor === '#ffffff' ?
            cellWidget.ownerTable.tableFormat.shading.backgroundColor : cellFormat.shading.backgroundColor;
        var left = cellWidget.x - leftMargin - lineWidth;
        var top = cellWidget.y - HelperMethods.convertPointToPixel(cellWidget.topMargin);
        var width = cellWidget.width + leftMargin + lineWidth + cellWidget.margin.right;
        this.pageContext.beginPath();
        if (bgColor !== 'empty') {
            this.pageContext.fillStyle = HelperMethods.getColor(bgColor);
            // tslint:disable-next-line:max-line-length
            this.pageContext.fillRect(this.getScaledValue(left, 1), this.getScaledValue(top, 2), this.getScaledValue(width), this.getScaledValue(height));
            this.pageContext.closePath();
        }
        //Render foreground color
        if (cellFormat.shading.hasValue('foregroundColor')) {
            this.pageContext.beginPath();
            if (cellFormat.shading.foregroundColor !== 'empty') {
                this.pageContext.fillStyle = HelperMethods.getColor(cellFormat.shading.foregroundColor);
                // tslint:disable-next-line:max-line-length
                this.pageContext.fillRect(this.getScaledValue(left, 1), this.getScaledValue(top, 2), this.getScaledValue(width), this.getScaledValue(height));
                this.pageContext.closePath();
            }
        }
    };
    /**
     * Renders single border.
     * @param {WBorder} border
     * @param {number} startX
     * @param {number} startY
     * @param {number} endX
     * @param {number} endY
     * @param {number} lineWidth
     */
    // tslint:disable-next-line:max-line-length
    Renderer.prototype.renderSingleBorder = function (border, startX, startY, endX, endY, lineWidth) {
        this.pageContext.beginPath();
        this.pageContext.moveTo(this.getScaledValue(startX, 1), this.getScaledValue(startY, 2));
        this.pageContext.lineTo(this.getScaledValue(endX, 1), this.getScaledValue(endY, 2));
        this.pageContext.lineWidth = this.getScaledValue(lineWidth);
        // set line color
        this.pageContext.strokeStyle = border.color;
        if (lineWidth > 0) {
            this.pageContext.stroke();
        }
        this.pageContext.closePath();
    };
    /**
     * Gets scaled value.
     * @param {number} value
     * @param {number} type
     * @private
     */
    Renderer.prototype.getScaledValue = function (value, type) {
        if (this.isPrinting) {
            return value;
        }
        if (isNullOrUndefined(type)) {
            type = 0;
        }
        var x = value * this.viewer.zoomFactor;
        return x + (type === 1 ? this.pageLeft : (type === 2 ? this.pageTop : 0));
    };
    /**
     * Destroys the internal objects which is maintained.
     */
    Renderer.prototype.destroy = function () {
        this.viewer = undefined;
        if (!isNullOrUndefined(this.pageCanvasIn)) {
            this.pageCanvasIn.innerHTML = '';
        }
        this.pageCanvasIn = undefined;
    };
    return Renderer;
}());

/**
 * @private
 */
var TextHelper = /** @__PURE__ @class */ (function () {
    function TextHelper(viewer) {
        this.paragraphMarkInfo = {};
        this.owner = viewer;
        if (!isNullOrUndefined(viewer)) {
            this.context = viewer.containerContext;
        }
    }
    Object.defineProperty(TextHelper.prototype, "paragraphMark", {
        get: function () {
            return '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextHelper.prototype, "lineBreakMark", {
        get: function () {
            return '';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    TextHelper.prototype.getParagraphMarkWidth = function (characterFormat) {
        return this.getParagraphMarkSize(characterFormat).Width;
    };
    /**
     * @private
     */
    TextHelper.prototype.getParagraphMarkSize = function (characterFormat) {
        var format = this.getFormatText(characterFormat);
        if (this.paragraphMarkInfo[format]) {
            return this.paragraphMarkInfo[format];
        }
        // Gets the text element's width;
        var width = this.getWidth(this.paragraphMark, characterFormat);
        // Calculate the text element's height and baseline offset.
        var textHelper = this.getHeight(characterFormat);
        var textSizeInfo = {
            'Width': width, 'Height': textHelper.Height, 'BaselineOffset': textHelper.BaselineOffset
        };
        return this.paragraphMarkInfo[format] = textSizeInfo;
    };
    /**
     * @private
     */
    TextHelper.prototype.getTextSize = function (elementBox, characterFormat) {
        // Gets the text element's width;
        var textTrimEndWidth = 0;
        var isRTL = characterFormat.bidi || this.isRTLText(elementBox.text);
        var text = this.setText(elementBox.text, isRTL, characterFormat.bdo);
        textTrimEndWidth = this.getWidth(text, characterFormat);
        elementBox.width = textTrimEndWidth;
        // Calculate the text element's height and baseline offset.
        var textHelper = this.getHeight(characterFormat);
        elementBox.height = textHelper.Height;
        elementBox.baselineOffset = textHelper.BaselineOffset;
        if (elementBox.text[elementBox.text.length - 1] === ' ') {
            textTrimEndWidth = this.getWidth(HelperMethods.trimEnd(elementBox.text), characterFormat);
        }
        return textTrimEndWidth;
    };
    /**
     * @private
     */
    TextHelper.prototype.getHeight = function (characterFormat) {
        // Get character format property as  below predefined structure to make it easy to check and retrieve
        // Predefined static structure `[FontName];[FontSize];bold;italic` to maintain as key in the collection 
        var key = this.getFormatText(characterFormat);
        if (!isNullOrUndefined(this.owner.heightInfoCollection[key])) {
            return this.owner.heightInfoCollection[key];
        }
        var sizeInfo = this.getHeightInternal(characterFormat);
        this.owner.heightInfoCollection[key] = sizeInfo;
        return sizeInfo;
    };
    /**
     * @private
     */
    TextHelper.prototype.getFormatText = function (characterFormat) {
        var formatText = characterFormat.fontFamily.toLocaleLowerCase();
        formatText += ';' + characterFormat.fontSize;
        if (characterFormat.bold) {
            formatText += ';' + 'bold';
        }
        if (characterFormat.italic) {
            formatText += ';' + 'italic';
        }
        return formatText;
    };
    /**
     * @private
     */
    TextHelper.prototype.getHeightInternal = function (characterFormat) {
        var textHeight = 0;
        var baselineOffset = 0;
        var spanElement = document.createElement('span');
        spanElement.innerText = 'm';
        this.applyStyle(spanElement, characterFormat);
        var parentDiv = document.createElement('div');
        parentDiv.setAttribute('style', 'display:inline-block;position:absolute;');
        var tempDiv = document.createElement('div');
        tempDiv.setAttribute('style', 'display:inline-block;width: 1px; height: 0px;vertical-align: baseline;');
        parentDiv.appendChild(spanElement);
        parentDiv.appendChild(tempDiv);
        document.body.appendChild(parentDiv);
        // Sets the text element's height.
        textHeight = spanElement.offsetHeight;
        // Calculate the text element's baseline offset.
        var textTopVal = spanElement.offsetTop;
        var tempDivTopVal = tempDiv.offsetTop;
        var width = (parentDiv.offsetWidth - spanElement.offsetWidth);
        if ((textTopVal - width) === 1) {
            tempDivTopVal += width;
        }
        baselineOffset = tempDivTopVal - textTopVal;
        document.body.removeChild(parentDiv);
        return { 'Height': textHeight, 'BaselineOffset': baselineOffset };
    };
    /**
     * @private
     */
    TextHelper.prototype.measureTextExcludingSpaceAtEnd = function (text, characterFormat) {
        return this.getWidth(HelperMethods.trimEnd(text), characterFormat);
    };
    /**
     * @private
     */
    TextHelper.prototype.getWidth = function (text, characterFormat) {
        if (text.match('\v')) {
            text.replace('\v', this.lineBreakMark);
        }
        var bold = '';
        var italic = '';
        var fontFamily = '';
        var fontSize = characterFormat.fontSize;
        bold = characterFormat.bold ? 'bold' : '';
        italic = characterFormat.italic ? 'italic' : '';
        fontFamily = characterFormat.fontFamily;
        fontSize = fontSize === 0 ? 0.5 : fontSize / (characterFormat.baselineAlignment === 'Normal' ? 1 : 1.5);
        this.context.font = bold + ' ' + italic + ' ' + fontSize + 'pt' + ' ' + fontFamily;
        return this.context.measureText(text).width;
    };
    TextHelper.prototype.setText = function (textToRender, isBidi, bdo, isRender) {
        if (isNullOrUndefined(isRender)) {
            isRender = false;
        }
        if (textToRender.length === 0) {
            return '';
        }
        var isRtlText = isBidi;
        if ((!isRtlText && (bdo === 'RTL')) || (isRtlText && (bdo === 'LTR'))) {
            textToRender = HelperMethods.ReverseString(textToRender);
        }
        else if (isRender && isRtlText && HelperMethods.endsWith(textToRender)) {
            var spaceCount = textToRender.length - HelperMethods.trimEnd(textToRender).length;
            textToRender = HelperMethods.addSpace(spaceCount) + HelperMethods.trimEnd(textToRender);
        }
        return textToRender;
    };
    /**
     * @private
     */
    TextHelper.prototype.applyStyle = function (spanElement, characterFormat) {
        if (!isNullOrUndefined(spanElement) && !isNullOrUndefined(characterFormat)) {
            var style = 'white-space:nowrap;';
            if (characterFormat.fontFamily !== '') {
                style += 'font-family:' + characterFormat.fontFamily + ';';
            }
            var fontSize = characterFormat.fontSize;
            if (fontSize <= 0.5) {
                fontSize = 0.5;
            }
            style += 'font-size:' + fontSize.toString() + 'pt;';
            if (characterFormat.bold) {
                style += 'font-weight:bold;';
            }
            if (characterFormat.italic) {
                style += 'font-style:italic;';
            }
            spanElement.setAttribute('style', style);
        }
    };
    /**
     * @private
     */
    TextHelper.prototype.measureText = function (text, characterFormat) {
        // Gets the text element's width;
        var width = this.getWidth(text, characterFormat);
        var textHelper = this.getHeight(characterFormat);
        return {
            'Width': width, 'Height': textHelper.Height, 'BaselineOffset': textHelper.BaselineOffset
        };
    };
    /**
     * @private
     */
    TextHelper.prototype.updateTextSize = function (elementBox, paragraph) {
        var format = new WCharacterFormat(undefined);
        var listCharacterFormat = elementBox.listLevel.characterFormat;
        var breakCharacterFormat = paragraph.characterFormat;
        format.fontSize = listCharacterFormat.fontSize === 11 ? breakCharacterFormat.fontSize : listCharacterFormat.fontSize;
        format.fontFamily = listCharacterFormat.fontFamily === 'Verdana' ? breakCharacterFormat.fontFamily
            : listCharacterFormat.fontFamily;
        var bold = '';
        var italic = '';
        var baselineAlignment = listCharacterFormat.baselineAlignment === 'Normal' ?
            breakCharacterFormat.baselineAlignment : listCharacterFormat.baselineAlignment;
        bold = listCharacterFormat.bold ? 'bold' : breakCharacterFormat.bold ? 'bold' : '';
        italic = listCharacterFormat.italic ? 'italic' : breakCharacterFormat.italic ? 'italic' : '';
        format.baselineAlignment = baselineAlignment;
        if (bold) {
            format.bold = true;
        }
        if (italic) {
            format.italic = true;
        }
        var isRTL = format.bidi || this.isRTLText(elementBox.text);
        var text = this.setText(elementBox.text, isRTL, format.bdo);
        elementBox.width = this.getWidth(text, format);
        // Calculate the text element's height and baseline offset.
        var textHelper = this.getHeight(format);
        elementBox.height = textHelper.Height;
        elementBox.baselineOffset = textHelper.BaselineOffset;
    };
    /**
     * @private
     * @param text
     */
    TextHelper.prototype.containsSpecialCharAlone = function (text) {
        var specialChars = '*|.\:[]{}`\;()@&$#%!~';
        for (var i = 0; i < text.length; i++) {
            if (specialChars.indexOf(text.charAt(i)) === -1) {
                return false;
            }
        }
        return true;
    };
    /**
     * @private
     * @param text
     */
    TextHelper.prototype.containsSpecialChar = function (text) {
        var specialChars = '*|.\:[]{}`\;()@&$#%!~';
        for (var i = 0; i < text.length; i++) {
            if (specialChars.indexOf(text.charAt(i)) !== -1) {
                return true;
            }
        }
        return false;
    };
    /**
     * @private
     */
    TextHelper.prototype.isRTLText = function (text) {
        var isRTL = false;
        if (!isNullOrUndefined(text)) {
            for (var i = 0; i < text.length; i++) {
                var temp = text[i];
                if ((temp >= '\u0590' && temp <= '\u05ff') //Hebrew characters
                    || (temp >= '\u0600' && temp <= '\u06ff') //Arabic - Urdu characters
                    || (temp >= '\u0750' && temp <= '\u077f') //Arabic - Urdu characters
                    || (temp >= '\u08a0' && temp <= '\u08ff') //Arabic characters
                    || (temp >= '\ufb50' && temp <= '\ufdff') //Arabic - Urdu characters
                    || (temp >= '\ufe70' && temp <= '\ufeff') //Arabic - Urdu characters
                    || (temp >= '\ua980' && temp <= '\ua9df') //Javanese characters
                    || (temp >= '\u0700' && temp <= '\u074f') //Syriac characters
                    || (temp >= '\u0780' && temp <= '\u07bf') //Thaana characters
                    || (temp >= '\u0840' && temp <= '\u085f') //Mandiac characters
                    || (temp >= '\u07c0' && temp <= '\u07ff') //N'Ko characters
                    || (temp >= '\u0800' && temp <= '\u083f') //Samaritan characters
                    //Tifinag characters 
                    || (temp >= '\u2d30' && temp <= '\u2d7f')) {
                    isRTL = true;
                    break;
                }
            }
        }
        return isRTL;
    };
    /**
     * @private
     */
    TextHelper.prototype.getRtlLanguage = function (text) {
        if (isNullOrUndefined(text) || text === '') {
            return { isRtl: false, id: 0 };
        }
        if (text >= '\u0590' && text <= '\u05ff') {
            return { isRtl: true, id: 1 };
            //Arabic - Urdu characters
        }
        else if ((text >= '\u0600' && text <= '\u06ff')
            || (text >= '\u0750' && text <= '\u077f')
            || (text >= '\u08a0' && text <= '\u08ff')
            || (text >= '\ufb50' && text <= '\ufdff')
            || (text >= '\ufe70' && text <= '\ufeff')) {
            return { isRtl: true, id: 2 };
        }
        else if (text >= '\ua980' && text <= '\ua9df') {
            return { isRtl: true, id: 3 };
        }
        else if (text >= '\u0700' && text <= '\u074f') {
            return { isRtl: true, id: 4 };
        }
        else if (text >= '\u0780' && text <= '\u07bf') {
            return { isRtl: true, id: 5 };
        }
        else if (text >= '\u0840' && text <= '\u085f') {
            return { isRtl: true, id: 6 };
        }
        else if (text >= '\u07c0' && text <= '\u07ff') {
            return { isRtl: true, id: 7 };
        }
        else if (text >= '\u0800' && text <= '\u083f') {
            return { isRtl: true, id: 8 };
        }
        else if (text >= '\u2d30' && text <= '\u2d7f') {
            return { isRtl: true, id: 9 };
        }
        return { isRtl: false, id: 0 };
    };
    TextHelper.prototype.destroy = function () {
        this.owner = undefined;
        this.context = undefined;
        this.paragraphMarkInfo = {};
        this.paragraphMarkInfo = undefined;
    };
    return TextHelper;
}());

/**
 * @private
 */
var Zoom = /** @__PURE__ @class */ (function () {
    function Zoom(viewer) {
        var _this = this;
        this.onMouseWheelInternal = function (event) {
            if (event.ctrlKey === true) {
                event.preventDefault();
                var pageX = event.pageX - _this.viewer.viewerContainer.offsetLeft;
                if (pageX < _this.viewer.pageContainer.offsetWidth) {
                    var wheel = navigator.userAgent.match('Firefox') ? event.detail < 0 : event.wheelDelta > 0;
                    var zoomFactor = _this.viewer.zoomFactor;
                    if (wheel) {
                        if (zoomFactor <= 4.90) {
                            zoomFactor += .10;
                        }
                        else {
                            zoomFactor = 5.00;
                        }
                    }
                    else {
                        if (zoomFactor >= .20) {
                            zoomFactor -= .10;
                        }
                        else {
                            zoomFactor = 0.10;
                        }
                    }
                    _this.viewer.zoomFactor = zoomFactor;
                }
            }
        };
        this.viewer = viewer;
    }
    Zoom.prototype.setZoomFactor = function (value) {
        this.onZoomFactorChanged();
        if (!isNullOrUndefined(this.viewer.selection)) {
            this.viewer.selection.updateCaretPosition();
        }
        this.viewer.updateTouchMarkPosition();
        if (!isNullOrUndefined(this.viewer.owner.imageResizerModule)) {
            this.viewer.owner.imageResizerModule.updateImageResizerPosition();
        }
        this.viewer.owner.fireZoomFactorChange();
    };
    //Zoom Implementation Starts
    Zoom.prototype.onZoomFactorChanged = function () {
        if (this.viewer.zoomFactor > 5) {
            this.viewer.zoomFactor = 5;
        }
        else if (this.viewer.zoomFactor < 0.1) {
            this.viewer.zoomFactor = 0.1;
        }
        this.zoom();
    };
    Zoom.prototype.zoom = function () {
        var viewer = this.viewer;
        viewer.clearContent();
        viewer.handleZoom();
        viewer.updateFocus();
    };
    return Zoom;
}());

/**
 * @private
 */
var AddUserDialog = /** @__PURE__ @class */ (function () {
    function AddUserDialog(viewer, owner) {
        var _this = this;
        /**
         * @private
         */
        this.show = function () {
            var localObj = new L10n('documenteditor', _this.viewer.owner.defaultLocale);
            localObj.setLocale(_this.viewer.owner.locale);
            if (!_this.target) {
                _this.initUserDialog(localObj, _this.viewer.owner.enableRtl);
            }
            _this.viewer.dialog.header = localObj.getConstant('Add Users');
            _this.viewer.dialog.height = 'auto';
            _this.viewer.dialog.width = 'auto';
            _this.viewer.dialog.content = _this.target;
            _this.viewer.dialog.beforeOpen = _this.loadUserDetails;
            _this.viewer.dialog.close = _this.viewer.updateFocus;
            _this.viewer.dialog.buttons = [
                {
                    click: _this.okButtonClick,
                    buttonModel: {
                        content: localObj.getConstant('Ok'), cssClass: 'e-flat', isPrimary: true
                    }
                },
                {
                    click: _this.hideDialog,
                    buttonModel: { content: localObj.getConstant('Cancel'), cssClass: 'e-flat' }
                }, {
                    click: _this.deleteButtonClick,
                    buttonModel: { content: localObj.getConstant('Delete'), cssClass: 'e-flat e-user-delete' }
                }
            ];
            _this.viewer.dialog.dataBind();
            _this.viewer.dialog.show();
        };
        this.loadUserDetails = function () {
            _this.viewer.restrictEditingPane.addedUser.dataSource = _this.viewer.userCollection;
            _this.viewer.restrictEditingPane.addedUser.refresh();
        };
        /**
         * @private
         */
        this.okButtonClick = function () {
            _this.viewer.restrictEditingPane.showStopProtectionPane(false);
            _this.viewer.restrictEditingPane.loadPaneValue();
            _this.viewer.dialog.hide();
        };
        /**
         * @private
         */
        this.hideDialog = function () {
            _this.textBoxInput.value = '';
            _this.viewer.dialog.hide();
        };
        /**
         * @private
         */
        this.onKeyUpOnDisplayBox = function () {
            _this.addButton.disabled = _this.textBoxInput.value === '';
        };
        this.addButtonClick = function () {
            if (_this.validateUserName(_this.textBoxInput.value)) {
                if (_this.viewer.userCollection.indexOf(_this.textBoxInput.value) === -1) {
                    _this.viewer.userCollection.push(_this.textBoxInput.value);
                }
                _this.userList.dataSource = _this.viewer.userCollection;
                _this.userList.refresh();
                _this.textBoxInput.value = '';
            }
            else {
                DialogUtility.alert('Invalid user name');
            }
        };
        this.deleteButtonClick = function () {
            var index = _this.viewer.userCollection.indexOf(_this.userList.getSelectedItems().text);
            if (index > -1) {
                _this.viewer.userCollection.splice(index, 1);
                _this.userList.dataSource = _this.viewer.userCollection;
                _this.userList.refresh();
            }
        };
        this.viewer = viewer;
        this.owner = owner;
    }
    /**
     * @private
     */
    AddUserDialog.prototype.initUserDialog = function (localValue, isRtl) {
        var instance = this;
        var id = this.viewer.owner.containerId + '_addUser';
        this.target = createElement('div', { id: id, className: 'e-de-user-dlg' });
        var headerValue = localValue.getConstant('Enter User');
        var dlgFields = createElement('div', { innerHTML: headerValue, className: 'e-bookmark-dlgfields' });
        this.target.appendChild(dlgFields);
        var commonDiv = createElement('div', { className: 'e-de-user-dlg-common' });
        this.target.appendChild(commonDiv);
        var adduserDiv = createElement('div', { className: 'e-de-user-dlg-list', styles: 'display:inline-flex' });
        commonDiv.appendChild(adduserDiv);
        if (isRtl) {
            adduserDiv.classList.add('e-de-rtl');
        }
        var textBoxDiv = createElement('div', { className: 'e-de-user-dlg-textboxdiv' });
        adduserDiv.appendChild(textBoxDiv);
        // tslint:disable-next-line:max-line-length
        this.textBoxInput = createElement('input', { className: 'e-input e-de-user-dlg-textbox-input', id: 'bookmark_text_box', attrs: { autofocus: 'true' } });
        this.textBoxInput.setAttribute('type', 'text');
        textBoxDiv.appendChild(this.textBoxInput);
        this.textBoxInput.addEventListener('keyup', instance.onKeyUpOnDisplayBox);
        var addButtonElement = createElement('button', {
            innerHTML: localValue.getConstant('Add'), id: 'add',
            attrs: { type: 'button' }
        });
        adduserDiv.appendChild(addButtonElement);
        addButtonElement.addEventListener('click', this.addButtonClick);
        this.addButton = new Button({ cssClass: 'e-de-user-add-btn' });
        this.addButton.disabled = true;
        this.addButton.appendTo(addButtonElement);
        this.addButton.addEventListener('click', this.addButtonClick);
        var userCollectionDiv = createElement('div');
        commonDiv.appendChild(userCollectionDiv);
        var userDiv = createElement('div', { innerHTML: localValue.getConstant('Users'), className: 'e-de-user-dlg-user' });
        userCollectionDiv.appendChild(userDiv);
        var listviewDiv = createElement('div', { id: 'user_listView' });
        userCollectionDiv.appendChild(listviewDiv);
        this.userList = new ListView({
            cssClass: 'e-de-user-listview'
        });
        this.userList.appendTo(listviewDiv);
    };
    AddUserDialog.prototype.validateUserName = function (value) {
        if (value.indexOf('@') === -1) {
            return false;
        }
        else {
            var parts = value.split('@');
            var domain = parts[1];
            if (domain.indexOf('.') === -1) {
                return false;
            }
            else {
                var domainParts = domain.split('.');
                var ext = domainParts[1];
                if (domainParts.length > 2) {
                    return false;
                }
                if (ext.length > 4 || ext.length < 2) {
                    return false;
                }
            }
        }
        return true;
    };
    return AddUserDialog;
}());

/**
 * @private
 */
var EnforceProtectionDialog = /** @__PURE__ @class */ (function () {
    function EnforceProtectionDialog(viewer, owner) {
        var _this = this;
        /**
         * @private
         */
        this.show = function () {
            _this.localeValue = new L10n('documenteditor', _this.viewer.owner.defaultLocale);
            _this.localeValue.setLocale(_this.viewer.owner.locale);
            if (!_this.target) {
                _this.initDialog(_this.localeValue, _this.viewer.owner.enableRtl);
            }
            _this.viewer.dialog.header = _this.localeValue.getConstant('Start Enforcing Protection');
            _this.viewer.dialog.height = 'auto';
            _this.viewer.dialog.content = _this.target;
            _this.viewer.dialog.width = 'auto';
            _this.viewer.dialog.buttons = [{
                    click: _this.okButtonClick,
                    buttonModel: { content: _this.localeValue.getConstant('Ok'), cssClass: 'e-flat', isPrimary: true }
                },
                {
                    click: _this.hideDialog,
                    buttonModel: { content: _this.localeValue.getConstant('Cancel'), cssClass: 'e-flat' }
                }];
            _this.passwordTextBox.value = '';
            _this.confirmPasswordTextBox.value = '';
            _this.viewer.dialog.show();
        };
        this.hideDialog = function () {
            _this.passwordTextBox.value = '';
            _this.confirmPasswordTextBox.value = '';
            _this.viewer.dialog.hide();
        };
        /**
         * @private
         */
        this.okButtonClick = function () {
            if (_this.passwordTextBox.value !== _this.confirmPasswordTextBox.value) {
                /* tslint:disable */
                DialogUtility.alert(_this.localeValue.getConstant('Password Mismatch'));
                /* tslint:enable */
            }
            else {
                _this.password = _this.passwordTextBox.value;
                _this.viewer.owner.editor.addProtection(_this.password);
            }
        };
        this.viewer = viewer;
        this.owner = owner;
    }
    /**
     * @private
     */
    EnforceProtectionDialog.prototype.initDialog = function (localValue, isRtl) {
        var id = this.viewer.owner.containerId + '_enforce_protection';
        this.target = createElement('div', { id: id, className: 'e-de-enforce' });
        var container = createElement('div');
        // tslint:disable-next-line:max-line-length
        var newPassWord = createElement('div', { className: 'e-de-enforce-dlg-title', innerHTML: localValue.getConstant('Enter new password') });
        // tslint:disable-next-line:max-line-length
        this.passwordTextBox = createElement('input', { attrs: { type: 'password', autofocus: 'true' }, id: this.viewer.owner.containerId + '_display_text', className: 'e-input e-de-enforce-dlg-input' });
        // this.passwordTextBox.addEventListener('keyup', instance.onKeyUpOnDisplayBox);
        container.appendChild(newPassWord);
        container.appendChild(this.passwordTextBox);
        // tslint:disable-next-line:max-line-length
        var confirmPassword = createElement('div', { className: 'e-de-enforce-dlg-title', innerHTML: localValue.getConstant('Reenter new password to confirm') });
        // tslint:disable-next-line:max-line-length
        this.confirmPasswordTextBox = createElement('input', { attrs: { type: 'password' }, id: this.viewer.owner.containerId + '_url_text', className: 'e-input e-de-enforce-dlg-input' });
        container.appendChild(confirmPassword);
        container.appendChild(this.confirmPasswordTextBox);
        this.target.appendChild(container);
    };
    return EnforceProtectionDialog;
}());
/**
 * @private
 */
var UnProtectDocumentDialog = /** @__PURE__ @class */ (function () {
    function UnProtectDocumentDialog(viewer, owner) {
        var _this = this;
        /**
         * @private
         */
        this.show = function () {
            _this.localObj = new L10n('documenteditor', _this.viewer.owner.defaultLocale);
            _this.localObj.setLocale(_this.viewer.owner.locale);
            if (!_this.target) {
                _this.initDialog(_this.localObj, _this.viewer.owner.enableRtl);
            }
            _this.viewer.dialog.header = 'Unprotect Document';
            _this.viewer.dialog.height = 'auto';
            _this.viewer.dialog.width = 'auto';
            _this.viewer.dialog.content = _this.target;
            _this.viewer.dialog.buttons = [{
                    click: _this.okButtonClick,
                    buttonModel: { content: _this.localObj.getConstant('Ok'), cssClass: 'e-flat', isPrimary: true }
                },
                {
                    click: _this.hideDialog,
                    buttonModel: { content: _this.localObj.getConstant('Cancel'), cssClass: 'e-flat' }
                }];
            _this.viewer.dialog.dataBind();
            _this.passwordTextBox.value = '';
            _this.viewer.dialog.show();
        };
        /**
         * @private
         */
        /* tslint:disable:no-any */
        this.okButtonClick = function () {
            var password = _this.passwordTextBox.value;
            if (password === '') {
                return;
            }
            _this.viewer.owner.editor.stopProtection(password);
        };
        /**
         * @private
         */
        this.hideDialog = function () {
            _this.passwordTextBox.value = '';
            _this.viewer.dialog.hide();
        };
        this.viewer = viewer;
        this.owner = owner;
    }
    /**
     * @private
     */
    UnProtectDocumentDialog.prototype.initDialog = function (localValue, isRtl) {
        var id = this.viewer.owner.containerId + '_enforce_protection';
        this.target = createElement('div', { id: id, className: 'e-de-enforce' });
        var container = createElement('div');
        var newPassWord = createElement('div', {
            className: 'e-de-unprotect-dlg-title',
            innerHTML: localValue.getConstant('Password')
        });
        this.passwordTextBox = createElement('input', {
            attrs: { type: 'password' },
            id: this.viewer.owner.containerId + '_display_text', className: 'e-input e-de-enforce-dlg-input'
        });
        // this.passwordTextBox.addEventListener('keyup', instance.onKeyUpOnDisplayBox);
        container.appendChild(newPassWord);
        container.appendChild(this.passwordTextBox);
        this.target.appendChild(container);
    };
    return UnProtectDocumentDialog;
}());

/**
 * @private
 */
var RestrictEditing = /** @__PURE__ @class */ (function () {
    function RestrictEditing(viewer) {
        var _this = this;
        this.addRemove = true;
        this.protectionType = 'NoProtection';
        this.restrictFormatting = false;
        this.isShowRestrictPane = false;
        this.usersCollection = ['Everyone'];
        this.closePane = function () {
            _this.restrictPane.style.display = 'none';
            _this.viewer.updateViewerSize();
        };
        /* tslint:disable:no-any */
        this.enableFormatting = function (args) {
            _this.restrictFormatting = !args.checked;
        };
        this.readOnlyChanges = function (args) {
            if (args.checked) {
                _this.protectionType = 'ReadOnly';
            }
            else {
                _this.protectionType = 'NoProtection';
                _this.addedUser.uncheckAllItems();
                _this.viewer.owner.editor.removeAllEditRestrictions();
            }
        };
        this.selectHandler = function (args) {
            if (args.isChecked) {
                _this.viewer.owner.editor.insertEditRangeElement(args.text);
                args.event.target.classList.add('e-check');
            }
            else {
                _this.viewer.owner.editor.removeUserRestrictions(args.text);
            }
        };
        this.highlightClicked = function (args) {
            _this.viewer.selection.isHighlightEditRegion = args.checked;
        };
        /* tslint:enable:no-any */
        this.protectDocument = function () {
            _this.enforceProtectionDialog.show();
        };
        this.navigateNextRegion = function () {
            _this.viewer.selection.navigateToNextEditingRegion();
        };
        this.showAllRegion = function () {
            _this.viewer.selection.showAllEditingRegion();
        };
        this.viewer = viewer;
        this.addUserDialog = new AddUserDialog(viewer, this);
        this.enforceProtectionDialog = new EnforceProtectionDialog(viewer, this);
        this.unProtectDialog = new UnProtectDocumentDialog(viewer, this);
        this.base64 = new Base64();
    }
    RestrictEditing.prototype.showHideRestrictPane = function (isShow) {
        if (isShow) {
            this.localObj = new L10n('documenteditor', this.viewer.owner.defaultLocale);
            this.localObj.setLocale(this.viewer.owner.locale);
            if (!this.restrictPane) {
                this.initPane(this.localObj, true);
            }
            this.restrictPane.style.display = 'block';
            this.isShowRestrictPane = true;
            this.viewer.selection.isHighlightEditRegion = true;
            this.wireEvents();
            this.viewer.updateViewerSize();
            this.loadPaneValue();
        }
        else {
            this.closePane();
            this.viewer.updateFocus();
        }
    };
    RestrictEditing.prototype.initPane = function (localValue, initial) {
        this.restrictPane = createElement('div', { className: 'e-de-restrict-pane', styles: 'display:none' });
        var headerWholeDiv = createElement('div', { className: 'e-de-rp-whole-header' });
        var headerDiv1 = createElement('div', {
            styles: 'width:75%',
            innerHTML: localValue.getConstant('Restrict Editing'), className: 'e-de-rp-header'
        });
        this.closeButton = createElement('button', {
            className: 'e-de-rp-close-icon e-btn e-flat e-icon-btn', id: 'close',
            attrs: { type: 'button' }
        });
        headerWholeDiv.appendChild(this.closeButton);
        headerWholeDiv.appendChild(headerDiv1);
        var closeSpan = createElement('span', { className: 'e-de-op-close-icon e-btn-icon e-icons' });
        this.closeButton.appendChild(closeSpan);
        this.restrictPane.appendChild(headerWholeDiv);
        this.initRestrictEditingPane(localValue);
        this.viewer.optionsPaneContainer.setAttribute('style', 'display:inline-flex;');
        this.viewer.optionsPaneContainer.insertBefore(this.restrictPane, this.viewer.viewerContainer);
    };
    // tslint:disable:max-func-body-length
    RestrictEditing.prototype.initRestrictEditingPane = function (localObj) {
        this.restrictPaneWholeDiv = createElement('div');
        var formatWholeDiv = createElement('div', { className: 'e-de-rp-sub-div' });
        var formatDiv = createElement('div', {
            innerHTML: localObj.getConstant('Formatting restrictions'),
            className: 'e-de-rp-format'
        });
        formatWholeDiv.appendChild(formatDiv);
        var allowFormatting = createElement('input', {
            attrs: { type: 'checkbox' },
            id: this.viewer.owner.containerId + '_allowFormat',
        });
        formatWholeDiv.appendChild(allowFormatting);
        this.allowFormat = this.createCheckBox(localObj.getConstant('Allow formatting'), allowFormatting);
        this.restrictPaneWholeDiv.appendChild(formatWholeDiv);
        // Editing restrictions
        var editRestrictWholeDiv = createElement('div', { className: 'e-de-rp-sub-div' });
        var editRestrict = createElement('div', {
            innerHTML: localObj.getConstant('Editing restrictions'),
            className: 'e-de-rp-format'
        });
        editRestrictWholeDiv.appendChild(editRestrict);
        var readOnly = createElement('input', {
            attrs: { type: 'checkbox' },
            id: this.viewer.owner.containerId + '_readOnly'
        });
        editRestrictWholeDiv.appendChild(readOnly);
        this.readonly = this.createCheckBox('Read only', readOnly);
        // let allowPrint: HTMLInputElement = createElement('input', {
        //     attrs: { type: 'checkbox' },
        //     id: this.viewer.owner.containerId + '_allowPrint'
        // }) as HTMLInputElement;
        // editRestrictWholeDiv.appendChild(allowPrint);
        // this.allowPrint = this.createCheckBox('Allow Printing', allowPrint);
        // let allowCopy: HTMLInputElement = createElement('input', {
        //     attrs: { type: 'checkbox' },
        //     id: this.viewer.owner.containerId + '_allowCopy'
        // }) as HTMLInputElement;
        // editRestrictWholeDiv.appendChild(allowCopy);
        // this.allowCopy = this.createCheckBox('Allow Copy', allowCopy);
        this.restrictPaneWholeDiv.appendChild(editRestrictWholeDiv);
        // User Permissions
        var userWholeDiv = createElement('div', { className: 'e-de-rp-sub-div' });
        var userDiv = createElement('div', {
            innerHTML: localObj.getConstant('Exceptions Optional'),
            className: 'e-de-rp-format'
        });
        userWholeDiv.appendChild(userDiv);
        var subContentDiv = createElement('div', {
            innerHTML: localObj.getConstant('Select Part Of Document And User'),
            styles: 'margin-bottom:8px;'
        });
        userWholeDiv.appendChild(subContentDiv);
        var emptyuserDiv = createElement('div', { className: 'e-de-rp-user' });
        userWholeDiv.appendChild(emptyuserDiv);
        this.addedUser = new ListView({
            cssClass: 'e-de-user-listView',
            dataSource: [{ text: 'Everyone' }],
            showCheckBox: true,
            select: this.selectHandler
        });
        this.addedUser.appendTo(emptyuserDiv);
        this.addUser = createElement('button', {
            id: this.viewer.owner.containerId + '_addUser',
            className: 'e-btn e-primary e-flat',
            innerHTML: localObj.getConstant('More users')
        });
        userWholeDiv.appendChild(this.addUser);
        this.restrictPaneWholeDiv.appendChild(userWholeDiv);
        var lastDiv = createElement('div', { className: 'e-de-rp-enforce' });
        this.restrictPaneWholeDiv.appendChild(lastDiv);
        this.enforceProtection = createElement('button', {
            id: this.viewer.owner.containerId + '_addUser',
            innerHTML: localObj.getConstant('Enforcing Protection'),
            className: 'e-btn e-de-rp-btn-enforce'
        });
        lastDiv.appendChild(this.enforceProtection);
        this.restrictPane.appendChild(this.restrictPaneWholeDiv);
        this.stopProtectionDiv = createElement('div', { styles: 'display:none' });
        // tslint:disable-next-line:max-line-length
        var headerDiv = createElement('div', { innerHTML: localObj.getConstant('Your permissions'), className: 'e-de-rp-stop-div1' });
        this.stopProtectionDiv.appendChild(headerDiv);
        // tslint:disable-next-line:max-line-length
        var content = localObj.getConstant('Protected Document');
        var contentDiv1 = createElement('div', { innerHTML: content, className: 'e-de-rp-stop-div2' });
        this.stopProtectionDiv.appendChild(contentDiv1);
        // tslint:disable-next-line:max-line-length
        var contentDiv2 = createElement('div', { innerHTML: localObj.getConstant('You may format text only with certain styles'), className: 'e-de-rp-stop-div3' });
        this.stopProtectionDiv.appendChild(contentDiv2);
        this.stopReadOnlyOptions = createElement('div');
        this.stopProtectionDiv.appendChild(this.stopReadOnlyOptions);
        var navigateNext = createElement('div', { className: 'e-de-rp-enforce-nav' });
        // tslint:disable-next-line:max-line-length
        var navigateNextButton = createElement('button', { innerHTML: localObj.getConstant('Find Next Region I Can Edit'), className: 'e-btn e-de-rp-nav-btn' });
        navigateNext.appendChild(navigateNextButton);
        navigateNextButton.addEventListener('click', this.navigateNextRegion);
        this.stopReadOnlyOptions.appendChild(navigateNext);
        var showAllRegion = createElement('div', { className: 'e-de-rp-enforce-nav' });
        // tslint:disable-next-line:max-line-length
        var showAllRegionButton = createElement('button', { innerHTML: localObj.getConstant('Show All Regions I Can Edit'), className: 'e-btn e-de-rp-nav-btn' });
        showAllRegion.appendChild(showAllRegionButton);
        showAllRegionButton.addEventListener('click', this.showAllRegion);
        this.stopReadOnlyOptions.appendChild(showAllRegion);
        var highlightRegion = createElement('div', { className: 'e-de-rp-enforce-nav e-de-rp-nav-lbl' });
        // tslint:disable-next-line:max-line-length
        var highlightRegionInput = createElement('input', { attrs: { type: 'checkbox' }, className: 'e-btn e-de-rp-nav-btn' });
        highlightRegion.appendChild(highlightRegionInput);
        this.stopReadOnlyOptions.appendChild(highlightRegion);
        this.highlightCheckBox = new CheckBox({ label: localObj.getConstant('Highlight the regions I can edit') }, highlightRegionInput);
        var lastButtonDiv = createElement('div', { className: 'e-de-rp-enforce' });
        this.stopProtection = createElement('button', {
            innerHTML: localObj.getConstant('Stop Protection'),
            className: 'e-btn e-de-rp-btn-stop-enforce'
        });
        lastButtonDiv.appendChild(this.stopProtection);
        this.stopProtectionDiv.appendChild(lastButtonDiv);
        this.restrictPane.appendChild(this.stopProtectionDiv);
    };
    RestrictEditing.prototype.showStopProtectionPane = function (show) {
        if (show) {
            this.stopProtectionDiv.style.display = 'block';
            this.restrictPaneWholeDiv.style.display = 'none';
        }
        else {
            this.stopProtectionDiv.style.display = 'none';
            this.restrictPaneWholeDiv.style.display = 'block';
        }
        if (this.viewer.protectionType === 'ReadOnly') {
            this.stopReadOnlyOptions.style.display = 'block';
        }
        else {
            this.stopReadOnlyOptions.style.display = 'none';
        }
    };
    RestrictEditing.prototype.wireEvents = function () {
        this.addUser.addEventListener('click', this.addUserDialog.show);
        this.enforceProtection.addEventListener('click', this.protectDocument);
        this.stopProtection.addEventListener('click', this.unProtectDialog.show);
        this.closeButton.addEventListener('click', this.closePane);
        this.allowFormat.addEventListener('change', this.enableFormatting);
        this.readonly.addEventListener('change', this.readOnlyChanges);
        this.highlightCheckBox.addEventListener('change', this.highlightClicked);
    };
    RestrictEditing.prototype.createCheckBox = function (label, element) {
        var checkBox = new CheckBox({ label: label });
        checkBox.appendTo(element);
        return checkBox;
    };
    RestrictEditing.prototype.loadPaneValue = function () {
        this.protectionType = this.viewer.protectionType;
        this.allowFormat.checked = !this.viewer.restrictFormatting;
        this.readonly.checked = this.viewer.protectionType === 'ReadOnly';
        this.highlightCheckBox.checked = true;
        this.addedUser.enablePersistence = true;
        this.addedUser.dataSource = this.viewer.userCollection;
        this.addedUser.refresh();
        this.showStopProtectionPane(this.viewer.isDocumentProtected);
    };
    RestrictEditing.prototype.addUserCollection = function () {
        if (this.viewer.selection && this.viewer.selection.editRangeCollection.length > 0) {
            for (var i = 0; i < this.viewer.selection.editRangeCollection.length; i++) {
                var editStart = this.viewer.selection.editRangeCollection[i];
                if (editStart.user !== '' && this.usersCollection.indexOf(editStart.user) === -1) {
                    this.usersCollection.push(editStart.user);
                }
                if (editStart.group !== '' && this.usersCollection.indexOf(editStart.group) === -1) {
                    this.usersCollection.push(editStart.group);
                }
            }
        }
        this.addedUser.dataSource = this.usersCollection;
        this.addedUser.refresh();
    };
    RestrictEditing.prototype.updateUserInformation = function () {
        this.addedUser.uncheckAllItems();
        if (this.viewer.selection.checkSelectionIsAtEditRegion) {
            var editRange = this.viewer.selection.getEditRangeStartElement();
            if (editRange) {
                var index = this.addedUser.dataSource.indexOf(editRange.user);
                if (index > -1) {
                    var listElement = this.addedUser.element.querySelectorAll('li')[index];
                    listElement.querySelector('.e-icons').classList.add('e-check');
                }
                index = this.addedUser.dataSource.indexOf(editRange.group);
                if (index > -1) {
                    var listElement = this.addedUser.element.querySelectorAll('li')[index];
                    listElement.querySelector('.e-icons').classList.add('e-check');
                }
            }
        }
    };
    return RestrictEditing;
}());

var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @private
 */
var LayoutViewer = /** @__PURE__ @class */ (function () {
    //#endregion
    function LayoutViewer(owner) {
        var _this = this;
        /**
         * @private
         */
        this.textWrap = true;
        /**
         * @private
         */
        this.currentPage = undefined;
        this.selectionStartPageIn = undefined;
        this.selectionEndPageIn = undefined;
        /**
         * @private
         */
        this.fieldStacks = [];
        /**
         * @private
         */
        this.splittedCellWidgets = [];
        /**
         * @private
         */
        this.tableLefts = [];
        this.tapCount = 0;
        this.timer = -1;
        this.isTimerStarted = false;
        /**
         * @private
         */
        this.isFirstLineFitInShiftWidgets = false;
        /**
         * @private
         */
        this.preZoomFactor = 0;
        /**
         * @private
         */
        this.preDifference = -1;
        /**
         * @private
         */
        this.fieldEndParagraph = undefined;
        /**
         * @private
         */
        this.fieldToLayout = undefined;
        /**
         * @private
         */
        this.backgroundColor = '#FFFFFF';
        /**
         * @private
         */
        this.containerTop = 0;
        /**
         * @private
         */
        this.containerLeft = 0;
        // Event 
        /**
         * @private
         */
        this.isMouseDown = false;
        this.isMouseEntered = false;
        // tslint:disable-next-line
        this.scrollMoveTimer = 0;
        /**
         * @private
         */
        this.isSelectionChangedOnMouseMoved = false;
        /**
         * @private
         */
        this.isControlPressed = false;
        /**
         * @private
         */
        this.isTouchInput = false;
        /**
         * @private
         */
        this.useTouchSelectionMark = false;
        /**
         * @private
         */
        this.touchDownOnSelectionMark = 0;
        /**
         * @private
         */
        this.isComposingIME = false;
        /**
         * @private
         */
        this.lastComposedText = '';
        /**
         * @private
         */
        this.isCompositionStart = false;
        /**
         * @private
         */
        this.isCompositionUpdated = false;
        /**
         * @private
         */
        this.isCompositionCanceled = false;
        /**
         * @private
         */
        this.isCompositionEnd = false;
        /**
         * @private
         */
        this.prefix = '';
        /**
         * @private
         */
        this.suffix = '';
        /**
         * @private
         */
        this.fields = [];
        /**
         * @private
         */
        this.heightInfoCollection = {};
        /**
         * @private
         */
        this.defaultTabWidth = 36;
        /**
         * @private
         */
        this.lists = [];
        /**
         * @private
         */
        this.comments = [];
        /**
         * @private
         */
        this.commentUserOptionId = 1;
        /**
         * @private
         */
        this.abstractLists = [];
        /**
         * @private
         */
        this.styles = new WStyles();
        /**
         * @private
         */
        this.preDefinedStyles = undefined;
        /**
         * @private
         */
        this.isRowOrCellResizing = false;
        this.isMouseDownInFooterRegion = false;
        this.pageFitTypeIn = 'None';
        /**
         * @private
         */
        this.fieldCollection = [];
        /**
         * @private
         */
        this.isPageField = false;
        /**
         * @private
         */
        this.mouseDownOffset = new Point(0, 0);
        this.zoomFactorInternal = 1;
        /**
         * If movecaretposition is 1, Home key is pressed
         * If moveCaretPosition is 2, End key is pressed
         * @private
         */
        this.moveCaretPosition = 0;
        /**
         * @private
         */
        this.isTextInput = false;
        /**
         * @private
         */
        this.isScrollHandler = false;
        /**
         * @private
         */
        this.triggerElementsOnLoading = false;
        /**
         * @private
         */
        this.triggerSpellCheck = false;
        //Document Protection Properties Starts
        /**
         * preserve the format
         * @private
         */
        this.restrictFormatting = false;
        /**
         * preserve the document protection type either readonly or no protection
         * @private
         */
        this.protectionType = 'NoProtection';
        /**
         * Preserve the password protection is enforced or not
         * @private
         */
        this.isDocumentProtected = false;
        /**
         * preserve the hash value of password
         * @private
         */
        this.hashValue = '';
        /**
         * @private
         */
        this.saltValue = '';
        /**
         * @private
         */
        this.userCollection = [];
        /**
         * @private
         */
        this.cachedPages = [];
        /**
         * @private
         */
        this.skipScrollToPosition = false;
        /**
         * @private
         */
        this.isIosDevice = false;
        this.onIframeLoad = function () {
            if (!isNullOrUndefined(_this.iframe) && _this.iframe.contentDocument.body.children.length === 0) {
                _this.initIframeContent();
                _this.wireInputEvents();
            }
        };
        /**
         * @private
         */
        this.onTextInput = function (event) {
            if (!_this.isComposingIME) {
                event.preventDefault();
                var text = event.data;
                _this.owner.editor.handleTextInput(text);
            }
        };
        //#region Composition Event
        /**
         * Fires when composition starts.
         * @private
         */
        this.compositionStart = function (event) {
            if (!Browser.isDevice && !_this.owner.isReadOnlyMode) {
                _this.isComposingIME = true;
                _this.positionEditableTarget();
                if (_this.owner.editorHistory) {
                    _this.owner.editor.initComplexHistory('IMEInput');
                }
            }
            _this.isCompositionStart = true;
        };
        /**
         * Fires on every input during composition.
         * @private
         */
        this.compositionUpdated = function (event) {
            if (_this.isComposingIME && !_this.owner.isReadOnlyMode) {
                /* tslint:disable:align */
                setTimeout(function () {
                    _this.owner.editor.insertIMEText(_this.getEditableDivTextContent(), true);
                }, 0);
            }
            _this.isCompositionUpdated = true;
        };
        /**
         * Fires when user selects a character/word and finalizes the input.
         * @private
         */
        this.compositionEnd = function (event) {
            if (_this.isComposingIME && !_this.owner.isReadOnlyMode) {
                var text = _this.getEditableDivTextContent();
                if (text !== '') {
                    _this.owner.editor.insertIMEText(text, false);
                }
                _this.isComposingIME = false;
                _this.lastComposedText = '';
                // tslint:disable-next-line:max-line-length
                _this.iframe.setAttribute('style', 'pointer-events:none;position:absolute;left:' + _this.containerLeft + 'px;top:' + _this.containerTop + 'px;outline:none;background-color:transparent;width:0px;height:0px;overflow:hidden');
                _this.editableDiv.innerHTML = '';
                if (_this.owner.editorHistory) {
                    _this.owner.editorHistory.updateComplexHistory();
                    if (text === '') {
                        // tslint:disable-next-line:max-line-length
                        //When the composition in live. The Undo operation will terminate the composition and empty text will be return from text box.
                        //At that time the the history should be updated. Undo the operation and clear the redo stack. This undo operation will not be saved for redo operation.
                        _this.owner.editorHistory.undo();
                        _this.owner.editorHistory.redoStack.pop();
                    }
                }
            }
            event.preventDefault();
            _this.isCompositionUpdated = false;
            _this.isCompositionEnd = true;
        };
        // tslint:disable:no-any 
        this.onImageResizer = function (args) {
            if (!isNullOrUndefined(_this.owner.imageResizerModule) && _this.owner.imageResizerModule.isImageResizerVisible
                && _this.owner.imageResizerModule.isImageResizing) {
                if (args instanceof MouseEvent) {
                    _this.onMouseUpInternal(args);
                }
                else if (args instanceof TouchEvent) {
                    _this.onTouchUpInternal(args);
                }
            }
            if (_this.scrollMoveTimer) {
                _this.isMouseEntered = true;
                clearInterval(_this.scrollMoveTimer);
            }
        };
        // tslint:enable:no-any 
        this.onKeyPressInternal = function (event) {
            var key = event.which || event.keyCode;
            _this.triggerElementsOnLoading = false;
            var ctrl = (event.ctrlKey || event.metaKey) ? true : ((key === 17) ? true : false); // ctrl detection
            if (ctrl && event.key === 'v' || ctrl && event.key === 'a') {
                return;
            }
            if (!_this.owner.isReadOnlyMode) {
                var key_1 = event.keyCode || event.charCode;
                var char = '';
                if (key_1) {
                    char = String.fromCharCode(key_1);
                }
                else if (event.key) {
                    char = event.key;
                }
                // tslint:disable-next-line:max-line-length
                if (char !== ' ' && char !== '\r' && char !== '\b' && char !== '\u001B' && !_this.owner.isReadOnlyMode && event.ctrlKey === false) {
                    _this.owner.editorModule.handleTextInput(char);
                }
                else if (char === ' ') {
                    _this.triggerSpellCheck = true;
                    _this.owner.editorModule.handleTextInput(' ');
                    _this.triggerSpellCheck = false;
                }
                event.preventDefault();
            }
        };
        this.onTextInputInternal = function (event) {
            if (!_this.owner.isReadOnlyMode) {
                _this.owner.editorModule.onTextInputInternal(event);
            }
            else {
                _this.editableDiv.innerText = '';
            }
        };
        /**
         * Fired on paste.
         * @param {ClipboardEvent} event
         * @private
         */
        this.onPaste = function (event) {
            if (!_this.owner.isReadOnlyMode) {
                _this.owner.editorModule.pasteInternal(event);
            }
            _this.editableDiv.innerText = '';
            event.preventDefault();
        };
        /**
         * Fires when editable div loses focus.
         * @private
         */
        this.onFocusOut = function () {
            if (!isNullOrUndefined(_this.selection)) {
                if (_this.owner.contextMenuModule && _this.owner.contextMenuModule.contextMenuInstance &&
                    _this.owner.contextMenuModule.contextMenuInstance.element.style.display === 'block') {
                    return;
                }
                _this.selection.hideCaret();
            }
        };
        /**
         * Updates focus to editor area.
         * @private
         */
        this.updateFocus = function () {
            if (_this.selection) {
                _this.editableDiv.focus();
                _this.selection.showCaret();
            }
        };
        /**
         * Fires on scrolling.
         */
        this.scrollHandler = function () {
            if (_this.scrollTimer) {
                clearTimeout(_this.scrollTimer);
            }
            _this.clearContent();
            _this.isScrollHandler = true;
            if (!Browser.isDevice && !_this.isComposingIME) {
                _this.iframe.style.top = _this.containerTop + 'px';
                _this.iframe.style.left = _this.containerLeft + 'px';
            }
            _this.updateScrollBars();
            var vtHeight = _this.containerTop + _this.visibleBounds.height;
            if (vtHeight > _this.pageContainer.offsetHeight) {
                _this.viewerContainer.scrollTop = _this.containerTop - (vtHeight - _this.pageContainer.offsetHeight);
            }
            var viewer = _this;
            if (viewer instanceof PageLayoutViewer && !isNullOrUndefined(_this.owner)) {
                _this.owner.fireViewChange();
            }
            _this.isScrollHandler = false;
            _this.scrollTimer = setTimeout(function () {
                if (!_this.isScrollHandler && !isNullOrUndefined(_this.owner) && _this.owner.enableSpellCheck) {
                    _this.isScrollToSpellCheck = true;
                    _this.updateScrollBars();
                }
            }, 200);
        };
        /**
         * Fires when the window gets resized.
         * @private
         */
        this.onWindowResize = function () {
            var viewer = _this;
            var resizeTimer;
            /* tslint:disable:align */
            resizeTimer = setTimeout(function () {
                if (!isNullOrUndefined(viewer.owner) && !isNullOrUndefined(viewer.owner.element)) {
                    viewer.updateViewerSizeInternal(viewer.owner.element);
                    viewer.updateScrollBars();
                    if (!isNullOrUndefined(_this.selection)) {
                        _this.selection.updateCaretPosition();
                    }
                    viewer.updateTouchMarkPosition();
                    if (viewer.owner.contextMenuModule && viewer.owner.contextMenuModule.contextMenuInstance) {
                        viewer.owner.contextMenuModule.contextMenuInstance.close();
                    }
                    if (resizeTimer) {
                        clearTimeout(resizeTimer);
                    }
                }
            }, 200);
        };
        /**
         * @private
         */
        this.onContextMenu = function (event) {
            if (_this.owner.contextMenuModule) {
                if (_this.isMouseDown) {
                    _this.isMouseDown = false;
                }
                _this.owner.contextMenuModule.onContextMenuInternal(event);
            }
        };
        /**
         * Called on mouse down.
         * @param {MouseEvent} event
         * @private
         */
        this.onMouseDownInternal = function (event) {
            if ((event.target && event.target.classList.contains('e-de-cmt-mark-icon')) || _this.isTouchInput ||
                event.offsetX > (_this.visibleBounds.width - (_this.visibleBounds.width - _this.viewerContainer.clientWidth))
                || event.offsetY > (_this.visibleBounds.height - (_this.visibleBounds.height - _this.viewerContainer.clientHeight))) {
                return;
            }
            if (!isNullOrUndefined(_this.selection)) {
                _this.updateCursor(event);
                // tslint:disable-next-line:max-line-length
                if (_this.isLeftButtonPressed(event) && !_this.owner.isReadOnlyMode && _this.owner.enableImageResizerMode && !isNullOrUndefined(_this.owner.imageResizerModule.selectedResizeElement)) {
                    _this.owner.imageResizerModule.isImageResizing = true;
                }
                event.preventDefault();
                if (!_this.isTouchInput) {
                    _this.selection.hideCaret();
                }
                var cursorPoint = new Point(event.offsetX, event.offsetY);
                var touchPoint = _this.findFocusedPage(cursorPoint, true);
                _this.mouseDownOffset.x = touchPoint.x;
                _this.mouseDownOffset.y = touchPoint.y;
                // tslint:disable-next-line:max-line-length
                _this.isMouseDownInFooterRegion = _this.selection.isCursorInsidePageRect(cursorPoint, _this.currentPage) && _this.selection.isCursorInFooterRegion(cursorPoint, _this.currentPage);
                _this.isSelectionChangedOnMouseMoved = false;
                if (!_this.owner.isReadOnlyMode && (_this.owner.editorModule.tableResize.isInCellResizerArea(touchPoint) ||
                    _this.owner.editorModule.tableResize.isInRowResizerArea(touchPoint))) {
                    _this.selection.hideCaret();
                    _this.isMouseDown = true;
                    _this.isSelectionChangedOnMouseMoved = false;
                    if (_this.isLeftButtonPressed(event)) {
                        _this.owner.editorModule.tableResize.startingPoint.x = touchPoint.x;
                        _this.owner.editorModule.tableResize.startingPoint.y = touchPoint.y;
                        _this.owner.editorModule.tableResize.handleResize(touchPoint);
                    }
                    return;
                }
                if (event.ctrlKey) {
                    _this.isControlPressed = true;
                }
                if (_this.owner.selection.isEmpty) {
                    _this.useTouchSelectionMark = false;
                }
                if (event.which === 3 && !_this.owner.selection.isEmpty
                    && _this.selection.checkCursorIsInSelection(_this.getLineWidget(touchPoint), touchPoint)) {
                    event.preventDefault();
                    return;
                }
                _this.isTouchInput = false;
                _this.isMouseDown = true;
                _this.updateFocus();
                /* tslint:disable:align */
                _this.timer = setTimeout(function () {
                    _this.tapCount++;
                    if (_this.tapCount === 4) {
                        _this.tapCount = 1;
                    }
                }, 200);
            }
        };
        /**
         * Called on mouse move.
         * @param {MouseEvent} event
         * @private
         */
        this.onMouseMoveInternal = function (event) {
            event.preventDefault();
            if (!isNullOrUndefined(_this.selection)) {
                //For image Resizing
                if (!_this.owner.isReadOnlyMode && _this.owner.enableImageResizerMode
                    && _this.owner.imageResizerModule.isImageResizing) {
                    if (!_this.owner.imageResizerModule.isImageMoveToNextPage) {
                        _this.owner.imageResizerModule.handleImageResizingOnMouse(event);
                    }
                    return;
                }
                var cursorPoint = new Point(event.offsetX, event.offsetY);
                var touchPoint = _this.findFocusedPage(cursorPoint, !_this.owner.enableHeaderAndFooter);
                if (_this.isMouseDown) {
                    if (!isNullOrUndefined(_this.currentPage)) {
                        var xPosition = touchPoint.x;
                        var yPosition = touchPoint.y;
                        if (!_this.owner.isReadOnlyMode && _this.isRowOrCellResizing) {
                            _this.owner.editorModule.tableResize.handleResizing(touchPoint);
                        }
                        else {
                            if (!(_this.isTouchInput || _this.isSelectionChangedOnMouseMoved || _this.touchDownOnSelectionMark > 0)) {
                                _this.updateTextPositionForSelection(touchPoint, 1);
                            }
                            if (_this.isLeftButtonPressed(event)) {
                                event.preventDefault();
                                var touchY = yPosition;
                                var textPosition = _this.owner.selection.end;
                                var touchPoint_1 = new Point(xPosition, touchY);
                                if (!_this.owner.enableImageResizerMode || !_this.owner.imageResizerModule.isImageResizerVisible) {
                                    _this.owner.selection.moveTextPosition(touchPoint_1, textPosition);
                                }
                                _this.isSelectionChangedOnMouseMoved = true;
                            }
                        }
                    }
                    _this.selection.checkForCursorVisibility();
                }
                if (!_this.isRowOrCellResizing && !_this.isSelectionChangedOnMouseMoved) {
                    _this.updateCursor(event);
                }
                if (_this.isRowOrCellResizing) {
                    _this.selection.hideCaret();
                }
            }
        };
        /**
         * @private
         */
        this.onMouseLeaveInternal = function (event) {
            event.preventDefault();
            if (_this.isMouseDown) {
                var viewerTop = _this.viewerContainer.scrollTop;
                if (event.offsetY + viewerTop > viewerTop) {
                    _this.scrollMoveTimer = setInterval(function () { _this.scrollForwardOnSelection(); }, 500);
                }
                else {
                    _this.scrollMoveTimer = setInterval(function () { _this.scrollBackwardOnSelection(); }, 500);
                }
                if (_this.isMouseEntered) {
                    _this.isMouseEntered = false;
                }
            }
        };
        /**
         * @private
         */
        this.onMouseEnterInternal = function () {
            if (!_this.isMouseEntered) {
                _this.updateScrollBars();
            }
            _this.isMouseEntered = true;
            if (_this.scrollMoveTimer) {
                clearInterval(_this.scrollMoveTimer);
            }
        };
        /**
         * Fired on double tap.
         * @param {MouseEvent} event
         * @private
         */
        this.onDoubleTap = function (event) {
            if (!isNullOrUndefined(_this.selection)) {
                _this.isTouchInput = false;
                var cursorPoint = new Point(event.offsetX, event.offsetY);
                if (_this.selection.checkAndEnableHeaderFooter(cursorPoint, _this.findFocusedPage(cursorPoint, true))) {
                    return;
                }
                // tslint:disable-next-line:max-line-length
                if (_this.selection.isEmpty && !isNullOrUndefined(_this.currentPage) && !isNullOrUndefined(_this.owner.selection.start)) {
                    _this.owner.selection.selectCurrentWord();
                    _this.selection.checkForCursorVisibility();
                    _this.tapCount = 2;
                }
            }
        };
        /**
         * Called on mouse up.
         * @param {MouseEvent} event
         * @private
         */
        this.onMouseUpInternal = function (event) {
            event.preventDefault();
            _this.isListTextSelected = false;
            var cursorPoint = new Point(event.offsetX, event.offsetY);
            var touchPoint = _this.findFocusedPage(cursorPoint, true);
            if (!isNullOrUndefined(_this.selection)) {
                var tapCount = 1;
                if (!Browser.isIE) {
                    if (event.detail > 2) {
                        tapCount = event.detail;
                    }
                }
                else {
                    tapCount = _this.tapCount;
                }
                if (_this.isRowOrCellResizing) {
                    _this.owner.editorModule.tableResize.updateResizingHistory(touchPoint);
                }
                if (_this.isMouseDown && !_this.isSelectionChangedOnMouseMoved
                    && !isNullOrUndefined(_this.currentPage) && !isNullOrUndefined(_this.owner.selection.start)
                    && (!_this.owner.enableImageResizerMode || !_this.owner.imageResizerModule.isImageResizing)) {
                    if (_this.touchDownOnSelectionMark === 0 && !_this.isRowOrCellResizing) {
                        _this.updateTextPositionForSelection(touchPoint, tapCount);
                        if (Browser.isIE && tapCount === 2) {
                            _this.selection.checkAndEnableHeaderFooter(cursorPoint, touchPoint);
                        }
                    }
                    _this.selection.checkForCursorVisibility();
                    if (!isNullOrUndefined(_this.currentSelectedComment) && _this.owner.commentReviewPane
                        && !_this.owner.commentReviewPane.commentPane.isEditMode) {
                        _this.currentSelectedComment = undefined;
                    }
                }
                if (!isNullOrUndefined(_this.currentPage) && !isNullOrUndefined(_this.owner.selection.start)
                    && (_this.owner.selection.isEmpty || _this.owner.selection.isImageSelected) &&
                    (((event.ctrlKey && _this.owner.useCtrlClickToFollowHyperlink ||
                        !_this.owner.useCtrlClickToFollowHyperlink) && _this.isLeftButtonPressed(event) === true))) {
                    _this.selection.navigateHyperLinkOnEvent(touchPoint, false);
                }
                if (!_this.owner.isReadOnlyMode && _this.isSelectionInListText(touchPoint)) {
                    _this.selection.selectListText();
                }
                // tslint:disable-next-line:max-line-length
                if (!_this.owner.isReadOnlyMode && _this.owner.enableImageResizerMode && _this.owner.imageResizerModule.isImageResizing) {
                    _this.owner.imageResizerModule.mouseUpInternal();
                    _this.scrollToPosition(_this.owner.selection.start, _this.owner.selection.end);
                    _this.owner.imageResizerModule.isImageResizing = false;
                    _this.owner.imageResizerModule.updateHistoryForImageResizer();
                }
                // tslint:disable-next-line:max-line-length
                if (_this.owner.enableImageResizerMode && _this.owner.imageResizerModule.isImageResizerVisible && !isNullOrUndefined(_this.selection.caret)) {
                    _this.selection.caret.style.display = 'none';
                }
                _this.isMouseDown = false;
                _this.isSelectionChangedOnMouseMoved = false;
                _this.isTouchInput = false;
                _this.useTouchSelectionMark = true;
                _this.isControlPressed = false;
                _this.updateFocus();
                if (_this.isListTextSelected) {
                    _this.selection.hideCaret();
                }
                if (_this.owner.enableImageResizerMode) {
                    var imageResizer = _this.owner.imageResizerModule;
                    imageResizer.isImageResizing = false;
                    imageResizer.isImageMoveToNextPage = false;
                    imageResizer.leftValue = undefined;
                    imageResizer.topValue = undefined;
                }
                _this.isMouseDownInFooterRegion = false;
            }
        };
        /**
         * Fired on touch start.
         * @param {TouchEvent} event
         * @private
         */
        this.onTouchStartInternal = function (event) {
            if (_this.selection) {
                _this.isCompositionStart = false;
                _this.isCompositionEnd = false;
                _this.isCompositionUpdated = false;
                _this.isCompositionCanceled = true;
                _this.isTouchInput = true;
                if (_this.isTimerStarted) {
                    if (_this.tapCount === 1) {
                        _this.tapCount = 2;
                    }
                    else {
                        _this.tapCount = 3;
                        _this.isTimerStarted = false;
                    }
                }
                else {
                    _this.isTimerStarted = true;
                    _this.tapCount = 1;
                }
                if (event.touches.length === 1) {
                    _this.zoomX = event.touches[0].clientX;
                    _this.zoomY = event.touches[0].clientY;
                    if (_this.owner.selection.isEmpty) {
                        _this.useTouchSelectionMark = false;
                    }
                    _this.isMouseDown = true;
                    _this.isSelectionChangedOnMouseMoved = false;
                    var point = void 0;
                    if (_this.isMouseDown) {
                        point = _this.getTouchOffsetValue(event);
                    }
                    point = _this.findFocusedPage(point, true);
                    if (_this.owner.enableImageResizerMode) {
                        var resizeObj = _this.owner.imageResizerModule.getImagePointOnTouch(point);
                        _this.owner.imageResizerModule.selectedResizeElement = resizeObj.selectedElement;
                    }
                    // tslint:disable-next-line:max-line-length
                    if (_this.owner.enableImageResizerMode && !isNullOrUndefined(_this.owner.imageResizerModule.selectedResizeElement)) {
                        _this.owner.imageResizerModule.isImageResizing = true;
                    }
                    var x = _this.owner.selection.end.location.x;
                    var y = _this.selection.getCaretBottom(_this.owner.selection.end, _this.owner.selection.isEmpty) + 9;
                    //TouchDownOnSelectionMark will be 2 when touch end is pressed
                    _this.touchDownOnSelectionMark = ((point.y <= y && point.y >= y - 20 || point.y >= y && point.y <= y + 20)
                        && (point.x <= x && point.x >= x - 20 || point.x >= x && point.x <= x + 20)) ? 1 : 0;
                    if (!_this.owner.selection.isEmpty && _this.touchDownOnSelectionMark === 0) {
                        x = _this.owner.selection.start.location.x;
                        y = _this.selection.getCaretBottom(_this.owner.selection.start, false) + 9;
                        //TouchDownOnSelectionMark will be 1 when touch start is pressed
                        _this.touchDownOnSelectionMark = ((point.y <= y && point.y >= y - 20 || point.y >= y && point.y <= y + 20)
                            && (point.x <= x && point.x >= x - 20 || point.x >= x && point.x <= x + 20)) ? 2 : 0;
                    }
                }
                if (!isNullOrUndefined(_this.owner.contextMenuModule) && _this.owner.contextMenuModule.contextMenuInstance) {
                    _this.owner.contextMenuModule.contextMenuInstance.close();
                }
                if (_this.touchDownOnSelectionMark || event.touches.length > 1) {
                    event.preventDefault();
                }
                _this.longTouchTimer = setTimeout(_this.onLongTouch, 500, event);
                _this.timer = setTimeout(function () {
                    _this.isTimerStarted = false;
                }, 200);
            }
        };
        /**
         * Fired on long touch
         * @param {TouchEvent} event
         * @private
         */
        this.onLongTouch = function (event) {
            if (isNullOrUndefined(_this.owner) || isNullOrUndefined(_this.viewerContainer)) {
                return;
            }
            var point = _this.getTouchOffsetValue(event);
            var pointRelToPage = _this.findFocusedPage(point, true);
            var selStart = _this.selection.start;
            var selEnd = _this.selection.end;
            var updateSel = false;
            if (!_this.selection.isForward) {
                selStart = _this.selection.end;
                selEnd = _this.selection.start;
            }
            var selStartPt = selStart.location;
            var selEndPt = selEnd.location;
            if (selStart.currentWidget !== selEnd.currentWidget) {
                updateSel = !(pointRelToPage.x >= selStartPt.x && pointRelToPage.x <= selEndPt.x)
                    && !(pointRelToPage.y >= selStartPt.y && pointRelToPage.y <= selEndPt.y);
            }
            else {
                updateSel = !(pointRelToPage.x >= selStartPt.x && pointRelToPage.x <= selEndPt.x)
                    || !(pointRelToPage.y >= selStartPt.y && pointRelToPage.y <= selEndPt.y);
            }
            if (event.changedTouches.length === 1 && updateSel) {
                _this.updateSelectionOnTouch(point, pointRelToPage);
                _this.isMouseDown = false;
                _this.touchDownOnSelectionMark = 0;
                _this.useTouchSelectionMark = true;
                _this.isSelectionChangedOnMouseMoved = false;
            }
            if (_this.selection.isEmpty) {
                _this.selection.selectCurrentWord();
            }
            if (!isNullOrUndefined(_this.owner.contextMenuModule) && _this.owner.contextMenuModule.contextMenuInstance) {
                _this.owner.contextMenuModule.onContextMenuInternal(event);
            }
        };
        /**
         * Fired on touch move.
         * @param {TouchEvent} event
         * @private
         */
        this.onTouchMoveInternal = function (event) {
            var touch = event.touches;
            var cursorPoint;
            if (!isNullOrUndefined(_this.selection)) {
                // tslint:disable-next-line:max-line-length
                if (_this.owner.editorModule && _this.owner.enableImageResizerMode && _this.owner.imageResizerModule.isImageResizing) {
                    event.preventDefault();
                    if (!_this.owner.imageResizerModule.isImageMoveToNextPage) {
                        _this.owner.imageResizerModule.handleImageResizingOnTouch(event);
                        _this.selection.caret.style.display = 'none';
                    }
                    return;
                }
                if (_this.isMouseDown) {
                    cursorPoint = _this.getTouchOffsetValue(event);
                    var touchPoint = _this.findFocusedPage(cursorPoint, true);
                    if (_this.touchDownOnSelectionMark > 0 /*|| !this.useTouchSelectionMark*/) {
                        event.preventDefault();
                        var touchY = touchPoint.y;
                        var textPosition = _this.owner.selection.end;
                        if (touchPoint.y <= 26) {
                            touchY -= touchPoint.y < 0 ? 0 : touchPoint.y + 0.5;
                        }
                        else {
                            touchY -= 36.5;
                        }
                        textPosition = _this.touchDownOnSelectionMark === 2 ? _this.selection.start : _this.selection.end;
                        touchPoint = new Point(touchPoint.x, touchY);
                        _this.owner.selection.moveTextPosition(touchPoint, textPosition);
                        _this.isSelectionChangedOnMouseMoved = true;
                    }
                    _this.selection.checkForCursorVisibility();
                }
            }
            if (touch.length > 1) {
                event.preventDefault();
                _this.isMouseDown = false;
                _this.zoomX = (touch[0].clientX + touch[1].clientX) / 2;
                _this.zoomY = (touch[0].clientY + touch[1].clientY) / 2;
                // tslint:disable-next-line:max-line-length
                var currentDiff = Math.sqrt(Math.pow((touch[0].clientX - touch[1].clientX), 2) + Math.pow((touch[0].clientY - touch[1].clientY), 2));
                if (_this.preDifference > -1) {
                    if (currentDiff > _this.preDifference) {
                        _this.onPinchOutInternal(event);
                    }
                    else if (currentDiff < _this.preDifference) {
                        _this.onPinchInInternal(event);
                    }
                }
                else if (_this.zoomFactor < 2) {
                    if (_this.preDifference !== -1) {
                        if (currentDiff > _this.preDifference) {
                            _this.onPinchInInternal(event);
                        }
                    }
                }
                else if (_this.preDifference === -1) {
                    if (_this.zoomFactor > 2) {
                        if (currentDiff > _this.preDifference) {
                            _this.onPinchInInternal(event);
                        }
                    }
                }
                _this.preDifference = currentDiff;
            }
            if (_this.longTouchTimer) {
                clearTimeout(_this.longTouchTimer);
                _this.longTouchTimer = undefined;
            }
        };
        /**
         * Fired on touch up.
         * @param {TouchEvent} event
         * @private
         */
        this.onTouchUpInternal = function (event) {
            if (!isNullOrUndefined(_this.selection)) {
                var point = _this.getTouchOffsetValue(event);
                var touchPoint = _this.findFocusedPage(point, true);
                if (event.changedTouches.length === 1) {
                    _this.updateSelectionOnTouch(point, touchPoint);
                    if (!isNullOrUndefined(_this.currentPage) && !isNullOrUndefined(_this.selection.start)
                        && !_this.isSelectionChangedOnMouseMoved && (_this.selection.isEmpty ||
                        _this.selection.isImageField() && (!_this.owner.enableImageResizerMode ||
                            _this.owner.enableImageResizerMode && !_this.owner.imageResizerModule.isImageResizing))) {
                        _this.selection.navigateHyperLinkOnEvent(touchPoint, true);
                    }
                    _this.isMouseDown = false;
                    _this.touchDownOnSelectionMark = 0;
                    _this.useTouchSelectionMark = true;
                    _this.isSelectionChangedOnMouseMoved = false;
                }
                if (_this.owner.enableImageResizerMode && _this.owner.imageResizerModule.isImageResizing) {
                    _this.owner.imageResizerModule.mouseUpInternal();
                    _this.owner.imageResizerModule.isImageResizing = false;
                    _this.owner.imageResizerModule.isImageMoveToNextPage = false;
                    _this.scrollToPosition(_this.owner.selection.start, _this.owner.selection.end);
                    _this.owner.imageResizerModule.updateHistoryForImageResizer();
                }
                // tslint:disable-next-line:max-line-length
                if (_this.owner.enableImageResizerMode && _this.owner.imageResizerModule.isImageResizerVisible && _this.isTouchInput) {
                    _this.touchStart.style.display = 'none';
                    _this.touchEnd.style.display = 'none';
                }
                // if (!this.owner.isReadOnlyMode && this.isSelectionInListText(touchPoint)) {
                //     this.selection.selectListText();
                // }
                event.preventDefault();
            }
            _this.preDifference = -1;
            _this.isTouchInput = false;
            if (_this.longTouchTimer) {
                clearTimeout(_this.longTouchTimer);
                _this.longTouchTimer = undefined;
            }
            if (!_this.isTimerStarted) {
                _this.tapCount = 1;
            }
            if (_this.isListTextSelected) {
                _this.selection.hideCaret();
            }
        };
        /**
         * Fired on keyup event.
         * @private
         */
        this.onKeyUpInternal = function (event) {
            if (Browser.isDevice && event.target === _this.editableDiv) {
                if (window.getSelection().anchorOffset !== _this.prefix.length) {
                    _this.selection.setEditableDivCaretPosition(_this.editableDiv.innerText.length);
                }
            }
            if (event.ctrlKey || (event.keyCode === 17 || event.which === 17)) {
                _this.isControlPressed = false;
            }
        };
        /**
         * Fired on keydown.
         * @private
         */
        this.onKeyDownInternal = function (event) {
            var isHandled = false;
            var keyEventArgs = { 'event': event, 'isHandled': false, source: _this.owner };
            _this.owner.trigger('keyDown', keyEventArgs);
            if (keyEventArgs.isHandled) {
                return;
            }
            var key = event.which || event.keyCode;
            var ctrl = (event.ctrlKey || event.metaKey) ? true : ((key === 17) ? true : false); // ctrl detection       
            var shift = event.shiftKey ? event.shiftKey : ((key === 16) ? true : false); // Shift Key detection        
            var alt = event.altKey ? event.altKey : ((key === 18) ? true : false); // alt key detection
            if (ctrl && !shift && !alt) {
                switch (key) {
                    case 80:
                        event.preventDefault();
                        _this.owner.print();
                        isHandled = true;
                        break;
                    case 83:
                        event.preventDefault();
                        _this.owner.save(_this.owner.documentName === '' ? 'sample' : _this.owner.documentName, 'Sfdt');
                        isHandled = true;
                        break;
                }
            }
            if (!isHandled && !isNullOrUndefined(_this.selection)) {
                _this.selection.onKeyDownInternal(event, ctrl, shift, alt);
            }
            if (isHandled) {
                event.preventDefault();
            }
        };
        this.owner = owner;
        this.pages = [];
        this.render = new Renderer(this);
        this.lists = [];
        this.abstractLists = [];
        this.characterFormat = new WCharacterFormat(this);
        this.paragraphFormat = new WParagraphFormat(this);
        this.renderedLists = new Dictionary();
        this.renderedLevelOverrides = [];
        this.headersFooters = [];
        this.styles = new WStyles();
        this.preDefinedStyles = new Dictionary();
        this.initalizeStyles();
        this.bookmarks = new Dictionary();
        this.editRanges = new Dictionary();
        this.isIosDevice = /Mac|iPad|iPod/i.test(navigator.userAgent);
    }
    Object.defineProperty(LayoutViewer.prototype, "containerCanvas", {
        //Document Protection Properties Ends
        //#region Properties
        /**
         * Gets container canvas.
         * @private
         */
        get: function () {
            if (isNullOrUndefined(this.containerCanvasIn)) {
                this.containerCanvasIn = document.createElement('canvas');
                this.containerCanvasIn.getContext('2d').save();
            }
            if (!isNullOrUndefined(this.pageContainer)
                && this.containerCanvasIn.parentElement !== this.pageContainer) {
                this.pageContainer.appendChild(this.containerCanvasIn);
            }
            return this.containerCanvasIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayoutViewer.prototype, "selectionCanvas", {
        /**
         * Gets selection canvas.
         * @private
         */
        get: function () {
            if (isNullOrUndefined(this.selectionCanvasIn)) {
                this.selectionCanvasIn = document.createElement('canvas');
                this.selectionCanvas.getContext('2d').save();
            }
            if (!isNullOrUndefined(this.pageContainer)
                && this.selectionCanvasIn.parentElement !== this.pageContainer) {
                this.pageContainer.appendChild(this.selectionCanvasIn);
            }
            return this.selectionCanvasIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayoutViewer.prototype, "containerContext", {
        /**
         * Gets container context.
         * @private
         */
        get: function () {
            return this.containerCanvas.getContext('2d');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayoutViewer.prototype, "selectionContext", {
        /**
         * Gets selection context.
         * @private
         */
        get: function () {
            return this.selectionCanvas.getContext('2d');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayoutViewer.prototype, "currentRenderingPage", {
        /**
         * Gets the current rendering page.
         */
        get: function () {
            if (this.pages.length === 0) {
                return undefined;
            }
            return this.pages[this.pages.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayoutViewer.prototype, "visibleBounds", {
        /**
         * Gets visible bounds.
         * @private
         */
        get: function () {
            return this.visibleBoundsIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayoutViewer.prototype, "zoomFactor", {
        /**
         * Gets or sets zoom factor.
         * @private
         */
        get: function () {
            return this.zoomFactorInternal;
        },
        set: function (value) {
            if (this.zoomFactorInternal !== value) {
                this.preZoomFactor = this.zoomFactor;
                this.zoomFactorInternal = value;
                this.zoomModule.setZoomFactor(value);
                this.owner.zoomFactor = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayoutViewer.prototype, "selection", {
        /**
         * Gets the selection.
         * @private
         */
        get: function () {
            return this.owner.selection;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayoutViewer.prototype, "selectionStartPage", {
        /**
         * Gets or sets selection start page.
         * @private
         */
        get: function () {
            return this.selectionStartPageIn;
        },
        set: function (value) {
            this.selectionStartPageIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayoutViewer.prototype, "selectionEndPage", {
        /**
         * Gets or sets selection end page.
         * @private
         */
        get: function () {
            return this.selectionEndPageIn;
        },
        set: function (value) {
            this.selectionEndPageIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayoutViewer.prototype, "dialog", {
        /**
         * Gets the initialized default dialog.
         * @private
         */
        get: function () {
            if (!this.dialogInternal) {
                this.initDialog(this.owner.enableRtl);
            }
            return this.dialogInternal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayoutViewer.prototype, "dialog2", {
        /**
         * Gets the initialized default dialog.
         * @private
         */
        get: function () {
            if (!this.dialogInternal2) {
                this.initDialog2(this.owner.enableRtl);
            }
            return this.dialogInternal2;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayoutViewer.prototype, "pageFitType", {
        /**
         * Gets or sets page fit type.
         * @private
         */
        get: function () {
            return this.pageFitTypeIn;
        },
        set: function (value) {
            this.pageFitTypeIn = value;
            this.onPageFitTypeChanged(this.pageFitTypeIn);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayoutViewer.prototype, "currentSelectedComment", {
        /**
         * @private
         */
        get: function () {
            return this.currentSelectedCommentInternal;
        },
        /**
         * @private
         */
        set: function (value) {
            if (this.owner && this.owner.commentReviewPane) {
                this.owner.commentReviewPane.previousSelectedComment = this.currentSelectedCommentInternal;
            }
            this.currentSelectedCommentInternal = value;
        },
        enumerable: true,
        configurable: true
    });
    LayoutViewer.prototype.initalizeStyles = function () {
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Normal', '{"type":"Paragraph","name":"Normal","next":"Normal"}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 1', '{"type":"Paragraph","name":"Heading 1","basedOn":"Normal","next":"Normal","link":"Heading 1 Char","characterFormat":{"fontSize":16.0,"fontFamily":"Calibri Light","fontColor":"#2F5496"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":12.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level1"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 2', '{"type":"Paragraph","name":"Heading 2","basedOn":"Normal","next":"Normal","link":"Heading 2 Char","characterFormat":{"fontSize":13.0,"fontFamily":"Calibri Light","fontColor":"#2F5496"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":2.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level2"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 3', '{"type":"Paragraph","name":"Heading 3","basedOn":"Normal","next":"Normal","link":"Heading 3 Char","characterFormat":{"fontSize":12.0,"fontFamily":"Calibri Light","fontColor":"#1F3763"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":2.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level3"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 4', '{"type":"Paragraph","name":"Heading 4","basedOn":"Normal","next":"Normal","link":"Heading 4 Char","characterFormat":{"italic":true,"fontFamily":"Calibri Light","fontColor":"#2F5496"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":2.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level4"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 5', '{"type":"Paragraph","name":"Heading 5","basedOn":"Normal","next":"Normal","link":"Heading 5 Char","characterFormat":{"fontFamily":"Calibri Light","fontColor":"#2F5496"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":2.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level5"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 6', '{"type":"Paragraph","name":"Heading 6","basedOn":"Normal","next":"Normal","link":"Heading 6 Char","characterFormat":{"fontFamily":"Calibri Light","fontColor":"#1F3763"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":2.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level6"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Default Paragraph Font', '{"type":"Character","name":"Default Paragraph Font"}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 1 Char', '{"type":"Character","name":"Heading 1 Char","basedOn":"Default Paragraph Font","characterFormat":{"fontSize":16.0,"fontFamily":"Calibri Light","fontColor":"#2F5496"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 2 Char', '{"type":"Character","name":"Heading 2 Char","basedOn":"Default Paragraph Font","characterFormat":{"fontSize":13.0,"fontFamily":"Calibri Light","fontColor":"#2F5496"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 3 Char', '{"type":"Character","name":"Heading 3 Char","basedOn":"Default Paragraph Font","characterFormat":{"fontSize":12.0,"fontFamily":"Calibri Light","fontColor": "#1F3763"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 4 Char', '{"type":"Character","name":"Heading 4 Char","basedOn":"Default Paragraph Font","characterFormat":{"italic":true,"fontFamily":"Calibri Light","fontColor":"#2F5496"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 5 Char', '{"type":"Character","name":"Heading 5 Char","basedOn":"Default Paragraph Font","characterFormat":{"fontFamily":"Calibri Light","fontColor":"#2F5496"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 6 Char', '{"type":"Character","name":"Heading 6 Char","basedOn":"Default Paragraph Font","characterFormat":{"fontFamily":"Calibri Light","fontColor":"#1F3763"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Hyperlink', '{"type":"Character","name":"Hyperlink","basedOn":"Default Paragraph Font","next":"Normal","characterFormat":{"fontColor":"#0563C1","underline": "Single"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc1', '{"type":"Paragraph","name":"Toc1","basedOn":"Normal","next":"Normal","paragraphFormat":{"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc2', '{"type":"Paragraph","name":"Toc2","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :11.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc3', '{"type":"Paragraph","name":"Toc3","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :22.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc4', '{"type":"Paragraph","name":"Toc4","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :33.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc5', '{"type":"Paragraph","name":"Toc5","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :44.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc6', '{"type":"Paragraph","name":"Toc6","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :55.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc7', '{"type":"Paragraph","name":"Toc7","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :66.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc8', '{"type":"Paragraph","name":"Toc8","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :77.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc9', '{"type":"Paragraph","name":"Toc9","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :88.0,"afterSpacing":5.0}}');
    };
    /**
     * @private
     */
    LayoutViewer.prototype.clearDocumentItems = function () {
        this.editRanges.clear();
        this.headersFooters = [];
        this.fields = [];
        this.currentSelectedComment = undefined;
        for (var i = 0; i < this.comments.length; i++) {
            var commentStart = this.comments[i].commentStart;
            commentStart.destroy();
        }
        this.comments = [];
        this.bookmarks.clear();
        this.styles.clear();
        this.characterFormat.clearFormat();
        this.paragraphFormat.clearFormat();
        this.setDefaultCharacterValue(this.characterFormat);
        this.setDefaultParagraphValue(this.paragraphFormat);
        if (this.owner.commentReviewPane) {
            this.owner.commentReviewPane.clear();
        }
        this.defaultTabWidth = 36;
        this.isDocumentProtected = false;
        this.protectionType = 'NoProtection';
        this.restrictFormatting = false;
        this.hashValue = '';
        this.saltValue = '';
        this.userCollection = [];
    };
    /**
     * @private
     */
    LayoutViewer.prototype.setDefaultDocumentFormat = function () {
        this.owner.parser.parseCharacterFormat(this.owner.characterFormat, this.characterFormat);
        this.owner.parser.parseParagraphFormat(this.owner.paragraphFormat, this.paragraphFormat);
    };
    LayoutViewer.prototype.setDefaultCharacterValue = function (characterFormat) {
        characterFormat.bold = false;
        characterFormat.italic = false;
        characterFormat.fontFamily = 'Calibri';
        characterFormat.fontSize = 11;
        characterFormat.underline = 'None';
        characterFormat.strikethrough = 'None';
        characterFormat.fontSizeBidi = 11;
        characterFormat.fontFamilyBidi = 'Calibri';
        characterFormat.baselineAlignment = 'Normal';
        characterFormat.highlightColor = 'NoColor';
        characterFormat.fontColor = '#000000';
    };
    LayoutViewer.prototype.setDefaultParagraphValue = function (paragraphFormat) {
        paragraphFormat.leftIndent = 0;
        paragraphFormat.rightIndent = 0;
        paragraphFormat.firstLineIndent = 0;
        paragraphFormat.textAlignment = 'Left';
        paragraphFormat.beforeSpacing = 0;
        paragraphFormat.afterSpacing = 0;
        paragraphFormat.lineSpacing = 1;
        paragraphFormat.lineSpacingType = 'Multiple';
        paragraphFormat.bidi = false;
    };
    /**
     * @private
     */
    LayoutViewer.prototype.getAbstractListById = function (id) {
        if (isNullOrUndefined(this.abstractLists)) {
            return undefined;
        }
        for (var i = 0; i < this.abstractLists.length; i++) {
            var abstractList = this.abstractLists[i];
            if (abstractList instanceof WAbstractList && abstractList.abstractListId === id) {
                return abstractList;
            }
        }
        return undefined;
    };
    /**
     * @private
     */
    LayoutViewer.prototype.getListById = function (id) {
        if (isNullOrUndefined(this.lists)) {
            return undefined;
        }
        for (var i = 0; i < this.lists.length; i++) {
            if (!isNullOrUndefined(this.lists[i]) && this.lists[i].listId === id) {
                return this.lists[i];
            }
        }
        return undefined;
    };
    /**
     * @private
     */
    LayoutViewer.getListLevelNumber = function (listLevel) {
        if (listLevel.ownerBase instanceof WLevelOverride) {
            return listLevel.ownerBase.levelNumber;
        }
        else if (listLevel.ownerBase instanceof WAbstractList && !isNullOrUndefined(listLevel.ownerBase.levels)) {
            return listLevel.ownerBase.levels.indexOf(listLevel);
        }
        else {
            return -1;
        }
    };
    /**
     * Gets the bookmarks.
     * @private
     */
    LayoutViewer.prototype.getBookmarks = function (includeHidden) {
        var bookmarks = [];
        for (var i = 0; i < this.bookmarks.keys.length; i++) {
            var bookmark = this.bookmarks.keys[i];
            if (includeHidden || bookmark.indexOf('_') !== 0) {
                bookmarks.push(bookmark);
            }
        }
        return bookmarks;
    };
    /**
     * @private
     */
    LayoutViewer.prototype.selectComment = function (comment) {
        var _this = this;
        if (this.owner.selection && this.owner.commentReviewPane) {
            this.owner.showComments = true;
            setTimeout(function () {
                if (_this.owner && _this.owner.selection) {
                    _this.owner.selection.selectComment(comment);
                }
            });
        }
    };
    /**
     * @private
     */
    LayoutViewer.prototype.showComments = function (show) {
        if (this.owner && show && this.owner.enableComment) {
            var eventArgs = { type: 'Comment' };
            this.owner.trigger('beforePaneSwitch', eventArgs);
        }
        this.owner.commentReviewPane.showHidePane(show && this.owner.enableComment);
    };
    /**
     * Initializes components.
     * @private
     */
    LayoutViewer.prototype.initializeComponents = function () {
        var element = this.owner.element;
        if (isNullOrUndefined(element)) {
            return;
        }
        this.optionsPaneContainer = createElement('div', {
            className: 'e-documenteditor-optionspane'
        });
        element.appendChild(this.optionsPaneContainer);
        var isRtl = this.owner.enableRtl;
        var viewerContainerStyle;
        if (isRtl) {
            viewerContainerStyle = 'direction:ltr;';
        }
        this.viewerContainer = createElement('div', { id: this.owner.containerId + '_viewerContainer' });
        this.viewerContainer.style.cssText = 'position:relative;backgroundColor:#FBFBFB;overflow:auto;' + viewerContainerStyle;
        this.optionsPaneContainer.appendChild(this.viewerContainer);
        this.viewerContainer.tabIndex = 0;
        this.viewerContainer.style.outline = 'none';
        this.pageContainer = createElement('div', { id: this.owner.containerId + '_pageContainer', className: 'e-de-background' });
        this.viewerContainer.appendChild(this.pageContainer);
        this.pageContainer.style.top = '0px';
        this.pageContainer.style.left = '0px';
        this.pageContainer.style.position = 'relative';
        this.pageContainer.style.pointerEvents = 'none';
        if (Browser.isDevice) {
            this.createEditableDiv(element);
        }
        else {
            this.createEditableIFrame();
        }
        if (this.owner.enableImageResizerMode) {
            this.owner.imageResizerModule.initializeImageResizer();
        }
        this.updateViewerSizeInternal(element);
        this.layout = new Layout(this);
        this.textHelper = new TextHelper(this);
        this.zoomModule = new Zoom(this);
        this.initTouchEllipse();
        this.wireEvent();
        this.restrictEditingPane = new RestrictEditing(this);
        this.owner.commentReviewPane = new CommentReviewPane(this.owner);
        createSpinner({ target: this.owner.element, cssClass: 'e-spin-overlay' });
    };
    /**
     * @private
     */
    LayoutViewer.prototype.createEditableDiv = function (element) {
        this.editableDiv = document.createElement('div');
        this.editableDiv.contentEditable = 'true';
        this.editableDiv.style.position = 'fixed';
        this.editableDiv.style.left = '-150em';
        this.editableDiv.style.width = '100%';
        this.editableDiv.style.height = '100%';
        this.editableDiv.id = element.id + '_editableDiv';
        document.body.appendChild(this.editableDiv);
    };
    /**
     * @private
     */
    LayoutViewer.prototype.createEditableIFrame = function () {
        this.iframe = createElement('iframe', {
            attrs: {
                'scrolling': 'no',
                // tslint:disable-next-line:max-line-length
                'style': 'pointer-events:none;position:absolute;left:0px;top:0px;outline:none;background-color:transparent;width:0px;height:0px;overflow:hidden'
            },
            className: 'e-de-text-target'
        });
        this.viewerContainer.appendChild(this.iframe);
        this.initIframeContent();
    };
    LayoutViewer.prototype.initIframeContent = function () {
        var style = 'background-color:transparent;width:100%;height:100%;padding: 0px; margin: 0px;';
        var innerHtml = '<!DOCTYPE html>'
            + '<html><head></head>'
            + '<body spellcheck="false" style=' + style + ' >'
            + '<div contenteditable="true" style=' + style + '></div>'
            + '</body>'
            + '</html>';
        this.iframe.contentDocument.open();
        this.iframe.contentDocument.write(innerHtml);
        this.iframe.contentDocument.close();
        this.editableDiv = this.iframe.contentDocument.body.children[0];
    };
    /**
     * Wires events and methods.
     */
    LayoutViewer.prototype.wireEvent = function () {
        if (!isNullOrUndefined(this.selection)) {
            this.selection.initCaret();
        }
        this.wireInputEvents();
        if (!isNullOrUndefined(this.iframe)) {
            this.iframe.addEventListener('load', this.onIframeLoad);
        }
        this.viewerContainer.addEventListener('scroll', this.scrollHandler);
        this.viewerContainer.addEventListener('mousedown', this.onMouseDownInternal);
        this.viewerContainer.addEventListener('keydown', this.onKeyDownInternal);
        this.viewerContainer.addEventListener('mousemove', this.onMouseMoveInternal);
        this.viewerContainer.addEventListener('mouseleave', this.onMouseLeaveInternal);
        this.viewerContainer.addEventListener('mouseenter', this.onMouseEnterInternal);
        this.viewerContainer.addEventListener('contextmenu', this.onContextMenu);
        this.viewerContainer.addEventListener('dblclick', this.onDoubleTap);
        this.viewerContainer.addEventListener('mouseup', this.onMouseUpInternal);
        window.addEventListener('resize', this.onWindowResize);
        window.addEventListener('keyup', this.onKeyUpInternal);
        window.addEventListener('mouseup', this.onImageResizer);
        window.addEventListener('touchend', this.onImageResizer);
        this.viewerContainer.addEventListener('touchstart', this.onTouchStartInternal);
        this.viewerContainer.addEventListener('touchmove', this.onTouchMoveInternal);
        this.viewerContainer.addEventListener('touchend', this.onTouchUpInternal);
        if (navigator.userAgent.match('Firefox')) {
            this.viewerContainer.addEventListener('DOMMouseScroll', this.zoomModule.onMouseWheelInternal);
        }
        this.viewerContainer.addEventListener('mousewheel', this.zoomModule.onMouseWheelInternal);
    };
    LayoutViewer.prototype.wireInputEvents = function () {
        if (isNullOrUndefined(this.editableDiv)) {
            return;
        }
        this.editableDiv.addEventListener('paste', this.onPaste);
        if (!Browser.isDevice) {
            this.editableDiv.addEventListener('keypress', this.onKeyPressInternal);
            if (Browser.info.name === 'chrome') {
                this.editableDiv.addEventListener('textInput', this.onTextInput);
            }
        }
        else {
            this.editableDiv.addEventListener('input', this.onTextInputInternal);
        }
        this.editableDiv.addEventListener('blur', this.onFocusOut);
        this.editableDiv.addEventListener('keydown', this.onKeyDownInternal);
        this.editableDiv.addEventListener('compositionstart', this.compositionStart);
        this.editableDiv.addEventListener('compositionupdate', this.compositionUpdated);
        this.editableDiv.addEventListener('compositionend', this.compositionEnd);
    };
    LayoutViewer.prototype.getEditableDivTextContent = function () {
        return this.editableDiv.textContent;
    };
    /**
     * @private
     */
    LayoutViewer.prototype.positionEditableTarget = function () {
        var point = this.selection.getRect(this.selection.start);
        var page = this.selection.getSelectionPage(this.selection.start);
        var caretInfo = this.selection.updateCaretSize(this.owner.selection.start);
        var sectionFormat = page.bodyWidgets[0].sectionFormat;
        var left = page.boundingRectangle.x + (HelperMethods.convertPointToPixel(sectionFormat.leftMargin) * this.zoomFactor);
        var top = point.y;
        var pageWidth = sectionFormat.pageWidth - sectionFormat.leftMargin - sectionFormat.rightMargin;
        var iframeStyle = 'left:' + left + 'px;';
        iframeStyle += 'top:' + top + 'px;';
        iframeStyle += 'width:' + (HelperMethods.convertPointToPixel(pageWidth) * this.zoomFactor) + 'px;';
        iframeStyle += 'height:250px;outline-style:none;position:absolute';
        this.iframe.setAttribute('style', iframeStyle);
        var style = 'background-color:transparent;width:100%;height:250px;padding: 0px; margin: 0px;';
        style += 'text-indent:' + (point.x - left) + 'px;';
        style += 'color:transparent;pointer-events:none;outline-style:none;';
        style += 'font-size:' + (HelperMethods.convertPointToPixel(this.selection.characterFormat.fontSize) * this.zoomFactor) + 'px;';
        style += 'font-family' + this.selection.characterFormat.fontFamily + ';';
        style += 'overflow:hidden;text-decoration:none;white-space:normal;';
        this.editableDiv.setAttribute('style', style);
    };
    /**
     * Initializes dialog template.
     */
    LayoutViewer.prototype.initDialog = function (isRtl) {
        if (!this.dialogInternal) {
            this.dialogTarget1 = createElement('div', { className: 'e-de-dlg-target' });
            document.body.appendChild(this.dialogTarget1);
            if (isRtl) {
                this.dialogTarget1.classList.add('e-de-rtl');
            }
            this.dialogInternal = new Dialog({
                target: document.body, showCloseIcon: true,
                allowDragging: true, enableRtl: isRtl, visible: false,
                width: '1px', isModal: true, position: { X: 'center', Y: 'center' }, zIndex: this.owner.zIndex + 10,
                animationSettings: { effect: 'None' }
            });
            this.dialogInternal.open = this.selection.hideCaret;
            this.dialogInternal.beforeClose = this.updateFocus;
            this.dialogInternal.appendTo(this.dialogTarget1);
        }
    };
    /**
     * Initializes dialog template.
     */
    LayoutViewer.prototype.initDialog2 = function (isRtl) {
        if (!this.dialogInternal2) {
            this.dialogTarget2 = createElement('div', { className: 'e-de-dlg-target' });
            document.body.appendChild(this.dialogTarget2);
            if (isRtl) {
                this.dialogTarget2.classList.add('e-de-rtl');
            }
            this.dialogInternal2 = new Dialog({
                target: document.body, showCloseIcon: true,
                allowDragging: true, enableRtl: isRtl, visible: false,
                width: '1px', isModal: true, position: { X: 'center', Y: 'Top' }, zIndex: this.owner.zIndex
            });
            this.dialogInternal2.appendTo(this.dialogTarget2);
        }
    };
    /**
     * Clears the context.
     * @private
     */
    LayoutViewer.prototype.clearContent = function () {
        this.containerContext.clearRect(0, 0, this.containerCanvas.width, this.containerCanvas.height);
        this.selectionContext.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
        // Hide comment mark
        if (this.pageContainer) {
            var commentMarkElement = this.pageContainer.getElementsByClassName('e-de-cmt-mark');
            for (var i = 0; i < commentMarkElement.length; i++) {
                commentMarkElement[i].style.display = 'none';
            }
        }
    };
    /**
     * Fired when the document gets changed.
     * @param {WordDocument} document
     */
    LayoutViewer.prototype.onDocumentChanged = function (sections) {
        this.clearContent();
        if (this.owner.editorModule) {
            this.owner.editorModule.tocStyles = {};
            this.owner.editorModule.tocBookmarkId = 0;
        }
        this.heightInfoCollection = {};
        this.owner.isDocumentLoaded = false;
        for (var i = 0; i < this.pages.length; i++) {
            this.pages[i].bodyWidgets[0].destroy();
        }
        this.pages = [];
        if (!isNullOrUndefined(this.renderedLists)) {
            this.renderedLists.clear();
        }
        if (!isNullOrUndefined(this.renderedLevelOverrides)) {
            this.renderedLevelOverrides = [];
        }
        if (!isNullOrUndefined(this.owner.editorHistory)) {
            this.owner.editorHistory.destroy();
        }
        this.owner.isDocumentLoaded = true;
        this.layout.isInitialLoad = true;
        this.layout.layoutItems(sections);
        if (this.owner.selection) {
            this.owner.selection.editRangeCollection = [];
            this.owner.selection.selectRange(this.owner.documentStart, this.owner.documentStart);
            if (this.isDocumentProtected) {
                this.restrictEditingPane.showHideRestrictPane(true);
            }
        }
        if (this.owner.optionsPaneModule) {
            this.owner.optionsPaneModule.showHideOptionsPane(false);
        }
        if (this.restrictEditingPane.restrictPane && !this.isDocumentProtected) {
            this.restrictEditingPane.showHideRestrictPane(false);
        }
        this.owner.fireDocumentChange();
    };
    /**
     * Initialize touch ellipse.
     */
    LayoutViewer.prototype.initTouchEllipse = function () {
        var style = 'height: 30px;width: 30px;position: absolute;background-color: transparent;margin: 0px;padding: 0px;z-index:5';
        // tslint:disable-next-line:max-line-length
        var ellipse = ' height: 12px;width: 12px;border-radius: 50%;background-color: white;position: absolute;margin: 0px 6px 0px 6px;border-width: 2px;border-style: solid;border-color: #000000;';
        this.touchStart = createElement('div', { className: 'e-touch-ellipse', styles: style });
        var start = createElement('div', { styles: ellipse });
        this.touchEnd = createElement('div', { className: 'e-touch-ellipse', styles: style });
        this.touchStart.style.display = 'none';
        var end = createElement('div', { styles: ellipse });
        this.touchStart.appendChild(start);
        this.touchEnd.appendChild(end);
        this.touchEnd.style.display = 'none';
        this.viewerContainer.appendChild(this.touchStart);
        this.viewerContainer.appendChild(this.touchEnd);
    };
    /**
     * Updates touch mark position.
     * @private
     */
    LayoutViewer.prototype.updateTouchMarkPosition = function () {
        if (this.touchStart.style.display !== 'none' && !isNullOrUndefined(this.selection)) {
            if (!this.selection.isEmpty) {
                var y = this.selection.getCaretBottom(this.selection.start, false);
                var page = this.selection.getPage(this.selection.start.paragraph);
                var viewer = this;
                // tslint:disable-next-line:max-line-length
                var pageTop = (page.boundingRectangle.y - viewer.pageGap * (this.pages.indexOf(page) + 1)) * this.zoomFactor + viewer.pageGap * (this.pages.indexOf(page) + 1);
                // tslint:disable-next-line:max-line-length
                this.touchStart.style.left = page.boundingRectangle.x + (Math.round(this.selection.start.location.x) * this.zoomFactor - 14) + 'px';
                this.touchStart.style.top = pageTop + ((y) * this.zoomFactor) + 'px';
                if (!this.selection.isEmpty) {
                    y = this.selection.getCaretBottom(this.selection.end, false);
                    page = this.selection.getPage(this.selection.end.paragraph);
                }
                // tslint:disable-next-line:max-line-length
                this.touchEnd.style.left = page.boundingRectangle.x + (Math.round(this.selection.end.location.x) * this.zoomFactor - 14) + 'px';
                this.touchEnd.style.top = pageTop + (y * this.zoomFactor) + 'px';
            }
            else {
                this.selection.updateCaretPosition();
            }
        }
    };
    LayoutViewer.prototype.scrollForwardOnSelection = function () {
        this.viewerContainer.scrollTop = this.viewerContainer.scrollTop + 200;
    };
    LayoutViewer.prototype.scrollBackwardOnSelection = function () {
        this.viewerContainer.scrollTop = this.viewerContainer.scrollTop - 200;
    };
    LayoutViewer.prototype.isSelectionInListText = function (cursorPoint) {
        var widget = this.getLineWidget(cursorPoint);
        if (!isNullOrUndefined(widget) && widget.children[0] instanceof ListTextElementBox) {
            var left = this.getLeftValue(widget);
            var width = widget.children[0].width;
            var height = widget.children[0].height;
            if (this.isInsideRect(left, widget.paragraph.y, width, height, cursorPoint)) {
                this.selectionLineWidget = widget;
                return true;
            }
        }
        return false;
    };
    /**
     * Check whether touch point is inside the rectangle or not.
     * @param x
     * @param y
     * @param width
     * @param height
     * @param touchPoint
     * @private
     */
    LayoutViewer.prototype.isInsideRect = function (x, y, width, height, touchPoint) {
        if ((touchPoint.x > x && touchPoint.x <= x + width) && (touchPoint.y > y && touchPoint.y <= y + height)) {
            return true;
        }
        return false;
    };
    /**
     * @private
     */
    LayoutViewer.prototype.getLeftValue = function (widget) {
        var left = widget.paragraph.x;
        var paragraphFormat = widget.paragraph.paragraphFormat;
        if (this.selection.isParagraphFirstLine(widget)) {
            if (paragraphFormat.textAlignment === 'Right') {
                left -= HelperMethods.convertPointToPixel(paragraphFormat.firstLineIndent);
                left -= HelperMethods.convertPointToPixel(paragraphFormat.leftIndent);
            }
            else {
                left += HelperMethods.convertPointToPixel(paragraphFormat.firstLineIndent);
            }
        }
        var element = widget.children[0];
        if (element instanceof ListTextElementBox) {
            left += element.margin.left;
        }
        return left;
    };
    /**
     * Checks whether left mouse button is pressed or not.
     */
    LayoutViewer.prototype.isLeftButtonPressed = function (event) {
        this.isTouchInput = false;
        var button = event.which || event.button;
        return button === 1;
    };
    /**
     * Updates selection for touch position.
     * @param point
     * @param touchPoint
     */
    LayoutViewer.prototype.updateSelectionOnTouch = function (point, touchPoint) {
        this.zoomX = undefined;
        this.zoomY = undefined;
        // tslint:disable-next-line:max-line-length
        if (this.isMouseDown && !this.isSelectionChangedOnMouseMoved && !isNullOrUndefined(this.currentPage) && !isNullOrUndefined(this.owner.selection.start)) {
            if (this.touchDownOnSelectionMark === 0) {
                this.updateTextPositionForSelection(new Point(touchPoint.x, touchPoint.y), this.tapCount);
                if (this.tapCount === 2) {
                    this.selection.checkAndEnableHeaderFooter(point, touchPoint);
                }
            }
            if (this.owner.selection.isEmpty) {
                this.selection.updateCaretPosition();
            }
            this.selection.checkForCursorVisibility();
            if (!isNullOrUndefined(this.currentSelectedComment) && this.owner.commentReviewPane
                && !this.owner.commentReviewPane.commentPane.isEditMode) {
                this.currentSelectedComment = undefined;
            }
        }
    };
    /**
     * Gets touch offset value.
     * @private
     */
    LayoutViewer.prototype.getTouchOffsetValue = function (event) {
        var targetElement = this.viewerContainer;
        var offset = targetElement.getBoundingClientRect();
        var touchOffsetValues = event.touches[0];
        if (isNullOrUndefined(touchOffsetValues)) {
            touchOffsetValues = event.changedTouches[0];
        }
        var offsetX = touchOffsetValues.pageX - offset.left;
        var offsetY = touchOffsetValues.pageY - offset.top;
        return new Point(offsetX, offsetY);
    };
    /**
     * Fired on pinch zoom in.
     * @param {TouchEvent} event
     */
    LayoutViewer.prototype.onPinchInInternal = function (event) {
        this.preZoomFactor = this.zoomFactor;
        var updatedZoomFactor = this.zoomFactor - 0.01;
        if (updatedZoomFactor < 5 && updatedZoomFactor > 2) {
            updatedZoomFactor = updatedZoomFactor - 0.01;
        }
        if (updatedZoomFactor < 0.1) {
            updatedZoomFactor = 0.1;
        }
        this.zoomFactor = updatedZoomFactor;
    };
    /**
     * Fired on pinch zoom out.
     * @param {TouchEvent} event
     */
    LayoutViewer.prototype.onPinchOutInternal = function (event) {
        this.preZoomFactor = this.zoomFactor;
        var updatedZoomFactor = this.zoomFactor + 0.01;
        if (updatedZoomFactor > 2) {
            updatedZoomFactor = updatedZoomFactor + 0.01;
        }
        if (updatedZoomFactor > 5) {
            updatedZoomFactor = 5;
        }
        this.zoomFactor = updatedZoomFactor;
    };
    /**
     * Gets page width.
     * @private
     */
    LayoutViewer.prototype.getPageWidth = function (page) {
        var width = page.boundingRectangle.width;
        return width;
    };
    /**
     * Removes specified page.
     * @private
     */
    LayoutViewer.prototype.removePage = function (page) {
        if (this.currentPage === page) {
            this.currentPage = undefined;
        }
        var index = this.pages.indexOf(page);
        // if (index > -1) {
        this.pages.splice(index, 1);
        // }        
        //this.removeRenderedPages();
        var viewer = this;
        if (!isNullOrUndefined(viewer.visiblePages)) {
            if ((viewer.visiblePages).indexOf(page) > -1) {
                var pageIndex = (viewer.visiblePages).indexOf(page);
                (viewer.visiblePages).splice(pageIndex, 1);
            }
        }
        //(viewer as PageLayoutViewer).visiblePages.remove(page);
        var height = 0;
        for (var i = 0; i < this.pages.length; i++) {
            height = height + this.pages[i].boundingRectangle.height;
        }
        //Updates the vertical height.
        height -= page.boundingRectangle.height + 20;
        //ToDo:Update horizontal width, if removed page has max width.
        var top = 20;
        if (index > 0) {
            top += this.pages[index - 1].boundingRectangle.bottom;
        }
        if (index !== -1) {
            for (var i = index; i < this.pages.length; i++) {
                //Update bounding rectangle of next pages in collection.
                page = this.pages[i];
                // tslint:disable-next-line:max-line-length
                page.boundingRectangle = new Rect(page.boundingRectangle.x, top, page.boundingRectangle.width, page.boundingRectangle.height);
                top = page.boundingRectangle.bottom + 20;
                page.repeatHeaderRowTableWidget = false;
            }
        }
    };
    // private removeRenderedPages(): void {
    //     for (let i: number = 0; i < this.pages.length; i++) {
    //         this.clearContainer(this.pages[i]);
    //     }
    // }
    /**
     * Updates viewer size on window resize.
     * @private
     */
    LayoutViewer.prototype.updateViewerSize = function () {
        var viewer = this;
        var element = this.owner.getDocumentEditorElement();
        viewer.updateViewerSizeInternal(element);
        viewer.updateScrollBars();
        if (!isNullOrUndefined(this.selection)) {
            this.selection.updateCaretPosition();
        }
    };
    /**
     * Updates viewer size.
     */
    LayoutViewer.prototype.updateViewerSizeInternal = function (element) {
        if (!isNullOrUndefined(element)) {
            var rect = element.getBoundingClientRect();
            var width = 0;
            var height = 0;
            height = rect.height > 0 ? rect.height : 200;
            var restrictPaneRect = this.restrictEditingPane && this.restrictEditingPane.isShowRestrictPane ?
                this.restrictEditingPane.restrictPane.getBoundingClientRect() : undefined;
            var optionsRect = this.owner.optionsPaneModule && this.owner.optionsPaneModule.isOptionsPaneShow ?
                this.owner.optionsPaneModule.optionsPane.getBoundingClientRect() : undefined;
            var commentPane = this.owner.commentReviewPane && this.owner.commentReviewPane.reviewPane ?
                this.owner.commentReviewPane.reviewPane.getBoundingClientRect() : undefined;
            if (restrictPaneRect || optionsRect || commentPane) {
                var paneWidth = restrictPaneRect ? restrictPaneRect.width : 0;
                paneWidth += optionsRect ? optionsRect.width : 0;
                paneWidth += commentPane ? commentPane.width : 0;
                width = (rect.width - paneWidth) > 0 ? (rect.width - paneWidth) : 200;
            }
            else {
                width = rect.width > 0 ? rect.width : 200;
            }
            this.viewerContainer.style.height = height.toString() + 'px';
            this.viewerContainer.style.width = Math.ceil(width) + 'px';
            this.visibleBoundsIn = new Rect(0, 0, width, height);
            this.containerCanvas.width = width;
            this.containerCanvas.height = height;
            this.selectionCanvas.width = width;
            this.selectionCanvas.height = height;
        }
    };
    /**
     * Updates client area for block.
     * @private
     */
    LayoutViewer.prototype.updateClientAreaForBlock = function (block, beforeLayout, tableCollection) {
        var leftIndent = HelperMethods.convertPointToPixel(block.leftIndent);
        var rightIndent = HelperMethods.convertPointToPixel(block.rightIndent);
        var bidi = block.bidi;
        var width = 0;
        if (beforeLayout) {
            if (block instanceof TableWidget && tableCollection) {
                var tableWidget = tableCollection[0];
                this.clientActiveArea.x = this.clientArea.x = tableWidget.x;
                this.clientActiveArea.width = this.clientArea.width = tableWidget.width;
                //Updates the location of last item.
                tableWidget = tableCollection[tableCollection.length - 1];
                tableWidget.x = this.clientActiveArea.x;
                tableWidget.y = this.clientActiveArea.y;
            }
            else {
                // tslint:disable-next-line:max-line-length
                if (block instanceof TableWidget && !isNullOrUndefined(block.tableFormat)) {
                    if (!block.isGridUpdated) {
                        block.buildTableColumns();
                        block.isGridUpdated = true;
                    }
                    var tableAlignment = this.tableAlignmentForBidi(block, bidi);
                    if (tableAlignment !== 'Left') {
                        var tableWidth = 0;
                        // If the grid is calculated, we can direclty get the width from the grid.
                        // Otherwise, calculate the width.
                        tableWidth = HelperMethods.convertPointToPixel(block.tableHolder.getTotalWidth(0));
                        tableWidth = tableWidth === 0 ? block.tableHolder.tableWidth === 0 ?
                            block.getTableClientWidth(block.getOwnerWidth(false)) : block.tableHolder.tableWidth : tableWidth;
                        // Fore resizing table, the tableholder table width taken for updated width. 
                        // Since, the columns will be cleared if we performed resizing.
                        if (this.owner.editor && this.owner.editor.tableResize.currentResizingTable === block
                            && this.owner.editor.tableResize.resizerPosition === 0) {
                            tableWidth = HelperMethods.convertPointToPixel(block.tableHolder.tableWidth);
                        }
                        if (tableAlignment === 'Center') {
                            leftIndent = (this.clientArea.width - tableWidth) / 2;
                        }
                        else {
                            leftIndent = this.clientArea.width - tableWidth;
                        }
                        if (bidi) {
                            leftIndent = leftIndent - HelperMethods.convertPointToPixel(block.leftIndent);
                            rightIndent = leftIndent;
                        }
                        this.tableLefts.push(leftIndent);
                    }
                }
                width = this.clientArea.width - (leftIndent + HelperMethods.convertPointToPixel(block.rightIndent));
                this.clientActiveArea.x = this.clientArea.x = this.clientArea.x + (bidi ? rightIndent : leftIndent);
                this.clientActiveArea.width = this.clientArea.width = width > 0 ? width : 0;
            }
        }
        else {
            // Clears table left for table with right or center alignment.
            if (block instanceof TableWidget && !isNullOrUndefined(block.tableFormat)) {
                var tableAlignment = this.tableAlignmentForBidi(block, bidi);
                if (!block.isGridUpdated) {
                    block.buildTableColumns();
                    block.isGridUpdated = true;
                }
                if (tableAlignment !== 'Left' && this.tableLefts.length > 0) {
                    leftIndent = this.tableLefts.pop();
                    if (bidi) {
                        rightIndent = leftIndent;
                    }
                }
            }
            width = this.clientArea.width + leftIndent + HelperMethods.convertPointToPixel(block.rightIndent);
            this.clientActiveArea.width = this.clientArea.width = width > 0 ? width : 0;
            this.clientActiveArea.x = this.clientArea.x = this.clientArea.x - (bidi ? rightIndent : leftIndent);
        }
        this.clientArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
        // tslint:disable-next-line:max-line-length
        this.clientActiveArea = new Rect(this.clientActiveArea.x, this.clientActiveArea.y, this.clientActiveArea.width, this.clientActiveArea.height);
    };
    LayoutViewer.prototype.tableAlignmentForBidi = function (block, bidi) {
        var tableAlignment = block.tableFormat.tableAlignment;
        if (bidi) {
            if (tableAlignment === 'Left') {
                tableAlignment = 'Right';
            }
            else if (tableAlignment === 'Right') {
                tableAlignment = 'Left';
            }
        }
        return tableAlignment;
    };
    /**
     * Updates client active area left.
     * @private
     */
    LayoutViewer.prototype.cutFromLeft = function (x) {
        if (x < this.clientActiveArea.x) {
            x = this.clientActiveArea.x;
        }
        if (x > this.clientActiveArea.right && this.textWrap) {
            x = this.clientActiveArea.right;
        }
        this.clientActiveArea.width = this.clientActiveArea.right > x ? this.clientActiveArea.right - x : 0;
        this.clientActiveArea.x = x;
    };
    /**
     * Updates client active area top.
     * @private
     */
    LayoutViewer.prototype.cutFromTop = function (y) {
        if (y < this.clientActiveArea.y) {
            y = this.clientActiveArea.y;
        }
        if (y > this.clientActiveArea.bottom) {
            y = this.clientActiveArea.bottom;
        }
        this.clientActiveArea.height = this.clientActiveArea.bottom - y;
        this.clientActiveArea.x = this.clientArea.x;
        this.clientActiveArea.width = this.clientArea.width;
        this.clientActiveArea.y = y;
    };
    /**
     * Updates client width.
     * @private
     */
    LayoutViewer.prototype.updateClientWidth = function (width) {
        this.clientActiveArea.x -= width;
        if (this.clientActiveArea.width + width > 0) {
            this.clientActiveArea.width += width;
        }
        else {
            this.clientActiveArea.width = 0;
        }
    };
    /**
     * Inserts page in specified index.
     * @private
     */
    LayoutViewer.prototype.insertPage = function (index, page) {
        if (this.pages.indexOf(page) > -1) {
            this.pages.splice(this.pages.indexOf(page), 1);
        }
        this.pages.splice(index, 0, page);
        var top = 20;
        if (index > 0) {
            top += this.pages[index - 1].boundingRectangle.bottom;
        }
        for (var i = index; i < this.pages.length; i++) {
            //Update bounding rectangle of next pages in collection.
            page = this.pages[i];
            page.boundingRectangle = new Rect(page.boundingRectangle.x, top, page.boundingRectangle.width, page.boundingRectangle.height);
            top = page.boundingRectangle.bottom + 20;
        }
    };
    /**
     * Updates client area.
     * @private
     */
    LayoutViewer.prototype.updateClientArea = function (sectionFormat, page) {
        var top = 0;
        var headerDistance = 48;
        var footerDistance = 48;
        var pageHeight = HelperMethods.convertPointToPixel(sectionFormat.pageHeight);
        var bottomMargin = HelperMethods.convertPointToPixel(sectionFormat.bottomMargin);
        if (!isNullOrUndefined(sectionFormat)) {
            top = HelperMethods.convertPointToPixel(sectionFormat.topMargin);
            headerDistance = HelperMethods.convertPointToPixel(sectionFormat.headerDistance);
            footerDistance = HelperMethods.convertPointToPixel(sectionFormat.footerDistance);
        }
        var isEmptyWidget = false;
        if (!isNullOrUndefined(page.headerWidget)) {
            isEmptyWidget = page.headerWidget.isEmpty;
            if (!isEmptyWidget || isEmptyWidget && this.owner.enableHeaderAndFooter) {
                top = Math.min(Math.max(headerDistance + page.headerWidget.height, top), pageHeight / 100 * 40);
            }
        }
        var bottom = 0.667 + bottomMargin;
        if (!isNullOrUndefined(page.footerWidget)) {
            isEmptyWidget = page.footerWidget.isEmpty;
            if (!isEmptyWidget || isEmptyWidget && this.owner.enableHeaderAndFooter) {
                bottom = 0.667 + Math.min(pageHeight / 100 * 40, Math.max(footerDistance + page.footerWidget.height, bottomMargin));
            }
        }
        var width = 0;
        if (!isNullOrUndefined(sectionFormat)) {
            width = HelperMethods.convertPointToPixel(sectionFormat.pageWidth - sectionFormat.leftMargin - sectionFormat.rightMargin);
            
        }
        if (width < 0) {
            width = 0;
        }
        this.clientArea = new Rect(HelperMethods.convertPointToPixel(sectionFormat.leftMargin), top, width, pageHeight - top - bottom);
        this.clientActiveArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
    };
    /**
     * Updates client area left or top position.
     * @private
     */
    LayoutViewer.prototype.updateClientAreaTopOrLeft = function (tableWidget, beforeLayout) {
        if (beforeLayout) {
            this.clientActiveArea.y = this.clientActiveArea.y + tableWidget.topBorderWidth;
            this.clientActiveArea.x = this.clientActiveArea.x + tableWidget.leftBorderWidth;
        }
    };
    /**
     * Updates client area for table.
     * @private
     */
    LayoutViewer.prototype.updateClientAreaForTable = function (tableWidget) {
        this.clientActiveArea.x = this.clientArea.x = tableWidget.x;
        this.clientActiveArea.width = this.clientArea.width = tableWidget.width;
    };
    /**
     * Updates client area for row.
     * @private
     */
    LayoutViewer.prototype.updateClientAreaForRow = function (row, beforeLayout) {
        // tslint:disable-next-line:max-line-length
        var tableWidget = row.ownerTable;
        if (beforeLayout) {
            //tslint:disable:no-empty
        }
        else {
            this.clientActiveArea.x = this.clientArea.x = tableWidget.x;
            this.clientActiveArea.width = this.clientArea.width = tableWidget.width;
            this.clientArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
            // tslint:disable-next-line:max-line-length
            this.clientActiveArea = new Rect(this.clientActiveArea.x, this.clientActiveArea.y, this.clientActiveArea.width, this.clientActiveArea.height);
        }
    };
    /**
     * Updates client area for cell.
     * @private
     */
    LayoutViewer.prototype.updateClientAreaForCell = function (cell, beforeLayout) {
        // tslint:disable-next-line:max-line-length
        var rowWidget = cell.ownerRow;
        var cellWidget = cell;
        if (beforeLayout) {
            this.clientActiveArea.x = this.clientArea.x = cellWidget.x;
            this.clientActiveArea.y = cellWidget.y;
            this.clientActiveArea.width = this.clientArea.width = cellWidget.width > 0 ? cellWidget.width : 0;
            if (this instanceof PageLayoutViewer) {
                this.clientActiveArea.height = Number.POSITIVE_INFINITY;
            }
            this.clientArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
            // tslint:disable-next-line:max-line-length
            this.clientActiveArea = new Rect(this.clientActiveArea.x, this.clientActiveArea.y, this.clientActiveArea.width, this.clientActiveArea.height);
        }
        else {
            this.clientActiveArea.x = this.clientArea.x = cellWidget.x + cellWidget.width + cellWidget.margin.right;
            if (rowWidget.x + rowWidget.width - this.clientArea.x < 0) {
                this.clientActiveArea.width = this.clientArea.width = 0;
            }
            else {
                this.clientActiveArea.width = this.clientArea.width = rowWidget.x + rowWidget.width - this.clientArea.x;
            }
            // tslint:disable-next-line:max-line-length
            this.clientActiveArea.y = cellWidget.y - cellWidget.margin.top - HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.cellSpacing);
            if (!cell.ownerTable.isInsideTable) {
                this.clientActiveArea.height = this.clientArea.bottom - rowWidget.y > 0 ? this.clientArea.bottom - rowWidget.y : 0;
            }
            this.clientArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
            // tslint:disable-next-line:max-line-length
            this.clientActiveArea = new Rect(this.clientActiveArea.x, this.clientActiveArea.y, this.clientActiveArea.width, this.clientActiveArea.height);
        }
    };
    /**
     * Updates the client area based on widget.
     * @private
     */
    LayoutViewer.prototype.updateClientAreaByWidget = function (widget) {
        this.clientArea.x = widget.x;
        this.clientArea.y = widget.y;
        this.clientActiveArea.x = widget.x;
        this.clientActiveArea.y = widget.y;
    };
    //Widget
    /**
     * Updates client area location.
     * @param widget
     * @param area
     * @private
     */
    LayoutViewer.prototype.updateClientAreaLocation = function (widget, area) {
        widget.x = area.x;
        widget.y = area.y;
        widget.width = area.width;
    };
    /**
     * Updates text position for selection.
     * @param cursorPoint
     * @param tapCount
     * @param clearMultiSelection
     * @private
     */
    LayoutViewer.prototype.updateTextPositionForSelection = function (cursorPoint, tapCount) {
        var widget = this.getLineWidget(cursorPoint);
        if (!isNullOrUndefined(widget)) {
            this.selection.updateTextPosition(widget, cursorPoint);
        }
        if (tapCount > 1) {
            this.isMouseDown = false;
            this.useTouchSelectionMark = false;
            if (this.pages.length === 0) {
                return;
            }
            //Double tap/triple tap selection
            if (!isNullOrUndefined(this.currentPage) && !isNullOrUndefined(this.owner.selection.start)) {
                if (tapCount % 2 === 0) {
                    this.owner.selection.selectCurrentWord();
                }
                else {
                    this.owner.selection.selectParagraph();
                }
            }
        }
    };
    /**
     * Scrolls to specified position.
     * @param startPosition
     * @param endPosition
     * @private
     */
    LayoutViewer.prototype.scrollToPosition = function (startPosition, endPosition, skipCursorUpdate) {
        if (this.skipScrollToPosition) {
            this.skipScrollToPosition = false;
            return;
        }
        if (this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizing
            || this.isMouseDownInFooterRegion || this.isRowOrCellResizing) {
            return;
        }
        var lineWidget = this.selection.getLineWidgetInternal(endPosition.currentWidget, endPosition.offset, true);
        if (isNullOrUndefined(lineWidget)) {
            return;
        }
        var top = this.selection.getTop(lineWidget);
        if (this.isMouseDown) {
            var prevLineWidget = this.selection.getLineWidgetInternal(endPosition.currentWidget, endPosition.offset, false);
            var prevTop = this.selection.getTop(prevLineWidget);
            if (prevLineWidget !== lineWidget && endPosition.location.y >= prevTop) {
                lineWidget = prevLineWidget;
            }
        }
        var height = lineWidget.height;
        //Gets current page.
        var endPage = this.selection.getPage(lineWidget.paragraph);
        this.currentPage = endPage;
        var x = 0;
        var y = 0;
        var viewer = this;
        var isPageLayout = viewer instanceof PageLayoutViewer;
        if (isPageLayout) {
            if (isNullOrUndefined(endPage)) {
                return;
            }
            var pageWidth = endPage.boundingRectangle.width;
            x = (this.visibleBounds.width - pageWidth * this.zoomFactor) / 2;
            if (x < 30) {
                x = 30;
            }
            // tslint:disable-next-line:max-line-length
            y = endPage.boundingRectangle.y * this.zoomFactor + (this.pages.indexOf(endPage) + 1) * viewer.pageGap * (1 - this.zoomFactor);
        }
        var scrollTop = this.containerTop;
        var scrollLeft = this.containerLeft;
        var pageHeight = this.visibleBounds.height;
        var caretInfo = this.selection.updateCaretSize(this.owner.selection.end, true);
        var topMargin = caretInfo.topMargin;
        var caretHeight = caretInfo.height;
        x += (endPosition.location.x) * this.zoomFactor;
        y += (endPosition.location.y + topMargin) * this.zoomFactor;
        //vertical scroll bar update
        if ((scrollTop + 20) > y) {
            this.viewerContainer.scrollTop = (y - 10);
        }
        else if (scrollTop + pageHeight < y + caretHeight) {
            this.viewerContainer.scrollTop = y + caretHeight - pageHeight + 10;
        }
        if (!skipCursorUpdate) {
            this.selection.updateCaretToPage(startPosition, endPage);
        }
        var scrollBarWidth = this.viewerContainer.offsetWidth - this.viewerContainer.clientWidth;
        if (scrollLeft > x) {
            this.viewerContainer.scrollLeft = x - (viewer.pageContainer.offsetWidth / 100) * 20;
        }
        else if (scrollLeft + this.visibleBounds.width < x + scrollBarWidth) {
            this.viewerContainer.scrollLeft = scrollLeft + (viewer.pageContainer.offsetWidth / 100) * 15 + scrollBarWidth;
        }
    };
    /**
     * Gets line widget using cursor point.
     * @private
     */
    LayoutViewer.prototype.getLineWidget = function (cursorPoint) {
        return this.getLineWidgetInternal(cursorPoint, false);
    };
    /**
     * Gets line widget.
     * @private
     */
    LayoutViewer.prototype.getLineWidgetInternal = function (cursorPoint, isMouseDragged) {
        var widget = undefined;
        if (!isNullOrUndefined(this.currentPage)) {
            var childWidgets = void 0;
            if (this.owner.enableHeaderAndFooter) {
                var page = this.currentPage;
                var pageTop = this.selection.getPageTop(page);
                var pageBottom = page.boundingRectangle.height;
                var headerHeight = Math.max((page.headerWidget.y + page.headerWidget.height), HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.topMargin)) * this.zoomFactor;
                var footerDistance = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.footerDistance);
                var footerHeight = (page.boundingRectangle.height -
                    Math.max(page.footerWidget.height + footerDistance, footerDistance * 2));
                if (isMouseDragged) {
                    if (this.isBlockInHeader(this.selection.start.paragraph)) {
                        childWidgets = this.currentPage.headerWidget;
                    }
                    else {
                        childWidgets = this.currentPage.footerWidget;
                    }
                }
                else {
                    if (cursorPoint.y <= pageBottom && cursorPoint.y >= footerHeight) {
                        childWidgets = this.currentPage.footerWidget;
                    }
                    else if ((cursorPoint.y) >= 0 && (cursorPoint.y) <= headerHeight) {
                        childWidgets = this.currentPage.headerWidget;
                    }
                }
                if (isNullOrUndefined(childWidgets)) {
                    return undefined;
                }
                return this.selection.getLineWidgetBodyWidget(childWidgets, cursorPoint);
            }
            else {
                for (var i = 0; i < this.currentPage.bodyWidgets.length; i++) {
                    var bodyWidgets = this.currentPage.bodyWidgets[i];
                    widget = this.selection.getLineWidgetBodyWidget(bodyWidgets, cursorPoint);
                    if (!isNullOrUndefined(widget)) {
                        break;
                    }
                }
            }
        }
        return widget;
    };
    /**
     * @private
     */
    LayoutViewer.prototype.isBlockInHeader = function (block) {
        while (!(block.containerWidget instanceof HeaderFooterWidget)) {
            if (!block.containerWidget) {
                return false;
            }
            block = block.containerWidget;
        }
        return block.containerWidget.headerFooterType.indexOf('Header') !== -1;
    };
    /**
     * Clears selection highlight.
     * @private
     */
    LayoutViewer.prototype.clearSelectionHighlight = function () {
        var canClear = true;
        canClear = (!this.isControlPressed || !this.isMouseDown);
        // if (this.owner.selection.selectionRanges.length > 0 && canClear) {
        if (this.owner.selection.clearSelectionHighlightInSelectedWidgets()) {
            this.selectionContext.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
        }
        // } else if (!isNullOrUndefined(this.owner.selection.currentSelectionRange) && this.isMouseDown) {
        //     this.owner.selection.currentSelectionRange.clearSelectionHighlight();
        // }
        //this.renderVisiblePages();
    };
    /**
     * @private
     */
    LayoutViewer.prototype.removeEmptyPages = function () {
        var scrollToLastPage = false;
        var viewer = this;
        for (var j = 0; j < this.pages.length; j++) {
            var page = this.pages[j];
            if (page.bodyWidgets.length === 0 || page.bodyWidgets[0].childWidgets.length === 0) {
                // tslint:disable-next-line:max-line-length
                if (j === this.pages.length - 1 && viewer instanceof PageLayoutViewer && viewer.visiblePages.indexOf(this.pages[j]) !== -1) {
                    scrollToLastPage = true;
                }
                this.removePage(this.pages[j]);
                j--;
            }
        }
        if (scrollToLastPage) {
            this.scrollToBottom();
        }
    };
    /**
     * @private
     */
    LayoutViewer.prototype.scrollToBottom = function () {
        if (this.selection.start.paragraph && this.selection.start.paragraph.bodyWidget) {
            var page = this.selection.start.paragraph.bodyWidget.page;
            var containerHeight = this.visibleBounds.height;
            this.viewerContainer.scrollTop = page.boundingRectangle.bottom - containerHeight;
        }
    };
    /**
     * Returns the field code result.
     * @private
     */
    LayoutViewer.prototype.getFieldResult = function (fieldBegin, page) {
        if (!isNullOrUndefined(page) && !isNullOrUndefined(this.selection)) {
            var fieldCode = this.selection.getFieldCode(fieldBegin);
            var fieldCodes = fieldCode.split('\*');
            var fieldCategory = fieldCodes[0].replace(/[^\w\s]/gi, '').trim().toLowerCase();
            var fieldPattern = '';
            if (fieldCodes.length > 1) {
                fieldPattern = fieldCodes[1].replace(/[^\w\s]/gi, '').trim();
            }
            switch (fieldCategory) {
                case 'page':
                    if (page.bodyWidgets[0].sectionFormat.restartPageNumbering && page.sectionIndex !== 0) {
                        var currentSectionIndex_1 = page.sectionIndex;
                        var previousPage = page.previousPage;
                        if (currentSectionIndex_1 !== previousPage.sectionIndex) {
                            page.currentPageNum = (page.bodyWidgets[0].sectionFormat.pageStartingNumber);
                            return this.getFieldText(fieldPattern, page.currentPageNum);
                        }
                        if (previousPage.currentPageNum === 0) {
                            previousPage.currentPageNum = (page.bodyWidgets[0].sectionFormat.pageStartingNumber);
                        }
                        page.currentPageNum = previousPage.currentPageNum + 1;
                        return this.getFieldText(fieldPattern, page.currentPageNum);
                    }
                    page.currentPageNum = page.index + 1;
                    return this.getFieldText(fieldPattern, page.currentPageNum);
                case 'numpages':
                    return this.getFieldText(fieldPattern, page.viewer.pages.length);
                case 'sectionpages':
                    var currentSectionIndex = page.sectionIndex;
                    var currentPageCount = 0;
                    for (var i = 0; i < page.viewer.pages.length; i++) {
                        if (page.viewer.pages[i].sectionIndex === currentSectionIndex) {
                            currentPageCount++;
                        }
                        else if (currentPageCount !== 0) {
                            break;
                        }
                    }
                    return this.getFieldText(fieldPattern, currentPageCount);
                default:
                    break;
            }
        }
        return '';
    };
    /**
     * Returns field text.
     */
    LayoutViewer.prototype.getFieldText = function (pattern, value) {
        switch (pattern) {
            case 'ALPHABETIC':
                return this.layout.getAsLetter(value).toUpperCase();
            case 'alphabetic':
                return this.layout.getAsLetter(value).toLowerCase();
            case 'roman':
                return this.layout.getAsRoman(value).toLowerCase();
            case 'ROMAN':
                return this.layout.getAsRoman(value).toUpperCase();
            default:
                return value.toString();
        }
    };
    /**
     * Destroys the internal objects maintained for control.
     */
    LayoutViewer.prototype.destroy = function () {
        if (!isNullOrUndefined(this.owner)) {
            this.unWireEvent();
        }
        this.pages = [];
        this.pages = undefined;
        this.fieldStacks = [];
        this.fieldStacks = undefined;
        this.splittedCellWidgets = [];
        this.splittedCellWidgets = undefined;
        this.fields = [];
        this.fields = undefined;
        if (this.layout) {
            this.layout.destroy();
        }
        this.layout = undefined;
        if (!isNullOrUndefined(this.render)) {
            this.render.destroy();
        }
        this.render = undefined;
        if (this.dialogInternal) {
            this.dialogInternal.destroy();
        }
        this.dialogInternal = undefined;
        if (this.dialogInternal2) {
            this.dialogInternal2.destroy();
            this.dialogInternal2 = undefined;
        }
        if (this.dialogTarget1 && this.dialogTarget1.parentElement) {
            this.dialogTarget1.parentElement.removeChild(this.dialogTarget1);
        }
        this.dialogTarget1 = undefined;
        if (this.dialogTarget2 && this.dialogTarget2.parentElement) {
            this.dialogTarget2.parentElement.removeChild(this.dialogTarget2);
        }
        this.dialogTarget2 = undefined;
        if (!isNullOrUndefined(this.touchStart)) {
            this.touchStart.innerHTML = '';
        }
        if (this.textHelper) {
            this.textHelper.destroy();
        }
        this.textHelper = undefined;
        this.touchStart = undefined;
        if (!isNullOrUndefined(this.touchEnd)) {
            this.touchEnd.innerHTML = '';
        }
        this.touchEnd = undefined;
        if (!isNullOrUndefined(this.containerCanvasIn)) {
            this.containerCanvasIn.innerHTML = '';
        }
        this.containerCanvasIn = undefined;
        if (!isNullOrUndefined(this.selectionCanvasIn)) {
            this.selectionCanvasIn.innerHTML = '';
        }
        this.selectionCanvasIn = undefined;
        if (!isNullOrUndefined(this.editableDiv)) {
            this.editableDiv.innerHTML = '';
            this.editableDiv.parentElement.removeChild(this.editableDiv);
        }
        this.editableDiv = undefined;
        if (!isNullOrUndefined(this.pageContainer)) {
            this.pageContainer.innerHTML = '';
        }
        this.pageContainer = undefined;
        if (!isNullOrUndefined(this.viewerContainer)) {
            this.viewerContainer.innerHTML = '';
        }
        this.viewerContainer = undefined;
        this.owner = undefined;
        this.heightInfoCollection = undefined;
    };
    /**
     * Un-Wires events and methods
     */
    LayoutViewer.prototype.unWireEvent = function () {
        this.viewerContainer.removeEventListener('scroll', this.scrollHandler);
        this.viewerContainer.removeEventListener('mousedown', this.onMouseDownInternal);
        this.viewerContainer.removeEventListener('mousemove', this.onMouseMoveInternal);
        if (!Browser.isDevice) {
            this.editableDiv.removeEventListener('keypress', this.onKeyPressInternal);
            if (Browser.info.name === 'chrome') {
                this.editableDiv.removeEventListener('textInput', this.onTextInput);
            }
        }
        else {
            this.editableDiv.removeEventListener('input', this.onTextInputInternal);
        }
        this.editableDiv.removeEventListener('paste', this.onPaste);
        this.viewerContainer.removeEventListener('contextmenu', this.onContextMenu);
        this.editableDiv.removeEventListener('blur', this.onFocusOut);
        this.editableDiv.removeEventListener('keydown', this.onKeyDownInternal);
        this.editableDiv.removeEventListener('compositionstart', this.compositionStart);
        this.editableDiv.removeEventListener('compositionupdate', this.compositionUpdated);
        this.editableDiv.removeEventListener('compositionend', this.compositionEnd);
        this.viewerContainer.removeEventListener('mouseup', this.onMouseUpInternal);
        if (!isNullOrUndefined(this.iframe)) {
            this.iframe.removeEventListener('load', this.onIframeLoad);
        }
        this.viewerContainer.removeEventListener('dblclick', this.onDoubleTap);
        window.removeEventListener('resize', this.onWindowResize);
        window.removeEventListener('keyup', this.onKeyUpInternal);
        window.removeEventListener('mouseup', this.onImageResizer);
        window.removeEventListener('touchend', this.onImageResizer);
    };
    return LayoutViewer;
}());
/**
 * @private
 */
var PageLayoutViewer = /** @__PURE__ @class */ (function (_super) {
    __extends$3(PageLayoutViewer, _super);
    /**
     * Initialize the constructor of PageLayoutViewer
     */
    function PageLayoutViewer(owner) {
        var _this = _super.call(this, owner) || this;
        _this.pageLeft = 30;
        /**
         * @private
         */
        _this.visiblePages = [];
        if (isNullOrUndefined(owner) || isNullOrUndefined(owner.element)) {
            return _this;
        }
        return _this;
    }
    Object.defineProperty(PageLayoutViewer.prototype, "pageGap", {
        /**
         * @private
         */
        get: function () {
            return this.owner.pageGap;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates new page.
     * @private
     */
    PageLayoutViewer.prototype.createNewPage = function (section, index) {
        var viewer = this;
        var yPos = this.pageGap;
        if (this.pages.length > 0) {
            yPos = this.pages[this.pages.length - 1].boundingRectangle.bottom + this.pageGap;
        }
        var page = new Page();
        page.viewer = this;
        // tslint:disable-next-line:max-line-length
        var pageWidth = !isNullOrUndefined(section.sectionFormat) ? HelperMethods.convertPointToPixel(section.sectionFormat.pageWidth) : 816;
        // tslint:disable-next-line:max-line-length
        var pageHeight = !isNullOrUndefined(section.sectionFormat) ? HelperMethods.convertPointToPixel(section.sectionFormat.pageHeight) : 1056;
        var xPos = (this.visibleBounds.width - pageWidth * this.zoomFactor) / 2;
        if (xPos < this.pageLeft) {
            xPos = this.pageLeft;
        }
        page.boundingRectangle = new Rect(xPos, yPos, pageWidth, pageHeight);
        if (isNullOrUndefined(index)) {
            this.pages.push(page);
        }
        else {
            this.pages.splice(index, 0, page);
        }
        this.updateClientArea(section.sectionFormat, page);
        page.bodyWidgets.push(section);
        page.bodyWidgets[page.bodyWidgets.length - 1].page = page;
        this.layout.layoutHeaderFooter(section, viewer, page);
        this.updateClientArea(section.sectionFormat, page);
        return page;
    };
    /**
     * Updates cursor.
     */
    PageLayoutViewer.prototype.updateCursor = function (event) {
        var hyperlinkField = undefined;
        var div = this.viewerContainer;
        var point = new Point(event.offsetX, event.offsetY);
        var touchPoint = this.findFocusedPage(point, true);
        var widget = this.getLineWidget(touchPoint);
        var widgetInfo;
        var left;
        var top;
        var editor = !this.owner.isReadOnlyMode ? this.owner.editorModule : undefined;
        var isRowResize = editor ? editor.tableResize.isInRowResizerArea(touchPoint) : false;
        var isCellResize = editor ? editor.tableResize.isInCellResizerArea(touchPoint) : false;
        var resizePosition = '';
        if (this.owner.enableImageResizerMode) {
            var resizeObj = this.owner.imageResizerModule.getImagePoint(touchPoint);
            this.owner.imageResizerModule.selectedResizeElement = resizeObj.selectedElement;
            resizePosition = resizeObj.resizePosition;
        }
        var lineLeft = 0;
        if (!isNullOrUndefined(widget)) {
            lineLeft = this.selection.getLineStartLeft(widget);
            hyperlinkField = this.selection.getHyperLinkFieldInCurrentSelection(widget, touchPoint);
            widgetInfo = this.selection.updateTextPositionIn(widget, undefined, 0, touchPoint, true);
            left = this.selection.getLeft(widget);
            top = this.selection.getTop(widget);
            this.selection.setHyperlinkContentToToolTip(hyperlinkField, widget, touchPoint.x);
        }
        if (!isNullOrUndefined(hyperlinkField) && (event.ctrlKey &&
            this.owner.useCtrlClickToFollowHyperlink || !this.owner.useCtrlClickToFollowHyperlink)) {
            div.style.cursor = 'pointer';
            return;
        }
        else if (touchPoint.x >= lineLeft &&
            event.offsetX < (this.visibleBounds.width - (this.visibleBounds.width - this.viewerContainer.clientWidth)) &&
            event.offsetY < (this.visibleBounds.height - (this.visibleBounds.height - this.viewerContainer.clientHeight))) {
            if (this.selection.isEmpty) {
                div.style.cursor = 'text';
            }
            else {
                div.style.cursor = this.selection.checkCursorIsInSelection(widget, touchPoint) ? 'default' : 'text';
            }
        }
        else {
            div.style.cursor = 'default';
        }
        if (!isNullOrUndefined(resizePosition) && resizePosition !== '') {
            div.style.cursor = resizePosition;
        }
        else if (!isNullOrUndefined(widgetInfo) && widgetInfo.isImageSelected && left < touchPoint.x && top < touchPoint.y &&
            left + widget.width > touchPoint.x && top + widget.height > touchPoint.y) {
            div.style.cursor = 'move';
        }
        if (isRowResize) {
            div.style.cursor = 'row-resize';
        }
        else if (isCellResize) {
            div.style.cursor = 'col-resize';
        }
    };
    /**
     * Finds focused page.
     * @private
     */
    PageLayoutViewer.prototype.findFocusedPage = function (currentPoint, updateCurrentPage) {
        var point = new Point(currentPoint.x, currentPoint.y);
        point.x += this.viewerContainer.scrollLeft;
        point.y += this.viewerContainer.scrollTop;
        for (var i = 0; i < this.pages.length; i++) {
            var page = this.pages[i];
            var pageTop = (page.boundingRectangle.y - this.pageGap * (i + 1)) * this.zoomFactor + this.pageGap * (i + 1);
            var pageHeight = (page.boundingRectangle.height * this.zoomFactor) + this.pageGap;
            var pageLeft = page.boundingRectangle.x;
            var pageRight = ((page.boundingRectangle.right - pageLeft) * this.zoomFactor) + pageLeft;
            if (pageTop <= point.y && pageTop + pageHeight >= point.y) {
                if (updateCurrentPage) {
                    this.currentPage = page;
                }
                point.y = (point.y - (pageTop)) / this.zoomFactor;
                if (point.x > pageRight) {
                    point.x = page.boundingRectangle.right;
                }
                else if (point.x < pageLeft) {
                    point.x = 0;
                }
                else {
                    point.x = (point.x - pageLeft) / this.zoomFactor;
                }
                return point;
            }
        }
        return point;
    };
    /**
     * Fired when page fit type changed.
     * @private
     */
    PageLayoutViewer.prototype.onPageFitTypeChanged = function (pageFitType) {
        var width = this.visibleBounds.width;
        var height = this.visibleBounds.height;
        var section = this.visiblePages[0].bodyWidgets[0];
        var pageWidth = HelperMethods.convertPointToPixel(section.sectionFormat.pageWidth);
        var pageHeight = HelperMethods.convertPointToPixel(section.sectionFormat.pageHeight);
        switch (pageFitType) {
            case 'FitOnePage':
                if (height > 0 && pageHeight > 0) {
                    var zoomFactor = (this.visibleBounds.height - 2 * this.pageGap - (this.pageGap - 2)) / pageHeight;
                    if (zoomFactor === this.zoomFactor) {
                        if (!isNullOrUndefined(this.owner.selection) && !isNullOrUndefined(this.owner.selection.start) &&
                            !isNullOrUndefined(this.owner.selection.end)) {
                            this.scrollToPosition(this.owner.selection.start, this.owner.selection.end);
                        }
                    }
                    else {
                        this.zoomFactor = zoomFactor;
                    }
                }
                break;
            case 'FitPageWidth':
                if (width > 0 && pageWidth > 0) {
                    this.zoomFactor = (this.visibleBounds.width - 80) / pageWidth;
                }
                break;
            default:
                this.zoomFactor = 100 / 100;
                break;
        }
    };
    /**
     * @private
     */
    PageLayoutViewer.prototype.handleZoom = function () {
        var prevScaleFactor = this.preZoomFactor;
        var page = null;
        var verticalHeight = 0;
        var scrollToPosition = false;
        if (this.selection && isNullOrUndefined(this.zoomX && isNullOrUndefined(this.zoomY))) {
            var x = 0;
            var y = 0;
            var endPage = this.selection.getPage(this.selection.end.currentWidget.paragraph);
            x = (this.visibleBounds.width - endPage.boundingRectangle.width * prevScaleFactor) / 2;
            if (x < 30) {
                x = 30;
            }
            // tslint:disable-next-line:max-line-length
            y = endPage.boundingRectangle.y * prevScaleFactor + (this.pages.indexOf(endPage) + 1) * this.pageGap * (1 - prevScaleFactor);
            var caretInfo = this.selection.updateCaretSize(this.owner.selection.end, true);
            var topMargin = caretInfo.topMargin;
            var caretHeight = caretInfo.height;
            x += (this.selection.end.location.x) * prevScaleFactor;
            y += (this.selection.end.location.y + topMargin) * prevScaleFactor;
            if (x >= this.containerLeft && x <= this.visibleBounds.width &&
                y >= this.containerTop && y <= this.containerTop + this.visibleBounds.height) {
                scrollToPosition = true;
            }
        }
        for (var i = 0; i < this.pages.length; i++) {
            verticalHeight = verticalHeight + this.pages[i].boundingRectangle.height;
        }
        var horizontalWidth = 0;
        for (var i = 0; i < this.pages.length; i++) {
            if (horizontalWidth < this.pages[i].boundingRectangle.width) {
                horizontalWidth = this.pages[i].boundingRectangle.width;
            }
        }
        // tslint:disable-next-line:max-line-length
        var height = (verticalHeight * this.zoomFactor + (this.pages.length + 1) * this.pageGap * (1 - this.zoomFactor)) - this.visibleBounds.height;
        var horWidth = horizontalWidth * this.zoomFactor - this.visibleBounds.width;
        if (this.visibleBounds.width - horizontalWidth * this.zoomFactor < 60) {
            horWidth += 60;
        }
        //Update Vertical Scroll bar
        if (height > 0) {
            var value = this.containerTop;
            if (this.visiblePages.length > 0) {
                page = this.visiblePages[0];
                // tslint:disable-next-line:max-line-length
                var prevPageTop = (page.boundingRectangle.y - (page.index + 1) * this.pageGap) * prevScaleFactor + (page.index + 1) * this.pageGap;
                var zoomY = this.zoomY;
                if (isNullOrUndefined) {
                    zoomY = this.visibleBounds.height / 2;
                }
                var prevY = value + zoomY;
                while (prevY > prevPageTop + (page.boundingRectangle.height * prevScaleFactor)) {
                    var pageIndex = page.index + 1;
                    if (pageIndex === this.pages.length) {
                        break;
                    }
                    page = this.pages[pageIndex];
                    // tslint:disable-next-line:max-line-length
                    prevPageTop = (page.boundingRectangle.y - (page.index + 1) * this.pageGap) * prevScaleFactor + (page.index + 1) * this.pageGap;
                }
                // tslint:disable-next-line:max-line-length
                var currentY = (page.boundingRectangle.y - (page.index + 1) * this.pageGap) * this.zoomFactor + (page.index + 1) * this.pageGap
                    + ((prevY - prevPageTop) < 0 ? prevY - prevPageTop : (prevY - prevPageTop) * (this.zoomFactor / prevScaleFactor));
                value = currentY - zoomY;
                zoomY = this.visibleBounds.height / 2;
            }
            this.viewerContainer.scrollTop = value;
        }
        else {
            this.viewerContainer.scrollTop = 0;
        }
        // update Horizontal Scroll Bar
        if (horWidth > 0) {
            var value = this.containerLeft;
            if (this.visiblePages.length > 0) {
                if (page === null) {
                    page = this.visiblePages[0];
                }
                var zoomX = this.zoomX;
                if (isNullOrUndefined(zoomX)) {
                    zoomX = this.visibleBounds.width / 2;
                }
                var prevValue = (page.boundingRectangle.width * prevScaleFactor) / page.boundingRectangle.width;
                var prevX = value + zoomX;
                // tslint:disable-next-line:max-line-length
                var currentX = page.boundingRectangle.x
                    + ((prevX - page.boundingRectangle.x) < 0 ? prevX - page.boundingRectangle.x : (prevX - page.boundingRectangle.x) * (this.zoomFactor / prevValue));
                value = currentX - zoomX;
                zoomX = this.visibleBounds.width / 2;
            }
            this.viewerContainer.scrollLeft = value;
        }
        else {
            this.viewerContainer.scrollLeft = 0;
        }
        this.updateScrollBars();
        if (scrollToPosition) {
            this.scrollToPosition(this.selection.start, this.selection.end);
        }
    };
    /**
     * Gets current page header footer.
     * @private
     */
    PageLayoutViewer.prototype.getCurrentPageHeaderFooter = function (section, isHeader) {
        return this.getCurrentHeaderFooter(this.getHeaderFooterType(section, isHeader), section.index);
    };
    /**
     * Get header footer type
     * @private
     */
    PageLayoutViewer.prototype.getHeaderFooterType = function (section, isHeader) {
        var type;
        type = isHeader ? 'OddHeader' : 'OddFooter';
        var page = section.page;
        // tslint:disable-next-line:max-line-length
        if (section.sectionFormat.differentFirstPage && (isNullOrUndefined(page.previousPage) || page.sectionIndex !== page.previousPage.sectionIndex)) {
            type = isHeader ? 'FirstPageHeader' : 'FirstPageFooter';
        }
        else if (section.sectionFormat.differentOddAndEvenPages && this.pages.length % 2 === 0) {
            type = isHeader ? 'EvenHeader' : 'EvenFooter';
        }
        return type;
    };
    /**
     * Gets current header footer.
     * @param type
     * @param section
     * @private
     */
    PageLayoutViewer.prototype.getCurrentHeaderFooter = function (type, sectionIndex) {
        if (this.headersFooters[sectionIndex]) {
            var index = this.getHeaderFooter(type);
            var headerFooter = this.headersFooters[sectionIndex][index];
            if (!headerFooter) {
                if (this.headersFooters[0][index]) {
                    headerFooter = this.headersFooters[0][index];
                }
                else {
                    headerFooter = this.createHeaderFooterWidget(type);
                    headerFooter.isEmpty = true;
                }
                this.headersFooters[sectionIndex][index] = headerFooter;
            }
            return headerFooter;
        }
        else if (sectionIndex > 0) {
            return this.getCurrentHeaderFooter(type, sectionIndex - 1);
        }
        return undefined;
    };
    PageLayoutViewer.prototype.createHeaderFooterWidget = function (type) {
        var headerFooter = new HeaderFooterWidget(type);
        var paragraph = new ParagraphWidget();
        paragraph.childWidgets.push(new LineWidget(paragraph));
        return headerFooter;
    };
    /**
     * Gets header footer.
     * @param type
     * @private
     */
    PageLayoutViewer.prototype.getHeaderFooter = function (type) {
        switch (type) {
            case 'OddHeader':
                return 0;
            case 'OddFooter':
                return 1;
            case 'EvenHeader':
                return 2;
            case 'EvenFooter':
                return 3;
            case 'FirstPageHeader':
                return 4;
            case 'FirstPageFooter':
                return 5;
        }
    };
    /**
     * Updates header footer client area.
     * @private
     */
    PageLayoutViewer.prototype.updateHFClientArea = function (sectionFormat, isHeader) {
        // tslint:disable-next-line:max-line-length
        var width = HelperMethods.convertPointToPixel(sectionFormat.pageWidth - sectionFormat.leftMargin - sectionFormat.rightMargin);
        if (width < 0) {
            width = 0;
        }
        if (isHeader) {
            // tslint:disable-next-line:max-line-length
            this.clientArea = new Rect(HelperMethods.convertPointToPixel(sectionFormat.leftMargin), HelperMethods.convertPointToPixel(sectionFormat.headerDistance), width, Number.POSITIVE_INFINITY);
        }
        else {
            // tslint:disable-next-line:max-line-length
            this.clientArea = new Rect(HelperMethods.convertPointToPixel(sectionFormat.leftMargin), HelperMethods.convertPointToPixel(sectionFormat.pageHeight - sectionFormat.footerDistance), width, Number.POSITIVE_INFINITY);
        }
        this.clientActiveArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
    };
    /**
     * @private
     */
    PageLayoutViewer.prototype.updateHCFClientAreaWithTop = function (sectionFormat, isHeader, page) {
        this.updateHFClientArea(sectionFormat, isHeader);
        if (!isHeader) {
            if (page.footerWidget.y < this.clientActiveArea.y) {
                this.clientActiveArea.y = page.footerWidget.y;
                this.clientActiveArea.height = Number.POSITIVE_INFINITY;
            }
        }
    };
    /**
     * Scrolls to the specified page
     * @private
     */
    PageLayoutViewer.prototype.scrollToPage = function (pageIndex) {
        var top = 0;
        for (var i = 0; i < this.pages.length; i++) {
            top = this.pages[i].boundingRectangle.y - (this.pageGap / 2);
            if (i === pageIndex) {
                break;
            }
        }
        this.viewerContainer.scrollTop = top;
        this.updateScrollBars();
    };
    /**
     * Updates scroll bars.
     * @private
     */
    PageLayoutViewer.prototype.updateScrollBars = function () {
        var height = 0;
        for (var i = 0; i < this.pages.length; i++) {
            height = height + this.pages[i].boundingRectangle.height;
        }
        var width = 0;
        for (var i = 0; i < this.pages.length; i++) {
            if (width < this.pages[i].boundingRectangle.width) {
                width = this.pages[i].boundingRectangle.width;
            }
        }
        var containerWidth = (width * this.zoomFactor) + (this.pageLeft * 2);
        var containerHeight = (height * this.zoomFactor) + (this.pages.length + 1) * this.pageGap;
        var viewerWidth = this.visibleBounds.width;
        var viewerHeight = this.visibleBounds.height;
        if (this.visibleBounds.width !== this.viewerContainer.clientWidth) {
            viewerWidth -= (this.visibleBounds.width - this.viewerContainer.clientWidth);
        }
        else if (containerHeight > viewerHeight) {
            viewerWidth -= this.viewerContainer.offsetWidth - this.viewerContainer.clientWidth;
        }
        if (containerWidth > viewerWidth) {
            viewerHeight -= (this.visibleBounds.height - this.viewerContainer.clientHeight);
        }
        width = containerWidth > viewerWidth ? containerWidth : viewerWidth;
        height = containerHeight > viewerHeight ? containerHeight : viewerHeight;
        if (parseInt(this.pageContainer.style.width.replace('px', ''), 10) !== width ||
            parseInt(this.pageContainer.style.height.replace('px', ''), 10) !== width) {
            this.pageContainer.style.width = width.toString() + 'px';
            this.pageContainer.style.height = height.toString() + 'px';
        }
        // if (!isNullOrUndefined(this.selection) && !this.selection.isEmpty) {
        //     this.selectionContext.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
        // }
        var displayPixelRatio = Math.max(1, window.devicePixelRatio || 1);
        if (this.containerCanvas.width !== Math.floor(viewerWidth * displayPixelRatio)
            || this.containerCanvas.height !== Math.floor(viewerHeight * displayPixelRatio)) {
            this.containerCanvas.width = viewerWidth * displayPixelRatio;
            this.containerCanvas.height = viewerHeight * displayPixelRatio;
            this.containerCanvas.style.width = viewerWidth + 'px';
            this.containerCanvas.style.height = viewerHeight + 'px';
            this.containerContext.scale(displayPixelRatio, displayPixelRatio);
            this.selectionCanvas.width = viewerWidth * displayPixelRatio;
            this.selectionCanvas.height = viewerHeight * displayPixelRatio;
            this.selectionCanvas.style.width = viewerWidth + 'px';
            this.selectionCanvas.style.height = viewerHeight + 'px';
            this.selectionContext.scale(displayPixelRatio, displayPixelRatio);
        }
        this.containerContext.globalAlpha = 1;
        this.selectionContext.globalAlpha = 0.4;
        for (var i = 0; i < this.pages.length; i++) {
            var left = (width - this.pages[i].boundingRectangle.width * this.zoomFactor) / 2;
            if (left > this.pageLeft) {
                // tslint:disable-next-line:max-line-length
                this.pages[i].boundingRectangle = new Rect(left, this.pages[i].boundingRectangle.y, this.pages[i].boundingRectangle.width, this.pages[i].boundingRectangle.height);
            }
            else {
                // tslint:disable-next-line:max-line-length
                this.pages[i].boundingRectangle = new Rect(this.pageLeft, this.pages[i].boundingRectangle.y, this.pages[i].boundingRectangle.width, this.pages[i].boundingRectangle.height);
            }
        }
        this.updateScrollBarPosition(containerWidth, containerHeight, viewerWidth, viewerHeight, width, height);
        this.isScrollToSpellCheck = false;
    };
    // tslint:disable-next-line:max-line-length
    PageLayoutViewer.prototype.updateScrollBarPosition = function (containerWidth, containerHeight, viewerWidth, viewerHeight, width, height) {
        var viewerHeight1 = parseFloat(this.viewerContainer.style.height);
        var containerHeight1 = parseFloat(this.pageContainer.style.height);
        this.containerTop = this.viewerContainer.scrollTop;
        this.containerCanvas.style.position = 'absolute';
        this.containerCanvas.style.top = this.containerTop.toString() + 'px';
        this.selectionCanvas.style.position = 'absolute';
        this.selectionCanvas.style.top = this.containerTop.toString() + 'px';
        this.containerLeft = this.viewerContainer.scrollLeft;
        this.containerCanvas.style.left = this.containerLeft + 'px';
        this.selectionCanvas.style.left = this.containerLeft + 'px';
        this.updateVisiblePages();
    };
    /**
     * Updates visible pages.
     * @private
     */
    PageLayoutViewer.prototype.updateVisiblePages = function () {
        this.visiblePages = [];
        var height = this.visibleBounds.height;
        var vertical = this.viewerContainer.scrollTop;
        for (var i = 0; i < this.pages.length; i++) {
            var page = this.pages[i];
            var y = (page.boundingRectangle.y - this.pageGap * (i + 1)) * this.zoomFactor + this.pageGap * (i + 1);
            var pageH = page.boundingRectangle.height * this.zoomFactor;
            var left_1 = page.boundingRectangle.x;
            var isTopFit = y >= vertical && y <= vertical + height;
            var isBottomFit = y + pageH >= vertical && y + pageH <= vertical + height;
            var isMiddleFit = y <= vertical && y + pageH >= vertical + height;
            //UI Virtualization
            if (isTopFit || isBottomFit || isMiddleFit) {
                this.addVisiblePage(page, left_1, y);
            }
        }
    };
    /**
     * Adds visible pages.
     */
    PageLayoutViewer.prototype.addVisiblePage = function (page, x, y) {
        var _this = this;
        var width = page.boundingRectangle.width * this.zoomFactor;
        var height = page.boundingRectangle.height * this.zoomFactor;
        // tslint:disable-next-line:max-line-length
        if (this.owner.enableImageResizerMode && this.owner.imageResizerModule.currentPage !== undefined && this.owner.imageResizerModule.currentPage === page && this.owner.imageResizerModule.isImageResizerVisible) {
            this.owner.imageResizerModule.setImageResizerPositions(x, y, width, height);
        }
        this.visiblePages.push(page);
        // tslint:disable-next-line:max-line-length
        if (this.owner.enableSpellCheck && this.owner.spellChecker.enableOptimizedSpellCheck && (this.triggerElementsOnLoading || this.isScrollHandler) && this.cachedPages.indexOf(page.index) < 0) {
            page.allowNextPageRendering = false;
            this.cachedPages.push(page.index);
            var content = this.owner.spellChecker.getPageContent(page);
            if (content.trim().length > 0) {
                // tslint:disable-next-line:max-line-length
                /* tslint:disable:no-any */
                this.owner.spellChecker.CallSpellChecker(this.owner.spellChecker.languageID, content, true, false, false, true).then(function (data) {
                    /* tslint:disable:no-any */
                    var jsonObject = JSON.parse(data);
                    _this.owner.spellChecker.updateUniqueWords(jsonObject.SpellCollection);
                    page.allowNextPageRendering = true;
                    _this.triggerSpellCheck = true;
                    _this.renderPage(page, x, y, width, height);
                    _this.triggerSpellCheck = false;
                    _this.triggerElementsOnLoading = false;
                });
            }
            else {
                this.renderPage(page, x, y, width, height);
            }
        }
        else {
            this.renderPage(page, x, y, width, height);
        }
    };
    /**
     * Render specified page widgets.
     */
    PageLayoutViewer.prototype.renderPage = function (page, x, y, width, height) {
        this.render.renderWidgets(page, x - this.containerLeft, y - this.containerTop, width, height);
    };
    /**
     * Renders visible pages.
     * @private
     */
    PageLayoutViewer.prototype.renderVisiblePages = function () {
        if (isNullOrUndefined(this.visiblePages) || this.visiblePages.length < 1) {
            return;
        }
        this.clearContent();
        for (var i = 0; i < this.visiblePages.length; i++) {
            var page = this.visiblePages[i];
            var width = page.boundingRectangle.width * this.zoomFactor;
            var height = page.boundingRectangle.height * this.zoomFactor;
            var x = page.boundingRectangle.x;
            var y = (page.boundingRectangle.y - this.pageGap * (i + 1)) * this.zoomFactor + this.pageGap * (i + 1);
            this.renderPage(page, x, y, width, height);
        }
    };
    return PageLayoutViewer;
}(LayoutViewer));

/**
 * @private
 */
var SfdtReader = /** @__PURE__ @class */ (function () {
    function SfdtReader(viewer) {
        /* tslint:disable:no-any */
        this.viewer = undefined;
        this.commentStarts = undefined;
        this.commentEnds = undefined;
        this.commentsCollection = undefined;
        this.isPageBreakInsideTable = false;
        this.isParseHeader = false;
        this.viewer = viewer;
        this.editableRanges = new Dictionary();
    }
    Object.defineProperty(SfdtReader.prototype, "isPasting", {
        get: function () {
            return this.viewer && this.viewer.owner.isPastingContent;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param json
     */
    SfdtReader.prototype.convertJsonToDocument = function (json) {
        this.commentStarts = new Dictionary();
        this.commentEnds = new Dictionary();
        this.commentsCollection = new Dictionary();
        var sections = [];
        var jsonObject = json;
        jsonObject = (jsonObject instanceof Object) ? jsonObject : JSON.parse(jsonObject);
        var characterFormat = isNullOrUndefined(jsonObject.characterFormat) ?
            this.viewer.owner.characterFormat : jsonObject.characterFormat;
        this.parseCharacterFormat(characterFormat, this.viewer.characterFormat);
        var paragraphFormat = isNullOrUndefined(jsonObject.paragraphFormat) ?
            this.viewer.owner.paragraphFormat : jsonObject.paragraphFormat;
        this.parseParagraphFormat(paragraphFormat, this.viewer.paragraphFormat);
        this.parseDocumentProtection(jsonObject);
        if (!isNullOrUndefined(jsonObject.defaultTabWidth)) {
            this.viewer.defaultTabWidth = jsonObject.defaultTabWidth;
        }
        if (!isNullOrUndefined(jsonObject.background)) {
            this.viewer.backgroundColor = this.getColor(jsonObject.background.color);
        }
        if (!isNullOrUndefined(jsonObject.abstractLists)) {
            this.parseAbstractList(jsonObject, this.viewer.abstractLists);
        }
        if (!isNullOrUndefined(jsonObject.lists)) {
            this.parseList(jsonObject, this.viewer.lists);
        }
        if (!isNullOrUndefined(jsonObject.styles)) {
            this.parseStyles(jsonObject, this.viewer.styles);
        }
        if (!isNullOrUndefined(jsonObject.comments)) {
            this.parseComments(jsonObject, this.viewer.comments);
        }
        if (!isNullOrUndefined(jsonObject.sections)) {
            this.parseSections(jsonObject.sections, sections);
        }
        return sections;
    };
    SfdtReader.prototype.parseDocumentProtection = function (data) {
        if (!isNullOrUndefined(data.formatting)) {
            this.viewer.restrictFormatting = data.formatting;
        }
        if (!isNullOrUndefined(data.enforcement)) {
            this.viewer.isDocumentProtected = data.enforcement;
        }
        if (!isNullOrUndefined(data.protectionType)) {
            this.viewer.protectionType = data.protectionType;
        }
        if (!isNullOrUndefined(data.hashValue)) {
            this.viewer.hashValue = data.hashValue;
        }
        if (!isNullOrUndefined(data.saltValue)) {
            this.viewer.saltValue = data.saltValue;
        }
    };
    SfdtReader.prototype.parseStyles = function (data, styles) {
        for (var i = 0; i < data.styles.length; i++) {
            if (isNullOrUndefined(this.viewer.styles.findByName(data.styles[i].name))) {
                this.parseStyle(data, data.styles[i], styles);
            }
        }
    };
    SfdtReader.prototype.parseComments = function (data, comments) {
        var count = 0;
        for (var i = 0; i < data.comments.length; i++) {
            var commentData = data.comments[i];
            var commentElement = undefined;
            commentElement = this.parseComment(commentData, commentElement);
            while (count < commentData.replyComments.length) {
                var replyComment = undefined;
                replyComment = this.parseComment(commentData.replyComments[count], replyComment);
                replyComment.ownerComment = commentElement;
                replyComment.isReply = true;
                commentElement.replyComments.push(replyComment);
                this.commentsCollection.add(replyComment.commentId, replyComment);
                count++;
            }
            this.commentsCollection.add(commentElement.commentId, commentElement);
            comments.push(commentElement);
            count = 0;
        }
    };
    SfdtReader.prototype.parseComment = function (commentData, commentElement) {
        commentElement = new CommentElementBox(commentData.date);
        commentElement.author = commentData.author;
        commentElement.initial = commentData.initial;
        commentElement.commentId = commentData.commentId;
        commentElement.isResolved = commentData.done;
        commentElement.text = this.parseCommentText(commentData.blocks);
        return commentElement;
    };
    SfdtReader.prototype.parseCommentText = function (blocks) {
        var text = '';
        for (var i = 0; i < blocks.length; i++) {
            if (i !== 0) {
                text += '\n';
            }
            for (var j = 0; j < blocks[i].inlines.length; j++) {
                text = text + blocks[i].inlines[j].text;
            }
        }
        return text;
    };
    SfdtReader.prototype.parseStyle = function (data, style, styles) {
        var wStyle;
        if (!isNullOrUndefined(style.type)) {
            if (style.type === 'Paragraph') {
                wStyle = new WParagraphStyle();
                wStyle.type = 'Paragraph';
            }
            if (style.type === 'Character') {
                wStyle = new WCharacterStyle();
                wStyle.type = 'Character';
            }
            if (!isNullOrUndefined(style.name)) {
                wStyle.name = style.name;
            }
            styles.push(wStyle);
            if (!isNullOrUndefined(style.basedOn)) {
                var basedOn = styles.findByName(style.basedOn);
                if (!isNullOrUndefined(basedOn)) {
                    if (basedOn.type === wStyle.type) {
                        wStyle.basedOn = basedOn;
                    }
                }
                else {
                    var basedStyle = this.getStyle(style.basedOn, data);
                    var styleString = void 0;
                    if (!isNullOrUndefined(basedStyle) && basedStyle.type === wStyle.type) {
                        styleString = basedStyle;
                    }
                    else {
                        if (wStyle.type === 'Paragraph') {
                            styleString = JSON.parse('{"type":"Paragraph","name":"Normal","next":"Normal"}');
                        }
                        else {
                            styleString = JSON.parse('{"type": "Character","name": "Default Paragraph Font"}');
                        }
                    }
                    this.parseStyle(data, styleString, styles);
                    wStyle.basedOn = styles.findByName(styleString.name);
                }
            }
            if (!isNullOrUndefined(style.link)) {
                var link = styles.findByName(style.link);
                var linkStyle = this.getStyle(style.link, data);
                var styleString = void 0;
                if (isNullOrUndefined(link)) {
                    if (isNullOrUndefined(linkStyle)) {
                        //Construct the CharacterStyle string
                        var charaStyle = {};
                        charaStyle.characterFormat = style.characterFormat;
                        charaStyle.name = style.name + ' Char';
                        charaStyle.type = 'Character';
                        //TODO: Implement basedOn
                        charaStyle.basedOn = style.basedOn === 'Normal' ? 'Default Paragraph Font' : (style.basedOn + ' Char');
                        styleString = charaStyle;
                    }
                    else {
                        styleString = linkStyle;
                    }
                    this.parseStyle(data, styleString, styles);
                    wStyle.link = isNullOrUndefined(styles.findByName(styleString.name)) ? style.link : styles.findByName(styleString.name);
                }
                else {
                    wStyle.link = link;
                }
            }
            if (!isNullOrUndefined(style.characterFormat)) {
                this.parseCharacterFormat(style.characterFormat, wStyle.characterFormat);
            }
            if (!isNullOrUndefined(style.paragraphFormat)) {
                this.parseParagraphFormat(style.paragraphFormat, wStyle.paragraphFormat);
            }
            if (!isNullOrUndefined(style.next)) {
                if (style.next === style.name) {
                    wStyle.next = wStyle;
                }
                else {
                    var next = styles.findByName(style.next);
                    if (!isNullOrUndefined(next) && next.type === wStyle.type) {
                        wStyle.next = next;
                    }
                    else {
                        var nextStyleString = this.getStyle(style.next, data);
                        if (!isNullOrUndefined(nextStyleString)) {
                            this.parseStyle(data, nextStyleString, styles);
                            wStyle.next = styles.findByName(nextStyleString.name);
                        }
                        else {
                            wStyle.next = wStyle;
                        }
                    }
                }
            }
        }
    };
    SfdtReader.prototype.getStyle = function (name, data) {
        for (var i = 0; i < data.styles.length; i++) {
            if (data.styles[i].name === name) {
                return data.styles[i];
            }
        }
        return undefined;
    };
    /**
     * @private
     * @param data
     * @param abstractLists
     */
    SfdtReader.prototype.parseAbstractList = function (data, abstractLists) {
        for (var i = 0; i < data.abstractLists.length; i++) {
            var abstractList = new WAbstractList();
            var abstract = data.abstractLists[i];
            abstractLists.push(abstractList);
            if (!isNullOrUndefined(abstract)) {
                if (!isNullOrUndefined(abstract.abstractListId)) {
                    abstractList.abstractListId = abstract.abstractListId;
                }
                if (!isNullOrUndefined(abstract.levels)) {
                    for (var j = 0; j < abstract.levels.length; j++) {
                        var level = abstract.levels[j];
                        if (!isNullOrUndefined(level)) {
                            var listLevel = this.parseListLevel(level, abstractList);
                            abstractList.levels.push(listLevel);
                        }
                    }
                }
            }
        }
    };
    SfdtReader.prototype.parseListLevel = function (data, owner) {
        var listLevel = new WListLevel(owner);
        if (data.listLevelPattern === 'Bullet') {
            listLevel.listLevelPattern = 'Bullet';
            listLevel.numberFormat = !isNullOrUndefined(data.numberFormat) ? data.numberFormat : '';
        }
        else {
            listLevel.listLevelPattern = data.listLevelPattern;
            listLevel.startAt = data.startAt;
            listLevel.numberFormat = !isNullOrUndefined(data.numberFormat) ? data.numberFormat : '';
            if (data.restartLevel >= 0) {
                listLevel.restartLevel = data.restartLevel;
            }
            else {
                listLevel.restartLevel = data.levelNumber;
            }
        }
        listLevel.followCharacter = data.followCharacter;
        this.parseCharacterFormat(data.characterFormat, listLevel.characterFormat);
        this.parseParagraphFormat(data.paragraphFormat, listLevel.paragraphFormat);
        return listLevel;
    };
    /**
     * @private
     * @param data
     * @param listCollection
     */
    SfdtReader.prototype.parseList = function (data, listCollection) {
        for (var i = 0; i < data.lists.length; i++) {
            var list = new WList();
            var lists = data.lists[i];
            if (!isNullOrUndefined(lists.abstractListId)) {
                list.abstractListId = lists.abstractListId;
                list.abstractList = this.viewer.getAbstractListById(lists.abstractListId);
            }
            listCollection.push(list);
            if (!isNullOrUndefined(lists.listId)) {
                list.listId = lists.listId;
            }
            if (lists.hasOwnProperty('levelOverrides')) {
                this.parseLevelOverride(lists.levelOverrides, list);
            }
        }
    };
    SfdtReader.prototype.parseLevelOverride = function (data, list) {
        if (isNullOrUndefined(data)) {
            return;
        }
        for (var i = 0; i < data.length; i++) {
            var levelOverrides = new WLevelOverride();
            var levelOverride = data[i];
            levelOverrides.startAt = levelOverride.startAt;
            levelOverrides.levelNumber = levelOverride.levelNumber;
            if (!isNullOrUndefined(levelOverride.overrideListLevel)) {
                levelOverrides.overrideListLevel = this.parseListLevel(levelOverride.overrideListLevel, levelOverrides);
            }
            list.levelOverrides.push(levelOverrides);
        }
    };
    SfdtReader.prototype.parseSections = function (data, sections) {
        for (var i = 0; i < data.length; i++) {
            var section = new BodyWidget();
            section.sectionFormat = new WSectionFormat(section);
            section.index = i;
            var item = data[i];
            if (!isNullOrUndefined(item.sectionFormat)) {
                this.parseSectionFormat(item.sectionFormat, section.sectionFormat);
            }
            if (isNullOrUndefined(item.headersFooters)) {
                item.headersFooters = {};
            }
            this.viewer.headersFooters.push(this.parseHeaderFooter(item.headersFooters, this.viewer.headersFooters));
            this.isParseHeader = false;
            this.parseTextBody(item.blocks, section, i + 1 < data.length);
            for (var i_1 = 0; i_1 < section.childWidgets.length; i_1++) {
                section.childWidgets[i_1].containerWidget = section;
            }
            sections.push(section);
        }
    };
    /**
     * @private
     */
    SfdtReader.prototype.parseHeaderFooter = function (data, headersFooters) {
        this.isParseHeader = true;
        var hfs = {};
        if (!isNullOrUndefined(data.header)) {
            var oddHeader = new HeaderFooterWidget('OddHeader');
            hfs[0] = oddHeader;
            this.parseTextBody(data.header.blocks, oddHeader);
        }
        if (!isNullOrUndefined(data.footer)) {
            var oddFooter = new HeaderFooterWidget('OddFooter');
            hfs[1] = oddFooter;
            this.parseTextBody(data.footer.blocks, oddFooter);
        }
        if (!isNullOrUndefined(data.evenHeader)) {
            var evenHeader = new HeaderFooterWidget('EvenHeader');
            hfs[2] = evenHeader;
            this.parseTextBody(data.evenHeader.blocks, evenHeader);
        }
        if (!isNullOrUndefined(data.evenFooter)) {
            var evenFooter = new HeaderFooterWidget('EvenFooter');
            hfs[3] = evenFooter;
            this.parseTextBody(data.evenFooter.blocks, evenFooter);
        }
        if (!isNullOrUndefined(data.firstPageHeader)) {
            var firstPageHeader = new HeaderFooterWidget('FirstPageHeader');
            hfs[4] = firstPageHeader;
            this.parseTextBody(data.firstPageHeader.blocks, firstPageHeader);
        }
        if (!isNullOrUndefined(data.firstPageFooter)) {
            var firstPageFooter = new HeaderFooterWidget('FirstPageFooter');
            hfs[5] = firstPageFooter;
            this.parseTextBody(data.firstPageFooter.blocks, firstPageFooter);
        }
        return hfs;
    };
    SfdtReader.prototype.parseTextBody = function (data, section, isSectionBreak) {
        this.parseBody(data, section.childWidgets, section, isSectionBreak);
    };
    SfdtReader.prototype.addCustomStyles = function (data) {
        for (var i = 0; i < data.styles.length; i++) {
            var style = this.viewer.styles.findByName(data.styles[i].name);
            if (style === undefined) {
                this.parseStyle(data, data.styles[i], this.viewer.styles);
            }
        }
    };
    SfdtReader.prototype.parseBody = function (data, blocks, container, isSectionBreak) {
        if (!isNullOrUndefined(data)) {
            for (var i = 0; i < data.length; i++) {
                var block = data[i];
                var hasValidElmts = false;
                if (block.hasOwnProperty('inlines')) {
                    var writeInlineFormat = false;
                    //writeInlineFormat = this.isPasting && i === data.length - 1;
                    var paragraph = new ParagraphWidget();
                    paragraph.characterFormat = new WCharacterFormat(paragraph);
                    paragraph.paragraphFormat = new WParagraphFormat(paragraph);
                    if (block.inlines.length > 0) {
                        hasValidElmts = this.parseParagraph(block.inlines, paragraph, writeInlineFormat);
                    }
                    if (!(isSectionBreak && block === data[data.length - 1] && !hasValidElmts)) {
                        this.parseCharacterFormat(block.characterFormat, paragraph.characterFormat);
                        this.parseParagraphFormat(block.paragraphFormat, paragraph.paragraphFormat);
                        var styleObj = void 0;
                        if (!isNullOrUndefined(block.paragraphFormat) && !isNullOrUndefined(block.paragraphFormat.styleName)) {
                            styleObj = this.viewer.styles.findByName(block.paragraphFormat.styleName, 'Paragraph');
                            if (!isNullOrUndefined(styleObj)) {
                                paragraph.paragraphFormat.ApplyStyle(styleObj);
                            }
                        }
                        blocks.push(paragraph);
                    }
                    else if (isSectionBreak && data.length === 1) {
                        blocks.push(paragraph);
                    }
                    paragraph.index = i;
                    paragraph.containerWidget = container;
                }
                else if (block.hasOwnProperty('rows')) {
                    this.parseTable(block, blocks, i, container);
                }
            }
        }
    };
    SfdtReader.prototype.parseTable = function (block, blocks, index, section) {
        var table = new TableWidget();
        table.index = index;
        table.tableFormat = new WTableFormat(table);
        if (!isNullOrUndefined(block.tableFormat)) {
            this.parseTableFormat(block.tableFormat, table.tableFormat);
        }
        table.title = block.title;
        table.description = block.description;
        for (var i = 0; i < block.rows.length; i++) {
            var row = new TableRowWidget();
            row.rowFormat = new WRowFormat(row);
            var tableRow = block.rows[i];
            if (tableRow.hasOwnProperty('rowFormat')) {
                this.parseRowFormat(tableRow.rowFormat, row.rowFormat);
                this.parseRowGridValues(tableRow, row.rowFormat);
                this.parseRowGridValues(tableRow.rowFormat, row.rowFormat);
                row.index = i;
                for (var j = 0; j < block.rows[i].cells.length; j++) {
                    var cell = new TableCellWidget();
                    cell.cellFormat = new WCellFormat(cell);
                    row.childWidgets.push(cell);
                    cell.containerWidget = row;
                    cell.index = j;
                    cell.rowIndex = i;
                    cell.columnIndex = j;
                    if (block.rows[i].cells[j].hasOwnProperty('cellFormat')) {
                        this.parseCellFormat(block.rows[i].cells[j].cellFormat, cell.cellFormat);
                    }
                    this.isPageBreakInsideTable = true;
                    this.parseTextBody(block.rows[i].cells[j].blocks, cell, false);
                    this.isPageBreakInsideTable = false;
                }
            }
            table.childWidgets.push(row);
            row.containerWidget = table;
        }
        table.containerWidget = section;
        blocks.push(table);
        table.isGridUpdated = false;
    };
    SfdtReader.prototype.parseRowGridValues = function (data, rowFormat) {
        if (!isNullOrUndefined(data.gridBefore)) {
            rowFormat.gridBefore = data.gridBefore;
        }
        if (!isNullOrUndefined(data.gridBeforeWidth)) {
            rowFormat.gridBeforeWidth = data.gridBeforeWidth;
        }
        if (!isNullOrUndefined(data.gridBeforeWidthType)) {
            rowFormat.gridBeforeWidthType = data.gridBeforeWidthType;
        }
        if (!isNullOrUndefined(data.gridAfter)) {
            rowFormat.gridAfter = data.gridAfter;
        }
        if (!isNullOrUndefined(data.gridAfterWidth)) {
            rowFormat.gridAfterWidth = data.gridAfterWidth;
        }
        if (!isNullOrUndefined(data.gridAfterWidthType)) {
            rowFormat.gridAfterWidthType = data.gridAfterWidthType;
        }
    };
    // tslint:disable:max-func-body-length
    SfdtReader.prototype.parseParagraph = function (data, paragraph, writeInlineFormat) {
        var lineWidget = new LineWidget(paragraph);
        var hasValidElmts = false;
        for (var i = 0; i < data.length; i++) {
            var inline = data[i];
            if (inline.hasOwnProperty('text')) {
                var textElement = undefined;
                if (this.viewer.isPageField) {
                    textElement = new FieldTextElementBox();
                    textElement.fieldBegin = this.viewer.fieldStacks[this.viewer.fieldStacks.length - 1];
                }
                else if (inline.text === '\t') {
                    textElement = new TabElementBox();
                }
                else if (inline.text === '\f' && this.isPageBreakInsideTable) {
                    continue;
                }
                else {
                    textElement = new TextElementBox();
                }
                textElement.characterFormat = new WCharacterFormat(textElement);
                this.parseCharacterFormat(inline.characterFormat, textElement.characterFormat, writeInlineFormat);
                this.applyCharacterStyle(inline, textElement);
                textElement.text = inline.text;
                textElement.line = lineWidget;
                lineWidget.children.push(textElement);
                hasValidElmts = true;
            }
            else if (inline.hasOwnProperty('chartType')) {
                // chartPreservation
                var chartElement = new ChartElementBox();
                chartElement.title = inline.chartTitle;
                chartElement.type = inline.chartType;
                chartElement.chartGapWidth = inline.gapWidth;
                chartElement.chartOverlap = inline.overlap;
                this.parseChartTitleArea(inline.chartTitleArea, chartElement.chartTitleArea);
                this.parseChartArea(inline.chartArea, chartElement.chartArea);
                this.parseChartArea(inline.plotArea, chartElement.chartPlotArea);
                this.parseChartLegend(inline.chartLegend, chartElement.chartLegend);
                this.parseChartData(inline, chartElement);
                this.parseChartCategoryAxis(inline.chartPrimaryCategoryAxis, chartElement.chartPrimaryCategoryAxis);
                this.parseChartCategoryAxis(inline.chartPrimaryValueAxis, chartElement.chartPrimaryValueAxis);
                if (inline.chartDataTable != null) {
                    this.parseChartDataTable(inline.chartDataTable, chartElement.chartDataTable);
                }
                chartElement.line = lineWidget;
                lineWidget.children.push(chartElement);
                chartElement.height = HelperMethods.convertPointToPixel(inline.height);
                chartElement.width = HelperMethods.convertPointToPixel(inline.width);
                var officeChart = new ChartComponent();
                officeChart.chartRender(inline);
                chartElement.officeChart = officeChart;
                officeChart.chart.appendTo(chartElement.targetElement);
                hasValidElmts = true;
            }
            else if (inline.hasOwnProperty('imageString')) {
                var image = new ImageElementBox(data[i].isInlineImage);
                image.isMetaFile = data[i].isMetaFile;
                image.characterFormat = new WCharacterFormat(image);
                image.line = lineWidget;
                lineWidget.children.push(image);
                var imageString = HelperMethods.formatClippedString(inline.imageString).formatClippedString;
                var isValidImage = this.validateImageUrl(imageString);
                if (!isValidImage) {
                    // tslint:disable-next-line:max-line-length
                    image.imageString = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAMAAAAJbSJIAAAAgVBMVEX///8AAADgAADY2Njl5eVcXFxjY2NZWVl/f3+wsLCmpqb4+PiioqKpqam7u7vV1dX2uLj2wsLhFRXzpKT3vb30sbHhCwv74+P40dH+9vbkIyO2trbBwcHLy8tsbGycnJz529v4zMzrbGzlLS3qZmblNzfrdXXoRkbvi4vvgYHlHh7CZsBOAAADpUlEQVR4nO3da1faQBSF4ekAUQlUEFs14AXxVv7/D6yaQiZx5mSEYXF2ut+PNKzyyK5diYDmR9czx34AB49C/CjE759w3jvvWr15Tdgz3atXE54f++EcIArxoxA/CvGjED8K8aMQPwrxoxA/CvGLEeZ9jPJdhfk4GyCUjb3ECGE/Q6m/q3DwfudjP0ERZYN9hKdn2hvd3+0jHJz5/kBVuTk96bbQUEjhYR9ckiikUH8UUqg/CinUH4UU6o9CCvVHIYX6o5BC/VFIof4opFB/FFKoPwop1B+FFOqPQgrjyxfjVC38Lxk9tnAxGqZqdKtSOE4GHA5/fuNJpDCtcNHbv4VqYYqPLjgfUViPQgrjozA2CptRSGF8/59w+Wrt+rr1btNna1cPzg0wwuXavncxabnX7PfHYYXzlYARvlobQZyUR9mXm+1NMEK7SSLONgcVV9vb8IQXv4J3KSeKKlxXxNCzONkeYp8AV3p9UT1+P3FWHVAsq5thhGZSEb1DrSZq7dS5HUdoLiuBZ6jORG3tCwAkNJfCUJ2Jrqe1P0ESCkMNTdSACYNDDU7UoAkDQw1P1MAJvUMVJmrwhJ6hShM1gMIvQxUnahCFjaHKEzWQQneoxR95ogZTWBuqPFEDKnSHKk/UoArdoYoTNbDC5lBDEzW4QjMpYiZqgIXG/S76JhwHK5zVVipcnkIVuv/RW/HyFKhwYhuFr6NiCmdNoDBUSGFjovJQEYXuRN9ahwoorJ8uSZenPsMTNk+X2q6jwgm/ntHL11HhhL4zenmoYEL/Gb04VCxh6KKTNFQoYfiikzBUJKF00Sk8VCChfF00OFQcYdt10dBQYYRT5xn0n9G7Q0X8GfCzNNEyZ6iPgD/HlydaVg11DfhajJaJlm2HugIUrlomWrYZKuJKHz6vHhbSM/hROdRnxNe1meuXYvW0DB6+aflYrB7dlzDiCM3N1dVN6GDhMCDhjlHYjEIK46MwNgqbUUhhfJ/vA07wO8N1vw94ONo/3e/lTpVOYfc/UyG//ZmqW52fi/FuTNW3/lZ+eguF+qOQQv1RSKH+KKRQfxRSqD8KKdQfhRTqj0IK9UchhfqjkEL9UUih/iikUH8UUqg/CmXh6Hsv3jlK+wnvD/vgkrSHMMuyu1P9ZdmuwnycDQYn+svG3n9KEUKT9zHyf6+IEWJHIX4U4kchfhTiRyF+FOJHIX4U4kchfnVhijeZa6sunCf4ZdPamteEHY5C/CjEr/vCv0ec0g+AtS1QAAAAAElFTkSuQmCC';
                }
                else {
                    image.imageString = inline.imageString;
                }
                image.width = HelperMethods.convertPointToPixel(inline.width);
                image.height = HelperMethods.convertPointToPixel(inline.height);
                this.parseCharacterFormat(inline.characterFormat, image.characterFormat);
                hasValidElmts = true;
            }
            else if (inline.hasOwnProperty('hasFieldEnd') || (inline.hasOwnProperty('fieldType') && inline.fieldType === 0)) {
                var fieldBegin = new FieldElementBox(0);
                this.parseCharacterFormat(inline.characterFormat, fieldBegin.characterFormat, writeInlineFormat);
                this.applyCharacterStyle(inline, fieldBegin);
                fieldBegin.fieldCodeType = inline.fieldCodeType;
                fieldBegin.hasFieldEnd = inline.hasFieldEnd;
                this.viewer.fieldStacks.push(fieldBegin);
                fieldBegin.line = lineWidget;
                this.viewer.fields.push(fieldBegin);
                lineWidget.children.push(fieldBegin);
            }
            else if (inline.hasOwnProperty('fieldType')) {
                var field = undefined;
                if (inline.fieldType === 2) {
                    field = new FieldElementBox(2);
                    this.fieldSeparator = field;
                    if (this.viewer.fieldStacks.length > 0) {
                        field.fieldBegin = this.viewer.fieldStacks[this.viewer.fieldStacks.length - 1];
                        field.fieldBegin.fieldSeparator = field;
                        //finds the whether the field is page filed or not
                        var lineWidgetCount = lineWidget.children.length;
                        if (lineWidgetCount >= 2 && (lineWidget.children[lineWidgetCount - 2] instanceof FieldElementBox)
                            && lineWidget.children[lineWidgetCount - 2].hasFieldEnd
                            && (lineWidget.children[lineWidgetCount - 1] instanceof TextElementBox)) {
                            var fieldElementText = lineWidget.children[lineWidgetCount - 1].text;
                            if (fieldElementText.match('PAGE')) {
                                this.viewer.isPageField = true;
                            }
                        }
                    }
                }
                else if (inline.fieldType === 1) {
                    field = new FieldElementBox(1);
                    this.parseCharacterFormat(inline.characterFormat, field.characterFormat, writeInlineFormat);
                    this.applyCharacterStyle(inline, field);
                    //For Field End Updated begin and separator.                                      
                    if (this.viewer.fieldStacks.length > 0) {
                        field.fieldBegin = this.viewer.fieldStacks[this.viewer.fieldStacks.length - 1];
                        field.fieldBegin.fieldEnd = field;
                    }
                    if (!isNullOrUndefined(field.fieldBegin) && field.fieldBegin.fieldSeparator) {
                        field.fieldSeparator = field.fieldBegin.fieldSeparator;
                        field.fieldBegin.fieldSeparator.fieldEnd = field;
                        hasValidElmts = true;
                    }
                    //After setting all the property clear the field values
                    this.viewer.fieldStacks.splice(this.viewer.fieldStacks.length - 1, 1);
                    this.fieldSeparator = undefined;
                    this.viewer.isPageField = false;
                    this.viewer.fieldCollection.push(field.fieldBegin);
                }
                field.line = lineWidget;
                lineWidget.children.push(field);
            }
            else if (inline.hasOwnProperty('bookmarkType')) {
                var bookmark = undefined;
                bookmark = new BookmarkElementBox(inline.bookmarkType);
                bookmark.name = inline.name;
                lineWidget.children.push(bookmark);
                bookmark.line = lineWidget;
                if (!this.isParseHeader) {
                    if (inline.bookmarkType === 0) {
                        this.viewer.bookmarks.add(bookmark.name, bookmark);
                    }
                    else if (inline.bookmarkType === 1) {
                        if (this.viewer.bookmarks.containsKey(bookmark.name)) {
                            var bookmarkStart = this.viewer.bookmarks.get(bookmark.name);
                            bookmarkStart.reference = bookmark;
                            bookmark.reference = bookmarkStart;
                        }
                    }
                }
                if (bookmark.name.indexOf('_') !== 0) {
                    hasValidElmts = true;
                }
            }
            else if (inline.hasOwnProperty('editRangeId')) {
                if (inline.hasOwnProperty('editableRangeStart')) {
                    var permEnd = new EditRangeEndElementBox();
                    if (this.editableRanges.containsKey(inline.editRangeId)) {
                        var start = this.editableRanges.get(inline.editRangeId);
                        permEnd.editRangeStart = start;
                        start.editRangeEnd = permEnd;
                        this.editableRanges.remove(inline.editRangeId);
                    }
                    lineWidget.children.push(permEnd);
                    permEnd.line = lineWidget;
                }
                else {
                    var permStart = this.parseEditableRangeStart(inline);
                    lineWidget.children.push(permStart);
                    permStart.line = lineWidget;
                    if (!this.editableRanges.containsKey(inline.editRangeId)) {
                        this.editableRanges.add(inline.editRangeId, permStart);
                    }
                }
                hasValidElmts = true;
            }
            else if (inline.hasOwnProperty('commentId')) {
                var commentID = inline.commentId;
                var commentStart = undefined;
                if (this.commentStarts.containsKey(commentID)) {
                    commentStart = this.commentStarts.get(commentID);
                }
                var commentEnd = undefined;
                if (this.commentEnds.containsKey(commentID)) {
                    commentEnd = this.commentEnds.get(commentID);
                }
                if (inline.hasOwnProperty('commentCharacterType')) {
                    if (inline.commentCharacterType === 0) {
                        var commentStartElement = new CommentCharacterElementBox(0);
                        commentStartElement.commentId = commentID;
                        if (!this.commentStarts.containsKey(commentID)) {
                            this.commentStarts.add(commentID, commentStartElement);
                        }
                        commentStartElement.line = lineWidget;
                        lineWidget.children.push(commentStartElement);
                        var comment = this.commentsCollection.get(commentID);
                        if (!isNullOrUndefined(comment)) {
                            comment.commentStart = commentStartElement;
                            commentStartElement.comment = comment;
                        }
                    }
                    else {
                        var commentEndElement = new CommentCharacterElementBox(1);
                        commentEndElement.commentId = commentID;
                        if (!this.commentEnds.containsKey(commentID)) {
                            this.commentEnds.add(commentID, commentEndElement);
                        }
                        commentEndElement.line = lineWidget;
                        lineWidget.children.push(commentEndElement);
                        var comment = this.commentsCollection.get(commentID);
                        if (!isNullOrUndefined(comment)) {
                            comment.commentEnd = commentEndElement;
                            commentEndElement.comment = comment;
                        }
                    }
                }
            }
        }
        paragraph.childWidgets.push(lineWidget);
        return hasValidElmts;
    };
    SfdtReader.prototype.applyCharacterStyle = function (inline, elementbox) {
        /*tslint:disable-next-line:max-line-length */
        if (!isNullOrUndefined(inline.characterFormat) && !isNullOrUndefined(inline.characterFormat.styleName)) {
            var charStyle = this.viewer.styles.findByName(inline.characterFormat.styleName, 'Character');
            elementbox.characterFormat.ApplyStyle(charStyle);
        }
    };
    SfdtReader.prototype.parseEditableRangeStart = function (data) {
        var permStart = new EditRangeStartElementBox();
        if (!isNullOrUndefined(data.columnFirst)) {
            permStart.columnFirst = data.columnFirst;
        }
        if (!isNullOrUndefined(data.columnLast)) {
            permStart.columnLast = data.columnLast;
        }
        if (!isNullOrUndefined(data.user)) {
            permStart.user = data.user;
            if (this.viewer.userCollection.indexOf(permStart.user) === -1) {
                this.viewer.userCollection.push(permStart.user);
            }
            this.addEditRangeCollection(permStart.user, permStart);
        }
        if (!isNullOrUndefined(data.group)) {
            permStart.group = data.group;
            permStart.group = permStart.group === 'everyone' ? 'Everyone' : permStart.group;
            if (this.viewer.userCollection.indexOf(permStart.group) === -1) {
                this.viewer.userCollection.push(permStart.group);
            }
            this.addEditRangeCollection(permStart.group, permStart);
        }
        return permStart;
    };
    SfdtReader.prototype.addEditRangeCollection = function (name, permStart) {
        if (this.viewer.editRanges.containsKey(name)) {
            var editStartCollection = this.viewer.editRanges.get(name);
            editStartCollection.push(permStart);
        }
        else {
            var newEditStartCollection = [];
            newEditStartCollection.push(permStart);
            this.viewer.editRanges.add(name, newEditStartCollection);
        }
    };
    SfdtReader.prototype.parseChartTitleArea = function (titleArea, chartTitleArea) {
        chartTitleArea.chartfontName = titleArea.fontName;
        chartTitleArea.chartFontSize = titleArea.fontSize;
        this.parseChartDataFormat(titleArea.dataFormat, chartTitleArea.dataFormat);
        this.parseChartLayout(titleArea.layout, chartTitleArea.layout);
    };
    SfdtReader.prototype.parseChartDataFormat = function (format, dataFormat) {
        dataFormat.fill.color = format.fill.foreColor;
        dataFormat.fill.rgb = format.fill.rgb;
        dataFormat.line.color = format.line.color;
        dataFormat.line.rgb = format.line.rgb;
    };
    SfdtReader.prototype.parseChartLayout = function (layout, chartLayout) {
        chartLayout.chartLayoutLeft = layout.layoutX;
        chartLayout.chartLayoutTop = layout.layoutY;
    };
    SfdtReader.prototype.parseChartLegend = function (legend, chartLegend) {
        chartLegend.chartLegendPostion = legend.position;
        this.parseChartTitleArea(legend.chartTitleArea, chartLegend.chartTitleArea);
    };
    SfdtReader.prototype.parseChartCategoryAxis = function (categoryAxis, primaryAxis) {
        primaryAxis.categoryAxisType = categoryAxis.categoryType;
        primaryAxis.categoryNumberFormat = categoryAxis.numberFormat;
        primaryAxis.interval = categoryAxis.majorUnit;
        primaryAxis.axisFontSize = categoryAxis.fontSize;
        primaryAxis.axisFontName = categoryAxis.fontName;
        primaryAxis.max = categoryAxis.maximumValue;
        primaryAxis.min = categoryAxis.minimumValue;
        primaryAxis.majorGridLines = categoryAxis.hasMajorGridLines;
        primaryAxis.minorGridLines = categoryAxis.hasMinorGridLines;
        primaryAxis.majorTick = categoryAxis.majorTickMark;
        primaryAxis.minorTick = categoryAxis.minorTickMark;
        primaryAxis.tickPosition = categoryAxis.tickLabelPosition;
        primaryAxis.categoryAxisTitle = categoryAxis.chartTitle;
        if (categoryAxis.chartTitle != null) {
            this.parseChartTitleArea(categoryAxis.chartTitleArea, primaryAxis.chartTitleArea);
        }
    };
    SfdtReader.prototype.parseChartDataTable = function (dataTable, chartDataTable) {
        chartDataTable.showSeriesKeys = dataTable.showSeriesKeys;
        chartDataTable.hasHorzBorder = dataTable.hasHorzBorder;
        chartDataTable.hasVertBorder = dataTable.hasVertBorder;
        chartDataTable.hasBorders = dataTable.hasBorders;
    };
    SfdtReader.prototype.parseChartArea = function (area, chartArea) {
        chartArea.chartForeColor = area.foreColor;
    };
    SfdtReader.prototype.parseChartData = function (inline, chart) {
        for (var i = 0; i < inline.chartCategory.length; i++) {
            var chartCategory = new ChartCategory();
            var xData = inline.chartCategory[i];
            if (xData.hasOwnProperty('categoryXName')) {
                chartCategory.xName = xData.categoryXName;
            }
            for (var j = 0; j < xData.chartData.length; j++) {
                var chartData = new ChartData();
                var yData = xData.chartData[j];
                chartData.yAxisValue = yData.yValue;
                if (inline.chartType === 'Bubble') {
                    chartData.bubbleSize = yData.size;
                }
                chartCategory.chartData.push(chartData);
            }
            chart.chartCategory.push(chartCategory);
        }
        this.parseChartSeries(inline, chart);
    };
    SfdtReader.prototype.parseChartSeries = function (inline, chart) {
        var chartType = inline.chartType;
        var isPieType = (chartType === 'Pie' || chartType === 'Doughnut');
        for (var i = 0; i < inline.chartSeries.length; i++) {
            var chartSeries = new ChartSeries();
            var xData = inline.chartSeries[i];
            if (xData.hasOwnProperty('seriesName')) {
                chartSeries.seriesName = xData.seriesName;
                if (isPieType) {
                    if (xData.hasOwnProperty('firstSliceAngle')) {
                        chartSeries.firstSliceAngle = xData.firstSliceAngle;
                    }
                    if (chartType === 'Doughnut') {
                        chartSeries.doughnutHoleSize = xData.holeSize;
                    }
                }
                if (xData.hasOwnProperty('dataLabel')) {
                    this.parseChartDataLabels(xData.dataLabel, chartSeries);
                }
                if (xData.hasOwnProperty('seriesFormat')) {
                    var seriesFormat = new ChartSeriesFormat();
                    var format = xData.seriesFormat;
                    seriesFormat.markerStyle = format.markerStyle;
                    seriesFormat.markerColor = format.markerColor;
                    seriesFormat.numberValue = format.markerSize;
                    chartSeries.seriesFormat = seriesFormat;
                }
                if (xData.hasOwnProperty('errorBar')) {
                    var errorBar = chartSeries.errorBar;
                    errorBar.errorType = xData.errorBar.type;
                    errorBar.errorDirection = xData.errorBar.direction;
                    errorBar.errorEndStyle = xData.errorBar.endStyle;
                    errorBar.numberValue = xData.errorBar.numberValue;
                }
                if (xData.hasOwnProperty('trendLines')) {
                    this.parseChartTrendLines(xData.trendLines, chartSeries);
                }
                this.parseChartSeriesDataPoints(xData.dataPoints, chartSeries);
            }
            chart.chartSeries.push(chartSeries);
        }
    };
    SfdtReader.prototype.parseChartDataLabels = function (dataLabels, series) {
        var dataLabel = new ChartDataLabels();
        dataLabel.labelPosition = dataLabels.position;
        dataLabel.fontName = dataLabels.fontName;
        dataLabel.fontColor = dataLabels.fontColor;
        dataLabel.fontSize = dataLabels.fontSize;
        dataLabel.isLegendKey = dataLabels.isLegendKey;
        dataLabel.isBubbleSize = dataLabels.isBubbleSize;
        dataLabel.isCategoryName = dataLabels.isCategoryName;
        dataLabel.isSeriesName = dataLabels.isSeriesName;
        dataLabel.isValue = dataLabels.isValue;
        dataLabel.isPercentage = dataLabels.isPercentage;
        dataLabel.isLeaderLines = dataLabels.isLeaderLines;
        series.dataLabels = dataLabel;
    };
    SfdtReader.prototype.parseChartSeriesDataPoints = function (dataPoints, series) {
        for (var i = 0; i < dataPoints.length; i++) {
            var chartFormat = new ChartDataFormat();
            this.parseChartDataFormat(dataPoints[i], chartFormat);
            series.chartDataFormat.push(chartFormat);
        }
    };
    SfdtReader.prototype.parseChartTrendLines = function (trendLines, series) {
        for (var i = 0; i < trendLines.length; i++) {
            var data = trendLines[i];
            var trendLine = new ChartTrendLines();
            trendLine.trendLineName = data.name;
            trendLine.trendLineType = data.type;
            trendLine.forwardValue = data.forward;
            trendLine.backwardValue = data.backward;
            trendLine.interceptValue = data.intercept;
            trendLine.isDisplayEquation = data.isDisplayEquation;
            trendLine.isDisplayRSquared = data.isDisplayRSquared;
            series.trendLines.push(trendLine);
        }
    };
    SfdtReader.prototype.parseTableFormat = function (sourceFormat, tableFormat) {
        this.parseBorders(sourceFormat.borders, tableFormat.borders);
        if (!isNullOrUndefined(sourceFormat.allowAutoFit)) {
            tableFormat.allowAutoFit = sourceFormat.allowAutoFit;
        }
        if (!isNullOrUndefined(sourceFormat.cellSpacing)) {
            tableFormat.cellSpacing = sourceFormat.cellSpacing;
        }
        if (!isNullOrUndefined(sourceFormat.leftMargin)) {
            tableFormat.leftMargin = sourceFormat.leftMargin;
        }
        if (!isNullOrUndefined(sourceFormat.topMargin)) {
            tableFormat.topMargin = sourceFormat.topMargin;
        }
        if (!isNullOrUndefined(sourceFormat.rightMargin)) {
            tableFormat.rightMargin = sourceFormat.rightMargin;
        }
        if (!isNullOrUndefined(sourceFormat.bottomMargin)) {
            tableFormat.bottomMargin = sourceFormat.bottomMargin;
        }
        if (!isNullOrUndefined(sourceFormat.leftIndent)) {
            tableFormat.leftIndent = sourceFormat.leftIndent;
        }
        this.parseShading(sourceFormat.shading, tableFormat.shading);
        if (!isNullOrUndefined(sourceFormat.tableAlignment)) {
            tableFormat.tableAlignment = sourceFormat.tableAlignment;
        }
        if (!isNullOrUndefined(sourceFormat.preferredWidth)) {
            tableFormat.preferredWidth = sourceFormat.preferredWidth;
        }
        if (!isNullOrUndefined(sourceFormat.preferredWidthType)) {
            tableFormat.preferredWidthType = sourceFormat.preferredWidthType;
        }
        if (!isNullOrUndefined(sourceFormat.bidi)) {
            tableFormat.bidi = sourceFormat.bidi;
        }
    };
    SfdtReader.prototype.parseCellFormat = function (sourceFormat, cellFormat) {
        if (!isNullOrUndefined(sourceFormat)) {
            this.parseBorders(sourceFormat.borders, cellFormat.borders);
            if (!sourceFormat.isSamePaddingAsTable) {
                //    cellFormat.ClearMargins();
                //else
                this.parseCellMargin(sourceFormat, cellFormat);
            }
            if (!isNullOrUndefined(sourceFormat.cellWidth)) {
                cellFormat.cellWidth = sourceFormat.cellWidth;
            }
            if (!isNullOrUndefined(sourceFormat.columnSpan)) {
                cellFormat.columnSpan = sourceFormat.columnSpan;
            }
            if (!isNullOrUndefined(sourceFormat.rowSpan)) {
                cellFormat.rowSpan = sourceFormat.rowSpan;
            }
            this.parseShading(sourceFormat.shading, cellFormat.shading);
            if (!isNullOrUndefined(sourceFormat.verticalAlignment)) {
                cellFormat.verticalAlignment = sourceFormat.verticalAlignment;
            }
            if (!isNullOrUndefined(sourceFormat.preferredWidthType)) {
                cellFormat.preferredWidthType = sourceFormat.preferredWidthType;
            }
            if (!isNullOrUndefined(sourceFormat.preferredWidth)) {
                cellFormat.preferredWidth = sourceFormat.preferredWidth;
            }
        }
    };
    SfdtReader.prototype.parseCellMargin = function (sourceFormat, cellFormat) {
        if (!isNullOrUndefined(sourceFormat.leftMargin)) {
            cellFormat.leftMargin = sourceFormat.leftMargin;
        }
        if (!isNullOrUndefined(sourceFormat.rightMargin)) {
            cellFormat.rightMargin = sourceFormat.rightMargin;
        }
        if (!isNullOrUndefined(sourceFormat.topMargin)) {
            cellFormat.topMargin = sourceFormat.topMargin;
        }
        if (!isNullOrUndefined(sourceFormat.bottomMargin)) {
            cellFormat.bottomMargin = sourceFormat.bottomMargin;
        }
    };
    SfdtReader.prototype.parseRowFormat = function (sourceFormat, rowFormat) {
        if (!isNullOrUndefined(sourceFormat)) {
            if (!isNullOrUndefined(sourceFormat.allowBreakAcrossPages)) {
                rowFormat.allowBreakAcrossPages = sourceFormat.allowBreakAcrossPages;
            }
            if (!isNullOrUndefined(sourceFormat.isHeader)) {
                rowFormat.isHeader = sourceFormat.isHeader;
            }
            if (!isNullOrUndefined(sourceFormat.heightType)) {
                rowFormat.heightType = sourceFormat.heightType;
            }
            if (!isNullOrUndefined(sourceFormat.height)) {
                rowFormat.height = sourceFormat.height;
            }
            if (!isNullOrUndefined(sourceFormat.leftMargin)) {
                rowFormat.leftMargin = sourceFormat.leftMargin;
            }
            if (!isNullOrUndefined(sourceFormat.topMargin)) {
                rowFormat.topMargin = sourceFormat.topMargin;
            }
            if (!isNullOrUndefined(sourceFormat.rightMargin)) {
                rowFormat.rightMargin = sourceFormat.rightMargin;
            }
            if (!isNullOrUndefined(sourceFormat.bottomMargin)) {
                rowFormat.bottomMargin = sourceFormat.bottomMargin;
            }
            if (!isNullOrUndefined(sourceFormat.leftIndent)) {
                rowFormat.leftIndent = sourceFormat.leftIndent;
            }
            this.parseBorders(sourceFormat.borders, rowFormat.borders);
        }
    };
    SfdtReader.prototype.parseBorders = function (sourceBorders, destBorder) {
        if (!isNullOrUndefined(sourceBorders)) {
            this.parseBorder(sourceBorders.left, destBorder.left);
            this.parseBorder(sourceBorders.right, destBorder.right);
            this.parseBorder(sourceBorders.top, destBorder.top);
            this.parseBorder(sourceBorders.bottom, destBorder.bottom);
            this.parseBorder(sourceBorders.vertical, destBorder.vertical);
            this.parseBorder(sourceBorders.horizontal, destBorder.horizontal);
            this.parseBorder(sourceBorders.diagonalDown, destBorder.diagonalDown);
            this.parseBorder(sourceBorders.diagonalUp, destBorder.diagonalUp);
        }
    };
    SfdtReader.prototype.parseBorder = function (sourceBorder, destBorder) {
        if (!isNullOrUndefined(sourceBorder)) {
            if (!isNullOrUndefined(sourceBorder.color)) {
                destBorder.color = this.getColor(sourceBorder.color);
            }
            if (!isNullOrUndefined(sourceBorder.lineStyle)) {
                destBorder.lineStyle = sourceBorder.lineStyle;
            }
            if (!isNullOrUndefined(sourceBorder.lineWidth)) {
                destBorder.lineWidth = sourceBorder.lineWidth;
            }
            if (!isNullOrUndefined(sourceBorder.hasNoneStyle)) {
                destBorder.hasNoneStyle = sourceBorder.hasNoneStyle;
            }
        }
    };
    SfdtReader.prototype.parseShading = function (sourceShading, destShading) {
        if (!isNullOrUndefined(sourceShading)) {
            if (!isNullOrUndefined(sourceShading.backgroundColor)) {
                destShading.backgroundColor = this.getColor(sourceShading.backgroundColor);
            }
            if (!isNullOrUndefined(sourceShading.foregroundColor)) {
                destShading.foregroundColor = this.getColor(sourceShading.foregroundColor);
            }
            if (!isNullOrUndefined(sourceShading.texture) || !isNullOrUndefined(sourceShading.textureStyle)) {
                destShading.textureStyle = !isNullOrUndefined(sourceShading.texture) ? sourceShading.texture : sourceShading.textureStyle;
            }
        }
    };
    /**
     * @private
     */
    SfdtReader.prototype.parseCharacterFormat = function (sourceFormat, characterFormat, writeInlineFormat) {
        if (!isNullOrUndefined(sourceFormat)) {
            if (writeInlineFormat && sourceFormat.hasOwnProperty('inlineFormat')) {
                this.parseCharacterFormat(sourceFormat.inlineFormat, characterFormat);
                return;
            }
            if (!isNullOrUndefined(sourceFormat.baselineAlignment)) {
                characterFormat.baselineAlignment = sourceFormat.baselineAlignment;
            }
            if (!isNullOrUndefined(sourceFormat.underline)) {
                characterFormat.underline = sourceFormat.underline;
            }
            if (!isNullOrUndefined(sourceFormat.strikethrough)) {
                characterFormat.strikethrough = sourceFormat.strikethrough;
            }
            if (!isNullOrUndefined(sourceFormat.fontSize)) {
                characterFormat.fontSize = sourceFormat.fontSize;
            }
            if (!isNullOrUndefined(sourceFormat.fontFamily)) {
                if (sourceFormat.fontFamily.indexOf('"') !== -1) {
                    sourceFormat.fontFamily = sourceFormat.fontFamily.replace('"', '');
                }
                characterFormat.fontFamily = sourceFormat.fontFamily;
            }
            if (!isNullOrUndefined(sourceFormat.bold)) {
                characterFormat.bold = sourceFormat.bold;
            }
            if (!isNullOrUndefined(sourceFormat.italic)) {
                characterFormat.italic = sourceFormat.italic;
            }
            if (!isNullOrUndefined(sourceFormat.highlightColor)) {
                characterFormat.highlightColor = sourceFormat.highlightColor;
            }
            if (!isNullOrUndefined(sourceFormat.fontColor)) {
                characterFormat.fontColor = this.getColor(sourceFormat.fontColor);
            }
            if (!isNullOrUndefined(sourceFormat.bidi)) {
                characterFormat.bidi = sourceFormat.bidi;
            }
            if (!isNullOrUndefined(sourceFormat.bdo)) {
                characterFormat.bdo = sourceFormat.bdo;
            }
            if (!isNullOrUndefined(sourceFormat.fontSizeBidi)) {
                characterFormat.fontSizeBidi = sourceFormat.fontSizeBidi;
            }
            if (!isNullOrUndefined(sourceFormat.fontFamilyBidi)) {
                characterFormat.fontFamilyBidi = sourceFormat.fontFamilyBidi;
            }
            if (!isNullOrUndefined(sourceFormat.boldBidi)) {
                characterFormat.boldBidi = sourceFormat.boldBidi;
            }
            if (!isNullOrUndefined(sourceFormat.italicBidi)) {
                characterFormat.italicBidi = sourceFormat.italicBidi;
            }
        }
    };
    SfdtReader.prototype.getColor = function (color) {
        var convertColor = color;
        return convertColor || '#ffffff';
    };
    /**
     * @private
     */
    SfdtReader.prototype.parseParagraphFormat = function (sourceFormat, paragraphFormat) {
        if (!isNullOrUndefined(sourceFormat)) {
            if (!isNullOrUndefined(sourceFormat.bidi)) {
                paragraphFormat.bidi = sourceFormat.bidi;
            }
            if (!isNullOrUndefined(sourceFormat.leftIndent)) {
                paragraphFormat.leftIndent = sourceFormat.leftIndent;
            }
            if (!isNullOrUndefined(sourceFormat.rightIndent)) {
                paragraphFormat.rightIndent = sourceFormat.rightIndent;
            }
            if (!isNullOrUndefined(sourceFormat.firstLineIndent)) {
                paragraphFormat.firstLineIndent = sourceFormat.firstLineIndent;
            }
            if (!isNullOrUndefined(sourceFormat.afterSpacing)) {
                paragraphFormat.afterSpacing = sourceFormat.afterSpacing;
            }
            if (!isNullOrUndefined(sourceFormat.beforeSpacing)) {
                paragraphFormat.beforeSpacing = sourceFormat.beforeSpacing;
            }
            if (!isNullOrUndefined(sourceFormat.lineSpacing)) {
                paragraphFormat.lineSpacing = sourceFormat.lineSpacing;
            }
            if (!isNullOrUndefined(sourceFormat.lineSpacingType)) {
                paragraphFormat.lineSpacingType = sourceFormat.lineSpacingType;
            }
            if (!isNullOrUndefined(sourceFormat.textAlignment)) {
                paragraphFormat.textAlignment = sourceFormat.textAlignment;
            }
            if (!isNullOrUndefined(sourceFormat.outlineLevel)) {
                paragraphFormat.outlineLevel = sourceFormat.outlineLevel;
            }
            if (!isNullOrUndefined(sourceFormat.contextualSpacing)) {
                paragraphFormat.contextualSpacing = sourceFormat.contextualSpacing;
            }
            paragraphFormat.listFormat = new WListFormat();
            if (sourceFormat.hasOwnProperty('listFormat')) {
                this.parseListFormat(sourceFormat, paragraphFormat.listFormat);
            }
            if (sourceFormat.hasOwnProperty('tabs')) {
                this.parseTabStop(sourceFormat.tabs, paragraphFormat.tabs);
            }
        }
    };
    SfdtReader.prototype.parseListFormat = function (block, listFormat) {
        if (!isNullOrUndefined(block.listFormat)) {
            if (!isNullOrUndefined(block.listFormat.listId)) {
                listFormat.listId = block.listFormat.listId;
                listFormat.list = this.viewer.getListById(block.listFormat.listId);
            }
            if (!isNullOrUndefined(block.listFormat.listLevelNumber)) {
                listFormat.listLevelNumber = block.listFormat.listLevelNumber;
            }
        }
    };
    /**
     *
     * @param data @private
     * @param sectionFormat
     */
    SfdtReader.prototype.parseSectionFormat = function (data, sectionFormat) {
        if (!isNullOrUndefined(data.pageWidth)) {
            sectionFormat.pageWidth = data.pageWidth;
        }
        if (!isNullOrUndefined(data.pageHeight)) {
            sectionFormat.pageHeight = data.pageHeight;
        }
        if (!isNullOrUndefined(data.leftMargin)) {
            sectionFormat.leftMargin = data.leftMargin;
        }
        if (!isNullOrUndefined(data.topMargin)) {
            sectionFormat.topMargin = data.topMargin;
        }
        if (!isNullOrUndefined(data.rightMargin)) {
            sectionFormat.rightMargin = data.rightMargin;
        }
        if (!isNullOrUndefined(data.bottomMargin)) {
            sectionFormat.bottomMargin = data.bottomMargin;
        }
        if (!isNullOrUndefined(data.headerDistance)) {
            sectionFormat.headerDistance = data.headerDistance;
        }
        if (!isNullOrUndefined(data.footerDistance)) {
            sectionFormat.footerDistance = data.footerDistance;
        }
        if (!isNullOrUndefined(data.differentFirstPage)) {
            sectionFormat.differentFirstPage = data.differentFirstPage;
        }
        if (!isNullOrUndefined(data.differentOddAndEvenPages)) {
            sectionFormat.differentOddAndEvenPages = data.differentOddAndEvenPages;
        }
        if (!isNullOrUndefined(data.bidi)) {
            sectionFormat.bidi = data.bidi;
        }
        if (!isNullOrUndefined(data.restartPageNumbering)) {
            sectionFormat.restartPageNumbering = data.restartPageNumbering;
        }
        if (!isNullOrUndefined(data.pageStartingNumber)) {
            sectionFormat.pageStartingNumber = data.pageStartingNumber;
        }
    };
    SfdtReader.prototype.parseTabStop = function (wTabs, tabs) {
        for (var i = 0; i < wTabs.length; i++) {
            var tabStop = new WTabStop();
            tabStop.position = wTabs[i].position;
            tabStop.tabLeader = wTabs[i].tabLeader;
            tabStop.deletePosition = wTabs[i].deletePosition;
            tabStop.tabJustification = wTabs[i].tabJustification;
            tabs.push(tabStop);
        }
    };
    SfdtReader.prototype.validateImageUrl = function (imagestr) {
        var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        imagestr = imagestr.replace(/[^A-Za-z0-9\+\/\=]/g, '');
        var totalLength = imagestr.length * 3 / 4;
        if (imagestr.charAt(imagestr.length - 1) === keyStr.charAt(64)) {
            totalLength--;
        }
        if (imagestr.charAt(imagestr.length - 2) === keyStr.charAt(64)) {
            totalLength--;
        }
        if (totalLength % 1 !== 0) {
            // totalLength is not an integer, the length does not match a valid
            // base64 content. That can happen if:
            // - the imagestr is not a base64 content
            // - the imagestr is *almost* a base64 content, with a extra chars at the
            // beginning or at the end
            // - the imagestr uses a base64 variant (base64url for example)
            return false;
        }
        return true;
    };
    return SfdtReader;
}());

/**
 * Viewer Export
 */

/**
 * Selection character format implementation
 */
var SelectionCharacterFormat = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function SelectionCharacterFormat(selection) {
        this.boldIn = undefined;
        this.italicIn = undefined;
        this.underlineIn = undefined;
        this.strikeThroughIn = undefined;
        this.baselineAlignmentIn = undefined;
        this.highlightColorIn = undefined;
        this.fontSizeIn = 0;
        this.fontColorIn = undefined;
        /**
         * @private
         */
        this.boldBidi = undefined;
        /**
         * @private
         */
        this.italicBidi = undefined;
        /**
         * @private
         */
        this.fontSizeBidi = 0;
        /**
         * @private
         */
        this.bidi = undefined;
        /**
         * @private
         */
        this.bdo = undefined;
        this.selection = selection;
    }
    Object.defineProperty(SelectionCharacterFormat.prototype, "fontSize", {
        /**
         * Gets the font size of selected contents.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.fontSizeIn;
        },
        /**
         * Sets the font size of selected contents.
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.fontSizeIn) {
                return;
            }
            this.fontSizeIn = value;
            this.notifyPropertyChanged('fontSize');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCharacterFormat.prototype, "fontFamily", {
        /**
         * Gets or sets the font family of selected contents.
         * @aspType string
         * @blazorType string
         */
        get: function () {
            return this.fontFamilyIn;
        },
        /**
         * Sets the font family of selected contents.
         * @aspType string
         * @blazorType string
         */
        set: function (value) {
            if (value === this.fontFamilyIn) {
                return;
            }
            this.fontFamilyIn = value;
            this.notifyPropertyChanged('fontFamily');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCharacterFormat.prototype, "fontColor", {
        /**
         * Gets or sets the font color of selected contents.
         * @aspType string
         * @blazorType string
         */
        get: function () {
            return this.fontColorIn;
        },
        /**
         * Sets the font color of selected contents.
         * @aspType string
         * @blazorType string
         */
        set: function (value) {
            if (value === this.fontColorIn) {
                return;
            }
            this.fontColorIn = value;
            this.notifyPropertyChanged('fontColor');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCharacterFormat.prototype, "bold", {
        /**
         * Gets or sets the bold formatting of selected contents.
         * @aspType bool
         * @blazorType bool
         */
        get: function () {
            return this.boldIn;
        },
        /**
         * Sets the bold formatting of selected contents.
         * @aspType bool
         * @blazorType bool
         */
        set: function (value) {
            if (value === this.boldIn) {
                return;
            }
            this.boldIn = value;
            this.notifyPropertyChanged('bold');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCharacterFormat.prototype, "italic", {
        /**
         * Gets or sets the italic formatting of selected contents.
         * @aspType bool
         * @blazorType bool
         */
        get: function () {
            return this.italicIn;
        },
        /**
         * Sets the italic formatting of selected contents.
         * @aspType bool
         * @blazorType bool
         */
        set: function (value) {
            if (value === this.italic) {
                return;
            }
            this.italicIn = value;
            this.notifyPropertyChanged('italic');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCharacterFormat.prototype, "strikethrough", {
        /**
         * Gets or sets the strikethrough property of selected contents.
         */
        get: function () {
            return this.strikeThroughIn;
        },
        /**
         * Sets the strikethrough property of selected contents.
         */
        set: function (value) {
            if (value === this.strikeThroughIn) {
                return;
            }
            this.strikeThroughIn = value;
            this.notifyPropertyChanged('strikethrough');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCharacterFormat.prototype, "baselineAlignment", {
        /**
         * Gets or sets the baseline alignment property of selected contents.
         */
        get: function () {
            return this.baselineAlignmentIn;
        },
        /**
         * Sets the baseline alignment property of selected contents.
         */
        set: function (value) {
            if (value === this.baselineAlignmentIn) {
                return;
            }
            this.baselineAlignmentIn = value;
            this.notifyPropertyChanged('baselineAlignment');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCharacterFormat.prototype, "underline", {
        /**
         * Gets or sets the underline style of selected contents.
         */
        get: function () {
            return this.underlineIn;
        },
        /**
         * Sets the underline style of selected contents.
         */
        set: function (value) {
            if (value === this.underlineIn) {
                return;
            }
            this.underlineIn = value;
            this.notifyPropertyChanged('underline');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCharacterFormat.prototype, "highlightColor", {
        /**
         * Gets or sets the highlight color of selected contents.
         */
        get: function () {
            return this.highlightColorIn;
        },
        /**
         * Sets the highlight color of selected contents.
         */
        set: function (value) {
            if (value === this.highlightColorIn) {
                return;
            }
            this.highlightColorIn = value;
            this.notifyPropertyChanged('highlightColor');
        },
        enumerable: true,
        configurable: true
    });
    SelectionCharacterFormat.prototype.getPropertyValue = function (property) {
        switch (property) {
            case 'bold':
                return this.bold;
            case 'italic':
                return this.italic;
            case 'fontSize':
                if (this.fontSize >= 1) {
                    return this.fontSize;
                }
                return undefined;
            case 'fontFamily':
                return this.fontFamily;
            case 'strikethrough':
                return this.strikethrough;
            case 'baselineAlignment':
                return this.baselineAlignment;
            case 'highlightColor':
                return this.highlightColor;
            case 'underline':
                return this.underline;
            case 'fontColor':
                return this.fontColor;
            default:
                return undefined;
        }
    };
    /**
     * Notifies whenever property gets changed.
     * @param  {string} propertyName
     */
    SelectionCharacterFormat.prototype.notifyPropertyChanged = function (propertyName) {
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(this.selection) && (this.selection.isCleared || this.selection.owner.isReadOnlyMode || !this.selection.owner.isDocumentLoaded || this.selection.owner.isPastingContent) && !this.selection.isRetrieveFormatting) {
            return;
        }
        if (!isNullOrUndefined(this.selection) && !isNullOrUndefined(this.selection.start) && !this.selection.isRetrieveFormatting) {
            var propertyValue = this.getPropertyValue(propertyName);
            if (!isNullOrUndefined(propertyValue)) {
                this.selection.owner.editorModule.onApplyCharacterFormat(propertyName, propertyValue);
            }
        }
    };
    /**
     * Copies the source format.
     * @param  {WCharacterFormat} format
     * @returns void
     * @private
     */
    SelectionCharacterFormat.prototype.copyFormat = function (format) {
        this.styleName = !isNullOrUndefined(format.baseCharStyle) ? format.baseCharStyle.name : 'Default Paragraph Font';
        this.fontSize = format.fontSize;
        this.fontFamily = format.fontFamily;
        this.bold = format.bold;
        this.italic = format.italic;
        this.baselineAlignment = format.baselineAlignment;
        this.underline = format.underline;
        this.fontColor = format.fontColor;
        this.highlightColor = format.highlightColor;
        this.strikethrough = format.strikethrough;
        this.bidi = format.bidi;
        this.bdo = format.bdo;
        this.boldBidi = format.boldBidi;
        this.italicBidi = format.italicBidi;
        this.fontFamilyBidi = format.fontFamilyBidi;
        this.fontSizeBidi = format.fontSizeBidi;
    };
    /**
     * Combines the format.
     * @param  {WCharacterFormat} format
     * @private
     */
    SelectionCharacterFormat.prototype.combineFormat = function (format) {
        if (!isNullOrUndefined(this.bold) && this.bold !== format.bold) {
            this.bold = undefined;
        }
        if (!isNullOrUndefined(this.italic) && this.italic !== format.italic) {
            this.italic = undefined;
        }
        if (this.fontSize !== 0 && this.fontSize !== format.fontSize) {
            this.fontSize = 0;
        }
        if (!isNullOrUndefined(this.fontFamily) && this.fontFamily !== format.fontFamily) {
            this.fontFamily = undefined;
        }
        if (!isNullOrUndefined(this.highlightColor) && this.highlightColor !== format.highlightColor) {
            this.highlightColor = undefined;
        }
        if (!isNullOrUndefined(this.baselineAlignment) && this.baselineAlignment !== format.baselineAlignment) {
            this.baselineAlignment = undefined;
        }
        if (!isNullOrUndefined(this.fontColor) && (this.fontColor !== format.fontColor)) {
            this.fontColor = undefined;
        }
        if (!isNullOrUndefined(this.underline) && this.underline !== format.underline) {
            this.underline = undefined;
        }
        if (!isNullOrUndefined(this.strikethrough) && this.strikethrough !== format.strikethrough) {
            this.strikethrough = undefined;
        }
        if (!isNullOrUndefined(this.boldBidi) && this.boldBidi !== format.boldBidi) {
            this.boldBidi = undefined;
        }
        if (!isNullOrUndefined(this.italicBidi) && this.italicBidi !== format.italicBidi) {
            this.italicBidi = undefined;
        }
        if (this.fontSizeBidi !== 0 && this.fontSizeBidi !== format.fontSizeBidi) {
            this.fontSizeBidi = 0;
        }
        if (!isNullOrUndefined(this.fontFamilyBidi) && this.fontFamilyBidi !== format.fontFamilyBidi) {
            this.fontFamilyBidi = undefined;
        }
        if (!isNullOrUndefined(this.bidi) && this.bidi !== format.bidi) {
            this.bidi = undefined;
        }
        if (!isNullOrUndefined(this.bdo) && this.bdo !== format.bdo) {
            this.bdo = undefined;
        }
    };
    /**
     * Clones the format.
     * @param  {SelectionCharacterFormat} selectionCharacterFormat
     * @returns void
     * @private
     */
    SelectionCharacterFormat.prototype.cloneFormat = function (selectionCharacterFormat) {
        this.bold = selectionCharacterFormat.bold;
        this.italic = selectionCharacterFormat.italic;
        this.underline = selectionCharacterFormat.underline;
        this.strikethrough = selectionCharacterFormat.strikethrough;
        this.baselineAlignment = selectionCharacterFormat.baselineAlignment;
        this.highlightColor = selectionCharacterFormat.highlightColor;
        this.fontSize = selectionCharacterFormat.fontSize;
        this.fontFamily = selectionCharacterFormat.fontFamily;
        this.fontColor = selectionCharacterFormat.fontColor;
        this.styleName = selectionCharacterFormat.styleName;
        this.bidi = selectionCharacterFormat.bidi;
        this.bdo = selectionCharacterFormat.bdo;
        this.boldBidi = selectionCharacterFormat.boldBidi;
        this.italicBidi = selectionCharacterFormat.italicBidi;
        this.fontSizeBidi = selectionCharacterFormat.fontSizeBidi;
        this.fontFamilyBidi = selectionCharacterFormat.fontFamilyBidi;
    };
    /**
     * Checks whether current format is equal to the source format or not.
     * @param  {SelectionCharacterFormat} format
     * @returns boolean
     * @private
     */
    SelectionCharacterFormat.prototype.isEqualFormat = function (format) {
        return (this.fontSize === format.fontSize
            && this.strikethrough === format.strikethrough
            && this.bold === format.bold
            && this.fontFamily === format.fontFamily
            && this.underline === format.underline
            && this.highlightColor === format.highlightColor
            && this.italic === format.italic
            && this.baselineAlignment === format.baselineAlignment
            && this.fontColor === format.fontColor);
    };
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    SelectionCharacterFormat.prototype.clearFormat = function () {
        this.fontSizeIn = 0;
        this.boldIn = undefined;
        this.italicIn = undefined;
        this.fontFamilyIn = undefined;
        this.fontColorIn = undefined;
        this.underlineIn = undefined;
        this.strikeThroughIn = undefined;
        this.highlightColorIn = undefined;
        this.baselineAlignmentIn = undefined;
        this.styleName = undefined;
        this.bidi = undefined;
        this.bdo = undefined;
        this.boldBidi = undefined;
        this.italicBidi = undefined;
        this.fontFamilyBidi = undefined;
        this.fontSizeBidi = undefined;
    };
    /**
     * Destroys the maintained resources.
     * @returns void
     * @private
     */
    SelectionCharacterFormat.prototype.destroy = function () {
        this.fontSizeIn = undefined;
        this.boldIn = undefined;
        this.italicIn = undefined;
        this.fontFamilyIn = undefined;
        this.fontColorIn = undefined;
        this.underlineIn = undefined;
        this.strikeThroughIn = undefined;
        this.baselineAlignmentIn = undefined;
        this.highlightColorIn = undefined;
        this.selection = undefined;
        this.styleName = undefined;
        this.bidi = undefined;
        this.bdo = undefined;
        this.boldBidi = undefined;
        this.italicBidi = undefined;
        this.fontFamilyBidi = undefined;
        this.fontSizeBidi = undefined;
    };
    return SelectionCharacterFormat;
}());
/**
 * Selection paragraph format implementation
 */
var SelectionParagraphFormat = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function SelectionParagraphFormat(selection, viewer) {
        // Declaring the character format properties.
        this.leftIndentIn = 0;
        this.rightIndentIn = 0;
        this.beforeSpacingIn = 0;
        this.afterSpacingIn = 0;
        this.textAlignmentIn = undefined;
        this.firstLineIndentIn = 0;
        this.lineSpacingIn = 1;
        this.lineSpacingTypeIn = undefined;
        this.bidiIn = undefined;
        this.contextualSpacingIn = undefined;
        this.listLevelNumberIn = -1;
        this.selection = selection;
        this.viewer = viewer;
    }
    Object.defineProperty(SelectionParagraphFormat.prototype, "leftIndent", {
        /**
         * Gets or Sets the left indent for selected paragraphs.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.leftIndentIn;
        },
        /**
         * Sets the left indent for selected paragraphs.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.leftIndentIn) {
                return;
            }
            this.leftIndentIn = value;
            this.notifyPropertyChanged('leftIndent');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionParagraphFormat.prototype, "rightIndent", {
        /**
         * Gets or Sets the right indent for selected paragraphs.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.rightIndentIn;
        },
        /**
         * Sets the right indent for selected paragraphs.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.rightIndentIn) {
                return;
            }
            this.rightIndentIn = value;
            this.notifyPropertyChanged('rightIndent');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionParagraphFormat.prototype, "firstLineIndent", {
        /**
         * Gets or Sets the first line indent for selected paragraphs.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.firstLineIndentIn;
        },
        /**
         * Sets the first line indent for selected paragraphs.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.firstLineIndentIn) {
                return;
            }
            this.firstLineIndentIn = value;
            this.notifyPropertyChanged('firstLineIndent');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionParagraphFormat.prototype, "textAlignment", {
        /**
         * Gets or Sets the text alignment for selected paragraphs.
         * @default undefined
         */
        get: function () {
            return this.textAlignmentIn;
        },
        /**
         * Sets the text alignment for selected paragraphs.
         * @default undefined
         */
        set: function (value) {
            if (value === this.textAlignmentIn) {
                return;
            }
            this.textAlignmentIn = value;
            this.notifyPropertyChanged('textAlignment');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionParagraphFormat.prototype, "afterSpacing", {
        /**
         * Sets the after spacing for selected paragraphs.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.afterSpacingIn;
        },
        /**
         * Gets or Sets the after spacing for selected paragraphs.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.afterSpacingIn) {
                return;
            }
            this.afterSpacingIn = value;
            this.notifyPropertyChanged('afterSpacing');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionParagraphFormat.prototype, "beforeSpacing", {
        /**
         * Gets or Sets the before spacing for selected paragraphs.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.beforeSpacingIn;
        },
        /**
         * Sets the before spacing for selected paragraphs.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.beforeSpacingIn) {
                return;
            }
            this.beforeSpacingIn = value;
            this.notifyPropertyChanged('beforeSpacing');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionParagraphFormat.prototype, "lineSpacing", {
        /**
         * Gets or Sets the line spacing for selected paragraphs.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.lineSpacingIn;
        },
        /**
         * Sets the line spacing for selected paragraphs.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.lineSpacingIn) {
                return;
            }
            this.lineSpacingIn = value;
            this.notifyPropertyChanged('lineSpacing');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionParagraphFormat.prototype, "lineSpacingType", {
        /**
         * Gets or Sets the line spacing type for selected paragraphs.
         * @default undefined
         */
        get: function () {
            return this.lineSpacingTypeIn;
        },
        /**
         * Gets or Sets the line spacing type for selected paragraphs.
         * @default undefined
         */
        set: function (value) {
            if (value === this.lineSpacingTypeIn) {
                return;
            }
            this.lineSpacingTypeIn = value;
            this.notifyPropertyChanged('lineSpacingType');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionParagraphFormat.prototype, "listLevelNumber", {
        /**
         * Sets the list level number for selected paragraphs.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.listLevelNumberIn;
        },
        /**
         * Gets or Sets the list level number for selected paragraphs.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.listLevelNumberIn) {
                return;
            }
            this.listLevelNumberIn = value;
            this.notifyPropertyChanged('listLevelNumber');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionParagraphFormat.prototype, "bidi", {
        /**
         * Gets or Sets the bidirectional property for selected paragraphs
         * @aspType bool
         * @blazorType bool
         */
        get: function () {
            return this.bidiIn;
        },
        /**
         * Sets the bidirectional property for selected paragraphs
         * @aspType bool
         * @blazorType bool
         */
        set: function (value) {
            this.bidiIn = value;
            this.notifyPropertyChanged('bidi');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionParagraphFormat.prototype, "contextualSpacing", {
        /**
         * Gets or sets a value indicating whether to add space between the paragraphs of same style.
         * @aspType bool
         * @blazorType bool
         */
        get: function () {
            return this.contextualSpacingIn;
        },
        /**
         * Sets a value indicating whether to add space between the paragraphs of same style.
         * @aspType bool
         * @blazorType bool
         */
        set: function (value) {
            this.contextualSpacingIn = value;
            this.notifyPropertyChanged('contextualSpacing');
        },
        enumerable: true,
        configurable: true
    });
    SelectionParagraphFormat.prototype.validateLineSpacing = function () {
        if (this.lineSpacingType !== 'Multiple' && this.lineSpacingIn < 12) {
            return true;
        }
        return false;
    };
    Object.defineProperty(SelectionParagraphFormat.prototype, "listText", {
        /**
         * Gets the list text for selected paragraphs.
         * @aspType string
         * @blazorType string
         */
        get: function () {
            var listFormat = undefined;
            var list = this.viewer.getListById(this.listId);
            if (list instanceof WList && this.listLevelNumberIn > -1 && this.listLevelNumberIn < 9) {
                var listLevel = list.getListLevel(this.listLevelNumber);
                if (listLevel instanceof WListLevel) {
                    if (listLevel.listLevelPattern === 'Bullet') {
                        listFormat = listLevel.numberFormat;
                    }
                    else {
                        listFormat = listLevel.numberFormat;
                        for (var i = 0; i < 9; i++) {
                            var levelPattern = '%' + (i + 1);
                            if (listFormat.indexOf(levelPattern) > -1) {
                                var level = i === this.listLevelNumberIn ? listLevel : list.getListLevel(i);
                                var listTextElement = this.selection.getListTextElementBox(this.selection.start.paragraph);
                                var listText = listTextElement ? listTextElement.text : '';
                                listFormat = listText;
                            }
                        }
                    }
                }
            }
            return listFormat;
        },
        enumerable: true,
        configurable: true
    });
    SelectionParagraphFormat.prototype.getPropertyValue = function (property) {
        switch (property) {
            case 'leftIndent':
                return this.leftIndent;
            case 'rightIndent':
                return this.rightIndent;
            case 'firstLineIndent':
                return this.firstLineIndent;
            case 'beforeSpacing':
                return this.beforeSpacing;
            case 'afterSpacing':
                return this.afterSpacing;
            case 'textAlignment':
                return this.textAlignment;
            case 'lineSpacing':
                return this.lineSpacing;
            case 'lineSpacingType':
                return this.lineSpacingType;
            case 'bidi':
                return this.bidi;
            case 'contextualSpacing':
                return this.contextualSpacing;
            default:
                return undefined;
        }
    };
    /**
     * Notifies whenever the property gets changed.
     * @param  {string} propertyName
     */
    SelectionParagraphFormat.prototype.notifyPropertyChanged = function (propertyName) {
        if (!isNullOrUndefined(this.selection) &&
            (this.selection.owner.isReadOnlyMode || !this.selection.owner.isDocumentLoaded)
            && !this.selection.isRetrieveFormatting) {
            return;
        }
        if (!isNullOrUndefined(this.selection) && !isNullOrUndefined(this.selection.start) && !this.selection.isRetrieveFormatting) {
            var editorModule = this.selection.owner.editorModule;
            if (propertyName === 'lineSpacing' || propertyName === 'lineSpacingType') {
                var editorHistory = this.selection.owner.editorHistory;
                if (!(editorHistory && (editorHistory.isUndoing || editorHistory.isRedoing)) && this.validateLineSpacing()) {
                    this.selection.owner.editorHistory.initComplexHistory(this.selection, 'LineSpacing');
                    if (propertyName === 'lineSpacing') {
                        this.lineSpacingTypeIn = 'Multiple';
                        var value_1 = this.getPropertyValue('lineSpacingType');
                        editorModule.onApplyParagraphFormat('lineSpacingType', value_1, false, false);
                        editorModule.onApplyParagraphFormat(propertyName, this.getPropertyValue(propertyName), false, false);
                    }
                    else {
                        editorModule.onApplyParagraphFormat(propertyName, this.getPropertyValue(propertyName), false, false);
                        this.lineSpacingIn = 12;
                        editorModule.onApplyParagraphFormat('lineSpacing', this.getPropertyValue('lineSpacing'), false, false);
                    }
                    this.selection.owner.editorHistory.updateComplexHistory();
                    return;
                }
            }
            var value = this.getPropertyValue(propertyName);
            if ((propertyName === 'leftIndent' || propertyName === 'rightIndent' || propertyName === 'firstLineIndent')
                && !(value >= -1056 && value < 1056)) {
                return;
            }
            if (propertyName === 'listLevelNumber') {
                editorModule.onApplyListInternal(this.viewer.getListById(this.listId), this.listLevelNumber);
            }
            else {
                editorModule.onApplyParagraphFormat(propertyName, value, propertyName === 'textAlignment' ? true : false, false);
            }
        }
    };
    /**
     * Copies the format.
     * @param  {WParagraphFormat} format
     * @returns void
     * @private
     */
    SelectionParagraphFormat.prototype.copyFormat = function (format) {
        this.styleName = !isNullOrUndefined(format.baseStyle) ? format.baseStyle.name : 'Normal';
        this.leftIndent = format.leftIndent;
        this.rightIndent = format.rightIndent;
        this.firstLineIndent = format.firstLineIndent;
        this.afterSpacing = format.afterSpacing;
        this.beforeSpacing = format.beforeSpacing;
        this.lineSpacing = format.lineSpacing;
        this.lineSpacingType = format.lineSpacingType;
        this.textAlignment = format.textAlignment;
        this.bidi = format.bidi;
        this.contextualSpacing = format.contextualSpacing;
        if (!isNullOrUndefined(format.listFormat) && !isNullOrUndefined(format.listFormat.listId)) {
            this.listId = format.listFormat.listId;
            this.listLevelNumber = format.listFormat.listLevelNumber;
        }
        else {
            this.listId = undefined;
            this.listLevelNumber = 0;
        }
    };
    /**
     * Copies to format.
     * @param  {WParagraphFormat} format
     * @private
     */
    SelectionParagraphFormat.prototype.copyToFormat = function (format) {
        if (isNullOrUndefined(format)) {
            return;
        }
        if (!isNullOrUndefined(this.afterSpacing)) {
            format.afterSpacing = this.afterSpacing;
        }
        if (!isNullOrUndefined(this.beforeSpacing)) {
            format.beforeSpacing = this.beforeSpacing;
        }
        if (!isNullOrUndefined(this.leftIndent)) {
            format.leftIndent = this.leftIndent;
        }
        if (!isNullOrUndefined(this.rightIndent)) {
            format.rightIndent = this.rightIndent;
        }
        if (!isNullOrUndefined(this.textAlignment)) {
            format.textAlignment = this.textAlignment;
        }
        if (!isNullOrUndefined(this.lineSpacing)) {
            format.lineSpacing = this.lineSpacing;
        }
        if (!isNullOrUndefined(this.lineSpacingType)) {
            format.lineSpacingType = this.lineSpacingType;
        }
        if (!isNullOrUndefined(this.firstLineIndent)) {
            format.firstLineIndent = this.firstLineIndent;
        }
        if (!isNullOrUndefined(this.bidi)) {
            format.bidi = this.bidi;
        }
        if (!isNullOrUndefined(this.contextualSpacing)) {
            format.contextualSpacing = this.contextualSpacing;
        }
    };
    /**
     * Combines the format.
     * @param  {WParagraphFormat} format
     * @private
     */
    SelectionParagraphFormat.prototype.combineFormat = function (format) {
        if (!isNullOrUndefined(this.leftIndent) && this.leftIndent !== format.leftIndent) {
            this.leftIndent = undefined;
        }
        if (!isNullOrUndefined(this.rightIndent) && this.rightIndent !== format.rightIndent) {
            this.rightIndent = undefined;
        }
        if (!isNullOrUndefined(this.firstLineIndent) && this.firstLineIndent !== format.firstLineIndent) {
            this.firstLineIndent = undefined;
        }
        if (this.lineSpacing !== 0 && this.lineSpacing !== format.lineSpacing) {
            this.lineSpacing = 0;
        }
        if (this.beforeSpacing !== -1 && this.beforeSpacing !== format.beforeSpacing) {
            this.beforeSpacing = -1;
        }
        if (this.afterSpacing !== -1 && this.afterSpacing !== format.afterSpacing) {
            this.afterSpacing = -1;
        }
        if (!isNullOrUndefined(this.lineSpacingType) && this.lineSpacingType !== format.lineSpacingType) {
            this.lineSpacingType = undefined;
        }
        if (!isNullOrUndefined(this.textAlignment) && this.textAlignment !== format.textAlignment) {
            this.textAlignment = undefined;
        }
        // tslint:disable-next-line:max-line-length
        if (this.listLevelNumber >= 0 && !isNullOrUndefined(this.listId) && (isNullOrUndefined(format.listFormat) || format.listFormat.listLevelNumber !== this.listLevelNumber)) {
            this.listLevelNumber = -1;
        }
        // tslint:disable-next-line:max-line-length
        if (isNullOrUndefined(format.listFormat) || isNullOrUndefined(format.listFormat.listId) || (!isNullOrUndefined(this.listId) && this.listId !== format.listFormat.listId)) {
            this.listId = undefined;
        }
        if (!isNullOrUndefined(this.bidi) && this.bidi !== format.bidi) {
            this.bidi = undefined;
        }
        if (!isNullOrUndefined(this.contextualSpacing) && this.contextualSpacing !== format.contextualSpacing) {
            this.contextualSpacing = undefined;
        }
    };
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    SelectionParagraphFormat.prototype.clearFormat = function () {
        this.leftIndent = 0;
        this.rightIndent = 0;
        this.beforeSpacing = 0;
        this.afterSpacing = 0;
        this.firstLineIndent = 0;
        this.lineSpacing = 1;
        this.textAlignment = undefined;
        this.lineSpacingType = undefined;
        this.listId = undefined;
        this.listLevelNumber = -1;
        this.styleName = undefined;
        this.bidi = undefined;
        this.contextualSpacing = undefined;
    };
    /**
     * Gets the clone of list at current selection.
     * @returns WList
     * @private
     */
    SelectionParagraphFormat.prototype.getList = function () {
        var list = this.viewer.getListById(this.listId);
        if (!isNullOrUndefined(list)) {
            var listAdv = new WList();
            var abstractList = new WAbstractList();
            var currentAbstractList = this.viewer.getAbstractListById(list.abstractListId);
            var editor = this.selection.owner.editorModule;
            if (!isNullOrUndefined(currentAbstractList)) {
                for (var i = 0; i < currentAbstractList.levels.length; i++) {
                    var level = editor.cloneListLevel(currentAbstractList.levels[i]);
                    abstractList.levels.push(level);
                    level.ownerBase = abstractList;
                }
            }
            else {
                abstractList.levels.push(new WListLevel(abstractList));
            }
            if (!isNullOrUndefined(list.levelOverrides)) {
                for (var i = 0; i < list.levelOverrides.length; i++) {
                    var levelOverride = editor.cloneLevelOverride(list.levelOverrides[i]);
                    listAdv.levelOverrides.push(levelOverride);
                }
            }
            listAdv.abstractList = abstractList;
            listAdv.abstractListId = abstractList.abstractListId;
            listAdv.sourceListId = list.listId;
            return listAdv;
        }
        return undefined;
    };
    /**
     * Modifies the list at current selection.
     * @param  {WList} listAdv
     * @private
     */
    SelectionParagraphFormat.prototype.setList = function (listAdv) {
        if (this.viewer.owner.isReadOnlyMode || !this.viewer.owner.isDocumentLoaded) {
            return;
        }
        var list = this.viewer.getListById(this.listId);
        var collection = undefined;
        var currentAbstractList = listAdv ? this.viewer.getAbstractListById(listAdv.abstractListId) : undefined;
        if (!isNullOrUndefined(list) && !isNullOrUndefined(listAdv)
            && !isNullOrUndefined(currentAbstractList) && listAdv.sourceListId === list.listId) {
            var history_1 = this.viewer.owner.editorHistory;
            var listLevel = this.viewer.layout.getListLevel(list, 1);
            this.selection.owner.isLayoutEnabled = false;
            this.viewer.owner.editorModule.setOffsetValue(this.selection);
            if (history_1) {
                collection = history_1.updateListChangesInHistory(currentAbstractList, list);
            }
            this.viewer.owner.editorModule.updateListParagraphs();
            if (history_1) {
                history_1.applyListChanges(this.selection, collection);
            }
            this.selection.owner.isLayoutEnabled = true;
            this.viewer.renderedLists.clear();
            this.viewer.renderedLevelOverrides = [];
            // this.viewer.pages = [];
            this.viewer.owner.editorModule.layoutWholeDocument();
            this.viewer.owner.editorModule.updateSelectionTextPosition(false);
            if (history_1 && history_1.currentBaseHistoryInfo) {
                if (history_1.currentBaseHistoryInfo.modifiedProperties.length > 0) {
                    history_1.currentBaseHistoryInfo.updateSelection();
                }
                history_1.updateHistory();
            }
            this.viewer.owner.editorModule.fireContentChange();
        }
        else if (!isNullOrUndefined(listAdv)) {
            this.selection.owner.isLayoutEnabled = false;
            if (!isNullOrUndefined(currentAbstractList) && this.viewer.abstractLists.indexOf(currentAbstractList) === -1) {
                this.viewer.abstractLists.push(currentAbstractList);
            }
            if (this.viewer.lists.indexOf(listAdv) === -1) {
                this.viewer.lists.push(listAdv);
            }
            //currentAbstractList.listType = 'Numbering';
            this.selection.owner.isLayoutEnabled = true;
            this.selection.owner.editorModule.onApplyList(listAdv);
        }
        else {
            this.selection.owner.editorModule.onApplyList(undefined);
        }
    };
    /**
     * Destroys the managed resources.
     * @returns void
     * @private
     */
    SelectionParagraphFormat.prototype.destroy = function () {
        this.leftIndentIn = undefined;
        this.rightIndentIn = undefined;
        this.beforeSpacingIn = undefined;
        this.afterSpacingIn = undefined;
        this.firstLineIndentIn = undefined;
        this.lineSpacingIn = undefined;
        this.textAlignmentIn = undefined;
        this.lineSpacingTypeIn = undefined;
        this.listId = undefined;
        this.listLevelNumberIn = undefined;
        this.viewer = undefined;
        this.selection = undefined;
        this.styleName = undefined;
        this.bidi = undefined;
        this.contextualSpacing = undefined;
    };
    return SelectionParagraphFormat;
}());
/**
 * Selection section format implementation
 */
var SelectionSectionFormat = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function SelectionSectionFormat(selection) {
        this.differentFirstPageIn = undefined;
        this.differentOddAndEvenPagesIn = undefined;
        /**
         * private
         */
        this.bidi = undefined;
        this.selection = selection;
    }
    Object.defineProperty(SelectionSectionFormat.prototype, "pageHeight", {
        /**
         * Gets or sets the page height.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.pageHeightIn;
        },
        /**
         * Gets or sets the page height.
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            this.pageHeightIn = value;
            this.notifyPropertyChanged('pageHeight');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionSectionFormat.prototype, "pageWidth", {
        /**
         * Gets or sets the page width.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.pageWidthIn;
        },
        /**
         * Gets or sets the page width.
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            this.pageWidthIn = value;
            this.notifyPropertyChanged('pageWidth');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionSectionFormat.prototype, "leftMargin", {
        /**
         * Gets or sets the page left margin.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.leftMarginIn;
        },
        /**
         * Gets or sets the page left margin.
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            this.leftMarginIn = value;
            this.notifyPropertyChanged('leftMargin');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionSectionFormat.prototype, "bottomMargin", {
        /**
         * Gets or sets the page bottom margin.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.bottomMarginIn;
        },
        /**
         * Gets or sets the page bottom margin.
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            this.bottomMarginIn = value;
            this.notifyPropertyChanged('bottomMargin');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionSectionFormat.prototype, "topMargin", {
        /**
         * Gets or sets the page top margin.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.topMarginIn;
        },
        /**
         * Gets or sets the page top margin.
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            this.topMarginIn = value;
            this.notifyPropertyChanged('topMargin');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionSectionFormat.prototype, "rightMargin", {
        /**
         * Gets or sets the page right margin.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.rightMarginIn;
        },
        /**
         * Gets or sets the page right margin.
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            this.rightMarginIn = value;
            this.notifyPropertyChanged('rightMargin');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionSectionFormat.prototype, "headerDistance", {
        /**
         * Gets or sets the header distance.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.headerDistanceIn;
        },
        /**
         * Gets or sets the header distance.
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            this.headerDistanceIn = value;
            this.notifyPropertyChanged('headerDistance');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionSectionFormat.prototype, "footerDistance", {
        /**
         * Gets or sets the footer distance.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.footerDistanceIn;
        },
        /**
         * Gets or sets the footer distance.
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            this.footerDistanceIn = value;
            this.notifyPropertyChanged('footerDistance');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionSectionFormat.prototype, "differentFirstPage", {
        /**
         * Gets or sets a value indicating whether the section has different first page.
         * @aspType bool
         * @blazorType bool
         */
        get: function () {
            return this.differentFirstPageIn;
        },
        /**
         * Gets or sets a value indicating whether the section has different first page.
         * @aspType bool
         * @blazorType bool
         */
        set: function (value) {
            this.differentFirstPageIn = value;
            this.notifyPropertyChanged('differentFirstPage');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionSectionFormat.prototype, "differentOddAndEvenPages", {
        /**
         * Gets or sets a value indicating whether the section has different odd and even page.
         * @aspType bool
         * @blazorType bool
         */
        get: function () {
            return this.differentOddAndEvenPagesIn;
        },
        /**
         * Gets or sets a value indicating whether the section has different odd and even page.
         * @aspType bool
         * @blazorType bool
         */
        set: function (value) {
            this.differentOddAndEvenPagesIn = value;
            this.notifyPropertyChanged('differentOddAndEvenPages');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies the format.
     * @param  {WSectionFormat} format
     * @returns void
     * @private
     */
    SelectionSectionFormat.prototype.copyFormat = function (format) {
        this.pageHeight = format.pageHeight;
        this.pageWidth = format.pageWidth;
        this.leftMargin = format.leftMargin;
        this.topMargin = format.topMargin;
        this.rightMargin = format.rightMargin;
        this.bottomMargin = format.bottomMargin;
        this.headerDistance = format.headerDistance;
        this.footerDistance = format.footerDistance;
        this.differentFirstPage = format.differentFirstPage;
        this.differentOddAndEvenPages = format.differentOddAndEvenPages;
        this.bidi = format.bidi;
    };
    SelectionSectionFormat.prototype.notifyPropertyChanged = function (propertyName) {
        var selection = this.selection;
        if (!isNullOrUndefined(selection) && (selection.isCleared || selection.owner.isPastingContent
            || selection.owner.isReadOnlyMode || !selection.owner.isDocumentLoaded)
            && !selection.isRetrieveFormatting) {
            return;
        }
        if (!isNullOrUndefined(selection) && !isNullOrUndefined(selection.start) && !selection.isRetrieveFormatting) {
            var value = this.getPropertyvalue(propertyName);
            if (!isNullOrUndefined(value)) {
                selection.owner.editorModule.onApplySectionFormat(propertyName, value);
            }
        }
    };
    SelectionSectionFormat.prototype.getPropertyvalue = function (propertyName) {
        switch (propertyName) {
            case 'pageHeight':
                if (this.pageHeight > 0) {
                    return this.pageHeight;
                }
                return undefined;
            case 'pageWidth':
                if (this.pageWidth > 0) {
                    return this.pageWidth;
                }
                return undefined;
            case 'leftMargin':
                if (this.leftMargin >= 0) {
                    return this.leftMargin;
                }
                return undefined;
            case 'rightMargin':
                if (this.rightMargin >= 0) {
                    return this.rightMargin;
                }
                return undefined;
            case 'topMargin':
                if (this.topMargin >= 0) {
                    return this.topMargin;
                }
                return undefined;
            case 'bottomMargin':
                if (this.bottomMargin >= 0) {
                    return this.bottomMargin;
                }
                return undefined;
            case 'differentFirstPage':
                if (!isNullOrUndefined(this.differentFirstPage)) {
                    return this.differentFirstPage;
                }
                return undefined;
            case 'differentOddAndEvenPages':
                if (!isNullOrUndefined(this.differentOddAndEvenPages)) {
                    return this.differentOddAndEvenPages;
                }
                return undefined;
            case 'headerDistance':
                return this.headerDistanceIn;
            case 'footerDistance':
                return this.footerDistance;
            default:
                return undefined;
        }
    };
    /**
     * Combines the format.
     * @param  {WSectionFormat} format
     * @private
     */
    SelectionSectionFormat.prototype.combineFormat = function (format) {
        if (this.pageHeight > 0 && this.pageHeight !== format.pageHeight) {
            this.pageHeight = 0;
        }
        if (this.pageWidth > 0 && this.pageWidth !== format.pageWidth) {
            this.pageWidth = 0;
        }
        if (this.leftMargin > -1 && this.leftMargin !== format.leftMargin) {
            this.leftMargin = -1;
        }
        if (this.topMargin > -1 && this.topMargin !== format.topMargin) {
            this.topMargin = -1;
        }
        if (this.rightMargin > -1 && this.rightMargin !== format.rightMargin) {
            this.rightMargin = -1;
        }
        if (this.bottomMargin > -1 && this.bottomMargin !== format.bottomMargin) {
            this.bottomMargin = -1;
        }
        if (this.headerDistance !== 0 && this.headerDistance !== format.headerDistance) {
            this.headerDistance = 0;
        }
        if (this.footerDistance !== 0 && this.footerDistance !== format.footerDistance) {
            this.footerDistance = 0;
        }
        if (!isNullOrUndefined(this.differentFirstPage) && this.differentFirstPage !== format.differentFirstPage) {
            this.differentFirstPage = undefined;
        }
        if (!isNullOrUndefined(this.differentOddAndEvenPages) && this.differentOddAndEvenPages !== format.differentOddAndEvenPages) {
            this.differentOddAndEvenPages = undefined;
        }
        if (!isNullOrUndefined(this.bidi) && this.bidi !== format.bidi) {
            this.bidi = undefined;
        }
    };
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    SelectionSectionFormat.prototype.clearFormat = function () {
        this.headerDistance = 0;
        this.footerDistance = 0;
        this.pageHeight = 0;
        this.pageWidth = 0;
        this.leftMargin = -1;
        this.rightMargin = -1;
        this.topMargin = -1;
        this.bottomMargin = -1;
        this.differentFirstPage = undefined;
        this.differentOddAndEvenPages = undefined;
        this.bidi = undefined;
    };
    /**
     * Destroys the managed resources.
     * @returns void
     * @private
     */
    SelectionSectionFormat.prototype.destroy = function () {
        this.headerDistanceIn = undefined;
        this.footerDistanceIn = undefined;
        this.pageHeightIn = undefined;
        this.pageWidthIn = undefined;
        this.leftMarginIn = undefined;
        this.rightMarginIn = undefined;
        this.topMarginIn = undefined;
        this.bottomMarginIn = undefined;
        this.differentFirstPageIn = undefined;
        this.differentOddAndEvenPagesIn = undefined;
        this.selection = undefined;
        this.bidi = undefined;
    };
    return SelectionSectionFormat;
}());
/**
 * Selection table format implementation
 */
var SelectionTableFormat = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function SelectionTableFormat(selection) {
        this.leftIndentIn = 0;
        this.backgroundIn = undefined;
        this.tableAlignmentIn = undefined;
        this.cellSpacingIn = 0;
        this.leftMarginIn = 0;
        this.rightMarginIn = 0;
        this.topMarginIn = 0;
        this.bottomMarginIn = 0;
        this.preferredWidthIn = 0;
        this.bidiIn = undefined;
        this.selection = selection;
    }
    Object.defineProperty(SelectionTableFormat.prototype, "table", {
        /**
         * Gets or sets the table.
         * @private
         */
        get: function () {
            return this.tableIn;
        },
        set: function (value) {
            this.tableIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionTableFormat.prototype, "leftIndent", {
        /**
         * Gets or Sets the left indent for selected table.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.leftIndentIn;
        },
        /**
         * Gets or Sets the left indent for selected table.
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.leftIndentIn) {
                return;
            }
            this.leftIndentIn = value;
            this.notifyPropertyChanged('leftIndent');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionTableFormat.prototype, "topMargin", {
        /**
         * Gets or Sets the default top margin of cell for selected table.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.topMarginIn;
        },
        /**
         * Gets or Sets the default top margin of cell for selected table.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.topMarginIn) {
                return;
            }
            this.topMarginIn = value;
            this.notifyPropertyChanged('topMargin');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionTableFormat.prototype, "background", {
        /**
         * Gets or Sets the background for selected table.
         * @default undefined
         * @aspType string
         * @blazorType string
         */
        get: function () {
            return this.backgroundIn;
        },
        /**
         * Gets or Sets the background for selected table.
         * @default undefined
         * @aspType string
         * @blazorType string
         */
        set: function (value) {
            if (value === this.backgroundIn) {
                return;
            }
            this.backgroundIn = value;
            this.notifyPropertyChanged('background');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionTableFormat.prototype, "tableAlignment", {
        /**
         * Gets or Sets the table alignment for selected table.
         * @default undefined
         */
        get: function () {
            return this.tableAlignmentIn;
        },
        /**
         * Gets or Sets the table alignment for selected table.
         * @default undefined
         */
        set: function (value) {
            if (value === this.tableAlignmentIn) {
                return;
            }
            this.tableAlignmentIn = value;
            this.notifyPropertyChanged('tableAlignment');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionTableFormat.prototype, "leftMargin", {
        /**
         * Gets or Sets the default left margin of cell for selected table.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.leftMarginIn;
        },
        /**
         * Gets or Sets the default left margin of cell for selected table.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.leftMarginIn) {
                return;
            }
            this.leftMarginIn = value;
            this.notifyPropertyChanged('leftMargin');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionTableFormat.prototype, "bottomMargin", {
        /**
         * Gets or Sets the default bottom margin of cell for selected table.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.bottomMarginIn;
        },
        /**
         * Gets or Sets the default bottom margin of cell for selected table.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.bottomMarginIn) {
                return;
            }
            this.bottomMarginIn = value;
            this.notifyPropertyChanged('bottomMargin');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionTableFormat.prototype, "cellSpacing", {
        /**
         * Gets or Sets the cell spacing for selected table.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.cellSpacingIn;
        },
        /**
         * Gets or Sets the cell spacing for selected table.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.cellSpacingIn) {
                return;
            }
            this.cellSpacingIn = value;
            this.notifyPropertyChanged('cellSpacing');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionTableFormat.prototype, "rightMargin", {
        /**
         * Gets or Sets the default right margin of cell for selected table.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.rightMarginIn;
        },
        /**
         * Gets or Sets the default right margin of cell for selected table.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.rightMarginIn) {
                return;
            }
            this.rightMarginIn = value;
            this.notifyPropertyChanged('rightMargin');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionTableFormat.prototype, "preferredWidth", {
        /**
         * Gets or Sets the preferred width for selected table.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.preferredWidthIn;
        },
        /**
         * Gets or Sets the preferred width for selected table.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.preferredWidthIn) {
                return;
            }
            this.preferredWidthIn = value;
            this.notifyPropertyChanged('preferredWidth');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionTableFormat.prototype, "preferredWidthType", {
        /**
         * Gets or Sets the preferred width type for selected table.
         * @default undefined
         */
        get: function () {
            return this.preferredWidthTypeIn;
        },
        /**
         * Gets or Sets the preferred width type for selected table.
         * @default undefined
         */
        set: function (value) {
            if (value === this.preferredWidthTypeIn) {
                return;
            }
            this.preferredWidthTypeIn = value;
            this.notifyPropertyChanged('preferredWidthType');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionTableFormat.prototype, "bidi", {
        /**
         * Gets or sets the bidi property
         * @aspType bool
         * @blazorType bool
         */
        get: function () {
            return this.bidiIn;
        },
        /**
         * Gets or sets the bidi property
         * @aspType bool
         * @blazorType bool
         */
        set: function (value) {
            this.bidiIn = value;
            this.notifyPropertyChanged('bidi');
        },
        enumerable: true,
        configurable: true
    });
    SelectionTableFormat.prototype.getPropertyValue = function (propertyName) {
        switch (propertyName) {
            case 'tableAlignment':
                return this.tableAlignment;
            case 'leftIndent':
                return this.leftIndent;
            case 'cellSpacing':
                return this.cellSpacing;
            case 'leftMargin':
                return this.leftMargin;
            case 'rightMargin':
                return this.rightMargin;
            case 'topMargin':
                return this.topMargin;
            case 'bottomMargin':
                return this.bottomMargin;
            case 'background':
                var shading = new WShading();
                shading.backgroundColor = this.background;
                return shading;
            case 'preferredWidth':
                return this.preferredWidth;
            case 'preferredWidthType':
                return this.preferredWidthType;
            case 'bidi':
                return this.bidi;
            default:
                return undefined;
        }
    };
    SelectionTableFormat.prototype.notifyPropertyChanged = function (propertyName) {
        if (!isNullOrUndefined(this.selection) && (this.selection.isCleared
            || !this.selection.owner.isDocumentLoaded || this.selection.owner.isReadOnlyMode
            || this.selection.owner.isPastingContent) && !this.selection.isRetrieveFormatting) {
            return;
        }
        if (!isNullOrUndefined(this.selection) && !isNullOrUndefined(this.selection.start) && !this.selection.isRetrieveFormatting) {
            var value = this.getPropertyValue(propertyName);
            if (propertyName === 'background') {
                propertyName = 'shading';
            }
            if (!isNullOrUndefined(value)) {
                this.selection.owner.editorModule.onApplyTableFormat(propertyName, value);
            }
        }
    };
    /**
     * Copies the format.
     * @param  {WTableFormat} format Format to copy.
     * @returns void
     * @private
     */
    SelectionTableFormat.prototype.copyFormat = function (format) {
        this.leftIndent = format.leftIndent;
        this.background = format.shading.backgroundColor;
        this.tableAlignment = format.tableAlignment;
        this.leftMargin = format.leftMargin;
        this.rightMargin = format.rightMargin;
        this.topMargin = format.topMargin;
        this.bottomMargin = format.bottomMargin;
        this.cellSpacing = format.cellSpacing;
        this.preferredWidth = format.preferredWidth;
        this.preferredWidthType = format.preferredWidthType;
        this.bidi = format.bidi;
    };
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    SelectionTableFormat.prototype.clearFormat = function () {
        this.table = undefined;
        this.leftIndent = 0;
        this.background = undefined;
        this.leftIndent = 0;
        this.leftMargin = 0;
        this.rightMargin = 0;
        this.topMargin = 0;
        this.bottomMargin = 0;
        this.cellSpacing = 0;
        this.tableAlignment = undefined;
        this.bidi = undefined;
    };
    /**
     * Destroys the managed resources.
     * @returns void
     * @private
     */
    SelectionTableFormat.prototype.destroy = function () {
        this.leftIndentIn = undefined;
        this.backgroundIn = undefined;
        this.leftIndentIn = undefined;
        this.leftMarginIn = undefined;
        this.rightMarginIn = undefined;
        this.topMarginIn = undefined;
        this.bottomMarginIn = undefined;
        this.cellSpacingIn = undefined;
        this.tableAlignmentIn = undefined;
        this.tableIn = undefined;
        this.selection = undefined;
        this.bidi = undefined;
    };
    return SelectionTableFormat;
}());
/**
 * Selection cell format implementation
 */
var SelectionCellFormat = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function SelectionCellFormat(selection) {
        this.verticalAlignmentIn = undefined;
        this.leftMarginIn = 0;
        this.rightMarginIn = 0;
        this.topMarginIn = 0;
        this.bottomMarginIn = 0;
        this.backgroundIn = undefined;
        this.preferredWidthTypeIn = undefined;
        this.selection = selection;
    }
    Object.defineProperty(SelectionCellFormat.prototype, "verticalAlignment", {
        /**
         * Gets or sets the vertical alignment of the selected cells.
         * @default undefined
         */
        get: function () {
            return this.verticalAlignmentIn;
        },
        /**
         * Gets or sets the vertical alignment of the selected cells.
         * @default undefined
         */
        set: function (value) {
            if (value === this.verticalAlignmentIn) {
                return;
            }
            this.verticalAlignmentIn = value;
            this.notifyPropertyChanged('verticalAlignment');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCellFormat.prototype, "leftMargin", {
        /**
         * Gets or Sets the left margin for selected cells.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        /* tslint:disable */
        get: function () {
            return this.leftMarginIn;
        },
        /**
         * Gets or Sets the left margin for selected cells.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.leftMarginIn) {
                return;
            }
            this.leftMarginIn = value;
            this.notifyPropertyChanged('leftMargin');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCellFormat.prototype, "rightMargin", {
        /**
         * Gets or Sets the right margin for selected cells.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.rightMarginIn;
        },
        /**
         * Gets or Sets the right margin for selected cells.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.rightMarginIn) {
                return;
            }
            this.rightMarginIn = value;
            this.notifyPropertyChanged('rightMargin');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCellFormat.prototype, "topMargin", {
        /**
         * Gets or Sets the top margin for selected cells.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.topMarginIn;
        },
        /**
         * Gets or Sets the top margin for selected cells.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.topMarginIn) {
                return;
            }
            this.topMarginIn = value;
            this.notifyPropertyChanged('topMargin');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCellFormat.prototype, "bottomMargin", {
        /**
         * Gets or Sets the bottom margin for selected cells.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.bottomMarginIn;
        },
        /**
         * Gets or Sets the bottom margin for selected cells.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.bottomMarginIn) {
                return;
            }
            this.bottomMarginIn = value;
            this.notifyPropertyChanged('bottomMargin');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCellFormat.prototype, "background", {
        /**
         * Gets or Sets the background for selected cells.
         * @default undefined
         * @aspType string
         * @blazorType string
         */
        get: function () {
            return this.backgroundIn;
        },
        /**
         * Gets or Sets the background for selected cells.
         * @default undefined
         * @aspType string
         * @blazorType string
         */
        /* tslint:enable */
        set: function (value) {
            if (value === this.backgroundIn) {
                return;
            }
            this.backgroundIn = value;
            this.notifyPropertyChanged('background');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCellFormat.prototype, "preferredWidthType", {
        /* tslint:disable */
        /**
         * Gets or Sets the preferred width type for selected cells.
         * @default undefined
         */
        get: function () {
            return this.preferredWidthTypeIn;
        },
        /**
         * Gets or Sets the preferred width type for selected cells.
         * @default undefined
         */
        set: function (value) {
            if (value === this.preferredWidthTypeIn) {
                return;
            }
            this.preferredWidthTypeIn = value;
            this.notifyPropertyChanged('preferredWidthType');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionCellFormat.prototype, "preferredWidth", {
        /**
         * Gets or Sets the preferred width  for selected cells.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.preferredWidthIn;
        },
        /**
         * Gets or Sets the preferred width  for selected cells.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.preferredWidthIn) {
                return;
            }
            this.preferredWidthIn = value;
            this.notifyPropertyChanged('preferredWidth');
        },
        enumerable: true,
        configurable: true
    });
    /* tslint:enable */
    SelectionCellFormat.prototype.notifyPropertyChanged = function (propertyName) {
        var selection = this.selection;
        if (!isNullOrUndefined(selection)) {
            if ((selection.isCleared || !selection.owner.isDocumentLoaded
                || selection.owner.isReadOnlyMode || selection.owner.isPastingContent) && !selection.isRetrieveFormatting) {
                return;
            }
            if (!isNullOrUndefined(this.selection.start) && !this.selection.isRetrieveFormatting) {
                var value = this.getPropertyValue(propertyName);
                if (propertyName === 'background') {
                    propertyName = 'shading';
                }
                if (!isNullOrUndefined(value)) {
                    this.selection.owner.editorModule.onApplyTableCellFormat(propertyName, value);
                }
            }
        }
    };
    SelectionCellFormat.prototype.getPropertyValue = function (propertyName) {
        switch (propertyName) {
            case 'verticalAlignment':
                return this.verticalAlignment;
            case 'leftMargin':
                return this.leftMargin;
            case 'rightMargin':
                return this.rightMargin;
            case 'topMargin':
                return this.topMargin;
            case 'bottomMargin':
                return this.bottomMargin;
            case 'preferredWidth':
                return this.preferredWidth;
            case 'preferredWidthType':
                return this.preferredWidthType;
            case 'background':
                var shading = new WShading();
                shading.backgroundColor = this.background;
                return shading;
            default:
                return undefined;
        }
    };
    /**
     * Copies the format.
     * @param  {WCellFormat} format Source Format to copy.
     * @returns void
     * @private
     */
    SelectionCellFormat.prototype.copyFormat = function (format) {
        this.leftMargin = format.leftMargin;
        this.rightMargin = format.rightMargin;
        this.topMargin = format.topMargin;
        this.bottomMargin = format.bottomMargin;
        this.background = format.shading.backgroundColor;
        this.verticalAlignment = format.verticalAlignment;
        this.preferredWidth = format.preferredWidth;
        this.preferredWidthType = format.preferredWidthType;
    };
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    SelectionCellFormat.prototype.clearCellFormat = function () {
        this.leftMargin = undefined;
        this.rightMargin = undefined;
        this.topMargin = undefined;
        this.bottomMargin = undefined;
        this.background = undefined;
        this.verticalAlignment = undefined;
    };
    /**
     * Combines the format.
     * @param  {WCellFormat} format
     * @private
     */
    SelectionCellFormat.prototype.combineFormat = function (format) {
        if (!isNullOrUndefined(this.leftMargin) && this.leftMargin !== format.leftMargin) {
            this.leftMargin = undefined;
        }
        if (!isNullOrUndefined(this.topMargin) && this.topMargin !== format.topMargin) {
            this.topMargin = undefined;
        }
        if (!isNullOrUndefined(this.rightMargin) && this.rightMargin !== format.rightMargin) {
            this.rightMargin = undefined;
        }
        if (!isNullOrUndefined(this.bottomMargin) && this.bottomMargin !== format.bottomMargin) {
            this.bottomMargin = undefined;
        }
        if (!isNullOrUndefined(this.background) && this.background !== format.shading.backgroundColor) {
            this.background = undefined;
        }
        if (!isNullOrUndefined(this.verticalAlignment) && this.verticalAlignment !== format.verticalAlignment) {
            this.verticalAlignment = undefined;
        }
        if (!isNullOrUndefined(this.preferredWidth) && this.preferredWidth !== format.preferredWidth) {
            this.preferredWidth = undefined;
        }
        if (!isNullOrUndefined(this.preferredWidthType) && this.preferredWidthType !== format.preferredWidthType) {
            this.preferredWidthType = undefined;
        }
    };
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    SelectionCellFormat.prototype.clearFormat = function () {
        this.background = undefined;
        this.bottomMargin = 0;
        this.leftMargin = 0;
        this.rightMargin = 0;
        this.topMargin = 0;
        this.verticalAlignment = undefined;
    };
    /**
     * Destroys the manages resources.
     * @returns void
     * @private
     */
    SelectionCellFormat.prototype.destroy = function () {
        this.backgroundIn = undefined;
        this.verticalAlignmentIn = undefined;
        this.bottomMarginIn = undefined;
        this.leftMarginIn = undefined;
        this.rightMarginIn = undefined;
        this.topMarginIn = undefined;
        this.selection = undefined;
    };
    return SelectionCellFormat;
}());
/**
 * Selection row format implementation
 */
var SelectionRowFormat = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function SelectionRowFormat(selection) {
        this.heightIn = undefined;
        this.heightTypeIn = undefined;
        this.isHeaderIn = undefined;
        this.allowRowBreakAcrossPagesIn = undefined;
        this.selection = selection;
    }
    Object.defineProperty(SelectionRowFormat.prototype, "height", {
        /**
         * Gets or Sets the height for selected rows.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.heightIn;
        },
        /**
         * Gets or Sets the height for selected rows.
         * @default undefined
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value === this.heightIn) {
                return;
            }
            this.heightIn = value;
            this.notifyPropertyChanged('height');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionRowFormat.prototype, "heightType", {
        /**
         * Gets or Sets the height type for selected rows.
         * @default undefined
         */
        get: function () {
            return this.heightTypeIn;
        },
        /**
         * Gets or Sets the height type for selected rows.
         * @default undefined
         */
        set: function (value) {
            if (value === this.heightTypeIn) {
                return;
            }
            this.heightTypeIn = value;
            this.notifyPropertyChanged('heightType');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionRowFormat.prototype, "isHeader", {
        /**
         * Gets or Sets a value indicating whether the selected rows are header rows or not.
         * @default undefined
         * @aspType bool
         * @blazorType bool
         */
        get: function () {
            return this.isHeaderIn;
        },
        /**
         * Gets or Sets a value indicating whether the selected rows are header rows or not.
         * @default undefined
         * @aspType bool
         * @blazorType bool
         */
        set: function (value) {
            if (value === this.isHeaderIn) {
                return;
            }
            this.isHeaderIn = value;
            this.notifyPropertyChanged('isHeader');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionRowFormat.prototype, "allowBreakAcrossPages", {
        /**
         * Gets or Sets a value indicating whether to allow break across pages for selected rows.
         * @default undefined
         * @aspType bool
         * @blazorType bool
         */
        get: function () {
            return this.allowRowBreakAcrossPagesIn;
        },
        /**
         * Gets or Sets a value indicating whether to allow break across pages for selected rows.
         * @default undefined
         * @aspType bool
         * @blazorType bool
         */
        set: function (value) {
            if (value === this.allowRowBreakAcrossPagesIn) {
                return;
            }
            this.allowRowBreakAcrossPagesIn = value;
            this.notifyPropertyChanged('allowBreakAcrossPages');
        },
        enumerable: true,
        configurable: true
    });
    SelectionRowFormat.prototype.notifyPropertyChanged = function (propertyName) {
        var selection = this.selection;
        if (!isNullOrUndefined(selection) && (selection.isCleared || selection.owner.isReadOnlyMode
            || !selection.owner.isDocumentLoaded || selection.owner.isPastingContent) && !selection.isRetrieveFormatting) {
            return;
        }
        if (!isNullOrUndefined(selection) && !isNullOrUndefined(selection.start) && !selection.isRetrieveFormatting) {
            var value = this.getPropertyValue(propertyName);
            if (!isNullOrUndefined(value)) {
                selection.owner.editorModule.onApplyTableRowFormat(propertyName, value);
            }
        }
    };
    SelectionRowFormat.prototype.getPropertyValue = function (propertyName) {
        switch (propertyName) {
            case 'height':
                return this.height;
            case 'heightType':
                return this.heightType;
            case 'isHeader':
                return this.isHeader;
            case 'allowBreakAcrossPages':
                return this.allowBreakAcrossPages;
            default:
                return undefined;
        }
    };
    /**
     * Copies the format.
     * @param  {WRowFormat} format
     * @returns void
     * @private
     */
    SelectionRowFormat.prototype.copyFormat = function (format) {
        this.height = format.height;
        this.heightType = format.heightType;
        this.allowBreakAcrossPages = format.allowBreakAcrossPages;
        this.isHeader = format.isHeader;
    };
    /**
     * Combines the format.
     * @param  {WRowFormat} format
     * @private
     */
    SelectionRowFormat.prototype.combineFormat = function (format) {
        if (!isNullOrUndefined(this.height) && this.height !== format.height) {
            this.height = undefined;
        }
        if (!isNullOrUndefined(this.heightType) && this.heightType !== format.heightType) {
            this.heightType = undefined;
        }
        if (!isNullOrUndefined(this.allowBreakAcrossPages) && this.allowBreakAcrossPages !== format.allowBreakAcrossPages) {
            this.allowBreakAcrossPages = undefined;
        }
        if (!isNullOrUndefined(this.isHeader) && this.isHeader !== format.isHeader) {
            this.isHeader = undefined;
        }
    };
    /**
     * Clears the row format.
     * @returns void
     * @private
     */
    SelectionRowFormat.prototype.clearRowFormat = function () {
        this.height = undefined;
        this.heightType = undefined;
        this.allowBreakAcrossPages = undefined;
        this.isHeader = undefined;
    };
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    SelectionRowFormat.prototype.clearFormat = function () {
        this.height = 0;
        this.heightType = undefined;
        this.allowBreakAcrossPages = undefined;
        this.isHeader = undefined;
    };
    /**
     * Destroys the managed resources.
     * @returns void
     * @private
     */
    SelectionRowFormat.prototype.destroy = function () {
        this.heightIn = undefined;
        this.heightTypeIn = undefined;
        this.allowRowBreakAcrossPagesIn = undefined;
        this.isHeaderIn = undefined;
        this.selection = undefined;
    };
    return SelectionRowFormat;
}());
/**
 * Selection image format implementation
 */
var SelectionImageFormat = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function SelectionImageFormat(selection) {
        this.selection = selection;
    }
    Object.defineProperty(SelectionImageFormat.prototype, "width", {
        /**
         * Gets the width of the image.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            if (this.image) {
                return this.image.width;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionImageFormat.prototype, "height", {
        /**
         * Gets the height of the image.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            if (this.image) {
                return this.image.height;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resizes the image based on given size.
     * @param width
     * @param height
     */
    SelectionImageFormat.prototype.resize = function (width, height) {
        this.updateImageFormat(width, height);
    };
    /**
     * Update image width and height
     * @private
     */
    SelectionImageFormat.prototype.updateImageFormat = function (width, height) {
        if (this.image) {
            if (this.selection.owner.editorModule) {
                this.selection.owner.editorModule.onImageFormat(this.image, width, height);
            }
        }
    };
    /**
     * @private
     */
    SelectionImageFormat.prototype.copyImageFormat = function (image) {
        this.image = image;
    };
    /**
     * @private
     */
    SelectionImageFormat.prototype.clearImageFormat = function () {
        this.image = undefined;
    };
    return SelectionImageFormat;
}());

/* tslint:enable */

/**
 * @private
 */
var HtmlExport = /** @__PURE__ @class */ (function () {
    function HtmlExport() {
        /* tslint:disable:no-any */
        this.document = undefined;
        this.prevListLevel = undefined;
        this.isOrdered = undefined;
        /* tslint:disable:no-any */
        /**
         * @private
         */
        this.fieldCheck = 0;
        /* tslint:enable:no-any */
    }
    /* tslint:disable:no-any */
    /**
     * @private
     */
    HtmlExport.prototype.writeHtml = function (document) {
        this.document = document;
        var html = '';
        for (var i = 0; i < document.sections.length; i++) {
            html = this.serializeSection(document.sections[i]);
        }
        return html;
    };
    /**
     * @private
     */
    HtmlExport.prototype.serializeSection = function (section) {
        var string = '';
        for (var i = 0; i < section.blocks.length; i++) {
            var block = section.blocks[i];
            if (block.hasOwnProperty('inlines')) {
                string += this.serializeParagraph(block);
            }
            else {
                string += this.closeList();
                string += this.serializeTable(block);
            }
        }
        string += this.closeList();
        this.prevListLevel = undefined;
        this.isOrdered = undefined;
        return string;
    };
    // Serialize Paragraph 
    /**
     * @private
     */
    HtmlExport.prototype.serializeParagraph = function (paragraph) {
        var blockStyle = '';
        var isList = false;
        var isPreviousList = false;
        if (!isNullOrUndefined(this.prevListLevel)) {
            isPreviousList = true;
        }
        var tagAttributes = [];
        var listLevel = undefined;
        if (!isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
            listLevel = this.getListLevel(paragraph);
            if (!isPreviousList) {
                this.prevListLevel = listLevel;
            }
            if (this.prevListLevel !== listLevel) {
                isPreviousList = false;
            }
            this.prevListLevel = listLevel;
        }
        if (!isPreviousList) {
            blockStyle += this.closeList();
        }
        if (!isNullOrUndefined(listLevel)) {
            isList = true;
        }
        if (isList && !isPreviousList) {
            blockStyle += this.getHtmlList(listLevel, paragraph.paragraphFormat.listFormat.listLevelNumber);
        }
        tagAttributes.push('style="' + this.serializeParagraphStyle(paragraph, '', isList) + '"');
        if (isList) {
            blockStyle += this.createAttributesTag('li', tagAttributes);
        }
        else {
            this.prevListLevel = undefined;
            this.isOrdered = undefined;
            blockStyle += this.createAttributesTag(this.getStyleName(paragraph.paragraphFormat.styleName), tagAttributes);
        }
        if (paragraph.inlines.length === 0) {
            //Handled to preserve non breaking space for empty paragraphs similar to MS Word behavior.
            blockStyle += '&nbsp';
        }
        else {
            blockStyle = this.serializeInlines(paragraph, blockStyle);
        }
        if (isList) {
            blockStyle += this.endTag('li');
            if (blockStyle.indexOf('<ul') > -1) {
                this.isOrdered = false;
            }
            else if (blockStyle.indexOf('<ol') > -1) {
                this.isOrdered = true;
            }
        }
        else {
            blockStyle += this.endTag(this.getStyleName(paragraph.paragraphFormat.styleName));
        }
        return blockStyle;
    };
    HtmlExport.prototype.closeList = function () {
        var blockStyle = '';
        if (!isNullOrUndefined(this.isOrdered)) {
            if (this.isOrdered) {
                blockStyle = this.endTag('ol');
            }
            else {
                blockStyle = this.endTag('ul');
            }
            this.isOrdered = undefined;
        }
        return blockStyle;
    };
    HtmlExport.prototype.getListLevel = function (paragraph) {
        var listLevel = undefined;
        var list = undefined;
        for (var i = 0; i < this.document.lists.length; i++) {
            if (this.document.lists[i].listId === paragraph.paragraphFormat.listFormat.listId) {
                list = this.document.lists[i];
                break;
            }
        }
        if (list) {
            for (var j = 0; j < this.document.abstractLists.length; j++) {
                if (this.document.abstractLists[j].abstractListId === list.abstractListId) {
                    listLevel = this.document.abstractLists[j].levels[paragraph.paragraphFormat.listFormat.listLevelNumber];
                    break;
                }
            }
        }
        return listLevel;
    };
    HtmlExport.prototype.getHtmlList = function (listLevel, levelNumer) {
        //if (start == null || (start != null && start.Paragraph != this)) {
        //    let block: BlockAdv = this.GetPreviousBlock();
        //    if (block instanceof ParagraphAdv) {
        //        let previousListLevel: ListLevelAdv = (block as ParagraphAdv).ParagraphFormat.ListFormat.ListLevel;
        //        if (previousListLevel == listLevel)
        //            return "";
        //    }
        //}
        var html = '';
        if (listLevel.listLevelPattern === 'Bullet') {
            html += '<ul type=\"';
            switch (levelNumer) {
                case 0:
                    html += 'disc';
                    listLevel.characterFormat.fontFamily = 'Symbol';
                    break;
                case 1:
                    html += 'circle';
                    listLevel.characterFormat.fontFamily = 'Symbol';
                    break;
                case 2:
                    html += 'square';
                    listLevel.characterFormat.fontFamily = 'Wingdings';
                    break;
                default:
                    html += 'disc';
                    listLevel.characterFormat.fontFamily = 'Symbol';
                    break;
            }
            html += '\">';
        }
        else {
            html += '<ol type=\"';
            switch (listLevel.listLevelPattern) {
                case 'LowLetter':
                    html += 'a';
                    break;
                case 'UpLetter':
                    html += 'A';
                    break;
                case 'LowRoman':
                    html += 'i';
                    break;
                case 'UpRoman':
                    html += 'I';
                    break;
                default:
                    html += '1';
                    break;
            }
            html += '\" start=\"' + listLevel.startAt.toString() + '\">';
        }
        return html;
    };
    //SerializeInlines
    /**
     * @private
     */
    HtmlExport.prototype.serializeInlines = function (paragraph, blockStyle) {
        var inline = undefined;
        var i = 0;
        while (paragraph.inlines.length > i) {
            inline = paragraph.inlines[i];
            if (inline.hasOwnProperty('imageString')) {
                blockStyle += this.serializeImageContainer(inline);
            }
            else if (inline.hasOwnProperty('fieldType')) {
                if (inline.fieldType === 0) {
                    var fieldCode = paragraph.inlines[i + 1];
                    if (!isNullOrUndefined(fieldCode) && (fieldCode.text.indexOf('TOC') >= 0 || fieldCode.text.indexOf('HYPERLINK') >= 0)) {
                        this.fieldCheck = 1;
                        var tagAttributes = [];
                        tagAttributes.push('style="' + this.serializeInlineStyle(inline.characterFormat, '') + '"');
                        blockStyle += this.createAttributesTag('a', tagAttributes);
                    }
                    else {
                        this.fieldCheck = undefined;
                    }
                }
                else if (inline.fieldType === 2) {
                    if (!isNullOrUndefined(this.fieldCheck)) {
                        this.fieldCheck = 2;
                    }
                    else {
                        this.fieldCheck = 0;
                    }
                }
                else {
                    if (!isNullOrUndefined(this.fieldCheck) && this.fieldCheck !== 0) {
                        blockStyle += this.endTag('a');
                    }
                    this.fieldCheck = 0;
                }
            }
            else {
                var text = isNullOrUndefined(inline.text) ? '' : inline.text;
                if (this.fieldCheck === 0) {
                    blockStyle += this.serializeSpan(text, inline.characterFormat);
                }
                if (this.fieldCheck === 1) {
                    var hyperLink = text.replace(/"/g, '');
                    blockStyle += ' href= \"' + hyperLink.replace('HYPERLINK', '').trim();
                    blockStyle += '\"';
                    blockStyle += '>';
                }
                if (this.fieldCheck === 2) {
                    blockStyle += text;
                }
            }
            i++;
        }
        return blockStyle;
    };
    // Serialize Span
    /**
     * @private
     */
    HtmlExport.prototype.serializeSpan = function (spanText, characterFormat) {
        var spanClass = '';
        if (spanText.indexOf('\v') !== -1) {
            spanClass += '<br>';
            return spanClass.toString();
        }
        else if (spanText.indexOf('\f') !== -1) {
            spanClass += '<br style = "page-break-after:always;"/>';
            return spanClass.toString();
        }
        var tagAttributes = [];
        this.serializeInlineStyle(characterFormat, '');
        tagAttributes.push('style="' + this.serializeInlineStyle(characterFormat, '') + '"');
        spanClass += this.createAttributesTag('span', tagAttributes);
        var text = this.decodeHtmlNames(spanText.toString());
        if (text.length === 0) {
            text = '&nbsp';
        }
        spanClass += text;
        spanClass += this.endTag('span');
        return spanClass.toString();
    };
    /**
     * @private
     */
    HtmlExport.prototype.getStyleName = function (style) {
        switch (style) {
            case 'Heading 1':
                return 'h1';
            case 'Heading 2':
                return 'h2';
            case 'Heading 3':
                return 'h3';
            case 'Heading 4':
                return 'h4';
            case 'Heading 5':
                return 'h5';
            default:
                return 'p';
        }
    };
    //Serialize Image
    /**
     * @private
     */
    HtmlExport.prototype.serializeImageContainer = function (image) {
        var imageStyle = '';
        var tagAttributes = [];
        this.serializeInlineStyle(image.characterFormat, '');
        var imageSource = '';
        if (!isNullOrUndefined(image.imageString)) {
            imageSource = image.imageString;
        }
        var width = HelperMethods.convertPointToPixel(image.width);
        var height = HelperMethods.convertPointToPixel(image.height);
        tagAttributes.push('width="', width.toString() + '"');
        tagAttributes.push('height="', height.toString() + '"');
        tagAttributes.push('src="', imageSource + '"');
        imageStyle += this.createAttributesTag('img', tagAttributes);
        imageStyle += (this.endTag('img'));
        return imageStyle.toString();
    };
    // Serialize Table Cell
    /**
     * @private
     */
    HtmlExport.prototype.serializeCell = function (cell) {
        var blockStyle = '';
        var tagAttributes = [];
        var cellHtml = '';
        tagAttributes = [];
        if (!isNullOrUndefined(cell.cellFormat)) {
            //if (cell.cellFormat.shading.backgroundColor !== Color.FromArgb(0, 0, 0, 0)) {
            if (!isNullOrUndefined(cell.cellFormat.shading.backgroundColor)) {
                tagAttributes.push('bgcolor="' + HelperMethods.getColor(cell.cellFormat.shading.backgroundColor) + '"');
            }
            // }
            if (!isNullOrUndefined(cell.cellFormat.columnSpan) && cell.cellFormat.columnSpan > 1) {
                tagAttributes.push('colspan="' + cell.cellFormat.columnSpan.toString() + '"');
            }
            if (!isNullOrUndefined(cell.cellFormat.rowSpan) && cell.cellFormat.rowSpan > 1) {
                tagAttributes.push('rowspan="' + cell.cellFormat.rowSpan.toString() + '"');
            }
            if (!isNullOrUndefined(cell.cellFormat.cellWidth) && cell.cellFormat.cellWidth !== 0) {
                var cellWidth = HelperMethods.convertPointToPixel(cell.cellFormat.cellWidth);
                tagAttributes.push('width="' + cellWidth.toString() + '"');
            }
            var cellAlignment = isNullOrUndefined(cell.cellFormat.verticalAlignment) ? 'top' :
                cell.cellFormat.verticalAlignment.toString().toLowerCase();
            tagAttributes.push('valign="' + cellAlignment + '"');
            if (!isNullOrUndefined(cell.cellFormat.leftMargin) && cell.cellFormat.leftMargin !== 0) {
                cellHtml += ('padding-left:' + cell.cellFormat.leftMargin.toString() + 'pt;');
            }
            if (!isNullOrUndefined(cell.cellFormat.rightMargin) && cell.cellFormat.rightMargin !== 0) {
                cellHtml += ('padding-right:' + cell.cellFormat.rightMargin.toString() + 'pt;');
            }
            if (!isNullOrUndefined(cell.cellFormat.topMargin) && cell.cellFormat.topMargin !== 0) {
                cellHtml += ('padding-top:' + cell.cellFormat.topMargin.toString() + 'pt;');
            }
            if (!isNullOrUndefined(cell.cellFormat.bottomMargin) && cell.cellFormat.bottomMargin !== 0) {
                cellHtml += ('padding-bottom:' + cell.cellFormat.bottomMargin.toString() + 'pt;');
            }
            if (!isNullOrUndefined(cell.cellFormat.borders)) {
                cellHtml += this.serializeCellBordersStyle(cell.cellFormat.borders);
            }
        }
        if (cellHtml.length !== 0) {
            tagAttributes.push('style="' + cellHtml + '"');
        }
        blockStyle += (this.createAttributesTag('td', tagAttributes));
        for (var k = 0; k < cell.blocks.length; k++) {
            var block = cell.blocks[k];
            if (block.hasOwnProperty('rows')) {
                blockStyle += this.serializeTable(block);
            }
            else {
                blockStyle += this.serializeParagraph(block);
            }
        }
        blockStyle += (this.endTag('td'));
        return blockStyle;
    };
    // Serialize Table
    /**
     * @private
     */
    HtmlExport.prototype.serializeTable = function (table) {
        var html = '';
        html += this.createTableStartTag(table);
        for (var j = 0; j < table.rows.length; j++) {
            html += this.serializeRow(table.rows[j]);
        }
        html += this.createTableEndTag();
        return html;
    };
    // Serialize Row
    /**
     * @private
     */
    HtmlExport.prototype.serializeRow = function (row) {
        var html = '';
        html += this.createRowStartTag(row);
        for (var k = 0; k < row.cells.length; k++) {
            html += this.serializeCell(row.cells[k]);
        }
        return html;
    };
    // Serialize Styles
    /**
     * @private
     */
    HtmlExport.prototype.serializeParagraphStyle = function (paragraph, className, isList) {
        var paragraphClass = '';
        paragraphClass += this.serializeCharacterFormat(paragraph.characterFormat);
        paragraphClass += this.serializeParagraphFormat(paragraph.paragraphFormat, isList);
        return paragraphClass;
    };
    /**
     * @private
     */
    HtmlExport.prototype.serializeInlineStyle = function (characterFormat, className) {
        return this.serializeCharacterFormat(characterFormat);
    };
    /**
     * @private
     */
    HtmlExport.prototype.serializeTableBorderStyle = function (borders) {
        var borderStyle = '';
        if (!isNullOrUndefined(borders.left.lineStyle)) {
            borderStyle += ('border-left-style:' + this.convertBorderLineStyle(borders.left.lineStyle));
            borderStyle += ';';
        }
        if (borders.left.lineWidth) {
            borderStyle += ('border-left-width:' + borders.left.lineWidth.toString() + 'pt');
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.left.color)) {
            borderStyle += ('border-left-color:' + HelperMethods.getColor(borders.left.color));
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.right.lineStyle)) {
            borderStyle += ('border-right-style:' + this.convertBorderLineStyle(borders.right.lineStyle));
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.right.lineWidth)) {
            borderStyle += ('border-right-width:' + borders.right.lineWidth.toString() + 'pt');
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.right.color)) {
            borderStyle += ('border-right-color:' + HelperMethods.getColor(borders.right.color));
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.top.lineStyle)) {
            borderStyle += ('border-top-style:' + this.convertBorderLineStyle(borders.top.lineStyle));
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.top.lineWidth)) {
            borderStyle += ('border-top-width:' + borders.top.lineWidth.toString() + 'pt');
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.top.color)) {
            borderStyle += ('border-top-color:' + HelperMethods.getColor(borders.bottom.color));
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.bottom.lineStyle)) {
            borderStyle += ('border-bottom-style:' + this.convertBorderLineStyle(borders.bottom.lineStyle));
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.bottom.lineWidth)) {
            borderStyle += ('border-bottom-width:' + borders.bottom.lineWidth.toString() + 'pt');
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.bottom.color)) {
            borderStyle += ('border-bottom-color:' + HelperMethods.getColor(borders.bottom.color));
            borderStyle += ';';
        }
        return borderStyle;
    };
    /**
     * @private
     */
    HtmlExport.prototype.serializeCellBordersStyle = function (borders) {
        var borderStyle = '';
        borderStyle = 'border:solid 1px;';
        // if (borders.left.color) {
        //     borderStyle += ('border-left-color:' + HelperMethods.getColor(borders.left.color));
        //     borderStyle += ';';
        // }
        // borderStyle += this.serializeBorderStyle(borders.left, 'left');
        // if (!isNullOrUndefined(borders.right.color)) {
        //     borderStyle += ('border-right-color:' + HelperMethods.getColor(borders.right.color));
        //     borderStyle += ';';
        // }
        // borderStyle += this.serializeBorderStyle(borders.right, 'right');
        // if (!isNullOrUndefined(borders.top.color)) {
        //     borderStyle += ('border-top-color:' + HelperMethods.getColor(borders.top.color));
        //     borderStyle += ';';
        // }
        // borderStyle += this.serializeBorderStyle(borders.top, 'top');
        // if (!isNullOrUndefined(borders.bottom.color)) {
        //     borderStyle += ('border-bottom-color:' + HelperMethods.getColor(borders.bottom.color));
        //     borderStyle += ';';
        // }
        // borderStyle += this.serializeBorderStyle(borders.bottom, 'bottom');
        // Todo: handle
        // let border: WBorder = undefined;
        // //LeftBorder
        // border = WCell.getCellLeftBorder(WCell.getCellOf(borders));
        // if (!isNullOrUndefined(border) && border.lineStyle !== 'None') {
        //     borderStyle += this.serializeBorderStyle(border, 'left');
        // } else if (!isNullOrUndefined(border) && border.hasNoneStyle) {
        //     borderStyle += ('border-left-style:none;');
        // }
        // //RightBorder
        // border = WCell.getCellRightBorder(WCell.getCellOf(borders));
        // if (!isNullOrUndefined(border) && border.lineStyle !== 'None') {
        //     borderStyle += this.serializeBorderStyle(border, 'right');
        // } else if (!isNullOrUndefined(border) && border.hasNoneStyle) {
        //     borderStyle += ('border-right-style:none');
        // }
        // //TopBorder
        // border = WCell.getCellTopBorder(WCell.getCellOf(borders));
        // if (!isNullOrUndefined(border) && border.lineStyle !== 'None') {
        //     borderStyle += this.serializeBorderStyle(border, 'top');
        // } else if (!isNullOrUndefined(border) && border.hasNoneStyle) {
        //     borderStyle += ('border-top-style:none');
        // }
        // //BottomBorder
        // border = WCell.getCellBottomBorder(WCell.getCellOf(borders));
        // if (!isNullOrUndefined(border) && border.lineStyle !== 'None') {
        //     borderStyle += this.serializeBorderStyle(border, 'bottom');
        // } else if (!isNullOrUndefined(border) && border.hasNoneStyle) {
        //     borderStyle += ('border-bottom-style:none');
        // }
        return borderStyle;
    };
    /**
     * @private
     */
    HtmlExport.prototype.serializeBorderStyle = function (border, borderPosition) {
        var borderStyle = '';
        borderStyle += ('border-' + borderPosition + '-style:' + this.convertBorderLineStyle(border.lineStyle));
        borderStyle += ';';
        if (border.lineWidth > 0) {
            borderStyle += ('border-' + borderPosition + '-width:' + border.lineWidth.toString() + 'pt;');
        }
        //if (border.color !== Color.FromArgb(0, 0, 0, 0))
        if (!isNullOrUndefined(border.color)) {
            borderStyle += ('border-' + borderPosition + '-color:' + HelperMethods.getColor(border.color) + ';');
        }
        return borderStyle;
    };
    /**
     * @private
     */
    HtmlExport.prototype.convertBorderLineStyle = function (lineStyle) {
        switch (lineStyle) {
            case 'None':
                return 'none';
            case 'Single':
                return 'solid';
            case 'Dot':
                return 'dotted';
            case 'DashSmallGap':
            case 'DashLargeGap':
            case 'DashDot':
            case 'DashDotDot':
                return 'dashed';
            case 'Double':
            case 'Triple':
            case 'ThinThickSmallGap':
            case 'ThickThinSmallGap':
            case 'ThinThickThinSmallGap':
            case 'ThinThickMediumGap':
            case 'ThickThinMediumGap':
            case 'ThinThickThinMediumGap':
            case 'ThinThickLargeGap':
            case 'ThickThinLargeGap':
            case 'ThinThickThinLargeGap':
                return 'double';
            case 'SingleWavy':
                return 'solid';
            case 'DoubleWavy':
                return 'double';
            case 'DashDotStroked':
                return 'solid';
            case 'Emboss3D':
                return 'ridge';
            case 'Engrave3D':
                return 'groove';
            case 'Outset':
                return 'outset';
            case 'Inset':
                return 'inset';
            default:
                return 'solid';
        }
    };
    // Serialize Format
    /**
     * @private
     */
    HtmlExport.prototype.serializeCharacterFormat = function (characterFormat) {
        if (!isNullOrUndefined(characterFormat.inlineFormat)) {
            return this.serializeCharacterFormat(characterFormat.inlineFormat);
        }
        var propertyValue;
        var charStyle = '';
        charStyle += 'font-weight';
        charStyle += ':';
        charStyle += characterFormat.bold ? 'bold' : 'normal';
        charStyle += ';';
        charStyle += 'font-style';
        charStyle += ':';
        if (characterFormat.italic) {
            charStyle += 'italic';
        }
        else {
            charStyle += 'normal';
        }
        charStyle += ';';
        // Double strike through will become Single strike through while saving HTML using MS Word.
        if (characterFormat.strikethrough === 'SingleStrike' || characterFormat.strikethrough === 'DoubleStrike') {
            charStyle += 'text-decoration';
            charStyle += ':';
            charStyle += 'line-through';
            charStyle += ';';
        }
        //Text Baseline Alignment
        // tslint:disable-next-line:max-line-length
        if (characterFormat.baselineAlignment === 'Superscript' || characterFormat.baselineAlignment === 'Subscript') {
            charStyle += 'vertical-align';
            charStyle += ':';
            charStyle += characterFormat.baselineAlignment === 'Superscript' ? 'super' : 'sub';
            charStyle += ';';
        }
        //Text Foreground and Background Color 
        if (!isNullOrUndefined(characterFormat.highlightColor) && characterFormat.highlightColor !== 'NoColor') {
            charStyle += 'background-color';
            charStyle += ':';
            charStyle += HelperMethods.getColor(characterFormat.highlightColor.toString());
            charStyle += ';';
        }
        //Font Color
        propertyValue = characterFormat.fontColor;
        if (!isNullOrUndefined(propertyValue)) {
            charStyle += 'color';
            charStyle += ':';
            charStyle += HelperMethods.getColor(propertyValue);
            charStyle += ';';
        }
        if (!isNullOrUndefined(characterFormat.underline) && characterFormat.underline !== 'None') {
            charStyle += 'text-decoration';
            charStyle += ':';
            charStyle += 'underline';
            charStyle += ';';
        }
        propertyValue = characterFormat.fontSize;
        if (!isNullOrUndefined(propertyValue)) {
            charStyle += 'font-size';
            charStyle += ':';
            charStyle += propertyValue.toString();
            charStyle += 'pt';
            charStyle += ';';
        }
        propertyValue = characterFormat.fontFamily;
        if (!isNullOrUndefined(propertyValue)) {
            charStyle += 'font-family';
            charStyle += ':';
            charStyle += propertyValue.toString();
            charStyle += ';';
        }
        return charStyle.toString();
    };
    /**
     * @private
     */
    HtmlExport.prototype.serializeParagraphFormat = function (paragraphFormat, isList) {
        if (!isNullOrUndefined(paragraphFormat.inlineFormat)) {
            return this.serializeParagraphFormat(paragraphFormat.inlineFormat, isList);
        }
        var propertyValue;
        var paraStyle = '';
        propertyValue = paragraphFormat.textAlignment;
        if (!isNullOrUndefined(propertyValue)) {
            paraStyle += 'text-align:' + propertyValue.toLowerCase() + ';';
        }
        propertyValue = paragraphFormat.beforeSpacing;
        if (!isNullOrUndefined(propertyValue)) {
            paraStyle += 'margin-top:' + propertyValue.toString() + 'pt; ';
        }
        propertyValue = paragraphFormat.rightIndent;
        if (!isNullOrUndefined(propertyValue)) {
            paraStyle += 'margin-right:' + propertyValue.toString() + 'pt; ';
        }
        propertyValue = paragraphFormat.afterSpacing;
        if (!isNullOrUndefined(propertyValue)) {
            paraStyle += 'margin-bottom:' + propertyValue.toString() + 'pt; ';
        }
        propertyValue = paragraphFormat.leftIndent;
        if (isList) {
            // if (isNullOrUndefined(propertyValue)) {
            //     propertyValue = -36;
            // } else {
            //     propertyValue -= 36;
            // }
            propertyValue = 0;
        }
        if (!isNullOrUndefined(propertyValue)) {
            paraStyle += 'margin-left:' + propertyValue.toString() + 'pt; ';
        }
        propertyValue = paragraphFormat.firstLineIndent;
        if (isList) {
            // if (isNullOrUndefined(propertyValue)) {
            //     propertyValue = 18;
            // } else {
            //     propertyValue += 18;
            // }
            propertyValue = 0;
        }
        if (!isNullOrUndefined(propertyValue) && propertyValue !== 0) {
            paraStyle += 'text-indent:' + propertyValue.toString() + 'pt;';
        }
        propertyValue = paragraphFormat.lineSpacing;
        if (!isNullOrUndefined(propertyValue)) {
            if (paragraphFormat.lineSpacingType === 'Multiple') {
                propertyValue = Math.round(propertyValue * 10) / 10;
            }
            else {
                propertyValue = propertyValue.toString() + 'pt;';
            }
            paraStyle += 'line-height:' + propertyValue;
        }
        return paraStyle.toString();
    };
    /**
     * @private
     */
    HtmlExport.prototype.createAttributesTag = function (tagValue, localProperties) {
        var sb = '';
        sb += '<';
        sb += tagValue;
        for (var i = 0; i < localProperties.length; i++) {
            sb += ' ';
            sb += localProperties[i];
        }
        if (tagValue !== 'a') {
            sb += '>';
        }
        return sb;
    };
    /**
     * @private
     */
    HtmlExport.prototype.createTag = function (tagValue) {
        var s = '';
        s += '<';
        s += tagValue;
        s += '>';
        return s;
    };
    /**
     * @private
     */
    HtmlExport.prototype.endTag = function (tagValue) {
        var sb = '';
        sb += '<';
        sb += '/';
        sb += tagValue;
        sb += '>';
        return sb;
    };
    /**
     * @private
     */
    HtmlExport.prototype.createTableStartTag = function (table) {
        var blockStyle = '';
        var tableStyle = '';
        var tagAttributes = [];
        tagAttributes.push('border="' + '1"');
        if (!isNullOrUndefined(table.tableFormat)) {
            //if (table.tableFormat.shading.backgroundColor !== Color.FromArgb(0, 0, 0, 0)) {
            if (!isNullOrUndefined(table.tableFormat.shading) && !isNullOrUndefined(table.tableFormat.shading.backgroundColor)) {
                tagAttributes.push('bgcolor="' + HelperMethods.getColor(table.tableFormat.shading.backgroundColor) + '"');
            }
            //}
            if (!isNullOrUndefined(table.tableFormat.leftIndent) && table.tableFormat.leftIndent !== 0) {
                tagAttributes.push('left-indent="' + table.tableFormat.leftIndent.toString() + 'pt;');
            }
            if (!isNullOrUndefined(table.tableFormat.cellSpacing) && table.tableFormat.cellSpacing > 0) {
                tagAttributes.push('cellspacing="' + (((table.tableFormat.cellSpacing * 72) / 96) * 2).toString() + '"');
            }
            else {
                tableStyle += ('border-collapse:collapse;');
            }
            tagAttributes.push('cellpadding="' + '0"');
            if (!isNullOrUndefined(table.tableFormat.borders)) {
                tableStyle += this.serializeTableBorderStyle(table.tableFormat.borders);
            }
        }
        if (tableStyle.length !== 0) {
            tagAttributes.push('style="', tableStyle.toString() + '"');
        }
        return blockStyle += (this.createAttributesTag('table', tagAttributes));
    };
    /**
     * @private
     */
    HtmlExport.prototype.createTableEndTag = function () {
        var blockStyle = '';
        blockStyle += (this.endTag('table'));
        return blockStyle;
    };
    /**
     * @private
     */
    HtmlExport.prototype.createRowStartTag = function (row) {
        var blockStyle = '';
        var tagAttributes = [];
        if (row.rowFormat.isHeader) {
            blockStyle += (this.createTag('thead'));
        }
        if (!isNullOrUndefined(row.rowFormat.height) && row.rowFormat.height > 0) {
            var height = HelperMethods.convertPointToPixel(row.rowFormat.height);
            tagAttributes.push('height="' + height + '"');
        }
        return blockStyle + this.createAttributesTag('tr', tagAttributes);
    };
    /**
     * @private
     */
    HtmlExport.prototype.createRowEndTag = function (row) {
        var blockStyle = '';
        blockStyle += (this.endTag('tr'));
        if (row.rowFormat.isHeader) {
            blockStyle += (this.endTag('thead'));
        }
        return blockStyle;
    };
    /**
     * @private
     */
    HtmlExport.prototype.decodeHtmlNames = function (text) {
        if (text === '\t') {
            return '&emsp;';
        }
        var splittedText = text.split(' ');
        var htmlText = '';
        if (splittedText.length > 0) {
            htmlText = splittedText[0];
            for (var i = 0; i < splittedText.length - 1; i++) {
                htmlText += ' ' + splittedText[i + 1];
            }
        }
        return htmlText;
    };
    return HtmlExport;
}());

/**
 * @private
 */
var TextPosition = /** @__PURE__ @class */ (function () {
    function TextPosition(owner) {
        /**
         * @private
         */
        this.location = new Point(0, 0);
        /**
         * @private
         */
        this.isUpdateLocation = true;
        this.owner = owner;
        this.viewer = this.owner.viewer;
    }
    Object.defineProperty(TextPosition.prototype, "paragraph", {
        /**
         * @private
         */
        get: function () {
            return this.currentWidget.paragraph;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextPosition.prototype, "isAtParagraphStart", {
        /**
         * @private
         */
        get: function () {
            return this.offset === this.owner.selection.getStartOffset(this.paragraph);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextPosition.prototype, "isAtParagraphEnd", {
        /**
         * @private
         */
        get: function () {
            return this.owner.selection.isParagraphLastLine(this.currentWidget)
                && this.offset === this.owner.selection.getLineLength(this.currentWidget);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextPosition.prototype, "isCurrentParaBidi", {
        /**
         * @private
         */
        get: function () {
            if (!isNullOrUndefined(this.currentWidget.paragraph)) {
                return this.currentWidget.paragraph.paragraphFormat.bidi;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextPosition.prototype, "selection", {
        /**
         * @private
         */
        get: function () {
            return this.owner.selection;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextPosition.prototype, "hierarchicalPosition", {
        /**
         * Gets the hierarchical position of logical text position in the document
         * @returns {string}
         */
        get: function () {
            return this.getHierarchicalIndexInternal();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Return clone of current text position
     * @private
     */
    TextPosition.prototype.clone = function () {
        var textPosition = new TextPosition(this.owner);
        textPosition.currentWidget = this.currentWidget;
        textPosition.offset = this.offset;
        textPosition.location = this.location;
        return textPosition;
    };
    /**
     * @private
     */
    TextPosition.prototype.containsRtlText = function (widget) {
        for (var i = 0; i < widget.children.length; i++) {
            if (widget.children[i].isRightToLeft) {
                return true;
            }
        }
        return false;
    };
    /**
     * Set text position for paragraph and inline
     * @private
     */
    TextPosition.prototype.setPositionForSelection = function (line, element, index, physicalLocation) {
        //Set the start end position
        var isParagraphEnd = false;
        if (isNullOrUndefined(element)) {
            this.currentWidget = line;
        }
        else {
            this.currentWidget = element.line;
            if (element.nextNode instanceof FieldElementBox && index > element.length) {
                isParagraphEnd = this.selection.isLastRenderedInline(element, element.length);
            }
        }
        this.location = physicalLocation;
        if (isParagraphEnd) {
            this.offset = this.selection.getParagraphLength(this.currentWidget.paragraph) + 1;
        }
        else {
            this.offset = this.currentWidget.getOffset(element, index);
        }
    };
    /**
     * Set text position
     * @private
     */
    TextPosition.prototype.setPositionFromLine = function (line, offset, location) {
        this.currentWidget = line;
        this.offset = offset;
        if (location instanceof Point) {
            this.location.copy(location);
        }
    };
    /**
     * Set text position
     * @private
     */
    TextPosition.prototype.setPosition = function (line, positionAtStart) {
        this.currentWidget = line;
        this.offset = positionAtStart ? this.selection.getStartOffset(line.paragraph)
            : line.paragraph.lastChild.getEndOffset() + 1;
        this.updatePhysicalPosition(true);
    };
    /**
     * Set position for text position
     * @private
     */
    TextPosition.prototype.setPositionInternal = function (textPosition) {
        this.currentWidget = textPosition.currentWidget;
        this.offset = textPosition.offset;
        this.location = textPosition.location;
    };
    /**
     * Set position for current index
     * @private
     */
    TextPosition.prototype.setPositionForCurrentIndex = function (hierarchicalIndex) {
        var index = { index: hierarchicalIndex };
        var paragraph = this.getParagraphWidget(index); //ref hierarchicalIndex
        this.offset = parseFloat(index.index);
        this.setPositionParagraph(paragraph, this.offset);
    };
    /**
     * Get Page
     */
    TextPosition.prototype.getPage = function (position) {
        var page;
        var index = position.index.indexOf(';');
        var newValue = '0';
        if (index >= 0) {
            newValue = position.index.substring(0, index);
            position.index = position.index.substring(index).replace(';', '');
        }
        index = parseInt(newValue, 10);
        page = this.viewer.pages[index];
        return page;
    };
    /**
     * @private
     */
    TextPosition.prototype.getParagraphWidget = function (position) {
        if (isNullOrUndefined(position.index)) {
            return undefined;
        }
        var page = this.getPage(position);
        var child = this.getLineWidget(undefined, position, page);
        return child;
    };
    /**
     * @private
     */
    TextPosition.prototype.getLineWidget = function (widget, position, page) {
        if (isNullOrUndefined(position.index)) {
            return undefined;
        }
        var index = position.index.indexOf(';');
        var value = '0';
        if (index >= 0) {
            value = position.index.substring(0, index);
            position.index = position.index.substring(index).replace(';', '');
        }
        if (value === 'H' || value === 'F') {
            if (value === 'H') {
                widget = page.headerWidget;
            }
            else {
                widget = page.footerWidget;
            }
        }
        else if (!isNullOrUndefined(page)) {
            widget = page.bodyWidgets[0];
        }
        index = parseInt(value, 10);
        if (widget instanceof BlockContainer) {
            index = position.index.indexOf(';');
            value = '0';
            value = position.index.substring(0, index);
            position.index = position.index.substring(index).replace(';', '');
            index = parseInt(value, 10);
        }
        if (widget instanceof TableRowWidget && index >= widget.childWidgets.length) {
            position.index = '0;0';
            index = widget.childWidgets.length - 1;
        }
        if (index >= 0 && index < widget.childWidgets.length) {
            var child = widget.childWidgets[index];
            if (child instanceof LineWidget) {
                if (position.index.indexOf(';') > 0) {
                    position.index = '0';
                }
                return child;
            }
            if (child instanceof Widget) {
                if (position.index.indexOf(';') > 0) {
                    return this.getLineWidget(child, position);
                }
                else {
                    //If table is shifted to previous text position then return the first paragraph within table.
                    if (child instanceof TableWidget) {
                        return this.getLineWidget(this.selection.getFirstParagraphInFirstCell(child), position);
                    }
                    else if (child instanceof TableRowWidget && position.index.indexOf(';') === -1) {
                        return this.selection.getFirstParagraphInFirstCell(child.ownerTable).childWidgets[0];
                    }
                    return undefined;
                }
            }
        }
        else if (widget.nextRenderedWidget instanceof Widget) {
            position.index = '0';
            if (widget.nextRenderedWidget instanceof TableWidget) {
                return this.selection.getFirstParagraphInFirstCell(widget.nextRenderedWidget).firstChild;
            }
            return this.getLineWidget(widget.nextRenderedWidget, position);
        }
        return undefined;
    };
    /**
     * Update physical location of paragraph
     * @private
     */
    TextPosition.prototype.updatePhysicalPosition = function (moveNextLine) {
        if (this.currentWidget && this.owner.isLayoutEnabled && this.isUpdateLocation) {
            this.location = this.selection.getPhysicalPositionInternal(this.currentWidget, this.offset, moveNextLine);
        }
    };
    /**
     * Return true if text position are in same paragraph and offset
     * @private
     */
    TextPosition.prototype.isAtSamePosition = function (textPosition) {
        return this.currentWidget === textPosition.currentWidget
            && this.offset === textPosition.offset;
    };
    /**
     * Return true if text position is in same paragraph
     * @private
     */
    TextPosition.prototype.isInSameParagraph = function (textPosition) {
        if (isNullOrUndefined(textPosition)) {
            throw new Error('textPosition is undefined.');
        }
        return this.paragraph === textPosition.paragraph;
    };
    /**
     * Return true is current text position exist before given text position
     * @private
     */
    TextPosition.prototype.isExistBefore = function (textPosition) {
        if (isNullOrUndefined(textPosition)) {
            throw new Error('textPosition is undefined.');
        }
        if (this.currentWidget === textPosition.currentWidget) {
            return this.offset < textPosition.offset;
        }
        var currentParagraph = this.currentWidget.paragraph;
        var paragraph = textPosition.currentWidget.paragraph;
        if (currentParagraph === paragraph) {
            return currentParagraph.childWidgets.indexOf(this.currentWidget) < paragraph.childWidgets.indexOf(textPosition.currentWidget);
        }
        if (currentParagraph.containerWidget === paragraph.containerWidget) {
            if (currentParagraph.isInsideTable) {
                return currentParagraph.associatedCell.childWidgets.indexOf(currentParagraph) <
                    paragraph.associatedCell.childWidgets.indexOf(paragraph);
                //handle after header footer implementation
                // } else if ((this.currentParagraph).owner instanceof WHeaderFooter) {
                //     return ((this.currentParagraph).owner as WHeaderFooter).blocks.indexOf((this.currentParagraph)) <
                //         ((textPosition.currentParagraph).owner as WHeaderFooter).blocks.indexOf((textPosition.currentParagraph));
            }
            else {
                return (currentParagraph.containerWidget.childWidgets.indexOf(currentParagraph)) <
                    (paragraph.containerWidget.childWidgets.indexOf(paragraph));
            }
        }
        return this.owner.selection.isExistBefore(currentParagraph, paragraph);
    };
    /**
     * Return true is current text position exist after given text position
     * @private
     */
    TextPosition.prototype.isExistAfter = function (textPosition) {
        if (isNullOrUndefined(textPosition)) {
            throw new Error('textPosition is undefined.');
        }
        if (this.currentWidget === textPosition.currentWidget) {
            return this.offset > textPosition.offset;
        }
        if (this.currentWidget.paragraph === textPosition.currentWidget.paragraph) {
            return this.currentWidget.paragraph.childWidgets.indexOf(this.currentWidget) >
                textPosition.currentWidget.paragraph.childWidgets.indexOf(textPosition.currentWidget);
        }
        var startParagraph = this.currentWidget.paragraph;
        var endParagraph = textPosition.currentWidget.paragraph;
        if (startParagraph.containerWidget instanceof BodyWidget && endParagraph.containerWidget instanceof BodyWidget &&
            startParagraph.containerWidget === endParagraph.containerWidget) {
            if (startParagraph.isInsideTable && endParagraph.isInsideTable) {
                return startParagraph.associatedCell.childWidgets.indexOf(startParagraph) >
                    endParagraph.associatedCell.childWidgets.indexOf(endParagraph);
                // } else if ((this.currentParagraph).owner instanceof WHeaderFooter) {
                //     return ((this.currentParagraph).owner as WHeaderFooter).blocks.indexOf((this.currentParagraph)) >
                //         ((textPosition.currentParagraph).owner as WHeaderFooter).blocks.indexOf((textPosition.currentParagraph));
            }
            else {
                return (startParagraph.containerWidget.childWidgets.indexOf(startParagraph) >
                    (endParagraph.containerWidget.childWidgets.indexOf(endParagraph)));
            }
        }
        return this.owner.selection.isExistAfter(startParagraph, endParagraph);
    };
    /**
     * Return hierarchical index of current text position
     * @private
     */
    TextPosition.prototype.getHierarchicalIndexInternal = function () {
        return this.getHierarchicalIndex(this.currentWidget, this.offset.toString());
    };
    /**
     * @private
     */
    TextPosition.prototype.getHierarchicalIndex = function (line, hierarchicalIndex) {
        var node = line;
        if (node) {
            return node.getHierarchicalIndex(hierarchicalIndex);
        }
        return hierarchicalIndex;
    };
    /**
     * @private
     */
    TextPosition.prototype.setPositionParagraph = function (line, offsetInLine) {
        this.currentWidget = line;
        this.offset = offsetInLine;
        this.updatePhysicalPosition(true);
    };
    /**
     * @private
     */
    TextPosition.prototype.setPositionForLineWidget = function (lineWidget, offset) {
        var lineLength = this.selection.getLineLength(lineWidget);
        var lineIndex = lineWidget.paragraph.childWidgets.indexOf(lineWidget);
        if (lineWidget.isLastLine()) {
            lineLength = lineLength + 1;
        }
        if (offset > lineLength) {
            var nextLineWidget = void 0;
            if (lineIndex >= lineWidget.paragraph.childWidgets.length - 1) {
                var nextBlock = this.selection.getNextRenderedBlock(lineWidget.paragraph);
                if (nextBlock && nextBlock.index === lineWidget.paragraph.index) {
                    nextLineWidget = nextBlock.firstChild;
                }
            }
            else {
                nextLineWidget = lineWidget.paragraph.childWidgets[lineIndex + 1];
            }
            this.setPositionForLineWidget(nextLineWidget, offset - lineLength);
            return;
        }
        else if (offset < 0) {
            var prevLine = lineWidget.paragraph.childWidgets[lineIndex - 1];
            var currentOffSet = this.selection.getLineLength(prevLine) + offset;
            this.setPositionForLineWidget(prevLine, currentOffSet);
            return;
        }
        else {
            this.currentWidget = lineWidget;
            this.offset = offset;
        }
        this.updatePhysicalPosition(true);
    };
    /**
     * move to next text position
     * @private
     */
    TextPosition.prototype.moveNextPosition = function (isNavigate) {
        if (isNullOrUndefined(isNavigate)) {
            isNavigate = true;
        }
        var inline = this.selection.getNextStartInline(this.currentWidget, this.offset);
        if (inline instanceof FieldElementBox && inline.fieldType === 0 && !isNullOrUndefined(inline.fieldEnd)) {
            if (isNavigate) {
                this.moveNextPositionInternal(inline);
                this.moveNextPosition();
                return;
            }
            else {
                var line = inline.fieldEnd.line;
                var fieldEnd = inline.fieldEnd;
                var fieldEndOffset = line.getOffset(fieldEnd, 1);
                var fieldEndIndex = this.getHierarchicalIndex(line, fieldEndOffset.toString());
                if (TextPosition.isForwardSelection(this.selection.end.getHierarchicalIndexInternal(), fieldEndIndex)) {
                    //If field end is after selection end, extend selection end to field end.
                    this.selection.end.moveToInline(inline.fieldEnd, 1);
                    return;
                }
                this.moveToInline(inline.fieldEnd, 1);
            }
        }
        var nextOffset = this.selection.getNextValidOffset(this.currentWidget, this.offset);
        var lineIndex = this.paragraph.childWidgets.indexOf(this.currentWidget);
        var index = 0;
        if (nextOffset > this.offset) {
            this.offset = nextOffset;
            var info = this.currentWidget.getInline(this.offset, index);
            inline = info.element;
            index = info.index;
            if (!isNullOrUndefined(inline) && index === inline.length && (inline.nextNode instanceof FieldElementBox
                || inline.nextNode instanceof BookmarkElementBox)) {
                var nextValidInline = this.selection.getNextValidElement(inline.nextNode);
                //Moves to field end mark or Bookmark end.
                if (nextValidInline instanceof FieldElementBox && nextValidInline.fieldType === 1
                    || nextValidInline instanceof BookmarkElementBox && nextValidInline.bookmarkType === 1) {
                    inline = nextValidInline;
                    this.offset = this.currentWidget.getOffset(inline, 1);
                }
            }
        }
        else if (lineIndex + 1 < this.paragraph.childWidgets.length) {
            var nextLineWidget = this.paragraph.childWidgets[lineIndex + 1];
            if (nextLineWidget) {
                this.currentWidget = nextLineWidget;
                this.offset = this.selection.getStartLineOffset(this.currentWidget);
            }
            var inlineObj = this.currentWidget.getInline(this.offset, index);
            inline = inlineObj.element;
            index = inlineObj.index;
            if (inline instanceof FieldElementBox && inline.fieldType === 0) {
                this.offset++;
            }
        }
        else {
            this.updateOffsetToNextParagraph(index, false);
        }
        //Gets physical position in current page.
        this.updatePhysicalPosition(true);
    };
    /**
     * Move text position to previous paragraph inside table
     * @private
     */
    TextPosition.prototype.moveToPreviousParagraphInTable = function (selection) {
        var previousParagraph;
        var currentPara = this.currentWidget.paragraph;
        if (currentPara.isInsideTable) {
            previousParagraph = selection.getPreviousSelectionCell(currentPara.associatedCell);
        }
        else {
            previousParagraph = selection.getPreviousParagraphBlock(currentPara);
        }
        if (isNullOrUndefined(previousParagraph)) {
            return;
        }
        this.currentWidget = previousParagraph.childWidgets[previousParagraph.childWidgets.length - 1];
        this.offset = this.currentWidget.getEndOffset() + 1;
    };
    TextPosition.prototype.updateOffsetToNextParagraph = function (indexInInline, isHighlight) {
        //Moves to owner and get next paragraph.
        var inline;
        var positionAtStart = false;
        var nextParagraph = undefined;
        var lineIndex = this.paragraph.childWidgets.indexOf(this.currentWidget);
        if (!isHighlight) {
            nextParagraph = this.selection.getNextParagraphBlock(this.paragraph);
        }
        else if (lineIndex + 1 < this.paragraph.childWidgets.length) {
            var nextLineWidget = this.paragraph.childWidgets[lineIndex + 1];
            if (nextLineWidget) {
                this.currentWidget = nextLineWidget;
                this.offset = 1;
            }
        }
        else {
            nextParagraph = this.selection.getNextSelectionBlock(this.paragraph);
            if (!isNullOrUndefined(nextParagraph)) {
                if (nextParagraph.containerWidget instanceof TableCellWidget) {
                    if (this.selection.start.paragraph.isInsideTable) {
                        // tslint:disable-next-line:max-line-length
                        var containerCell = this.selection.getContainerCellOf(this.selection.start.paragraph.associatedCell, nextParagraph.associatedCell);
                        positionAtStart = !containerCell.ownerTable.contains(nextParagraph.associatedCell);
                    }
                    else {
                        positionAtStart = true;
                    }
                }
            }
        }
        if (!isNullOrUndefined(nextParagraph) && nextParagraph.childWidgets.length > 0) {
            if (!positionAtStart) {
                this.currentWidget = nextParagraph.firstChild;
                this.offset = isHighlight ? 1 : this.selection.getStartLineOffset(this.currentWidget);
            }
            else {
                this.currentWidget = nextParagraph.childWidgets[nextParagraph.childWidgets.length - 1];
                this.offset = this.selection.getLineLength(this.currentWidget) + 1;
            }
        }
        var inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
        inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            this.offset++;
        }
    };
    TextPosition.prototype.updateOffsetToPrevPosition = function (index, isHighlight) {
        var inlineInfo;
        var inline;
        var lineIndex = this.paragraph.childWidgets.indexOf(this.currentWidget);
        var prevOffset = this.selection.getPreviousValidOffset(this.currentWidget.paragraph, this.offset);
        if (this.offset > prevOffset) {
            this.offset = prevOffset;
        }
        else if (lineIndex > 0) {
            var prevLineWidget = this.paragraph.childWidgets[lineIndex - 1];
            if (prevLineWidget) {
                this.currentWidget = prevLineWidget;
                var endOffset = this.currentWidget.getEndOffset();
                this.offset = endOffset > 0 ? endOffset - 1 : endOffset;
            }
        }
        else {
            //Moves to owner and get previous paragraph.
            var previousParagraph = undefined;
            var positionAtStart = false;
            if (!isHighlight) {
                previousParagraph = this.selection.getPreviousParagraphBlock(this.paragraph);
            }
            else {
                previousParagraph = this.selection.getPreviousSelectionBlock(this.paragraph);
                if (!isNullOrUndefined(previousParagraph)) {
                    if (previousParagraph.containerWidget instanceof TableCellWidget) {
                        if (this.selection.start.paragraph.isInsideTable) {
                            // tslint:disable-next-line:max-line-length
                            var containerCell = this.selection.getContainerCellOf(this.selection.start.paragraph.associatedCell, previousParagraph.associatedCell);
                            positionAtStart = !containerCell.ownerTable.contains(previousParagraph.associatedCell);
                        }
                        else {
                            positionAtStart = true;
                        }
                    }
                }
            }
            if (!isNullOrUndefined(previousParagraph)) {
                if (!positionAtStart) {
                    this.currentWidget = previousParagraph.childWidgets[previousParagraph.childWidgets.length - 1];
                    this.offset = this.currentWidget.getEndOffset();
                }
                else {
                    this.currentWidget = previousParagraph.firstChild;
                    this.offset = this.selection.getStartLineOffset(this.currentWidget);
                }
            }
        }
        index = 0;
        inlineInfo = this.currentWidget.getInline(this.offset, index);
        inline = inlineInfo.element;
        index = inlineInfo.index;
        if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            this.offset++;
        }
        if (inline instanceof FieldElementBox) {
            //Checks if field character is part of rendered field, otherwise moves to previous rendered content.
            var previousInline = this.selection.getPreviousValidElement(inline);
            if (!isNullOrUndefined(previousInline)) {
                inline = previousInline;
                this.currentWidget = inline.line;
                this.offset = this.currentWidget.getOffset(inline, inline.length);
                if (inline instanceof FieldElementBox && inline.fieldType === 0) {
                    this.offset--;
                }
            }
        }
        //Gets physical position in current page.
        this.updatePhysicalPosition(true);
    };
    /**
     * Moves the text position to start of the next paragraph.
     */
    TextPosition.prototype.moveToNextParagraphStartInternal = function () {
        var paragraph = this.currentWidget.paragraph;
        if (!isNullOrUndefined(this.selection.getNextParagraphBlock(paragraph))) {
            // tslint:disable-next-line:max-line-length
            this.currentWidget = this.selection.getNextParagraphBlock(paragraph).firstChild;
            this.offset = this.selection.getStartOffset(paragraph);
            this.updatePhysicalPosition(true);
        }
    };
    /**
     * Move to previous position
     * @private
     */
    TextPosition.prototype.movePreviousPosition = function () {
        var index = 0;
        var inlineInfo = this.currentWidget.getInline(this.offset, index);
        var inline = inlineInfo.element;
        index = inlineInfo.index;
        var lineIndex = this.paragraph.childWidgets.indexOf(this.currentWidget);
        if (inline instanceof FieldElementBox && inline.fieldType === 1 && !isNullOrUndefined(inline.fieldBegin)) {
            this.movePreviousPositionInternal(inline);
        }
        this.updateOffsetToPrevPosition(index, false);
    };
    /**
     * Move to next position
     * @private
     */
    TextPosition.prototype.moveNextPositionInternal = function (fieldBegin) {
        var inline;
        if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
            inline = fieldBegin.fieldEnd;
        }
        else {
            inline = fieldBegin.fieldSeparator;
            this.currentWidget = inline.line;
            // tslint:disable-next-line:max-line-length
            if (this.currentWidget === fieldBegin.fieldEnd.line && !this.selection.hasValidInline(this.paragraph, inline, fieldBegin.fieldEnd)) {
                inline = fieldBegin.fieldEnd;
            }
        }
        this.currentWidget = inline.line;
        this.offset = this.currentWidget.getOffset(inline, 1);
    };
    /**
     * Move text position backward
     * @private
     */
    TextPosition.prototype.moveBackward = function () {
        var indexInInline = 0;
        var inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
        var inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (!this.owner.selection.isEmpty && !isNullOrUndefined(inline)) {
            var nextInline = this.selection.getNextRenderedElementBox(inline, indexInInline);
            if (nextInline instanceof FieldElementBox && nextInline.fieldType === 0) {
                var hierarchicalIndex = this.owner.selection.start.getHierarchicalIndexInternal();
                // tslint:disable-next-line:max-line-length
                var fieldEndOffset = nextInline.fieldEnd.line.getOffset(nextInline.fieldEnd, 1);
                // tslint:disable-next-line:max-line-length
                var fieldEndIndex = this.getHierarchicalIndex(nextInline.fieldEnd.line, fieldEndOffset.toString());
                if (!TextPosition.isForwardSelection(fieldEndIndex, hierarchicalIndex)) {
                    //If field end is after selection start, move selection start to field end.
                    // tslint:disable-next-line:max-line-length
                    this.owner.selection.start.setPositionParagraph(nextInline.fieldEnd.line, fieldEndOffset);
                    return;
                }
            }
        }
        if (inline instanceof FieldElementBox && inline.fieldType === 1 && !isNullOrUndefined(inline.fieldBegin)) {
            var hierarchicalIndex = this.owner.selection.start.getHierarchicalIndexInternal();
            var fieldEndOffset = inline.line.getOffset(inline, 1);
            var fieldEndIndex = this.getHierarchicalIndex(inline.line, fieldEndOffset.toString());
            if (!TextPosition.isForwardSelection(hierarchicalIndex, fieldEndIndex)) {
                //If field end is after selection start, extend selection end to field begin.
                // tslint:disable-next-line:max-line-length
                var fieldBeginOffset = inline.fieldBegin.line.getOffset(inline.fieldBegin, 0);
                this.currentWidget = inline.fieldBegin.line;
                this.offset = fieldBeginOffset;
                //Updates physical position in current page.
                this.updatePhysicalPosition(true);
                return;
            }
            this.movePreviousPositionInternal(inline);
        }
        this.updateOffsetToPrevPosition(indexInInline, true);
    };
    /**
     * Move text position forward
     * @private
     */
    TextPosition.prototype.moveForward = function () {
        var indexInInline = 0;
        var inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
        var inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (!isNullOrUndefined(inline)) {
            if (!this.owner.selection.isEmpty && indexInInline === inline.length && inline instanceof FieldElementBox
                && inline.fieldType === 1) {
                var hierarchicalIndex = this.owner.selection.start.getHierarchicalIndexInternal();
                // tslint:disable-next-line:max-line-length
                var fieldBeginOffset = inline.fieldBegin.line.getOffset(inline.fieldBegin, 0);
                // tslint:disable-next-line:max-line-length
                var fieldBeginIndex = this.getHierarchicalIndex(inline.fieldBegin.line, fieldBeginOffset.toString());
                if (!TextPosition.isForwardSelection(hierarchicalIndex, fieldBeginIndex)) {
                    //If field begin is before selection start, move selection start to field begin.
                    // tslint:disable-next-line:max-line-length
                    this.owner.selection.start.setPositionParagraph(inline.fieldBegin.line, fieldBeginOffset);
                    return;
                }
            }
            inline = this.selection.getNextRenderedElementBox(inline, indexInInline);
        }
        if (inline instanceof FieldElementBox && !isNullOrUndefined(inline.fieldEnd)) {
            var selectionStartParagraph = this.owner.selection.start.paragraph;
            var selectionStartIndex = 0;
            // tslint:disable-next-line:max-line-length
            var selectionStartInlineObj = selectionStartParagraph.getInline(this.owner.selection.start.offset, selectionStartIndex);
            var selectionStartInline = selectionStartInlineObj.element;
            selectionStartIndex = selectionStartInlineObj.index;
            var nextRenderInline = this.selection.getNextRenderedElementBox(selectionStartInline, selectionStartIndex);
            if (nextRenderInline === inline) {
                this.moveNextPositionInternal(inline);
            }
            else {
                //If selection start is before field begin, extend selection end to field end.
                inline = inline.fieldEnd;
                this.currentWidget = inline.line;
                this.offset = this.currentWidget.getOffset(inline, 1);
                //Updates physical position in current page.
                this.updatePhysicalPosition(true);
                return;
            }
        }
        else if ((inline instanceof FieldElementBox)
            && (inline.fieldType === 0 || inline.fieldType === 1)) {
            this.currentWidget = inline.line;
            this.offset = this.currentWidget.getOffset(inline, 1);
        }
        indexInInline = 0;
        var nextOffset = this.selection.getNextValidOffset(this.currentWidget, this.offset);
        var length = this.selection.getLineLength(this.currentWidget);
        var isParagraphEnd = this.selection.isParagraphLastLine(this.currentWidget);
        if (this.offset < nextOffset) {
            this.offset = nextOffset;
            var inlineObj_1 = this.currentWidget.getInline(this.offset, indexInInline);
            inline = inlineObj_1.element;
            indexInInline = inlineObj_1.index;
            if (!isNullOrUndefined(inline) && indexInInline === inline.length && inline.nextNode instanceof FieldElementBox) {
                var nextValidInline = this.selection.getNextValidElement(inline.nextNode);
                //Moves to field end mark.
                if (nextValidInline instanceof FieldElementBox && nextValidInline.fieldType === 1) {
                    inline = nextValidInline;
                    this.offset = this.currentWidget.getOffset(inline, 1);
                }
            }
        }
        else if (this.offset === nextOffset && this.offset < length + 1 && isParagraphEnd) {
            this.offset = length + 1;
        }
        else {
            this.updateOffsetToNextParagraph(indexInInline, true);
        }
        //Gets physical position in current page.
        this.updatePhysicalPosition(true);
    };
    /**
     * Move to given inline
     * @private
     */
    TextPosition.prototype.moveToInline = function (inline, index) {
        this.currentWidget = inline.line;
        this.offset = this.currentWidget.getOffset(inline, index);
        //Updates physical position in current page.
        this.updatePhysicalPosition(true);
    };
    /**
     * Return true is start element exist before end element
     * @private
     */
    TextPosition.isForwardSelection = function (start, end) {
        if (start === end) {
            return true;
        }
        start = start.replace(/C;/g, '');
        end = end.replace(/C;/g, '');
        start = start.replace(/H;/g, '');
        end = end.replace(/H;/g, '');
        start = start.replace(/F;/g, '');
        end = end.replace(/F;/g, '');
        var selectionStart = start.split(';');
        var selectionEnd = end.split(';');
        var length = selectionStart.length;
        if (length > selectionEnd.length) {
            length = selectionEnd.length - 1;
        }
        for (var i = 0; i < length; i++) {
            var startOffset = parseFloat(selectionStart[i]);
            var endOffset = parseFloat(selectionEnd[i]);
            if (startOffset !== endOffset) {
                return startOffset < endOffset;
            }
        }
        return false;
    };
    /**
     * Move to previous position offset
     * @private
     */
    TextPosition.prototype.movePreviousPositionInternal = function (fieldEnd) {
        var inline;
        if (isNullOrUndefined(fieldEnd.fieldSeparator)) {
            inline = this.selection.getPreviousValidElement(fieldEnd.fieldBegin);
        }
        else {
            inline = this.selection.getPreviousValidElement(fieldEnd);
        }
        this.currentWidget = inline.line;
        this.offset = this.currentWidget.getOffset(inline, inline instanceof FieldElementBox ? 0 : inline.length);
    };
    /**
     * Moves the text position to start of the word.
     * @private
     */
    TextPosition.prototype.moveToWordStartInternal = function (type) {
        var endOffset = this.currentWidget.getEndOffset();
        var currentPara = this.currentWidget.paragraph;
        var selection = this.selection;
        if (type === 2 && (this.offset === endOffset || this.offset === endOffset + 1)) {
            return;
        }
        if (this.offset === endOffset + 1) {
            this.offset = endOffset;
        }
        else if (this.offset === selection.getStartOffset(currentPara) && this.currentWidget === currentPara.childWidgets[0]) {
            var previousParagraph = selection.getPreviousParagraphBlock(currentPara);
            if (isNullOrUndefined(previousParagraph)) {
                return;
            }
            this.currentWidget = previousParagraph.childWidgets[previousParagraph.childWidgets.length - 1];
            this.offset = this.currentWidget.getEndOffset();
        }
        else {
            if (this.offset === selection.getStartLineOffset(this.currentWidget)) {
                var lineIndex = currentPara.childWidgets.indexOf(this.currentWidget);
                if (lineIndex - 1 >= 0) {
                    this.currentWidget = currentPara.childWidgets[lineIndex - 1];
                    this.offset = this.currentWidget.getEndOffset();
                }
            }
            var isStarted = false;
            var endSelection = false;
            var indexInInline = 0;
            var inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
            var inline = inlineObj.element;
            indexInInline = inlineObj.index;
            // tslint:disable-next-line:max-line-length           
            this.getPreviousWordOffset(inline, selection, indexInInline, type, (inline instanceof FieldElementBox && inline.fieldType === 1), isStarted, endSelection, this);
        }
        if (type === 1) {
            this.calculateOffset();
        }
        this.updatePhysicalPosition(true);
    };
    /**
     * Get next word offset
     * @private
     */
    // tslint:disable-next-line:max-line-length
    TextPosition.prototype.getNextWordOffset = function (inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        if (inline instanceof TextElementBox) {
            this.getNextWordOffsetSpan(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (inline instanceof ImageElementBox) {
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffsetImage(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffsetFieldBegin(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 2 || inline instanceof BookmarkElementBox) {
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffsetFieldSeperator(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 1) {
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffsetFieldEnd(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace);
        }
    };
    /**
     * get next word offset from field begin
     * @private
     */
    // tslint:disable-next-line:max-line-length
    TextPosition.prototype.getNextWordOffsetFieldBegin = function (fieldBegin, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        var startOffset = fieldBegin.line.getOffset(fieldBegin, 0);
        var endOffset = startOffset + fieldBegin.length;
        if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
            this.getNextWordOffsetFieldEnd(fieldBegin.fieldEnd, 0, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (type === 0) {
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffsetFieldSeperator(fieldBegin.fieldSeparator, 0, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (!isNullOrUndefined(fieldBegin.fieldEnd)) {
            var inline = fieldBegin.fieldSeparator;
            // tslint:disable-next-line:max-line-length
            if (inline.line.paragraph === fieldBegin.fieldEnd.line.paragraph && !this.selection.hasValidInline(inline.line.paragraph, inline, fieldBegin.fieldEnd)) {
                inline = fieldBegin.fieldEnd;
            }
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffset(inline, 0, type, !(endPosition.paragraph === fieldBegin.line.paragraph && endPosition.offset === startOffset), endSelection, endPosition, excludeSpace);
            // tslint:disable-next-line:max-line-length
            if (endSelection && !isNullOrUndefined(fieldBegin.fieldSeparator) && (endPosition.paragraph === fieldBegin.line.paragraph) && (endPosition.offset === fieldBegin.fieldSeparator.line.getOffset(fieldBegin.fieldSeparator, fieldBegin.fieldSeparator.length))) {
                endPosition.setPositionParagraph(fieldBegin.line, startOffset);
                return;
            }
            if (!endSelection) {
                // tslint:disable-next-line:max-line-length
                endPosition.setPositionParagraph(fieldBegin.fieldEnd.line, fieldBegin.fieldEnd.line.getOffset(fieldBegin.fieldEnd, fieldBegin.fieldEnd.length));
            }
        }
    };
    /**
     * get next word offset from image
     * @private
     */
    // tslint:disable-next-line:max-line-length
    TextPosition.prototype.getNextWordOffsetImage = function (image, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        if (isInField) {
            endPosition.setPositionParagraph(image.line, image.line.getOffset(image, indexInInline));
            endSelection = false;
            return;
        }
        if (indexInInline === 0) {
            var startOffset = image.line.getOffset(image, 0);
            endSelection = true;
            if (endPosition.offset === startOffset) {
                if (isNullOrUndefined(image.nextNode)) {
                    endPosition.setPositionParagraph(image.line, startOffset + image.length);
                }
                else {
                    this.getNextWordOffset(image.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
                }
            }
            else {
                endPosition.setPositionParagraph(image.line, startOffset);
            }
        }
        else if (!isNullOrUndefined(image.nextNode)) {
            this.getNextWordOffset(image.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
        }
    };
    /**
     * get next word offset from span
     */
    // tslint:disable-next-line:max-line-length
    TextPosition.prototype.getNextWordOffsetSpan = function (span, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        if (span.text === '\t' || span.text === '\v') {
            if (isInField) {
                endPosition.setPositionParagraph(span.line, span.line.getOffset(span, indexInInline));
                endSelection = false;
                return;
            }
            if (indexInInline === 0) {
                endSelection = true;
                var startOffset = span.line.getOffset(span, 0);
                if (endPosition.offset === startOffset) {
                    endPosition.setPositionParagraph(span.line, startOffset + span.length);
                }
                else {
                    endPosition.setPositionParagraph(span.line, startOffset);
                }
            }
            else if (!isNullOrUndefined(span.nextNode)) {
                this.getNextWordOffset(span.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
            }
        }
        else {
            var wordEndIndex = 0;
            if (indexInInline === 0 && endSelection && (HelperMethods.wordSplitCharacters.indexOf(span.text[0]) === -1)) {
                endPosition.setPositionParagraph(span.line, span.line.getOffset(span, indexInInline));
                if (isInField) {
                    return;
                }
            }
            else if (indexInInline < span.length) {
                // tslint:disable-next-line:max-line-length
                var txt = indexInInline > 0 && span.text.length - 1 >= indexInInline ? span.text.slice(indexInInline, span.length) : span.text;
                wordEndIndex = HelperMethods.indexOfAny(txt, HelperMethods.wordSplitCharacters);
                if (wordEndIndex !== -1) {
                    if (isInField) {
                        endSelection = false;
                        return;
                    }
                    var offset = span.line.getOffset(span, wordEndIndex + indexInInline);
                    // tslint:disable-next-line:max-line-length
                    if ((excludeSpace || txt[wordEndIndex] !== ' ') && !endSelection && span.line.paragraph === endPosition.paragraph && offset !== endPosition.offset) {
                        endSelection = true;
                        endPosition.setPositionParagraph(span.line, offset);
                        return;
                    }
                    wordEndIndex++;
                    while (wordEndIndex < txt.length && HelperMethods.wordSplitCharacters.indexOf(txt[wordEndIndex]) !== -1) {
                        if (txt[wordEndIndex] !== ' ' && txt[wordEndIndex] !== '') {
                            break;
                        }
                        wordEndIndex++;
                    }
                    endSelection = true;
                    if (wordEndIndex < txt.length) {
                        // tslint:disable-next-line:max-line-length
                        endPosition.setPositionParagraph(span.line, span.line.getOffset(span, wordEndIndex + indexInInline));
                    }
                    else if (!isNullOrUndefined(span.nextNode)) {
                        // tslint:disable-next-line:max-line-length
                        this.getNextWordOffset(span.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
                    }
                    else {
                        // tslint:disable-next-line:max-line-length
                        endPosition.setPositionParagraph(span.line, span.line.getOffset(span, wordEndIndex + indexInInline));
                    }
                }
                else if (!isNullOrUndefined(span.nextNode)) {
                    this.getNextWordOffset(span.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
                }
                else {
                    endPosition.setPositionParagraph(span.line, span.line.getEndOffset());
                }
            }
            else if (!isNullOrUndefined(span.nextNode)) {
                this.getNextWordOffset(span.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
            }
        }
    };
    /**
     * get next word offset from field separator
     * @private
     */
    // tslint:disable-next-line:max-line-length
    TextPosition.prototype.getNextWordOffsetFieldSeperator = function (fieldSeparator, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        if (!isNullOrUndefined(fieldSeparator.nextNode)) {
            this.getNextWordOffset(fieldSeparator.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
        }
    };
    /**
     * get next word offset from field end
     * @private
     */
    // tslint:disable-next-line:max-line-length
    TextPosition.prototype.getNextWordOffsetFieldEnd = function (fieldEnd, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        var startOffset = fieldEnd.line.getOffset(fieldEnd, 0);
        var endOffset = startOffset + fieldEnd.length;
        if (endPosition.offset === startOffset) {
            endPosition.setPositionParagraph(fieldEnd.line, endOffset);
            if (isNullOrUndefined(fieldEnd.nextNode)) {
                return;
            }
        }
        if (!isNullOrUndefined(fieldEnd.nextNode)) {
            this.getNextWordOffset(fieldEnd.nextNode, 0, type, false, endSelection, endPosition, excludeSpace);
            if (endPosition.offset === endOffset) {
                endPosition.setPositionParagraph(fieldEnd.line, startOffset);
            }
        }
        else {
            endPosition.setPositionParagraph(fieldEnd.line, startOffset);
        }
        endSelection = true;
    };
    /**
     * Get previous word offset
     * @private
     */
    // tslint:disable-next-line:max-line-length
    TextPosition.prototype.getPreviousWordOffset = function (inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        if (inline instanceof TextElementBox) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetSpan(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof ImageElementBox) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetImage(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetFieldBegin(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 2) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetFieldSeparator(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 1) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetFieldEnd(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof BookmarkElementBox) {
            this.getPreviousWordOffsetBookMark(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof ListTextElementBox && inline.previousNode) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetSpan(inline.previousNode, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
    };
    // tslint:disable-next-line:max-line-length
    TextPosition.prototype.getPreviousWordOffsetBookMark = function (bookmark, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        if (bookmark.previousNode) {
            if (bookmark.previousNode instanceof TextElementBox) {
                var inline = bookmark.previousNode;
                if (HelperMethods.lastIndexOfAny(inline.text, HelperMethods.wordSplitCharacters) !== inline.text.length - 1) {
                    this.getPreviousWordOffset(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
                }
                else {
                    endPosition.setPositionParagraph(bookmark.line, bookmark.line.getOffset(bookmark, 0));
                }
            }
        }
        else {
            endPosition.setPositionParagraph(bookmark.line, selection.getStartLineOffset(bookmark.line));
        }
    };
    /**
     * get previous word offset from field end
     * @private
     */
    // tslint:disable-next-line:max-line-length
    TextPosition.prototype.getPreviousWordOffsetFieldEnd = function (fieldEnd, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        var startOffset = fieldEnd.line.getOffset(fieldEnd, 0);
        var endOffset = startOffset + fieldEnd.length;
        if (isNullOrUndefined(fieldEnd.fieldSeparator)) {
            this.getPreviousWordOffsetFieldBegin(fieldEnd.fieldBegin, selection, 0, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (type === 0 && !isNullOrUndefined(fieldEnd.previousNode)) {
            var inline = fieldEnd.previousNode;
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffset(inline, selection, inline.length, type, (inline instanceof FieldElementBox && inline.fieldType === 1), isStarted, endSelection, endPosition);
        }
        else if (!isNullOrUndefined(fieldEnd.fieldBegin) && type !== 0) {
            var inline = fieldEnd.previousNode;
            // tslint:disable-next-line:max-line-length
            if (isNullOrUndefined(inline) || (inline.line.paragraph === fieldEnd.fieldBegin.line.paragraph && !selection.hasValidInline(inline.line.paragraph, inline, fieldEnd.fieldBegin))) {
                inline = fieldEnd.fieldBegin;
            }
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffset(inline, selection, inline.length, type, !(endPosition.paragraph === fieldEnd.line.paragraph && endPosition.offset === endOffset), isStarted, endSelection, endPosition);
            if (endSelection && endPosition.paragraph === fieldEnd.line.paragraph
                && endPosition.offset === startOffset) {
                endPosition.setPositionParagraph(fieldEnd.line, endOffset);
                return;
            }
            if (!endSelection) {
                // tslint:disable-next-line:max-line-length
                endPosition.setPositionParagraph(fieldEnd.fieldBegin.line, fieldEnd.fieldBegin.line.getOffset(fieldEnd.fieldBegin, 0));
            }
        }
    };
    /**
     * get previous word offset from field separator
     * @private
     */
    // tslint:disable-next-line:max-line-length
    TextPosition.prototype.getPreviousWordOffsetFieldSeparator = function (fieldSeparator, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        this.getPreviousWordOffsetFieldBegin(fieldSeparator.fieldBegin, selection, fieldSeparator.fieldBegin.length, type, isInField, isStarted, endSelection, endPosition);
    };
    /**
     * get previous word offset from field begin
     * @private
     */
    // tslint:disable-next-line:max-line-length
    TextPosition.prototype.getPreviousWordOffsetFieldBegin = function (fieldBegin, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        var startOffset = fieldBegin.line.getOffset(fieldBegin, 0);
        var endOffset = startOffset + fieldBegin.length;
        if (endPosition.offset === endOffset) {
            endPosition.setPositionParagraph(fieldBegin.line, startOffset);
        }
        if (!isNullOrUndefined(fieldBegin.previousNode)) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffset(fieldBegin.previousNode, selection, fieldBegin.previousNode.length, type, false, isStarted, endSelection, endPosition);
            if (endPosition.offset === startOffset) {
                if (type !== 0 && !isNullOrUndefined(fieldBegin.fieldSeparator)) {
                    // tslint:disable-next-line:max-line-length
                    endPosition.setPositionParagraph(fieldBegin.line, fieldBegin.fieldSeparator.line.getOffset(fieldBegin.fieldSeparator, fieldBegin.fieldSeparator.length));
                }
            }
        }
        else {
            endPosition.setPositionParagraph(fieldBegin.line, selection.getStartLineOffset(fieldBegin.line));
        }
    };
    /**
     * get previous word offset from image
     * @private
     */
    // tslint:disable-next-line:max-line-length
    TextPosition.prototype.getPreviousWordOffsetImage = function (image, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        if (isInField) {
            endPosition.setPositionParagraph(image.line, image.line.getOffset(image, indexInInline));
            endSelection = false;
            return;
        }
        if (indexInInline === image.length) {
            var endOffset = image.line.getOffset(image, image.length);
            if (endOffset === endPosition.offset) {
                endPosition.setPositionParagraph(image.line, endOffset - image.length);
            }
            else {
                endPosition.setPositionParagraph(image.line, endOffset);
            }
        }
        else if (!isNullOrUndefined(image.previousNode)) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffset(image.previousNode, selection, image.previousNode.length, type, isInField, isStarted, endSelection, endPosition);
        }
    };
    /**
     * Get previous word offset from span
     * @private
     */
    // tslint:disable-next-line:max-line-length   
    TextPosition.prototype.getPreviousWordOffsetSpan = function (span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        if (span.text === '\t' || span.text === '\v') {
            if (isInField) {
                endSelection = false;
                return;
            }
            if (indexInInline === span.length) {
                endSelection = true;
                var endOffset = span.line.getOffset(span, span.length);
                if (endOffset === endPosition.offset) {
                    endPosition.setPositionParagraph(span.line, endOffset - span.length);
                }
                else {
                    endPosition.setPositionParagraph(span.line, endOffset);
                }
            }
            else if (!isNullOrUndefined(span.previousNode)) {
                // tslint:disable-next-line:max-line-length
                this.getPreviousWordOffset(span.previousNode, selection, span.previousNode.length, type, isInField, isStarted, endSelection, endPosition);
            }
        }
        else {
            var wordStartIndex = 0;
            if (!isStarted) {
                while (indexInInline > 0 && span.text[indexInInline - 1] === ' ') {
                    indexInInline--;
                }
                endPosition.setPositionParagraph(span.line, span.line.getOffset(span, indexInInline));
            }
            if (indexInInline > 0) {
                isStarted = true;
                if (indexInInline === 0 && endSelection && (HelperMethods.wordSplitCharacters.indexOf(span.text[0])) === -1) {
                    endPosition.setPositionParagraph(span.line, span.line.getOffset(span, indexInInline));
                    endSelection = true;
                    return;
                }
                var txt = span.text.length > indexInInline ? span.text.slice(0, indexInInline) : span.text;
                wordStartIndex = HelperMethods.lastIndexOfAny(txt, HelperMethods.wordSplitCharacters);
                if (wordStartIndex !== -1) {
                    if (isInField) {
                        endSelection = false;
                        return;
                    }
                    while (wordStartIndex > 0 && endSelection && txt[wordStartIndex] !== ' '
                        && (HelperMethods.wordSplitCharacters.indexOf(txt[wordStartIndex - 1])) !== -1) {
                        wordStartIndex--;
                    }
                    if (txt[wordStartIndex] === ' ' || txt[wordStartIndex] === '' || !endSelection) {
                        wordStartIndex++;
                    }
                    endSelection = true;
                    if (wordStartIndex > 0) {
                        var offset = span.line.getOffset(span, wordStartIndex);
                        if (span.line.paragraph === endPosition.paragraph && offset === endPosition.offset) {
                            // tslint:disable-next-line:max-line-length
                            this.getPreviousWordOffsetSpan(span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
                        }
                        else {
                            endPosition.setPositionParagraph(span.line, offset);
                        }
                    }
                    else if (span.previousNode instanceof TextElementBox) {
                        // tslint:disable-next-line:max-line-length
                        this.getPreviousWordOffset(span.previousNode, selection, span.previousNode.length, type, isInField, isStarted, endSelection, endPosition);
                    }
                    else {
                        endPosition.setPositionParagraph(span.line, span.line.getOffset(span, 0));
                    }
                }
                else {
                    this.setPreviousWordOffset(span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
                }
            }
            else {
                this.setPreviousWordOffset(span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
            }
        }
    };
    /**
     * set previous word offset in span
     * @private
     */
    // tslint:disable-next-line:max-line-length
    TextPosition.prototype.setPreviousWordOffset = function (span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        if (span.previousNode instanceof ElementBox && span.line === span.previousNode.line) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffset(span.previousNode, selection, span.previousNode.length, type, isInField, isStarted, endSelection, endPosition);
        }
        else {
            endPosition.setPositionParagraph(span.line, selection.getStartLineOffset(span.line));
        }
    };
    /**
     * Validate if text position is in field forward
     * @private
     */
    TextPosition.prototype.validateForwardFieldSelection = function (currentIndex, selectionEndIndex) {
        var textPosition = new TextPosition(this.owner);
        textPosition.setPositionForCurrentIndex(currentIndex);
        textPosition.isUpdateLocation = false;
        var isPositionMoved = false;
        if (this.selection.start.paragraph !== this.selection.end.paragraph) {
            // To select Paragraph mark similar to MS WORD
            if (this.selection.end.offset === this.selection.end.currentWidget.getEndOffset()
                && this.selection.isParagraphLastLine(this.selection.end.currentWidget)) {
                this.selection.end.setPositionParagraph(this.selection.end.currentWidget, this.selection.end.offset + 1);
            }
        }
        while (currentIndex !== selectionEndIndex && TextPosition.isForwardSelection(currentIndex, selectionEndIndex)) {
            if (!isPositionMoved) {
                textPosition.moveNextPosition(false);
                var nextIndex = textPosition.getHierarchicalIndexInternal();
                //Handled specifically to break infinite looping, if selection ends at last paragraph mark.
                if (currentIndex === nextIndex) {
                    break;
                }
            }
            var indexInInline = 0;
            var inlineObj = textPosition.currentWidget.getInline(textPosition.offset, indexInInline);
            var inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!isNullOrUndefined(inline)) {
                var selectionStartIndex = this.selection.start.getHierarchicalIndexInternal();
                if (indexInInline === inline.length && inline instanceof FieldElementBox && inline.fieldType === 1) {
                    if (inline.line.getOffset(inline, 0) === this.offset) {
                        return;
                    }
                    var lineWidget = inline.fieldBegin.line;
                    var fieldBeginOffset = lineWidget.getOffset(inline.fieldBegin, 0);
                    var fieldBeginIndex = this.getHierarchicalIndex(lineWidget, fieldBeginOffset.toString());
                    if (!TextPosition.isForwardSelection(selectionStartIndex, fieldBeginIndex)) {
                        this.selection.start.setPositionParagraph(lineWidget, fieldBeginOffset);
                    }
                }
                var nextInline = this.selection.getNextRenderedElementBox(inline, indexInInline);
                if (!isNullOrUndefined(nextInline) && nextInline instanceof ElementBox) {
                    inline = nextInline;
                }
            }
            isPositionMoved = (inline instanceof FieldElementBox && inline.fieldType === 0 && !isNullOrUndefined(inline.fieldEnd));
            if (isPositionMoved) {
                if (inline.line.getOffset(inline, 0) === this.offset) {
                    return;
                }
                var fieldEnd = inline.fieldEnd;
                var paragraph = fieldEnd.line.paragraph;
                var fieldEndOffset = fieldEnd.line.getOffset(fieldEnd, 1);
                var fieldEndIndex = this.getHierarchicalIndex(fieldEnd.line, fieldEndOffset.toString());
                if (!TextPosition.isForwardSelection(fieldEndIndex, selectionEndIndex)) {
                    //If selection end is after field begin, extend selection end to field end.
                    this.moveToInline(inline.fieldEnd, 1);
                    return;
                }
                textPosition.moveToInline(inline.fieldEnd, 1);
            }
            currentIndex = textPosition.getHierarchicalIndexInternal();
        }
    };
    /**
     * Validate if text position is in field backward
     * @private
     */
    TextPosition.prototype.validateBackwardFieldSelection = function (currentIndex, selectionEndIndex) {
        var textPosition = new TextPosition(this.owner);
        textPosition.setPositionForCurrentIndex(currentIndex);
        textPosition.isUpdateLocation = false;
        if (this.selection.start.paragraph !== this.selection.end.paragraph) {
            // To select Paragraph mark similar to MS WORD
            if (this.selection.start.offset !== this.selection.getStartOffset(this.selection.start.paragraph)
                && this.selection.start.offset === this.selection.start.currentWidget.getEndOffset()
                && this.selection.isParagraphLastLine(this.selection.start.currentWidget)) {
                this.selection.start.setPositionParagraph(this.selection.start.currentWidget, this.selection.start.offset + 1);
            }
        }
        var selectionStartIndex = this.selection.start.getHierarchicalIndexInternal();
        while (currentIndex !== selectionEndIndex && TextPosition.isForwardSelection(selectionEndIndex, currentIndex)) {
            var indexInInline = 0;
            var inlineObj = textPosition.currentWidget.getInline(textPosition.offset, indexInInline);
            var inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!isNullOrUndefined(inline)) {
                var nextInline = this.selection.getNextRenderedElementBox(inline, indexInInline);
                if (nextInline instanceof FieldElementBox && nextInline.fieldType === 0) {
                    var paragraph = nextInline.fieldEnd.line;
                    var fieldEndOffset = paragraph.getOffset(nextInline.fieldEnd, 1);
                    var fieldEndIndex = this.getHierarchicalIndex(paragraph, fieldEndOffset.toString());
                    if (!TextPosition.isForwardSelection(fieldEndIndex, selectionStartIndex)) {
                        this.selection.start.setPositionParagraph(paragraph, fieldEndOffset);
                        selectionStartIndex = fieldEndIndex;
                    }
                }
            }
            if (inline instanceof FieldElementBox && inline.fieldType === 1 && !isNullOrUndefined(inline.fieldBegin)) {
                var line = inline.fieldBegin.line;
                var fieldBegin = inline.fieldBegin;
                var fieldBeginOffset = line.getOffset(fieldBegin, 0);
                var fieldBeginIndex = this.getHierarchicalIndex(line, fieldBeginOffset.toString());
                if (!TextPosition.isForwardSelection(selectionEndIndex, fieldBeginIndex)) {
                    //If field begin is before selection end, extend selection end to field begin.
                    this.moveToInline(inline.fieldBegin, 0);
                    return;
                }
                textPosition.moveToInline(inline.fieldBegin, 0);
            }
            else {
                textPosition.movePreviousPosition();
            }
            currentIndex = textPosition.getHierarchicalIndexInternal();
        }
    };
    /**
     * @private
     */
    TextPosition.prototype.paragraphStartInternal = function (selection, moveToPreviousParagraph) {
        var offset = selection.getStartLineOffset(this.currentWidget);
        if (this.offset === offset && moveToPreviousParagraph) {
            var startParagraph = this.moveToNextParagraphInTableCheck();
            if (startParagraph) {
                this.moveToPreviousParagraphInTable(selection);
            }
            else if (!isNullOrUndefined(selection.getPreviousParagraphBlock(this.currentWidget.paragraph))) {
                var paragraphValue = selection.getPreviousParagraphBlock(this.currentWidget.paragraph);
                this.currentWidget = paragraphValue.childWidgets[0];
                this.offset = selection.getStartLineOffset(this.currentWidget);
            }
        }
        else {
            this.currentWidget = this.currentWidget.paragraph.getSplitWidgets()[0].childWidgets[0];
            this.offset = offset;
        }
        this.calculateOffset();
    };
    /**
     * @private
     */
    TextPosition.prototype.calculateOffset = function () {
        var selectionStartIndex = this.owner.selection.start.getHierarchicalIndexInternal();
        var selectionEndIndex = this.getHierarchicalIndexInternal();
        if (selectionStartIndex !== selectionEndIndex) {
            this.validateBackwardFieldSelection(selectionStartIndex, selectionEndIndex);
        }
        this.updatePhysicalPosition(true);
    };
    /**
     * Moves the text position to start of the paragraph.
     * @private
     */
    TextPosition.prototype.moveToParagraphStartInternal = function (selection, moveToPreviousParagraph) {
        var startOffset = selection.getStartOffset(this.paragraph);
        if (this.offset === startOffset && moveToPreviousParagraph) {
            var paragraphstart = this.moveToNextParagraphInTableCheck();
            if (paragraphstart) {
                this.moveToPreviousParagraphInTable(selection);
            }
            else if (!isNullOrUndefined(selection.getPreviousParagraphBlock(this.paragraph))) {
                this.currentWidget = selection.getPreviousParagraphBlock(this.paragraph).firstChild;
                this.offset = selection.getStartOffset(this.paragraph);
            }
        }
        else {
            this.currentWidget = this.paragraph.firstChild;
            this.offset = selection.getStartLineOffset(this.currentWidget);
        }
        var selectionStartIndex = this.owner.selection.start.getHierarchicalIndexInternal();
        var selectionEndIndex = this.getHierarchicalIndexInternal();
        if (selectionStartIndex !== selectionEndIndex) {
            this.validateBackwardFieldSelection(selectionStartIndex, selectionEndIndex);
        }
        this.updatePhysicalPosition(false);
    };
    /**
     * Moves the text position to end of the paragraph.
     * @private
     */
    TextPosition.prototype.moveToParagraphEndInternal = function (selection, moveToNextParagraph) {
        // tslint:disable-next-line:max-line-length
        var splittedParagraph = this.currentWidget.paragraph;
        while (splittedParagraph.nextSplitWidget) {
            splittedParagraph = splittedParagraph.nextSplitWidget;
        }
        this.currentWidget = splittedParagraph.childWidgets[splittedParagraph.childWidgets.length - 1];
        var endOffset = this.currentWidget.getEndOffset() + 1;
        if (this.offset === endOffset && moveToNextParagraph) {
            var paragraphEnd = this.moveToNextParagraphInTableCheck();
            if (paragraphEnd) {
                this.moveToNextParagraphInTable();
            }
            else if (!isNullOrUndefined(selection.getNextParagraphBlock(this.currentWidget.paragraph))) {
                var endParagraph = selection.getNextParagraphBlock(this.currentWidget.paragraph);
                this.currentWidget = endParagraph.childWidgets[endParagraph.childWidgets.length - 1];
                this.offset = this.currentWidget.getEndOffset() + 1;
            }
        }
        else {
            this.offset = endOffset;
        }
        this.calculateOffset();
    };
    /**
     * @private
     */
    TextPosition.prototype.moveUp = function (selection, left) {
        var paragraph = this.currentWidget.paragraph;
        //Moves text position to start of line.
        this.moveToLineStartInternal(selection, true);
        //Moves previous line starting.
        this.movePreviousPosition();
        var prevLine = undefined;
        var currentParagraph = this.currentWidget.paragraph;
        if (paragraph.isInsideTable && paragraph !== currentParagraph && paragraph.associatedCell !== currentParagraph.associatedCell
            // tslint:disable-next-line:max-line-length
            && (!isNullOrUndefined(currentParagraph.associatedCell) && (paragraph.associatedCell.ownerRow === currentParagraph.associatedCell.ownerRow))) {
            var ownerRow = currentParagraph.associatedCell.ownerRow;
            if (ownerRow.previousRenderedWidget instanceof TableRowWidget) {
                // tslint:disable-next-line:max-line-length
                var cell = selection.getFirstCellInRegion(ownerRow.previousRenderedWidget, currentParagraph.associatedCell, left, true);
                var lastParagraph = selection.getLastParagraph(cell);
                this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
            }
            else {
                var prevBlock = ownerRow.ownerTable.previousRenderedWidget;
                do {
                    if (prevBlock instanceof TableWidget) {
                        prevBlock = selection.getLastBlockInLastCell(prevBlock);
                    }
                } while (prevBlock instanceof TableWidget);
                if (prevBlock instanceof ParagraphWidget) {
                    this.setPosition(prevBlock.childWidgets[prevBlock.childWidgets.length - 1], false);
                }
            }
            prevLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        }
        else {
            if (!paragraph.isInsideTable && this.currentWidget.paragraph.isInsideTable) {
                // tslint:disable-next-line:max-line-length
                var cell = selection.getFirstCellInRegion(this.currentWidget.paragraph.associatedCell.ownerRow, this.currentWidget.paragraph.associatedCell, this.owner.selection.upDownSelectionLength, true);
                var lastParagraph = selection.getLastParagraph(cell);
                this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
                // tslint:disable-next-line:max-line-length
            }
            else if (paragraph.isInsideTable && (!isNullOrUndefined(this.currentWidget.paragraph.associatedCell) && paragraph.associatedCell.ownerRow.previousRenderedWidget !== paragraph.associatedCell.ownerRow.previousSplitWidget &&
                paragraph.associatedCell.ownerRow.previousRenderedWidget === this.currentWidget.paragraph.associatedCell.ownerRow)) {
                // tslint:disable-next-line:max-line-length
                var cell = selection.getLastCellInRegion(this.currentWidget.paragraph.associatedCell.ownerRow, this.currentWidget.paragraph.associatedCell, this.owner.selection.upDownSelectionLength, true);
                var lastParagraph = selection.getLastParagraph(cell);
                this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
            }
            prevLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        }
        //Moves till the Up/Down selection width.
        var top = selection.getTop(prevLine);
        selection.updateTextPositionWidget(prevLine, new Point(left, top), this, false);
    };
    /**
     * @private
     */
    TextPosition.prototype.moveDown = function (selection, left) {
        //Moves text position to end of line.
        var prevParagraph = this.currentWidget.paragraph;
        var currentLine = this.currentWidget;
        this.moveToLineEndInternal(selection, true);
        var length = this.selection.getParagraphLength(this.currentWidget.paragraph);
        if (this.offset > length) {
            this.offset = length;
        }
        //Moves next line starting.
        this.moveNextPosition();
        var nextLine = undefined;
        // tslint:disable-next-line:max-line-length
        if (prevParagraph.isInsideTable && prevParagraph !== this.currentWidget.paragraph && prevParagraph.associatedCell !== this.currentWidget.paragraph.associatedCell && (!isNullOrUndefined(this.currentWidget.paragraph.associatedCell) && prevParagraph.associatedCell.ownerRow === this.currentWidget.paragraph.associatedCell.ownerRow)) {
            var ownerRow = this.currentWidget.paragraph.associatedCell.ownerRow;
            // tslint:disable-next-line:max-line-length
            if (prevParagraph.isInsideTable && this.currentWidget.paragraph.isInsideTable && prevParagraph.associatedCell.cellFormat.rowSpan > 1 && prevParagraph.associatedCell.cellFormat.rowSpan + prevParagraph.associatedCell.ownerRow.rowIndex === prevParagraph.associatedCell.ownerTable.childWidgets.length) {
                //If the prevParagraph  owner cell is Verically merged upto the last row, then theposition moved to next column. the position moved to out of the current tabel so owner row is assigned to last row.
                // tslint:disable-next-line:max-line-length
                ownerRow = this.currentWidget.paragraph.associatedCell.ownerTable.childWidgets[this.currentWidget.paragraph.associatedCell.ownerTable.childWidgets.length - 1];
            }
            if (ownerRow.nextRenderedWidget instanceof TableRowWidget) {
                // tslint:disable-next-line:max-line-length
                var cell = this.selection.getLastCellInRegion(ownerRow.nextRenderedWidget, this.currentWidget.paragraph.associatedCell, left, false);
                this.setPosition(this.selection.getFirstParagraph(cell).childWidgets[0], true);
            }
            else {
                var nextBlock = this.selection.getNextRenderedBlock(ownerRow.ownerTable);
                do {
                    if (nextBlock instanceof TableWidget) {
                        nextBlock = this.selection.getFirstBlockInFirstCell(nextBlock);
                    }
                } while (nextBlock instanceof TableWidget);
                if (nextBlock instanceof ParagraphWidget) {
                    this.setPosition(nextBlock.childWidgets[0], true);
                }
            }
            nextLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        }
        else {
            if (!prevParagraph.isInsideTable && this.currentWidget.paragraph.isInsideTable) {
                // tslint:disable-next-line:max-line-length
                var cell = this.selection.getLastCellInRegion(this.currentWidget.paragraph.associatedCell.ownerRow, this.currentWidget.paragraph.associatedCell, this.owner.selection.upDownSelectionLength, false);
                this.setPosition(this.selection.getFirstParagraph(cell).childWidgets[0], true);
                // tslint:disable-next-line:max-line-length
            }
            else if (prevParagraph.isInsideTable && (!isNullOrUndefined(this.currentWidget.paragraph.associatedCell) && prevParagraph.associatedCell.ownerRow.nextRenderedWidget !== prevParagraph.associatedCell.ownerRow.nextSplitWidget
                && prevParagraph.associatedCell.ownerRow.nextRenderedWidget === this.currentWidget.paragraph.associatedCell.ownerRow)) {
                // tslint:disable-next-line:max-line-length
                var cell = selection.getLastCellInRegion(this.currentWidget.paragraph.associatedCell.ownerRow, this.currentWidget.paragraph.associatedCell, this.owner.selection.upDownSelectionLength, true);
                this.setPosition(selection.getFirstParagraph(cell).childWidgets[0], false);
            }
            nextLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        }
        //Moves till the Up/Down selection width.
        var top = this.selection.getTop(nextLine);
        if (nextLine !== currentLine) {
            this.selection.updateTextPositionWidget(nextLine, new Point(left, top), this, false);
        }
    };
    /**
     * Moves the text position to start of the line.
     * @private
     */
    TextPosition.prototype.moveToLineStartInternal = function (selection, moveToPreviousLine) {
        if (this.location.x > this.viewer.clientActiveArea.right) {
            this.offset = this.offset - 1;
        }
        var currentLine = selection.getLineWidgetInternal(this.currentWidget, this.offset, moveToPreviousLine);
        var firstElement;
        var isParaBidi = this.currentWidget.paragraph.paragraphFormat.bidi;
        if (isParaBidi && currentLine.children.length > 0 && this.containsRtlText(currentLine)) {
            firstElement = currentLine.children[currentLine.children.length - 1];
            if (firstElement instanceof ListTextElementBox) {
                firstElement = undefined;
            }
        }
        else {
            firstElement = selection.getFirstElementInternal(currentLine);
        }
        this.viewer.moveCaretPosition = 1;
        var startOffset = selection.getStartOffset(this.currentWidget.paragraph);
        if (isNullOrUndefined(firstElement) && this.offset > startOffset) {
            var index = 0;
            var inlineObj = this.currentWidget.getInline(this.offset, index);
            var inline = inlineObj.element;
            index = inlineObj.index;
            if (inline instanceof TextElementBox && inline.text !== '\v') {
                this.offset = startOffset;
            }
        }
        else if (!isNullOrUndefined(firstElement)) {
            var indexInInline = 0;
            this.currentWidget = firstElement.line;
            this.offset = this.currentWidget.getOffset(firstElement, indexInInline);
            indexInInline = 0;
            var inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
            var inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (inline instanceof FieldElementBox) {
                //Checks if field character is part of rendered field, otherwise moves to previous rendered content.
                var prevInline = selection.getPreviousValidElement(inline);
                if (!isNullOrUndefined(prevInline)) {
                    inline = prevInline;
                    this.currentWidget = inline.line;
                    this.offset = this.currentWidget.getOffset(inline, inline.length);
                    if (inline instanceof FieldElementBox) {
                        this.offset--;
                    }
                }
            }
        }
        this.updatePhysicalPosition(true);
    };
    /**
     * Check paragraph is inside table
     * @private
     */
    TextPosition.prototype.moveToNextParagraphInTableCheck = function () {
        if ((this.selection.start.paragraph.isInsideTable || this.paragraph.isInsideTable)
            && (this.selection.start.paragraph.associatedCell !== this.paragraph.associatedCell
                || this.selection.isCellSelected(this.selection.start.paragraph.associatedCell, this.selection.start, this))) {
            return true;
        }
        return false;
    };
    /**
     * Moves the text position to end of the word.
     * @private
     */
    TextPosition.prototype.moveToWordEndInternal = function (type, excludeSpace) {
        // type === 0 -------->CTRL+ARROW Navigation
        // type === 1 -------->CTRL+SHIFT+ARROW Selection
        // type === 2 -------->Double-tap Word Selection
        var incrementValue = 0;
        var endOffset = this.currentWidget.getEndOffset();
        if (this.selection.isParagraphFirstLine(this.currentWidget)) {
            if (this.currentWidget.children[0] instanceof ListTextElementBox) {
                incrementValue = 1;
            }
            if (this.currentWidget.children[1] instanceof ListTextElementBox) {
                incrementValue = 2;
            }
        }
        if (this.offset + incrementValue === endOffset || this.offset === endOffset + 1) {
            if (this.offset === endOffset && type !== 0) {
                this.setPositionParagraph(this.currentWidget, endOffset + 1);
            }
            else {
                var nextParagraph = this.selection.getNextParagraphBlock(this.currentWidget.paragraph);
                if (isNullOrUndefined(nextParagraph)) {
                    return;
                }
                this.currentWidget = nextParagraph.childWidgets[0];
                this.offset = this.selection.getStartLineOffset(this.currentWidget);
                if (type === 1) {
                    // tslint:disable-next-line:max-line-length
                    var nextWord = this.moveToNextParagraphInTableCheck();
                    if (nextWord) {
                        this.moveToNextParagraphInTable();
                    }
                    else {
                        this.moveToWordEndInternal(type, excludeSpace);
                    }
                }
            }
        }
        else {
            var indexInInline = 0;
            var endSelection = false;
            var inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
            var inline = inlineObj.element;
            indexInInline = inlineObj.index;
            this.getNextWordOffset(inline, indexInInline, type, false, endSelection, this, excludeSpace);
        }
        if (type !== 0) {
            var selectionStartIndex = this.owner.selection.start.getHierarchicalIndexInternal();
            var selectionEndIndex = this.getHierarchicalIndexInternal();
            if (selectionStartIndex !== selectionEndIndex) {
                this.validateForwardFieldSelection(selectionStartIndex, selectionEndIndex);
            }
        }
        this.updatePhysicalPosition(true);
    };
    /**
     * move text position to next paragraph inside table
     * @private
     */
    TextPosition.prototype.moveToNextParagraphInTable = function () {
        var paragraph = this.currentWidget.paragraph;
        var nextParagraph = (paragraph.isInsideTable) ? this.selection.getNextSelectionCell(paragraph.associatedCell) :
            this.selection.getNextParagraphBlock(paragraph);
        if (isNullOrUndefined(nextParagraph)) {
            return;
        }
        this.currentWidget = nextParagraph.childWidgets[nextParagraph.childWidgets.length - 1];
        this.offset = this.currentWidget.getEndOffset() + 1;
    };
    /**
     * Moves the text position to start of the previous paragraph.
     */
    TextPosition.prototype.moveToPreviousParagraph = function (selection) {
        var startOffset = selection.getStartOffset(this.currentWidget.paragraph);
        // tslint:disable-next-line:max-line-length
        if (this.offset === startOffset && !isNullOrUndefined(selection.getPreviousParagraphBlock(this.currentWidget.paragraph))) {
            var previousParagraph = selection.getPreviousParagraphBlock(this.currentWidget.paragraph);
            this.currentWidget = previousParagraph.childWidgets[0];
            this.offset = selection.getStartOffset(this.currentWidget.paragraph);
        }
        else {
            this.offset = selection.getStartOffset(this.currentWidget.paragraph);
        }
        this.updatePhysicalPosition(true);
    };
    /**
     * Move to previous line from current position
     * @private
     */
    TextPosition.prototype.moveToPreviousLine = function (selection, left) {
        var currentIndex = this.getHierarchicalIndexInternal();
        var currentLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        //Moves text position to start of line.
        this.moveToLineStartInternal(selection, true);
        if (this.currentWidget.paragraph.isInsideTable) {
            this.moveUpInTable(selection);
        }
        else {
            this.moveBackward();
        }
        var prevLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        var lineStart = selection.getLeft(prevLine);
        var lineWidth = selection.getWidth(prevLine, true);
        //Moves till the Up/Down selection width.
        if (lineWidth + lineStart >= left && currentLine !== prevLine) {
            var top_1 = selection.getTop(prevLine);
            var point = new Point(left, top_1);
            selection.updateTextPositionWidget(prevLine, point, this, true);
        }
        //Checks if the current position is between field result, then move to field begin.
        var selectionEndIndex = this.getHierarchicalIndexInternal();
        this.validateBackwardFieldSelection(currentIndex, selectionEndIndex);
    };
    /**
     * @private
     */
    TextPosition.prototype.moveToLineEndInternal = function (selection, moveToNextLine) {
        if (this.location.x > this.viewer.clientActiveArea.right) {
            this.offset = this.offset - 1;
        }
        var currentLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        var firstElement = selection.getFirstElementInternal(currentLine);
        var isParaBidi = this.currentWidget.paragraph.paragraphFormat.bidi;
        this.viewer.moveCaretPosition = 2;
        if (isNullOrUndefined(firstElement) && this.offset === selection.getStartLineOffset(this.currentWidget)) {
            this.offset = selection.getParagraphLength(this.paragraph) + 1;
            this.updatePhysicalPosition(true);
        }
        else if (!isNullOrUndefined(firstElement)) {
            var lastElement = void 0;
            // As per Microsoft Behavior, when current para is RTL and if line widget contains rtl text or mixed inlines(rtl, normal),
            // then need to consider the last element and to update offset to last element
            if (isParaBidi && this.containsRtlText(currentLine)) {
                var endOffset = currentLine.getEndOffset();
                lastElement = currentLine.getInline(endOffset, 0).element;
            }
            else {
                lastElement = currentLine.children[currentLine.children.length - 1];
                if (lastElement instanceof ListTextElementBox && currentLine.children.length > 2) {
                    lastElement = currentLine.children[currentLine.children.length - 3];
                }
            }
            var index = 0;
            index += lastElement instanceof TextElementBox ? lastElement.length : 1;
            this.currentWidget = lastElement.line;
            if (index === lastElement.length
                && isNullOrUndefined(lastElement.nextNode) && selection.isParagraphLastLine(this.currentWidget)) {
                var length_1 = selection.getLineLength(this.currentWidget);
                this.offset = moveToNextLine ? length_1 + 1 : length_1;
            }
            else {
                var inline = lastElement;
                while (!isNullOrUndefined(inline) && inline.length === index && inline.nextNode instanceof FieldElementBox) {
                    var nextInline = selection.getNextValidElement(inline.nextNode);
                    if (inline !== nextInline) {
                        inline = nextInline;
                        index = 0;
                    }
                    if (inline instanceof FieldElementBox && inline.fieldType === 0
                        && !isNullOrUndefined(inline.fieldEnd)) {
                        var fieldBegin = inline;
                        if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                            inline = fieldBegin.fieldEnd;
                        }
                        else {
                            inline = fieldBegin.fieldSeparator;
                            this.currentWidget = inline.line;
                            if (this.currentWidget === fieldBegin.fieldEnd.line
                                && !selection.hasValidInline(this.currentWidget.paragraph, inline, fieldBegin.fieldEnd)) {
                                inline = fieldBegin.fieldEnd;
                            }
                        }
                        this.currentWidget = inline.line;
                    }
                    if (inline instanceof FieldElementBox) {
                        index = 1;
                    }
                }
                if (index === inline.length && isNullOrUndefined(inline.nextNode)) {
                    index++;
                }
                if (!moveToNextLine && inline instanceof ElementBox && inline.text === '\v') {
                    index--;
                }
                this.offset = this.currentWidget.getOffset(inline, index);
            }
            this.updatePhysicalPosition(moveToNextLine);
        }
    };
    /**
     * Move to next line
     * @private
     */
    TextPosition.prototype.moveToNextLine = function (left) {
        var selection = this.selection;
        var textPosition = new TextPosition(this.owner);
        textPosition.setPositionInternal(this);
        var currentIndex = this.getHierarchicalIndexInternal();
        var currentLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        var isAtLineStart = this.offset === 0 ? true : false;
        //Moves text position to end of line.
        this.moveToLineEndInternal(selection, true);
        var isMoveToLineEnd = !textPosition.isAtSamePosition(this);
        textPosition.setPositionInternal(this);
        if (this.currentWidget.paragraph.isInsideTable) {
            this.moveDownInTable(selection);
        }
        else {
            this.moveNextPosition();
            this.moveForward();
        }
        var nextLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        var lineStart = selection.getLeft(nextLine);
        var firstElement = selection.getFirstElementInternal(nextLine);
        // tslint:disable-next-line:max-line-length
        var firstItemWidth = isNullOrUndefined(firstElement) ? selection.getWidth(nextLine, true) : selection.getLeftInternal(nextLine, firstElement, 1) - lineStart;
        //Moves till the Up/Down selection width.
        if (lineStart < left && (firstItemWidth / 2 < left - lineStart)) {
            var top_2 = selection.getTop(nextLine);
            var point = new Point(left, top_2);
            selection.updateTextPositionWidget(nextLine, point, this, true);
            var width = selection.getWidth(nextLine, true);
            if (width < left - lineStart) {
                this.moveToLineEndInternal(selection, true);
            }
        }
        else if (isMoveToLineEnd && this.currentWidget.paragraph.isInsideTable
            && this.currentWidget === this.owner.selection.start.currentWidget) {
            this.setPositionInternal(textPosition);
        }
        else if (!isMoveToLineEnd) {
            this.moveToLineEndInternal(selection, true);
        }
        //Checks if the current position is between field result, then move to field end.
        var selectionEndIndex = this.getHierarchicalIndexInternal();
        this.validateForwardFieldSelection(currentIndex, selectionEndIndex);
    };
    /**
     * Move upward in table
     * @private
     */
    TextPosition.prototype.moveUpInTable = function (selection) {
        var isPositionUpdated = false;
        var end = this.owner.selection.end;
        var isBackwardSelection = !this.owner.selection.isEmpty;
        isPositionUpdated = end.paragraph.isInsideTable;
        if (isPositionUpdated) {
            var startCell = this.currentWidget.paragraph.associatedCell;
            var endCell = end.paragraph.associatedCell;
            var containerCell = selection.getContainerCellOf(endCell, startCell);
            isPositionUpdated = containerCell.ownerTable.contains(startCell);
            if (isPositionUpdated) {
                endCell = selection.getSelectedCell(endCell, containerCell);
                startCell = selection.getSelectedCell(startCell, containerCell);
                // tslint:disable-next-line:max-line-length
                var isInContainerCell = selection.containsCell(containerCell, this.currentWidget.paragraph.associatedCell);
                var isContainerCellSelected = selection.isCellSelected(containerCell, this, end);
                if (!isContainerCellSelected) {
                    // tslint:disable-next-line:max-line-length
                    isContainerCellSelected = this.currentWidget.paragraph === selection.getFirstParagraph(containerCell) && this.isAtParagraphStart;
                }
                if ((isInContainerCell && isContainerCellSelected
                    || !isInContainerCell) && !isNullOrUndefined(startCell.ownerRow.previousRenderedWidget)) {
                    //Moves to cell in previous row.
                    var row = startCell.ownerRow.previousRenderedWidget;
                    // tslint:disable-next-line:max-line-length
                    var cell = selection.getFirstCellInRegion(row, containerCell, this.owner.selection.upDownSelectionLength, true);
                    var previousParagraph = selection.getLastParagraph(cell);
                    this.setPosition(previousParagraph.childWidgets[0], true);
                    return;
                }
                else if (isInContainerCell && isContainerCellSelected
                    && isNullOrUndefined(startCell.ownerRow.previousRenderedWidget) || !isInContainerCell) {
                    if (isBackwardSelection) {
                        //Moves to first cell of row.
                        startCell = startCell.ownerRow.childWidgets[0];
                        var previousParagraph = selection.getFirstParagraph(startCell);
                        this.setPosition(previousParagraph.childWidgets[0], true);
                    }
                    else {
                        //Moves to last cell of row.
                        startCell = startCell.ownerRow.childWidgets[startCell.ownerRow.childWidgets.length - 1];
                        var previousParagraph = selection.getLastParagraph(startCell);
                        this.setPosition(previousParagraph.childWidgets[0], false);
                    }
                }
            }
        }
        if (!isPositionUpdated) {
            //Moves to previous row / previous block.
            var cell = selection.getContainerCell(this.currentWidget.paragraph.associatedCell);
            if (isBackwardSelection) {
                //Moves to first cell of row.
                cell = cell.ownerRow.childWidgets[0];
                var previousParagraph = selection.getFirstParagraph(cell);
                this.setPosition(previousParagraph.childWidgets[0], true);
            }
            else {
                //Moves to end of row.
                cell = cell.ownerRow.childWidgets[cell.ownerRow.childWidgets.length - 1];
                var previousParagraph = selection.getLastParagraph(cell);
                this.setPosition(previousParagraph.childWidgets[0], false);
            }
        }
        //Moves to previous row / previous block.
        this.moveBackward();
    };
    /**
     * Move down inside table
     * @private
     */
    TextPosition.prototype.moveDownInTable = function (selection) {
        var isPositionUpdated = false;
        var isForwardSelection = this.owner.selection.isEmpty || this.owner.selection.isForward;
        isPositionUpdated = this.owner.selection.start.paragraph.isInsideTable;
        if (isPositionUpdated) {
            var startCell = this.owner.selection.start.paragraph.associatedCell;
            var endCell = this.currentWidget.paragraph.associatedCell;
            var containerCell = selection.getContainerCellOf(startCell, endCell);
            isPositionUpdated = containerCell.ownerTable.contains(endCell);
            if (isPositionUpdated) {
                startCell = selection.getSelectedCell(startCell, containerCell);
                endCell = selection.getSelectedCell(endCell, containerCell);
                // tslint:disable-next-line:max-line-length
                var isInContainerCell = selection.containsCell(containerCell, this.currentWidget.paragraph.associatedCell);
                var isContainerCellSelected = selection.isCellSelected(containerCell, this.owner.selection.start, this);
                if ((isInContainerCell && isContainerCellSelected
                    || !isInContainerCell) && !isNullOrUndefined(endCell.ownerRow.nextRenderedWidget)) {
                    //Moves to cell in next row.
                    var row = endCell.ownerRow.nextRenderedWidget;
                    // tslint:disable-next-line:max-line-length
                    var cell = selection.getLastCellInRegion(row, containerCell, this.owner.selection.upDownSelectionLength, false);
                    var lastParagraph = selection.getLastParagraph(cell);
                    this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
                    return;
                }
                else if (isInContainerCell && isContainerCellSelected
                    && isNullOrUndefined(endCell.ownerRow.nextRenderedWidget) || !isInContainerCell) {
                    if (isForwardSelection) {
                        //Moves to last cell of row.
                        endCell = endCell.ownerRow.childWidgets[endCell.ownerRow.childWidgets.length - 1];
                        var lastParagraph = selection.getLastParagraph(endCell);
                        this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
                    }
                    else {
                        //Moves to first cell of row.
                        endCell = endCell.ownerRow.childWidgets[0];
                        var lastParagraph = selection.getFirstParagraph(endCell);
                        this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], true);
                    }
                }
            }
        }
        if (!isPositionUpdated) {
            //Moves to next row / next block.
            var cell = selection.getContainerCell(this.currentWidget.paragraph.associatedCell);
            if (isForwardSelection) {
                //Moves to end of row.
                cell = cell.ownerRow.childWidgets[cell.ownerRow.childWidgets.length - 1];
                var lastParagraph = selection.getLastParagraph(cell);
                this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
            }
            else if (cell.ownerRow.nextRenderedWidget) {
                //Moves to first cell of row.
                cell = cell.ownerRow.nextRenderedWidget.childWidgets[0];
                var lastParagraph = selection.getFirstParagraph(cell);
                this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], true);
            }
        }
        //Moves to next row / next block.
        this.moveForward();
    };
    /**
     * @private
     */
    TextPosition.prototype.destroy = function () {
        this.offset = undefined;
        this.isUpdateLocation = undefined;
        if (!isNullOrUndefined(this.location)) {
            this.location.destroy();
        }
        this.location = undefined;
        this.currentWidget = undefined;
        this.owner = undefined;
        this.viewer = undefined;
    };
    return TextPosition;
}());
/**
 * @private
 */
var SelectionWidgetInfo = /** @__PURE__ @class */ (function () {
    function SelectionWidgetInfo(left, width) {
        this.leftIn = 0;
        this.widthIn = 0;
        this.color = '';
        this.leftIn = left;
        this.widthIn = width;
    }
    Object.defineProperty(SelectionWidgetInfo.prototype, "left", {
        /**
         * @private
         */
        get: function () {
            return this.leftIn;
        },
        /**
         * @private
         */
        set: function (value) {
            this.leftIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionWidgetInfo.prototype, "width", {
        /**
         * @private
         */
        get: function () {
            return this.widthIn;
        },
        /**
         * @private
         */
        set: function (value) {
            this.widthIn = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    SelectionWidgetInfo.prototype.destroy = function () {
        this.widthIn = undefined;
        this.leftIn = undefined;
    };
    return SelectionWidgetInfo;
}());
/**
 * @private
 */
var Hyperlink = /** @__PURE__ @class */ (function () {
    function Hyperlink(fieldBeginAdv, selection) {
        this.linkInternal = '';
        this.localRef = '';
        this.opensNewWindow = false;
        var fieldCode = selection.getFieldCode(fieldBeginAdv);
        var lowercase = fieldCode.toLowerCase();
        if (lowercase.substring(0, 9) === 'hyperlink') {
            this.parseFieldValues(fieldCode.substring(9).trim(), selection);
        }
    }
    Object.defineProperty(Hyperlink.prototype, "navigationLink", {
        /**
         * Gets navigation link.
         * @returns string
         * @private
         */
        get: function () {
            return this.linkInternal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hyperlink.prototype, "localReference", {
        /**
         * Gets the local reference if any.
         * @returns string
         * @private
         */
        get: function () {
            return this.localRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hyperlink.prototype, "linkType", {
        /**
         * Gets hyper link type.
         * @returns HyperLinkType
         * @private
         */
        get: function () {
            return this.typeInternal;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Parse field values
     * @param  {string} value
     * @returns Void
     */
    Hyperlink.prototype.parseFieldValues = function (value, selection) {
        var codes = value.split(' ');
        var isLocalRef = false;
        for (var i = 0; i < codes.length; i++) {
            var code = codes[i];
            if (code.length < 1) {
                continue;
            }
            if (code === '\\t' || code === '\\l') {
                isLocalRef = true;
            }
            else if (code === '\\n') {
                this.opensNewWindow = true;
            }
            else {
                code = this.parseFieldValue(code, code[0] === '\"' ? '\"' : undefined);
                if (isLocalRef) {
                    this.localRef = code;
                    isLocalRef = false;
                }
                else {
                    this.linkInternal = code;
                }
            }
        }
        this.setLinkType();
    };
    Hyperlink.prototype.parseFieldValue = function (value, endChar) {
        value = value.substring(1);
        var endIndex = endChar ? value.indexOf(endChar) : -1;
        if (endIndex < 0) {
            endIndex = value.length;
        }
        return value.substring(0, endIndex).trim();
    };
    Hyperlink.prototype.setLinkType = function () {
        // If only local reference.
        if (isNullOrUndefined(this.linkInternal) || this.linkInternal.length < 1) {
            this.typeInternal = 'Bookmark';
            return;
        }
        // Validates link.
        if (this.linkInternal.substring(0, 4) === ('www.')) {
            this.linkInternal = 'http://' + this.navigationLink;
        }
        else if (this.linkInternal[0] === '@') {
            this.linkInternal = 'mailto:' + this.navigationLink;
        }
        // Finds proper link type.
        if (this.linkInternal.substring(0, 7) === 'http://'
            || this.linkInternal.substring(0, 8) === 'https://') {
            this.typeInternal = 'WebPage';
        }
        else if (this.linkInternal.substring(0, 7) === 'mailto:') {
            this.typeInternal = 'Email';
        }
        else {
            this.typeInternal = 'File';
        }
    };
    /**
     * @private
     */
    Hyperlink.prototype.destroy = function () {
        this.linkInternal = undefined;
        this.localRef = undefined;
        this.typeInternal = undefined;
        this.opensNewWindow = undefined;
    };
    return Hyperlink;
}());
/**
 * @private
 */
var ImageFormat = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for image format class
     * @param imageContainer - Specifies for image width and height values.
     */
    function ImageFormat(imageContainer) {
        /**
         * @private
         */
        this.width = 0;
        /**
         * @private
         */
        this.height = 0;
        this.width = imageContainer.width;
        this.height = imageContainer.height;
    }
    /**
     * Dispose the internal objects which are maintained.
     * @private
     */
    ImageFormat.prototype.destroy = function () {
        this.width = undefined;
        this.height = undefined;
    };
    return ImageFormat;
}());

/**
 * Selection
 */
var Selection = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function Selection(documentEditor) {
        var _this = this;
        /**
         * @private
         */
        this.upDownSelectionLength = 0;
        /**
         * @private
         */
        this.isSkipLayouting = false;
        /**
         * @private
         */
        this.isImageSelected = false;
        this.contextTypeInternal = undefined;
        /**
         * @private
         */
        this.caret = undefined;
        //Format Retrieval Field
        /**
         * @private
         */
        this.isRetrieveFormatting = false;
        /**
         * @private
         */
        this.skipFormatRetrieval = false;
        this.isMoveDownOrMoveUp = false;
        /**
         * @private
         */
        this.isViewPasteOptions = false;
        /**
         * @private
         */
        this.skipEditRangeRetrieval = false;
        /**
         * @private
         */
        this.selectedWidgets = undefined;
        /**
         * @private
         */
        this.isHighlightEditRegionIn = false;
        /**
         * @private
         */
        this.isHightlightEditRegionInternal = false;
        /**
         * @private
         */
        this.isCurrentUser = false;
        /**
         * @private
         */
        this.isHighlightNext = false;
        /**
         * @private
         */
        this.editRegionHighlighters = undefined;
        /**
         * @private
         */
        this.pasteOptions = function (event) {
            if (event.item.text === 'Keep source formatting') {
                _this.owner.editor.applyPasteOptions('KeepSourceFormatting');
            }
            else if (event.item.text === 'Match destination formatting') {
                _this.owner.editor.applyPasteOptions('MergeWithExistingFormatting');
            }
            else {
                _this.owner.editor.applyPasteOptions('KeepTextOnly');
            }
        };
        /**
         * Hides caret.
         * @private
         */
        this.hideCaret = function () {
            if (!isNullOrUndefined(_this.caret)) {
                _this.caret.style.display = 'none';
            }
        };
        this.owner = documentEditor;
        this.viewer = this.owner.viewer;
        this.start = new TextPosition(this.owner);
        this.end = new TextPosition(this.owner);
        this.selectedWidgets = new Dictionary();
        this.characterFormatIn = new SelectionCharacterFormat(this);
        this.paragraphFormatIn = new SelectionParagraphFormat(this, this.viewer);
        this.sectionFormatIn = new SelectionSectionFormat(this);
        this.rowFormatIn = new SelectionRowFormat(this);
        this.cellFormatIn = new SelectionCellFormat(this);
        this.tableFormatIn = new SelectionTableFormat(this);
        this.imageFormatInternal = new SelectionImageFormat(this);
        this.editRangeCollection = [];
        this.editRegionHighlighters = new Dictionary();
    }
    Object.defineProperty(Selection.prototype, "isHighlightEditRegion", {
        /**
         * @private
         */
        get: function () {
            return this.isHighlightEditRegionIn;
        },
        /**
         * @private
         */
        set: function (value) {
            this.isHighlightEditRegionIn = value;
            this.onHighlight();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "htmlWriter", {
        /**
         * @private
         */
        get: function () {
            if (isNullOrUndefined(this.htmlWriterIn)) {
                this.htmlWriterIn = new HtmlExport();
            }
            return this.htmlWriterIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "start", {
        /**
         * Gets the start text position of last range in the selection
         * @returns {TextPosition}
         * @private
         */
        get: function () {
            if (!isNullOrUndefined(this.owner) && !isNullOrUndefined(this.viewer)) {
                if (isNullOrUndefined(this.startInternal)) {
                    this.startInternal = this.owner.documentStart;
                }
                return this.startInternal;
            }
            return undefined;
        },
        /**
         * @private
         */
        set: function (value) {
            this.startInternal = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "characterFormat", {
        //Format retrieval properties
        /**
         * Gets the instance of selection character format.
         * @default undefined
         * @aspType SelectionCharacterFormat
         * @blazorType SelectionCharacterFormat
         * @return {SelectionCharacterFormat}
         */
        get: function () {
            return this.characterFormatIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "paragraphFormat", {
        /**
         * Gets the instance of selection paragraph format.
         * @default undefined
         * @aspType SelectionParagraphFormat
         * @blazorType SelectionParagraphFormat
         * @return {SelectionParagraphFormat}
         */
        get: function () {
            return this.paragraphFormatIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "sectionFormat", {
        /**
         * Gets the instance of selection section format.
         * @default undefined
         * @aspType SelectionSectionFormat
         * @blazorType SelectionSectionFormat
         * @return {SelectionSectionFormat}
         */
        get: function () {
            return this.sectionFormatIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "tableFormat", {
        /**
         * Gets the instance of selection table format.
         * @default undefined
         * @aspType SelectionTableFormat
         * @blazorType SelectionTableFormat
         * @return {SelectionTableFormat}
         */
        get: function () {
            return this.tableFormatIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "cellFormat", {
        /**
         * Gets the instance of selection cell format.
         * @default undefined
         * @aspType SelectionCellFormat
         * @blazorType SelectionCellFormat
         * @return {SelectionCellFormat}
         */
        get: function () {
            return this.cellFormatIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "rowFormat", {
        /**
         * Gets the instance of selection row format.
         * @default undefined
         * @aspType SelectionRowFormat
         * @blazorType SelectionRowFormat
         * @returns {SelectionRowFormat}
         */
        get: function () {
            return this.rowFormatIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "imageFormat", {
        /**
         * Gets the instance of selection image format.
         * @default undefined
         * @aspType SelectionImageFormat
         * @blazorType SelectionImageFormat
         * @returns {SelectionImageFormat}
         */
        get: function () {
            return this.imageFormatInternal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "end", {
        /**
         * Gets the start text position of selection range.
         * @private
         */
        get: function () {
            return this.endInternal;
        },
        /**
         * For internal use
         * @private
         */
        set: function (value) {
            this.endInternal = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "startPage", {
        /**
         * Gets the page number where the selection ends.
         */
        get: function () {
            if (!this.owner.isDocumentLoaded || isNullOrUndefined(this.viewer)
                || isNullOrUndefined(this.viewer.selectionStartPage)) {
                return 1;
            }
            return this.viewer.pages.indexOf(this.viewer.selectionStartPage) + 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "endPage", {
        /**
         * Gets the page number where the selection ends.
         */
        get: function () {
            if (!this.owner.isDocumentLoaded || isNullOrUndefined(this.viewer)
                || isNullOrUndefined(this.viewer.selectionEndPage)) {
                return 1;
            }
            return this.viewer.pages.indexOf(this.viewer.selectionEndPage) + 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "isForward", {
        /**
         * Determines whether the selection direction is forward or not.
         * @default false
         * @returns {boolean}
         * @private
         */
        get: function () {
            return this.start.isExistBefore(this.end);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "isEmpty", {
        /**
         * Determines whether the start and end positions are same or not.
         * @default false
         * @returns {boolean}
         * @private
         */
        get: function () {
            if (isNullOrUndefined(this.start)) {
                return true;
            }
            return this.start.isAtSamePosition(this.end);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "startOffset", {
        /**
         * Returns start hierarchical index.
         */
        get: function () {
            return this.getHierarchicalIndexByPosition(this.start);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "endOffset", {
        /**
         * Returns end hierarchical index.
         */
        get: function () {
            return this.getHierarchicalIndexByPosition(this.end);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "text", {
        /**
         * Gets the text within selection.
         * @default ''
         * @aspType string
         * @blazorType string
         * @returns {string}
         */
        get: function () {
            return this.getText(false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "contextType", {
        /**
         * Gets the context type of the selection.
         */
        get: function () {
            return this.contextTypeInternal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "bookmarks", {
        /**
         * Gets bookmark name collection.
         */
        get: function () {
            return this.getSelBookmarks();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "isCleared", {
        /**
         * @private
         */
        get: function () {
            return isNullOrUndefined(this.end);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "isInField", {
        /**
         * Returns true if selection is in field
         */
        get: function () {
            if (!isNullOrUndefined(this.getHyperlinkField(true))) {
                return true;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Selection.prototype.getSelBookmarks = function () {
        var bookmarkCln = [];
        var bookmarks = this.viewer.bookmarks;
        var start = this.start;
        var end = this.end;
        if (!this.isForward) {
            start = this.end;
            end = this.start;
        }
        var bookmrkStart;
        var bookmrkEnd;
        var isCellSelected = false;
        var selectedCells = this.getSelectedCells();
        for (var i = 0; i < bookmarks.length; i++) {
            if (bookmarks.keys[i].indexOf('_') !== 0) {
                bookmrkStart = bookmarks.get(bookmarks.keys[i]);
                bookmrkEnd = bookmrkStart.reference;
                var bmStartPos = this.getElementPosition(bookmrkStart).startPosition;
                var bmEndPos = this.getElementPosition(bookmrkEnd).startPosition;
                if (bmStartPos.paragraph.isInsideTable || bmEndPos.paragraph.isInsideTable) {
                    if (selectedCells.length > 0) {
                        if (selectedCells.indexOf(bmStartPos.paragraph.associatedCell) >= 0
                            || selectedCells.indexOf(bmEndPos.paragraph.associatedCell) >= 0) {
                            isCellSelected = true;
                        }
                        else {
                            isCellSelected = false;
                            if (selectedCells.indexOf(bmStartPos.paragraph.associatedCell) < 0
                                || selectedCells.indexOf(bmEndPos.paragraph.associatedCell) < 0) {
                                var endCell = end.paragraph.isInsideTable && end.paragraph.associatedCell;
                                var bmEndPosCell = bmEndPos.paragraph.associatedCell;
                                if (endCell && bmEndPosCell && endCell.ownerTable.equals(bmEndPosCell.ownerTable) &&
                                    !(endCell.ownerTable
                                        && selectedCells.indexOf(this.getCellInTable(endCell.ownerTable, bmEndPosCell)) >= 0)) {
                                    continue;
                                }
                            }
                        }
                    }
                    else {
                        isCellSelected = false;
                    }
                }
                else {
                    isCellSelected = false;
                }
                if ((start.isExistAfter(bmStartPos) || start.isAtSamePosition(bmStartPos))
                    && (end.isExistBefore(bmEndPos) || end.isAtSamePosition(bmEndPos)) ||
                    ((bmStartPos.isExistAfter(start) || bmStartPos.isAtSamePosition(start))
                        && (bmEndPos.isExistBefore(end) || bmEndPos.isAtSamePosition(end))) ||
                    (bmStartPos.isExistAfter(start) && bmStartPos.isExistBefore(end)
                        && (end.isExistAfter(bmEndPos) || end.isExistBefore(bmEndPos))) ||
                    (bmEndPos.isExistBefore(end) && bmEndPos.isExistAfter(start)
                        && (start.isExistBefore(bmStartPos) || start.isExistAfter(bmStartPos))) || isCellSelected) {
                    bookmarkCln.push(bookmrkStart.name);
                }
            }
        }
        return bookmarkCln;
    };
    Selection.prototype.getModuleName = function () {
        return 'Selection';
    };
    //Public API
    /**
     * Moves the selection to the header of current page.
     */
    Selection.prototype.goToHeader = function () {
        this.owner.enableHeaderAndFooter = true;
        this.enableHeadersFootersRegion(this.start.paragraph.bodyWidget.page.headerWidget);
    };
    /**
     * Moves the selection to the footer of current page.
     */
    Selection.prototype.goToFooter = function () {
        this.owner.enableHeaderAndFooter = true;
        this.enableHeadersFootersRegion(this.start.paragraph.bodyWidget.page.footerWidget);
    };
    /**
     * Closes the header and footer region.
     */
    Selection.prototype.closeHeaderFooter = function () {
        this.disableHeaderFooter();
    };
    /**
     * Moves the selection to the start of specified page number.
     */
    Selection.prototype.goToPage = function (pageNumber) {
        if (pageNumber >= 1 && pageNumber <= this.viewer.pages.length) {
            var page = this.viewer.pages[pageNumber - 1];
            this.updateTextPositionForBlockContainer(page.bodyWidgets[0]);
        }
    };
    /**
     * Selects the entire table if the context is within table.
     */
    Selection.prototype.selectTable = function () {
        if (!this.owner.enableSelection) {
            return;
        }
        this.selectTableInternal();
    };
    /**
     * Selects the entire row if the context is within table.
     */
    Selection.prototype.selectRow = function () {
        if (!this.owner.enableSelection) {
            return;
        }
        this.selectTableRow();
    };
    /**
     * Selects the entire column if the context is within table.
     */
    Selection.prototype.selectColumn = function () {
        if (!this.owner.enableSelection) {
            return;
        }
        this.selectColumnInternal();
    };
    /**
     * Selects the entire cell if the context is within table.
     */
    Selection.prototype.selectCell = function () {
        if (!this.owner.enableSelection) {
            return;
        }
        this.selectTableCell();
    };
    Selection.prototype.select = function (selectionSettings, startOrEnd) {
        if (typeof (selectionSettings) === 'string') {
            var startPosition = this.getTextPosBasedOnLogicalIndex(selectionSettings);
            var endPosition = this.getTextPosBasedOnLogicalIndex(startOrEnd);
            this.selectPosition(startPosition, endPosition);
        }
        else {
            var point = new Point(selectionSettings.x, selectionSettings.y);
            var pageCoordinates = this.viewer.findFocusedPage(point, true);
            if (selectionSettings.extend) {
                this.moveTextPosition(pageCoordinates, this.end);
            }
            else {
                this.viewer.updateTextPositionForSelection(pageCoordinates, 1);
            }
        }
    };
    /**
     * Selects based on start and end hierarchical index.
     */
    Selection.prototype.selectByHierarchicalIndex = function (start, end) {
        var startPosition = this.getTextPosBasedOnLogicalIndex(start);
        var endPosition = this.getTextPosBasedOnLogicalIndex(end);
        this.selectPosition(startPosition, endPosition);
    };
    /**
     * Select the current field if selection is in field
     */
    Selection.prototype.selectField = function () {
        if (this.isInField) {
            var fieldStart = this.getHyperlinkField(true);
            var fieldEnd = fieldStart.fieldEnd;
            var offset = fieldStart.line.getOffset(fieldStart, 0);
            var startPosition = new TextPosition(this.viewer.owner);
            startPosition.setPositionParagraph(fieldStart.line, offset);
            var endoffset = fieldEnd.line.getOffset(fieldEnd, 1);
            var endPosition = new TextPosition(this.viewer.owner);
            endPosition.setPositionParagraph(fieldEnd.line, endoffset);
            //selects the field range
            this.viewer.selection.selectRange(startPosition, endPosition);
        }
    };
    /**
     * Toggles the bold property of selected contents.
     * @private
     */
    Selection.prototype.toggleBold = function () {
        if (this.owner.editorModule) {
            this.owner.editorModule.toggleBold();
        }
    };
    /**
     * Toggles the italic property of selected contents.
     * @private
     */
    Selection.prototype.toggleItalic = function () {
        if (this.owner.editorModule) {
            this.owner.editorModule.toggleItalic();
        }
    };
    /**
     * Toggles the underline property of selected contents.
     * @param underline Default value of underline parameter is Single.
     * @private
     */
    Selection.prototype.toggleUnderline = function (underline) {
        if (this.owner.editor) {
            this.owner.editor.toggleUnderline(underline);
        }
    };
    /**
     * Toggles the strike through property of selected contents.
     * @param {Strikethrough} strikethrough Default value of strikethrough parameter is SingleStrike.
     * @private
     */
    Selection.prototype.toggleStrikethrough = function (strikethrough) {
        if (this.owner.editor) {
            this.owner.editor.toggleStrikethrough(strikethrough);
        }
    };
    /**
     * Toggles the highlight color property of selected contents.
     * @param {HighlightColor} highlightColor Default value of underline parameter is Yellow.
     * @private
     */
    Selection.prototype.toggleHighlightColor = function (highlightColor) {
        if (this.owner.editor) {
            this.owner.editor.toggleHighlightColor(highlightColor);
        }
    };
    /**
     * Toggles the subscript formatting of selected contents.
     * @private
     */
    Selection.prototype.toggleSubscript = function () {
        if (this.owner.editor) {
            this.owner.editor.toggleSubscript();
        }
    };
    /**
     * Toggles the superscript formatting of selected contents.
     * @private
     */
    Selection.prototype.toggleSuperscript = function () {
        if (this.owner.editor) {
            this.owner.editor.toggleSuperscript();
        }
    };
    /**
     * Toggles the text alignment property of selected contents.
     * @param {TextAlignment} textAlignment Default value of textAlignment parameter is TextAlignment.Left.
     * @private
     */
    Selection.prototype.toggleTextAlignment = function (textAlignment) {
        if (this.owner.editor) {
            this.owner.editor.toggleTextAlignment(textAlignment);
        }
    };
    /**
     * Increases the left indent of selected paragraphs to a factor of 36 points.
     * @private
     */
    Selection.prototype.increaseIndent = function () {
        if (this.owner.editor) {
            this.owner.editor.increaseIndent();
        }
    };
    /**
     * Decreases the left indent of selected paragraphs to a factor of 36 points.
     * @private
     */
    Selection.prototype.decreaseIndent = function () {
        if (this.owner.editor) {
            this.owner.editor.decreaseIndent();
        }
    };
    /**
     * Fires the `requestNavigate` event if current selection context is in hyperlink.
     */
    Selection.prototype.navigateHyperlink = function () {
        var fieldBegin = this.getHyperlinkField();
        if (fieldBegin) {
            this.fireRequestNavigate(fieldBegin);
        }
    };
    /**
     * Navigate Hyperlink
     * @param fieldBegin
     * @private
     */
    Selection.prototype.fireRequestNavigate = function (fieldBegin) {
        var hyperlink = new Hyperlink(fieldBegin, this);
        var eventArgs = {
            isHandled: false,
            navigationLink: hyperlink.navigationLink,
            linkType: hyperlink.linkType,
            localReference: hyperlink.localReference,
            source: this.owner
        };
        this.owner.trigger('requestNavigate', eventArgs);
        if (!eventArgs.isHandled) {
            this.viewer.selection.navigateBookmark(hyperlink.localReference, true);
        }
    };
    /**
     * Copies the hyperlink URL if the context is within hyperlink.
     */
    Selection.prototype.copyHyperlink = function () {
        var hyperLinkField = this.getHyperlinkField();
        var linkText = this.getLinkText(hyperLinkField);
        this.copyToClipboard(linkText);
    };
    Selection.prototype.isHideSelection = function (paragraph) {
        var bodyWgt = paragraph.bodyWidget;
        var sectionFormat = bodyWgt.sectionFormat;
        var pageHt = sectionFormat.pageHeight - sectionFormat.footerDistance;
        var headerFooterHt = bodyWgt.page.boundingRectangle.height / 100 * 40;
        return this.contextType.indexOf('Footer') >= 0
            && (paragraph.y + paragraph.height > HelperMethods.convertPointToPixel(pageHt))
            || this.contextType.indexOf('Header') >= 0 && paragraph.y + paragraph.height > headerFooterHt;
    };
    //Selection add, Highlight, remove API starts
    /**
     * @private
     */
    Selection.prototype.highlightSelection = function (isSelectionChanged) {
        if (this.owner.enableImageResizerMode) {
            this.owner.imageResizerModule.hideImageResizer();
        }
        if (this.isEmpty) {
            if (this.isHideSelection(this.start.paragraph)) {
                this.hideCaret();
                return;
            }
            this.updateCaretPosition();
        }
        else {
            if (this.isForward) {
                this.highlightSelectedContent(this.start, this.end);
            }
            else {
                this.highlightSelectedContent(this.end, this.start);
            }
            if (this.viewer.isComposingIME) {
                this.updateCaretPosition();
            }
        }
        this.viewer.updateTouchMarkPosition();
        if (isSelectionChanged) {
            this.viewer.scrollToPosition(this.start, this.end);
        }
    };
    /**
     * @private
     */
    Selection.prototype.createHighlightBorder = function (lineWidget, width, left, top, isElementBoxHighlight) {
        if (width < 0) {
            width = 0;
        }
        var page = this.getPage(lineWidget.paragraph);
        var height = lineWidget.height;
        var widgets = this.selectedWidgets;
        var selectionWidget = undefined;
        var selectionWidgetCollection = undefined;
        if (this.isHightlightEditRegionInternal) {
            this.addEditRegionHighlight(lineWidget, left, width);
            return;
        }
        else {
            if (widgets.containsKey(lineWidget)) {
                if (widgets.get(lineWidget) instanceof SelectionWidgetInfo) {
                    selectionWidget = widgets.get(lineWidget);
                    // if the line element has already added with SelectionWidgetInfo
                    // now its need to be added as ElementBox highlighting them remove it from dictionary and add it collection.
                    if (isElementBoxHighlight) {
                        widgets.remove(lineWidget);
                        selectionWidgetCollection = [];
                        widgets.add(lineWidget, selectionWidgetCollection);
                    }
                }
                else {
                    selectionWidgetCollection = widgets.get(lineWidget);
                }
            }
            else {
                if (isElementBoxHighlight) {
                    selectionWidgetCollection = [];
                    widgets.add(lineWidget, selectionWidgetCollection);
                }
                else {
                    selectionWidget = new SelectionWidgetInfo(left, width);
                    widgets.add(lineWidget, selectionWidget);
                }
            }
            if (selectionWidget === undefined) {
                selectionWidget = new SelectionWidgetInfo(left, width);
                widgets.add(lineWidget, selectionWidget);
            }
        }
        var viewer = this.viewer;
        var pageTop = this.getPageTop(page);
        var pageLeft = page.boundingRectangle.x;
        if (viewer.containerTop <= pageTop
            || pageTop < viewer.containerTop + viewer.selectionCanvas.height) {
            var zoomFactor = viewer.zoomFactor;
            this.clipSelection(page, pageTop);
            if (this.viewer.isComposingIME) {
                // tslint:disable-next-line:max-line-length
                this.renderDashLine(viewer.selectionContext, page, lineWidget, (pageLeft + (left * zoomFactor)) - viewer.containerLeft, top, width * zoomFactor, height);
            }
            else {
                this.viewer.selectionContext.fillStyle = 'gray';
                viewer.selectionContext.globalAlpha = 0.4;
                // tslint:disable-next-line:max-line-length
                viewer.selectionContext.fillRect((pageLeft + (left * zoomFactor)) - viewer.containerLeft, (pageTop + (top * zoomFactor)) - viewer.containerTop, width * zoomFactor, height * zoomFactor);
            }
            viewer.selectionContext.restore();
        }
        if (isElementBoxHighlight) {
            selectionWidgetCollection.push(selectionWidget);
        }
    };
    /**
     * @private
     */
    Selection.prototype.addEditRegionHighlight = function (lineWidget, left, width) {
        var highlighters = undefined;
        var collection = this.editRegionHighlighters;
        if (collection.containsKey(lineWidget)) {
            highlighters = collection.get(lineWidget);
        }
        else {
            highlighters = [];
            collection.add(lineWidget, highlighters);
        }
        var editRegionHighlight = new SelectionWidgetInfo(left, width);
        if (this.isCurrentUser) {
            editRegionHighlight.color = this.owner.userColor !== '' ? this.owner.userColor : '#FFFF00';
        }
        highlighters.push(editRegionHighlight);
        return editRegionHighlight;
    };
    /**
     * Create selection highlight inside table
     * @private
     */
    Selection.prototype.createHighlightBorderInsideTable = function (cellWidget) {
        var page = this.getPage(cellWidget);
        var selectionWidget = undefined;
        var left = cellWidget.x - cellWidget.margin.left + cellWidget.leftBorderWidth;
        var width = cellWidget.width + cellWidget.margin.left
            + cellWidget.margin.right - cellWidget.leftBorderWidth - cellWidget.rightBorderWidth;
        var top = cellWidget.y;
        var height = cellWidget.height;
        var pageTop = this.getPageTop(page);
        var pageLeft = page.boundingRectangle.x;
        var isVisiblePage = this.viewer.containerTop <= pageTop
            || pageTop < this.viewer.containerTop + this.viewer.selectionCanvas.height;
        var widgets = this.selectedWidgets;
        if (!this.isHightlightEditRegionInternal) {
            if (widgets.containsKey(cellWidget) && widgets.get(cellWidget) instanceof SelectionWidgetInfo) {
                selectionWidget = widgets.get(cellWidget);
                if (isVisiblePage) {
                    // tslint:disable-next-line:max-line-length
                    this.viewer.selectionContext.clearRect((pageLeft + (selectionWidget.left * this.viewer.zoomFactor) - this.viewer.containerLeft), (pageTop + (top * this.viewer.zoomFactor)) - this.viewer.containerTop, selectionWidget.width * this.viewer.zoomFactor, height * this.viewer.zoomFactor);
                }
            }
            else {
                selectionWidget = new SelectionWidgetInfo(left, width);
                if (widgets.containsKey(cellWidget)) {
                    widgets.remove(widgets.get(cellWidget));
                }
                widgets.add(cellWidget, selectionWidget);
            }
        }
        if (isVisiblePage) {
            this.viewer.selectionContext.fillStyle = 'gray';
            this.viewer.selectionContext.globalAlpha = 0.4;
            var zoomFactor = this.viewer.zoomFactor;
            this.clipSelection(page, pageTop);
            // tslint:disable-next-line:max-line-length
            this.viewer.selectionContext.fillRect((pageLeft + (left * zoomFactor)) - this.viewer.containerLeft, (pageTop + (top * zoomFactor)) - this.viewer.containerTop, width * zoomFactor, height * zoomFactor);
            this.viewer.selectionContext.restore();
        }
    };
    /**
     * @private
     */
    Selection.prototype.clipSelection = function (page, pageTop) {
        var viewer = this.viewer;
        var width = page.boundingRectangle.width * viewer.zoomFactor;
        var height = page.boundingRectangle.height * viewer.zoomFactor;
        var left = page.boundingRectangle.x;
        viewer.selectionContext.beginPath();
        viewer.selectionContext.save();
        viewer.selectionContext.rect(left - viewer.containerLeft, pageTop - viewer.containerTop, width, height);
        viewer.selectionContext.clip();
    };
    /**
     * Add selection highlight
     * @private
     */
    Selection.prototype.addSelectionHighlight = function (canvasContext, widget, top) {
        if (this.selectedWidgets.containsKey(widget)) {
            var height = widget.height;
            var widgetInfo = this.selectedWidgets.get(widget);
            var widgetInfoCollection = undefined;
            if (widgetInfo instanceof SelectionWidgetInfo) {
                widgetInfoCollection = [];
                widgetInfoCollection.push(widgetInfo);
            }
            else {
                widgetInfoCollection = widgetInfo;
            }
            if (!isNullOrUndefined(widgetInfoCollection)) {
                for (var i = 0; i < widgetInfoCollection.length; i++) {
                    var width = this.viewer.render.getScaledValue(widgetInfoCollection[i].width);
                    var left = this.viewer.render.getScaledValue(widgetInfoCollection[i].left, 1);
                    var page = this.owner.selection.getPage(widget.paragraph);
                    this.owner.selection.clipSelection(page, this.owner.selection.getPageTop(page));
                    if (this.viewer.isComposingIME) {
                        this.renderDashLine(canvasContext, page, widget, left, top, width, height);
                    }
                    else {
                        height = this.viewer.render.getScaledValue(height);
                        canvasContext.globalAlpha = 0.4;
                        canvasContext.fillStyle = 'gray';
                        canvasContext.fillRect(left, this.viewer.render.getScaledValue(top, 2), width, height);
                    }
                    canvasContext.restore();
                }
            }
        }
    };
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Selection.prototype.renderDashLine = function (ctx, page, widget, left, top, width, height) {
        var fontColor = this.characterFormat.fontColor;
        var fillColor = fontColor ? HelperMethods.getColor(fontColor) : '#000000';
        ctx.globalAlpha = 1;
        // Get character format copied from selection format
        var format = this.owner.editor.copyInsertFormat(new WCharacterFormat(), false);
        var heightInfo = this.viewer.textHelper.getHeight(format);
        var pageTop = this.getPageTop(page);
        var descent = heightInfo.Height - heightInfo.BaselineOffset;
        top = this.viewer.render.getUnderlineYPosition(widget) + top + 4 - descent;
        // tslint:disable-next-line:max-line-length
        this.viewer.render.renderDashLine(ctx, left, (pageTop - this.viewer.containerTop) + (top * this.viewer.zoomFactor), width, fillColor, true);
    };
    /**
     * Add Selection highlight inside table
     * @private
     */
    Selection.prototype.addSelectionHighlightTable = function (canvasContext, tableCellWidget) {
        if (this.selectedWidgets.containsKey(tableCellWidget)) {
            var selectedWidgetInfo = this.selectedWidgets.get(tableCellWidget);
            var selectedWidgetInfoCollection = undefined;
            if (selectedWidgetInfo instanceof SelectionWidgetInfo) {
                selectedWidgetInfoCollection = [];
                selectedWidgetInfoCollection.push(selectedWidgetInfo);
            }
            else {
                selectedWidgetInfoCollection = selectedWidgetInfo;
            }
            if (!isNullOrUndefined(selectedWidgetInfoCollection)) {
                for (var i = 0; i < selectedWidgetInfoCollection.length; i++) {
                    var left = this.viewer.render.getScaledValue(selectedWidgetInfoCollection[i].left, 1);
                    var top_1 = this.viewer.render.getScaledValue(tableCellWidget.y, 2);
                    var width = this.viewer.render.getScaledValue(selectedWidgetInfoCollection[i].width);
                    var height = this.viewer.render.getScaledValue(tableCellWidget.height);
                    canvasContext.fillStyle = 'gray';
                    var page = this.owner.selection.getPage(tableCellWidget);
                    this.owner.selection.clipSelection(page, this.owner.selection.getPageTop(page));
                    canvasContext.fillRect(left, top_1, width, height);
                    canvasContext.restore();
                }
            }
        }
    };
    /**
     * Remove Selection highlight
     * @private
     */
    Selection.prototype.removeSelectionHighlight = function (widget) {
        var left = 0;
        var top = 0;
        var width = 0;
        var height = 0;
        var page = undefined;
        if (widget instanceof LineWidget) {
            var lineWidget = widget;
            var currentParaWidget = lineWidget.paragraph;
            page = !isNullOrUndefined(currentParaWidget) ?
                this.getPage((lineWidget.paragraph)) : undefined;
            if (isNullOrUndefined(page)) {
                return;
            }
            top = this.getTop(lineWidget);
            height = lineWidget.height;
        }
        else if (widget instanceof TableCellWidget) {
            page = !isNullOrUndefined(widget) ?
                this.getPage(widget) : undefined;
            if (isNullOrUndefined(page)) {
                return;
            }
            top = widget.y;
            height = widget.height;
        }
        if (isNullOrUndefined(page)) {
            return;
        }
        var selectedWidget = this.selectedWidgets.get(widget);
        var selectedWidgetCollection = undefined;
        if (selectedWidget instanceof SelectionWidgetInfo) {
            selectedWidgetCollection = [];
            selectedWidgetCollection.push(selectedWidget);
        }
        else {
            selectedWidgetCollection = selectedWidget;
        }
        if (!isNullOrUndefined(selectedWidgetCollection)) {
            for (var i = 0; i < selectedWidgetCollection.length; i++) {
                width = selectedWidgetCollection[i].width;
                left = selectedWidgetCollection[i].left;
                var pageRect = page.boundingRectangle;
                var pageIndex = this.viewer.pages.indexOf(page);
                var pageGap = this.viewer.pageGap;
                var pageTop = (pageRect.y - pageGap * (pageIndex + 1)) * this.viewer.zoomFactor + pageGap * (pageIndex + 1);
                var pageLeft = pageRect.x;
                var zoomFactor = this.viewer.zoomFactor;
                if (this.viewer.containerTop <= pageTop
                    || pageTop < this.viewer.containerTop + this.viewer.selectionCanvas.height) {
                    // tslint:disable-next-line:max-line-length
                    this.viewer.selectionContext.clearRect((pageLeft + (left * zoomFactor) - this.viewer.containerLeft) - 0.5, (pageTop + (top * zoomFactor)) - this.viewer.containerTop - 0.5, width * zoomFactor + 0.5, height * zoomFactor + 0.5);
                }
            }
        }
    };
    /**
     * Selects Current word
     */
    Selection.prototype.selectCurrentWord = function (excludeSpace) {
        var startPosition = this.start.clone();
        var endPosition = this.end.clone();
        this.selectCurrentWordRange(startPosition, endPosition, excludeSpace ? excludeSpace : false);
        this.selectRange(startPosition, endPosition);
    };
    /**
     * Selects current paragraph
     */
    Selection.prototype.selectParagraph = function () {
        if (!isNullOrUndefined(this.start)) {
            this.start.paragraphStartInternal(this, false);
            this.end.moveToParagraphEndInternal(this, false);
            this.upDownSelectionLength = this.end.location.x;
            this.fireSelectionChanged(true);
        }
    };
    /**
     * Selects current line.
     */
    Selection.prototype.selectLine = function () {
        if (!isNullOrUndefined(this.start)) {
            this.moveToLineStart();
            this.handleShiftEndKey();
        }
    };
    /**
     * Moves selection to start of the document.
     */
    Selection.prototype.moveToDocumentStart = function () {
        this.handleControlHomeKey();
    };
    /**
     * Moves selection to end of the document.
     */
    Selection.prototype.moveToDocumentEnd = function () {
        this.handleControlEndKey();
    };
    /**
     * Moves selection to current paragraph start.
     */
    Selection.prototype.moveToParagraphStart = function () {
        if (this.isForward) {
            this.start.paragraphStartInternal(this, false);
            this.end.setPositionInternal(this.start);
            this.upDownSelectionLength = this.end.location.x;
        }
        else {
            this.end.paragraphStartInternal(this, false);
            this.start.setPositionInternal(this.end);
            this.upDownSelectionLength = this.start.location.x;
        }
        this.fireSelectionChanged(true);
    };
    /**
     * Moves selection to current paragraph end.
     */
    Selection.prototype.moveToParagraphEnd = function () {
        if (this.isForward) {
            this.start.moveToParagraphEndInternal(this, false);
            this.end.setPositionInternal(this.start);
            this.upDownSelectionLength = this.end.location.x;
        }
        else {
            this.end.moveToParagraphEndInternal(this, false);
            this.start.setPositionInternal(this.end);
            this.upDownSelectionLength = this.start.location.x;
        }
        this.fireSelectionChanged(true);
    };
    /**
     * Moves selection to next line.
     */
    Selection.prototype.moveToNextLine = function () {
        this.moveDown();
    };
    /**
     * Moves selection to previous line.
     */
    Selection.prototype.moveToPreviousLine = function () {
        this.moveUp();
    };
    /**
     * Moves selection to next character.
     */
    Selection.prototype.moveToNextCharacter = function () {
        this.handleRightKey();
    };
    /**
     * Moves selection to previous character.
     */
    Selection.prototype.moveToPreviousCharacter = function () {
        this.handleLeftKey();
    };
    /**
     * Select current word range
     * @private
     */
    Selection.prototype.selectCurrentWordRange = function (startPosition, endPosition, excludeSpace) {
        if (!isNullOrUndefined(startPosition)) {
            if (startPosition.offset > 0) {
                var wordStart = startPosition.clone();
                var indexInInline = 0;
                var inlineObj = startPosition.currentWidget.getInline(startPosition.offset, indexInInline);
                var inline = inlineObj.element;
                indexInInline = inlineObj.index;
                if (!isNullOrUndefined(inline) && inline instanceof FieldElementBox && inline.fieldType === 1) {
                    // tslint:disable-next-line:max-line-length
                    if (startPosition.offset > 2 && (!isNullOrUndefined(inline.fieldSeparator) || isNullOrUndefined(inline.fieldBegin))) {
                        wordStart.setPositionParagraph(wordStart.currentWidget, startPosition.offset - 2);
                        wordStart.moveToWordEndInternal(0, false);
                        if (!(wordStart.paragraph === startPosition.paragraph && wordStart.offset === startPosition.offset - 1)) {
                            startPosition.moveToWordStartInternal(2);
                        }
                    }
                    else if (startPosition.offset > 3 && isNullOrUndefined(inline.fieldSeparator)) {
                        wordStart.setPositionParagraph(wordStart.currentWidget, startPosition.offset - 3);
                        wordStart.moveToWordEndInternal(0, false);
                        if (!(wordStart.paragraph === startPosition.paragraph && wordStart.offset === startPosition.offset)) {
                            startPosition.moveToWordStartInternal(2);
                        }
                    }
                }
                else {
                    wordStart.setPositionParagraph(wordStart.currentWidget, startPosition.offset - 1);
                    wordStart.moveToWordEndInternal(0, false);
                    if (!(wordStart.paragraph === startPosition.paragraph && wordStart.offset === startPosition.offset)) {
                        startPosition.moveToWordStartInternal(2);
                    }
                }
            }
            endPosition.moveToWordEndInternal(2, excludeSpace);
        }
    };
    /**
     * Extends selection to paragraph start.
     */
    Selection.prototype.extendToParagraphStart = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.paragraphStartInternal(this, true);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * Extend selection to paragraph end.
     */
    Selection.prototype.extendToParagraphEnd = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToParagraphEndInternal(this, true);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * Move to next text position
     * @private
     */
    Selection.prototype.moveNextPosition = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        if (this.isEmpty) {
            this.start.moveNextPosition();
            this.end.setPositionInternal(this.start);
        }
        this.updateForwardSelection();
        this.upDownSelectionLength = this.start.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * Move to next paragraph
     * @private
     */
    Selection.prototype.moveToNextParagraph = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToNextParagraphStartInternal();
        this.start.setPositionInternal(this.end);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * Move to previous text position
     * @private
     */
    Selection.prototype.movePreviousPosition = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        if (this.isEmpty) {
            this.start.movePreviousPosition();
            this.end.setPositionInternal(this.start);
        }
        this.updateBackwardSelection();
        this.upDownSelectionLength = this.start.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * Move to previous paragraph
     * @private
     */
    Selection.prototype.moveToPreviousParagraph = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToPreviousParagraph(this);
        this.start.setPositionInternal(this.end);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * Extends selection to previous line.
     */
    Selection.prototype.extendToPreviousLine = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToPreviousLine(this, this.upDownSelectionLength);
        this.fireSelectionChanged(true);
    };
    /**
     * Extend selection to line end
     */
    Selection.prototype.extendToLineEnd = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToLineEndInternal(this, true);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * Extends selection to line start.
     */
    Selection.prototype.extendToLineStart = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToLineStartInternal(this, true);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * @private
     */
    Selection.prototype.moveUp = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        if (!this.isEmpty) {
            if (this.isForward) {
                this.end.setPositionInternal(this.start);
            }
            else {
                this.start.setPositionInternal(this.end);
            }
            this.upDownSelectionLength = this.start.location.x;
        }
        this.upDownSelectionLength = this.start.location.x;
        this.start.moveUp(this, this.upDownSelectionLength);
        this.end.setPositionInternal(this.start);
        this.fireSelectionChanged(true);
    };
    /**
     * @private
     */
    Selection.prototype.moveDown = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        if (!this.isEmpty) {
            if (this.isForward) {
                this.start.setPositionInternal(this.end);
            }
            else {
                this.end.setPositionInternal(this.start);
            }
            this.upDownSelectionLength = this.start.location.x;
        }
        this.start.moveDown(this, this.upDownSelectionLength);
        this.end.setPositionInternal(this.start);
        this.fireSelectionChanged(true);
    };
    Selection.prototype.updateForwardSelection = function () {
        if (!this.isEmpty) {
            if (this.isForward) {
                this.start.setPositionInternal(this.end);
            }
            else {
                this.end.setPositionInternal(this.start);
            }
        }
    };
    Selection.prototype.updateBackwardSelection = function () {
        if (!this.isEmpty) {
            if (this.isForward) {
                this.end.setPositionInternal(this.start);
            }
            else {
                this.start.setPositionInternal(this.end);
            }
        }
    };
    /**
     * @private
     */
    Selection.prototype.getFirstBlockInFirstCell = function (table) {
        if (table.childWidgets.length > 0) {
            var firstrow = table.childWidgets[0];
            if (firstrow.childWidgets.length > 0) {
                var firstcell = firstrow.childWidgets[0];
                if (firstcell.childWidgets.length === 0) {
                    return undefined;
                }
                return firstcell.childWidgets[0];
            }
        }
        return undefined;
    };
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Selection.prototype.getFirstCellInRegion = function (row, startCell, selectionLength, isMovePrevious) {
        var cellStart = this.getCellLeft(row, startCell);
        var cellEnd = cellStart + startCell.cellFormat.cellWidth;
        var flag = true;
        if (cellStart <= selectionLength && selectionLength < cellEnd) {
            for (var k = 0; k < row.childWidgets.length; k++) {
                var left = this.getCellLeft(row, row.childWidgets[k]);
                if (HelperMethods.round(cellStart, 2) <= HelperMethods.round(left, 2) &&
                    HelperMethods.round(left, 2) < HelperMethods.round(cellEnd, 2)) {
                    flag = false;
                    return row.childWidgets[k];
                }
            }
        }
        else {
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cellLeft = this.getCellLeft(row, row.childWidgets[j]);
                if (cellLeft <= selectionLength && cellLeft +
                    row.childWidgets[j].cellFormat.cellWidth > selectionLength) {
                    flag = false;
                    return row.childWidgets[j];
                }
            }
        }
        if (flag) {
            if (!isNullOrUndefined(row.previousRenderedWidget) && isMovePrevious) {
                var previousWidget = row.previousRenderedWidget;
                return this.getFirstCellInRegion(previousWidget, startCell, selectionLength, isMovePrevious);
            }
            else if (!isNullOrUndefined(row.nextRenderedWidget) && !isMovePrevious) {
                return this.getFirstCellInRegion(row.nextRenderedWidget, startCell, selectionLength, isMovePrevious);
            }
        }
        return row.childWidgets[0];
    };
    /**
     * @private
     */
    Selection.prototype.getFirstParagraph = function (tableCell) {
        while (tableCell.previousSplitWidget) {
            tableCell = tableCell.previousSplitWidget;
        }
        var firstBlock = tableCell.firstChild;
        return this.getFirstParagraphBlock(firstBlock);
    };
    /**
     * Get last block in last cell
     * @private
     */
    //Table
    Selection.prototype.getLastBlockInLastCell = function (table) {
        if (table.childWidgets.length > 0) {
            var lastRow = table.childWidgets[table.childWidgets.length - 1];
            var lastCell = lastRow.childWidgets[lastRow.childWidgets.length - 1];
            while (lastCell.childWidgets.length === 0 && !isNullOrUndefined(lastCell.previousSplitWidget)) {
                lastCell = lastCell.previousSplitWidget;
            }
            return lastCell.childWidgets[lastCell.childWidgets.length - 1];
        }
        return undefined;
    };
    /**
     * Moves selection to start of the current line.
     */
    Selection.prototype.moveToLineStart = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.updateBackwardSelection();
        this.start.moveToLineStartInternal(this, false);
        this.end.setPositionInternal(this.start);
        this.upDownSelectionLength = this.start.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * Moves selection to end of the current line.
     */
    Selection.prototype.moveToLineEnd = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.updateForwardSelection();
        this.start.moveToLineEndInternal(this, false);
        this.end.setPositionInternal(this.start);
        this.upDownSelectionLength = this.start.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * Get Page top
     * @private
     */
    Selection.prototype.getPageTop = function (page) {
        // tslint:disable-next-line:max-line-length
        return (page.boundingRectangle.y - this.viewer.pageGap * (this.viewer.pages.indexOf(page) + 1)) * this.viewer.zoomFactor + this.viewer.pageGap * (this.viewer.pages.indexOf(page) + 1);
    };
    /**
     * Move text position to cursor point
     * @private
     */
    Selection.prototype.moveTextPosition = function (cursorPoint, textPosition) {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        //Updates the text position based on the cursor position.
        var widget = this.viewer.getLineWidgetInternal(cursorPoint, true);
        if (!isNullOrUndefined(widget)) {
            this.updateTextPositionWidget(widget, cursorPoint, textPosition, true);
        }
        this.upDownSelectionLength = textPosition.location.x;
        var selectionStartIndex = this.start.getHierarchicalIndexInternal();
        var selectionEndIndex = this.end.getHierarchicalIndexInternal();
        if (selectionStartIndex !== selectionEndIndex) {
            // Extends selection end to field begin or field end.
            if (TextPosition.isForwardSelection(selectionStartIndex, selectionEndIndex)) {
                textPosition.validateForwardFieldSelection(selectionStartIndex, selectionEndIndex);
            }
            else {
                textPosition.validateBackwardFieldSelection(selectionStartIndex, selectionEndIndex);
            }
        }
        this.fireSelectionChanged(true);
    };
    //Helper Method Implementation 
    //Document
    /**
     * Get document start position
     * @private
     */
    Selection.prototype.getDocumentStart = function () {
        var block = this.viewer.pages[0].bodyWidgets[0].childWidgets[0];
        return this.setPositionForBlock(block, true);
    };
    /**
     * Get document end position
     * @private
     */
    Selection.prototype.getDocumentEnd = function () {
        var textPosition = undefined;
        var documentStart = this.owner.documentStart;
        var lastPage = this.viewer.pages[this.viewer.pages.length - 1];
        if (!isNullOrUndefined(documentStart) && lastPage.bodyWidgets[0].childWidgets.length > 0) {
            var block = undefined;
            var section = lastPage.bodyWidgets[0];
            var blocks = section.childWidgets;
            var lastBlkItem = blocks.length - 1;
            var lastBlock = blocks[lastBlkItem];
            if (lastBlock instanceof BlockWidget) {
                block = lastBlock;
            }
            textPosition = this.setPositionForBlock(block, false);
        }
        return textPosition;
    };
    //Keyboard shortcut internal API
    /**
     * @private
     * Handles control end key.
     */
    Selection.prototype.handleControlEndKey = function () {
        var documentEnd = undefined;
        if (!isNullOrUndefined(this.owner.documentEnd)) {
            documentEnd = this.owner.documentEnd;
        }
        if (!isNullOrUndefined(documentEnd)) {
            this.owner.selection.selectContent(documentEnd, true);
        }
        this.checkForCursorVisibility();
    };
    /**
     * @private
     * Handles control home key.
     */
    Selection.prototype.handleControlHomeKey = function () {
        var documentStart = undefined;
        if (!isNullOrUndefined(this.owner.documentStart)) {
            documentStart = this.owner.documentStart;
        }
        if (!isNullOrUndefined(documentStart)) {
            this.owner.selection.selectContent(documentStart, true);
        }
        this.checkForCursorVisibility();
    };
    /**
     * @private
     * Handles control left key.
     */
    Selection.prototype.handleControlLeftKey = function () {
        this.extendToWordStartInternal(true);
        this.checkForCursorVisibility();
    };
    /**
     * @private
     * Handles control right key.
     */
    Selection.prototype.handleControlRightKey = function () {
        this.extendToWordEndInternal(true);
        this.checkForCursorVisibility();
    };
    /**
     * Handles control down key.
     * @private
     */
    Selection.prototype.handleControlDownKey = function () {
        this.moveToNextParagraph();
        this.checkForCursorVisibility();
    };
    /**
     * Handles control up key.
     * @private
     */
    Selection.prototype.handleControlUpKey = function () {
        this.moveToPreviousParagraph();
        this.checkForCursorVisibility();
    };
    /**
     * @private
     * Handles shift left key.
     */
    Selection.prototype.handleShiftLeftKey = function () {
        this.extendBackward();
        this.checkForCursorVisibility();
    };
    /**
     * Handles shift up key.
     * @private
     */
    Selection.prototype.handleShiftUpKey = function () {
        this.extendToPreviousLine();
        this.checkForCursorVisibility();
    };
    /**
     * Handles shift right key.
     * @private
     */
    Selection.prototype.handleShiftRightKey = function () {
        this.extendForward();
        this.checkForCursorVisibility();
    };
    /**
     * Handles shift down key.
     * @private
     */
    Selection.prototype.handleShiftDownKey = function () {
        this.extendToNextLine();
        this.checkForCursorVisibility();
    };
    /**
     * @private
     * Handles control shift left key.
     */
    Selection.prototype.handleControlShiftLeftKey = function () {
        var isForward = this.isForward ? this.start.isCurrentParaBidi : this.end.isCurrentParaBidi;
        if (isForward) {
            this.extendToWordEndInternal(false);
        }
        else {
            this.extendToWordStartInternal(false);
        }
        this.checkForCursorVisibility();
    };
    /**
     * Handles control shift up key.
     * @private
     */
    Selection.prototype.handleControlShiftUpKey = function () {
        this.extendToParagraphStart();
        this.checkForCursorVisibility();
    };
    /**
     * Handles control shift right key
     * @private
     */
    Selection.prototype.handleControlShiftRightKey = function () {
        var isForward = this.isForward ? this.start.isCurrentParaBidi : this.end.isCurrentParaBidi;
        if (isForward) {
            this.extendToWordStartInternal(false);
        }
        else {
            this.extendToWordEndInternal(false);
        }
        this.checkForCursorVisibility();
    };
    /**
     * Handles control shift down key.
     * @private
     */
    Selection.prototype.handleControlShiftDownKey = function () {
        this.extendToParagraphEnd();
        this.checkForCursorVisibility();
    };
    /**
     * Handles left key.
     * @private
     */
    Selection.prototype.handleLeftKey = function () {
        if (this.end.isCurrentParaBidi) {
            this.moveNextPosition();
        }
        else {
            this.movePreviousPosition();
        }
        this.checkForCursorVisibility();
    };
    /**
     * Handles up key.
     * @private
     */
    Selection.prototype.handleUpKey = function () {
        this.isMoveDownOrMoveUp = true;
        this.moveUp();
        this.isMoveDownOrMoveUp = false;
        this.checkForCursorVisibility();
    };
    /**
     * Handles right key.
     * @private
     */
    Selection.prototype.handleRightKey = function () {
        if (this.end.isCurrentParaBidi) {
            this.movePreviousPosition();
        }
        else {
            this.moveNextPosition();
        }
        this.checkForCursorVisibility();
    };
    /**
     * Handles end key.
     * @private
     */
    Selection.prototype.handleEndKey = function () {
        this.moveToLineEnd();
        this.checkForCursorVisibility();
    };
    /**
     * Handles home key.
     * @private
     */
    Selection.prototype.handleHomeKey = function () {
        this.moveToLineStart();
        this.checkForCursorVisibility();
    };
    /**
     * Handles down key.
     * @private
     */
    Selection.prototype.handleDownKey = function () {
        this.isMoveDownOrMoveUp = true;
        this.moveDown();
        this.isMoveDownOrMoveUp = false;
        this.checkForCursorVisibility();
    };
    /**
     * Handles shift end key.
     * @private
     */
    Selection.prototype.handleShiftEndKey = function () {
        this.extendToLineEnd();
        this.checkForCursorVisibility();
    };
    /**
     * Handles shift home key.
     * @private
     */
    Selection.prototype.handleShiftHomeKey = function () {
        this.extendToLineStart();
        this.checkForCursorVisibility();
    };
    /**
     * Handles control shift end key.
     * @private
     */
    Selection.prototype.handleControlShiftEndKey = function () {
        var documentEnd = undefined;
        if (!isNullOrUndefined(this.owner.documentEnd)) {
            documentEnd = this.owner.documentEnd;
        }
        if (!isNullOrUndefined(documentEnd)) {
            this.end.setPosition(documentEnd.currentWidget, false);
            this.fireSelectionChanged(true);
        }
        this.checkForCursorVisibility();
    };
    /**
     * Handles control shift home key.
     * @private
     */
    Selection.prototype.handleControlShiftHomeKey = function () {
        var documentStart = undefined;
        if (!isNullOrUndefined(this.owner.documentStart)) {
            documentStart = this.owner.documentStart;
        }
        if (!isNullOrUndefined(documentStart)) {
            this.end.setPositionInternal(documentStart);
            this.fireSelectionChanged(true);
        }
        this.checkForCursorVisibility();
    };
    /**
     * Handles tab key.
     * @param isNavigateInCell
     * @param isShiftTab
     * @private
     */
    Selection.prototype.handleTabKey = function (isNavigateInCell, isShiftTab) {
        var start = this.start;
        if (isNullOrUndefined(start)) {
            return;
        }
        if (start.paragraph.isInsideTable && this.end.paragraph.isInsideTable && (isNavigateInCell || isShiftTab)) {
            //Perform tab navigation
            if (isShiftTab) {
                this.selectPreviousCell();
            }
            else {
                this.selectNextCell();
            }
        }
        else if ((isNavigateInCell || isShiftTab) && !isNullOrUndefined(start) && start.offset === this.getStartOffset(start.paragraph)
            && !isNullOrUndefined(start.paragraph.paragraphFormat) && !isNullOrUndefined(start.paragraph.paragraphFormat.listFormat)
            && start.paragraph.paragraphFormat.listFormat.listId !== -1 && !this.owner.isReadOnlyMode) {
            this.owner.editorModule.updateListLevel(isShiftTab ? false : true);
        }
        else if (!this.owner.isReadOnlyMode) {
            this.owner.editorModule.handleTextInput('\t');
        }
        this.checkForCursorVisibility();
    };
    Selection.prototype.selectPreviousCell = function () {
        var tableCell = this.start.paragraph.associatedCell;
        var tableRow = tableCell.ownerRow;
        var tableAdv = tableRow.ownerTable;
        if (isNullOrUndefined(tableCell.previousWidget)) {
            if (!isNullOrUndefined(tableRow.previousRenderedWidget)) {
                //Move text selection or cursor to previous row's last cell
                var prevRow = undefined;
                if (tableRow.previousRenderedWidget instanceof TableRowWidget) {
                    prevRow = tableRow.previousRenderedWidget;
                }
                this.selectTableCellInternal(prevRow.childWidgets[prevRow.childWidgets.length - 1], true);
            }
        }
        else {
            //Move text selection or cursor to next cell in current row
            var prevCell = undefined;
            if (tableCell.previousWidget instanceof TableCellWidget) {
                prevCell = tableCell.previousWidget;
            }
            this.selectTableCellInternal(prevCell, true);
        }
    };
    Selection.prototype.selectNextCell = function () {
        var tableCell = this.start.paragraph.associatedCell;
        var tableRow = tableCell.ownerRow;
        var tableAdv = tableRow.ownerTable;
        if (isNullOrUndefined(tableCell.nextWidget)) {
            if (isNullOrUndefined(tableRow.nextRenderedWidget) && !this.owner.isReadOnlyMode) {
                //Insert new row below                  
                this.owner.editorModule.insertRow(false);
            }
            else {
                //Move text selection or cursor to next row's first cell
                var nextRow = undefined;
                if (tableRow.nextRenderedWidget instanceof TableRowWidget) {
                    nextRow = tableRow.nextRenderedWidget;
                }
                this.selectTableCellInternal(nextRow.childWidgets[0], true);
            }
            // }
        }
        else {
            //Move text selection or cursor to next cell in current row
            var nextCell = undefined;
            if (tableCell.nextRenderedWidget instanceof TableCellWidget) {
                nextCell = tableCell.nextRenderedWidget;
            }
            this.selectTableCellInternal(nextCell, true);
        }
    };
    /**
     * Select given table cell
     * @private
     */
    Selection.prototype.selectTableCellInternal = function (tableCell, clearMultiSelection) {
        var firstParagraph = this.getFirstParagraph(tableCell);
        var lastParagraph = this.getLastParagraph(tableCell);
        if (firstParagraph === lastParagraph && lastParagraph.isEmpty()) {
            this.selectParagraphInternal(lastParagraph, true);
        }
        else {
            var firstLineWidget = lastParagraph.childWidgets[0];
            this.start.setPosition(firstParagraph.childWidgets[0], true);
            this.end.setPositionParagraph(firstLineWidget, firstLineWidget.getEndOffset());
            this.fireSelectionChanged(true);
        }
    };
    /**
     * Select while table
     * @private
     */
    Selection.prototype.selectTableInternal = function () {
        var start = this.start;
        var end = this.end;
        if (!this.isForward) {
            start = this.end;
            end = this.start;
        }
        if (!isNullOrUndefined(start) && !isNullOrUndefined(end) && !isNullOrUndefined(this.getTable(start, end))) {
            var containerCell = this.getContainerCellOf(start.paragraph.associatedCell, end.paragraph.associatedCell);
            var table = containerCell.ownerTable;
            var firstPara = this.getFirstParagraphBlock(table);
            var lastPara = this.getLastParagraphBlock(table);
            var offset = lastPara.lastChild.getEndOffset();
            this.start.setPosition(firstPara.childWidgets[0], true);
            this.end.setPositionParagraph(lastPara.lastChild, offset + 1);
        }
        this.selectPosition(this.start, this.end);
    };
    /**
     * Select single column
     * @private
     */
    Selection.prototype.selectColumnInternal = function () {
        var startTextPos = this.start;
        var endTextPos = this.end;
        if (!this.isForward) {
            startTextPos = this.end;
            endTextPos = this.start;
        }
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(startTextPos) && !isNullOrUndefined(endTextPos) && !isNullOrUndefined(this.getTable(startTextPos, endTextPos))) {
            var containerCell = this.getContainerCellOf(startTextPos.paragraph.associatedCell, endTextPos.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(endTextPos.paragraph.associatedCell)) {
                var startCell = this.getSelectedCell(startTextPos.paragraph.associatedCell, containerCell);
                var endCell = this.getSelectedCell(endTextPos.paragraph.associatedCell, containerCell);
                if (this.containsCell(containerCell, endTextPos.paragraph.associatedCell)) {
                    var row = startCell.ownerRow;
                    var columnCells = containerCell.ownerTable.getColumnCellsForSelection(containerCell, containerCell);
                    if (columnCells.length > 0) {
                        var firstPara = this.getFirstParagraph(columnCells[0]);
                        var lastPara = this.getLastParagraph(columnCells[columnCells.length - 1]);
                        this.start.setPosition(firstPara.firstChild, true);
                        var lastLine = lastPara.lastChild;
                        this.end.setPositionParagraph(lastLine, lastLine.getEndOffset() + 1);
                    }
                }
                else {
                    var startCellColumnCells = containerCell.ownerTable.getColumnCellsForSelection(startCell, startCell);
                    var endCellColumnCells = containerCell.ownerTable.getColumnCellsForSelection(endCell, endCell);
                    if (startCellColumnCells.length > 0 && endCellColumnCells.length > 0) {
                        var firstPara = this.getFirstParagraph(startCellColumnCells[0]);
                        // tslint:disable-next-line:max-line-length
                        var lastPara = this.getLastParagraph(endCellColumnCells[endCellColumnCells.length - 1]);
                        this.start.setPosition(firstPara.firstChild, true);
                        var lastLine = lastPara.lastChild;
                        this.end.setPositionParagraph(lastLine, lastLine.getEndOffset() + 1);
                    }
                }
            }
        }
        this.selectPosition(this.start, this.end);
    };
    /**
     * Select single row
     * @private
     */
    Selection.prototype.selectTableRow = function () {
        var startPos = this.start;
        var endPos = this.end;
        if (!this.isForward) {
            startPos = this.end;
            endPos = this.start;
        }
        if (!isNullOrUndefined(startPos) && !isNullOrUndefined(endPos) && !isNullOrUndefined(this.getTable(startPos, endPos))) {
            var containerCell = void 0;
            containerCell = this.getContainerCellOf(startPos.paragraph.associatedCell, endPos.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(endPos.paragraph.associatedCell)) {
                var startCell = this.getSelectedCell(startPos.paragraph.associatedCell, containerCell);
                var endCell = this.getSelectedCell(endPos.paragraph.associatedCell, containerCell);
                if (this.containsCell(containerCell, endPos.paragraph.associatedCell)) {
                    var row = startCell.ownerRow;
                    var firstPara = this.getFirstParagraph(row.childWidgets[0]);
                    var lastPara = this.getLastParagraph(row.childWidgets[row.childWidgets.length - 1]);
                    this.start.setPosition(firstPara.firstChild, true);
                    this.end.setPositionParagraph(lastPara.lastChild, lastPara.lastChild.getEndOffset() + 1);
                }
                else {
                    var firstPara = this.getFirstParagraph(startCell.ownerRow.childWidgets[0]);
                    var lastPara = void 0;
                    // tslint:disable-next-line:max-line-length
                    lastPara = this.getLastParagraph(endCell.ownerRow.childWidgets[endCell.ownerRow.childWidgets.length - 1]);
                    this.start.setPosition(firstPara.firstChild, true);
                    this.end.setPositionParagraph(lastPara.lastChild, lastPara.lastChild.getEndOffset() + 1);
                }
            }
        }
        this.selectPosition(this.start, this.end);
    };
    /**
     * Select single cell
     * @private
     */
    Selection.prototype.selectTableCell = function () {
        var start = this.start;
        var end = this.end;
        if (!this.isForward) {
            start = this.end;
            end = this.start;
        }
        if (isNullOrUndefined(this.getTable(start, end))) {
            return;
        }
        if (this.isEmpty) {
            if (start.paragraph.isInsideTable && !isNullOrUndefined(start.paragraph.associatedCell)) {
                var firstPara = this.getFirstParagraph(start.paragraph.associatedCell);
                var lastPara = this.getLastParagraph(end.paragraph.associatedCell);
                if (firstPara === lastPara) {
                    this.start.setPosition(lastPara.firstChild, true);
                    this.end.setPositionParagraph(lastPara.lastChild, lastPara.lastChild.getEndOffset() + 1);
                }
                else {
                    this.start.setPosition(firstPara.firstChild, true);
                    this.end.setPositionParagraph(lastPara.lastChild, lastPara.lastChild.getEndOffset() + 1);
                }
            }
        }
        else {
            var containerCell = this.getContainerCell(start.paragraph.associatedCell);
            // tslint:disable-next-line:max-line-length
            if (this.containsCell(containerCell, start.paragraph.associatedCell) && this.containsCell(containerCell, end.paragraph.associatedCell)) {
                var firstPara = this.getFirstParagraph(containerCell);
                var lastPara = this.getLastParagraph(containerCell);
                if (!isNullOrUndefined(firstPara) && !isNullOrUndefined(lastPara)) {
                    this.start.setPosition(firstPara.firstChild, true);
                    this.end.setPositionParagraph(lastPara.lastChild, lastPara.lastChild.getEndOffset() + 1);
                }
            }
        }
        this.selectPosition(this.start, this.end);
    };
    /**
     * Selects the entire document.
     */
    Selection.prototype.selectAll = function () {
        var documentStart;
        var documentEnd;
        if (this.owner.enableHeaderAndFooter) {
            var headerFooter = this.getContainerWidget(this.start.paragraph);
            documentStart = this.setPositionForBlock(headerFooter.firstChild, true);
            documentEnd = this.setPositionForBlock(headerFooter.lastChild, false);
        }
        else {
            documentStart = this.owner.documentStart;
            documentEnd = this.owner.documentEnd;
        }
        //Selects the entire document.        
        if (!isNullOrUndefined(documentStart)) {
            this.start.setPositionInternal(documentStart);
            this.end.setPositionParagraph(documentEnd.currentWidget, documentEnd.offset + 1);
            this.upDownSelectionLength = this.end.location.x;
            this.fireSelectionChanged(true);
        }
    };
    /**
     * Extends selection backward.
     */
    Selection.prototype.extendBackward = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        var isForward = this.isForward ? this.start.isCurrentParaBidi : this.end.isCurrentParaBidi;
        if (isForward) {
            this.end.moveForward();
        }
        else {
            this.end.moveBackward();
        }
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * Extends selection forward.
     */
    Selection.prototype.extendForward = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        var isForward = this.isForward ? this.start.isCurrentParaBidi : this.end.isCurrentParaBidi;
        if (isForward) {
            this.end.moveBackward();
        }
        else {
            this.end.moveForward();
        }
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * Extend selection to word start and end
     * @private
     */
    Selection.prototype.extendToWordStartEnd = function () {
        if ((this.start.paragraph.isInsideTable || this.end.paragraph.isInsideTable)
            && (this.start.paragraph.associatedCell !== this.end.paragraph.associatedCell
                || this.isCellSelected(this.start.paragraph.associatedCell, this.start, this.end))) {
            return true;
        }
        return false;
    };
    /**
     * Extends selection to word start.
     */
    Selection.prototype.extendToWordStart = function () {
        this.extendToWordStartInternal(false);
    };
    /**
     * Extends selection to word end.
     */
    Selection.prototype.extendToWordEnd = function () {
        this.extendToWordEndInternal(false);
    };
    /**
     * Extends selection to word start
     * @private
     */
    Selection.prototype.extendToWordStartInternal = function (isNavigation) {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        var isCellSelected = this.extendToWordStartEnd();
        if (isCellSelected) {
            this.end.moveToPreviousParagraphInTable(this);
        }
        else {
            if (isNavigation && this.end.isCurrentParaBidi) {
                this.end.moveToWordEndInternal(isNavigation ? 0 : 1, false);
            }
            else {
                this.end.moveToWordStartInternal(isNavigation ? 0 : 1);
            }
        }
        if (isNavigation) {
            this.start.setPositionInternal(this.end);
        }
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * Extends selection to word end.
     */
    Selection.prototype.extendToWordEndInternal = function (isNavigation) {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        var isCellSelect = this.extendToWordStartEnd();
        if (isCellSelect) {
            this.end.moveToNextParagraphInTable();
        }
        else {
            if (isNavigation && this.end.isCurrentParaBidi) {
                this.end.moveToWordStartInternal(isNavigation ? 0 : 1);
            }
            else {
                this.end.moveToWordEndInternal(isNavigation ? 0 : 1, false);
            }
        }
        if (isNavigation) {
            this.start.setPositionInternal(this.end);
        }
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * Extend selection to next line.
     */
    Selection.prototype.extendToNextLine = function () {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToNextLine(this.upDownSelectionLength);
        this.fireSelectionChanged(true);
    };
    //Selection Text get API
    //Selection add, Highlight, remove API enda
    Selection.prototype.getTextPosition = function (hierarchicalIndex) {
        var textPosition = new TextPosition(this.owner);
        textPosition.setPositionForCurrentIndex(hierarchicalIndex);
        return textPosition;
    };
    /**
     * Get Selected text
     * @private
     */
    Selection.prototype.getText = function (includeObject) {
        if (isNullOrUndefined(this.start) || isNullOrUndefined(this.end)
            || isNullOrUndefined(this.start.paragraph) || isNullOrUndefined(this.end.paragraph)) {
            return undefined;
        }
        var startPosition = this.start;
        var endPosition = this.end;
        if (startPosition.isAtSamePosition(endPosition)) {
            return '';
        }
        return this.getTextInternal(startPosition, endPosition, includeObject);
    };
    /**
     * Get selected text
     * @private
     */
    Selection.prototype.getTextInternal = function (start, end, includeObject) {
        if (start.isExistAfter(end)) {
            var temp = end;
            end = start;
            start = temp;
        }
        var startPosition = start;
        var endPosition = end;
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(start) && !isNullOrUndefined(end) && !isNullOrUndefined(start.paragraph) && !isNullOrUndefined(end.paragraph)) {
            var startIndex = 0;
            var endIndex = 0;
            var startOffset = start.offset;
            var endOffset = end.offset;
            var startInlineObj = start.currentWidget.getInline(startOffset, startIndex);
            startIndex = startInlineObj.index;
            var inline = startInlineObj.element;
            // If the start position is at the beginning of field begin that has field end, then field code should be skipped.
            if (inline instanceof FieldElementBox && !isNullOrUndefined(inline.fieldEnd)) {
                var elementInfo = this.getRenderedInline(inline, startIndex);
                inline = elementInfo.element;
                startIndex = elementInfo.index;
            }
            var endInlineObj = end.currentWidget.getInline(endOffset, endIndex);
            var endInline = endInlineObj.element;
            endIndex = endInlineObj.index;
            var text = '';
            // Retrieves the text from start inline.
            if (inline instanceof ImageElementBox && includeObject && startIndex === 0) {
                text = ElementBox.objectCharacter;
            }
            else if (inline instanceof TextElementBox) {
                // tslint:disable-next-line:max-line-length
                text = ((isNullOrUndefined(inline.text)) || (inline.text) === '') || inline.text.length < startIndex ? text : inline.text.substring(startIndex);
            }
            if (startPosition.paragraph === endPosition.paragraph) {
                if (inline instanceof ElementBox) {
                    if (inline === endInline && inline instanceof TextElementBox) {
                        text = text.length < endIndex - startIndex ? text : text.substring(0, endIndex - startIndex);
                    }
                    else if (inline.nextNode instanceof ElementBox) {
                        // tslint:disable-next-line:max-line-length
                        text = text + this.getTextInline(inline.nextNode, endPosition.paragraph, endInline, endIndex, includeObject);
                    }
                }
            }
            else {
                if (inline instanceof ElementBox && inline.nextNode instanceof ElementBox) {
                    text = text + this.getTextInline(inline.nextNode, endPosition.paragraph, undefined, 0, includeObject);
                }
                else {
                    // tslint:disable-next-line:max-line-length
                    var nextParagraphWidget = this.viewer.selection.getNextParagraphBlock(startPosition.paragraph);
                    text = text + '\r';
                    while (!isNullOrUndefined(nextParagraphWidget) && nextParagraphWidget.isEmpty()) {
                        text = text + '\r';
                        if (nextParagraphWidget === endPosition.paragraph) {
                            return text;
                        }
                        nextParagraphWidget = this.viewer.selection.getNextParagraphBlock(nextParagraphWidget);
                    }
                    if (!isNullOrUndefined(nextParagraphWidget) && !nextParagraphWidget.isEmpty()) {
                        // tslint:disable-next-line:max-line-length
                        text = text + this.getTextInline(nextParagraphWidget.childWidgets[0].children[0], endPosition.paragraph, endInline, endIndex, includeObject);
                    }
                }
            }
            // If the selection includes end paragraph mark.
            if (endOffset === (endPosition.currentWidget).getEndOffset() + 1) {
                text = text + '\r';
            }
            return text;
        }
        return undefined;
    };
    /**
     * @private
     * @param block
     * @param offset
     */
    Selection.prototype.getHierarchicalIndex = function (block, offset) {
        var index;
        if (block) {
            if (block instanceof HeaderFooterWidget) {
                var hfString = block.headerFooterType.indexOf('Header') !== -1 ? 'H' : 'F';
                var pageIndex = block.page.index.toString();
                var headerFooterIndex = this.viewer.getHeaderFooter(block.headerFooterType).toString();
                var sectionIndex = block.page.sectionIndex;
                index = sectionIndex + ';' + hfString + ';' + pageIndex + ';' + offset;
            }
            else {
                index = block.index + ';' + offset;
            }
            if (block.containerWidget) {
                if (block instanceof TableCellWidget && block.rowIndex !== block.containerWidget.index) {
                    index = block.rowIndex + ';' + index;
                    block = block.containerWidget;
                }
                return this.getHierarchicalIndex(block.containerWidget, index);
            }
        }
        return index;
    };
    Selection.prototype.getHierarchicalIndexByPosition = function (position) {
        var info = this.getParagraphInfo(position);
        return this.getHierarchicalIndex(info.paragraph, info.offset.toString());
    };
    /**
     * @private
     * Gets logical position.
     */
    Selection.prototype.getTextPosBasedOnLogicalIndex = function (hierarchicalIndex) {
        var textPosition = new TextPosition(this.owner);
        var blockInfo = this.getParagraph({ index: hierarchicalIndex });
        var lineInfo = this.getLineInfoBasedOnParagraph(blockInfo.paragraph, blockInfo.offset);
        textPosition.setPositionForLineWidget(lineInfo.line, lineInfo.offset);
        return textPosition;
    };
    /**
     * Get offset value to update in selection
     * @private
     */
    Selection.prototype.getLineInfoBasedOnParagraph = function (paragraph, offset) {
        var length = this.getParagraphLength(paragraph);
        var next = paragraph.nextSplitWidget;
        if (offset > length + 1 && isNullOrUndefined(next)) {
            offset = length;
        }
        while (offset > length && next instanceof ParagraphWidget) {
            offset -= length;
            paragraph = next;
            length = this.getParagraphLength(paragraph);
            next = paragraph.nextSplitWidget;
        }
        return this.getLineInfo(paragraph, offset);
    };
    /**
     * @private
     */
    Selection.prototype.getParagraph = function (position) {
        var paragraph = this.getParagraphInternal(this.getBodyWidget(position), position);
        return { paragraph: paragraph, offset: parseInt(position.index, 10) };
    };
    /**
     * Gets body widget based on position.
     * @private
     */
    Selection.prototype.getBodyWidget = function (position) {
        var index = position.index.indexOf(';');
        var value = position.index.substring(0, index);
        position.index = position.index.substring(index).replace(';', '');
        var sectionIndex = parseInt(value, 10);
        index = parseInt(value, 10);
        index = position.index.indexOf(';');
        value = position.index.substring(0, index);
        // position = position.substring(index).replace(';', '');
        if (value === 'H' || value === 'F') {
            return this.getHeaderFooterWidget(position);
        }
        index = parseInt(value, 10);
        return this.getBodyWidgetInternal(sectionIndex, index);
    };
    Selection.prototype.getHeaderFooterWidget = function (position) {
        //HEADER OR FOOTER WIDGET
        var index = position.index.indexOf(';');
        var value = position.index.substring(0, index);
        position.index = position.index.substring(index).replace(';', '');
        var isHeader = value === 'H';
        index = position.index.indexOf(';');
        value = position.index.substring(0, index);
        position.index = position.index.substring(index).replace(';', '');
        index = parseInt(value, 10);
        var page = this.viewer.pages[index];
        if (isHeader) {
            return page.headerWidget;
        }
        else {
            return page.footerWidget;
        }
    };
    /**
     * @private
     */
    Selection.prototype.getBodyWidgetInternal = function (sectionIndex, blockIndex) {
        for (var i = 0; i < this.viewer.pages.length; i++) {
            var bodyWidget = this.viewer.pages[i].bodyWidgets[0];
            if (bodyWidget.index === sectionIndex) {
                if (bodyWidget.childWidgets.length > 0 && bodyWidget.firstChild.index <= blockIndex &&
                    bodyWidget.lastChild.index >= blockIndex) {
                    return bodyWidget;
                }
            }
            if (bodyWidget.index > sectionIndex) {
                break;
            }
        }
        return undefined;
    };
    /**
     * Get paragraph relative to position
     * @private
     */
    Selection.prototype.getParagraphInternal = function (container, position) {
        if (isNullOrUndefined(position.index)) {
            return undefined;
        }
        // let ins: Widget = container;
        var index = position.index.indexOf(';');
        var value = '0';
        if (index >= 0) {
            value = position.index.substring(0, index);
            position.index = position.index.substring(index).replace(';', '');
        }
        // if (container instanceof BodyWidget && value === 'HF') {
        //     return this.getParagraph(container.headerFooters, position);
        // }
        index = parseInt(value, 10);
        if (container instanceof TableRowWidget && index >= container.childWidgets.length) {
            position.index = '0;0';
            index = container.childWidgets.length - 1;
        }
        var childWidget = this.getBlockByIndex(container, index);
        if (childWidget) {
            var child = childWidget;
            if (child instanceof ParagraphWidget) {
                if (position.index.indexOf(';') > 0) {
                    position.index = '0';
                }
                return child;
            }
            if (child instanceof Widget) {
                if (position.index.indexOf(';') > 0) {
                    return this.getParagraphInternal(child, position);
                }
                else {
                    //If table is shifted to previous text position then return the first paragraph within table.
                    if (child instanceof TableWidget) {
                        return this.viewer.selection.getFirstParagraphInFirstCell(child);
                    }
                    return undefined;
                }
            }
        }
        else if (container) {
            var nextWidget = container.getSplitWidgets().pop().nextRenderedWidget;
            if (nextWidget instanceof Widget) {
                position.index = '0';
                if (nextWidget instanceof TableWidget) {
                    return this.viewer.selection.getFirstParagraphInFirstCell(nextWidget);
                }
                return nextWidget;
            }
        }
        return undefined;
    };
    /**
     * @private
     */
    Selection.prototype.getBlockByIndex = function (container, blockIndex) {
        var childWidget;
        if (container) {
            for (var j = 0; j < container.childWidgets.length; j++) {
                if (container.childWidgets[j].index === blockIndex) {
                    childWidget = container.childWidgets[j];
                    break;
                }
            }
            if (!childWidget && !(container instanceof HeaderFooterWidget)) {
                return this.getBlockByIndex(container.nextSplitWidget, blockIndex);
            }
        }
        return childWidget;
    };
    /**
     * Get logical offset of paragraph.
     * @private
     */
    Selection.prototype.getParagraphInfo = function (position) {
        return this.getParagraphInfoInternal(position.currentWidget, position.offset);
    };
    /**
     * @private
     */
    Selection.prototype.getParagraphInfoInternal = function (line, lineOffset) {
        var paragraph = line.paragraph;
        var offset = this.getParagraphLength(paragraph, line) + lineOffset;
        var previous = paragraph.previousSplitWidget;
        while (previous instanceof ParagraphWidget) {
            paragraph = previous;
            offset += this.viewer.selection.getParagraphLength(paragraph);
            previous = paragraph.previousSplitWidget;
        }
        return { 'paragraph': paragraph, 'offset': offset };
    };
    /**
     * @private
     */
    Selection.prototype.getListTextElementBox = function (paragarph) {
        if (isNullOrUndefined(paragarph)) {
            return undefined;
        }
        var listTextElement;
        if (!paragarph.isEmpty()) {
            var lineWidget = paragarph.childWidgets[0];
            if (lineWidget.children.length > 1) {
                if (lineWidget.children[0] instanceof ListTextElementBox) {
                    listTextElement = lineWidget.children[0];
                }
            }
        }
        return listTextElement;
    };
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Selection.prototype.getTextInline = function (inlineElement, endParagraphWidget, endInline, endIndex, includeObject) {
        var text = '';
        do {
            if (inlineElement === endInline) {
                if (inlineElement instanceof TextElementBox) {
                    var span = inlineElement;
                    if (!(isNullOrUndefined(span.text) || span.text === '')) {
                        if (span.text.length < endIndex) {
                            text = text + span.text;
                        }
                        else {
                            text = text + span.text.substring(0, endIndex);
                        }
                    }
                    // tslint:disable-next-line:max-line-length
                }
                else if (inlineElement instanceof ImageElementBox && includeObject && endIndex === inlineElement.length) {
                    text = text + ElementBox.objectCharacter;
                }
                return text;
            }
            if (inlineElement instanceof TextElementBox) {
                text = text + inlineElement.text;
            }
            else if (inlineElement instanceof ImageElementBox && includeObject) {
                text = text + ElementBox.objectCharacter;
            }
            else if (inlineElement instanceof FieldElementBox && !isNullOrUndefined(inlineElement.fieldEnd)) {
                if (!isNullOrUndefined(inlineElement.fieldSeparator)) {
                    inlineElement = inlineElement.fieldSeparator;
                }
                else {
                    inlineElement = inlineElement.fieldEnd;
                }
            }
            if (isNullOrUndefined(inlineElement.nextNode)) {
                break;
            }
            inlineElement = inlineElement.nextNode;
        } while (!isNullOrUndefined(inlineElement));
        if (endParagraphWidget === inlineElement.line.paragraph) {
            return text;
        }
        // tslint:disable-next-line:max-line-length
        var nextParagraphWidget = this.viewer.selection.getNextParagraphBlock(inlineElement.line.paragraph);
        while (!isNullOrUndefined(nextParagraphWidget) && nextParagraphWidget.isEmpty()) {
            text = text + '\r';
            if (nextParagraphWidget === endParagraphWidget) {
                return text;
            }
            nextParagraphWidget = this.viewer.selection.getNextParagraphBlock(nextParagraphWidget);
        }
        if (!isNullOrUndefined(nextParagraphWidget) && !nextParagraphWidget.isEmpty()) {
            var lineWidget = nextParagraphWidget.childWidgets[0];
            // tslint:disable-next-line:max-line-length
            text = text + '\r' + this.getTextInline(lineWidget.children[0], endParagraphWidget, endInline, endIndex, includeObject);
        }
        return text;
    };
    /**
     * Returns field code.
     * @private
     * @param fieldBegin
     */
    Selection.prototype.getFieldCode = function (fieldBegin) {
        var fieldCode = '';
        if (!(fieldBegin.fieldEnd instanceof FieldElementBox)) {
            return fieldCode;
        }
        var paragraph = fieldBegin.paragraph;
        var endParagraph = fieldBegin.fieldEnd.paragraph;
        if (fieldBegin.fieldSeparator instanceof FieldElementBox) {
            endParagraph = fieldBegin.fieldSeparator.paragraph;
        }
        var startLineIndex = fieldBegin.line.indexInOwner;
        var startIndex = fieldBegin.indexInOwner;
        do {
            fieldCode += this.getFieldCodeInternal(paragraph, startLineIndex, startIndex);
            if (paragraph === endParagraph) {
                break;
            }
            paragraph = this.getNextParagraphBlock(paragraph);
            startLineIndex = 0;
            startIndex = 0;
        } while (paragraph instanceof ParagraphWidget);
        return fieldCode.trim();
    };
    Selection.prototype.getFieldCodeInternal = function (paragraph, startLineIndex, inlineIndex) {
        var fieldCode = '';
        for (var i = startLineIndex; i < paragraph.childWidgets.length; i++) {
            var line = paragraph.childWidgets[i];
            for (var i_1 = inlineIndex; i_1 < line.children.length; i_1++) {
                var element = line.children[i_1];
                if (element instanceof TextElementBox) {
                    fieldCode += element.text;
                }
                if (element instanceof FieldElementBox
                    && (element.fieldType === 2 || element.fieldType === 1)) {
                    return fieldCode;
                }
            }
            inlineIndex = 0;
        }
        return fieldCode;
    };
    /**
     * @private
     */
    Selection.prototype.getTocFieldInternal = function () {
        var paragraph = this.start.paragraph;
        if (!this.isEmpty && !this.isForward) {
            paragraph = this.end.paragraph;
        }
        while (paragraph instanceof ParagraphWidget && paragraph.childWidgets.length > 0) {
            var line = paragraph.firstChild;
            if (line.children.length > 0) {
                var element = line.children[0];
                var nextElement = element.nextNode;
                if (element instanceof FieldElementBox && element.fieldType === 0 && nextElement instanceof TextElementBox
                    && nextElement.text.trim().toLowerCase().indexOf('toc') === 0) {
                    return element;
                }
            }
            paragraph = paragraph.previousRenderedWidget;
        }
        return undefined;
    };
    /**
     * Get next paragraph in bodyWidget
     * @private
     */
    Selection.prototype.getNextParagraph = function (section) {
        if (section.nextRenderedWidget instanceof BodyWidget) {
            var block = section.nextRenderedWidget.childWidgets[0];
            return this.getFirstParagraphBlock(block);
        }
        return undefined;
    };
    /**
     * @private
     */
    Selection.prototype.getPreviousParagraph = function (section) {
        if (section.previousRenderedWidget instanceof BodyWidget) {
            var bodyWidget = section.previousRenderedWidget;
            var block = bodyWidget.childWidgets[bodyWidget.childWidgets.length - 1];
            return this.getLastParagraphBlock(block);
        }
        return undefined;
    };
    /**
     * Get first paragraph in cell
     * @private
     */
    Selection.prototype.getFirstParagraphInCell = function (cell) {
        var firstBlock = cell.childWidgets[0];
        if (firstBlock instanceof ParagraphWidget) {
            return firstBlock;
        }
        else {
            return this.getFirstParagraphInFirstCell(firstBlock);
        }
    };
    /**
     * Get first paragraph in first cell
     * @private
     */
    Selection.prototype.getFirstParagraphInFirstCell = function (table) {
        if (table.childWidgets.length > 0) {
            var firstRow = table.childWidgets[0];
            var cell = firstRow.childWidgets[0];
            var block = cell.childWidgets[0];
            return this.getFirstParagraphBlock(block);
        }
        return undefined;
    };
    /**
     * Get last paragraph in last cell
     * @private
     */
    Selection.prototype.getLastParagraphInLastCell = function (table) {
        if (table.childWidgets.length > 0) {
            var lastrow = table.lastChild;
            var lastcell = lastrow.lastChild;
            var lastBlock = lastcell.lastChild;
            return this.getLastParagraphBlock(lastBlock);
        }
        return undefined;
    };
    /**
     * Get last paragraph in first row
     * @private
     */
    Selection.prototype.getLastParagraphInFirstRow = function (table) {
        if (table.childWidgets.length > 0) {
            var row = table.firstChild;
            var lastcell = row.lastChild;
            var lastBlock = lastcell.lastChild;
            return this.getLastParagraphBlock(lastBlock);
        }
        return undefined;
    };
    /**
     * Get Next start inline
     * @private
     */
    Selection.prototype.getNextStartInline = function (line, offset) {
        var indexInInline = 0;
        var inlineObj = line.getInline(offset, indexInInline);
        var inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (!isNullOrUndefined(inline) && indexInInline === inline.length && inline.nextNode instanceof FieldElementBox) {
            var nextValidInline = this.getNextValidElement(inline.nextNode);
            if (nextValidInline instanceof FieldElementBox && nextValidInline.fieldType === 0) {
                inline = nextValidInline;
            }
        }
        return inline;
    };
    /**
     * Get previous text inline
     * @private
     */
    Selection.prototype.getPreviousTextInline = function (inline) {
        if (inline.previousNode instanceof TextElementBox) {
            return inline.previousNode;
        }
        if (inline.previousNode instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline.previousNode)) {
            if (inline.previousNode.fieldType === 0 || inline.previousNode.fieldType === 1) {
                return inline.previousNode;
            }
            return inline.previousNode.fieldBegin;
        }
        if (!isNullOrUndefined(inline.previousNode)) {
            return this.getPreviousTextInline((inline.previousNode));
        }
        return undefined;
    };
    /**
     * Get next text inline
     * @private
     */
    Selection.prototype.getNextTextInline = function (inline) {
        if (inline.nextNode instanceof TextElementBox) {
            return inline.nextNode;
        }
        if (inline.nextNode instanceof FieldElementBox && (HelperMethods.isLinkedFieldCharacter(inline.nextNode))) {
            if (inline.nextNode.fieldType === 1 || inline.nextNode.fieldType === 0) {
                return inline.nextNode;
            }
            return inline.nextNode.fieldEnd;
        }
        if (!isNullOrUndefined(inline.nextNode)) {
            return this.getNextTextInline((inline.nextNode));
        }
        return undefined;
    };
    /**
     * Get container table
     * @private
     */
    Selection.prototype.getContainerTable = function (block) {
        if (block.isInsideTable) {
            if (block.associatedCell.ownerTable.isInsideTable) {
                block = this.getContainerTable(block.associatedCell.ownerTable);
            }
            else {
                block = block.associatedCell.ownerTable;
            }
        }
        if (block instanceof TableWidget) {
            return block;
        }
        return undefined;
    };
    /**
     * @private
     */
    Selection.prototype.isExistBefore = function (start, block) {
        if (start.isInsideTable) {
            var cell1 = start.associatedCell;
            if (block.isInsideTable) {
                var cell2 = block.associatedCell;
                if (cell1 === cell2) {
                    return cell1.childWidgets.indexOf(start) < cell1.childWidgets.indexOf(block);
                }
                if (cell1.ownerRow === cell2.ownerRow) {
                    return cell1.cellIndex < cell2.cellIndex;
                }
                if (cell1.ownerTable === cell2.ownerTable) {
                    return cell1.ownerRow.rowIndex < cell2.ownerRow.rowIndex;
                }
                //Checks if current block exists before the block.
                var containerCell = this.getContainerCellOf(cell1, cell2);
                if (containerCell.ownerTable.contains(cell2)) {
                    cell1 = this.getSelectedCell(cell1, containerCell);
                    cell2 = this.getSelectedCell(cell2, containerCell);
                    if (cell1 === containerCell) {
                        return this.isExistBefore(start, cell2.ownerTable);
                    }
                    if (cell2 === containerCell) {
                        return this.isExistBefore(cell1.ownerTable, block);
                    }
                    if (containerCell.ownerRow === cell2.ownerRow) {
                        return containerCell.cellIndex < cell2.cellIndex;
                    }
                    if (containerCell.ownerTable === cell2.ownerTable) {
                        return containerCell.ownerRow.rowIndex < cell2.ownerRow.rowIndex;
                    }
                    return this.isExistBefore(cell1.ownerTable, cell2.ownerTable);
                }
                return this.isExistBefore(containerCell.ownerTable, this.getContainerTable(cell2.ownerTable));
            }
            else {
                var ownerTable = this.getContainerTable(start);
                return this.isExistBefore(ownerTable, block);
            }
        }
        else if (block.isInsideTable) {
            var ownerTable = this.getContainerTable(block);
            return this.isExistBefore(start, ownerTable);
        }
        else {
            {
                if (start.containerWidget === block.containerWidget) {
                    return start.index <
                        block.index;
                }
                if (start.containerWidget instanceof BodyWidget && block.containerWidget instanceof BodyWidget) {
                    //Splitted blocks                     
                    var startPage = this.viewer.pages.indexOf(start.containerWidget.page);
                    var endPage = this.viewer.pages.indexOf(block.containerWidget.page);
                    return startPage < endPage;
                }
            }
        }
        return false;
    };
    /**
     * @private
     */
    Selection.prototype.isExistAfter = function (start, block) {
        if (start.isInsideTable) {
            var cell1 = start.associatedCell;
            //Current paragraph in cell, paragraph in cell
            if (block.isInsideTable) {
                var cell2 = block.associatedCell;
                if (cell1 === cell2) {
                    return cell1.childWidgets.indexOf(start) > cell1.childWidgets.indexOf(block);
                }
                if (cell1.ownerRow === cell2.ownerRow) {
                    return cell1.cellIndex > cell2.cellIndex;
                }
                if (cell1.ownerTable === cell2.ownerTable) {
                    return cell1.ownerRow.rowIndex > cell2.ownerRow.rowIndex;
                }
                //Checks if this block exists before block.
                var containerCell = this.getContainerCellOf(cell1, cell2);
                if (containerCell.ownerTable.contains(cell2)) {
                    cell1 = this.getSelectedCell(cell1, containerCell);
                    cell2 = this.getSelectedCell(cell2, containerCell);
                    if (cell1 === containerCell) {
                        return this.isExistAfter(start, cell2.ownerTable);
                    }
                    if (cell2 === containerCell) {
                        return this.isExistAfter(cell1.ownerTable, block);
                    }
                    if (containerCell.ownerRow === cell2.ownerRow) {
                        return containerCell.cellIndex > cell2.cellIndex;
                    }
                    if (containerCell.ownerTable === cell2.ownerTable) {
                        return containerCell.ownerRow.rowIndex > cell2.ownerRow.rowIndex;
                    }
                    return this.isExistAfter(cell1.ownerTable, cell2.ownerTable);
                }
                return this.isExistAfter(containerCell.ownerTable, this.getContainerTable(cell2.ownerTable));
            }
            else {
                var ownerTable = this.getContainerTable(start);
                return this.isExistAfter(ownerTable, block);
            }
        }
        else if (block.isInsideTable) {
            var ownerTable = this.getContainerTable(block);
            return this.isExistAfter(start, ownerTable);
        }
        else {
            if (start.containerWidget === block.containerWidget) {
                return start.index >
                    block.index;
            }
            if (start.containerWidget instanceof BodyWidget && block.containerWidget instanceof BodyWidget) {
                //Splitted blocks                     
                var startPage = this.viewer.pages.indexOf(start.containerWidget.page);
                var endPage = this.viewer.pages.indexOf(block.containerWidget.page);
                return startPage > endPage;
            }
            //     if (start.owner instanceof WHeaderFooter) {
            //         return (start.owner as WHeaderFooter).childWidgets.indexOf(start) 
            // > (block.owner as WHeaderFooter).childWidgets.indexOf(block);
            //     } else if (start.section === block.section && start.section instanceof WSection) {
            //         return (start.section as WSection).childWidgets.indexOf(start)
            //  > (start.section as WSection).childWidgets.indexOf(block);
            //     } else if (start.wordDocument instanceof WordDocument) {
            // tslint:disable-next-line:max-line-length
            //         return (start.wordDocument as WordDocument).sections.indexOf(start.section as WSection) > (start.wordDocument as WordDocument).sections.indexOf(block.section as WSection);
        }
        return false;
    };
    /**
     * Return true if current inline in exist before inline
     * @private
     */
    Selection.prototype.isExistBeforeInline = function (currentInline, inline) {
        if (currentInline.line === inline.line) {
            return currentInline.line.children.indexOf(currentInline) <
                inline.line.children.indexOf(inline);
        }
        if (currentInline.line.paragraph === inline.line.paragraph) {
            return currentInline.line.paragraph.childWidgets.indexOf(currentInline.line)
                < inline.line.paragraph.childWidgets.indexOf(inline.line);
        }
        var startParagraph = currentInline.line.paragraph;
        var endParagraph = inline.line.paragraph;
        if (startParagraph.containerWidget === endParagraph.containerWidget) {
            if (startParagraph.isInsideTable) {
                return startParagraph.associatedCell.childWidgets.indexOf(startParagraph) <
                    endParagraph.associatedCell.childWidgets.indexOf(endParagraph);
            }
            else if (startParagraph.containerWidget instanceof HeaderFooterWidget) {
                // return ((currentInline.owner as WParagraph).owner as WHeaderFooter).blocks.indexOf(currentInline.owner as WParagraph) <
                //     ((inline.owner as WParagraph).owner as WHeaderFooter).blocks.indexOf(inline.owner as WParagraph);
            }
            else {
                return startParagraph.containerWidget.childWidgets.indexOf(startParagraph) <
                    endParagraph.containerWidget.childWidgets.indexOf(endParagraph);
            }
        }
        return this.isExistBefore(startParagraph, endParagraph);
    };
    /**
     * Return true id current inline is exist after inline
     * @private
     */
    Selection.prototype.isExistAfterInline = function (currentInline, inline) {
        if (currentInline.line === inline.line) {
            return currentInline.line.children.indexOf(currentInline) >
                inline.line.children.indexOf(inline);
        }
        if (currentInline.line.paragraph === inline.line.paragraph) {
            return currentInline.line.paragraph.childWidgets.indexOf(currentInline.line)
                > inline.line.paragraph.childWidgets.indexOf(inline.line);
        }
        var startParagraph = currentInline.line.paragraph;
        var endParagraph = inline.line.paragraph;
        if (startParagraph.containerWidget === endParagraph.containerWidget) {
            if (startParagraph.isInsideTable) {
                return startParagraph.associatedCell.childWidgets.indexOf(startParagraph) >
                    endParagraph.associatedCell.childWidgets.indexOf(endParagraph);
            }
            else if (startParagraph.containerWidget instanceof HeaderFooterWidget) {
                // return ((currentInline.owner as WParagraph).owner as WHeaderFooter).blocks.indexOf(currentInline.owner as WParagraph) <
                //     ((inline.owner as WParagraph).owner as WHeaderFooter).blocks.indexOf(inline.owner as WParagraph);
            }
            else {
                return startParagraph.containerWidget.childWidgets.indexOf(startParagraph) >
                    endParagraph.containerWidget.childWidgets.indexOf(endParagraph);
            }
        }
        return this.isExistAfter(startParagraph, endParagraph);
    };
    /**
     * Get next rendered block
     * @private
     */
    Selection.prototype.getNextRenderedBlock = function (block) {
        if (isNullOrUndefined(block.nextWidget)) {
            return block.nextRenderedWidget;
        }
        return block.nextWidget;
    };
    /**
     * Get next rendered block
     * @private
     */
    Selection.prototype.getPreviousRenderedBlock = function (block) {
        if (isNullOrUndefined(block.previousWidget)) {
            return block.previousRenderedWidget;
        }
        return block.previousWidget;
    };
    /**
     * Get Next paragraph in block
     * @private
     */
    Selection.prototype.getNextParagraphBlock = function (block) {
        if (block.nextRenderedWidget instanceof ParagraphWidget) {
            return block.nextRenderedWidget;
        }
        else if (block.nextRenderedWidget instanceof TableWidget) {
            return this.getFirstParagraphInFirstCell(block.nextRenderedWidget);
        }
        if (block.containerWidget instanceof TableCellWidget) {
            return this.getNextParagraphCell(block.containerWidget);
        }
        else if (block.containerWidget instanceof BodyWidget) {
            var bodyWidget = block.containerWidget;
            return this.getNextParagraph(block.containerWidget);
        }
        else if (block.containerWidget instanceof HeaderFooterWidget && this.isMoveDownOrMoveUp) {
            return this.getFirstBlockInNextHeaderFooter(block);
        }
        return undefined;
    };
    /**
     * @private
     */
    Selection.prototype.getFirstBlockInNextHeaderFooter = function (block) {
        var headerFooter = block.containerWidget;
        var nextBlock;
        if (headerFooter.headerFooterType.indexOf('Header') !== -1) {
            nextBlock = headerFooter.page.footerWidget.firstChild;
        }
        else if (headerFooter.page.nextPage) {
            nextBlock = headerFooter.page.nextPage.headerWidget.firstChild;
        }
        else {
            return undefined;
        }
        if (nextBlock instanceof ParagraphWidget) {
            return nextBlock;
        }
        else {
            return this.getFirstBlockInFirstCell(nextBlock);
        }
    };
    /**
     * @private
     */
    Selection.prototype.getLastBlockInPreviousHeaderFooter = function (block) {
        var headerFooter = block.containerWidget;
        var previousBlock;
        if (headerFooter.headerFooterType.indexOf('Footer') !== -1) {
            previousBlock = headerFooter.page.headerWidget.lastChild;
        }
        else if (headerFooter.page.previousPage) {
            previousBlock = headerFooter.page.previousPage.footerWidget.lastChild;
        }
        else {
            return undefined;
        }
        if (previousBlock instanceof ParagraphWidget) {
            return previousBlock;
        }
        else {
            return this.getFirstBlockInFirstCell(previousBlock);
        }
    };
    /**
     * Get previous paragraph in block
     * @private
     */
    Selection.prototype.getPreviousParagraphBlock = function (block) {
        if (block.previousRenderedWidget instanceof ParagraphWidget) {
            return block.previousRenderedWidget;
        }
        else if (block.previousRenderedWidget instanceof TableWidget) {
            return this.getLastParagraphInLastCell((block.previousRenderedWidget));
        }
        if (block.containerWidget instanceof TableCellWidget) {
            return this.getPreviousParagraphCell((block.containerWidget));
        }
        else if (block.containerWidget instanceof BodyWidget) {
            return this.getPreviousParagraph(block.containerWidget);
        }
        else if (block.containerWidget instanceof HeaderFooterWidget && this.isMoveDownOrMoveUp) {
            return this.getLastBlockInPreviousHeaderFooter(block);
        }
        return undefined;
    };
    /**
     * Get first paragraph in block
     * @private
     */
    Selection.prototype.getFirstParagraphBlock = function (block) {
        if (block instanceof ParagraphWidget) {
            return block;
        }
        else if (block instanceof TableWidget) {
            return this.getFirstParagraphInFirstCell(block);
        }
        return undefined;
    };
    /**
     * Get last paragraph in block
     * @private
     */
    Selection.prototype.getLastParagraphBlock = function (block) {
        if (block instanceof ParagraphWidget) {
            return block;
        }
        else if (block instanceof TableWidget) {
            return this.getLastParagraphInLastCell(block);
        }
        return undefined;
    };
    /**
     * Return true if paragraph has valid inline
     * @private
     */
    Selection.prototype.hasValidInline = function (paragraph, start, end) {
        var index = paragraph.childWidgets.indexOf(start.line);
        for (var i = index; i < paragraph.childWidgets.length; i++) {
            for (var j = 0; j < paragraph.childWidgets[i].children.length; j++) {
                var inline = paragraph.childWidgets[i].children[j];
                if (inline.length === 0) {
                    continue;
                }
                if (inline === end) {
                    return false;
                }
                if (inline instanceof TextElementBox || inline instanceof ImageElementBox
                    || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Get paragraph length
     * @private
     */
    Selection.prototype.getParagraphLength = function (paragraph, endLine, elementInfo) {
        var length = 0;
        for (var j = 0; j < paragraph.childWidgets.length; j++) {
            var line = paragraph.childWidgets[j];
            if (endLine instanceof LineWidget && endLine === line) {
                if (elementInfo) {
                    length += this.getLineLength(line, elementInfo);
                }
                break;
            }
            length += this.getLineLength(line);
        }
        return length;
    };
    /**
     * Get Line length
     * @private
     */
    Selection.prototype.getLineLength = function (line, elementInfo) {
        var length = 0;
        var bidi = line.paragraph.bidi;
        for (var i = !bidi ? 0 : line.children.length - 1; bidi ? i > -1 : i < line.children.length; bidi ? i-- : i++) {
            var element = line.children[i];
            if (element instanceof ListTextElementBox) {
                continue;
            }
            if (elementInfo && elementInfo.element instanceof ElementBox && elementInfo.element === element) {
                length += elementInfo.index;
                break;
            }
            length += element.length;
        }
        return length;
    };
    /**
     * Get line information
     * @private
     */
    Selection.prototype.getLineInfo = function (paragraph, offset) {
        var line = undefined;
        var length = 0;
        var childLength = paragraph.childWidgets.length;
        for (var j = 0; j < childLength; j++) {
            line = paragraph.childWidgets[j];
            length = this.getLineLength(line);
            if (offset <= length || j === childLength - 1) {
                break;
            }
            else {
                offset = offset - length;
            }
        }
        return { 'line': line, 'offset': offset };
    };
    /**
     * @private
     */
    Selection.prototype.getElementInfo = function (line, offset) {
        var element = undefined;
        for (var i = 0; i < line.children.length; i++) {
            element = line.children[i];
            if (element instanceof ListTextElementBox) {
                continue;
            }
            if (offset > element.length
                && (!(offset === element.length + 1 && isNullOrUndefined(element.nextNode)))) {
                offset = offset - element.length;
            }
            else {
                break;
            }
        }
        return { 'element': element, 'index': offset };
    };
    /**
     * Get paragraph start offset
     * @private
     */
    Selection.prototype.getStartOffset = function (paragraph) {
        var startOffset = 0;
        if (paragraph.childWidgets.length > 0) {
            var childWidgets = paragraph.childWidgets[0];
            return this.getStartLineOffset(childWidgets);
        }
        return startOffset;
    };
    /**
     * @private
     */
    Selection.prototype.getStartLineOffset = function (line) {
        var startOffset = 0;
        for (var i = 0; i < line.children.length; i++) {
            var inline = line.children[i];
            if (inline.length === 0) {
                continue;
            }
            // tslint:disable-next-line:max-line-length
            if (inline instanceof TextElementBox || inline instanceof ImageElementBox || inline instanceof BookmarkElementBox
                || inline instanceof EditRangeStartElementBox || inline instanceof EditRangeEndElementBox || inline instanceof CommentCharacterElementBox
                || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                return startOffset;
            }
            if (inline instanceof ListTextElementBox) {
                continue;
            }
            startOffset += inline.length;
        }
        return startOffset;
    };
    /**
     * Get previous paragraph from selection
     * @private
     */
    Selection.prototype.getPreviousSelectionCell = function (cell) {
        if (!isNullOrUndefined(cell.previousRenderedWidget)) {
            if (!this.isForward) {
                var block = cell.previousRenderedWidget.childWidgets[0];
                if (block instanceof ParagraphWidget) {
                    return block;
                }
                else {
                    return this.getFirstParagraphInLastRow(block);
                }
            }
            else {
                var widgets = cell.previousRenderedWidget.childWidgets;
                var block = widgets[widgets.length - 1];
                if (block instanceof ParagraphWidget) {
                    return block;
                }
                else {
                    // tslint:disable-next-line:max-line-length
                    return this.getPreviousParagraphSelection(block.childWidgets[block.childWidgets.length - 1]);
                }
            }
        }
        return this.getPreviousSelectionRow(cell.ownerRow);
    };
    /**
     * Get previous paragraph selection in selection
     * @private
     */
    Selection.prototype.getPreviousSelectionRow = function (row) {
        if (!isNullOrUndefined(row.previousRenderedWidget)) {
            if (!this.isForward) {
                var cell = row.previousRenderedWidget.childWidgets[0];
                var block = cell.childWidgets[0];
                return this.getFirstParagraphBlock(block);
            }
            else {
                return this.getPreviousParagraphSelection(row.previousRenderedWidget);
            }
        }
        return this.getPreviousSelectionBlock(row.ownerTable);
    };
    /**
     * @private
     */
    Selection.prototype.getNextSelectionBlock = function (block) {
        if (block.nextRenderedWidget instanceof ParagraphWidget) {
            return block.nextRenderedWidget;
        }
        else if (block.nextRenderedWidget instanceof TableWidget) {
            if (this.isEmpty || this.isForward) {
                return this.getLastParagraphInFirstRow(block.nextRenderedWidget);
            }
            else {
                return this.getNextParagraphSelection(block.nextRenderedWidget.childWidgets[0]);
            }
        }
        if (block.containerWidget instanceof TableCellWidget) {
            return this.getNextSelectionCell(block.containerWidget);
        }
        else if (block.containerWidget instanceof BodyWidget) {
            return this.getNextSelection(block.containerWidget);
        }
        return undefined;
    };
    /**
     * Get next paragraph from selected cell
     * @private
     */
    Selection.prototype.getNextSelectionCell = function (cell) {
        if (!isNullOrUndefined(cell.nextRenderedWidget)) {
            if (this.isEmpty || this.isForward) {
                // tslint:disable-next-line:max-line-length
                var block = cell.nextRenderedWidget.childWidgets[cell.nextRenderedWidget.childWidgets.length - 1];
                return this.getLastParagraphBlock(block);
            }
            else {
                //Return first paragraph in cell. 
                var block = cell.nextRenderedWidget.childWidgets[0];
                if (block instanceof ParagraphWidget) {
                    return block;
                }
                else {
                    return this.getNextParagraphSelection(block.childWidgets[0]);
                }
            }
        }
        return this.getNextSelectionRow(cell.ownerRow);
    };
    /**
     * Get next paragraph in selection
     * @private
     */
    Selection.prototype.getNextSelectionRow = function (row) {
        if (!isNullOrUndefined(row.nextRenderedWidget)) {
            var isForwardSelection = this.isEmpty || this.isForward;
            if (isForwardSelection) {
                // tslint:disable-next-line:max-line-length
                var cell = row.nextRenderedWidget.childWidgets[row.nextRenderedWidget.childWidgets.length - 1];
                var block = cell.childWidgets[cell.childWidgets.length - 1];
                return this.getLastParagraphBlock(block);
            }
            else {
                return this.getNextParagraphSelection(row.nextRenderedWidget);
            }
        }
        return this.getNextSelectionBlock(row.ownerTable);
    };
    /**
     * Get next block with selection
     * @private
     */
    Selection.prototype.getNextSelection = function (section) {
        if (section.nextRenderedWidget instanceof BodyWidget) {
            var block = section.nextRenderedWidget.childWidgets[0];
            if (block instanceof ParagraphWidget) {
                return block;
            }
            else {
                if (this.isEmpty || this.isForward) {
                    return this.getLastParagraphInFirstRow(block);
                }
                else {
                    return this.getNextParagraphSelection(block.childWidgets[0]);
                }
            }
        }
        return undefined;
    };
    /**
     * @private
     */
    Selection.prototype.getNextParagraphSelection = function (row) {
        //Iterate the exact cell based on UP/Down selection length.
        var cell = row.childWidgets[0];
        if (this.start.paragraph.isInsideTable
            && row.ownerTable.contains(this.start.paragraph.associatedCell)) {
            var startCell = this.getCellInTable(row.ownerTable, this.start.paragraph.associatedCell);
            cell = this.getFirstCellInRegion(row, startCell, this.upDownSelectionLength, false);
        }
        var block = cell.childWidgets[0];
        return this.getFirstParagraphBlock(block);
    };
    /**
     * @private
     */
    Selection.prototype.getPreviousSelectionBlock = function (block) {
        if (block.previousRenderedWidget instanceof ParagraphWidget) {
            return block.previousRenderedWidget;
        }
        else if (block.previousRenderedWidget instanceof TableWidget) {
            if (!this.isForward) {
                return this.getFirstParagraphInLastRow(block.previousRenderedWidget);
            }
            else {
                // tslint:disable-next-line:max-line-length
                return this.getPreviousParagraphSelection(block.previousRenderedWidget.childWidgets[block.previousRenderedWidget.childWidgets.length - 1]);
            }
        }
        if (block.containerWidget instanceof TableCellWidget) {
            return this.getPreviousSelectionCell(block.containerWidget);
        }
        else if (block.containerWidget instanceof BodyWidget) {
            return this.getPreviousSelection(block.containerWidget);
        }
        return undefined;
    };
    /**
     * Get previous paragraph in selection
     * @private
     */
    Selection.prototype.getPreviousSelection = function (section) {
        if (section.previousRenderedWidget instanceof BodyWidget) {
            var prevBodyWidget = section.previousRenderedWidget;
            var block = prevBodyWidget.childWidgets[prevBodyWidget.childWidgets.length - 1];
            if (block instanceof ParagraphWidget) {
                return block;
            }
            else {
                if (!this.isForward) {
                    return this.getFirstParagraphInLastRow(block);
                }
                else {
                    var tableWidget = block;
                    // tslint:disable-next-line:max-line-length
                    return this.getPreviousParagraphSelection(tableWidget.childWidgets[tableWidget.childWidgets.length - 1]);
                }
            }
        }
        return undefined;
    };
    /**
     * @private
     */
    Selection.prototype.getPreviousParagraphSelection = function (row) {
        //Iterate the exact cell based on UP/Down selection length.
        var cell = row.childWidgets[row.childWidgets.length - 1];
        if (this.start.paragraph.isInsideTable
            && row.ownerTable.contains(this.start.paragraph.associatedCell)) {
            var startCell = this.getCellInTable(row.ownerTable, this.start.paragraph.associatedCell);
            cell = this.getLastCellInRegion(row, startCell, this.upDownSelectionLength, true);
        }
        var block = cell.childWidgets[cell.childWidgets.length - 1];
        return this.getLastParagraphBlock(block);
    };
    /**
     * Get last cell in the selected region
     * @private
     */
    Selection.prototype.getLastCellInRegion = function (row, startCell, selLength, isMovePrev) {
        var start = this.getCellLeft(row, startCell);
        var end = start + startCell.cellFormat.cellWidth;
        var flag = true;
        if (start <= selLength && selLength < end) {
            for (var i = row.childWidgets.length - 1; i >= 0; i--) {
                var left = this.getCellLeft(row, row.childWidgets[i]);
                if (HelperMethods.round(start, 2) <= HelperMethods.round(left, 2) &&
                    HelperMethods.round(left, 2) < HelperMethods.round(end, 2)) {
                    flag = false;
                    return row.childWidgets[i];
                }
            }
        }
        else {
            for (var i = row.childWidgets.length - 1; i >= 0; i--) {
                var left = this.getCellLeft(row, row.childWidgets[i]);
                if (left <= selLength && left + row.childWidgets[i].cellFormat.cellWidth > selLength) {
                    flag = false;
                    return row.childWidgets[i];
                }
            }
        }
        if (flag) {
            if (!isNullOrUndefined(row.previousRenderedWidget) && isMovePrev) {
                return this.getLastCellInRegion(row.previousRenderedWidget, startCell, selLength, isMovePrev);
            }
            else if (!isNullOrUndefined(row.nextRenderedWidget) && !isMovePrev) {
                return this.getLastCellInRegion(row.nextRenderedWidget, startCell, selLength, isMovePrev);
            }
        }
        return row.childWidgets[row.childWidgets.length - 1];
    };
    /**
     * Get Container table
     * @private
     */
    Selection.prototype.getCellInTable = function (table, tableCell) {
        while (tableCell.ownerTable.isInsideTable) {
            if (table.equals(tableCell.ownerTable)) {
                return tableCell;
            }
            tableCell = tableCell.ownerTable.associatedCell;
        }
        return tableCell;
    };
    /**
     * Get first paragraph in last row
     * @private
     */
    Selection.prototype.getFirstParagraphInLastRow = function (table) {
        if (table.childWidgets.length > 0) {
            var lastRow = table.childWidgets[table.childWidgets.length - 1];
            var lastCell = lastRow.childWidgets[0];
            var lastBlock = lastCell.childWidgets[0];
            return this.getFirstParagraphBlock(lastBlock);
        }
        return undefined;
    };
    /**
     * Get previous valid offset
     * @private
     */
    Selection.prototype.getPreviousValidOffset = function (paragraph, offset) {
        if (offset === 0) {
            return 0;
        }
        var validOffset = 0;
        var count = 0;
        var value = 0;
        var bidi = paragraph.paragraphFormat.bidi;
        for (var i = 0; i < paragraph.childWidgets.length; i++) {
            var lineWidget = paragraph.childWidgets[i];
            if (!bidi) {
                for (var j = 0; j < lineWidget.children.length; j++) {
                    var inline = lineWidget.children[j];
                    if (inline.length === 0) {
                        continue;
                    }
                    if (offset <= count + inline.length) {
                        return offset - 1 === count ? validOffset : offset - 1;
                    }
                    if (inline instanceof TextElementBox || inline instanceof ImageElementBox
                        || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                        validOffset = count + inline.length;
                    }
                    count += inline.length;
                }
            }
            else {
                value = lineWidget.getInlineForOffset(offset, false, undefined, false, true, false).index;
                if (value >= 0) {
                    return value;
                }
            }
        }
        return offset - 1 === count ? validOffset : offset - 1;
    };
    /**
     * Get next valid offset
     * @private
     */
    Selection.prototype.getNextValidOffset = function (line, offset) {
        var count = 0;
        if (!line.paragraph.paragraphFormat.bidi) {
            for (var i = 0; i < line.children.length; i++) {
                var inline = line.children[i];
                if (inline.length === 0 || inline instanceof ListTextElementBox) {
                    continue;
                }
                if (offset < count + inline.length) {
                    if (inline instanceof TextElementBox || inline instanceof ImageElementBox
                        || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                        return (offset > count ? offset : count) + 1;
                    }
                }
                count += inline.length;
            }
        }
        else {
            if (offset !== this.getLineLength(line)) {
                offset = line.getInlineForOffset(offset, false, undefined, false, false, true).index;
            }
        }
        return offset;
    };
    /**
     * Get paragraph mark size info
     * @private
     */
    Selection.prototype.getParagraphMarkSize = function (paragraph, topMargin, bottomMargin) {
        var size = this.viewer.textHelper.getParagraphMarkSize(paragraph.characterFormat);
        var baselineOffset = size.BaselineOffset;
        var maxHeight = size.Height;
        var maxBaselineOffset = baselineOffset;
        if (paragraph instanceof ParagraphWidget) {
            // let paragraphWidget: ParagraphWidget[] = paragraph.renderedElement() as ParagraphWidget[];
            if (paragraph.childWidgets.length > 0) {
                var lineWidget = paragraph.childWidgets[0];
            }
            //Gets line spacing.
            var lineSpacing = this.viewer.layout.getLineSpacing(paragraph, maxHeight);
            var beforeSpacing = this.viewer.layout.getBeforeSpacing(paragraph);
            topMargin = maxBaselineOffset - baselineOffset;
            bottomMargin = maxHeight - maxBaselineOffset - (size.Height - baselineOffset);
            //Updates line spacing, paragraph after/ before spacing and aligns the text to base line offset.
            var lineSpacingType = paragraph.paragraphFormat.lineSpacingType;
            if (lineSpacingType === 'Multiple') {
                if (lineSpacing > maxHeight) {
                    bottomMargin += lineSpacing - maxHeight;
                }
                else {
                    topMargin += lineSpacing - maxHeight;
                }
            }
            else if (lineSpacingType === 'Exactly') {
                topMargin += lineSpacing - (topMargin + size.Height + bottomMargin);
            }
            else if (lineSpacing > topMargin + size.Height + bottomMargin) {
                topMargin += lineSpacing - (topMargin + size.Height + bottomMargin);
            }
            topMargin += beforeSpacing;
            bottomMargin += this.viewer.layout.getAfterSpacing(paragraph);
        }
        return { 'width': size.Width, 'height': size.Height, 'topMargin': topMargin, 'bottomMargin': bottomMargin };
    };
    /**
     * @private
     */
    Selection.prototype.getPhysicalPositionInternal = function (line, offset, moveNextLine) {
        if (line.paragraph.isEmpty()) {
            var paragraphWidget = line.paragraph;
            var left = paragraphWidget.x;
            if (paragraphWidget.childWidgets.length > 0) {
                var lineWidget = paragraphWidget.childWidgets[0];
                left = this.getLeft(lineWidget);
            }
            var topMargin = 0;
            var bottomMargin = 0;
            var size = this.getParagraphMarkSize(line.paragraph, topMargin, bottomMargin);
            if (offset > 0) {
                left += size.width;
            }
            return new Point(left, paragraphWidget.y + topMargin);
        }
        else {
            var indexInInline = 0;
            var inlineObj = line.getInline(offset, indexInInline, line.paragraph.bidi);
            var inline = inlineObj.element; //return indexInInline must
            indexInInline = inlineObj.index;
            // tslint:disable-next-line:max-line-length
            // if (inline.length === indexInInline && !isNullOrUndefined(inline.nextNode) && this.viewer.renderedElements.containsKey(inline) &&
            //     this.viewer.renderedElements.get(inline).length > 0 && this.viewer.renderedElements.containsKey(inline.nextNode as WInline)
            //     && this.viewer.renderedElements.get(inline.nextNode as WInline).length > 0 &&
            // tslint:disable-next-line:max-line-length
            //     (this.viewer.renderedElements.get(inline)[this.viewer.renderedElements.get(inline).length - 1] as ElementBox).line !== (this.viewer.renderedElements.get(inline.nextNode as WInline)[0] as ElementBox).line) {
            //     //Handled specifically to move the cursor at start of next line.
            //     inline = inline.nextNode as WInline;
            //     indexInInline = 0;
            // }
            return this.getPhysicalPositionInline(inline, indexInInline, moveNextLine);
        }
    };
    /**
     * Highlight selected content
     * @private
     */
    Selection.prototype.highlightSelectedContent = function (start, end) {
        if (start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
            || (!start.paragraph.associatedCell.equals(end.paragraph.associatedCell))
            || this.isCellSelected(start.paragraph.associatedCell, start, end))) {
            this.highlightCell(start.paragraph.associatedCell, this, start, end);
        }
        else {
            var inline = undefined;
            var index = 0;
            if (!this.owner.isReadOnlyMode && start.paragraph === end.paragraph) {
                if (start.offset + 1 === end.offset) {
                    var inlineObj = end.currentWidget.getInline(end.offset, index);
                    inline = inlineObj.element; // return index value
                    index = inlineObj.index;
                    if (inline instanceof ImageElementBox) {
                        var startOffset = start.currentWidget.getOffset(inline, 0);
                        if (startOffset !== start.offset) {
                            inline = undefined;
                        }
                    }
                }
                else {
                    var indexInInline = 0;
                    var startInlineObj = start.currentWidget.getInline(start.offset, indexInInline);
                    var startInline = startInlineObj.element; //return indexInInline
                    indexInInline = startInlineObj.index;
                    if (indexInInline === startInline.length) {
                        startInline = this.getNextRenderedElementBox(startInline, indexInInline);
                    }
                    var endInlineObj = end.currentWidget.getInline(end.offset, indexInInline);
                    var endInline = endInlineObj.element; //return indexInInline
                    indexInInline = endInlineObj.index;
                    // tslint:disable-next-line:max-line-length
                    if (startInline instanceof FieldElementBox && endInline instanceof FieldElementBox && !isNullOrUndefined(startInline.fieldSeparator)) {
                        var fieldValue = startInline.fieldSeparator.nextNode;
                        if (fieldValue instanceof ImageElementBox && fieldValue.nextNode === endInline) {
                            inline = fieldValue;
                        }
                    }
                }
            }
            if (!this.owner.isReadOnlyMode && inline instanceof ImageElementBox && this.owner.isDocumentLoaded) {
                var elementBoxObj = this.getElementBoxInternal(inline, index);
                var elementBox = elementBoxObj.element; //return index 
                index = elementBoxObj.index;
                if (this.owner.enableImageResizerMode) {
                    this.owner.imageResizerModule.positionImageResizer(elementBox);
                    this.owner.imageResizerModule.showImageResizer();
                }
                if (this.viewer.isTouchInput) {
                    this.viewer.touchStart.style.display = 'none';
                    this.viewer.touchEnd.style.display = 'none';
                }
            }
            else {
                this.highlight(start.paragraph, start, end);
                if (this.isHighlightNext) {
                    this.highlightNextBlock(this.hightLightNextParagraph, start, end);
                    this.isHighlightNext = false;
                    this.hightLightNextParagraph = undefined;
                }
            }
        }
    };
    /**
     * @private
     */
    // tslint:disable:max-func-body-length
    Selection.prototype.highlight = function (paragraph, start, end) {
        var selectionStartIndex = 0;
        var selectionEndIndex = 0;
        var startElement = undefined;
        var endElement = undefined;
        var startLineWidget = undefined;
        var endLineWidget = undefined;
        //return start Element and selection start index
        var startLineObj = this.getStartLineWidget(paragraph, start, startElement, selectionStartIndex);
        startElement = startLineObj.element;
        if (isNullOrUndefined(startElement)) {
            startLineWidget = paragraph.childWidgets[0];
        }
        else {
            startLineWidget = startElement.line;
        }
        selectionStartIndex = startLineObj.index;
        var endLineObj = this.getEndLineWidget(end, endElement, selectionEndIndex);
        endElement = endLineObj.element;
        if (endElement) {
            endLineWidget = endElement.line;
        }
        else {
            endLineWidget = end.paragraph.childWidgets[end.paragraph.childWidgets.length - 1];
        }
        selectionEndIndex = endLineObj.index;
        var top = 0;
        var left = 0;
        if (!isNullOrUndefined(startLineWidget)) {
            top = this.getTop(startLineWidget);
            left = this.getLeftInternal(startLineWidget, startElement, selectionStartIndex);
        }
        if (!isNullOrUndefined(startLineWidget) && startLineWidget === endLineWidget) {
            //Selection ends in current line.
            var right = this.getLeftInternal(endLineWidget, endElement, selectionEndIndex);
            var width = 0;
            var isRtlText = false;
            if (endElement instanceof TextElementBox) {
                isRtlText = endElement.isRightToLeft;
            }
            if (!isRtlText && startElement instanceof TextElementBox) {
                isRtlText = startElement.isRightToLeft;
            }
            width = Math.abs(right - left);
            // Handled the highlighting approach as genric for normal and rtl text.
            if (isRtlText || paragraph.bidi) {
                var elementBoxCollection = this.getElementsForward(startLineWidget, startElement, endElement, paragraph.bidi);
                if (elementBoxCollection && elementBoxCollection.length > 1) {
                    for (var i = 0; i < elementBoxCollection.length; i++) {
                        var element = elementBoxCollection[i];
                        var elementIsRTL = false;
                        var index = element instanceof TextElementBox ? element.length : 1;
                        if (element === startElement) {
                            left = this.getLeftInternal(startLineWidget, element, selectionStartIndex);
                            right = this.getLeftInternal(startLineWidget, element, index);
                        }
                        else if (element === endElement) {
                            left = this.getLeftInternal(startLineWidget, element, 0);
                            right = this.getLeftInternal(startLineWidget, element, selectionEndIndex);
                        }
                        else {
                            left = this.getLeftInternal(startLineWidget, element, 0);
                            right = this.getLeftInternal(startLineWidget, element, index);
                        }
                        if (element instanceof TextElementBox) {
                            elementIsRTL = element.isRightToLeft;
                        }
                        width = Math.abs(right - left);
                        // Handled the paragraph mark highliting as special case.
                        if (element === endElement && element instanceof TextElementBox
                            && selectionEndIndex > element.length) {
                            var charFormat = element.line.paragraph.characterFormat;
                            var paragraphMarkWidth = this.viewer.textHelper.getParagraphMarkSize(charFormat).Width;
                            if (paragraph.bidi && !elementIsRTL) {
                                width -= paragraphMarkWidth;
                                // Highlight the element.
                                this.createHighlightBorder(startLineWidget, width, left, top, true);
                                // Highlight the paragraph mark of Bidi paragrph. 
                                left = this.getLineStartLeft(startLineWidget) - paragraphMarkWidth;
                                this.createHighlightBorder(startLineWidget, paragraphMarkWidth, left, top, true);
                                // continue to next element.
                                continue;
                            }
                        }
                        this.createHighlightBorder(startLineWidget, width, elementIsRTL ? right : left, top, true);
                    }
                }
                else { // Need to handle the Paragraph mark highlighting.
                    if (endElement instanceof TextElementBox && selectionEndIndex > endElement.length) {
                        var charFormat = endElement.line.paragraph.characterFormat;
                        var paragraphMarkWidth = this.viewer.textHelper.getParagraphMarkSize(charFormat).Width;
                        // Since isRTLText is truo, so the right is considered as left
                        if (!paragraph.bidi && isRtlText) {
                            right += paragraphMarkWidth;
                            width -= paragraphMarkWidth;
                            // Highlight the element.
                            this.createHighlightBorder(startLineWidget, width, right, top, true);
                            // Highlight the paragraph mark. 
                            right += endElement.width;
                            this.createHighlightBorder(startLineWidget, paragraphMarkWidth, right, top, true);
                        }
                        else if (paragraph.bidi && !isRtlText) {
                            width -= paragraphMarkWidth;
                            // Highlight the element.
                            this.createHighlightBorder(startLineWidget, width, left, top, true);
                            // Highlight the paragraph mark of Bidi paragrph. 
                            left = this.getLineStartLeft(startLineWidget) - paragraphMarkWidth;
                            this.createHighlightBorder(startLineWidget, paragraphMarkWidth, left, top, true);
                        }
                        else {
                            this.createHighlightBorder(startLineWidget, width, isRtlText ? right : left, top, false);
                        }
                    }
                    else {
                        this.createHighlightBorder(startLineWidget, width, isRtlText ? right : left, top, false);
                    }
                }
            }
            else {
                // Start element and end element will be in reverese for Bidi paragraph highlighting. 
                // So, the right is considered based on Bidi property. 
                this.createHighlightBorder(startLineWidget, width, paragraph.bidi ? right : left, top, false);
            }
        }
        else {
            if (!isNullOrUndefined(startLineWidget)) {
                var x = startLineWidget.paragraph.x;
                if (paragraph !== startLineWidget.paragraph) {
                    paragraph = startLineWidget.paragraph;
                }
                var width = this.getWidth(startLineWidget, true) - (left - startLineWidget.paragraph.x);
                // Handled the  highlighting approach as genric for normal and rtl text.
                if (paragraph.bidi || (startElement instanceof TextElementBox && startElement.isRightToLeft)) {
                    var right = 0;
                    // tslint:disable-next-line:max-line-length
                    var elementCollection = this.getElementsForward(startLineWidget, startElement, endElement, paragraph.bidi);
                    if (elementCollection) {
                        var elementIsRTL = false;
                        for (var i = 0; i < elementCollection.length; i++) {
                            var element = elementCollection[i];
                            elementIsRTL = false;
                            if (element === startElement) {
                                left = this.getLeftInternal(startLineWidget, element, selectionStartIndex);
                            }
                            else {
                                left = this.getLeftInternal(startLineWidget, element, 0);
                            }
                            var index = element instanceof TextElementBox ? element.length : 1;
                            right = this.getLeftInternal(startLineWidget, element, index);
                            if (element instanceof TextElementBox) {
                                elementIsRTL = element.isRightToLeft;
                            }
                            width = Math.abs(right - left);
                            this.createHighlightBorder(startLineWidget, width, elementIsRTL ? right : left, top, true);
                        }
                        // Highlight the Paragrph mark for last line.
                        if (startLineWidget.isLastLine()) {
                            // tslint:disable-next-line:max-line-length
                            var charFormat = elementCollection[elementCollection.length - 1].line.paragraph.characterFormat;
                            var paragraphMarkWidth = this.viewer.textHelper.getParagraphMarkSize(charFormat).Width;
                            if (paragraph.bidi) {
                                // The paragraph mark will be at the left most end.
                                left = this.getLineStartLeft(startLineWidget) - paragraphMarkWidth;
                            }
                            else { // The paragraph mark will at right most end.
                                left = elementIsRTL ? startLineWidget.paragraph.x + this.getWidth(startLineWidget, false) : right;
                            }
                            this.createHighlightBorder(startLineWidget, paragraphMarkWidth, left, top, true);
                        }
                    }
                    else {
                        this.createHighlightBorder(startLineWidget, width, left, top, false);
                    }
                }
                else {
                    this.createHighlightBorder(startLineWidget, width, left, top, false);
                }
                var lineIndex = startLineWidget.paragraph.childWidgets.indexOf(startLineWidget);
                //Iterates to last item of paragraph or selection end.                                             
                this.highlightParagraph(paragraph, lineIndex + 1, endLineWidget, endElement, selectionEndIndex);
                if (paragraph.childWidgets.indexOf(end.currentWidget) !== -1) {
                    return;
                }
            }
            if (this.isHideSelection(paragraph)) {
                this.isHighlightNext = false;
                return;
            }
            this.isHighlightNext = true;
            this.hightLightNextParagraph = paragraph;
        }
    };
    Selection.prototype.highlightNextBlock = function (paragraph, start, end) {
        var block = paragraph.nextRenderedWidget;
        if (!isNullOrUndefined(block)) {
            if (block instanceof ParagraphWidget) {
                this.isHighlightNext = false;
                this.highlight(block, start, end);
                if (this.isHighlightNext) {
                    this.highlightNextBlock(this.hightLightNextParagraph, start, end);
                    this.isHighlightNext = false;
                    this.hightLightNextParagraph = undefined;
                }
            }
            else {
                this.highlightTable(block, start, end);
            }
        }
    };
    /**
     * Get start line widget
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Selection.prototype.getStartLineWidget = function (paragraph, start, startElement, selectionStartIndex) {
        var offset = paragraph === start.paragraph ? start.offset : this.getStartOffset(paragraph);
        var startInlineObj = undefined;
        if (paragraph === start.paragraph) {
            startInlineObj = start.currentWidget.getInline(offset, selectionStartIndex);
        }
        else {
            startInlineObj = paragraph.firstChild.getInline(offset, selectionStartIndex);
        }
        startElement = startInlineObj.element; //return selectionStartIndex
        selectionStartIndex = startInlineObj.index;
        if (startElement instanceof FieldElementBox) {
            var inlineInfo = this.getRenderedInline(startElement, selectionStartIndex);
            startElement = inlineInfo.element;
            selectionStartIndex = inlineInfo.index;
        }
        if (offset === this.getParagraphLength(start.paragraph) + 1) {
            selectionStartIndex++;
        }
        return {
            'index': selectionStartIndex, 'element': startElement
        };
    };
    /**
     * Get end line widget
     * @private
     */
    Selection.prototype.getEndLineWidget = function (end, endElement, selectionEndIndex) {
        var endInlineObj = end.currentWidget.getInline(end.offset, selectionEndIndex);
        endElement = endInlineObj.element; //return selection end index
        selectionEndIndex = endInlineObj.index;
        if (endElement instanceof FieldElementBox) {
            var inlineInfo = this.getRenderedInline(endElement, selectionEndIndex);
            endElement = inlineInfo.element;
            selectionEndIndex = inlineInfo.index;
        }
        var lineIndex = end.paragraph.childWidgets.indexOf(end.currentWidget);
        if (lineIndex === end.paragraph.childWidgets.length - 1 && end.offset === this.getLineLength(end.currentWidget) + 1) {
            selectionEndIndex = endElement ? endElement.length + 1 : 1;
        }
        return { 'index': selectionEndIndex, 'element': endElement };
    };
    /**
     * Get line widget
     * @private
     */
    Selection.prototype.getLineWidgetInternal = function (line, offset, moveToNextLine) {
        var lineWidget = undefined;
        if (line.children.length === 0 && line instanceof LineWidget) {
            lineWidget = line;
        }
        else {
            var indexInInline = 0;
            var inlineInfo = line.getInline(offset, indexInInline);
            var inline = inlineInfo.element;
            indexInInline = inlineInfo.index;
            lineWidget = inline instanceof ElementBox ? inline.line
                : this.getLineWidgetInternalInline(inline, indexInInline, moveToNextLine);
        }
        return lineWidget;
    };
    /**
     * Get last line widget
     * @private
     */
    Selection.prototype.getLineWidgetParagraph = function (offset, line) {
        var linewidget = undefined;
        if (line.children.length === 0) {
            linewidget = line;
        }
        else {
            var indexInInline = 0;
            var inlineInfo = line.getInline(offset, indexInInline);
            var inline = inlineInfo.element;
            indexInInline = inlineInfo.index;
            linewidget = this.getLineWidget(inline, indexInInline);
        }
        return linewidget;
    };
    /**
     * Highlight selected cell
     * @private
     */
    /* tslint:disable */
    // tslint:disable-next-line:max-line-length    
    Selection.prototype.highlightCells = function (table, startCell, endCell) {
        var start = this.getCellLeft(startCell.ownerRow, startCell);
        var end = start + startCell.cellFormat.cellWidth;
        var endCellLeft = this.getCellLeft(endCell.ownerRow, endCell);
        var endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        if (start > endCellLeft) {
            start = endCellLeft;
        }
        if (end < endCellRight) {
            end = endCellRight;
        }
        if (start > this.upDownSelectionLength) {
            start = this.upDownSelectionLength;
        }
        if (end < this.upDownSelectionLength) {
            end = this.upDownSelectionLength;
        }
        var tableWidgetCollection = table.getSplitWidgets();
        var startTableIndex = tableWidgetCollection.indexOf(startCell.ownerRow.ownerTable);
        var endTableIndex = tableWidgetCollection.indexOf(endCell.ownerRow.ownerTable);
        if (startTableIndex === endTableIndex) {
            var count = table.childWidgets.indexOf(endCell.ownerRow);
            for (var i = table.childWidgets.indexOf(startCell.ownerRow); i <= count; i++) {
                this.highlightRow(table.childWidgets[i], start, end);
            }
        }
        else {
            var startRowIndex = 0;
            var endRowIndex = 0;
            for (var i = startTableIndex; i <= endTableIndex; i++) {
                table = tableWidgetCollection[i];
                if (i === startTableIndex) {
                    startRowIndex = table.childWidgets.indexOf(startCell.ownerRow);
                }
                else {
                    startRowIndex = 0;
                }
                if (i === endTableIndex) {
                    endRowIndex = table.childWidgets.indexOf(endCell.ownerRow);
                }
                else {
                    endRowIndex = table.childWidgets.length - 1;
                }
                for (var j = startRowIndex; j <= endRowIndex; j++) {
                    this.highlightRow(table.childWidgets[j], start, end);
                }
            }
        }
    };
    /* tslint:enable */
    /**
     * highlight selected table
     * @private
     */
    Selection.prototype.highlightTable = function (table, start, end) {
        this.highlightInternal(table.childWidgets[0], start, end);
        if (!end.paragraph.isInsideTable //Selection end is outside the table cell.
            || !table.contains(end.paragraph.associatedCell)) { //Selection end is not inside the current table.
            this.highlightNextBlock(table, start, end);
        }
    };
    /**
     * Get cell left
     * @private
     */
    Selection.prototype.getCellLeft = function (row, cell) {
        var left = 0;
        left += cell.x - cell.margin.left;
        return left;
    };
    /**
     * Get next paragraph for row
     * @private
     */
    Selection.prototype.getNextParagraphRow = function (row) {
        if (!isNullOrUndefined(row.nextRenderedWidget)) {
            var cell = row.nextRenderedWidget.childWidgets[0];
            var block = cell.childWidgets[0];
            return this.getFirstParagraphBlock(block);
        }
        return this.getNextParagraphBlock(row.ownerTable);
    };
    /**
     * Get previous paragraph from row
     * @private
     */
    Selection.prototype.getPreviousParagraphRow = function (row) {
        if (!isNullOrUndefined(row.previousRenderedWidget)) {
            // tslint:disable-next-line:max-line-length
            var cell = row.previousRenderedWidget.lastChild;
            var block = cell.lastChild ? cell.lastChild : (cell.previousSplitWidget).lastChild;
            return this.getLastParagraphBlock(block);
        }
        return this.getPreviousParagraphBlock(row.ownerTable);
    };
    /**
     * Return true if row contain cell
     * @private
     */
    Selection.prototype.containsRow = function (row, tableCell) {
        if (row.childWidgets.indexOf(tableCell) !== -1) {
            return true;
        }
        while (tableCell.ownerTable.isInsideTable) {
            if (row.childWidgets.indexOf(tableCell) !== -1) {
                return true;
            }
            tableCell = tableCell.ownerTable.associatedCell;
        }
        return row.childWidgets.indexOf(tableCell) !== -1;
    };
    /**
     * Highlight selected row
     * @private
     */
    Selection.prototype.highlightRow = function (row, start, end) {
        for (var i = 0; i < row.childWidgets.length; i++) {
            var left = this.getCellLeft(row, row.childWidgets[i]);
            if (HelperMethods.round(start, 2) <= HelperMethods.round(left, 2) &&
                HelperMethods.round(left, 2) < HelperMethods.round(end, 2)) {
                this.highlightCellWidget(row.childWidgets[i]);
            }
        }
    };
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Selection.prototype.highlightInternal = function (row, start, end) {
        for (var i = 0; i < row.childWidgets.length; i++) {
            this.highlightCellWidget(row.childWidgets[i]);
        }
        if (end.paragraph.isInsideTable && this.containsRow(row, end.paragraph.associatedCell)) {
            return;
        }
        else if (row.nextRenderedWidget instanceof TableRowWidget) {
            this.highlightInternal(row.nextRenderedWidget, start, end);
        }
    };
    /**
     * Get last paragraph in cell
     * @private
     */
    Selection.prototype.getLastParagraph = function (cell) {
        while (cell.nextSplitWidget) {
            if (cell.nextSplitWidget.childWidgets.length > 0) {
                cell = cell.nextSplitWidget;
            }
            else {
                break;
            }
        }
        var lastBlock;
        if (cell.childWidgets.length > 0) {
            lastBlock = cell.lastChild;
        }
        else {
            lastBlock = cell.previousSplitWidget.lastChild;
        }
        return this.getLastParagraphBlock(lastBlock);
    };
    /**
     * Return true is source cell contain cell
     * @private
     */
    Selection.prototype.containsCell = function (sourceCell, cell) {
        if (sourceCell.equals(cell)) {
            return true;
        }
        while (cell.ownerTable.isInsideTable) {
            if (sourceCell.equals(cell.ownerTable.associatedCell)) {
                return true;
            }
            cell = cell.ownerTable.associatedCell;
        }
        return false;
    };
    /**
     * Return true if cell is selected
     * @private
     */
    Selection.prototype.isCellSelected = function (cell, startPosition, endPosition) {
        var lastParagraph = this.getLastParagraph(cell);
        // tslint:disable-next-line:max-line-length
        var isAtCellEnd = lastParagraph === endPosition.paragraph && endPosition.offset === this.getParagraphLength(lastParagraph) + 1;
        return isAtCellEnd || (!this.containsCell(cell, startPosition.paragraph.associatedCell) ||
            !this.containsCell(cell, endPosition.paragraph.associatedCell));
    };
    /**
     * Return Container cell
     * @private
     */
    Selection.prototype.getContainerCellOf = function (cell, tableCell) {
        while (cell.ownerTable.isInsideTable) {
            if (cell.ownerTable.contains(tableCell)) {
                return cell;
            }
            cell = cell.ownerTable.associatedCell;
        }
        return cell;
    };
    /**
     * Get Selected cell
     * @private
     */
    Selection.prototype.getSelectedCell = function (cell, containerCell) {
        if (cell.ownerTable.equals(containerCell.ownerTable)) {
            return cell;
        }
        while (cell.ownerTable.isInsideTable) {
            if (cell.ownerTable.associatedCell.equals(containerCell)) {
                return cell;
            }
            cell = cell.ownerTable.associatedCell;
        }
        return cell;
    };
    /**
     * @private
     */
    Selection.prototype.getSelectedCells = function () {
        var cells = [];
        for (var i = 0; i < this.selectedWidgets.keys.length; i++) {
            var widget = this.selectedWidgets.keys[i];
            if (widget instanceof TableCellWidget) {
                cells.push(widget);
            }
        }
        return cells;
    };
    /**
     * Get Next paragraph from cell
     * @private
     */
    Selection.prototype.getNextParagraphCell = function (cell) {
        if (cell.nextRenderedWidget && cell.nextRenderedWidget instanceof TableCellWidget) {
            //Return first paragraph in cell.            
            cell = cell.nextRenderedWidget;
            var block = cell.firstChild;
            if (block) {
                return this.getFirstParagraphBlock(block);
            }
            else {
                return this.getNextParagraphCell(cell);
            }
        }
        return this.getNextParagraphRow(cell.containerWidget);
    };
    /**
     * Get previous paragraph from cell
     * @private
     */
    Selection.prototype.getPreviousParagraphCell = function (cell) {
        if (!isNullOrUndefined(cell.previousRenderedWidget) && cell.previousRenderedWidget instanceof TableCellWidget) {
            cell = cell.previousRenderedWidget;
            var block = cell.lastChild;
            return this.getLastParagraphBlock(block);
        }
        return this.getPreviousParagraphRow(cell.ownerRow);
    };
    /**
     * Get cell's container cell
     * @private
     */
    Selection.prototype.getContainerCell = function (cell) {
        while (!isNullOrUndefined(cell.ownerTable) && cell.ownerTable.isInsideTable) {
            cell = cell.ownerTable.associatedCell;
        }
        return cell;
    };
    /**
     * Highlight selected cell
     * @private
     */
    /* tslint:disable */
    Selection.prototype.highlightCell = function (cell, selection, start, end) {
        if (end.paragraph.isInsideTable) {
            var containerCell = this.getContainerCellOf(cell, end.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(end.paragraph.associatedCell)) {
                var startCell = this.getSelectedCell(cell, containerCell);
                var endCell = this.getSelectedCell(end.paragraph.associatedCell, containerCell);
                if (this.containsCell(containerCell, end.paragraph.associatedCell)) {
                    /* tslint:enable */
                    //Selection end is in container cell.
                    if (this.isCellSelected(containerCell, start, end)) {
                        this.highlightCellWidget(containerCell);
                    }
                    else {
                        if (startCell === containerCell) {
                            this.highlight(start.paragraph, start, end);
                            if (this.isHighlightNext) {
                                this.highlightNextBlock(this.hightLightNextParagraph, start, end);
                                this.isHighlightNext = false;
                                this.hightLightNextParagraph = undefined;
                            }
                        }
                        else {
                            this.highlightContainer(startCell, start, end);
                        }
                    }
                }
                else {
                    //Selection end is not in container cell.
                    this.highlightCellWidget(containerCell);
                    if (containerCell.ownerRow.equals(endCell.ownerRow)) {
                        //Highlight other selected cells in current row.
                        startCell = containerCell;
                        while (!isNullOrUndefined(startCell.nextRenderedWidget)) {
                            startCell = startCell.nextRenderedWidget;
                            this.highlightCellWidget(startCell);
                            if (startCell === endCell) {
                                break;
                            }
                        }
                    }
                    else {
                        this.highlightCells(containerCell.ownerTable, containerCell, endCell);
                    }
                }
            }
            else {
                this.highlightContainer(containerCell, start, end);
            }
        }
        else {
            var cell1 = this.getContainerCell(cell);
            this.highlightContainer(cell1, start, end);
        }
    };
    /**
     * @private
     */
    Selection.prototype.highlightContainer = function (cell, start, end) {
        this.highlightInternal(cell.containerWidget, start, end);
        this.highlightNextBlock(cell.ownerTable, start, end);
    };
    /**
     * Get previous valid element
     * @private
     */
    Selection.prototype.getPreviousValidElement = function (inline) {
        var previousValidInline = undefined;
        while (inline instanceof FieldElementBox) {
            if (HelperMethods.isLinkedFieldCharacter(inline)) {
                if (inline instanceof FieldElementBox && inline.fieldType === 0) {
                    previousValidInline = inline;
                }
                else if (inline instanceof FieldElementBox && inline.fieldType === 1) {
                    previousValidInline = inline;
                    if (isNullOrUndefined(inline.fieldSeparator)) {
                        inline = inline.fieldBegin;
                        previousValidInline = inline;
                    }
                }
                else {
                    inline = inline.fieldBegin;
                    previousValidInline = inline;
                }
            }
            inline = inline.previousNode;
        }
        return isNullOrUndefined(previousValidInline) ? inline : previousValidInline;
    };
    /**
     * Get next valid element
     * @private
     */
    Selection.prototype.getNextValidElement = function (inline) {
        var nextValidInline = undefined;
        if (inline instanceof BookmarkElementBox && inline.bookmarkType === 1) {
            return inline;
        }
        while (inline instanceof FieldElementBox) {
            if (inline.fieldType === 0 && !isNullOrUndefined(inline.fieldEnd)) {
                return isNullOrUndefined(nextValidInline) ? inline : nextValidInline;
            }
            else if (inline.fieldType === 1 && !isNullOrUndefined(inline.fieldBegin)) {
                nextValidInline = inline;
            }
            inline = inline.nextNode;
        }
        return (isNullOrUndefined(nextValidInline) ? inline : nextValidInline);
    };
    /**
     * Return next valid inline with index
     * @private
     */
    Selection.prototype.validateTextPosition = function (inline, index) {
        if (inline.length === index && (inline.nextNode instanceof FieldElementBox || inline.nextNode instanceof BookmarkElementBox)) {
            //If inline is last item within field, then set field end as text position.
            var nextInline = this.getNextValidElement(inline.nextNode);
            if (nextInline instanceof FieldElementBox && nextInline.fieldType === 1
                || nextInline instanceof BookmarkElementBox && nextInline.bookmarkType === 1) {
                inline = nextInline;
                index = 1;
            }
        }
        else if (index === 0 && inline.previousNode instanceof FieldElementBox) {
            var prevInline = this.getPreviousValidElement(inline.previousNode);
            inline = prevInline;
            index = inline instanceof FieldElementBox ? 0 : inline.length;
            if (inline instanceof FieldElementBox && inline.fieldType === 1) {
                index++;
            }
        }
        return { 'element': inline, 'index': index };
    };
    /**
     * Get inline physical location
     * @private
     */
    Selection.prototype.getPhysicalPositionInline = function (inline, index, moveNextLine) {
        var element = undefined;
        element = this.getElementBox(inline, index, moveNextLine).element;
        var lineWidget = undefined;
        if (isNullOrUndefined(element) || isNullOrUndefined(element.line)) {
            if (inline instanceof FieldElementBox && inline.fieldType === 1) {
                element = inline;
            }
            else {
                if (inline instanceof FieldElementBox || inline instanceof BookmarkElementBox) {
                    return this.getFieldCharacterPosition(inline);
                }
                return new Point(0, 0);
            }
        }
        var margin = element.margin;
        var top = 0;
        var left = 0;
        if (element instanceof TextElementBox && element.text === '\v' && isNullOrUndefined(inline.nextNode)) {
            lineWidget = this.getNextLineWidget(element.line.paragraph, element);
            index = 0;
        }
        else {
            lineWidget = element.line;
        }
        top = this.getTop(lineWidget);
        if (element instanceof ImageElementBox) {
            var format = element.line.paragraph.characterFormat;
            var previousInline = this.getPreviousTextElement(inline);
            if (!isNullOrUndefined(previousInline)) {
                format = previousInline.characterFormat;
            }
            else {
                var nextInline = this.getNextTextElement(inline);
                if (!isNullOrUndefined(nextInline)) {
                    format = nextInline.characterFormat;
                }
            }
            var measureObj = this.viewer.textHelper.getHeight(format);
            if (element.margin.top + element.height - measureObj.BaselineOffset > 0) {
                top += element.margin.top + element.height - measureObj.BaselineOffset;
            }
        }
        else if (!(element instanceof FieldElementBox)) {
            top += margin.top > 0 ? margin.top : 0;
        }
        left = (isNullOrUndefined(element) || isNullOrUndefined(lineWidget)) ? 0 : this.getLeftInternal(lineWidget, element, index);
        return new Point(left, top);
    };
    /**
     * Get field character position
     * @private
     */
    Selection.prototype.getFieldCharacterPosition = function (firstInline) {
        var nextValidInline = this.getNextValidElementForField(firstInline);
        //If field separator/end exists at end of paragraph, then move to next paragraph.
        if (isNullOrUndefined(nextValidInline)) {
            var nextParagraph = firstInline.line.paragraph;
            return this.getEndPosition(nextParagraph);
        }
        else {
            return this.getPhysicalPositionInline(nextValidInline, 0, true);
        }
    };
    /**
     * @private
     */
    Selection.prototype.getNextValidElementForField = function (firstInline) {
        if (firstInline instanceof FieldElementBox && firstInline.fieldType === 0
            && HelperMethods.isLinkedFieldCharacter(firstInline)) {
            var fieldBegin = firstInline;
            if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                firstInline = fieldBegin.fieldEnd;
            }
            else {
                firstInline = fieldBegin.fieldSeparator;
            }
        }
        var nextValidInline = undefined;
        if (!isNullOrUndefined(firstInline.nextNode)) {
            nextValidInline = this.getNextValidElement(firstInline.nextNode);
        }
        return nextValidInline;
    };
    /**
     * Get paragraph end position
     * @private
     */
    Selection.prototype.getEndPosition = function (widget) {
        var left = widget.x;
        var top = widget.y;
        var lineWidget = undefined;
        if (widget.childWidgets.length > 0) {
            lineWidget = widget.childWidgets[widget.childWidgets.length - 1];
            left += this.getWidth(lineWidget, false);
        }
        if (!isNullOrUndefined(lineWidget)) {
            top = this.getTop(lineWidget);
        }
        var topMargin = 0;
        var bottomMargin = 0;
        var size = this.getParagraphMarkSize(widget, topMargin, bottomMargin);
        return new Point(left, top + size.topMargin);
    };
    /**
     * Get element box
     * @private
     */
    Selection.prototype.getElementBox = function (currentInline, index, moveToNextLine) {
        var elementBox = undefined;
        if (!(currentInline instanceof FieldElementBox || currentInline instanceof BookmarkElementBox)) {
            elementBox = currentInline;
        }
        return { 'element': elementBox, 'index': index };
    };
    /**
     * @private
     */
    Selection.prototype.getPreviousTextElement = function (inline) {
        if (inline.previousNode instanceof TextElementBox) {
            return inline.previousNode;
        }
        if (!isNullOrUndefined(inline.previousNode)) {
            return this.getPreviousTextElement(inline.previousNode);
        }
        return undefined;
    };
    /**
     * Get next text inline
     * @private
     */
    Selection.prototype.getNextTextElement = function (inline) {
        if (inline.nextNode instanceof TextElementBox) {
            return inline.nextNode;
        }
        if (!isNullOrUndefined(inline.nextNode)) {
            return this.getNextTextElement(inline.nextNode);
        }
        return undefined;
    };
    /**
     * @private
     */
    Selection.prototype.getNextRenderedElementBox = function (inline, indexInInline) {
        if (inline instanceof FieldElementBox) {
            var fieldBegin = inline;
            if (fieldBegin.fieldType === 0) {
                inline = this.getRenderedField(fieldBegin);
                if (fieldBegin === inline) {
                    return fieldBegin;
                }
            }
            indexInInline = 1;
        }
        while (!isNullOrUndefined(inline) && indexInInline === inline.length && inline.nextNode instanceof FieldElementBox) {
            var nextValidInline = this.getNextValidElement((inline.nextNode));
            if (nextValidInline instanceof FieldElementBox && nextValidInline.fieldType === 0) {
                var fieldBegin = nextValidInline;
                inline = this.getRenderedField(fieldBegin);
                if (!isNullOrUndefined(inline) && fieldBegin === inline) {
                    return fieldBegin;
                }
                indexInInline = 1;
            }
            else {
                inline = nextValidInline;
            }
        }
        return inline;
    };
    /**
     * @private
     */
    Selection.prototype.getElementBoxInternal = function (inline, index) {
        var element = undefined;
        element = inline;
        return {
            'element': element, 'index': index
        };
    };
    /**
     * Get Line widget
     * @private
     */
    Selection.prototype.getLineWidget = function (inline, index) {
        return this.getLineWidgetInternalInline(inline, index, true);
    };
    /**
     * @private
     */
    Selection.prototype.getLineWidgetInternalInline = function (inline, index, moveToNextLine) {
        var elementObj = this.getElementBox(inline, index, moveToNextLine);
        var element = elementObj.element; //return index
        index = elementObj.index;
        if (!isNullOrUndefined(element)) {
            if (moveToNextLine && element instanceof TextElementBox && element.text === '\v' && index === 1) {
                return this.getNextLineWidget(element.line.paragraph, element);
            }
            else {
                return element.line;
            }
        }
        var startInline = inline;
        //ToDo: Check previous inline here.
        var nextValidInline = this.getNextValidElementForField(startInline);
        //If field separator/end exists at end of paragraph, then move to next paragraph.
        if (isNullOrUndefined(nextValidInline)) {
            var lineWidget = undefined;
            var widget = startInline.line.paragraph;
            if (widget.childWidgets.length > 0) {
                lineWidget = widget.childWidgets[widget.childWidgets.length - 1];
            }
            return lineWidget;
        }
        else {
            return this.getLineWidget(nextValidInline, 0);
        }
    };
    /**
     * Get next line widget
     * @private
     */
    Selection.prototype.getNextLineWidget = function (paragraph, element) {
        var lineWidget = undefined;
        var widget = paragraph;
        if (widget.childWidgets.length > 0) {
            var widgetIndex = widget.childWidgets.indexOf(element.line);
            if (widgetIndex === widget.childWidgets.length - 1) {
                widget = paragraph;
                // widget = paragraph.leafWidgets[paragraph.leafWidgets.length - 1];
                widgetIndex = -1;
            }
            else if (widgetIndex > widget.childWidgets.length - 1) {
                widget = this.getNextParagraphBlock(paragraph);
                widgetIndex = -1;
            }
            else if (widgetIndex < 0) {
                // widget = paragraph.leafWidgets[paragraph.leafWidgets.length - 1];
                widget = paragraph;
                widgetIndex = widget.childWidgets.indexOf(element.line);
            }
            lineWidget = widget.childWidgets[widgetIndex + 1];
        }
        return lineWidget;
    };
    /**
     * Get Caret height
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Selection.prototype.getCaretHeight = function (inline, index, format, isEmptySelection, topMargin, isItalic) {
        var elementBoxInfo = this.getElementBox(inline, index, false);
        var element = elementBoxInfo.element;
        var currentInline = inline;
        if (isNullOrUndefined(element)) {
            if (currentInline instanceof FieldElementBox) {
                return this.getFieldCharacterHeight(currentInline, format, isEmptySelection, topMargin, isItalic);
            }
            return { 'height': this.viewer.textHelper.getHeight(format).Height, 'topMargin': topMargin, 'isItalic': isItalic };
        }
        var margin = element.margin;
        var heightElement = element.height;
        var maxLineHeight = 0;
        if (element instanceof ImageElementBox) {
            var previousInline = this.getPreviousTextElement(inline);
            var nextInline = this.getNextTextElement(inline);
            if (isNullOrUndefined(previousInline) && isNullOrUndefined(nextInline)) {
                var top_2 = 0;
                var bottom = 0;
                var paragarph = inline.line.paragraph;
                var sizeInfo = this.getParagraphMarkSize(paragarph, top_2, bottom);
                top_2 = sizeInfo.topMargin;
                bottom = sizeInfo.bottomMargin;
                maxLineHeight = sizeInfo.height;
                isItalic = paragarph.characterFormat.italic;
                if (!isEmptySelection) {
                    maxLineHeight += this.viewer.layout.getAfterSpacing(paragarph);
                }
            }
            else if (isNullOrUndefined(previousInline)) {
                isItalic = nextInline.characterFormat.italic;
                return this.getCaretHeight(nextInline, 0, nextInline.characterFormat, isEmptySelection, topMargin, isItalic);
            }
            else {
                if (!isNullOrUndefined(nextInline) && element instanceof ImageElementBox) {
                    //Calculates the caret size using image character format.
                    var textSizeInfo = this.viewer.textHelper.getHeight(element.characterFormat);
                    var charHeight = textSizeInfo.Height;
                    var baselineOffset = textSizeInfo.BaselineOffset;
                    // tslint:disable-next-line:max-line-length
                    maxLineHeight = (element.margin.top < 0 && baselineOffset > element.margin.top + element.height) ? element.margin.top + element.height + charHeight - baselineOffset : charHeight;
                    if (!isEmptySelection) {
                        maxLineHeight += element.margin.bottom;
                    }
                }
                else {
                    isItalic = previousInline.characterFormat.italic;
                    // tslint:disable-next-line:max-line-length
                    return this.getCaretHeight(previousInline, previousInline.length, previousInline.characterFormat, isEmptySelection, topMargin, isItalic);
                }
            }
        }
        else {
            var baselineAlignment = format.baselineAlignment;
            var elementHeight = heightElement;
            if (baselineAlignment !== 'Normal' && isEmptySelection) {
                //Set the caret height as sub/super script text height and updates the top margin for sub script text.
                elementHeight = elementHeight / 1.5;
                if (baselineAlignment === 'Subscript') {
                    topMargin = heightElement - elementHeight;
                }
            }
            maxLineHeight = (margin.top < 0 ? margin.top : 0) + elementHeight;
            if (!isEmptySelection) {
                maxLineHeight += margin.bottom;
            }
        }
        if (!isEmptySelection) {
            return { 'height': maxLineHeight, 'topMargin': topMargin, 'isItalic': isItalic };
        }
        var height = this.viewer.textHelper.getHeight(format).Height;
        if (height > maxLineHeight) {
            height = maxLineHeight;
        }
        return { 'height': height, 'topMargin': topMargin, 'isItalic': isItalic };
    };
    /**
     * Get field characters height
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Selection.prototype.getFieldCharacterHeight = function (startInline, format, isEmptySelection, topMargin, isItalic) {
        var nextValidInline = this.getNextValidElementForField(startInline);
        //If field separator/end exists at end of paragraph, then move to next paragraph.
        if (isNullOrUndefined(nextValidInline)) {
            var nextParagraph = startInline.line.paragraph;
            var height = this.viewer.textHelper.getParagraphMarkSize(format).Height;
            var top_3 = 0;
            var bottom = 0;
            var sizeInfo = this.getParagraphMarkSize(nextParagraph, top_3, bottom);
            var maxLineHeight = sizeInfo.height;
            top_3 = sizeInfo.topMargin;
            bottom = sizeInfo.bottomMargin;
            if (!isEmptySelection) {
                maxLineHeight += bottom;
                return { 'height': maxLineHeight, 'topMargin': topMargin, 'isItalic': isItalic };
            }
            if (height > maxLineHeight) {
                height = maxLineHeight;
            }
            return { 'height': height, 'topMargin': topMargin, 'isItalic': isItalic };
        }
        else {
            return this.getCaretHeight(nextValidInline, 0, format, isEmptySelection, topMargin, isItalic);
        }
    };
    /**
     * Get rendered inline
     * @private
     */
    //FieldCharacter
    Selection.prototype.getRenderedInline = function (inline, inlineIndex) {
        var prevInline = this.getPreviousValidElement(inline);
        while (prevInline instanceof FieldElementBox) {
            prevInline = this.getPreviousTextElement(prevInline);
            if (prevInline instanceof FieldElementBox) {
                prevInline = prevInline.previousNode;
            }
        }
        if (!isNullOrUndefined(prevInline)) {
            inlineIndex = prevInline.length;
            return { 'element': prevInline, 'index': inlineIndex };
        }
        inlineIndex = 0;
        var nextInline = this.getNextRenderedElementBox(inline, 0);
        if (nextInline instanceof FieldElementBox && nextInline.fieldType === 0) {
            nextInline = nextInline.fieldSeparator;
            nextInline = nextInline.nextNode;
            while (nextInline instanceof FieldElementBox) {
                if (nextInline instanceof FieldElementBox && nextInline.fieldType === 0
                    && HelperMethods.isLinkedFieldCharacter(nextInline)) {
                    if (isNullOrUndefined(nextInline.fieldSeparator)) {
                        nextInline = nextInline.fieldEnd;
                    }
                    else {
                        nextInline = nextInline.fieldSeparator;
                    }
                }
                nextInline = nextInline.nextNode;
            }
        }
        return { 'element': nextInline, 'index': inlineIndex };
    };
    //Field Begin
    /**
     * Get rendered field
     * @private
     */
    Selection.prototype.getRenderedField = function (fieldBegin) {
        var inline = fieldBegin;
        if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
            inline = fieldBegin.fieldEnd;
        }
        else {
            inline = fieldBegin.fieldSeparator;
            var paragraph = inline.line.paragraph;
            if (paragraph === fieldBegin.fieldEnd.line.paragraph
                && !this.hasValidInline(paragraph, inline, fieldBegin.fieldEnd)) {
                inline = fieldBegin.fieldEnd;
            }
            else {
                return inline;
            }
        }
        return inline;
    };
    /**
     * Return true is inline is tha last inline
     * @private
     */
    Selection.prototype.isLastRenderedInline = function (inline, index) {
        while (index === inline.length && inline.nextNode instanceof FieldElementBox) {
            var nextValidInline = this.getNextValidElement(inline.nextNode);
            index = 0;
            if (nextValidInline instanceof FieldElementBox && nextValidInline.fieldType === 0) {
                inline = nextValidInline;
            }
            if (inline instanceof FieldElementBox && inline.fieldType === 0 && !isNullOrUndefined(inline.fieldEnd)) {
                var fieldBegin = inline;
                if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                    inline = fieldBegin.fieldEnd;
                    index = 1;
                }
                else {
                    inline = fieldBegin.fieldSeparator;
                    var paragraph = inline.line.paragraph;
                    index = 1;
                    if (paragraph === fieldBegin.fieldEnd.line.paragraph
                        && !this.hasValidInline(paragraph, inline, fieldBegin.fieldEnd)) {
                        inline = fieldBegin.fieldEnd;
                    }
                    else {
                        break;
                    }
                }
            }
        }
        return index === inline.length && isNullOrUndefined(inline.nextNode);
    };
    /**
     * Get page
     * @private
     */
    Selection.prototype.getPage = function (widget) {
        var page = undefined;
        if (widget.containerWidget instanceof BlockContainer) {
            var bodyWidget = widget.containerWidget;
            page = widget.containerWidget.page;
        }
        else if (!isNullOrUndefined(widget.containerWidget)) {
            page = this.getPage(widget.containerWidget);
        }
        return page;
    };
    /**
     * Clear Selection highlight
     * @private
     */
    Selection.prototype.clearSelectionHighlightInSelectedWidgets = function () {
        var isNonEmptySelection = false;
        var widgets = this.selectedWidgets.keys;
        for (var i = 0; i < widgets.length; i++) {
            this.removeSelectionHighlight(widgets[i]);
            isNonEmptySelection = true;
        }
        this.selectedWidgets.clear();
        return isNonEmptySelection;
    };
    /**
     * Clear selection highlight
     * @private
     */
    Selection.prototype.clearChildSelectionHighlight = function (widget) {
        for (var i = 0; i < widget.childWidgets.length; i++) {
            if (widget.childWidgets[i] instanceof LineWidget) {
                this.clearSelectionHighlightLineWidget(widget.childWidgets[i]);
            }
            else if (widget.childWidgets[i] instanceof TableCellWidget) {
                this.clearSelectionHighlight(widget.childWidgets[i]);
            }
            else if (widget.childWidgets[i] instanceof Widget) {
                this.clearChildSelectionHighlight(widget.childWidgets[i]);
            }
        }
    };
    /**
     * Get line widget from paragraph widget
     * @private
     */
    //Body Widget
    Selection.prototype.getLineWidgetBodyWidget = function (widget, point) {
        for (var i = 0; i < widget.childWidgets.length; i++) {
            var childWidget = widget.childWidgets[i];
            if (childWidget instanceof Widget && childWidget.y <= point.y
                && (childWidget.y + childWidget.height) >= point.y) {
                if (childWidget instanceof ParagraphWidget) {
                    return this.getLineWidgetParaWidget(childWidget, point);
                }
                else {
                    return this.getLineWidgetTableWidget(childWidget, point);
                }
            }
        }
        var line = undefined;
        if (widget.childWidgets.length > 0) {
            var firstChild = widget.childWidgets[0];
            if (firstChild instanceof Widget && firstChild.y <= point.y) {
                if (widget.childWidgets[widget.childWidgets.length - 1] instanceof ParagraphWidget) {
                    // tslint:disable-next-line:max-line-length
                    line = this.getLineWidgetParaWidget(widget.childWidgets[widget.childWidgets.length - 1], point);
                }
                else {
                    // tslint:disable-next-line:max-line-length
                    line = this.getLineWidgetTableWidget(widget.childWidgets[widget.childWidgets.length - 1], point);
                }
            }
            else {
                var childWidget = undefined;
                if (firstChild instanceof Widget) {
                    childWidget = firstChild;
                }
                if (!isNullOrUndefined(childWidget)) {
                    if (childWidget instanceof ParagraphWidget) {
                        line = this.getLineWidgetParaWidget(firstChild, point);
                    }
                    else {
                        line = this.getLineWidgetTableWidget(firstChild, point);
                    }
                }
            }
        }
        return line;
    };
    //ParagraphWidget
    /**
     * Get line widget from paragraph widget
     * @private
     */
    Selection.prototype.getLineWidgetParaWidget = function (widget, point) {
        var childWidgets = widget.childWidgets;
        var top = widget.y;
        for (var i = 0; i < childWidgets.length; i++) {
            if (top <= point.y
                && (top + childWidgets[i].height) >= point.y) {
                return childWidgets[i];
            }
            top += childWidgets[i].height;
        }
        var lineWidget = undefined;
        if (childWidgets.length > 0) {
            if (widget.y <= point.y) {
                lineWidget = childWidgets[childWidgets.length - 1];
            }
            else {
                lineWidget = childWidgets[0];
            }
        }
        return lineWidget;
    };
    /**
     * highlight paragraph widget
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Selection.prototype.highlightParagraph = function (widget, startIndex, endLine, endElement, endIndex) {
        var top = 0;
        var width = 0;
        var isRtlText = false;
        if (widget.paragraphFormat.bidi && endLine.children.indexOf(endElement) > 0) {
            endElement = endLine.children[0];
        }
        for (var i = startIndex; i < widget.childWidgets.length; i++) {
            var line = widget.childWidgets[i];
            if (i === startIndex) {
                top = this.getTop(line);
            }
            if (endElement instanceof TextElementBox) {
                isRtlText = endElement.isRightToLeft;
            }
            var left = this.getLeft(line);
            if (line === endLine) {
                //Selection ends in current line.
                var right = 0;
                // highlighting approach for normal and rtl text.
                if (isRtlText || widget.bidi) {
                    var elementBoxCollection = this.getElementsBackward(line, endElement, endElement, widget.bidi);
                    for (var i_2 = 0; i_2 < elementBoxCollection.length; i_2++) {
                        var element = elementBoxCollection[i_2];
                        var elementIsRTL = false;
                        if (element === endElement) {
                            right = this.getLeftInternal(line, element, endIndex);
                        }
                        else {
                            var index = element instanceof TextElementBox ? element.length : 1;
                            right = this.getLeftInternal(line, element, index);
                        }
                        left = this.getLeftInternal(line, element, 0);
                        if (element instanceof TextElementBox) {
                            elementIsRTL = element.isRightToLeft;
                        }
                        width = Math.abs(right - left);
                        // Handled the paragraph mark highliting as special case.
                        if (element === endElement && element instanceof TextElementBox && endIndex > element.length) {
                            // tslint:disable-next-line:max-line-length
                            var paragraphMarkWidth = this.viewer.textHelper.getParagraphMarkSize(element.line.paragraph.characterFormat).Width;
                            if (!widget.bidi && elementIsRTL) {
                                right += paragraphMarkWidth;
                            }
                            else if (widget.bidi && !elementIsRTL) { // Paragrph and Selection ends in normal text
                                width -= paragraphMarkWidth;
                                // Highlight the element.
                                this.createHighlightBorder(line, width, left, top, true);
                                // Highlight the paragraph mark of Bidi paragrph. 
                                left = this.getLineStartLeft(line) - paragraphMarkWidth;
                                this.createHighlightBorder(line, paragraphMarkWidth, left, top, true);
                                // continue to next element.
                                continue;
                            }
                        }
                        this.createHighlightBorder(line, width, elementIsRTL ? right : left, top, true);
                    }
                    return;
                }
                else {
                    right = this.getLeftInternal(endLine, endElement, endIndex);
                    width = Math.abs(right - left);
                    this.createHighlightBorder(line, width, isRtlText ? right : left, top, false);
                    return;
                }
            }
            else {
                width = this.getWidth(line, true) - (left - widget.x);
                // Highlight the paragrph mark for Bidi paragrph.
                if (widget.bidi && line.isLastLine()) {
                    left -= this.viewer.textHelper.getParagraphMarkSize(widget.characterFormat).Width;
                }
                this.createHighlightBorder(line, width, left, top, false);
                top += line.height;
            }
        }
    };
    //Table Widget
    /**
     * Get line widget form table widget
     * @private
     */
    Selection.prototype.getLineWidgetTableWidget = function (widget, point) {
        var lineWidget = undefined;
        for (var i = 0; i < widget.childWidgets.length; i++) {
            //Removed the height condition check to handle the vertically merged cells.
            var childWidget = widget.childWidgets[i];
            if (childWidget instanceof TableRowWidget && childWidget.y <= point.y) {
                lineWidget = this.getLineWidgetRowWidget(childWidget, point);
                var cellWidget = undefined;
                if (!isNullOrUndefined(lineWidget) && lineWidget.paragraph.containerWidget instanceof TableCellWidget) {
                    cellWidget = lineWidget.paragraph.containerWidget;
                }
                var cellSpacing = 0;
                var rowSpan = 0;
                if (!isNullOrUndefined(cellWidget)) {
                    var tableWidget = cellWidget.ownerRow.containerWidget;
                    cellSpacing = HelperMethods.convertPointToPixel(tableWidget.tableFormat.cellSpacing);
                    rowSpan = cellWidget.cellFormat.rowSpan;
                }
                var leftCellSpacing = 0;
                var rightCellSpacing = 0;
                var topCellSpacing = 0;
                var bottomCellSpacing = 0;
                if (cellSpacing > 0) {
                    leftCellSpacing = cellWidget.cellIndex === 0 ? cellSpacing : cellSpacing / 2;
                    // tslint:disable-next-line:max-line-length
                    rightCellSpacing = cellWidget.cellIndex === cellWidget.ownerRow.childWidgets.length - 1 ? cellSpacing : cellSpacing / 2;
                    var rowWidget = undefined;
                    if (cellWidget.containerWidget instanceof TableRowWidget) {
                        rowWidget = cellWidget.containerWidget;
                    }
                    var tableWidget = undefined;
                    if (cellWidget.containerWidget.containerWidget instanceof TableWidget) {
                        tableWidget = cellWidget.containerWidget.containerWidget;
                    }
                    if (!isNullOrUndefined(rowWidget) && !isNullOrUndefined(tableWidget)) {
                        topCellSpacing = cellWidget.ownerRow.rowIndex === 0 ? cellSpacing : cellSpacing / 2;
                        if (cellWidget.ownerRow.rowIndex + rowSpan === cellWidget.ownerTable.childWidgets.length) {
                            bottomCellSpacing = cellSpacing;
                        }
                        else {
                            bottomCellSpacing = cellSpacing / 2;
                        }
                    }
                }
                if ((!isNullOrUndefined(lineWidget) && lineWidget.paragraph.x <= point.x
                    && lineWidget.paragraph.x + lineWidget.width >= point.x
                    && lineWidget.paragraph.y <= point.y && this.getTop(lineWidget) + lineWidget.height >= point.y)
                    || (!isNullOrUndefined(cellWidget) && cellWidget.x - cellWidget.margin.left - leftCellSpacing <= point.x
                        && cellWidget.x + cellWidget.width + cellWidget.margin.right + rightCellSpacing >= point.x
                        && cellWidget.y - cellWidget.margin.top - topCellSpacing <= point.y
                        && cellWidget.y + cellWidget.height + cellWidget.margin.bottom + bottomCellSpacing >= point.y)) {
                    break;
                }
            }
        }
        return lineWidget;
    };
    //TableRowWidget
    /**
     * Get line widget fom row
     * @private
     */
    Selection.prototype.getLineWidgetRowWidget = function (widget, point) {
        for (var i = 0; i < widget.childWidgets.length; i++) {
            var cellSpacing = 0;
            cellSpacing = HelperMethods.convertPointToPixel(widget.ownerTable.tableFormat.cellSpacing);
            var leftCellSpacing = 0;
            var rightCellSpacing = 0;
            if (cellSpacing > 0) {
                leftCellSpacing = widget.childWidgets[i].columnIndex === 0 ? cellSpacing : cellSpacing / 2;
                // tslint:disable-next-line:max-line-length
                rightCellSpacing = widget.childWidgets[i].cellIndex === widget.childWidgets[i].ownerRow.childWidgets.length - 1 ? cellSpacing : cellSpacing / 2;
            }
            if (widget.childWidgets[i].x -
                // tslint:disable-next-line:max-line-length
                widget.childWidgets[i].margin.left - leftCellSpacing <= point.x && (widget.childWidgets[i].x +
                // tslint:disable-next-line:max-line-length
                widget.childWidgets[i].width) + widget.childWidgets[i].margin.right + rightCellSpacing >= point.x) {
                return this.getLineWidgetCellWidget(widget.childWidgets[i], point);
            }
        }
        var lineWidget = undefined;
        if (widget.childWidgets.length > 0) {
            if (widget.childWidgets[0].x <= point.x) {
                lineWidget = this.getLineWidgetCellWidget(widget.childWidgets[widget.childWidgets.length - 1], point);
            }
            else {
                lineWidget = this.getLineWidgetCellWidget(widget.childWidgets[0], point);
            }
        }
        return lineWidget;
    };
    /**
     * @private
     */
    Selection.prototype.getFirstBlock = function (cell) {
        if (cell.childWidgets.length > 0) {
            return cell.childWidgets[0];
        }
        return undefined;
    };
    //Table Cell Widget
    /**
     * Highlight selected cell widget
     * @private
     */
    Selection.prototype.highlightCellWidget = function (widget) {
        var widgets = [];
        if (widget.previousSplitWidget || widget.nextSplitWidget) {
            widgets = widget.getSplitWidgets();
        }
        else {
            widgets.push(widget);
        }
        for (var i = 0; i < widgets.length; i++) {
            widget = widgets[i];
            //Clears Selection highlight of the child widgets.
            this.clearChildSelectionHighlight(widget);
            //Highlights the entire cell.
            this.createHighlightBorderInsideTable(widget);
        }
    };
    /**
     * Clear selection highlight
     * @private
     */
    Selection.prototype.clearSelectionHighlight = function (widget) {
        if (this.selectedWidgets.containsKey(widget)) {
            this.removeSelectionHighlight(widget);
            this.selectedWidgets.remove(widget);
        }
    };
    /**
     * Get line widget from cell widget
     * @private
     */
    Selection.prototype.getLineWidgetCellWidget = function (widget, point) {
        for (var i = 0; i < widget.childWidgets.length; i++) {
            if (widget.childWidgets[i].y <= point.y
                && (widget.childWidgets[i].y + widget.childWidgets[i].height) >= point.y) {
                if (widget.childWidgets[i] instanceof ParagraphWidget) {
                    return this.getLineWidgetParaWidget(widget.childWidgets[i], point);
                }
                else {
                    return this.getLineWidgetTableWidget(widget.childWidgets[i], point);
                }
            }
        }
        var lineWidget = undefined;
        if (widget.childWidgets.length > 0) {
            if (widget.childWidgets[0].y <= point.y) {
                if (widget.childWidgets[widget.childWidgets.length - 1] instanceof ParagraphWidget) {
                    // tslint:disable-next-line:max-line-length
                    lineWidget = this.getLineWidgetParaWidget(widget.childWidgets[widget.childWidgets.length - 1], point);
                }
                else {
                    lineWidget = this.getLineWidgetTableWidget(widget.childWidgets[0], point);
                }
            }
        }
        return lineWidget;
    };
    //LineWidget
    /**
     * update text position
     * @private
     */
    Selection.prototype.updateTextPosition = function (widget, point) {
        var caretPosition = point;
        var element = undefined;
        var index = 0;
        var isImageSelected = false;
        var isImageSelectedObj = this.updateTextPositionIn(widget, element, index, point, false);
        if (!isNullOrUndefined(isImageSelectedObj)) {
            element = isImageSelectedObj.element;
            index = isImageSelectedObj.index;
            caretPosition = isImageSelectedObj.caretPosition;
            isImageSelected = isImageSelectedObj.isImageSelected;
            this.isImageSelected = isImageSelected;
        }
        if (isImageSelected) {
            this.selectInternal(widget, element, index, caretPosition);
            if (index === 0) {
                this.extendForward();
            }
            else {
                this.extendBackward();
            }
        }
        else {
            this.selectInternal(widget, element, index, caretPosition);
        }
    };
    /**
     * @private
     */
    /* tslint:disable */
    Selection.prototype.updateTextPositionIn = function (widget, inline, index, caretPosition, includeParagraphMark) {
        var isImageSelected = false;
        var top = this.getTop(widget);
        var left = widget.paragraph.x;
        var elementValues = this.getFirstElement(widget, left);
        var element = elementValues.element;
        var isRtlText = false;
        var isParaBidi = false;
        left = elementValues.left;
        if (isNullOrUndefined(element)) {
            var topMargin = 0;
            var bottomMargin = 0;
            var size = this.getParagraphMarkSize(widget.paragraph, topMargin, bottomMargin);
            topMargin = size.topMargin;
            bottomMargin = size.bottomMargin;
            var selectParaMark = this.viewer.mouseDownOffset.y >= top && this.viewer.mouseDownOffset.y < top + widget.height ? (this.viewer.mouseDownOffset.x < left + size.width) : true;
            if (selectParaMark && includeParagraphMark && caretPosition.x > left + size.width / 2) {
                left += size.width;
                if (widget.children.length > 0) {
                    inline = widget.children[widget.children.length - 1];
                    index = inline.length;
                }
                index++;
            }
            caretPosition = new Point(left, topMargin > 0 ? top + topMargin : top);
        }
        else {
            if (!isNullOrUndefined(element)) {
                if (caretPosition.x > left + element.margin.left) {
                    for (var i = widget.children.indexOf(element); i < widget.children.length; i++) {
                        element = widget.children[i];
                        var isCurrentParaBidi = false;
                        if (element instanceof ListTextElementBox || element instanceof TextElementBox) {
                            isCurrentParaBidi = element.line.paragraph.paragraphFormat.bidi;
                        }
                        if (caretPosition.x < left + element.margin.left + element.width || i === widget.children.length - 1
                            || ((widget.children[i + 1] instanceof ListTextElementBox) && isCurrentParaBidi)) {
                            break;
                        }
                        left += element.margin.left + element.width;
                    }
                    if (element instanceof TextElementBox) {
                        isRtlText = element.isRightToLeft;
                        isParaBidi = element.line.paragraph.paragraphFormat.bidi;
                    }
                    if (caretPosition.x > left + element.margin.left + element.width) {
                        //Line End
                        index = element instanceof TextElementBox ? element.length : 1;
                        if (isRtlText && isParaBidi) {
                            index = 0;
                        }
                        if ((element instanceof TextElementBox && element.text !== "\v") || includeParagraphMark) {
                            left += element.margin.left + element.width;
                        }
                    }
                    else if (element instanceof TextElementBox) {
                        if (element instanceof TextElementBox && isRtlText) {
                            left += element.width;
                        }
                        var x = 0;
                        if (isRtlText) {
                            x = (left + element.margin.left) - caretPosition.x;
                        }
                        else {
                            x = caretPosition.x - left - element.margin.left;
                        }
                        left += element.margin.left;
                        var prevWidth = 0;
                        var charIndex = 0;
                        for (var i = 1; i <= element.length; i++) {
                            var width = 0;
                            if (i === element.length) {
                                width = element.width;
                            }
                            else {
                                width = this.viewer.textHelper.getWidth(element.text.substr(0, i), element.characterFormat);
                            }
                            if (x < width || i === element.length) {
                                //Updates exact left position of the caret.
                                var charWidth = width - prevWidth;
                                if (x - prevWidth > charWidth / 2) {
                                    if (isRtlText) {
                                        left -= width;
                                    }
                                    else {
                                        left += width;
                                    }
                                    charIndex = i;
                                }
                                else {
                                    if (isRtlText) {
                                        left -= prevWidth;
                                    }
                                    else {
                                        left += prevWidth;
                                    }
                                    charIndex = i - 1;
                                    if (i === 1 && element !== widget.children[0]) {
                                        var curIndex = widget.children.indexOf(element);
                                        if (!(widget.children[curIndex - 1] instanceof ListTextElementBox) && !isRtlText) {
                                            element = widget.children[curIndex - 1];
                                            charIndex = element instanceof TextElementBox ? element.length : 1;
                                        }
                                    }
                                }
                                break;
                            }
                            prevWidth = width;
                        }
                        index = charIndex;
                    }
                    else {
                        isImageSelected = element instanceof ImageElementBox;
                        if (caretPosition.x - left - element.margin.left > element.width / 2) {
                            index = 1;
                            left += element.margin.left + element.width;
                        }
                        else if (element !== widget.children[0] && !isImageSelected) {
                            var curIndex = widget.children.indexOf(element);
                            if (!(widget.children[curIndex - 1] instanceof ListTextElementBox)) {
                                element = widget.children[curIndex - 1];
                                index = element instanceof TextElementBox ? element.length : 1;
                            }
                        }
                    }
                    if (element instanceof TextElementBox && element.text === '\v') {
                        index = 0;
                    }
                }
                else {
                    isRtlText = element.isRightToLeft;
                    isParaBidi = element.line.paragraph.paragraphFormat.bidi;
                    if (element instanceof TextElementBox && (isParaBidi || isRtlText) && caretPosition.x < left + element.margin.left + element.width) {
                        index = this.getTextLength(element.line, element) + element.length;
                    }
                    else {
                        index = this.getTextLength(element.line, element);
                    }
                    left += element.margin.left;
                }
                if (element instanceof TextElementBox) {
                    top += element.margin.top > 0 ? element.margin.top : 0;
                }
                else {
                    var textMetrics = this.viewer.textHelper.getHeight(element.characterFormat); //for ascent and descent
                    var height = element.height;
                    if (element instanceof BookmarkElementBox && !this.viewer.layout.hasValidElement(element.line.paragraph)) {
                        height = textMetrics.Height; //after text helper class
                    }
                    top += element.margin.top + height - textMetrics.BaselineOffset;
                }
                inline = element;
                var inlineObj = this.validateTextPosition(inline, index);
                inline = inlineObj.element;
                index = inlineObj.index;
                var isParagraphEnd = isNullOrUndefined(inline.nextNode) && index === inline.length;
                var isLineEnd = isNullOrUndefined(inline.nextNode)
                    && inline instanceof TextElementBox && inline.text === '\v';
                if (includeParagraphMark && inline.nextNode instanceof FieldElementBox && index === inline.length) {
                    isParagraphEnd = this.isLastRenderedInline(inline, index);
                }
                if (includeParagraphMark && isParagraphEnd || isLineEnd) {
                    var width = 0;
                    //Include width of Paragraph mark.
                    if (isParagraphEnd) {
                        width = this.viewer.textHelper.getParagraphMarkWidth(widget.paragraph.characterFormat);
                        var selectParaMark = this.viewer.mouseDownOffset.y >= top && this.viewer.mouseDownOffset.y < top + widget.height ? (this.viewer.mouseDownOffset.x < left + width) : true;
                        if (selectParaMark && caretPosition.x > left + width / 2) {
                            left += width;
                            index = inline.length + 1;
                        }
                        //Include width of line break mark.
                    }
                    else if (isLineEnd) {
                        width = element.width;
                        left += width;
                        index = inline.length;
                    }
                }
                caretPosition = new Point(left, top);
            }
        }
        return {
            'element': inline,
            'index': index,
            'caretPosition': caretPosition,
            'isImageSelected': isImageSelected
        };
    };
    /* tslint:enable */
    /**
     * Get text length if the line widget
     * @private
     */
    Selection.prototype.getTextLength = function (widget, element) {
        var length = 0;
        var count = widget.children.indexOf(element);
        if (widget.children.length > 0 && widget.children[0] instanceof ListTextElementBox) {
            if (widget.children[1] instanceof ListTextElementBox) {
                count -= 2;
            }
            else {
                count -= 1;
            }
        }
        for (var i = 1; i < count; i++) {
            length += widget.children[i].length;
        }
        return length;
    };
    /**
     * Get Line widget left
     * @private
     */
    Selection.prototype.getLeft = function (widget) {
        var left = widget.paragraph.x;
        var paragraphFormat = widget.paragraph.paragraphFormat;
        if (this.isParagraphFirstLine(widget) && !paragraphFormat.bidi && !(paragraphFormat.textAlignment === 'Right')) {
            left += HelperMethods.convertPointToPixel(paragraphFormat.firstLineIndent);
        }
        for (var i = 0; i < widget.children.length; i++) {
            var element = widget.children[i];
            if (element instanceof ListTextElementBox && !paragraphFormat.bidi) { //after list implementation
                if (i === 0) {
                    left += element.margin.left + element.width;
                }
                else {
                    left += element.width;
                }
            }
            else {
                left += element.margin.left;
                break;
            }
        }
        return left;
    };
    /**
     * Get line widget top
     * @private
     */
    Selection.prototype.getTop = function (widget) {
        var top = widget.paragraph.y;
        var count = widget.paragraph.childWidgets.indexOf(widget);
        for (var i = 0; i < count; i++) {
            top += widget.paragraph.childWidgets[i].height;
        }
        return top;
    };
    /**
     * Get first element the widget
     * @private
     */
    Selection.prototype.getFirstElement = function (widget, left) {
        var firstLineIndent = 0;
        if (this.isParagraphFirstLine(widget) && !widget.paragraph.paragraphFormat.bidi) {
            firstLineIndent = HelperMethods.convertPointToPixel(widget.paragraph.paragraphFormat.firstLineIndent);
        }
        left += firstLineIndent;
        var element = undefined;
        for (var i = 0; i < widget.children.length; i++) {
            element = widget.children[i];
            if (element instanceof ListTextElementBox || element instanceof CommentCharacterElementBox) {
                if (widget.paragraph.paragraphFormat.bidi) {
                    left += element.margin.left;
                    element = undefined;
                    break;
                }
                left += element.margin.left + element.width;
                element = undefined;
                // }
                //  else if (element instanceof FieldElementBox || element instanceof BookmarkElementBox
                //     || (element.nextNode instanceof FieldElementBox && ((element.nextNode as FieldElementBox).fieldType === 2))) {
                //     element = undefined;
            }
            else {
                break;
            }
        }
        return { 'element': element, 'left': left };
    };
    /**
     * Return inline index
     * @private
     */
    //ElementBox
    Selection.prototype.getIndexInInline = function (elementBox) {
        var indexInInline = 0;
        if (elementBox instanceof TextElementBox) {
            var count = elementBox.line.children.indexOf(elementBox);
            for (var i = 0; i < count; i++) {
                var element = elementBox.line.children[i];
                if (element instanceof FieldElementBox || element instanceof ListTextElementBox) {
                    continue;
                }
                indexInInline += element.length;
            }
        }
        return indexInInline;
    };
    /**
     * Return true if widget is first inline of paragraph
     * @private
     */
    Selection.prototype.isParagraphFirstLine = function (widget) {
        if (isNullOrUndefined(widget.paragraph.previousSplitWidget) &&
            widget === widget.paragraph.firstChild) {
            return true;
        }
        return false;
    };
    /**
     * @private
     */
    Selection.prototype.isParagraphLastLine = function (widget) {
        if (isNullOrUndefined(widget.paragraph.nextSplitWidget)
            && widget === widget.paragraph.lastChild) {
            return true;
        }
        return false;
    };
    /**
     * Return line widget width
     * @private
     */
    Selection.prototype.getWidth = function (widget, includeParagraphMark) {
        var width = 0;
        var paraFormat = widget.paragraph.paragraphFormat;
        if (this.isParagraphFirstLine(widget) && !paraFormat.bidi) {
            width += HelperMethods.convertPointToPixel(paraFormat.firstLineIndent);
        }
        for (var i = 0; i < widget.children.length; i++) {
            width += widget.children[i].margin.left + widget.children[i].width;
        }
        if (includeParagraphMark && widget.paragraph.childWidgets.indexOf(widget) === widget.paragraph.childWidgets.length - 1
            && isNullOrUndefined(widget.paragraph.nextSplitWidget)) {
            width += this.viewer.textHelper.getParagraphMarkWidth(widget.paragraph.characterFormat);
        }
        return width;
    };
    /**
     * Return line widget left
     * @private
     */
    Selection.prototype.getLeftInternal = function (widget, elementBox, index) {
        var left = widget.paragraph.x;
        var paraFormat = widget.paragraph.paragraphFormat;
        if (this.isParagraphFirstLine(widget) && !paraFormat.bidi) {
            // tslint:disable-next-line:max-line-length
            left += HelperMethods.convertPointToPixel(widget.paragraph.paragraphFormat.firstLineIndent);
        }
        var isRtlText = false;
        var isParaBidi = false;
        if (elementBox instanceof TextElementBox) {
            isRtlText = elementBox.isRightToLeft;
            isParaBidi = elementBox.line.paragraph.paragraphFormat.bidi;
        }
        //when line contains normal text and para is RTL para.
        //if home key is pressed, update caret position after the last element in a line.
        //if end key pressed, update caret position before the first element in a line. 
        if (isParaBidi) {
            if (!isRtlText) {
                if (this.viewer.moveCaretPosition === 1 && widget.children.length > 0) {
                    elementBox = widget.children[widget.children.length - 1];
                }
                else if (this.viewer.moveCaretPosition === 2) {
                    elementBox = widget.children[0];
                }
                if (elementBox instanceof ListTextElementBox && widget.children.length > 2) {
                    elementBox = widget.children[widget.children.length - 3];
                }
            }
        }
        var count = widget.children.indexOf(elementBox);
        if ((widget.children.length === 1 && widget.children[0] instanceof ListTextElementBox) || (widget.children.length === 2
            && widget.children[0] instanceof ListTextElementBox && widget.children[1] instanceof ListTextElementBox)) {
            count = widget.children.length;
        }
        for (var i = 0; i < count; i++) {
            var widgetInternal = widget.children[i];
            // if (widgetInternal instanceof FieldElementBox) {
            //     continue;
            // }
            if (i === 1 && widget.children[i] instanceof ListTextElementBox) {
                left += widget.children[i].width;
            }
            else if (widget.children[i] instanceof TabElementBox && elementBox === widgetInternal) {
                left += widget.children[i].margin.left;
            }
            else {
                left += widget.children[i].margin.left + widget.children[i].width;
            }
        }
        if (!isNullOrUndefined(elementBox)) {
            left += elementBox.margin.left;
            if (isRtlText || (this.viewer.moveCaretPosition === 1 && !isRtlText && isParaBidi)) {
                left += elementBox.width;
            }
        }
        var width = 0;
        if (elementBox instanceof TextElementBox) {
            if ((this.viewer.moveCaretPosition !== 0) && (isParaBidi || isRtlText)) {
                if ((isRtlText && isParaBidi && this.viewer.moveCaretPosition === 2)
                    || (isRtlText && !isParaBidi && this.viewer.moveCaretPosition === 1)) {
                    left -= elementBox.width;
                }
                this.viewer.moveCaretPosition = 0;
                return left;
            }
            if (index === elementBox.length && !isRtlText) {
                left += elementBox.width;
            }
            else if (index > elementBox.length) {
                width = this.viewer.textHelper.getParagraphMarkWidth(elementBox.line.paragraph.characterFormat);
                if (isRtlText) {
                    left -= elementBox.width + width;
                }
                else {
                    left += elementBox.width + width;
                }
            }
            else {
                // tslint:disable-next-line:max-line-length
                width = this.viewer.textHelper.getWidth(elementBox.text.substr(0, index), elementBox.characterFormat);
                if (isRtlText) {
                    left -= width;
                }
                else {
                    left += width;
                }
            }
            this.viewer.moveCaretPosition = 0;
        }
        else if (index > 0) {
            if (!isNullOrUndefined(elementBox) && !(elementBox instanceof ListTextElementBox)) {
                left += elementBox.width;
                if (index === 2) {
                    var paragraph = elementBox.line.paragraph;
                    left += this.viewer.textHelper.getParagraphMarkWidth(paragraph.characterFormat);
                }
            }
            else {
                left += this.viewer.textHelper.getParagraphMarkWidth(widget.paragraph.characterFormat);
            }
        }
        return left;
    };
    /**
     * Return line widget start offset
     * @private
     */
    Selection.prototype.getLineStartLeft = function (widget) {
        var left = widget.paragraph.x;
        var paragraphFormat = widget.paragraph.paragraphFormat;
        if (this.isParagraphFirstLine(widget) && !paragraphFormat.bidi) {
            left += HelperMethods.convertPointToPixel(paragraphFormat.firstLineIndent);
        }
        if (widget.children.length > 0) {
            left += widget.children[0].margin.left;
        }
        return left;
    };
    /**
     * Update text position
     * @private
     */
    Selection.prototype.updateTextPositionWidget = function (widget, point, textPosition, includeParagraphMark) {
        var caretPosition = point;
        var inline = undefined;
        var index = 0;
        var updatePositionObj;
        updatePositionObj = this.updateTextPositionIn(widget, inline, index, caretPosition, includeParagraphMark);
        inline = updatePositionObj.element;
        index = updatePositionObj.index;
        caretPosition = updatePositionObj.caretPosition;
        textPosition.setPositionForSelection(widget, inline, index, caretPosition);
    };
    /**
     * Clear selection highlight
     * @private
     */
    Selection.prototype.clearSelectionHighlightLineWidget = function (widget) {
        if (!isNullOrUndefined(this.owner) && this.selectedWidgets.length > 0) {
            this.clearSelectionHighlight(this);
        }
    };
    /**
     * Return first element from line widget
     * @private
     */
    Selection.prototype.getFirstElementInternal = function (widget) {
        var element = undefined;
        var isBidi = widget.paragraph.paragraphFormat.bidi;
        var childLen = widget.children.length;
        for (var i = isBidi ? childLen - 1 : 0; isBidi ? i >= 0 : i < childLen; isBidi ? i-- : i++) {
            element = widget.children[i];
            if (element instanceof ListTextElementBox) {
                element = undefined;
            }
            else {
                break;
            }
        }
        return element;
    };
    //Selection API    
    /**
     * Select content between given range
     * @private
     */
    Selection.prototype.selectRange = function (startPosition, endPosition) {
        this.start.setPositionInternal(startPosition);
        this.end.setPositionInternal(endPosition);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * Selects current paragraph
     * @private
     */
    Selection.prototype.selectParagraphInternal = function (paragraph, positionAtStart) {
        var line;
        if (!isNullOrUndefined(paragraph) && !isNullOrUndefined(paragraph.firstChild)) {
            line = paragraph.firstChild;
            if (positionAtStart) {
                this.start.setPosition(line, positionAtStart);
            }
            else {
                var endOffset = line.getEndOffset();
                this.start.setPositionParagraph(line, endOffset);
            }
        }
        this.end.setPositionInternal(this.start);
        this.upDownSelectionLength = this.start.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * @private
     */
    Selection.prototype.setPositionForBlock = function (block, selectFirstBlock) {
        var position;
        if (block instanceof TableWidget) {
            if (selectFirstBlock) {
                block = this.getFirstParagraphInFirstCell(block);
            }
            else {
                block = this.getLastParagraphInLastCell(block);
            }
        }
        if (block instanceof ParagraphWidget) {
            position = new TextPosition(this.owner);
            if (selectFirstBlock) {
                position.setPosition(block.firstChild, true);
            }
            else {
                var line = block.lastChild;
                position.setPositionParagraph(line, line.getEndOffset());
            }
        }
        return position;
    };
    /**
     * Select content in given text position
     * @private
     */
    Selection.prototype.selectContent = function (textPosition, clearMultiSelection) {
        if (isNullOrUndefined(textPosition)) {
            throw new Error('textPosition is undefined.');
        }
        this.start.setPositionInternal(textPosition);
        this.end.setPositionInternal(textPosition);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    };
    /**
     * Select paragraph
     * @private
     */
    Selection.prototype.selectInternal = function (lineWidget, element, index, physicalLocation) {
        this.start.setPositionForSelection(lineWidget, element, index, physicalLocation);
        this.end.setPositionInternal(this.start);
        this.upDownSelectionLength = physicalLocation.x;
        this.fireSelectionChanged(true);
    };
    /**
     * @private
     */
    Selection.prototype.selects = function (lineWidget, offset, skipSelectionChange) {
        this.viewer.clearSelectionHighlight();
        this.start.setPositionForLineWidget(lineWidget, offset);
        this.end.setPositionInternal(this.start);
        if (!skipSelectionChange) {
            this.fireSelectionChanged(true);
        }
    };
    /**
     * Select content between start and end position
     * @private
     */
    Selection.prototype.selectPosition = function (startPosition, endPosition) {
        if (isNullOrUndefined(startPosition) || isNullOrUndefined(endPosition)) {
            throw new Error('TextPosition cannot be undefined');
        }
        if (isNullOrUndefined(startPosition.paragraph)
            || startPosition.offset > this.getParagraphLength(startPosition.paragraph) + 1) {
            throw new Error('Start TextPosition is not valid.');
        }
        if (isNullOrUndefined(endPosition.paragraph)
            || endPosition.offset > this.getParagraphLength(endPosition.paragraph) + 1) {
            throw new Error('End TextPosition is not valid.');
        }
        if (startPosition.isAtSamePosition(endPosition)) {
            // Select start position.
            this.selectRange(startPosition, startPosition);
        }
        else {
            // If both text position exists within same comment or outside comment, and not at same position.
            if (startPosition.isExistBefore(endPosition)) {
                // tslint:disable-next-line:max-line-length
                endPosition.validateForwardFieldSelection(startPosition.getHierarchicalIndexInternal(), endPosition.getHierarchicalIndexInternal());
            }
            else {
                // tslint:disable-next-line:max-line-length
                startPosition.validateForwardFieldSelection(endPosition.getHierarchicalIndexInternal(), startPosition.getHierarchicalIndexInternal());
            }
            this.selectRange(startPosition, endPosition);
        }
    };
    /**
     * Notify selection change event
     * @private
     */
    Selection.prototype.fireSelectionChanged = function (isSelectionChanged) {
        if (!this.isEmpty) {
            if (this.isForward) {
                this.start.updatePhysicalPosition(true);
                this.end.updatePhysicalPosition(false);
            }
            else {
                this.start.updatePhysicalPosition(false);
                this.end.updatePhysicalPosition(true);
            }
        }
        if (!this.skipFormatRetrieval) {
            this.retrieveCurrentFormatProperties();
        }
        this.viewer.clearSelectionHighlight();
        this.hideToolTip();
        if (this.owner.isLayoutEnabled && !this.owner.isShiftingEnabled) {
            this.highlightSelection(true);
        }
        if (this.viewer.restrictEditingPane.isShowRestrictPane && !this.skipEditRangeRetrieval) {
            this.viewer.restrictEditingPane.updateUserInformation();
        }
        if (isSelectionChanged) {
            if (this.start.paragraph.isInHeaderFooter && !this.owner.enableHeaderAndFooter) {
                this.owner.enableHeaderAndFooter = true;
            }
            else if (!this.start.paragraph.isInHeaderFooter && this.owner.enableHeaderAndFooter) {
                this.owner.enableHeaderAndFooter = false;
            }
            this.owner.fireSelectionChange();
        }
        this.viewer.updateFocus();
    };
    //Formats Retrieval
    /**
     * Retrieve all current selection format
     * @private
     */
    Selection.prototype.retrieveCurrentFormatProperties = function () {
        this.isRetrieveFormatting = true;
        var startPosition = this.start;
        var endPosition = this.end;
        if (!this.isForward) {
            startPosition = this.end;
            endPosition = this.start;
        }
        this.retrieveImageFormat(startPosition, endPosition);
        this.retrieveCharacterFormat(startPosition, endPosition);
        this.retrieveParagraphFormat(startPosition, endPosition);
        this.retrieveSectionFormat(startPosition, endPosition);
        this.retrieveTableFormat(startPosition, endPosition);
        if (!this.isImageSelected) {
            this.imageFormat.clearImageFormat();
        }
        this.isRetrieveFormatting = false;
        this.setCurrentContextType();
    };
    /**
     * @private
     */
    Selection.prototype.retrieveImageFormat = function (start, end) {
        var image;
        if (start.currentWidget === end.currentWidget && start.offset + 1 === end.offset) {
            var elementInfo = end.currentWidget.getInline(end.offset, 0);
            image = elementInfo.element;
            var index = elementInfo.index;
            if (image instanceof ImageElementBox) {
                var startOffset = start.currentWidget.getOffset(image, 0);
                if (startOffset !== start.offset) {
                    image = undefined;
                }
            }
        }
        if (image instanceof ImageElementBox) {
            this.imageFormat.copyImageFormat(image);
        }
        else {
            this.imageFormat.clearImageFormat();
        }
    };
    Selection.prototype.setCurrentContextType = function () {
        var contextIsinImage = this.imageFormat.image ? true : false;
        var contextIsinTable = (isNullOrUndefined(this.tableFormat) || isNullOrUndefined(this.tableFormat.table)) ? false : true;
        var style = this.start.paragraph.paragraphFormat.baseStyle;
        if (style instanceof WParagraphStyle && style.name.toLowerCase().indexOf('toc') === 0) {
            var tocField = this.getTocFieldInternal();
            if (!isNullOrUndefined(tocField)) {
                this.contextTypeInternal = 'TableOfContents';
                return;
            }
        }
        if (this.start.paragraph.isInHeaderFooter) {
            var isInHeader = this.start.paragraph.bodyWidget.headerFooterType.indexOf('Header') !== -1;
            if (contextIsinTable) {
                if (contextIsinImage) {
                    this.contextTypeInternal = isInHeader ? 'HeaderTableImage' : 'FooterTableImage';
                }
                else {
                    this.contextTypeInternal = isInHeader ? 'HeaderTableText' : 'FooterTableText';
                }
            }
            else {
                if (contextIsinImage) {
                    this.contextTypeInternal = isInHeader ? 'HeaderImage' : 'FooterImage';
                }
                else {
                    this.contextTypeInternal = isInHeader ? 'HeaderText' : 'FooterText';
                }
            }
        }
        else {
            if (contextIsinTable) {
                this.contextTypeInternal = contextIsinImage ? 'TableImage' : 'TableText';
            }
            else {
                this.contextTypeInternal = contextIsinImage ? 'Image' : 'Text';
            }
        }
    };
    //Table Format retrieval starts
    /**
     * Retrieve selection table format
     * @private
     */
    Selection.prototype.retrieveTableFormat = function (start, end) {
        var tableAdv = this.getTable(start, end);
        if (!isNullOrUndefined(tableAdv)) {
            this.tableFormat.copyFormat(tableAdv.tableFormat);
            this.tableFormat.table = tableAdv;
            this.retrieveCellFormat(start, end);
            this.retrieveRowFormat(start, end);
        }
        else {
            //When the selection is out of table
            this.tableFormat.clearFormat();
        }
    };
    /**
     * Retrieve selection cell format
     * @private
     */
    Selection.prototype.retrieveCellFormat = function (start, end) {
        if (start.paragraph.isInsideTable && end.paragraph.isInsideTable) {
            this.cellFormat.copyFormat(start.paragraph.associatedCell.cellFormat);
            this.getCellFormat(start.paragraph.associatedCell.ownerTable, start, end);
        }
        else {
            //When the selection is out of table
            this.cellFormat.clearCellFormat();
        }
    };
    /**
     * Retrieve selection row format
     * @private
     */
    Selection.prototype.retrieveRowFormat = function (start, end) {
        if (start.paragraph.isInsideTable && end.paragraph.isInsideTable) {
            this.rowFormat.copyFormat(start.paragraph.associatedCell.ownerRow.rowFormat);
            this.getRowFormat(start.paragraph.associatedCell.ownerTable, start, end);
        }
        else {
            //When the selection is out of table
            this.rowFormat.clearRowFormat();
        }
    };
    /**
     * Get selected cell format
     * @private
     */
    Selection.prototype.getCellFormat = function (table, start, end) {
        if (start.paragraph.associatedCell.equals(end.paragraph.associatedCell)) {
            return;
        }
        var isStarted = false;
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            if (row === start.paragraph.associatedCell.ownerRow) {
                isStarted = true;
            }
            if (isStarted) {
                for (var j = 0; j < row.childWidgets.length; j++) {
                    var cell = row.childWidgets[j];
                    if (this.isCellSelected(cell, start, end)) {
                        this.cellFormat.combineFormat(cell.cellFormat);
                    }
                    if (cell === end.paragraph.associatedCell) {
                        this.cellFormat.combineFormat(cell.cellFormat);
                        return;
                    }
                }
            }
        }
    };
    /**
     * Get selected row format
     * @private
     */
    Selection.prototype.getRowFormat = function (table, start, end) {
        var tableRow = start.paragraph.associatedCell.ownerRow;
        if (tableRow === end.paragraph.associatedCell.ownerRow) {
            return;
        }
        for (var i = table.childWidgets.indexOf(tableRow) + 1; i < table.childWidgets.length; i++) {
            var tempTableRow = table.childWidgets[i];
            this.rowFormat.combineFormat(tempTableRow.rowFormat);
            if (tempTableRow === end.paragraph.associatedCell.ownerRow) {
                return;
            }
        }
    };
    /**
     * Return table with given text position
     * @private
     */
    Selection.prototype.getTable = function (startPosition, endPosition) {
        if (!isNullOrUndefined(startPosition.paragraph.associatedCell) && !isNullOrUndefined(endPosition.paragraph.associatedCell)) {
            var startTable = startPosition.paragraph.associatedCell.ownerTable;
            var endTable = startPosition.paragraph.associatedCell.ownerTable;
            if (startTable === endTable) {
                return startTable;
            }
            else {
                if (startTable.contains(startPosition.paragraph.associatedCell)) {
                    return startTable;
                }
                else if (endTable.contains(startPosition.paragraph.associatedCell)) {
                    return endTable;
                }
                else if (!startTable.isInsideTable || !endTable.isInsideTable) {
                    return undefined;
                }
                else {
                    do {
                        startTable = startTable.associatedCell.ownerTable;
                        if (startTable === endTable || startTable.contains(endTable.associatedCell)) {
                            return startTable;
                        }
                        else if (endTable.contains(startTable.associatedCell)) {
                            return endTable;
                        }
                    } while (!isNullOrUndefined(startTable.associatedCell));
                }
            }
        }
        return undefined;
    };
    Selection.prototype.getContainerWidget = function (block) {
        var bodyWidget;
        if (block.containerWidget instanceof BlockContainer) {
            bodyWidget = block.containerWidget;
        }
        else {
            bodyWidget = block.containerWidget;
            while (!(bodyWidget instanceof BlockContainer)) {
                bodyWidget = bodyWidget.containerWidget;
            }
        }
        return bodyWidget;
    };
    //Table format retrieval ends
    //Section format retrieval starts
    /**
     * Retrieve selection section format
     * @private
     */
    Selection.prototype.retrieveSectionFormat = function (start, end) {
        var startParaSection = this.getContainerWidget(start.paragraph);
        var endParaSection = this.getContainerWidget(end.paragraph);
        if (!isNullOrUndefined(startParaSection)) {
            this.sectionFormat.copyFormat(startParaSection.sectionFormat);
            var startPageIndex = this.viewer.pages.indexOf(startParaSection.page);
            var endPageIndex = this.viewer.pages.indexOf(endParaSection.page);
            for (var i = startPageIndex + 1; i <= endPageIndex; i++) {
                this.sectionFormat.combineFormat(this.viewer.pages[i].bodyWidgets[0].sectionFormat);
            }
        }
    };
    //section format retrieval ends.
    //Paragraph format retrieval implementation starts.
    /**
     * Retrieve selection paragraph format
     * @private
     */
    Selection.prototype.retrieveParagraphFormat = function (start, end) {
        this.getParagraphFormatForSelection(start.paragraph, this, start, end);
    };
    /**
     * @private
     */
    Selection.prototype.getParagraphFormatForSelection = function (paragraph, selection, start, end) {
        //Selection start in cell.
        if (start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
            || start.paragraph.associatedCell !== end.paragraph.associatedCell
            || this.isCellSelected(start.paragraph.associatedCell, start, end))) {
            this.getParagraphFormatInternalInCell(start.paragraph.associatedCell, start, end);
        }
        else {
            this.getParagraphFormatInternalInParagraph(paragraph, start, end);
        }
    };
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Selection.prototype.getParagraphFormatInternalInParagraph = function (paragraph, start, end) {
        if (start.paragraph === paragraph) {
            this.paragraphFormat.copyFormat(paragraph.paragraphFormat);
        }
        else {
            this.paragraphFormat.combineFormat(paragraph.paragraphFormat);
        }
        if (end.paragraph === paragraph) {
            return;
        }
        var block = this.getNextRenderedBlock(paragraph);
        if (!isNullOrUndefined(block)) {
            this.getParagraphFormatInternalInBlock(block, start, end);
        }
    };
    /**
     * @private
     */
    Selection.prototype.getParagraphFormatInternalInBlock = function (block, start, end) {
        if (block instanceof ParagraphWidget) {
            this.getParagraphFormatInternalInParagraph(block, start, end);
        }
        else {
            this.getParagraphFormatInternalInTable(block, start, end);
        }
    };
    /**
     * @private
     */
    Selection.prototype.getParagraphFormatInternalInTable = function (table, start, end) {
        for (var i = 0; i < table.childWidgets.length; i++) {
            var tableRow = table.childWidgets[i];
            for (var j = 0; j < tableRow.childWidgets.length; j++) {
                this.getParagraphFormatInCell(tableRow.childWidgets[j]);
            }
            if (end.paragraph.isInsideTable && this.containsRow(tableRow, end.paragraph.associatedCell)) {
                return;
            }
        }
        var block = this.getNextRenderedBlock(table);
        //Goto the next block.
        this.getParagraphFormatInternalInBlock(block, start, end);
    };
    /**
     * Get paragraph format in cell
     * @private
     */
    Selection.prototype.getParagraphFormatInCell = function (cell) {
        for (var i = 0; i < cell.childWidgets.length; i++) {
            this.getParagraphFormatInBlock(cell.childWidgets[i]);
        }
    };
    /**
     * @private
     */
    Selection.prototype.getParagraphFormatInBlock = function (block) {
        if (block instanceof ParagraphWidget) {
            this.getParagraphFormatInParagraph(block);
        }
        else {
            this.getParagraphFormatInTable(block);
        }
    };
    /**
     * @private
     */
    Selection.prototype.getParagraphFormatInTable = function (tableAdv) {
        for (var i = 0; i < tableAdv.childWidgets.length; i++) {
            var tableRow = tableAdv.childWidgets[i];
            for (var j = 0; j < tableRow.childWidgets.length; j++) {
                this.getParagraphFormatInCell(tableRow.childWidgets[j]);
            }
        }
    };
    /**
     * @private
     */
    Selection.prototype.getParagraphFormatInParagraph = function (paragraph) {
        this.paragraphFormat.combineFormat(paragraph.paragraphFormat);
    };
    /**
     * Get paragraph format in cell
     * @private
     */
    Selection.prototype.getParagraphFormatInternalInCell = function (cellAdv, start, end) {
        if (end.paragraph.isInsideTable) {
            var containerCell = this.getContainerCellOf(cellAdv, end.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(end.paragraph.associatedCell)) {
                var startCell = this.getSelectedCell(cellAdv, containerCell);
                var endCell = this.getSelectedCell(end.paragraph.associatedCell, containerCell);
                if (this.containsCell(containerCell, end.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (this.isCellSelected(containerCell, start, end)) {
                        this.getParagraphFormatInCell(containerCell);
                    }
                    else {
                        if (startCell === containerCell) {
                            this.getParagraphFormatInternalInParagraph(start.paragraph, start, end);
                        }
                        else {
                            this.getParagraphFormatInRow(startCell.ownerRow, start, end);
                        }
                    }
                }
                else {
                    //Format other selected cells in current table.
                    this.getParaFormatForCell(containerCell.ownerTable, containerCell, endCell);
                }
            }
            else {
                this.getParagraphFormatInRow(containerCell.ownerRow, start, end);
            }
        }
        else {
            var cell = this.getContainerCell(cellAdv);
            this.getParagraphFormatInRow(cell.ownerRow, start, end);
        }
    };
    /**
     * @private
     */
    Selection.prototype.getParaFormatForCell = function (table, startCell, endCell) {
        var startCellIn = this.getCellLeft(startCell.ownerRow, startCell);
        var endCellIn = startCellIn + startCell.cellFormat.cellWidth;
        var endCellLeft = this.getCellLeft(endCell.ownerRow, endCell);
        var endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        if (startCellIn > endCellLeft) {
            startCellIn = endCellLeft;
        }
        if (endCellIn < endCellRight) {
            endCellIn = endCellRight;
        }
        if (startCellIn > this.upDownSelectionLength) {
            startCellIn = this.upDownSelectionLength;
        }
        if (startCellIn < this.upDownSelectionLength) {
            startCellIn = this.upDownSelectionLength;
        }
        var count = table.childWidgets.indexOf(endCell.ownerRow);
        for (var i = table.childWidgets.indexOf(startCell.ownerRow); i <= count; i++) {
            var tableRow = table.childWidgets[i];
            for (var j = 0; j < tableRow.childWidgets.length; j++) {
                var cell = tableRow.childWidgets[j];
                var left = this.getCellLeft(tableRow, cell);
                if (HelperMethods.round(startCellIn, 2) <= HelperMethods.round(left, 2)
                    && HelperMethods.round(left, 2) < HelperMethods.round(endCellIn, 2)) {
                    this.getParagraphFormatInCell(cell);
                }
            }
        }
    };
    /**
     * Get paragraph format ins row
     * @private
     */
    Selection.prototype.getParagraphFormatInRow = function (tableRow, start, end) {
        for (var i = tableRow.rowIndex; i < tableRow.ownerTable.childWidgets.length; i++) {
            var row = tableRow.ownerTable.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                this.getParagraphFormatInCell(row.childWidgets[j]);
            }
            if (end.paragraph.isInsideTable && this.containsRow(row, end.paragraph.associatedCell)) {
                return;
            }
        }
        var block = this.getNextRenderedBlock(tableRow.ownerTable);
        //Goto the next block.
        this.getParagraphFormatInternalInBlock(block, start, end);
    };
    // paragraph format retrieval implementation ends
    // Character format retrieval implementation starts.
    /**
     * Retrieve Selection character format
     * @private
     */
    Selection.prototype.retrieveCharacterFormat = function (start, end) {
        this.characterFormat.copyFormat(start.paragraph.characterFormat);
        if (start.paragraph === end.paragraph && start.currentWidget.isLastLine()
            && start.offset === this.getLineLength(start.currentWidget) && start.offset + 1 === end.offset) {
            return;
        }
        var para = start.paragraph;
        if (start.offset === this.getParagraphLength(para) && !this.isEmpty) {
            para = this.getNextParagraphBlock(para);
        }
        while (!isNullOrUndefined(para) && para !== end.paragraph && para.isEmpty()) {
            para = this.getNextParagraphBlock(para);
        }
        var offset = para === start.paragraph ? start.offset : 0;
        var indexInInline = 0;
        if (!isNullOrUndefined(para) && !para.isEmpty()) {
            var position = new TextPosition(this.owner);
            var elemInfo = start.currentWidget.getInline(offset, indexInInline);
            var physicalLocation = this.getPhysicalPositionInternal(start.currentWidget, offset, true);
            position.setPositionForSelection(start.currentWidget, elemInfo.element, elemInfo.index, physicalLocation);
            this.getCharacterFormatForSelection(para, this, position, end);
        }
    };
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Selection.prototype.getCharacterFormatForSelection = function (paragraph, selection, startPosition, endPosition) {
        //Selection start in cell.
        if (startPosition.paragraph instanceof ParagraphWidget && startPosition.paragraph.isInsideTable
            && (!endPosition.paragraph.isInsideTable
                || startPosition.paragraph.associatedCell !== endPosition.paragraph.associatedCell
                || this.isCellSelected(startPosition.paragraph.associatedCell, startPosition, endPosition))) {
            this.getCharacterFormatInTableCell(startPosition.paragraph.associatedCell, selection, startPosition, endPosition);
        }
        else {
            this.getCharacterFormat(paragraph, startPosition, endPosition);
        }
    };
    /**
     * Get Character format
     * @private
     */
    //Format Retrieval
    Selection.prototype.getCharacterFormatForTableRow = function (tableRowAdv, start, end) {
        for (var i = tableRowAdv.rowIndex; i < tableRowAdv.ownerTable.childWidgets.length; i++) {
            var tableRow = tableRowAdv.ownerTable.childWidgets[i];
            for (var j = 0; j < tableRow.childWidgets.length; j++) {
                this.getCharacterFormatForSelectionCell(tableRow.childWidgets[j], start, end);
            }
            if (end.paragraph.isInsideTable && this.containsRow(tableRow, end.paragraph.associatedCell)) {
                return;
            }
        }
        var block = this.getNextRenderedBlock(tableRowAdv.ownerTable);
        // //Goto the next block.
        this.getCharacterFormatForBlock(block, start, end);
    };
    /**
     * Get Character format in table
     * @private
     */
    Selection.prototype.getCharacterFormatInTableCell = function (tableCell, selection, start, end) {
        if (end.paragraph.isInsideTable) {
            var containerCell = this.getContainerCellOf(tableCell, end.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(end.paragraph.associatedCell)) {
                var startCell = this.getSelectedCell(tableCell, containerCell);
                var endCell = this.getSelectedCell(end.paragraph.associatedCell, containerCell);
                if (this.containsCell(containerCell, end.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (this.isCellSelected(containerCell, start, end)) {
                        this.getCharacterFormatForSelectionCell(containerCell, start, end);
                    }
                    else {
                        if (startCell === containerCell) {
                            this.getCharacterFormat(start.paragraph, start, end);
                        }
                        else {
                            this.getCharacterFormatForTableRow(startCell.ownerRow, start, end);
                        }
                    }
                }
                else {
                    //Format other selected cells in current table.
                    this.getCharacterFormatInternalInTable(containerCell.ownerTable, containerCell, endCell, start, end);
                }
            }
            else {
                this.getCharacterFormatForTableRow(containerCell.ownerRow, start, end);
            }
        }
        else {
            var cell = this.getContainerCell(tableCell);
            this.getCharacterFormatForTableRow(cell.ownerRow, start, end);
        }
    };
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Selection.prototype.getCharacterFormatInternalInTable = function (table, startCell, endCell, startPosition, endPosition) {
        var startIn = this.getCellLeft(startCell.ownerRow, startCell);
        var endIn = startIn + startCell.cellFormat.cellWidth;
        var endCellLeft = this.getCellLeft(endCell.ownerRow, endCell);
        var endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        if (startIn > endCellLeft) {
            startIn = endCellLeft;
        }
        if (endIn < endCellRight) {
            endIn = endCellRight;
        }
        if (startIn > this.upDownSelectionLength) {
            startIn = this.upDownSelectionLength;
        }
        if (endIn < this.upDownSelectionLength) {
            endIn = this.upDownSelectionLength;
        }
        var count = table.childWidgets.indexOf(endCell.ownerRow);
        for (var i = table.childWidgets.indexOf(startCell.ownerRow); i <= count; i++) {
            var row = table.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                var left = this.getCellLeft(row, cell);
                if (HelperMethods.round(startIn, 2) <= HelperMethods.round(left, 2) &&
                    HelperMethods.round(left, 2) < HelperMethods.round(endIn, 2)) {
                    this.getCharacterFormatForSelectionCell(cell, startPosition, endPosition);
                }
            }
        }
    };
    /**
     * Get character format with in selection
     * @private
     */
    Selection.prototype.getCharacterFormat = function (paragraph, start, end) {
        if (paragraph !== start.paragraph && paragraph !== end.paragraph) {
            this.getCharacterFormatInternal(paragraph, this);
            return;
        }
        if (end.paragraph === paragraph && start.paragraph !== paragraph && end.offset === 0) {
            return;
        }
        var startOffset = 0;
        var length = this.getParagraphLength(paragraph);
        if (paragraph === start.paragraph) {
            startOffset = start.offset;
            //Sets selection character format.            
            var isUpdated = this.setCharacterFormat(paragraph, start, end, length);
            if (isUpdated) {
                return;
            }
        }
        var startLineWidget = paragraph.childWidgets.indexOf(start.currentWidget) !== -1 ?
            paragraph.childWidgets.indexOf(start.currentWidget) : 0;
        var endLineWidget = paragraph.childWidgets.indexOf(end.currentWidget) !== -1 ?
            paragraph.childWidgets.indexOf(end.currentWidget) : paragraph.childWidgets.length - 1;
        var endOffset = end.offset;
        if (paragraph !== end.paragraph) {
            endOffset = length;
        }
        var isFieldStartSelected = false;
        for (var i = startLineWidget; i <= endLineWidget; i++) {
            var lineWidget = paragraph.childWidgets[i];
            if (i !== startLineWidget) {
                startOffset = this.getStartLineOffset(lineWidget);
            }
            if (lineWidget === end.currentWidget) {
                endOffset = end.offset;
            }
            else {
                endOffset = this.getLineLength(lineWidget);
            }
            var count = 0;
            for (var j = 0; j < lineWidget.children.length; j++) {
                var inline = lineWidget.children[j];
                if (startOffset >= count + inline.length) {
                    count += inline.length;
                    continue;
                }
                if (inline instanceof FieldElementBox && inline.fieldType === 0
                    && HelperMethods.isLinkedFieldCharacter(inline)) {
                    var nextInline = isNullOrUndefined(inline.fieldSeparator) ?
                        inline.fieldEnd : inline.fieldSeparator;
                    do {
                        count += inline.length;
                        inline = inline.nextNode;
                        i++;
                    } while (!isNullOrUndefined(inline) && inline !== nextInline);
                    isFieldStartSelected = true;
                }
                if (inline instanceof FieldElementBox && inline.fieldType === 1
                    && HelperMethods.isLinkedFieldCharacter(inline) && isFieldStartSelected) {
                    var fieldInline = inline.fieldBegin;
                    do {
                        this.characterFormat.combineFormat(fieldInline.characterFormat);
                        fieldInline = fieldInline.nextNode;
                    } while (!(fieldInline instanceof FieldElementBox));
                }
                if (inline instanceof TextElementBox) {
                    this.characterFormat.combineFormat(inline.characterFormat);
                }
                if (isNullOrUndefined(inline) || endOffset <= count + inline.length) {
                    break;
                }
                count += inline.length;
            }
        }
        if (end.paragraph === paragraph) {
            return;
        }
        var block = this.getNextRenderedBlock(paragraph);
        if (!isNullOrUndefined(block)) {
            this.getCharacterFormatForBlock(block, start, end);
        }
    };
    Selection.prototype.setCharacterFormat = function (para, startPos, endPos, length) {
        var index = 0;
        var startOffset = startPos.offset;
        var inlineAndIndex = startPos.currentWidget.getInline(startOffset, index);
        index = inlineAndIndex.index;
        var inline = inlineAndIndex.element;
        if (isNullOrUndefined(inline)) {
            var currentLineIndex = startPos.paragraph.childWidgets.indexOf(startPos.currentWidget);
            if (startPos.currentWidget.previousLine) {
                inline = startPos.currentWidget.previousLine.children[startPos.currentWidget.previousLine.children.length - 1];
                this.characterFormat.copyFormat(inline.characterFormat);
                return true;
            }
        }
        if (startOffset < length) {
            if (this.isEmpty) {
                if (inline instanceof TextElementBox || (inline instanceof FieldElementBox
                    && (inline.fieldType === 0 || inline.fieldType === 1))) {
                    var previousNode = this.getPreviousTextElement(inline);
                    if (startOffset === 0 && previousNode) {
                        inline = previousNode;
                    }
                    this.characterFormat.copyFormat(inline.characterFormat);
                }
                else {
                    if (!isNullOrUndefined(this.getPreviousTextElement(inline))) {
                        this.characterFormat.copyFormat(this.getPreviousTextElement(inline).characterFormat);
                    }
                    else if (!isNullOrUndefined(this.getNextTextElement(inline))) {
                        this.characterFormat.copyFormat(this.getNextTextElement(inline).characterFormat);
                    }
                    else {
                        this.characterFormat.copyFormat(para.characterFormat);
                    }
                }
                return true;
            }
            else {
                if (index === inline.length && !isNullOrUndefined(inline.nextNode)) {
                    this.characterFormat.copyFormat(this.getNextValidCharacterFormat(inline));
                }
                else if (inline instanceof TextElementBox) {
                    this.characterFormat.copyFormat(inline.characterFormat);
                }
                else if (inline instanceof FieldElementBox) {
                    this.characterFormat.copyFormat(this.getNextValidCharacterFormatOfField(inline));
                }
            }
        }
        else {
            if (length === endPos.offset) {
                if (inline instanceof TextElementBox || inline instanceof FieldElementBox) {
                    this.characterFormat.copyFormat(inline.characterFormat);
                }
                else if (!isNullOrUndefined(inline)) {
                    inline = this.getPreviousTextElement(inline);
                    if (!isNullOrUndefined(inline)) {
                        this.characterFormat.copyFormat(inline.characterFormat);
                    }
                }
                else {
                    this.characterFormat.copyFormat(para.characterFormat);
                }
                return true;
            }
        }
        return false;
    };
    /**
     * @private
     */
    Selection.prototype.getCharacterFormatForBlock = function (block, start, end) {
        if (block instanceof ParagraphWidget) {
            this.getCharacterFormat(block, start, end);
        }
        else {
            this.getCharacterFormatInTable(block, start, end);
        }
    };
    /**
     * @private
     */
    Selection.prototype.getCharacterFormatInTable = function (table, start, end) {
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                this.getCharacterFormatForSelectionCell(row.childWidgets[j], start, end);
            }
            if (end.paragraph.isInsideTable && this.containsRow(row, end.paragraph.associatedCell)) {
                return;
            }
        }
        var blockAdv = this.getNextRenderedBlock(table);
        // //Goto the next block.
        this.getCharacterFormatForBlock(blockAdv, start, end);
    };
    /**
     * Get character format in selection
     * @private
     */
    Selection.prototype.getCharacterFormatForSelectionCell = function (cell, start, end) {
        for (var i = 0; i < cell.childWidgets.length; i++) {
            this.getCharacterFormatForBlock(cell.childWidgets[i], start, end);
        }
    };
    /**
     * @private
     */
    Selection.prototype.getCharacterFormatInternal = function (paragraph, selection) {
        for (var i = 0; i < paragraph.childWidgets.length; i++) {
            var linewidget = paragraph.childWidgets[i];
            for (var j = 0; j < linewidget.children.length; j++) {
                var element = linewidget.children[j];
                if (!(element instanceof ImageElementBox || element instanceof FieldElementBox)) {
                    selection.characterFormat.combineFormat(element.characterFormat);
                }
            }
        }
    };
    /**
     * Get next valid character format from inline
     * @private
     */
    Selection.prototype.getNextValidCharacterFormat = function (inline) {
        var startInline = this.getNextTextElement(inline);
        if (isNullOrUndefined(startInline)) {
            return inline.characterFormat;
        }
        var fieldBegin = undefined;
        if (startInline instanceof FieldElementBox) {
            if (fieldBegin.fieldType === 0) {
                fieldBegin = startInline;
            }
        }
        if (isNullOrUndefined(fieldBegin)) {
            return startInline.characterFormat;
        }
        else {
            return this.getNextValidCharacterFormatOfField(fieldBegin);
        }
    };
    /**
     * Get next valid paragraph format from field
     * @private
     */
    Selection.prototype.getNextValidCharacterFormatOfField = function (fieldBegin) {
        var startInline = fieldBegin;
        if (HelperMethods.isLinkedFieldCharacter(fieldBegin)) {
            if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                startInline = fieldBegin.fieldEnd;
            }
            else {
                startInline = fieldBegin.fieldSeparator;
            }
        }
        var nextValidInline = undefined;
        if (!isNullOrUndefined(startInline.nextNode)) {
            //Check the next node is a valid and returns inline.
            nextValidInline = this.getNextValidElement(startInline.nextNode);
        }
        //If field separator/end exists at end of paragraph, then move to next paragraph.
        if (isNullOrUndefined(nextValidInline)) {
            return startInline.characterFormat;
        }
        return nextValidInline.characterFormat;
    };
    /**
     * Return true if cursor point with in selection range
     * @private
     */
    Selection.prototype.checkCursorIsInSelection = function (widget, point) {
        if (isNullOrUndefined(this.start) || this.isEmpty || isNullOrUndefined(widget)) {
            return false;
        }
        var isSelected = false;
        do {
            if (this.selectedWidgets.containsKey(widget)) {
                var top_4 = void 0;
                var left = void 0;
                if (widget instanceof LineWidget) {
                    top_4 = this.owner.selection.getTop(widget);
                    left = this.owner.selection.getLeft(widget);
                }
                else {
                    top_4 = widget.y;
                    left = widget.x;
                }
                var widgetInfo = this.selectedWidgets.get(widget);
                isSelected = widgetInfo.left <= point.x && top_4 <= point.y &&
                    top_4 + widget.height >= point.y && widgetInfo.left + widgetInfo.width >= point.x;
            }
            widget = (widget instanceof LineWidget) ? widget.paragraph : widget.containerWidget;
        } while (!isNullOrUndefined(widget) && !isSelected);
        return isSelected;
    };
    /**
     * Copy paragraph for to selection paragraph format
     * @private
     */
    Selection.prototype.copySelectionParagraphFormat = function () {
        var format = new WParagraphFormat();
        this.paragraphFormat.copyToFormat(format);
        return format;
    };
    /**
     * Get hyperlink display text
     * @private
     */
    // tslint:disable-next-line
    Selection.prototype.getHyperlinkDisplayText = function (paragraph, fieldSeparator, fieldEnd, isNestedField, format) {
        var para = paragraph;
        if (para !== fieldEnd.line.paragraph) {
            isNestedField = true;
            return { displayText: '<<Selection in Document>>', 'isNestedField': isNestedField, 'format': format };
        }
        var displayText = '';
        var lineIndex = para.childWidgets.indexOf(fieldSeparator.line);
        var index = para.childWidgets[lineIndex].children.indexOf(fieldSeparator);
        for (var j = lineIndex; j < para.childWidgets.length; j++) {
            var lineWidget = para.childWidgets[j];
            if (j !== lineIndex) {
                index = -1;
            }
            for (var i = index + 1; i < lineWidget.children.length; i++) {
                var inline = lineWidget.children[i];
                if (inline === fieldEnd) {
                    return { 'displayText': displayText, 'isNestedField': isNestedField, 'format': format };
                }
                if (inline instanceof TextElementBox) {
                    displayText += inline.text;
                    format = inline.characterFormat;
                }
                else if (inline instanceof FieldElementBox) {
                    if (inline instanceof FieldElementBox && inline.fieldType === 0
                        && !isNullOrUndefined(inline.fieldEnd)) {
                        if (isNullOrUndefined(inline.fieldSeparator)) {
                            index = lineWidget.children.indexOf(inline.fieldEnd);
                        }
                        else {
                            index = lineWidget.children.indexOf(inline.fieldSeparator);
                        }
                    }
                }
                else {
                    isNestedField = true;
                    return { 'displayText': '<<Selection in Document>>', 'isNestedField': isNestedField, 'format': format };
                }
            }
        }
        return { 'displayText': displayText, 'isNestedField': isNestedField, 'format': format };
    };
    /**
     * Navigates hyperlink on mouse Event.
     * @private
     */
    Selection.prototype.navigateHyperLinkOnEvent = function (cursorPoint, isTouchInput) {
        var _this = this;
        var widget = this.viewer.getLineWidget(cursorPoint);
        if (!isNullOrUndefined(widget)) {
            var hyperLinkField = this.getHyperLinkFieldInCurrentSelection(widget, cursorPoint);
            //Invokes Hyperlink navigation events.
            if (!isNullOrUndefined(hyperLinkField)) {
                this.viewer.updateTextPositionForSelection(cursorPoint, 1);
                this.fireRequestNavigate(hyperLinkField);
                setTimeout(function () {
                    if (_this.viewer) {
                        _this.viewer.isTouchInput = isTouchInput;
                        _this.viewer.updateFocus();
                        _this.viewer.isTouchInput = false;
                    }
                });
            }
        }
    };
    /**
     * @private
     */
    Selection.prototype.getLinkText = function (fieldBegin) {
        var hyperlink = new Hyperlink(fieldBegin, this);
        var link = hyperlink.navigationLink;
        if (hyperlink.localReference.length > 0) {
            if (hyperlink.localReference[0] === '_' && (isNullOrUndefined(link) || link.length === 0)) {
                link = 'Current Document';
            }
            else {
                link += '#' + hyperlink.localReference;
            }
        }
        hyperlink.destroy();
        return link;
    };
    /**
     * Set Hyperlink content to tool tip element
     * @private
     */
    Selection.prototype.setHyperlinkContentToToolTip = function (fieldBegin, widget, xPos) {
        if (fieldBegin) {
            if (this.owner.contextMenuModule &&
                this.owner.contextMenuModule.contextMenuInstance.element.style.display === 'block') {
                return;
            }
            if (!this.toolTipElement) {
                this.toolTipElement = createElement('div', { className: 'e-de-tooltip' });
                this.viewer.viewerContainer.appendChild(this.toolTipElement);
            }
            this.toolTipElement.style.display = 'block';
            var l10n = new L10n('documenteditor', this.owner.defaultLocale);
            l10n.setLocale(this.owner.locale);
            var toolTipText = l10n.getConstant('Click to follow link');
            if (this.owner.useCtrlClickToFollowHyperlink) {
                toolTipText = 'Ctrl+' + toolTipText;
            }
            var linkText = this.getLinkText(fieldBegin);
            this.toolTipElement.innerHTML = linkText + '</br><b>' + toolTipText + '</b>';
            var widgetTop = this.getTop(widget) * this.viewer.zoomFactor;
            var page = this.getPage(widget.paragraph);
            var containerWidth = this.viewer.viewerContainer.getBoundingClientRect().width + this.viewer.viewerContainer.scrollLeft;
            var left = page.boundingRectangle.x + xPos * this.viewer.zoomFactor;
            if ((left + this.toolTipElement.clientWidth + 10) > containerWidth) {
                left = left - ((this.toolTipElement.clientWidth - (containerWidth - left)) + 15);
            }
            var top_5 = this.getPageTop(page) + (widgetTop - this.toolTipElement.offsetHeight);
            top_5 = top_5 > this.viewer.viewerContainer.scrollTop ? top_5 : top_5 + widget.height + this.toolTipElement.offsetHeight;
            this.showToolTip(left, top_5);
            if (!isNullOrUndefined(this.toolTipField) && fieldBegin !== this.toolTipField) {
                this.toolTipObject.position = { X: left, Y: top_5 };
            }
            this.toolTipObject.show();
            this.toolTipField = fieldBegin;
        }
        else {
            this.hideToolTip();
        }
    };
    /**
     * @private
     */
    Selection.prototype.createPasteElement = function (top, left) {
        var locale = new L10n('documenteditor', this.owner.defaultLocale);
        locale.setLocale(this.owner.locale);
        var items = [
            {
                text: locale.getConstant('Keep source formatting'),
                iconCss: 'e-icons e-de-paste-source'
            },
            {
                text: locale.getConstant('Match destination formatting'),
                iconCss: 'e-icons e-de-paste-merge'
            },
            {
                text: locale.getConstant('Text only'),
                iconCss: 'e-icons e-de-paste-text'
            }
        ];
        if (!this.pasteElement) {
            this.pasteElement = createElement('div', { className: 'e-de-tooltip' });
            this.viewer.viewerContainer.appendChild(this.pasteElement);
            var splitButtonEle = createElement('button', { id: 'iconsplitbtn' });
            this.pasteElement.appendChild(splitButtonEle);
            this.pasteDropDwn = new DropDownButton({
                items: items, iconCss: 'e-icons e-de-paste', select: this.pasteOptions
            });
            this.pasteDropDwn.appendTo('#iconsplitbtn');
        }
        this.pasteElement.style.display = 'block';
        this.pasteElement.style.position = 'absolute';
        this.pasteElement.style.left = left;
        this.pasteElement.style.top = top;
    };
    /**
     * Show hyperlink tooltip
     * @private
     */
    Selection.prototype.showToolTip = function (x, y) {
        if (!this.toolTipObject) {
            this.toolTipObject = new Popup(this.toolTipElement, {
                height: 'auto',
                width: 'auto',
                relateTo: this.viewer.viewerContainer.parentElement,
                position: { X: x, Y: y }
            });
        }
    };
    /**
     * Hide tooltip object
     * @private
     */
    Selection.prototype.hideToolTip = function () {
        this.toolTipField = undefined;
        if (this.toolTipObject) {
            this.toolTipElement.style.display = 'none';
            this.toolTipObject.hide();
            this.toolTipObject.destroy();
            this.toolTipObject = undefined;
        }
    };
    /**
     * Return hyperlink field
     * @private
     */
    Selection.prototype.getHyperLinkFieldInCurrentSelection = function (widget, cursorPosition) {
        var inline = undefined;
        var top = this.getTop(widget);
        var lineStartLeft = this.getLineStartLeft(widget);
        if (cursorPosition.y < top || cursorPosition.y > top + widget.height
            || cursorPosition.x < lineStartLeft || cursorPosition.x > lineStartLeft + widget.paragraph.width) {
            return undefined;
        }
        var left = widget.paragraph.x;
        var elementValues = this.getFirstElement(widget, left);
        left = elementValues.left;
        var element = elementValues.element;
        if (isNullOrUndefined(element)) {
            var width = this.viewer.textHelper.getParagraphMarkWidth(widget.paragraph.characterFormat);
            if (cursorPosition.x <= lineStartLeft + width || cursorPosition.x >= lineStartLeft + width) {
                //Check if paragraph is within a field result.
                var checkedFields = [];
                var field = this.getHyperLinkFields(widget.paragraph, checkedFields);
                checkedFields = [];
                checkedFields = undefined;
                return field;
            }
        }
        else {
            if (cursorPosition.x > left + element.margin.left) {
                for (var i = widget.children.indexOf(element); i < widget.children.length; i++) {
                    element = widget.children[i];
                    if (cursorPosition.x < left + element.margin.left + element.width || i === widget.children.length - 1) {
                        break;
                    }
                    left += element.margin.left + element.width;
                }
            }
            inline = element;
            var width = element.margin.left + element.width;
            if (isNullOrUndefined(inline.nextNode)) {
                //Include width of Paragraph mark.
                width += this.viewer.textHelper.getParagraphMarkWidth(inline.line.paragraph.characterFormat);
            }
            if (cursorPosition.x <= left + width) {
                //Check if inline is within a field result.
                var checkedFields = [];
                var field = this.getHyperLinkFieldInternal(inline.line.paragraph, inline, checkedFields);
                checkedFields = [];
                checkedFields = undefined;
                return field;
            }
        }
        return undefined;
    };
    /**
     * Return field if paragraph contain hyperlink field
     * @private
     */
    Selection.prototype.getHyperlinkField = function (isRetrieve) {
        if (isNullOrUndefined(this.end)) {
            return undefined;
        }
        var index = 0;
        var currentInline = this.end.currentWidget.getInline(this.end.offset, index);
        index = currentInline.index;
        var inline = currentInline.element;
        var checkedFields = [];
        var field = undefined;
        if (isNullOrUndefined(inline)) {
            field = this.getHyperLinkFields(this.end.paragraph, checkedFields, isRetrieve);
        }
        else {
            var paragraph = inline.line.paragraph;
            field = this.getHyperLinkFieldInternal(paragraph, inline, checkedFields, isRetrieve);
        }
        checkedFields = [];
        return field;
    };
    /**
     * @private
     */
    Selection.prototype.getHyperLinkFields = function (paragraph, checkedFields, isRetrieve) {
        for (var i = 0; i < this.viewer.fields.length; i++) {
            if (checkedFields.indexOf(this.viewer.fields[i]) !== -1 || isNullOrUndefined(this.viewer.fields[i].fieldSeparator)) {
                continue;
            }
            else {
                checkedFields.push(this.viewer.fields[i]);
            }
            var field = this.getFieldCode(this.viewer.fields[i]);
            field = field.trim().toLowerCase();
            var isParagraph = this.paragraphIsInFieldResult(this.viewer.fields[i], paragraph);
            if ((isRetrieve || (!isRetrieve && field.match('hyperlink '))) && isParagraph) {
                return this.viewer.fields[i];
            }
        }
        // if (paragraph.containerWidget instanceof BodyWidget && !(paragraph instanceof WHeaderFooter)) {
        //     return this.getHyperLinkFields((paragraph.con as WCompositeNode), checkedFields);
        // }
        return undefined;
    };
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Selection.prototype.getHyperLinkFieldInternal = function (paragraph, inline, fields, isRetrieve) {
        for (var i = 0; i < this.viewer.fields.length; i++) {
            if (fields.indexOf(this.viewer.fields[i]) !== -1 || isNullOrUndefined(this.viewer.fields[i].fieldSeparator)) {
                continue;
            }
            else {
                fields.push(this.viewer.fields[i]);
            }
            var fieldCode = this.getFieldCode(this.viewer.fields[i]);
            fieldCode = fieldCode.trim().toLowerCase();
            var isInline = (this.inlineIsInFieldResult(this.viewer.fields[i], inline) || this.isImageField());
            if ((isRetrieve || (!isRetrieve && fieldCode.match('hyperlink '))) && isInline) {
                return this.viewer.fields[i];
            }
        }
        if (paragraph.containerWidget instanceof BodyWidget && !(paragraph instanceof HeaderFooterWidget)) {
            return this.getHyperLinkFieldInternal(paragraph.containerWidget, inline, fields, isRetrieve);
        }
        return undefined;
    };
    /**
     * @private
     */
    Selection.prototype.getBlock = function (currentIndex) {
        if (currentIndex === '' || isNullOrUndefined(currentIndex)) {
            return undefined;
        }
        var index = { index: currentIndex };
        var page = this.start.getPage(index);
        var bodyIndex = index.index.indexOf(';');
        var value = index.index.substring(0, bodyIndex);
        index.index = index.index.substring(bodyIndex).replace(';', '');
        var bodyWidget = page.bodyWidgets[parseInt(value, 10)];
        return this.getBlockInternal(bodyWidget, index.index);
    };
    /**
     * Return Block relative to position
     * @private
     */
    Selection.prototype.getBlockInternal = function (widget, position) {
        if (position === '' || isNullOrUndefined(position)) {
            return undefined;
        }
        var index = position.indexOf(';');
        var value = position.substring(0, index);
        position = position.substring(index).replace(';', '');
        var node = widget;
        // if (node instanceof Widget && value === 'HF') {
        //     //Gets the block in Header footers.
        //     let blockObj: BlockInfo = this.getBlock((node as WSection).headersFooters, position);
        // tslint:disable-next-line:max-line-length
        //     return { 'node': (!isNullOrUndefined(blockObj)) ? blockObj.node : undefined, 'position': (!isNullOrUndefined(blockObj)) ? blockObj.position : undefined };
        // }
        index = parseInt(value, 10);
        if (index >= 0 && index < widget.childWidgets.length) {
            var child = widget.childWidgets[(index)];
            if (position.indexOf(';') >= 0) {
                if (child instanceof ParagraphWidget) {
                    if (position.indexOf(';') >= 0) {
                        position = '0';
                    }
                    return child;
                }
                if (child instanceof BlockWidget) {
                    var blockObj = this.getBlockInternal(child, position);
                    return blockObj;
                }
            }
            else {
                return child;
            }
        }
        else {
            return node;
        }
        return node;
    };
    /**
     * Return true if inline is in field result
     * @private
     */
    Selection.prototype.inlineIsInFieldResult = function (fieldBegin, inline) {
        if (!isNullOrUndefined(fieldBegin.fieldEnd) && !isNullOrUndefined(fieldBegin.fieldSeparator)) {
            if (this.isExistBeforeInline(fieldBegin.fieldSeparator, inline)) {
                return this.isExistAfterInline(fieldBegin.fieldEnd, inline);
            }
        }
        return false;
    };
    /**
     * Retrieve true if paragraph is in field result
     * @private
     */
    Selection.prototype.paragraphIsInFieldResult = function (fieldBegin, paragraph) {
        if (!isNullOrUndefined(fieldBegin.fieldEnd) && !isNullOrUndefined(fieldBegin.fieldSeparator)) {
            var fieldParagraph = fieldBegin.fieldSeparator.line.paragraph;
            if (fieldBegin.fieldSeparator.line.paragraph === paragraph
                || this.isExistBefore(fieldParagraph, paragraph)) {
                var currentParagraph = fieldBegin.fieldEnd.line.paragraph;
                return (currentParagraph !== paragraph && this.isExistAfter(fieldParagraph, paragraph));
            }
        }
        return false;
    };
    /**
     * Return true if image is In field
     * @private
     */
    Selection.prototype.isImageField = function () {
        if (this.start.paragraph.isEmpty() || this.end.paragraph.isEmpty()) {
            return false;
        }
        var startPosition = this.start;
        var endPosition = this.end;
        if (!this.isForward) {
            startPosition = this.end;
            endPosition = this.start;
        }
        var indexInInline = 0;
        var inlineInfo = startPosition.paragraph.getInline(startPosition.offset, indexInInline);
        var inline = inlineInfo.element;
        indexInInline = inlineInfo.index;
        if (indexInInline === inline.length) {
            inline = this.getNextRenderedElementBox(inline, indexInInline);
        }
        inlineInfo = endPosition.paragraph.getInline(endPosition.offset, indexInInline);
        var endInline = inlineInfo.element;
        indexInInline = inlineInfo.index;
        if (inline instanceof FieldElementBox && inline.fieldType === 0
            && endInline instanceof FieldElementBox && endInline.fieldType === 1 && inline.fieldSeparator) {
            var fieldValue = inline.fieldSeparator.nextNode;
            if (fieldValue instanceof ImageElementBox && fieldValue.nextNode === endInline) {
                return true;
            }
        }
        return false;
    };
    /**
     * @private
     */
    Selection.prototype.isTableSelected = function () {
        var start = this.start;
        var end = this.end;
        if (!this.isForward) {
            start = this.end;
            end = this.start;
        }
        if (isNullOrUndefined(start.paragraph.associatedCell) ||
            isNullOrUndefined(end.paragraph.associatedCell)) {
            return false;
        }
        var table = start.paragraph.associatedCell.ownerTable.getSplitWidgets();
        var firstParagraph = this.getFirstBlockInFirstCell(table[0]);
        var lastParagraph = this.getLastBlockInLastCell(table[table.length - 1]);
        return start.paragraph.associatedCell.equals(firstParagraph.associatedCell) &&
            end.paragraph.associatedCell.equals(lastParagraph.associatedCell)
            && (!firstParagraph.associatedCell.equals(lastParagraph.associatedCell) || (start.offset === 0
                && end.offset === this.getLineLength(lastParagraph.lastChild) + 1));
    };
    /**
     * Select List Text
     * @private
     */
    Selection.prototype.selectListText = function () {
        var lineWidget = this.viewer.selectionLineWidget;
        var endOffset = '0';
        var selectionIndex = lineWidget.getHierarchicalIndex(endOffset);
        var startPosition = this.getTextPosition(selectionIndex);
        var endPosition = this.getTextPosition(selectionIndex);
        this.selectRange(startPosition, endPosition);
        this.highlightListText(this.viewer.selectionLineWidget);
        this.contextTypeInternal = 'List';
    };
    /**
     * Manually select the list text
     * @private
     */
    Selection.prototype.highlightListText = function (linewidget) {
        var width = linewidget.children[0].width;
        var left = this.viewer.getLeftValue(linewidget);
        var top = linewidget.paragraph.y;
        this.createHighlightBorder(linewidget, width, left, top, false);
        this.viewer.isListTextSelected = true;
    };
    /**
     * @private
     */
    Selection.prototype.updateImageSize = function (imageFormat) {
        this.owner.isShiftingEnabled = true;
        var startPosition = this.start;
        var endPosition = this.end;
        if (!this.isForward) {
            startPosition = this.end;
            endPosition = this.start;
        }
        var inline = null;
        var index = 0;
        var paragraph = startPosition.paragraph;
        if (paragraph === endPosition.paragraph
            && startPosition.offset + 1 === endPosition.offset) {
            var inlineObj = paragraph.getInline(endPosition.offset, index);
            inline = inlineObj.element;
            index = inlineObj.index;
        }
        if (inline instanceof ImageElementBox) {
            var width = inline.width;
            var height = inline.height;
            inline.width = imageFormat.width;
            inline.height = imageFormat.height;
            imageFormat.width = width;
            imageFormat.height = height;
            if (paragraph !== null && paragraph.containerWidget !== null && this.owner.editorModule) {
                var lineIndex = paragraph.childWidgets.indexOf(inline.line);
                var elementIndex = inline.line.children.indexOf(inline);
                this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, elementIndex);
                this.highlightSelection(false);
            }
        }
    };
    /**
     * Gets selected table content
     * @private
     */
    Selection.prototype.getSelectedCellsInTable = function (table, startCell, endCell) {
        var startColumnIndex = startCell.columnIndex;
        var endColumnIndex = endCell.columnIndex + endCell.cellFormat.columnSpan - 1;
        var startRowindex = startCell.ownerRow.index;
        var endRowIndex = endCell.ownerRow.index;
        var cells = [];
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            if (row.index >= startRowindex && row.index <= endRowIndex) {
                for (var j = 0; j < row.childWidgets.length; j++) {
                    var cell = row.childWidgets[j];
                    if (cell.columnIndex >= startColumnIndex && cell.columnIndex <= endColumnIndex) {
                        cells.push(cell);
                    }
                }
            }
            if (row.index > endRowIndex) {
                break;
            }
        }
        return cells;
        // return html;
    };
    /**
     * Copies the selected content to clipboard.
     */
    Selection.prototype.copy = function () {
        if (this.isEmpty) {
            return;
        }
        this.copySelectedContent(false);
    };
    /**
     * @private
     */
    Selection.prototype.copySelectedContent = function (isCut) {
        if (isNullOrUndefined(this.owner.sfdtExportModule)) {
            return;
        }
        var startPosition = this.start;
        var endPosition = this.end;
        if (!this.isForward) {
            startPosition = this.end;
            endPosition = this.start;
        }
        /* tslint:disable:no-any */
        // tslint:disable-next-line:max-line-length
        var documentContent = this.owner.sfdtExportModule.write(startPosition.currentWidget, startPosition.offset, endPosition.currentWidget, endPosition.offset, true);
        /* tslint:enable:no-any */
        if (this.owner.editorModule) {
            this.owner.editorModule.copiedData = JSON.stringify(documentContent);
        }
        var html = this.htmlWriter.writeHtml(documentContent);
        this.copyToClipboard(html);
        if (isCut && this.owner.editorModule) {
            this.owner.editorModule.handleCut(this);
        }
        this.viewer.updateFocus();
    };
    /**
     * Copy content to clipboard
     * @private
     */
    Selection.prototype.copyToClipboard = function (htmlContent) {
        window.getSelection().removeAllRanges();
        var div = document.createElement('div');
        div.tabIndex = 0;
        div.style.left = '-10000px';
        div.style.top = '-10000px';
        div.innerHTML = htmlContent;
        document.body.appendChild(div);
        div.focus();
        var range = document.createRange();
        range.selectNodeContents(div);
        window.getSelection().addRange(range);
        var copySuccess = false;
        try {
            copySuccess = document.execCommand('copy');
        }
        catch (e) {
            // Copying data to Clipboard can potentially fail - for example, if another application is holding Clipboard open.
        }
        finally {
            window.getSelection().removeAllRanges();
            div.parentNode.removeChild(div);
            this.viewer.viewerContainer.focus();
        }
        return copySuccess;
    };
    // Caret implementation starts
    /**
     * Shows caret in current selection position.
     * @private
     */
    Selection.prototype.showCaret = function () {
        // tslint:disable-next-line:max-line-length
        var page = !isNullOrUndefined(this.viewer.currentPage) ? this.viewer.currentPage : this.viewer.currentRenderingPage;
        if (isNullOrUndefined(page) || this.viewer.isRowOrCellResizing || this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizerVisible) {
            return;
        }
        var left = page.boundingRectangle.x;
        var right = page.boundingRectangle.width * this.viewer.zoomFactor + left;
        if (!this.owner.enableImageResizerMode || !this.owner.imageResizerModule.isImageResizerVisible) {
            if (this.isHideSelection(this.start.paragraph)) {
                this.caret.style.display = 'none';
            }
            else if (this.isEmpty && (!this.owner.isReadOnlyMode || this.owner.enableCursorOnReadOnly)) {
                var caretLeft = parseInt(this.caret.style.left.replace('px', ''), 10);
                if (caretLeft < left || caretLeft > right) {
                    this.caret.style.display = 'none';
                }
                else {
                    this.caret.style.display = 'block';
                }
            }
            else if (this.isImageSelected && !this.owner.enableImageResizerMode) {
                this.caret.style.display = 'block';
            }
            else {
                if (this.caret.style.display === 'block' || isNullOrUndefined(this)) {
                    if (!this.viewer.isComposingIME) {
                        this.caret.style.display = 'none';
                    }
                }
            }
        }
        if (!isNullOrUndefined(this) && this.viewer.isTouchInput && !this.owner.isReadOnlyMode) {
            var caretStartLeft = parseInt(this.viewer.touchStart.style.left.replace('px', ''), 10) + 14;
            var caretEndLeft = parseInt(this.viewer.touchEnd.style.left.replace('px', ''), 10) + 14;
            var page_1 = this.getSelectionPage(this.start);
            if (page_1) {
                if (caretEndLeft < left || caretEndLeft > right) {
                    this.viewer.touchEnd.style.display = 'none';
                }
                else {
                    this.viewer.touchEnd.style.display = 'block';
                }
                if (!this.isEmpty) {
                    left = page_1.boundingRectangle.x;
                    right = page_1.boundingRectangle.width * this.viewer.zoomFactor + left;
                }
                if (caretStartLeft < left || caretStartLeft > right) {
                    this.viewer.touchStart.style.display = 'none';
                }
                else {
                    this.viewer.touchStart.style.display = 'block';
                }
            }
        }
        else {
            this.viewer.touchStart.style.display = 'none';
            this.viewer.touchEnd.style.display = 'none';
        }
    };
    /**
     * To set the editable div caret position
     * @private
     */
    Selection.prototype.setEditableDivCaretPosition = function (index) {
        this.viewer.editableDiv.focus();
        var child = this.viewer.editableDiv.childNodes[this.viewer.editableDiv.childNodes.length - 1];
        if (child) {
            var range = document.createRange();
            range.setStart(child, index);
            range.collapse(true);
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
        }
    };
    /**
     * Initializes caret.
     * @private
     */
    Selection.prototype.initCaret = function () {
        this.caret = createElement('div', {
            styles: 'position:absolute',
            className: 'e-de-blink-cursor e-de-cursor-animation'
        });
        this.viewer.viewerContainer.appendChild(this.caret);
    };
    /**
     * Updates caret position.
     * @private
     */
    Selection.prototype.updateCaretPosition = function () {
        var caretPosition = this.end.location;
        var page = this.getSelectionPage(this.end);
        if (page && !isNullOrUndefined(this.caret)) {
            this.caret.style.left = page.boundingRectangle.x + (Math.round(caretPosition.x) * this.viewer.zoomFactor) + 'px';
            var caretInfo = this.updateCaretSize(this.owner.selection.end);
            var topMargin = caretInfo.topMargin;
            var caretHeight = caretInfo.height;
            var viewer = this.viewer;
            // tslint:disable-next-line:max-line-length
            var pageTop = (page.boundingRectangle.y - viewer.pageGap * (this.viewer.pages.indexOf(page) + 1)) * this.viewer.zoomFactor + viewer.pageGap * (this.viewer.pages.indexOf(page) + 1);
            this.caret.style.top = pageTop + (Math.round(caretPosition.y + topMargin) * this.viewer.zoomFactor) + 'px';
            if (this.owner.selection.characterFormat.baselineAlignment === 'Subscript') {
                this.caret.style.top = parseFloat(this.caret.style.top) + (parseFloat(this.caret.style.height) / 2) + 'px';
            }
            if (this.viewer.isTouchInput || this.viewer.touchStart.style.display !== 'none') {
                // tslint:disable-next-line:max-line-length
                this.viewer.touchStart.style.left = page.boundingRectangle.x + (Math.round(caretPosition.x) * this.viewer.zoomFactor - 14) + 'px';
                this.viewer.touchStart.style.top = pageTop + ((caretPosition.y + caretInfo.height) * this.viewer.zoomFactor) + 'px';
                // tslint:disable-next-line:max-line-length
                this.viewer.touchEnd.style.left = page.boundingRectangle.x + (Math.round(caretPosition.x) * this.viewer.zoomFactor - 14) + 'px';
                this.viewer.touchEnd.style.top = pageTop + ((caretPosition.y + caretInfo.height) * this.viewer.zoomFactor) + 'px';
            }
        }
        this.showHidePasteOptions(this.caret.style.top, this.caret.style.left);
    };
    /**
     * @private
     */
    Selection.prototype.showHidePasteOptions = function (top, left) {
        if (this.isViewPasteOptions) {
            if (this.pasteElement && this.pasteElement.style.display === 'block') {
                return;
            }
            this.createPasteElement(top, left);
        }
        else if (this.pasteElement) {
            this.pasteElement.style.display = 'none';
        }
    };
    /**
     * @private
     */
    Selection.prototype.getRect = function (position) {
        var caretPosition = position.location;
        var page = this.getSelectionPage(position);
        if (page) {
            var viewer = this.viewer;
            var left = page.boundingRectangle.x + (Math.round(caretPosition.x) * viewer.zoomFactor);
            var pageGap = viewer.pageGap;
            // tslint:disable-next-line:max-line-length
            var pageTop = (page.boundingRectangle.y - pageGap * (page.index + 1)) * viewer.zoomFactor + pageGap * (page.index + 1);
            var top_6 = pageTop + (Math.round(caretPosition.y) * viewer.zoomFactor);
            return new Point(left, top_6);
        }
        return new Point(0, 0);
    };
    /**
     * Gets current selected page
     * @private
     */
    Selection.prototype.getSelectionPage = function (position) {
        var lineWidget = this.getLineWidgetInternal(position.currentWidget, position.offset, true);
        if (lineWidget) {
            return this.getPage(lineWidget.paragraph);
        }
        return undefined;
    };
    /**
     * Updates caret size.
     * @private
     */
    Selection.prototype.updateCaretSize = function (textPosition, skipUpdate) {
        var topMargin = 0;
        var isItalic = false;
        var caret;
        var index = 0;
        var caretHeight = 0;
        if (this.characterFormat.italic) {
            isItalic = this.characterFormat.italic;
        }
        if (textPosition.paragraph.isEmpty()) {
            var paragraph = textPosition.paragraph;
            var bottomMargin = 0;
            var paragraphInfo = this.getParagraphMarkSize(paragraph, topMargin, bottomMargin);
            topMargin = paragraphInfo.topMargin;
            bottomMargin = paragraphInfo.bottomMargin;
            var height = paragraphInfo.height;
            caretHeight = topMargin < 0 ? topMargin + height : height;
            if (!skipUpdate) {
                this.caret.style.height = caretHeight * this.viewer.zoomFactor + 'px';
            }
            topMargin = 0;
        }
        else {
            var inlineInfo = textPosition.currentWidget.getInline(textPosition.offset, index);
            index = inlineInfo.index;
            var inline = inlineInfo.element;
            if (!isNullOrUndefined(inline)) {
                caret = this.getCaretHeight(inline, index, inline.characterFormat, true, topMargin, isItalic);
                caretHeight = caret.height;
                if (!skipUpdate) {
                    this.caret.style.height = caret.height * this.viewer.zoomFactor + 'px';
                }
            }
        }
        if (!skipUpdate) {
            if (isItalic) {
                this.caret.style.transform = 'rotate(13deg)';
            }
            else {
                this.caret.style.transform = '';
            }
        }
        return {
            'topMargin': topMargin,
            'height': caretHeight
        };
    };
    /**
     * Updates caret to page.
     * @private
     */
    Selection.prototype.updateCaretToPage = function (startPosition, endPage) {
        if (!isNullOrUndefined(endPage)) {
            this.viewer.selectionEndPage = endPage;
            if (this.owner.selection.isEmpty) {
                this.viewer.selectionStartPage = endPage;
            }
            else {
                // tslint:disable-next-line:max-line-length
                var startLineWidget = this.getLineWidgetParagraph(startPosition.offset, startPosition.paragraph.childWidgets[0]);
                //Gets start page.
                var startPage = this.getPage(startLineWidget.paragraph);
                if (!isNullOrUndefined(startPage)) {
                    this.viewer.selectionStartPage = startPage;
                }
            }
        }
        this.checkForCursorVisibility();
    };
    /**
     * Gets caret bottom position.
     * @private
     */
    Selection.prototype.getCaretBottom = function (textPosition, isEmptySelection) {
        var bottom = textPosition.location.y;
        if (textPosition.paragraph.isEmpty()) {
            var paragraph = textPosition.paragraph;
            var topMargin = 0;
            var bottomMargin = 0;
            var sizeInfo = this.getParagraphMarkSize(paragraph, topMargin, bottomMargin);
            topMargin = sizeInfo.topMargin;
            bottomMargin = sizeInfo.bottomMargin;
            bottom += sizeInfo.height;
            bottom += topMargin;
            if (!isEmptySelection) {
                bottom += bottomMargin;
            }
        }
        else {
            var index = 0;
            var inlineInfo = textPosition.paragraph.getInline(textPosition.offset, index);
            var inline = inlineInfo.element;
            index = inlineInfo.index;
            var topMargin = 0;
            var isItalic = false;
            // tslint:disable-next-line:max-line-length
            var caretHeightInfo = this.getCaretHeight(inline, index, inline.characterFormat, false, topMargin, isItalic);
            topMargin = caretHeightInfo.topMargin;
            isItalic = caretHeightInfo.isItalic;
            bottom += caretHeightInfo.height;
            if (isEmptySelection) {
                bottom -= HelperMethods.convertPointToPixel(this.viewer.layout.getAfterSpacing(textPosition.paragraph));
            }
        }
        return bottom;
    };
    /**
     * Checks for cursor visibility.
     * @param isTouch
     * @private
     */
    Selection.prototype.checkForCursorVisibility = function () {
        this.showCaret();
    };
    // caret implementation ends
    /**
     * Keyboard shortcuts
     * @private
     */
    // tslint:disable:max-func-body-length
    Selection.prototype.onKeyDownInternal = function (event, ctrl, shift, alt) {
        var key = event.which || event.keyCode;
        if (ctrl && !shift && !alt) {
            this.viewer.isControlPressed = true;
            switch (key) {
                // case 9:
                //     event.preventDefault();
                //     if (this.owner.acceptTab) {
                //         this.selection.handleTabKey(false, false);
                //     }
                //     break;
                case 35:
                    this.handleControlEndKey();
                    break;
                case 36:
                    this.handleControlHomeKey();
                    break;
                case 37:
                    this.handleControlLeftKey();
                    break;
                case 38:
                    this.handleControlUpKey();
                    break;
                case 39:
                    this.handleControlRightKey();
                    break;
                case 40:
                    this.handleControlDownKey();
                    break;
                case 65:
                    this.owner.selection.selectAll();
                    break;
                case 67:
                    event.preventDefault();
                    this.copy();
                    break;
                case 70:
                    event.preventDefault();
                    if (!isNullOrUndefined(this.owner.optionsPaneModule)) {
                        this.owner.optionsPaneModule.showHideOptionsPane(true);
                    }
                    break;
            }
        }
        else if (shift && !ctrl && !alt) {
            switch (key) {
                case 35:
                    this.handleShiftEndKey();
                    event.preventDefault();
                    break;
                case 36:
                    this.handleShiftHomeKey();
                    event.preventDefault();
                    break;
                case 37:
                    this.handleShiftLeftKey();
                    event.preventDefault();
                    break;
                case 38:
                    this.handleShiftUpKey();
                    event.preventDefault();
                    break;
                case 39:
                    this.handleShiftRightKey();
                    event.preventDefault();
                    break;
                case 40:
                    this.handleShiftDownKey();
                    event.preventDefault();
                    break;
            }
        }
        else if (shift && ctrl && !alt) {
            switch (key) {
                case 35:
                    this.handleControlShiftEndKey();
                    break;
                case 36:
                    this.handleControlShiftHomeKey();
                    break;
                case 37:
                    this.handleControlShiftLeftKey();
                    break;
                case 38:
                    this.handleControlShiftUpKey();
                    break;
                case 39:
                    this.handleControlShiftRightKey();
                    break;
                case 40:
                    this.handleControlShiftDownKey();
                    break;
            }
        }
        else {
            switch (key) {
                // case 9:
                //     event.preventDefault();
                //     if (this.owner.acceptTab) {
                //         this.handleTabKey(true, false);
                //     }
                //     break;             
                case 33:
                    event.preventDefault();
                    this.viewer.viewerContainer.scrollTop -= this.viewer.visibleBounds.height;
                    break;
                case 34:
                    event.preventDefault();
                    this.viewer.viewerContainer.scrollTop += this.viewer.visibleBounds.height;
                    break;
                case 35:
                    this.handleEndKey();
                    event.preventDefault();
                    break;
                case 36:
                    this.handleHomeKey();
                    event.preventDefault();
                    break;
                case 37:
                    this.handleLeftKey();
                    event.preventDefault();
                    break;
                case 38:
                    this.handleUpKey();
                    event.preventDefault();
                    break;
                case 39:
                    this.handleRightKey();
                    event.preventDefault();
                    break;
                case 40:
                    this.handleDownKey();
                    event.preventDefault();
                    break;
            }
        }
        if (!this.owner.isReadOnlyMode) {
            this.owner.editorModule.onKeyDownInternal(event, ctrl, shift, alt);
        }
        if (this.owner.searchModule) {
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(this.owner.searchModule.searchHighlighters) && this.owner.searchModule.searchHighlighters.length > 0) {
                this.owner.searchModule.searchResults.clear();
            }
        }
        if (event.keyCode === 27 || event.which === 27) {
            if (!isNullOrUndefined(this.owner.optionsPaneModule)) {
                this.owner.optionsPaneModule.showHideOptionsPane(false);
            }
            if (this.owner.enableHeaderAndFooter) {
                this.disableHeaderFooter();
            }
        }
    };
    //#region Enable or disable Header Footer
    /**
     * @private
     */
    Selection.prototype.checkAndEnableHeaderFooter = function (point, pagePoint) {
        var page = this.viewer.currentPage;
        if (this.isCursorInsidePageRect(point, page)) {
            if (this.isCursorInHeaderRegion(point, page)) {
                if (this.owner.enableHeaderAndFooter) {
                    return false;
                }
                return this.enableHeadersFootersRegion(page.headerWidget);
            }
            if (this.isCursorInFooterRegion(point, page)) {
                if (this.owner.enableHeaderAndFooter) {
                    return false;
                }
                return this.enableHeadersFootersRegion(page.footerWidget);
            }
        }
        if (this.owner.enableHeaderAndFooter) {
            this.owner.enableHeaderAndFooter = false;
            this.viewer.updateTextPositionForSelection(pagePoint, 1);
            return true;
        }
        return false;
    };
    /**
     * @private
     */
    Selection.prototype.isCursorInsidePageRect = function (point, page) {
        if ((this.viewer.containerLeft + point.x) >= page.boundingRectangle.x &&
            (this.viewer.containerLeft + point.x) <= (page.boundingRectangle.x + (page.boundingRectangle.width * this.viewer.zoomFactor))) {
            return true;
        }
        return false;
    };
    /**
     * @private
     */
    Selection.prototype.isCursorInHeaderRegion = function (point, page) {
        var pageTop = this.getPageTop(page);
        var headerHeight = 0;
        var header = page.headerWidget;
        if (header) {
            headerHeight = (header.y + header.height);
        }
        var isEmpty = header.isEmpty && !this.owner.enableHeaderAndFooter;
        var topMargin = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.topMargin);
        var pageHeight = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.pageHeight);
        var height = isEmpty ? topMargin : Math.min(Math.max(headerHeight, topMargin), pageHeight / 100 * 40);
        height = height * this.viewer.zoomFactor;
        if ((this.viewer.containerTop + point.y) >= pageTop && (this.viewer.containerTop + point.y) <= pageTop + height) {
            return true;
        }
        return false;
    };
    /**
     * @private
     */
    Selection.prototype.isCursorInFooterRegion = function (point, page) {
        var pageRect = page.boundingRectangle;
        var pageTop = this.getPageTop(page);
        var pageBottom = pageTop + (pageRect.height * this.viewer.zoomFactor);
        var footerDistance = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.footerDistance);
        var footerHeight = 0;
        if (page.footerWidget) {
            footerHeight = page.footerWidget.height;
        }
        var bottomMargin = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.bottomMargin);
        var isEmpty = page.footerWidget.isEmpty && !this.owner.enableHeaderAndFooter;
        var height = pageRect.height;
        if (isEmpty) {
            height = (height - bottomMargin) * this.viewer.zoomFactor;
        }
        else {
            // tslint:disable-next-line:max-line-length
            height = (height - Math.min(pageRect.height / 100 * 40, Math.max(footerHeight + footerDistance, bottomMargin))) * this.viewer.zoomFactor;
        }
        if ((this.viewer.containerTop + point.y) <= pageBottom && (this.viewer.containerTop + point.y) >= pageTop + height) {
            return true;
        }
        return false;
    };
    /**
     * @private
     */
    Selection.prototype.enableHeadersFootersRegion = function (widget) {
        this.owner.enableHeaderAndFooter = true;
        this.updateTextPositionForBlockContainer(widget);
        this.shiftBlockOnHeaderFooterEnableDisable();
        return true;
    };
    /**
     * @private
     */
    Selection.prototype.shiftBlockOnHeaderFooterEnableDisable = function () {
        for (var i = 0; i < this.viewer.headersFooters.length; i++) {
            var headerFooter = this.viewer.headersFooters[i];
            var sectionFormat = this.getBodyWidgetInternal(i, 0).sectionFormat;
            for (var _i = 0, _a = Object.keys(headerFooter); _i < _a.length; _i++) {
                var key = _a[_i];
                var widget = headerFooter[key];
                if (widget.isEmpty) {
                    this.owner.editor.shiftPageContent(widget.headerFooterType, sectionFormat);
                }
            }
        }
    };
    /**
     * @private
     */
    Selection.prototype.updateTextPositionForBlockContainer = function (widget) {
        var block = widget.firstChild;
        if (block instanceof TableWidget) {
            block = this.getFirstBlockInFirstCell(block);
        }
        this.selectParagraphInternal(block, true);
    };
    /**
     * Disable Header footer
     * @private
     */
    Selection.prototype.disableHeaderFooter = function () {
        var page = this.getPage(this.start.paragraph);
        this.updateTextPositionForBlockContainer(page.bodyWidgets[0]);
        this.owner.enableHeaderAndFooter = false;
        this.shiftBlockOnHeaderFooterEnableDisable();
    };
    //#endregion
    /**
     * @private
     */
    Selection.prototype.destroy = function () {
        if (!isNullOrUndefined(this.contextTypeInternal)) {
            this.contextTypeInternal = undefined;
        }
        if (this.pasteDropDwn) {
            this.pasteDropDwn.destroy();
            this.pasteDropDwn = undefined;
        }
        this.caret = undefined;
        this.contextTypeInternal = undefined;
        this.upDownSelectionLength = undefined;
        this.viewer = undefined;
        this.owner = undefined;
    };
    /**
     * Navigates to the specified bookmark.
     * @param name
     * @param moveToStart
     * @private
     */
    Selection.prototype.navigateBookmark = function (name, moveToStart) {
        var bookmarks = this.viewer.bookmarks;
        if (bookmarks.containsKey(name)) {
            //bookmark start element
            var bookmrkElmnt = bookmarks.get(name);
            var offset = bookmrkElmnt.line.getOffset(bookmrkElmnt, 1);
            var startPosition = new TextPosition(this.viewer.owner);
            startPosition.setPositionParagraph(bookmrkElmnt.line, offset);
            if (moveToStart) {
                this.viewer.selection.selectRange(startPosition, startPosition);
            }
            else {
                //bookmark end element
                var bookmrkEnd = bookmrkElmnt.reference;
                var endoffset = bookmrkEnd.line.getOffset(bookmrkEnd, 0);
                var endPosition = new TextPosition(this.viewer.owner);
                endPosition.setPositionParagraph(bookmrkEnd.line, endoffset);
                //selects the bookmark range
                this.viewer.selection.selectRange(startPosition, endPosition);
            }
        }
    };
    /**
     * Selects the specified bookmark.
     * @param name
     */
    Selection.prototype.selectBookmark = function (name) {
        this.navigateBookmark(name);
    };
    /**
     * Returns the toc field from the selection.
     * @private
     */
    Selection.prototype.getTocField = function () {
        var paragraph = this.start.paragraph;
        var tocPara = undefined;
        while ((paragraph !== undefined && this.isTocStyle(paragraph))) {
            tocPara = paragraph;
            paragraph = paragraph.previousRenderedWidget;
        }
        if (tocPara !== undefined) {
            var lineWidget = tocPara.childWidgets[0];
            if (lineWidget !== undefined) {
                return lineWidget.children[0];
            }
        }
        return undefined;
    };
    /**
     * Returns true if the paragraph has toc style.
     */
    Selection.prototype.isTocStyle = function (paragraph) {
        var style = paragraph.paragraphFormat.baseStyle;
        return (style !== undefined && (style.name.toLowerCase().indexOf('toc') !== -1));
    };
    /**
     * @private
     */
    Selection.prototype.getElementsForward = function (lineWidget, startElement, endElement, bidi) {
        if (isNullOrUndefined(startElement)) {
            return undefined;
        }
        var elements = [];
        while (bidi && startElement && startElement !== endElement && startElement.nextElement && !startElement.isRightToLeft) {
            startElement = startElement.nextElement;
        }
        while (bidi && endElement && startElement !== endElement && endElement.previousElement && !endElement.isRightToLeft) {
            endElement = endElement.previousElement;
        }
        var elementIndex = lineWidget.children.indexOf(startElement);
        while (elementIndex >= 0) {
            for (var i = elementIndex; i > -1 && i < lineWidget.children.length; bidi ? i-- : i++) {
                var inlineElement = lineWidget.children[i];
                if (inlineElement.line === lineWidget) {
                    if (inlineElement === endElement) {
                        elements.push(inlineElement);
                        elementIndex = -1;
                        break;
                    }
                    else {
                        elements.push(inlineElement);
                    }
                }
                else {
                    elementIndex = -1;
                    break;
                }
            }
            // inline = inline !== null && inline.NextNode !== null ? (inline.NextNode as Inline).GetNextRenderedInline() : null;
            elementIndex = -1;
        }
        return elements.length === 0 ? undefined : elements;
    };
    // Gets the current line elements in inline reverse order from the end element.
    /**
     * @private
     */
    Selection.prototype.getElementsBackward = function (lineWidget, startElement, endElement, bidi) {
        var elements = [];
        while (bidi && startElement && startElement.previousElement && (!startElement.isRightToLeft
            || startElement instanceof TextElementBox && this.viewer.textHelper.isRTLText(startElement.text))) {
            startElement = startElement.previousElement;
        }
        var elementIndex = lineWidget.children.indexOf(startElement);
        while (elementIndex >= 0) {
            for (var i = elementIndex; i > -1 && i < lineWidget.children.length; bidi ? i++ : i--) {
                var inlineElement = lineWidget.children[i];
                if (inlineElement.line === lineWidget) {
                    elements.push(inlineElement);
                }
                else {
                    elementIndex = -1;
                    break;
                }
            }
            // inline = inline !== null && inline.NextNode !== null ? (inline.NextNode as Inline).GetNextRenderedInline() : null;
            elementIndex = -1;
        }
        return elements;
    };
    /**
     * Navigate to previous comment in the document.
     */
    Selection.prototype.navigatePreviousComment = function () {
        this.commentNavigateInternal(false);
    };
    /**
     * Navigate to next comment in the document.
     */
    Selection.prototype.navigateNextComment = function () {
        this.commentNavigateInternal(true);
    };
    Selection.prototype.commentNavigateInternal = function (next) {
        if (!this.viewer.currentSelectedComment) {
            if (this.viewer.comments.length === 0) {
                return;
            }
            this.viewer.currentSelectedComment = this.viewer.comments[0];
        }
        if (this.viewer.currentSelectedComment) {
            var comments = this.viewer.comments;
            var comment = this.viewer.currentSelectedComment;
            var index = comments.indexOf(comment);
            if (next) {
                comment = (index === (comments.length - 1)) ? comments[0] : comments[index + 1];
            }
            else {
                comment = index === 0 ? comments[comments.length - 1] : comments[index - 1];
            }
            this.viewer.currentSelectedComment = comment;
            this.selectComment(comment);
        }
    };
    /**
     * @private
     */
    Selection.prototype.selectComment = function (comment) {
        if (!isNullOrUndefined(comment)) {
            var startPosition = this.getElementPosition(comment.commentStart).startPosition;
            var endPosition = this.getElementPosition(comment.commentEnd).startPosition;
            this.selectPosition(startPosition, endPosition);
            if (this.owner.commentReviewPane) {
                this.owner.commentReviewPane.selectComment(comment);
            }
        }
    };
    /**
     * @private
     */
    Selection.prototype.updateEditRangeCollection = function () {
        if (this.editRangeCollection.length > 0) {
            this.editRangeCollection = [];
        }
        var editRangeStart;
        var everyOneArea;
        if (!this.viewer.isDocumentProtected) {
            for (var i = 0; i < this.viewer.editRanges.length; i++) {
                var user = this.viewer.editRanges.keys[i];
                editRangeStart = this.viewer.editRanges.get(user);
                for (var j = 0; j < editRangeStart.length; j++) {
                    this.editRangeCollection.push(editRangeStart[j]);
                }
            }
        }
        else {
            if (this.viewer.editRanges.containsKey(this.owner.currentUser)) {
                editRangeStart = this.viewer.editRanges.get(this.owner.currentUser);
                for (var j = 0; j < editRangeStart.length; j++) {
                    this.editRangeCollection.push(editRangeStart[j]);
                }
            }
            if (this.viewer.editRanges.containsKey('Everyone')) {
                var user = 'Everyone';
                everyOneArea = this.viewer.editRanges.get(user);
                for (var j = 0; j < everyOneArea.length; j++) {
                    this.editRangeCollection.push(everyOneArea[j]);
                }
            }
        }
    };
    //Restrict editing implementation starts
    /**
     * @private
     */
    Selection.prototype.onHighlight = function () {
        if (this.isHighlightEditRegion) {
            this.highlightEditRegion();
        }
        else {
            this.unHighlightEditRegion();
        }
        this.viewer.renderVisiblePages();
    };
    /**
     * @private
     */
    Selection.prototype.highlightEditRegion = function () {
        this.updateEditRangeCollection();
        if (!this.isHighlightEditRegion) {
            this.unHighlightEditRegion();
            return;
        }
        this.isHightlightEditRegionInternal = true;
        if (isNullOrUndefined(this.editRegionHighlighters)) {
            this.editRegionHighlighters = new Dictionary();
        }
        this.editRegionHighlighters.clear();
        for (var j = 0; j < this.editRangeCollection.length; j++) {
            this.highlightEditRegionInternal(this.editRangeCollection[j]);
        }
        this.isHightlightEditRegionInternal = false;
        this.viewer.updateScrollBars();
    };
    /**
     * @private
     */
    Selection.prototype.unHighlightEditRegion = function () {
        if (!isNullOrUndefined(this.editRegionHighlighters)) {
            this.editRegionHighlighters.clear();
            this.editRegionHighlighters = undefined;
        }
        this.isHightlightEditRegionInternal = false;
    };
    /**
     * @private
     */
    Selection.prototype.highlightEditRegionInternal = function (editRangeStart) {
        var positionInfo = this.getPosition(editRangeStart);
        var startPosition = positionInfo.startPosition;
        var endPosition = positionInfo.endPosition;
        // if (editRangeStart.user === this.owner.currentUser && editRangeStart.group === '') {
        this.isCurrentUser = true;
        // }
        this.highlightEditRegions(editRangeStart, startPosition, endPosition);
        this.isCurrentUser = false;
    };
    /**
     * Shows all the editing region, where current user can edit.
     */
    Selection.prototype.showAllEditingRegion = function () {
        if (this.editRangeCollection.length === 0) {
            this.updateEditRangeCollection();
        }
        this.viewer.clearSelectionHighlight();
        for (var j = 0; j < this.editRangeCollection.length; j++) {
            var editRangeStart = this.editRangeCollection[j];
            var positionInfo = this.getPosition(editRangeStart);
            var startPosition = positionInfo.startPosition;
            var endPosition = positionInfo.endPosition;
            this.highlightEditRegions(editRangeStart, startPosition, endPosition);
        }
    };
    Selection.prototype.highlightEditRegions = function (editRangeStart, startPosition, endPosition) {
        if (!editRangeStart.line.paragraph.isInsideTable) {
            this.highlight(editRangeStart.line.paragraph, startPosition, endPosition);
            if (this.isHighlightNext) {
                this.highlightNextBlock(this.hightLightNextParagraph, startPosition, endPosition);
                this.isHighlightNext = false;
                this.hightLightNextParagraph = undefined;
            }
        }
        else {
            var row = editRangeStart.line.paragraph.associatedCell.ownerRow;
            var cell = row.childWidgets[editRangeStart.columnFirst];
            for (var i = 0; i < cell.childWidgets.length; i++) {
                if (cell.childWidgets[i] instanceof ParagraphWidget) {
                    this.highlight(cell.childWidgets[i], startPosition, endPosition);
                    if (this.isHighlightNext) {
                        this.highlightNextBlock(this.hightLightNextParagraph, startPosition, endPosition);
                        this.isHighlightNext = false;
                        this.hightLightNextParagraph = undefined;
                    }
                }
            }
        }
    };
    /**
     * Navigate to next editing region, where current user can edit.
     */
    Selection.prototype.navigateToNextEditingRegion = function () {
        var editRange = this.getEditRangeStartElement();
        //Sort based on position
        for (var i = this.editRangeCollection.length - 1; i >= 0; i--) {
            for (var j = 1; j <= i; j++) {
                var nextPosition = this.getPosition(this.editRangeCollection[j - 1]).startPosition;
                var firstPosition = this.getPosition(this.editRangeCollection[j]).startPosition;
                if (nextPosition.isExistAfter(firstPosition)) {
                    var temp = this.editRangeCollection[j - 1];
                    this.editRangeCollection[j - 1] = this.editRangeCollection[j];
                    this.editRangeCollection[j] = temp;
                }
            }
        }
        var index = this.editRangeCollection.indexOf(editRange);
        var editRangeStart = index < this.editRangeCollection.length - 1 ?
            this.editRangeCollection[index + 1] : this.editRangeCollection[0];
        var positionInfo = this.getPosition(editRangeStart);
        var startPosition = positionInfo.startPosition;
        var endPosition = positionInfo.endPosition;
        this.selectRange(startPosition, endPosition);
    };
    /**
     * Highlight all the editing region, where current user can edit.
     */
    Selection.prototype.toggleEditingRegionHighlight = function () {
        this.isHighlightEditRegion = !this.isHighlightEditRegion;
    };
    /**
     * @private
     */
    Selection.prototype.getEditRangeStartElement = function () {
        for (var i = 0; i < this.editRangeCollection.length; i++) {
            var editStart = this.editRangeCollection[i];
            var position = this.getPosition(editStart);
            var start = position.startPosition;
            var end = position.endPosition;
            if ((this.start.isExistAfter(start) || this.start.isAtSamePosition(start))
                && (this.end.isExistBefore(end) || this.end.isAtSamePosition(end))) {
                return editStart;
            }
        }
        return undefined;
    };
    /**
     * @private
     */
    Selection.prototype.isSelectionIsAtEditRegion = function (update) {
        if (!this.viewer.isDocumentProtected) {
            return false;
        }
        return this.checkSelectionIsAtEditRegion();
    };
    Selection.prototype.checkSelectionIsAtEditRegion = function () {
        for (var i = 0; i < this.editRangeCollection.length; i++) {
            var editRangeStart = this.editRangeCollection[i];
            var positionInfo = this.getPosition(editRangeStart);
            var startPosition = positionInfo.startPosition;
            var endPosition = positionInfo.endPosition;
            var start = this.start;
            var end = this.end;
            if (!this.isForward) {
                start = this.end;
                end = this.start;
            }
            if ((start.isExistAfter(startPosition) || start.isAtSamePosition(startPosition))
                && (end.isExistBefore(endPosition) || end.isAtSamePosition(endPosition))) {
                return true;
            }
        }
        return false;
    };
    Selection.prototype.getPosition = function (element) {
        var offset = element.line.getOffset(element, 1);
        var startPosition = new TextPosition(this.viewer.owner);
        startPosition.setPositionParagraph(element.line, offset);
        var endElement = element.editRangeEnd;
        offset = endElement.line.getOffset(endElement, 1);
        var endPosition = new TextPosition(this.viewer.owner);
        endPosition.setPositionParagraph(endElement.line, offset);
        return { 'startPosition': startPosition, 'endPosition': endPosition };
    };
    /**
     * @private
     */
    Selection.prototype.getElementPosition = function (element) {
        var offset = element.line.getOffset(element, 1);
        var startPosition = new TextPosition(this.viewer.owner);
        startPosition.setPositionParagraph(element.line, offset);
        return { 'startPosition': startPosition, 'endPosition': undefined };
    };
    return Selection;
}());

/**
 * Selection Export
 */

/**
 * @private
 */
var TextSearch = /** @__PURE__ @class */ (function () {
    function TextSearch(owner) {
        this.wordBefore = '\\b';
        this.wordAfter = '\\b';
        this.isHeader = false;
        this.isFooter = false;
        this.owner = owner;
    }
    Object.defineProperty(TextSearch.prototype, "viewer", {
        get: function () {
            return this.owner.viewer;
        },
        enumerable: true,
        configurable: true
    });
    TextSearch.prototype.find = function (pattern, findOption) {
        return this.findNext(pattern, findOption, '0;0;0');
    };
    // tslint:disable-next-line:max-line-length   
    TextSearch.prototype.findNext = function (pattern, findOption, hierarchicalPosition) {
        if (typeof pattern === 'string') {
            pattern = this.stringToRegex(pattern, findOption);
        }
        if (hierarchicalPosition === undefined) {
            hierarchicalPosition = '0;0;0';
        }
        this.owner.searchModule.textSearchResults.clearResults();
        var results = this.owner.searchModule.textSearchResults;
        this.findDocument(results, pattern, true, findOption, hierarchicalPosition);
        return results.length > 0, results.currentSearchResult;
    };
    TextSearch.prototype.stringToRegex = function (textToFind, option) {
        if (textToFind.indexOf('\\') > -1) {
            textToFind = textToFind.split('\\').join('\\\\');
        }
        // tslint:disable-next-line:max-line-length
        if (textToFind.indexOf('(') > -1 || textToFind.indexOf(')') > -1 || textToFind.indexOf('.') > -1 || textToFind.indexOf('[') > -1 || textToFind.indexOf(']') > -1) {
            var text = '';
            for (var i = 0; i < textToFind.length; i++) {
                // tslint:disable-next-line:max-line-length
                if (textToFind[i] === '(' || textToFind[i] === ')' || textToFind[i] === '.' || textToFind[i] === '[' || textToFind[i] === ']') {
                    text += '\\' + textToFind[i];
                }
                else {
                    text += textToFind[i];
                }
            }
            textToFind = text;
        }
        if (option === 'WholeWord' || option === 'CaseSensitiveWholeWord') {
            textToFind = this.wordBefore + textToFind + this.wordAfter;
        }
        return new RegExp(textToFind, (option === 'CaseSensitive' || option === 'CaseSensitiveWholeWord') ? 'g' : 'ig');
    };
    TextSearch.prototype.isPatternEmpty = function (pattern) {
        var wordEmpty = this.wordBefore + this.wordAfter;
        var patternRegExp = pattern.toString();
        return (patternRegExp.length === 0 || patternRegExp === wordEmpty);
    };
    // tslint:disable-next-line:max-line-length     
    TextSearch.prototype.findAll = function (pattern, findOption, hierarchicalPosition) {
        if (typeof pattern === 'string') {
            pattern = this.stringToRegex(pattern, findOption);
        }
        if (hierarchicalPosition === undefined) {
            hierarchicalPosition = '0;0;0';
        }
        this.owner.searchModule.textSearchResults.clearResults();
        var results = this.owner.searchModule.textSearchResults;
        this.findDocument(results, pattern, false, findOption, hierarchicalPosition);
        if (results.length > 0 && results.currentIndex < 0) {
            results.currentIndex = 0;
        }
        if (!isNullOrUndefined(results.currentSearchResult)) {
            var eventArgs = { source: this.viewer.owner };
            this.viewer.owner.trigger('searchResultsChange', eventArgs);
            return results;
        }
        return undefined;
    };
    /**
     * Method to retrieve text from a line widget
     * @param  {ElementBox} inlineElement
     * @param {number} indexInInline
     * @param {boolean} includeNextLine
     * @private
     */
    TextSearch.prototype.getElementInfo = function (inlineElement, indexInInline, includeNextLine) {
        var inlines = inlineElement;
        var stringBuilder = '';
        var spans = new Dictionary();
        //tslint:disable no-constant-condition
        do {
            // tslint:disable-next-line:max-line-length 
            if (inlineElement instanceof TextElementBox && (!isNullOrUndefined(inlineElement.text) && inlineElement.text !== '')) {
                spans.add(inlineElement, stringBuilder.length);
                // IndexInInline Handled specifically for simple find operation to start from starting point
                if (inlineElement === inlines) {
                    stringBuilder = stringBuilder + (inlineElement.text.substring(indexInInline));
                }
                else {
                    stringBuilder = stringBuilder + (inlineElement.text);
                }
            }
            else if (inlineElement instanceof FieldElementBox) {
                var fieldBegin = inlineElement;
                if (!isNullOrUndefined(fieldBegin.fieldEnd)) {
                    // tslint:disable-next-line:max-line-length 
                    inlineElement = isNullOrUndefined(fieldBegin.fieldSeparator) ? fieldBegin.fieldEnd : fieldBegin.fieldSeparator;
                }
            }
            if (!isNullOrUndefined(inlineElement) && isNullOrUndefined(inlineElement.nextNode)) {
                break;
            }
            if (!isNullOrUndefined(inlineElement)) {
                if ((!isNullOrUndefined(includeNextLine) && !includeNextLine)) {
                    var elementBoxes = inlineElement.line.children;
                    var length_1 = inlineElement.line.children.length;
                    if (elementBoxes.indexOf(inlineElement) < length_1 - 1) {
                        inlineElement = inlineElement.nextNode;
                    }
                    else {
                        inlineElement = undefined;
                        break;
                    }
                }
                else {
                    inlineElement = inlineElement.nextNode;
                }
            }
        } while (true);
        var text = stringBuilder.toString();
        return { elementsWithOffset: spans, fullText: text };
    };
    /**
     * Method to update location for matched text
     * @param {RegExpExecArray} matches
     * @param {TextSearchResults} results
     * @param {Dictionary<TextElementBox, number>} textInfo
     * @param {number}indexInInline
     * @param {boolean} isInline
     * @param {boolean}isFirstMatch
     * @param {TextPosition}selectionEnd
     */
    // tslint:disable-next-line:max-line-length
    TextSearch.prototype.updateMatchedTextLocation = function (matches, results, textInfo, indexInInline, inlines, isFirstMatch, selectionEnd, startPosition) {
        for (var i = 0; i < matches.length; i++) {
            var match = matches[i];
            var isMatched = void 0;
            if (!(isNullOrUndefined(startPosition)) && match.index < startPosition) {
                continue;
            }
            var result = results.addResult();
            var spanKeys = textInfo.keys;
            for (var i_1 = 0; i_1 < spanKeys.length; i_1++) {
                var span = spanKeys[i_1];
                var startIndex = textInfo.get(span);
                var spanLength = span.length;
                // IndexInInline Handled specifically for simple find operation to start from starting point
                if (span === inlines) {
                    spanLength -= indexInInline;
                }
                if (isNullOrUndefined(result.start) && match.index < startIndex + spanLength) {
                    var index = match.index - startIndex;
                    // IndexInInline Handled specifically for simple find operation to start from starting point
                    if (span === inlines) {
                        index += indexInInline;
                    }
                    var offset = (span.line).getOffset(span, index);
                    result.start = this.getTextPosition(span.line, offset.toString());
                    result.start.location = this.owner.selection.getPhysicalPositionInternal(span.line, offset, true);
                    result.start.setPositionParagraph(span.line, offset);
                }
                if (match.index + match[0].length <= startIndex + spanLength) {
                    var index = (match.index + match[0].length) - startIndex;
                    // IndexInInline Handled specifically for simple find operation to start from starting point
                    if (span === inlines) {
                        index += indexInInline;
                    }
                    var offset = (span.line).getOffset(span, index);
                    result.end = this.getTextPosition(span.line, offset.toString());
                    result.end.location = this.owner.selection.getPhysicalPositionInternal(span.line, offset, true);
                    result.end.setPositionParagraph(span.line, offset);
                    isMatched = true;
                    break;
                }
            }
            result.isHeader = this.isHeader;
            result.isFooter = this.isFooter;
            if (isFirstMatch) {
                results.currentIndex = 0;
                break;
                // tslint:disable-next-line:max-line-length   
            }
            else if (results.currentIndex < 0 && !isNullOrUndefined(selectionEnd) && (selectionEnd.isExistBefore(result.start) ||
                selectionEnd.isAtSamePosition(result.start))) {
                results.currentIndex = results.indexOf(result);
            }
            if (!isNullOrUndefined(startPosition) && isMatched) {
                break;
            }
        }
    };
    // tslint:disable-next-line:max-line-length     
    TextSearch.prototype.findDocument = function (results, pattern, isFirstMatch, findOption, hierachicalPosition) {
        if (this.isPatternEmpty(pattern)) {
            return;
        }
        if (findOption === undefined) {
            findOption = 'None';
        }
        var inline = undefined;
        var selectionEnd = undefined;
        if (hierachicalPosition !== undefined) {
            selectionEnd = this.owner.selection.end;
        }
        if (hierachicalPosition !== undefined && isFirstMatch && selectionEnd !== undefined && selectionEnd.paragraph !== undefined) {
            if (selectionEnd.paragraph instanceof ParagraphWidget) {
                var indexInInline = 0;
                // tslint:disable-next-line:max-line-length 
                // IndexInInline Handled specifically for simple find operation to start from starting point
                var inlineElement = selectionEnd.currentWidget.getInline(this.owner.selection.start.offset, indexInInline);
                inline = inlineElement.element;
                indexInInline = inlineElement.index;
                if (!isNullOrUndefined(inline)) {
                    var nextParagraphWidget = undefined;
                    // tslint:disable-next-line:max-line-length  
                    nextParagraphWidget = this.findInline(inline, pattern, findOption, indexInInline, isFirstMatch, results, selectionEnd);
                    while (results.length === 0 && !isNullOrUndefined(nextParagraphWidget)) {
                        while (!isNullOrUndefined(nextParagraphWidget) && nextParagraphWidget.childWidgets.length === 0) {
                            // tslint:disable-next-line:max-line-length 
                            nextParagraphWidget = this.owner.selection.getNextParagraph(nextParagraphWidget.containerWidget);
                        }
                        if (isNullOrUndefined(nextParagraphWidget)) {
                            break;
                        }
                        var lineWidget = nextParagraphWidget.childWidgets[0];
                        if (lineWidget.children[0] instanceof ListTextElementBox) {
                            inline = (lineWidget.children[2] instanceof TextElementBox) ? lineWidget.children[2] : undefined;
                        }
                        else {
                            inline = lineWidget.children[0];
                        }
                        if (isNullOrUndefined(inline)) {
                            break;
                        }
                        // tslint:disable-next-line:max-line-length  
                        nextParagraphWidget = this.findInline(inline, pattern, findOption, 0, isFirstMatch, results, selectionEnd);
                    }
                    if (results.length > 0) {
                        return;
                    }
                }
            }
        }
        var section;
        section = this.viewer.pages[0].bodyWidgets[0];
        while (!isNullOrUndefined(section) && section.childWidgets.length === 0) {
            section = section.nextWidget;
        }
        if (isNullOrUndefined(section) || section.childWidgets.length === 0) {
            return;
        }
        this.isHeader = false;
        this.isFooter = false;
        this.findInlineText(section, pattern, findOption, isFirstMatch, results, selectionEnd);
        for (var i = 0; i < this.viewer.pages.length; i++) {
            var headerWidget = this.viewer.pages[i].headerWidget;
            if (!isNullOrUndefined(headerWidget)) {
                this.isHeader = true;
                this.isFooter = false;
                this.findInlineText(headerWidget, pattern, findOption, isFirstMatch, results, selectionEnd);
            }
        }
        for (var i = 0; i < this.viewer.pages.length; i++) {
            var footerWidget = this.viewer.pages[i].footerWidget;
            if (!isNullOrUndefined(footerWidget)) {
                this.isHeader = false;
                this.isFooter = true;
                this.findInlineText(footerWidget, pattern, findOption, isFirstMatch, results, selectionEnd);
            }
        }
        if (isFirstMatch && !isNullOrUndefined(results) && results.length > 0) {
            return;
        }
    };
    // tslint:disable-next-line:max-line-length
    TextSearch.prototype.findInlineText = function (section, pattern, findOption, isFirstMatch, results, selectionEnd) {
        var paragraphWidget = this.owner.selection.getFirstParagraphBlock(section.childWidgets[0]);
        // tslint:disable-next-line:max-line-length 
        while (!isNullOrUndefined(paragraphWidget) && paragraphWidget.childWidgets.length === 1 && paragraphWidget.childWidgets[0].children.length === 0) {
            paragraphWidget = this.owner.selection.getNextParagraphBlock(paragraphWidget);
        }
        while (!isNullOrUndefined(paragraphWidget) && paragraphWidget.childWidgets.length > 0) {
            var inlineElement = paragraphWidget.childWidgets[0];
            var inlineEle = inlineElement.children[0];
            if (isNullOrUndefined(inlineEle)) {
                break;
            }
            this.findInline(inlineEle, pattern, findOption, 0, isFirstMatch, results, selectionEnd);
            paragraphWidget = this.owner.selection.getNextParagraphBlock(paragraphWidget);
            // tslint:disable-next-line:max-line-length 
            while (!isNullOrUndefined(paragraphWidget) && (paragraphWidget.childWidgets.length === 1) && paragraphWidget.childWidgets[0].children.length === 0) {
                paragraphWidget = this.owner.selection.getNextParagraphBlock(paragraphWidget);
            }
        }
        if (isFirstMatch && !isNullOrUndefined(results) && results.length > 0) {
            return;
        }
    };
    // tslint:disable-next-line:max-line-length     
    TextSearch.prototype.findInline = function (inlineElement, pattern, option, indexInInline, isFirstMatch, results, selectionEnd) {
        var inlines = inlineElement;
        var textInfo = this.getElementInfo(inlineElement, indexInInline);
        var text = textInfo.fullText;
        var matches = [];
        var spans = textInfo.elementsWithOffset;
        var matchObject;
        //tslint:disable no-conditional-assignment
        while (!isNullOrUndefined(matchObject = pattern.exec(text))) {
            matches.push(matchObject);
        }
        this.updateMatchedTextLocation(matches, results, spans, indexInInline, inlines, isFirstMatch, selectionEnd);
        if (isFirstMatch) {
            return undefined;
        }
        // tslint:disable-next-line:max-line-length
        var paragraphWidget = this.owner.selection.getNextParagraphBlock(inlineElement.line.paragraph);
        return paragraphWidget;
    };
    /**
     * Method to get text position
     * @param {LineWidget} lineWidget
     * @param {string} hierarchicalIndex
     * @private
     */
    TextSearch.prototype.getTextPosition = function (lineWidget, hierarchicalIndex) {
        var textPosition = new TextPosition(this.owner);
        var index = textPosition.getHierarchicalIndex(lineWidget, hierarchicalIndex);
        textPosition.setPositionForCurrentIndex(index);
        return textPosition;
    };
    return TextSearch;
}());
/**
 * @private
 */
var SearchWidgetInfo = /** @__PURE__ @class */ (function () {
    function SearchWidgetInfo(left, width) {
        this.leftInternal = 0;
        this.widthInternal = 0;
        this.leftInternal = left;
        this.widthInternal = width;
    }
    Object.defineProperty(SearchWidgetInfo.prototype, "left", {
        get: function () {
            return this.leftInternal;
        },
        set: function (value) {
            this.leftInternal = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchWidgetInfo.prototype, "width", {
        get: function () {
            return this.widthInternal;
        },
        set: function (value) {
            this.widthInternal = value;
        },
        enumerable: true,
        configurable: true
    });
    return SearchWidgetInfo;
}());

/**
 * @private
 */
var TextSearchResult = /** @__PURE__ @class */ (function () {
    function TextSearchResult(owner) {
        this.startIn = undefined;
        this.endIn = undefined;
        this.owner = owner;
    }
    Object.defineProperty(TextSearchResult.prototype, "viewer", {
        get: function () {
            return this.owner.viewer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextSearchResult.prototype, "start", {
        get: function () {
            return this.startIn;
        },
        set: function (value) {
            this.startIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextSearchResult.prototype, "end", {
        get: function () {
            return this.endIn;
        },
        set: function (value) {
            this.endIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextSearchResult.prototype, "text", {
        get: function () {
            return this.viewer.selection.getTextInternal(this.start, this.end, false);
        },
        enumerable: true,
        configurable: true
    });
    TextSearchResult.prototype.destroy = function () {
        this.start = undefined;
        this.end = undefined;
    };
    return TextSearchResult;
}());

/**
 * @private
 */
var TextSearchResults = /** @__PURE__ @class */ (function () {
    function TextSearchResults(owner) {
        this.currentIndex = -1;
        this.owner = owner;
    }
    Object.defineProperty(TextSearchResults.prototype, "length", {
        get: function () {
            if (this.innerList === undefined) {
                return 0;
            }
            return this.innerList.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextSearchResults.prototype, "currentSearchResult", {
        get: function () {
            if (this.innerList === undefined || this.currentIndex < 0 || this.currentIndex >= this.length) {
                return undefined;
            }
            return this.innerList[this.currentIndex];
        },
        enumerable: true,
        configurable: true
    });
    TextSearchResults.prototype.addResult = function () {
        var textSearchResult = new TextSearchResult(this.owner);
        if (isNullOrUndefined(this.innerList)) {
            this.innerList = [];
        }
        this.innerList.push(textSearchResult);
        return textSearchResult;
    };
    TextSearchResults.prototype.clearResults = function () {
        this.currentIndex = -1;
        if (!isNullOrUndefined(this.innerList)) {
            for (var i = this.innerList.length - 1; i >= 0; i--) {
                this.innerList[i].destroy();
                this.innerList.splice(i, 1);
            }
        }
    };
    TextSearchResults.prototype.indexOf = function (result) {
        if (isNullOrUndefined(this.innerList)) {
            return -1;
        }
        return this.innerList.indexOf(result);
    };
    TextSearchResults.prototype.destroy = function () {
        if (!isNullOrUndefined(this.innerList)) {
            this.clearResults();
        }
        this.innerList = undefined;
    };
    return TextSearchResults;
}());

/**
 * Search Result info
 */
var SearchResults = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function SearchResults(search) {
        this.searchModule = search;
    }
    Object.defineProperty(SearchResults.prototype, "length", {
        /**
         * Gets the length of search results.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.searchModule.textSearchResults.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchResults.prototype, "index", {
        /**
         * Gets the index of current search result.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return this.searchModule.textSearchResults.currentIndex;
        },
        /**
         * Set the index of current search result.
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (this.length === 0 || value < 0 || value > this.searchModule.textSearchResults.length - 1) {
                return;
            }
            this.searchModule.textSearchResults.currentIndex = value;
            this.navigate(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Replace text in current search result.
     * @param textToReplace text to replace
     * @private
     */
    SearchResults.prototype.replace = function (textToReplace) {
        if (this.index === -1) {
            return;
        }
        this.searchModule.replaceInternal(textToReplace);
    };
    /**
     * Replace all the instance of search result.
     * @param textToReplace text to replace
     */
    SearchResults.prototype.replaceAll = function (textToReplace) {
        if (this.index === -1) {
            return;
        }
        this.searchModule.replaceAllInternal(textToReplace);
    };
    /**
     * @private
     */
    SearchResults.prototype.navigate = function (index) {
        this.searchModule.navigate(this.searchModule.textSearchResults.currentSearchResult);
        this.searchModule.highlight(this.searchModule.textSearchResults);
    };
    /**
     * Clears all the instance of search result.
     */
    SearchResults.prototype.clear = function () {
        this.searchModule.textSearchResults.clearResults();
        this.searchModule.clearSearchHighlight();
        this.searchModule.viewer.renderVisiblePages();
    };
    return SearchResults;
}());

/**
 * Search module
 */
var Search = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function Search(owner) {
        /**
         * @private
         */
        this.searchHighlighters = undefined;
        this.isHandledOddPageHeader = undefined;
        this.isHandledEvenPageHeader = undefined;
        this.isHandledOddPageFooter = undefined;
        this.isHandledEvenPageFooter = undefined;
        this.owner = owner;
        this.searchHighlighters = new Dictionary();
        this.textSearch = new TextSearch(this.owner);
        this.textSearchResults = new TextSearchResults(this.owner);
        this.searchResultsInternal = new SearchResults(this);
    }
    Object.defineProperty(Search.prototype, "viewer", {
        /**
         * @private
         */
        get: function () {
            return this.owner.viewer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Search.prototype, "searchResults", {
        /**
         * Gets the search results object.
         * @aspType SearchResults
         * @blazorType SearchResults
         */
        get: function () {
            return this.searchResultsInternal;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the module name.
     */
    Search.prototype.getModuleName = function () {
        return 'Search';
    };
    //#region Find & Find All
    /**
     * Finds the immediate occurrence of specified text from cursor position in the document.
     * @param  {string} text
     * @param  {FindOption} findOption? - Default value of findOptions parameter is 'None'.
     * @private
     */
    Search.prototype.find = function (text, findOptions) {
        if (isNullOrUndefined(findOptions)) {
            findOptions = 'None';
        }
        var result = this.textSearch.find(text, findOptions);
        if (!isNullOrUndefined(result)) {
            this.navigate(result);
        }
    };
    /**
     * Finds all occurrence of specified text in the document.
     * @param  {string} text
     * @param  {FindOption} findOption? - Default value of findOptions parameter is 'None'.
     */
    Search.prototype.findAll = function (text, findOptions) {
        if (isNullOrUndefined(text || text === '')) {
            return;
        }
        if (isNullOrUndefined(findOptions)) {
            findOptions = 'None';
        }
        var results = this.textSearch.findAll(text, findOptions);
        if (!isNullOrUndefined(results) && results.length > 0) {
            this.navigate(results.innerList[results.currentIndex]);
            this.highlight(results);
        }
    };
    //#endregion
    //#region Replace and Replace All   
    /**
     * Replace the searched string with specified string
     * @param  {string} replaceText
     * @param  {TextSearchResult} result
     * @param  {TextSearchResults} results
     * @private
     */
    Search.prototype.replace = function (replaceText, result, results) {
        if (isNullOrUndefined(this.viewer.owner) || this.viewer.owner.isReadOnlyMode || isNullOrUndefined(results)) {
            return 0;
        }
        if (!isNullOrUndefined(this.viewer)) {
            this.clearSearchHighlight();
        }
        this.navigate(result);
        var endPosition = this.viewer.selection.start;
        var index = results.indexOf(result);
        if (index < 0) {
            return 0;
        }
        this.owner.editorModule.insertTextInternal(replaceText, true);
        var endTextPosition = result.end;
        var startPosition = new TextPosition(this.viewer.owner);
        startPosition.setPositionParagraph(endTextPosition.currentWidget, endPosition.offset - replaceText.length);
        this.viewer.selection.selectRange(endPosition, startPosition);
        var eventArgs = { source: this.viewer.owner };
        this.viewer.owner.trigger('searchResultsChange', eventArgs);
        return 1;
    };
    /**
     * Find the textToFind string in current document and replace the specified string.
     * @param  {string} textToFind
     * @param  {string} textToReplace
     * @param  {FindOption} findOptions? - Default value of findOptions parameter is FindOption.None.
     * @private
     */
    Search.prototype.replaceInternal = function (textToReplace, findOptions) {
        if ((textToReplace === '' || isNullOrUndefined(textToReplace))) {
            return;
        }
        if (isNullOrUndefined(findOptions)) {
            findOptions = 'None';
        }
        var textToFind = this.textSearchResults.currentSearchResult.text;
        var pattern = this.viewer.owner.searchModule.textSearch.stringToRegex(textToFind, findOptions);
        var index = this.owner.selection.end.getHierarchicalIndexInternal();
        var result = this.viewer.owner.searchModule.textSearch.findNext(pattern, findOptions, index);
        if (!isNullOrUndefined(result)) {
            this.navigate(result);
            this.textSearchResults.addResult();
            this.textSearchResults.innerList[0] = result;
            this.replace(textToReplace, result, this.textSearchResults);
            index = this.owner.selection.end.getHierarchicalIndexInternal();
            result = this.textSearch.findNext(textToFind, findOptions, index);
            if (result) {
                this.textSearchResults.addResult();
                this.textSearchResults.innerList[0] = result;
                this.navigate(result);
            }
        }
    };
    /**
     * Replace all the searched string with specified string
     * @param  {string} replaceText
     * @param  {TextSearchResults} results
     * @private
     */
    Search.prototype.replaceAll = function (replaceText, results) {
        if (isNullOrUndefined(this.viewer.owner) || this.viewer.owner.isReadOnlyMode || isNullOrUndefined(results)) {
            return 0;
        }
        if (this.owner.editorHistory) {
            this.owner.editorHistory.initComplexHistory(this.owner.selection, 'ReplaceAll');
        }
        var count = results.length;
        this.viewer.owner.isLayoutEnabled = false;
        for (var i = count - 1; i >= 0; i--) {
            var result = results.innerList[i];
            this.navigate(results.innerList[i]);
            this.owner.editorModule.insertTextInternal(replaceText, true);
            if (result.isHeader || result.isFooter) {
                this.viewer.layout.updateHeaderFooterToParent(this.viewer.selection.start.paragraph.bodyWidget);
            }
            results.innerList[i].destroy();
        }
        if (this.owner.editorHistory && !isNullOrUndefined(this.owner.editorHistory.currentHistoryInfo)) {
            this.owner.editorHistory.updateComplexHistory();
        }
        else {
            this.owner.editorModule.updateComplexWithoutHistory(2);
        }
        this.searchResults.clear();
        return count;
    };
    /**
     * Find the textToFind string in current document and replace the specified string.
     * @param  {string} textToFind
     * @param  {string} textToReplace
     * @param  {FindOption} findOptions? - Default value of findOptions parameter is FindOption.None.
     * @private
     */
    Search.prototype.replaceAllInternal = function (textToReplace, findOptions) {
        if ((textToReplace === '' || isNullOrUndefined(textToReplace))) {
            return;
        }
        if (isNullOrUndefined(findOptions)) {
            findOptions = 'None';
        }
        if (this.textSearchResults.length > 0) {
            this.navigate(this.textSearchResults.innerList[this.textSearchResults.currentIndex]);
            this.highlight(this.textSearchResults);
            this.replaceAll(textToReplace, this.textSearchResults);
        }
    };
    //#endregion
    //#region Highlight Search Result
    /**
     * @private
     */
    Search.prototype.navigate = function (textSearchResult) {
        if (textSearchResult) {
            var start = textSearchResult.start;
            var end = textSearchResult.end;
            if (!isNullOrUndefined(this.owner) && !isNullOrUndefined(this.owner.selection) && !isNullOrUndefined(start) &&
                !isNullOrUndefined(end) && !isNullOrUndefined(start.paragraph) && !isNullOrUndefined(end.paragraph)) {
                this.owner.selection.selectRange(start, end);
            }
        }
    };
    /**
     * @private
     */
    Search.prototype.highlight = function (textSearchResults) {
        this.searchHighlighters = new Dictionary();
        for (var i = 0; i < textSearchResults.innerList.length; i++) {
            var result = textSearchResults.innerList[i];
            this.highlightResult(result);
        }
        this.viewer.renderVisiblePages();
    };
    /**
     * @private
     */
    Search.prototype.highlightResult = function (result) {
        this.highlightSearchResult(result.start.paragraph, result.start, result.end);
    };
    /**
     * Highlight search result
     * @private
     */
    // tslint:disable:max-func-body-length
    Search.prototype.highlightSearchResult = function (paragraph, start, end) {
        var selectionStartIndex = 0;
        var selectionEndIndex = 0;
        var startElement = null;
        var endElement = null;
        // tslint:disable-next-line:max-line-length
        var lineWidget = this.viewer.selection.getStartLineWidget(paragraph, start, startElement, selectionStartIndex);
        selectionStartIndex = lineWidget.index;
        startElement = lineWidget.element;
        var startLineWidget = startElement ? startElement.line : paragraph.childWidgets[0];
        var endLine = this.viewer.selection.getEndLineWidget(end, endElement, selectionEndIndex);
        selectionEndIndex = endLine.index;
        endElement = endLine.element;
        var endLineWidget = endElement ? endElement.line :
            end.paragraph.childWidgets[end.paragraph.childWidgets.length - 1];
        var top = this.viewer.selection.getTop(startLineWidget);
        var left = this.viewer.selection.getLeftInternal(startLineWidget, startElement, selectionStartIndex);
        if (!isNullOrUndefined(startLineWidget) && startLineWidget === endLineWidget) {
            //find result ends in current line.
            var right = this.viewer.selection.getLeftInternal(endLineWidget, endElement, selectionEndIndex);
            var isRtlText = false;
            if (endElement instanceof TextElementBox) {
                isRtlText = endElement.isRightToLeft;
            }
            var width = 0;
            width = Math.abs(right - left);
            if (!isRtlText && startElement instanceof TextElementBox) {
                isRtlText = startElement.isRightToLeft;
            }
            // Handled the highlighting approach as genric for normal and rtl text.
            if (isRtlText || paragraph.bidi) {
                // tslint:disable-next-line:max-line-length
                var elementBox = this.viewer.selection.getElementsForward(startLineWidget, startElement, endElement, paragraph.bidi);
                if (elementBox && elementBox.length > 1) {
                    for (var i = 0; i < elementBox.length; i++) {
                        var element = elementBox[i];
                        var elementIsRTL = false;
                        var index = element instanceof TextElementBox ? element.length : 1;
                        if (element === startElement) {
                            left = this.viewer.selection.getLeftInternal(startLineWidget, element, selectionStartIndex);
                            right = this.viewer.selection.getLeftInternal(startLineWidget, element, index);
                        }
                        else if (element === endElement) {
                            left = this.viewer.selection.getLeftInternal(startLineWidget, element, 0);
                            right = this.viewer.selection.getLeftInternal(startLineWidget, element, selectionEndIndex);
                        }
                        else {
                            left = this.viewer.selection.getLeftInternal(startLineWidget, element, 0);
                            right = this.viewer.selection.getLeftInternal(startLineWidget, element, index);
                        }
                        if (element instanceof TextElementBox) {
                            elementIsRTL = element.isRightToLeft;
                        }
                        width = Math.abs(right - left);
                        this.createHighlightBorder(startLineWidget, width, elementIsRTL ? right : left, top);
                    }
                }
                else {
                    this.createHighlightBorder(startLineWidget, width, isRtlText ? right : left, top);
                }
            }
            else {
                // Start element and end element will be in reverese for Bidi paragraph highlighting. 
                // So, the right is considered based on Bidi property. 
                this.createHighlightBorder(startLineWidget, width, left, top);
            }
        }
        else {
            if (!isNullOrUndefined(startLineWidget)) {
                if (paragraph !== startLineWidget.paragraph) {
                    paragraph = startLineWidget.paragraph;
                }
                var width = this.viewer.selection.getWidth(startLineWidget, true) - (left - startLineWidget.paragraph.x);
                // Handled the  highlighting approach as genric for normal and rtl text.
                if (paragraph.bidi || (startElement instanceof TextElementBox && startElement.isRightToLeft)) {
                    var right = 0;
                    // tslint:disable-next-line:max-line-length
                    var elementCollection = this.viewer.selection.getElementsForward(startLineWidget, startElement, endElement, paragraph.bidi);
                    if (elementCollection) {
                        var elementIsRTL = false;
                        for (var i = 0; i < elementCollection.length; i++) {
                            var element = elementCollection[i];
                            var index = element instanceof TextElementBox ? element.length : 1;
                            right = this.viewer.selection.getLeftInternal(startLineWidget, element, index);
                            elementIsRTL = false;
                            if (element === startElement) {
                                left = this.viewer.selection.getLeftInternal(startLineWidget, element, selectionStartIndex);
                            }
                            else {
                                left = this.viewer.selection.getLeftInternal(startLineWidget, element, 0);
                            }
                            if (element instanceof TextElementBox) {
                                elementIsRTL = element.isRightToLeft;
                            }
                            width = Math.abs(right - left);
                            this.createHighlightBorder(startLineWidget, width, elementIsRTL ? right : left, top);
                        }
                        // Highlight the Paragrph mark for last line.
                    }
                }
                else {
                    this.createHighlightBorder(startLineWidget, width, left, top);
                }
                var lineIndex = startLineWidget.paragraph.childWidgets.indexOf(startLineWidget);
                //Iterates to last item of paragraph or search result end.
                for (var i = 0; i < paragraph.childWidgets.length; i++) {
                    if (paragraph === startLineWidget.paragraph) {
                        lineIndex += 1;
                    }
                    this.highlightSearchResultParaWidget(paragraph, lineIndex, endLineWidget, endElement, selectionEndIndex);
                    if (paragraph === endLineWidget.paragraph) {
                        return;
                    }
                    else {
                        lineIndex = 0;
                    }
                }
            }
        }
    };
    /**
     * @private
     */
    Search.prototype.createHighlightBorder = function (lineWidget, width, left, top) {
        var findHighLight = this.addSearchHighlightBorder(lineWidget);
        var page = this.viewer.owner.selection.getPage(lineWidget.paragraph);
        var pageTop = page.boundingRectangle.y;
        var pageLeft = page.boundingRectangle.x;
        findHighLight.left = Math.ceil(left);
        top = Math.ceil(top);
        findHighLight.width = Math.floor(width);
        var height = Math.floor(lineWidget.height);
        var context = this.viewer.containerContext;
    };
    /**
     * Adds search highlight border.
     * @private
     */
    Search.prototype.addSearchHighlightBorder = function (lineWidget) {
        var highlighters = undefined;
        var collection = this.searchHighlighters;
        if (collection.containsKey(lineWidget)) {
            highlighters = collection.get(lineWidget);
        }
        else {
            highlighters = [];
            collection.add(lineWidget, highlighters);
        }
        var searchHighlight = new SearchWidgetInfo(0, 0);
        highlighters.push(searchHighlight);
        return searchHighlight;
    };
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Search.prototype.highlightSearchResultParaWidget = function (widget, startIndex, endLine, endElement, endIndex) {
        var top = 0;
        var width = 0;
        var isRtlText = false;
        for (var j = startIndex; j < widget.childWidgets.length; j++) {
            var lineWidget = widget.childWidgets[j];
            if (j === startIndex) {
                top = this.viewer.selection.getTop(lineWidget);
            }
            var left = this.viewer.selection.getLeft(lineWidget);
            if (endElement instanceof TextElementBox) {
                isRtlText = endElement.isRightToLeft;
            }
            if (lineWidget === endLine) {
                //Selection ends in current line.
                var right = 0;
                // Handled the highlighting using the element box highlighting approach as genric for normal and rtl text.
                if (isRtlText || widget.bidi) {
                    // tslint:disable-next-line:max-line-length
                    var elementBox = this.viewer.selection.getElementsBackward(lineWidget, endElement, endElement, widget.bidi);
                    for (var i = 0; i < elementBox.length; i++) {
                        var element = elementBox[i];
                        var elementIsRTL = false;
                        left = this.viewer.selection.getLeftInternal(lineWidget, element, 0);
                        if (element === endElement) {
                            right = this.viewer.selection.getLeftInternal(lineWidget, element, endIndex);
                        }
                        else {
                            var index = element instanceof TextElementBox ? element.length : 1;
                            right = this.viewer.selection.getLeftInternal(lineWidget, element, index);
                        }
                        if (element instanceof TextElementBox) {
                            elementIsRTL = element.isRightToLeft;
                        }
                        width = Math.abs(right - left);
                        this.createHighlightBorder(lineWidget, width, elementIsRTL ? right : left, top);
                    }
                    return;
                }
                else {
                    right = this.viewer.selection.getLeftInternal(endLine, endElement, endIndex);
                    width = Math.abs(right - left);
                    this.createHighlightBorder(lineWidget, width, isRtlText ? right : left, top);
                    return;
                }
            }
            else {
                width = this.viewer.selection.getWidth(lineWidget, true) - (left - widget.x);
                this.createHighlightBorder(lineWidget, width, left, top);
                top += lineWidget.height;
            }
        }
    };
    //#endregion
    //#region Get find result view
    /**
     * @private
     */
    Search.prototype.addSearchResultItems = function (result) {
        if (isNullOrUndefined(result) || result === '') {
            return;
        }
        if (isNullOrUndefined(this.owner.findResultsList)) {
            this.owner.findResultsList = [];
        }
        this.owner.findResultsList.push(result);
    };
    /**
     * @private
     */
    Search.prototype.addFindResultView = function (textSearchResults) {
        for (var i = 0; i < textSearchResults.innerList.length; i++) {
            var result = textSearchResults.innerList[i];
            this.addFindResultViewForSearch(result);
        }
        this.isHandledOddPageHeader = true;
        this.isHandledOddPageFooter = true;
        this.isHandledEvenPageHeader = true;
        this.isHandledEvenPageFooter = true;
    };
    /**
     * @private
     */
    // tslint:disable:max-func-body-length
    Search.prototype.addFindResultViewForSearch = function (result) {
        if (result.start != null && result.end != null && result.start.paragraph != null && result.end.paragraph != null) {
            var prefixText = void 0;
            var suffixtext = void 0;
            var currentText = void 0;
            var startIndex = 0;
            var inlineObj = result.start.currentWidget.getInline(result.start.offset, startIndex);
            var inline = inlineObj.element;
            startIndex = inlineObj.index;
            var prefix = '';
            var lastIndex = 0;
            if (inline instanceof FieldElementBox) {
                var elementInfo = this.owner.selection.getRenderedInline(inline, startIndex);
                if (elementInfo.element.nextNode instanceof TextElementBox) {
                    inline = elementInfo.element.nextNode;
                    startIndex = elementInfo.index;
                }
                else {
                    inline = elementInfo.element;
                    startIndex = elementInfo.index;
                }
            }
            var boxObj = this.owner.selection.getElementBoxInternal(inline, startIndex);
            var box = boxObj.element;
            startIndex = boxObj.index;
            if (box != null) {
                if (box instanceof TextElementBox && startIndex > 0) {
                    prefix = box.text.substring(0, startIndex);
                }
                var boxIndex = box.line.children.indexOf(box);
                // tslint:disable-next-line:max-line-length
                lastIndex = prefix.lastIndexOf(' ');
                while (lastIndex < 0 && boxIndex > 0 && box.line.children[boxIndex - 1] instanceof TextElementBox) {
                    prefix = box.line.children[boxIndex - 1].text + prefix;
                    boxIndex--;
                    lastIndex = prefix.lastIndexOf(' ');
                }
            }
            var shiftIndex = prefix.lastIndexOf('\v');
            if (shiftIndex > 0) {
                prefix = prefix.substring(0, shiftIndex);
            }
            else {
                lastIndex = prefix.lastIndexOf(' ');
                prefixText = lastIndex < 0 ? prefix : prefix.substring(lastIndex + 1);
            }
            currentText = result.text;
            var endIndex = 0;
            var endInlineObj = result.end.currentWidget.getInline(result.end.offset, endIndex);
            var endInline = endInlineObj.element;
            endIndex = endInlineObj.index;
            suffixtext = '';
            //Checks prefix element box is empty
            if (boxObj != null) {
                // Gets the element box using endIndex of the text and set as suffix
                boxObj = this.owner.selection.getElementBoxInternal(endInline, endIndex);
                box = boxObj.element;
                endIndex = boxObj.index;
            }
            //Checks suffix element box is empty.
            if (box != null) {
                if (box instanceof TextElementBox && endIndex < box.length) {
                    suffixtext = box.text.substring(endIndex);
                }
                var boxIndex = box.line.children.indexOf(box);
                // tslint:disable-next-line:max-line-length
                while (boxIndex + 1 < box.line.children.length && (box.line.children[boxIndex + 1] instanceof TextElementBox) || (box.line.children[boxIndex + 1] instanceof FieldElementBox)) {
                    if (box.line.children[boxIndex + 1] instanceof FieldElementBox) {
                        boxIndex = boxIndex + 2;
                    }
                    else {
                        suffixtext = suffixtext + box.line.children[boxIndex + 1].text;
                        boxIndex = boxIndex + 1;
                    }
                }
            }
            lastIndex = suffixtext.lastIndexOf(' ');
            suffixtext = suffixtext === '\v' ? suffixtext = '' : suffixtext;
            var headerFooterString = '';
            if (result.isHeader) {
                headerFooterString = '<span class="e-de-header-footer-list">' + 'Header' + ': ' + '</span>';
            }
            else if (result.isFooter) {
                headerFooterString = '<span class="e-de-header-footer-list">' + 'Footer' + ': ' + '</span>';
            }
            else {
                headerFooterString = '';
                headerFooterString = '';
                this.isHandledOddPageHeader = true;
                this.isHandledEvenPageHeader = true;
                this.isHandledOddPageFooter = true;
                this.isHandledEvenPageFooter = true;
            }
            var listElement = '';
            var page = result.viewer.selection.getPage(result.start.paragraph);
            if (isNullOrUndefined(this.isHandledEvenPageHeader) && isNullOrUndefined(this.isHandledEvenPageFooter)) {
                this.isHandledEvenPageHeader = true;
                this.isHandledEvenPageFooter = true;
            }
            else if (isNullOrUndefined(this.isHandledOddPageHeader) && isNullOrUndefined(this.isHandledOddPageFooter)) {
                this.isHandledOddPageHeader = true;
                this.isHandledOddPageFooter = true;
            }
            if (result.isHeader) {
                if (page.headerWidget.headerFooterType === 'FirstPageHeader' && page.bodyWidgets[0].sectionFormat.differentFirstPage) {
                    // tslint:disable-next-line:max-line-length
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                }
                else if (page.headerWidget.headerFooterType === 'EvenHeader' && this.isHandledEvenPageHeader) {
                    // tslint:disable-next-line:max-line-length
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                    this.isHandledEvenPageHeader = false;
                    // tslint:disable-next-line:max-line-length
                }
                else if (page.headerWidget.headerFooterType === 'OddHeader' && this.isHandledOddPageHeader) {
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                    this.isHandledOddPageHeader = false;
                }
            }
            else if (result.isFooter) {
                if (page.footerWidget.headerFooterType === 'FirstPageFooter' && page.bodyWidgets[0].sectionFormat.differentFirstPage) {
                    // tslint:disable-next-line:max-line-length
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                }
                else if (page.footerWidget.headerFooterType === 'EvenFooter' && this.isHandledEvenPageFooter) {
                    // tslint:disable-next-line:max-line-length
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                    this.isHandledEvenPageFooter = false;
                    // tslint:disable-next-line:max-line-length
                }
                else if (page.footerWidget.headerFooterType === 'OddFooter' && this.isHandledOddPageFooter) {
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                    this.isHandledOddPageFooter = false;
                }
                // tslint:disable-next-line:max-line-length
            }
            else if (!result.isHeader && !result.isFooter) {
                listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
            }
            this.addSearchResultItems(listElement);
        }
    };
    //#endregion
    /**
     * Clears search highlight.
     * @private
     */
    Search.prototype.clearSearchHighlight = function () {
        if (!isNullOrUndefined(this.searchHighlighters)) {
            this.searchHighlighters.clear();
            this.searchHighlighters = undefined;
        }
        var eventArgs = { source: this.viewer.owner };
        this.viewer.owner.trigger('searchResultsChange', eventArgs);
    };
    /**
     * @private
     */
    Search.prototype.destroy = function () {
        if (this.textSearchResults) {
            this.textSearchResults.destroy();
        }
    };
    return Search;
}());

/**
 * Options Pane class.
 */
var OptionsPane = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for Options pane module
     * @param {LayoutViewer} layoutViewer
     * @private
     */
    function OptionsPane(layoutViewer) {
        var _this = this;
        /**
         * @private
         */
        this.isOptionsPaneShow = false;
        this.findOption = 'None';
        this.matchCase = undefined;
        this.wholeWord = undefined;
        // private regular: CheckBox = undefined;
        this.searchText = 'Navigation';
        this.resultsText = 'Results';
        this.messageDivText = 'No matches';
        this.replaceButtonText = 'Replace';
        this.replaceAllButtonText = 'Replace All';
        this.focusedIndex = -1;
        this.focusedElement = [];
        this.isOptionsPane = true;
        this.replacePaneText = 'Replace';
        this.findPaneText = 'Find';
        this.matchDivReplaceText = 'No matches';
        /**
         * @private
         */
        this.tabInstance = undefined;
        /**
         * @private
         */
        this.isReplace = false;
        /**
         * Gets selected tab item which tab is selected.
         * @param {SelectEventArgs} args - Specifies which tab will be opened.
         * @private
         */
        this.selectedTabItem = function (args) {
            var contentParent = _this.findTab.getElementsByClassName('e-content').item(0);
            if (args.previousIndex !== args.selectedIndex) {
                var previousTab = contentParent.children[args.previousIndex];
                var nextTab = contentParent.children[args.selectedIndex];
                var element = previousTab.firstElementChild;
                element.parentElement.removeChild(element);
                nextTab.appendChild(element);
            }
            var selectedElement = contentParent.children[args.selectedIndex];
            if (!isNullOrUndefined(selectedElement)) {
                if (args.selectedIndex === 0) {
                    _this.isOptionsPane = true;
                    _this.onFindPane();
                }
                else {
                    _this.isOptionsPane = false;
                    _this.onReplacePane();
                }
            }
        };
        this.searchOptionChange = function () {
            _this.clearSearchResultItems();
            _this.viewer.owner.searchModule.clearSearchHighlight();
            var inputText = _this.searchInput.value;
            if (inputText === '') {
                return;
            }
            var pattern = _this.viewer.owner.searchModule.textSearch.stringToRegex(inputText, _this.findOption);
            var endSelection = _this.viewer.selection.end;
            var selectionIndex = endSelection.getHierarchicalIndexInternal();
            _this.results = _this.viewer.owner.searchModule.textSearch.findAll(pattern, _this.findOption, selectionIndex);
            if (_this.results != null && _this.results.length > 0) {
                _this.navigateSearchResult(false);
            }
            else {
                _this.viewer.renderVisiblePages();
                _this.messageDiv.innerHTML = _this.localeValue.getConstant('No matches');
                _this.resultContainer.style.display = 'block';
                _this.resultsListBlock.style.display = 'none';
                _this.clearFocusElement();
                _this.resultsListBlock.innerHTML = '';
            }
        };
        /**
         * Apply find option based on whole words value.
         * @param {ChangeEventArgs} args - Specifies the search options value.
         * @private
         */
        this.wholeWordsChange = function (args) {
            if (_this.matchInput.checked && _this.wholeInput.checked) {
                _this.findOption = 'CaseSensitiveWholeWord';
            }
            else if (_this.matchInput.checked && !(_this.wholeInput.checked)) {
                _this.findOption = 'CaseSensitive';
            }
            else if (!(_this.matchInput.checked) && _this.wholeInput.checked) {
                _this.findOption = 'WholeWord';
            }
            else {
                _this.findOption = 'None';
            }
            _this.searchOptionChange();
        };
        /**
         * Apply find option based on match value.
         * @param {ChangeEventArgs} args - Specifies the search options value.
         * @private
         */
        this.matchChange = function (args) {
            if (_this.matchInput.checked && _this.wholeInput.checked) {
                _this.findOption = 'CaseSensitiveWholeWord';
            }
            else if (!(_this.matchInput.checked) && _this.wholeInput.checked) {
                _this.findOption = 'WholeWord';
            }
            else if (_this.matchInput.checked && !(_this.wholeInput.checked)) {
                _this.findOption = 'CaseSensitive';
            }
            else {
                _this.findOption = 'None';
            }
            _this.searchOptionChange();
        };
        /**
         * Apply find options based on regular value.
         * @param {ChangeEventArgs} args - Specifies the search options value.
         * @private
         */
        // public regularChange = (args: ChangeEventArgs): void => {
        //     if (args.checked) {
        //         this.matchCase.element.parentElement.parentElement.classList.add('e-checkbox-disabled');
        //         this.wholeWord.element.parentElement.parentElement.classList.add('e-checkbox-disabled');
        //         this.matchCase.checked = false;
        //         this.wholeWord.checked = false;
        //         this.findOption = 'None';
        //         this.onKeyDownInternal();
        //     } else {
        //         this.matchCase.element.parentElement.parentElement.classList.remove('e-checkbox-disabled');
        //         this.wholeWord.element.parentElement.parentElement.classList.remove('e-checkbox-disabled');
        //     }
        // }
        // tslint:enable:no-any 
        /**
         * Binding events from the element when optins pane creation.
         * @private
         */
        this.onWireEvents = function () {
            _this.searchIcon.addEventListener('click', _this.searchIconClickInternal);
            _this.navigateToNextResult.addEventListener('click', _this.navigateNextResultButtonClick);
            _this.navigateToPreviousResult.addEventListener('click', _this.navigatePreviousResultButtonClick);
            _this.searchInput.addEventListener('keydown', _this.onKeyDown);
            _this.searchInput.addEventListener('keyup', _this.onEnableDisableReplaceButton);
            _this.resultsListBlock.addEventListener('click', _this.resultListBlockClick);
            _this.closeButton.addEventListener('click', _this.close);
            _this.replaceButton.addEventListener('click', _this.onReplaceButtonClick);
            _this.replaceAllButton.addEventListener('click', _this.onReplaceAllButtonClick);
        };
        /**
         * Enable find pane only.
         * @private
         */
        this.onFindPane = function () {
            _this.replaceDiv.style.display = 'none';
            _this.occurrenceDiv.style.display = 'none';
            if (!isNullOrUndefined(_this.results) && _this.results.length === 0) {
                _this.resultsListBlock.innerHTML = '';
                _this.resultsListBlock.style.display = 'none';
                _this.messageDiv.innerHTML = _this.localeValue.getConstant('No matches');
            }
            var height = _this.isOptionsPane ? 215 : 292;
            var resultsContainerHeight = _this.viewer.owner.getDocumentEditorElement().offsetHeight - height;
            _this.resultsListBlock.style.height = resultsContainerHeight + 'px';
            _this.replaceTabContentDiv.style.display = 'none';
            _this.findDiv.style.display = 'block';
            _this.messageDiv.style.display = 'block';
            _this.focusedElement = [];
            // tslint:disable-next-line:max-line-length
            _this.focusedElement.push(_this.closeButton, _this.searchInput, _this.searchIcon, _this.navigateToPreviousResult, _this.navigateToNextResult, _this.matchInput, _this.wholeInput);
            _this.focusedIndex = 1;
            _this.searchInput.select();
            _this.getMessageDivHeight();
        };
        this.onEnableDisableReplaceButton = function () {
            if (_this.searchInput.value.length !== 0) {
                _this.replaceButton.disabled = false;
                _this.replaceAllButton.disabled = false;
            }
            else {
                _this.replaceButton.disabled = true;
                _this.replaceAllButton.disabled = true;
            }
        };
        /**
         * Enable replace pane only.
         * @private
         */
        this.onReplacePane = function () {
            _this.findDiv.style.display = 'block';
            _this.replaceDiv.style.display = 'block';
            _this.replaceTabContentDiv.style.display = 'block';
            var height = _this.isOptionsPane ? 215 : 292;
            var resultsContainerHeight = _this.viewer.owner.getDocumentEditorElement().offsetHeight - height;
            _this.resultsListBlock.style.height = resultsContainerHeight + 'px';
            _this.isOptionsPane = false;
            if (_this.searchInput.value.length !== 0) {
                _this.replaceButton.disabled = false;
                _this.replaceAllButton.disabled = false;
            }
            else {
                _this.replaceButton.disabled = true;
                _this.replaceAllButton.disabled = true;
            }
            _this.focusedElement = [];
            // tslint:disable-next-line:max-line-length
            _this.focusedElement.push(_this.closeButton, _this.searchInput, _this.searchIcon, _this.navigateToPreviousResult, _this.navigateToNextResult, _this.matchInput, _this.wholeInput, _this.replaceWith, _this.replaceButton, _this.replaceAllButton);
            _this.focusedIndex = 1;
            if (_this.searchInput.value === '') {
                _this.searchInput.select();
            }
            else {
                _this.replaceWith.select();
            }
            _this.getMessageDivHeight();
        };
        /**
         * Fires on key down on options pane.
         * @param {KeyboardEvent} event - Specifies the focus of current element.
         * @private
         */
        this.onKeyDownOnOptionPane = function (event) {
            // if (event.keyCode === 70) {
            //     event.preventDefault();
            //     return;
            // }
            if (event.keyCode === 9) {
                event.preventDefault();
                var focusIndex = undefined;
                if (event.shiftKey) {
                    focusIndex = (_this.focusedIndex === 0 || isNullOrUndefined(_this.focusedIndex)) ?
                        _this.focusedElement.length - 1 : _this.focusedIndex - 1;
                }
                else {
                    focusIndex = (_this.focusedElement.length - 1 === _this.focusedIndex || isNullOrUndefined(_this.focusedIndex)) ?
                        0 : _this.focusedIndex + 1;
                }
                var element = _this.focusedElement[focusIndex];
                element.focus();
                if (element instanceof HTMLInputElement) {
                    element.select();
                }
                _this.focusedIndex = focusIndex;
                if (element instanceof HTMLLIElement) {
                    _this.scrollToPosition(element);
                }
            }
            else if (event.keyCode === 13) {
                // tslint:disable-next-line:max-line-length
                if (event.target !== _this.searchInput && event.target !== _this.closeButton) {
                    event.preventDefault();
                    var index = _this.focusedElement.indexOf(event.target);
                    if (index !== -1) {
                        var list = _this.focusedElement[index];
                        list.click();
                        list.focus();
                        _this.focusedIndex = index;
                    }
                }
            }
            else if (event.keyCode === 40 || event.keyCode === 38) {
                if (_this.resultsListBlock.style.display !== 'none') {
                    var index = void 0;
                    var element = void 0;
                    if (event.keyCode === 40) {
                        if (_this.focusedIndex > 7) {
                            if (_this.focusedIndex + 1 < _this.focusedElement.length) {
                                element = _this.focusedElement[_this.focusedIndex + 1];
                                element.focus();
                                _this.focusedIndex = _this.focusedIndex + 1;
                            }
                        }
                        else {
                            index = (_this.focusedElement.length - _this.resultsListBlock.children.length) + _this.results.currentIndex + 1;
                            if (index < _this.focusedElement.length) {
                                element = _this.focusedElement[index];
                                element.focus();
                                _this.focusedIndex = index;
                            }
                        }
                    }
                    else {
                        if (_this.focusedIndex > 6) {
                            index = _this.focusedIndex - 1;
                            element = _this.focusedElement[index];
                            element.focus();
                            _this.focusedIndex = index;
                        }
                    }
                }
            }
        };
        /**
         * Fires on replace.
         * @private
         */
        this.onReplaceButtonClick = function () {
            var optionsPane = _this.optionsPane;
            var findText = _this.searchInput.value;
            var replaceText = _this.replaceWith.value;
            var results = _this.viewer.owner.searchModule.textSearchResults;
            if (findText !== '' && !isNullOrUndefined(findText)) {
                if (_this.viewer.owner.selection != null) {
                    var selectionText = _this.viewer.owner.selection.text;
                    if (!_this.viewer.owner.selection.isEmpty) {
                        if (_this.viewer.owner.selection.isForward) {
                            _this.viewer.owner.selection.selectContent(_this.viewer.owner.selection.start, true);
                        }
                        else {
                            _this.viewer.owner.selection.selectContent(_this.viewer.owner.selection.end, true);
                        }
                    }
                    if (!isNullOrUndefined(results) && !isNullOrUndefined(results.currentSearchResult)) {
                        var result = results.currentSearchResult;
                        _this.viewer.owner.searchModule.navigate(result);
                        if (result.text === selectionText) {
                            var replace = isNullOrUndefined(replaceText) ? '' : replaceText;
                            _this.viewer.owner.searchModule.replace(replace, result, results);
                            var pattern = _this.viewer.owner.searchModule.textSearch.stringToRegex(findText, _this.findOption);
                            var endSelection = _this.viewer.selection.end;
                            var index = endSelection.getHierarchicalIndexInternal();
                            // tslint:disable-next-line:max-line-length
                            _this.viewer.owner.searchModule.textSearchResults = _this.viewer.owner.searchModule.textSearch.findAll(pattern, _this.findOption, index);
                            _this.results = _this.viewer.owner.searchModule.textSearchResults;
                            if (!isNullOrUndefined(_this.results) && !isNullOrUndefined(_this.results.currentSearchResult)) {
                                _this.viewer.owner.searchModule.navigate(_this.results.currentSearchResult);
                            }
                            else {
                                _this.messageDiv.style.display = 'block';
                                _this.messageDiv.innerHTML = _this.localeValue.getConstant(_this.matchDivReplaceText);
                            }
                            _this.viewer.owner.findResultsList = [];
                            if (!isNullOrUndefined(_this.results) && _this.results.innerList.length > 0) {
                                _this.navigateSearchResult(true);
                            }
                            else {
                                _this.resultsListBlock.innerHTML = '';
                            }
                        }
                    }
                    else {
                        _this.messageDiv.style.display = 'block';
                        _this.messageDiv.innerHTML = _this.localeValue.getConstant(_this.matchDivReplaceText);
                    }
                }
            }
        };
        /**
         * Fires on replace all.
         * @private
         */
        this.onReplaceAllButtonClick = function () {
            _this.replaceAll();
            _this.resultsListBlock.style.display = 'none';
            _this.messageDiv.innerHTML = '';
        };
        /**
         * Fires on search icon.
         * @private
         */
        this.searchIconClickInternal = function () {
            // tslint:disable:no-any 
            var inputElement = document.getElementById(_this.viewer.owner.containerId + '_option_search_text_box');
            // tslint:enable:no-any
            var text = inputElement.value;
            if (text === '') {
                return;
            }
            if (_this.searchIcon.classList.contains('e-de-op-search-close-icon')) {
                _this.searchIcon.classList.add('e-de-op-search-icon');
                _this.searchIcon.classList.remove('e-de-op-search-close-icon');
                inputElement.value = '';
                _this.messageDiv.innerHTML = _this.localeValue.getConstant('No matches');
                _this.resultContainer.style.display = 'block';
                _this.resultsListBlock.style.display = 'none';
                _this.matchDiv.style.display = 'none';
                _this.occurrenceDiv.style.display = 'none';
                _this.onEnableDisableReplaceButton();
                _this.clearFocusElement();
                _this.resultsListBlock.innerHTML = '';
                _this.clearSearchResultItems();
                _this.viewer.owner.searchModule.clearSearchHighlight();
                _this.viewer.renderVisiblePages();
                return;
            }
            if (_this.searchIcon.classList.contains('e-de-op-search-icon') && text.length >= 1) {
                _this.searchIcon.classList.add('e-de-op-search-close-icon');
                _this.searchIcon.classList.remove('e-de-op-search-icon');
                _this.onEnableDisableReplaceButton();
            }
            _this.clearSearchResultItems();
            _this.viewer.owner.searchModule.clearSearchHighlight();
            var patterns = _this.viewer.owner.searchModule.textSearch.stringToRegex(text, _this.findOption);
            var endSelection = _this.viewer.selection.end;
            var index = endSelection.getHierarchicalIndexInternal();
            _this.results = _this.viewer.owner.searchModule.textSearch.findAll(patterns, _this.findOption, index);
            if (_this.results != null && _this.results.length > 0) {
                var start = _this.results.innerList[_this.results.currentIndex].start;
                var end = _this.results.innerList[_this.results.currentIndex].end;
                _this.viewer.scrollToPosition(start, end, true);
                _this.navigateSearchResult(false);
                _this.getMessageDivHeight();
                var height = _this.isOptionsPane ? 215 : 292;
                var resultsContainerHeight = _this.viewer.owner.getDocumentEditorElement().offsetHeight - height;
                _this.resultsListBlock.style.height = resultsContainerHeight + 'px';
            }
            else {
                _this.messageDiv.innerHTML = _this.localeValue.getConstant('No matches');
                _this.resultContainer.style.display = 'block';
                _this.resultsListBlock.style.display = 'none';
                _this.clearFocusElement();
                _this.resultsListBlock.innerHTML = '';
            }
        };
        /**
         * Fires on getting next results.
         * @private
         */
        this.navigateNextResultButtonClick = function () {
            if (document.getElementById(_this.viewer.owner.containerId + '_list_box_container') != null &&
                document.getElementById(_this.viewer.owner.containerId + '_list_box_container').style.display !== 'none') {
                var selectionEnd = _this.viewer.owner.selection.end;
                var nextResult = void 0;
                var currentIndex = 0;
                if (selectionEnd.isExistAfter(_this.results.currentSearchResult.start)) {
                    currentIndex = _this.results.currentIndex;
                }
                for (var i = currentIndex; i < _this.results.length; i++) {
                    var result = _this.results.innerList[i];
                    if (selectionEnd.isExistBefore(result.start) || selectionEnd.isAtSamePosition(result.start)) {
                        nextResult = result;
                        _this.results.currentIndex = i;
                        break;
                    }
                }
                if (isNullOrUndefined(nextResult)) {
                    _this.results.currentIndex = 0;
                    nextResult = _this.results.innerList[0];
                }
                // tslint:disable-next-line:max-line-length
                _this.messageDiv.innerHTML = _this.localeValue.getConstant('Result') + ' ' + (_this.results.currentIndex + 1) + ' ' + _this.localeValue.getConstant('of') + ' ' + _this.resultsListBlock.children.length;
                _this.updateListItems(nextResult);
                _this.focusedIndex = _this.focusedElement.indexOf(_this.navigateToNextResult);
            }
        };
        /**
         * Fires on getting previous results.
         * @private
         */
        this.navigatePreviousResultButtonClick = function () {
            if (document.getElementById(_this.viewer.owner.containerId + '_list_box_container') != null &&
                document.getElementById(_this.viewer.owner.containerId + '_list_box_container').style.display !== 'none') {
                var previousResult = void 0;
                var selectionStart = _this.viewer.owner.selection.start;
                var currentIndex = _this.results.currentIndex;
                if (selectionStart.isExistAfter(_this.results.currentSearchResult.start)) {
                    currentIndex = _this.results.length - 1;
                }
                for (var i = currentIndex; i >= 0; i--) {
                    var result = _this.results.innerList[i];
                    if (selectionStart.isExistAfter(result.start) || _this.viewer.owner.selection.end.isAtSamePosition(result.start)) {
                        previousResult = result;
                        _this.results.currentIndex = i;
                        break;
                    }
                }
                if (isNullOrUndefined(previousResult)) {
                    _this.results.currentIndex = _this.results.length - 1;
                    previousResult = _this.results.innerList[_this.results.currentIndex];
                }
                // tslint:disable-next-line:max-line-length
                _this.messageDiv.innerHTML = _this.localeValue.getConstant('Result') + ' ' + (_this.results.currentIndex + 1) + ' ' + _this.localeValue.getConstant('of') + ' ' + _this.resultsListBlock.children.length;
                _this.updateListItems(previousResult);
                _this.focusedIndex = _this.focusedElement.indexOf(_this.navigateToPreviousResult);
            }
        };
        /**
         * Fires on key down
         * @param {KeyboardEvent} event - Speficies key down actions.
         * @private
         */
        this.onKeyDown = function (event) {
            var code = event.which || event.keyCode;
            if (code === 13 && event.keyCode !== 9 && event.keyCode !== 40) {
                event.preventDefault();
                _this.findDiv.style.height = '';
                _this.onKeyDownInternal();
            }
            else if (code === 8 && (_this.searchInput.value.length === 0)) {
                _this.resultContainer.style.display = 'block';
            }
            else if (event.keyCode !== 9 && event.keyCode !== 40 && event.keyCode !== 27) {
                _this.viewer.owner.searchModule.clearSearchHighlight();
                _this.clearSearchResultItems();
                _this.viewer.renderVisiblePages();
                _this.resultsListBlock.style.display = 'none';
                _this.messageDiv.innerHTML = _this.localeValue.getConstant('No matches');
                _this.resultContainer.style.display = 'none';
                _this.clearFocusElement();
                _this.resultsListBlock.innerHTML = '';
                if (_this.searchIcon.classList.contains('e-de-op-search-close-icon')) {
                    _this.searchIcon.classList.add('e-de-op-search-icon');
                    _this.searchIcon.classList.remove('e-de-op-search-close-icon');
                }
            }
            else if (code === 27 && event.keyCode === 27) {
                _this.showHideOptionsPane(false);
            }
        };
        /**
         * Close the optios pane.
         * @private
         */
        this.close = function () {
            _this.clearFocusElement();
            _this.showHideOptionsPane(false);
            _this.resultsListBlock.innerHTML = '';
            _this.focusedIndex = 1;
            _this.isOptionsPane = true;
        };
        /**
         * Fires on results list block.
         * @param {MouseEvent} args - Specifies which list was clicked.
         * @private
         */
        this.resultListBlockClick = function (args) {
            var currentlist = args.target;
            var element = _this.resultsListBlock.children;
            var index = 0;
            for (var i = 0; i < element.length; i++) {
                var list_1 = element[i];
                if (list_1.classList.contains('e-de-search-result-hglt')) {
                    list_1.classList.remove('e-de-search-result-hglt');
                    list_1.children[0].classList.remove('e-de-op-search-word-text');
                    list_1.classList.add('e-de-search-result-item');
                }
            }
            var list;
            for (var i = 0; i < element.length; i++) {
                if (currentlist === element[i]) {
                    index = i;
                    list = element[i];
                    if (list.classList.contains('e-de-search-result-item')) {
                        list.classList.remove('e-de-search-result-item');
                        list.classList.add('e-de-search-result-hglt');
                        list.children[0].classList.add('e-de-op-search-word-text');
                        _this.focusedIndex = _this.focusedElement.indexOf(list);
                    }
                }
            }
            var currentelement = _this.results.innerList[index];
            _this.results.currentIndex = index;
            // tslint:disable-next-line:max-line-length
            _this.messageDiv.innerHTML = _this.localeValue.getConstant('Result') + ' ' + (index + 1) + ' ' + _this.localeValue.getConstant('of') + ' ' + _this.resultsListBlock.children.length;
            _this.viewer.owner.searchModule.navigate(currentelement);
            _this.viewer.owner.searchModule.highlight(_this.results);
            if (list) {
                list.focus();
            }
        };
        this.viewer = layoutViewer;
    }
    /**
     * Get the module name.
     */
    OptionsPane.prototype.getModuleName = function () {
        return 'OptionsPane';
    };
    /**
     * Initialize the options pane.
     * @param {L10n} localeValue - Specifies the localization based on culture.
     * @private
     */
    // tslint:disable:max-func-body-length
    OptionsPane.prototype.initOptionsPane = function (localeValue, isRtl) {
        var viewer = this.viewer;
        this.localeValue = localeValue;
        this.optionsPane = createElement('div', { className: 'e-de-op', styles: 'display:none;' });
        this.optionsPane.addEventListener('keydown', this.onKeyDownOnOptionPane);
        this.searchDiv = createElement('div', {
            className: this.viewer.owner.containerId + '_searchDiv e-de-op-header',
            innerHTML: localeValue.getConstant(this.searchText)
        });
        this.optionsPane.appendChild(this.searchDiv);
        // tslint:disable-next-line:max-line-length
        this.closeButton = createElement('button', {
            className: 'e-de-op-close-button e-de-op-icon-btn e-btn e-flat e-icon-btn', id: 'close',
            attrs: { type: 'button' }
        });
        this.optionsPane.appendChild(this.closeButton);
        var closeSpan = createElement('span', { className: 'e-de-op-close-icon e-btn-icon e-icons' });
        this.closeButton.appendChild(closeSpan);
        this.focusedElement.push(this.closeButton);
        this.findTab = createElement('div', { id: this.viewer.owner.containerId + '_findTabDiv', className: 'e-de-op-tab' });
        this.optionsPane.appendChild(this.findTab);
        var tabHeader = createElement('div', { className: 'e-tab-header' });
        this.findTab.appendChild(tabHeader);
        this.findTabButton = createElement('div', { innerHTML: localeValue.getConstant(this.findPaneText) });
        tabHeader.appendChild(this.findTabButton);
        this.replaceTabButton = createElement('div', { innerHTML: localeValue.getConstant(this.replacePaneText) });
        tabHeader.appendChild(this.replaceTabButton);
        var tabContent = createElement('div', { className: 'e-content' });
        var findTabContent = createElement('div', { id: 'findTabContent' });
        tabContent.appendChild(findTabContent);
        this.findTabContentDiv = createElement('div', { className: 'e-de-search-tab-content' });
        this.searchTextBoxContainer = createElement('div', { className: 'e-input-group e-de-op-input-group' });
        this.findTabContentDiv.appendChild(this.searchTextBoxContainer);
        // tslint:disable-next-line:max-line-length
        this.searchInput = createElement('input', { className: 'e-input e-de-search-input', id: this.viewer.owner.containerId + '_option_search_text_box', attrs: { placeholder: localeValue.getConstant('Search for') } });
        this.searchTextBoxContainer.appendChild(this.searchInput);
        this.searchIcon = createElement('span', {
            className: 'e-de-op-icon e-de-op-search-icon e-input-group-icon e-icon',
            id: this.viewer.owner.containerId + '_search-icon'
        });
        this.searchIcon.tabIndex = 0;
        this.searchTextBoxContainer.appendChild(this.searchIcon);
        this.focusedElement.push(this.searchIcon);
        // tslint:disable-next-line:max-line-length
        this.navigateToPreviousResult = createElement('span', { className: 'e-de-op-icon e-de-op-nav-btn e-arrow-up e-spin-up e-btn-icon e-icon e-input-group-icon' });
        this.navigateToPreviousResult.tabIndex = 0;
        this.searchTextBoxContainer.appendChild(this.navigateToPreviousResult);
        this.focusedElement.push(this.navigateToPreviousResult);
        // tslint:disable-next-line:max-line-length
        this.navigateToNextResult = createElement('span', { className: 'e-de-op-icon e-de-op-nav-btn e-arrow-down e-spin-down e-btn-icon e-icon e-input-group-icon' });
        this.navigateToNextResult.tabIndex = 0;
        this.searchTextBoxContainer.appendChild(this.navigateToNextResult);
        this.focusedElement.push(this.navigateToNextResult);
        var div = createElement('div', { className: 'e-de-op-more-less' });
        this.matchInput = createElement('input', {
            attrs: { type: 'checkbox' },
            id: this.viewer.owner.containerId + '_matchCase'
        });
        div.appendChild(this.matchInput);
        // tslint:disable-next-line:max-line-length
        this.matchCase = new CheckBox({ label: localeValue.getConstant('Match case'), enableRtl: isRtl, checked: false, change: this.matchChange });
        this.matchCase.appendTo(this.matchInput);
        this.focusedElement.push(this.matchInput);
        this.matchInput.tabIndex = 0;
        var wholeWordLabel;
        if (isRtl) {
            wholeWordLabel = '_e-de-rtl';
        }
        else {
            wholeWordLabel = '_e-de-ltr';
        }
        this.wholeInput = createElement('input', {
            attrs: { type: 'checkbox' },
            id: this.viewer.owner.containerId + '_wholeWord' + wholeWordLabel
        });
        div.appendChild(this.wholeInput);
        // tslint:disable-next-line:max-line-length
        this.wholeWord = new CheckBox({ label: localeValue.getConstant('Whole words'), enableRtl: isRtl, checked: false, change: this.wholeWordsChange });
        this.wholeWord.appendTo(this.wholeInput);
        this.focusedElement.push(this.wholeInput);
        this.wholeInput.tabIndex = 0;
        this.findTabContentDiv.appendChild(div);
        var replaceTabContent = createElement('div');
        tabContent.appendChild(replaceTabContent);
        this.replaceTabContentDiv = createElement('div', { className: 'e-de-op-replacetabcontentdiv', styles: 'display:none;' });
        tabContent.appendChild(this.replaceTabContentDiv);
        this.findTabContentDiv.appendChild(this.replaceTabContentDiv);
        this.createReplacePane(isRtl);
        this.findDiv = createElement('div', { className: 'findDiv', styles: 'display:block;' });
        findTabContent.appendChild(this.findTabContentDiv);
        this.resultContainer = createElement('div', { styles: 'width:85%;display:block;', className: 'e-de-op-result-container' });
        this.findDiv.appendChild(this.resultContainer);
        // tslint:disable-next-line:max-line-length
        this.messageDiv = createElement('div', { className: this.viewer.owner.containerId + '_messageDiv e-de-op-msg', innerHTML: this.localeValue.getConstant(this.messageDivText), id: this.viewer.owner.containerId + '_search_status' });
        this.resultContainer.appendChild(this.messageDiv);
        // tslint:disable-next-line:max-line-length
        this.resultsListBlock = createElement('div', { id: this.viewer.owner.containerId + '_list_box_container', styles: 'display:none;width:270px;list-style:none;padding-right:5px;overflow:auto;', className: 'e-de-result-list-block' });
        this.findDiv.appendChild(this.resultsListBlock);
        this.findTabContentDiv.appendChild(this.findDiv);
        this.findTab.appendChild(tabContent);
        this.tabInstance = new Tab({ enableRtl: isRtl, selected: this.selectedTabItem });
        this.tabInstance.appendTo(this.findTab);
        this.onWireEvents();
        if (isRtl) {
            this.optionsPane.classList.add('e-de-rtl');
            this.closeButton.classList.add('e-de-rtl');
            this.searchDiv.classList.add('e-de-rtl');
        }
    };
    /**
     * Create replace pane instances.
     */
    OptionsPane.prototype.createReplacePane = function (isRtl) {
        this.replaceDiv = createElement('div');
        this.replaceTabContentDiv.appendChild(this.replaceDiv);
        this.replaceWith = createElement('input', {
            className: 'e-de-op-replacewith e-input',
            attrs: { placeholder: this.localeValue.getConstant('Replace with') }
        });
        this.replaceDiv.appendChild(this.replaceWith);
        var replaceButtonDivTextAlign;
        var replaceButtonMargin;
        if (isRtl) {
            replaceButtonDivTextAlign = 'text-align:left';
            replaceButtonMargin = 'margin-left:10px';
        }
        else {
            replaceButtonDivTextAlign = 'text-align:right';
            replaceButtonMargin = 'margin-right:10px';
        }
        var replaceButtonDiv = createElement('div', { styles: replaceButtonDivTextAlign, className: 'e-de-op-dlg-footer' });
        this.replaceDiv.appendChild(replaceButtonDiv);
        this.replaceButton = createElement('button', {
            className: 'e-control e-btn e-flat e-replace',
            styles: replaceButtonMargin,
            innerHTML: this.localeValue.getConstant(this.replaceButtonText),
            attrs: { type: 'button' }
        });
        replaceButtonDiv.appendChild(this.replaceButton);
        this.replaceAllButton = createElement('button', {
            className: 'e-control e-btn e-flat e-replaceall',
            innerHTML: this.localeValue.getConstant(this.replaceAllButtonText),
            attrs: { type: 'button' }
        });
        replaceButtonDiv.appendChild(this.replaceAllButton);
        this.matchDiv = createElement('div', { styles: 'display:none;padding-top:10px;' });
        this.replaceDiv.appendChild(this.matchDiv);
        var emptyDiv6 = createElement('div', { className: 'e-de-op-search-replacediv' });
        this.replaceDiv.appendChild(emptyDiv6);
        this.occurrenceDiv = createElement('div', { styles: 'display:none;' });
        this.replaceDiv.appendChild(this.occurrenceDiv);
    };
    OptionsPane.prototype.navigateSearchResult = function (navigate) {
        if (navigate) {
            this.viewer.owner.searchModule.navigate(this.results.innerList[this.results.currentIndex]);
        }
        this.viewer.owner.searchModule.highlight(this.results);
        this.viewer.owner.searchModule.addFindResultView(this.results);
        this.resultsListBlock.style.display = 'block';
        this.resultContainer.style.display = 'block';
        var lists = this.viewer.owner.findResultsList;
        var text = '';
        for (var i = 0; i < lists.length; i++) {
            text += lists[i];
        }
        this.clearFocusElement();
        this.resultsListBlock.innerHTML = text;
        for (var i = 0; i < this.resultsListBlock.children.length; i++) {
            this.focusedElement.push(this.resultsListBlock.children[i]);
        }
        var currentIndexValue = this.results.currentIndex;
        // tslint:disable-next-line:max-line-length
        this.messageDiv.innerHTML = this.localeValue.getConstant('Result') + ' ' + (currentIndexValue + 1) + ' ' + this.localeValue.getConstant('of') + ' ' + this.resultsListBlock.children.length;
        var listElement = this.resultsListBlock.children[currentIndexValue];
        if (listElement.classList.contains('e-de-search-result-item')) {
            listElement.classList.remove('e-de-search-result-item');
            listElement.classList.add('e-de-search-result-hglt');
            listElement.children[0].classList.add('e-de-op-search-word-text');
            this.scrollToPosition(listElement);
        }
    };
    /**
     * Fires on key down actions done.
     * @private
     */
    OptionsPane.prototype.onKeyDownInternal = function () {
        // tslint:disable-next-line:max-line-length
        var inputElement = document.getElementById(this.viewer.owner.containerId + '_option_search_text_box');
        inputElement.blur();
        var text = inputElement.value;
        if (text === '') {
            return;
        }
        if (text.length >= 1 && this.searchIcon.classList.contains('e-de-op-search-icon')) {
            this.searchIcon.classList.add('e-de-op-search-close-icon');
            this.searchIcon.classList.remove('e-de-op-search-icon');
        }
        var height = this.isOptionsPane ? 215 : 292;
        var resultsContainerHeight = this.viewer.owner.getDocumentEditorElement().offsetHeight - height;
        this.clearSearchResultItems();
        this.viewer.owner.searchModule.clearSearchHighlight();
        var pattern = this.viewer.owner.searchModule.textSearch.stringToRegex(text, this.findOption);
        var endSelection = this.viewer.selection.end;
        var index = endSelection.getHierarchicalIndexInternal();
        this.results = this.viewer.owner.searchModule.textSearch.findAll(pattern, this.findOption, index);
        var results = this.results;
        if (isNullOrUndefined(results)) {
            this.viewer.renderVisiblePages();
        }
        if (results != null && results.length > 0) {
            if ((this.focusedElement.indexOf(this.navigateToPreviousResult) === -1) && this.isOptionsPane) {
                this.focusedElement.push(this.navigateToPreviousResult);
            }
            if ((this.focusedElement.indexOf(this.navigateToNextResult) === -1) && this.isOptionsPane) {
                this.focusedElement.push(this.navigateToNextResult);
            }
            this.viewer.owner.searchModule.navigate(this.results.innerList[this.results.currentIndex]);
            this.viewer.owner.searchModule.highlight(results);
            this.viewer.owner.searchModule.addFindResultView(results);
            // if (this.isOptionsPane) {
            this.resultsListBlock.style.display = 'block';
            this.resultsListBlock.style.height = resultsContainerHeight + 'px';
            this.resultContainer.style.display = 'block';
            var list = this.viewer.owner.findResultsList;
            var text_1 = '';
            this.clearFocusElement();
            this.resultsListBlock.innerHTML = '';
            for (var i = 0; i < list.length; i++) {
                text_1 += list[i];
            }
            this.resultsListBlock.innerHTML = text_1;
            for (var i = 0; i < this.resultsListBlock.children.length; i++) {
                this.focusedElement.push(this.resultsListBlock.children[i]);
            }
            var lists = this.resultsListBlock.children;
            var currentIndex = this.results.currentIndex;
            // tslint:disable-next-line:max-line-length
            this.messageDiv.innerHTML = this.localeValue.getConstant('Result') + ' ' + (currentIndex + 1) + ' ' + this.localeValue.getConstant('of') + ' ' + this.resultsListBlock.children.length;
            var listElement = this.resultsListBlock.children[currentIndex];
            if (listElement.classList.contains('e-de-search-result-item')) {
                listElement.classList.remove('e-de-search-result-item');
                listElement.classList.add('e-de-search-result-hglt');
                listElement.children[0].classList.add('e-de-op-search-word-text');
            }
            this.navigateToNextResult.focus();
            this.focusedIndex = this.focusedElement.indexOf(this.navigateToNextResult);
            this.getMessageDivHeight();
            // } else {
            //this.focusedIndex = 4;
            // }
        }
        else {
            this.messageDiv.innerHTML = this.localeValue.getConstant('No matches');
            this.resultContainer.style.display = 'block';
            this.resultsListBlock.style.display = 'none';
            this.clearFocusElement();
            this.resultsListBlock.innerHTML = '';
        }
    };
    OptionsPane.prototype.getMessageDivHeight = function () {
        if (!this.isOptionsPane && this.messageDiv.classList.contains('e-de-op-msg')) {
            this.messageDiv.classList.add('e-de-op-replace-messagediv');
            this.messageDiv.classList.remove('e-de-op-msg');
        }
        else if (this.isOptionsPane && this.messageDiv.classList.contains('e-de-op-replace-messagediv')) {
            this.messageDiv.classList.add('e-de-op-msg');
            this.messageDiv.classList.remove('e-de-op-replace-messagediv');
        }
    };
    /**
     * Replace all.
     * @private
     */
    OptionsPane.prototype.replaceAll = function () {
        var optionsPane = this.optionsPane;
        var findText = this.searchInput.value;
        var replaceText = this.replaceWith.value;
        if (findText !== '' && !isNullOrUndefined(findText)) {
            var pattern = this.viewer.owner.searchModule.textSearch.stringToRegex(findText, this.findOption);
            var endSelection = this.viewer.selection.end;
            var index = endSelection.getHierarchicalIndexInternal();
            var results = this.viewer.owner.searchModule.textSearch.findAll(pattern, this.findOption, index);
            var replace = isNullOrUndefined(replaceText) ? '' : replaceText;
            var count = isNullOrUndefined(results) ? 0 : results.length;
            this.viewer.owner.searchModule.replaceAll(replace, results);
            this.matchDiv.style.display = 'block';
            this.matchDiv.innerHTML = this.localeValue.getConstant('All Done') + '!';
            this.occurrenceDiv.style.display = 'block';
            // tslint:disable-next-line:max-line-length
            this.occurrenceDiv.innerHTML = this.localeValue.getConstant('We replaced all') + ' ' + count + ' ' + this.localeValue.getConstant('instances') + ' ' + this.localeValue.getConstant('of') + ' "' + findText + '" ' + this.localeValue.getConstant('with') + ' "' + replaceText + '" ';
        }
    };
    OptionsPane.prototype.updateListItems = function (textSearchResult) {
        var searchElements = this.resultsListBlock.getElementsByClassName('e-de-search-result-hglt');
        for (var j = 0; j < searchElements.length; j++) {
            var list = searchElements[j];
            classList(list, ['e-de-search-result-item'], ['e-de-search-result-hglt']);
            classList(list.children[0], [], ['e-de-op-search-word-text']);
        }
        var listElement = this.resultsListBlock.children[this.results.currentIndex];
        classList(listElement, ['e-de-search-result-hglt'], ['e-de-search-result-item']);
        classList(listElement.children[0], ['e-de-op-search-word-text'], []);
        this.scrollToPosition(listElement);
        this.viewer.owner.searchModule.navigate(textSearchResult);
        this.viewer.owner.searchModule.highlight(this.results);
    };
    /**
     * Scrolls to position.
     * @param {HTMLElement} list - Specifies the list element.
     * @private
     */
    OptionsPane.prototype.scrollToPosition = function (list) {
        var rect = list.getBoundingClientRect();
        var top;
        if (rect.top > 0) {
            top = rect.top - list.parentElement.getBoundingClientRect().top;
            if ((list.parentElement.offsetHeight - top) <= list.offsetHeight) {
                if (Math.ceil(top + list.offsetHeight) === list.parentElement.scrollHeight) {
                    list.parentElement.scrollTop = top;
                }
                list.parentElement.scrollTop = list.parentElement.scrollTop + (list.parentElement.offsetHeight / 100) * 30;
            }
            else if (top < 0) {
                list.parentElement.scrollTop = list.parentElement.scrollTop - (list.parentElement.offsetHeight / 100) * 30;
            }
        }
        else {
            list.parentElement.scrollTop = 0;
        }
    };
    /**
     * Clear the focus elements.
     * @private
     */
    OptionsPane.prototype.clearFocusElement = function () {
        for (var i = 0; i < this.resultsListBlock.children.length; i++) {
            var index = this.focusedElement.indexOf(this.resultsListBlock.children[i]);
            if (index !== -1) {
                this.focusedElement.splice(index, 1);
            }
        }
        this.focusedIndex = 1;
    };
    /**
     * Show or hide option pane based on boolean value.
     * @param {boolean} show - Specifies showing or hiding the options pane.
     * @private
     */
    OptionsPane.prototype.showHideOptionsPane = function (show) {
        if (!isNullOrUndefined(this.viewer.owner.selectionModule)) {
            if (show) {
                this.localeValue = new L10n('documenteditor', this.viewer.owner.defaultLocale);
                this.localeValue.setLocale(this.viewer.owner.locale);
                if (isNullOrUndefined(this.optionsPane)) {
                    this.initOptionsPane(this.localeValue, this.viewer.owner.enableRtl);
                    //Add Option Pane
                    var isRtl = this.viewer.owner.enableRtl;
                    var optionsPaneContainerStyle = void 0;
                    if (isRtl) {
                        optionsPaneContainerStyle = 'display:inline-flex;direction:rtl;';
                    }
                    else {
                        optionsPaneContainerStyle = 'display:inline-flex;';
                    }
                    this.viewer.optionsPaneContainer.setAttribute('style', optionsPaneContainerStyle);
                    // tslint:disable-next-line:max-line-length
                    this.viewer.optionsPaneContainer.insertBefore(this.viewer.owner.optionsPaneModule.optionsPane, this.viewer.viewerContainer);
                }
                this.optionsPane.style.display = 'block';
                if (this.viewer.owner.isReadOnlyMode) {
                    this.tabInstance.hideTab(1);
                }
                else {
                    this.tabInstance.hideTab(1, false);
                }
                if (this.isReplace && !this.viewer.owner.isReadOnlyMode) {
                    this.tabInstance.select(1);
                    this.isReplace = false;
                    this.isOptionsPane = false;
                }
                else {
                    this.tabInstance.select(0);
                }
                this.searchDiv.innerHTML = this.localeValue.getConstant(this.searchText);
                this.isOptionsPaneShow = true;
                // tslint:disable-next-line:max-line-length
                var textBox = document.getElementById(this.viewer.owner.getDocumentEditorElement().id + '_option_search_text_box');
                var selectedText = this.viewer.owner.selection.text;
                if (!isNullOrUndefined(selectedText)) {
                    var char = ['\v', '\r'];
                    var index = HelperMethods.indexOfAny(selectedText, char);
                    selectedText = index < 0 ? selectedText : selectedText.substring(0, index);
                }
                textBox.value = selectedText;
                textBox.select();
                this.messageDiv.innerHTML = '';
                if (this.searchIcon.classList.contains('e-de-op-search-close-icon')) {
                    this.searchIcon.classList.add('e-de-op-search-icon');
                    this.searchIcon.classList.remove('e-de-op-search-close-icon');
                }
                this.viewer.selection.caret.style.display = 'none';
                this.focusedIndex = 1;
                this.focusedElement = [];
                if (this.isOptionsPane) {
                    // tslint:disable-next-line:max-line-length
                    this.focusedElement.push(this.closeButton, this.searchInput, this.searchIcon, this.navigateToPreviousResult, this.navigateToNextResult, this.matchInput, this.wholeInput);
                }
                else {
                    // tslint:disable-next-line:max-line-length
                    this.focusedElement.push(this.closeButton, this.searchInput, this.searchIcon, this.navigateToPreviousResult, this.navigateToNextResult, this.matchInput, this.wholeInput, this.replaceWith, this.replaceButton, this.replaceAllButton);
                }
                this.viewer.updateViewerSize();
            }
            else {
                if (!isNullOrUndefined(this.optionsPane)) {
                    this.clearSearchResultItems();
                    this.viewer.owner.searchModule.clearSearchHighlight();
                    this.isOptionsPaneShow = false;
                    var resultListBox = document.getElementById(this.viewer.owner.containerId + '_list_box_container');
                    var message = document.getElementById(this.viewer.owner.containerId + '_search_status');
                    if (!isNullOrUndefined(resultListBox) && !isNullOrUndefined(message)) {
                        resultListBox.style.display = 'none';
                        this.clearFocusElement();
                        resultListBox.innerHTML = '';
                        message.innerHTML = this.localeValue.getConstant('No matches');
                    }
                }
                this.viewer.updateViewerSize();
                if (!isNullOrUndefined(this.optionsPane)) {
                    if (this.optionsPane.style.display !== 'none') {
                        this.viewer.selection.updateCaretPosition();
                        this.optionsPane.style.display = 'none';
                    }
                }
                this.viewer.updateFocus();
                this.viewer.selection.caret.style.display = 'block';
            }
        }
    };
    /**
     * Clears search results.
     * @private
     */
    OptionsPane.prototype.clearSearchResultItems = function () {
        if (!isNullOrUndefined(this.viewer.owner.findResultsList)) {
            this.viewer.owner.findResultsList = [];
        }
    };
    /**
     * Dispose the internal objects which are maintained.
     * @private
     */
    OptionsPane.prototype.destroy = function () {
        if (this.optionsPane) {
            this.optionsPane.innerHTML = '';
            this.optionsPane = undefined;
        }
        if (this.resultsListBlock) {
            this.resultsListBlock.innerHTML = '';
            this.resultsListBlock = undefined;
        }
        if (this.messageDiv) {
            this.messageDiv.innerHTML = '';
            this.messageDiv = undefined;
        }
        if (this.resultContainer) {
            this.resultContainer.innerHTML = '';
        }
        this.resultContainer = undefined;
        if (this.searchInput) {
            this.searchInput.value = '';
            this.searchInput = undefined;
        }
        if (this.searchDiv) {
            this.searchDiv.innerHTML = '';
            this.searchDiv = undefined;
        }
        if (this.searchTextBoxContainer) {
            this.searchTextBoxContainer.innerHTML = '';
            this.searchTextBoxContainer = undefined;
        }
        if (this.replaceWith) {
            this.replaceWith.innerHTML = '';
            this.replaceWith = undefined;
        }
        if (this.findDiv) {
            this.findDiv.innerHTML = '';
            this.findDiv = undefined;
        }
        if (this.replaceButton) {
            this.replaceButton.innerHTML = '';
            this.replaceButton = undefined;
        }
        if (this.replaceAllButton) {
            this.replaceAllButton.innerHTML = '';
            this.replaceAllButton = undefined;
        }
        if (this.matchInput) {
            this.matchInput.innerHTML = '';
            this.matchCase = undefined;
        }
        if (this.wholeInput) {
            this.wholeInput.innerHTML = '';
            this.wholeWord = undefined;
        }
        // if (this.regularInput) {
        //     this.regularInput.innerHTML = '';
        //     this.regular = undefined;
        // }
        if (!isNullOrUndefined(this.results)) {
            this.results.destroy();
        }
        if (this.focusedElement) {
            this.focusedElement = [];
        }
        this.focusedElement = undefined;
        this.destroyInternal();
    };
    /**
     * Dispose the internal objects which are maintained.
     */
    OptionsPane.prototype.destroyInternal = function () {
        if (this.searchText) {
            this.searchText = undefined;
        }
        if (this.resultsText) {
            this.resultsText = undefined;
        }
        if (this.messageDivText) {
            this.messageDivText = undefined;
        }
        if (this.replaceButtonText) {
            this.replaceButtonText = undefined;
        }
        if (this.replaceAllButtonText) {
            this.replaceAllButtonText = undefined;
        }
    };
    return OptionsPane;
}());

/**
 * Search Export
 */

/**
 * @private
 */
var TableResizer = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function TableResizer(node) {
        this.resizeNode = 0;
        this.resizerPosition = -1;
        this.currentResizingTable = undefined;
        this.owner = node;
        this.startingPoint = new Point(0, 0);
    }
    Object.defineProperty(TableResizer.prototype, "viewer", {
        /**
         * @private
         */
        get: function () {
            return this.owner.viewer;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets module name.
     */
    TableResizer.prototype.getModuleName = function () {
        return 'TableResizer';
    };
    /**
     * @private
     */
    TableResizer.prototype.updateResizingHistory = function (touchPoint) {
        if (this.owner.editorHistory) {
            this.owner.editorHistory.updateResizingHistory(touchPoint, this);
        }
        this.viewer.isRowOrCellResizing = false;
        this.resizerPosition = -1;
    };
    TableResizer.prototype.handleResize = function (point) {
        this.owner.viewer.isRowOrCellResizing = true;
        this.startingPoint.x = point.x;
        this.startingPoint.y = point.y;
        //Initialize resizing history.
        this.owner.editorHistory.initResizingHistory(point, this);
    };
    //Table Resizing implementation starts
    /**
     * @private
     */
    TableResizer.prototype.isInRowResizerArea = function (touchPoint) {
        var position = this.getRowReSizerPosition(undefined, touchPoint);
        if (position === -1) {
            return false;
        }
        else {
            this.resizeNode = 1;
            this.resizerPosition = position;
            return true;
        }
    };
    TableResizer.prototype.isInCellResizerArea = function (touchPoint) {
        var position = this.getCellReSizerPosition(touchPoint);
        if (position === -1) {
            return false;
        }
        else {
            this.resizeNode = 0;
            this.resizerPosition = position;
            return true;
        }
    };
    /**
     * Gets cell resizer position.
     * @param {Point} point
     * @private
     */
    TableResizer.prototype.getCellReSizerPosition = function (touchPoint) {
        var position = -1;
        var resizerBoundaryWidth = 2;
        var tableWidget = this.getTableWidget(touchPoint);
        var cellWidget = this.getTableCellWidget(touchPoint);
        var cellSpacing = isNullOrUndefined(tableWidget) ? 0 : tableWidget.tableFormat.cellSpacing;
        if (tableWidget && cellSpacing > 0) {
            this.currentResizingTable = tableWidget;
            // tslint:disable-next-line:max-line-length
            if (this.viewer.isInsideRect(tableWidget.x - HelperMethods.convertPointToPixel(tableWidget.leftBorderWidth) - 0.25, tableWidget.y, HelperMethods.convertPointToPixel(tableWidget.leftBorderWidth) + 0.5, tableWidget.height, touchPoint)) {
                return position = 0;
            }
            var startingPointX = tableWidget.x;
            for (var i = 0; i < tableWidget.tableHolder.columns.length; i++) {
                var preferredWidth = HelperMethods.convertPointToPixel(tableWidget.tableHolder.columns[i].preferredWidth);
                // tslint:disable-next-line:max-line-length
                if ((this.viewer.isInsideRect(startingPointX - 1, tableWidget.y, tableWidget.leftBorderWidth + resizerBoundaryWidth, tableWidget.height, touchPoint))) {
                    return position = i > 0 ? i : 0;
                    // tslint:disable-next-line:max-line-length
                }
                else if (i > 0 && (this.viewer.isInsideRect(startingPointX + preferredWidth - resizerBoundaryWidth / 2, tableWidget.y, resizerBoundaryWidth, tableWidget.height, touchPoint))) {
                    return position = (i + 1);
                }
                startingPointX = startingPointX + preferredWidth;
            }
        }
        else {
            if (!isNullOrUndefined(cellWidget)) {
                this.currentResizingTable = cellWidget.ownerTable;
                // tslint:disable-next-line:max-line-length
                if (this.viewer.isInsideRect(cellWidget.x - cellWidget.margin.left - resizerBoundaryWidth / 2, cellWidget.y - cellWidget.margin.top, resizerBoundaryWidth, cellWidget.height, touchPoint)) {
                    return position = cellWidget.columnIndex;
                    // tslint:disable-next-line:max-line-length
                }
                else if (isNullOrUndefined(cellWidget.nextRenderedWidget)
                    && this.viewer.isInsideRect(cellWidget.x + cellWidget.margin.right + cellWidget.width - resizerBoundaryWidth / 2, cellWidget.y - cellWidget.margin.top, resizerBoundaryWidth, cellWidget.height, touchPoint)) {
                    return position = (cellWidget.columnIndex + cellWidget.cellFormat.columnSpan);
                }
                else if (cellWidget.childWidgets.length > 0) {
                    return this.getCellReSizerPositionInternal(cellWidget, touchPoint); // Gets the nested table resizer position.
                }
            }
        }
        return position;
    };
    /**
     * Gets cell resizer position.
     * @param {TableCellWidget} cellWidget
     * @param {Point} touchPoint
     */
    TableResizer.prototype.getCellReSizerPositionInternal = function (cellWidget, touchPoint) {
        var position = -1;
        var childTableWidget = this.getTableWidgetFromWidget(touchPoint, cellWidget);
        var childCellWidget = undefined;
        if (!isNullOrUndefined(childTableWidget) && childTableWidget.tableFormat.cellSpacing > 0) {
            this.currentResizingTable = childTableWidget;
            // tslint:disable-next-line:max-line-length
            if (this.viewer.isInsideRect(childTableWidget.x - childTableWidget.leftBorderWidth - 0.25, childTableWidget.y, childTableWidget.leftBorderWidth + 0.5, childTableWidget.height, touchPoint)) {
                return position = 0;
            }
            var startingPointX = childTableWidget.x;
            for (var i = 0; i < childTableWidget.tableHolder.columns.length; i++) {
                // tslint:disable-next-line:max-line-length
                var preferredWidth = HelperMethods.convertPointToPixel(childTableWidget.tableHolder.columns[i].preferredWidth);
                // tslint:disable-next-line:max-line-length
                if ((this.viewer.isInsideRect(startingPointX - 1, childTableWidget.y, childTableWidget.leftBorderWidth + 2, childTableWidget.height, touchPoint))) {
                    return position = i > 0 ? i : 0;
                    // tslint:disable-next-line:max-line-length
                }
                else if (i > 0 && (this.viewer.isInsideRect(startingPointX + preferredWidth - 1, childTableWidget.y, 2, childTableWidget.height, touchPoint))) {
                    return position = (i + 1);
                }
                startingPointX = startingPointX + preferredWidth;
            }
        }
        else {
            if (!isNullOrUndefined(childTableWidget)) {
                childCellWidget = childTableWidget.getTableCellWidget(touchPoint);
            }
            if (!isNullOrUndefined(childCellWidget)) {
                this.currentResizingTable = childCellWidget.ownerTable;
                // tslint:disable-next-line:max-line-length
                if (this.viewer.isInsideRect(childCellWidget.x - childCellWidget.margin.left - 1, childCellWidget.y - childCellWidget.margin.top, 2, childCellWidget.height, touchPoint)) {
                    return position = childCellWidget.columnIndex;
                }
                else if (isNullOrUndefined(childCellWidget.nextRenderedWidget)
                    // tslint:disable-next-line:max-line-length
                    && this.viewer.isInsideRect(childCellWidget.x + childCellWidget.margin.right + childCellWidget.width - 1, childCellWidget.y - childCellWidget.margin.top, 2, childCellWidget.height, touchPoint)) {
                    return position = (childCellWidget.columnIndex + childCellWidget.cellFormat.columnSpan);
                }
                else if (childCellWidget.childWidgets.length > 0) {
                    return this.getCellReSizerPositionInternal(childCellWidget, touchPoint);
                }
            }
        }
        return position;
    };
    TableResizer.prototype.getRowReSizerPosition = function (widget, touchPoint) {
        var tableWidget = undefined;
        var cellWidget = undefined;
        if (isNullOrUndefined(widget)) {
            tableWidget = this.getTableWidget(touchPoint);
            cellWidget = this.getTableCellWidget(touchPoint);
        }
        else {
            tableWidget = this.getTableWidgetFromWidget(touchPoint, widget);
        }
        var cellSpacing = isNullOrUndefined(tableWidget) ? 0 : tableWidget.tableFormat.cellSpacing;
        if (tableWidget && cellSpacing > 0) {
            this.currentResizingTable = tableWidget;
            // tslint:disable-next-line:max-line-length
            if (this.owner.viewer.isInsideRect(tableWidget.x, tableWidget.y + tableWidget.height - cellSpacing, this.getActualWidth(tableWidget.lastChild), (isNullOrUndefined(tableWidget.nextSplitWidget) ? tableWidget.bottomBorderWidth + cellSpacing : 0), touchPoint)) {
                return tableWidget.lastChild.rowIndex;
            }
            for (var i = 0; i < tableWidget.childWidgets.length; i++) {
                //Need to consider for splitted widgets
                var rowWidget = tableWidget.childWidgets[i];
                if (tableWidget.childWidgets.indexOf(rowWidget) > -1
                    // tslint:disable-next-line:max-line-length
                    && (this.owner.viewer.isInsideRect(rowWidget.x, rowWidget.y + rowWidget.height + cellSpacing / 2, this.getActualWidth(rowWidget), cellSpacing / 2, touchPoint))) {
                    return rowWidget.rowIndex;
                }
            }
        }
        else {
            if (tableWidget && cellWidget) {
                cellWidget = this.getTableCellWidget(touchPoint);
            }
            if (cellWidget) {
                var rowWidget = cellWidget.containerWidget;
                var height = 0;
                if (rowWidget.rowIndex === rowWidget.ownerTable.childWidgets.length - 1) {
                    height = rowWidget.bottomBorderWidth + 2;
                }
                else {
                    height = rowWidget.nextRenderedWidget.topBorderWidth + 2;
                }
                // tslint:disable-next-line:max-line-length
                if (this.owner.viewer.isInsideRect(rowWidget.x, rowWidget.y + rowWidget.height - height, rowWidget.width, height * 2, touchPoint)) {
                    this.currentResizingTable = rowWidget.ownerTable;
                    return rowWidget.rowIndex;
                }
                else {
                    if (cellWidget.childWidgets.length > 0) {
                        return this.getRowReSizerPosition(cellWidget, touchPoint);
                    }
                }
            }
        }
        return -1;
    };
    /**
     * To handle Table Row and cell resize
     * @param touchPoint
     * @private
     */
    TableResizer.prototype.handleResizing = function (touchPoint) {
        var dragValue = 0;
        if (this.resizeNode === 0) {
            dragValue = touchPoint.x - this.startingPoint.x;
            this.resizeTableCellColumn(dragValue);
        }
        else {
            dragValue = touchPoint.y - this.startingPoint.y;
            this.resizeTableRow(dragValue);
        }
    };
    TableResizer.prototype.resizeTableRow = function (dragValue) {
        var table = this.currentResizingTable;
        if (isNullOrUndefined(table) || dragValue === 0 || this.resizerPosition === -1) {
            return;
        }
        var selection = this.owner.selection;
        if (table.isInsideTable) {
            this.owner.isLayoutEnabled = false; //Layouting is disabled to skip the child table layouting. 
        }
        var row = undefined;
        if (this.resizerPosition > -1) {
            row = table.childWidgets[this.resizerPosition];
            if (row) {
                this.updateRowHeight(row, dragValue);
            }
            selection.selectPosition(selection.start, selection.end);
        }
        if (table.isInsideTable) {
            var parentTable = this.owner.viewer.layout.getParentTable(table);
            this.owner.isLayoutEnabled = true; //layouting is enabled to layout the parent table of the nested table.
            table = parentTable;
        }
        this.startingPoint.y += HelperMethods.convertPointToPixel(dragValue);
        this.owner.viewer.layout.reLayoutTable(table);
        this.owner.editorModule.reLayout(this.owner.selection);
        if (row) {
            this.currentResizingTable = row.ownerTable;
        }
        if (this.currentResizingTable.childWidgets === undefined
            || this.currentResizingTable.childWidgets[this.resizerPosition] === undefined) {
            this.resizerPosition = -1;
        }
    };
    /**
     * Gets the table widget from given cursor point
     * @param cursorPoint
     */
    TableResizer.prototype.getTableWidget = function (cursorPoint) {
        var widget = undefined;
        var currentPage = this.owner.viewer.currentPage;
        if (!isNullOrUndefined(currentPage)) {
            for (var i = 0; i < currentPage.bodyWidgets.length; i++) {
                var bodyWidget = currentPage.bodyWidgets[i];
                widget = this.getTableWidgetFromWidget(cursorPoint, bodyWidget);
                if (!isNullOrUndefined(widget)) {
                    break;
                }
            }
        }
        return widget;
    };
    TableResizer.prototype.getTableWidgetFromWidget = function (point, widget) {
        for (var j = 0; j < widget.childWidgets.length; j++) {
            if (widget.childWidgets[j] instanceof TableWidget) {
                var childWidget = widget.childWidgets[j];
                if (childWidget.y <= point.y && (childWidget.y + childWidget.height) >= point.y) {
                    return childWidget;
                }
            }
        }
        return undefined;
    };
    /**
     * Return the table cell widget from the given cursor point
     * @param cursorPoint
     * @private
     */
    TableResizer.prototype.getTableCellWidget = function (cursorPoint) {
        var widget = undefined;
        var currentPage = this.owner.viewer.currentPage;
        if (!isNullOrUndefined(currentPage)) {
            for (var i = 0; i < currentPage.bodyWidgets.length; i++) {
                var bodyWidget = currentPage.bodyWidgets[i];
                widget = bodyWidget.getTableCellWidget(cursorPoint);
                if (!isNullOrUndefined(widget)) {
                    break;
                }
            }
        }
        return widget;
    };
    TableResizer.prototype.updateRowHeight = function (row, dragValue) {
        var rowFormat = row.rowFormat;
        if (rowFormat.heightType === 'Auto') {
            rowFormat.heightType = 'AtLeast';
            var row_1 = rowFormat.ownerBase;
            var currentHeight = this.owner.viewer.layout.getRowHeight(row_1, [row_1]);
            //the minimum height of the Row in MS word is 2.7 points which is equal to 3.6 pixel.
            if (currentHeight + dragValue >= 2.7 && rowFormat.height !== currentHeight + dragValue) {
                rowFormat.height = currentHeight + dragValue;
            }
        }
        else {
            //the minimum height of the Row in MS word is 2.7 points which is equal to 3.6 pixel.
            if (rowFormat.height + dragValue >= 2.7 && rowFormat.height !== rowFormat.height + dragValue) {
                rowFormat.height = rowFormat.height + dragValue;
            }
        }
    };
    //Resize Table cell
    TableResizer.prototype.resizeTableCellColumn = function (dragValue) {
        var table = this.currentResizingTable;
        if (isNullOrUndefined(table) || dragValue === 0 || isNullOrUndefined(table.childWidgets) || this.resizerPosition < 0) {
            return;
        }
        var selectionFlag = true;
        var selection = this.owner.selection;
        this.owner.editor.setOffsetValue(selection);
        table = table.combineWidget(this.viewer);
        this.owner.isLayoutEnabled = false;
        // table.PreserveGrid = true;
        this.setPreferredWidth(table);
        var containerWidth = table.getOwnerWidth(true);
        var newIndent = table.leftIndent;
        var tableAlignment = table.tableFormat.tableAlignment;
        if (!selection.isEmpty) {
            selectionFlag = this.resizeColumnWithSelection(selection, table, dragValue);
        }
        if (!selectionFlag) {
            this.owner.isLayoutEnabled = true;
            return;
        }
        if (this.resizerPosition === 0) {
            // Todo: need to handle the resizing of first column and table indent.
            var columnIndex = this.resizerPosition;
            var rightColumn = table.tableHolder.columns[columnIndex];
            var width = rightColumn.preferredWidth;
            if (dragValue > 0) {
                var prevDragValue = dragValue;
                do {
                    var newWidth = HelperMethods.round(rightColumn.preferredWidth - dragValue, 1);
                    if (newWidth >= rightColumn.minWidth) {
                        rightColumn.preferredWidth = newWidth;
                        newIndent = table.leftIndent + dragValue;
                        newIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                        break;
                    }
                    else {
                        prevDragValue = dragValue;
                        dragValue += newWidth - rightColumn.minWidth;
                    }
                } while (dragValue !== prevDragValue);
            }
            else {
                var prevDragValue = dragValue;
                do {
                    var newWidth = HelperMethods.round(rightColumn.preferredWidth - dragValue, 1);
                    if (newWidth <= 2112) {
                        rightColumn.preferredWidth = newWidth;
                        newIndent = table.leftIndent + dragValue;
                        newIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                        break;
                    }
                    else {
                        prevDragValue = dragValue;
                        dragValue -= newWidth - 2112;
                    }
                } while (dragValue !== prevDragValue);
            }
            var dragOffset = dragValue;
            // tslint:disable-next-line:max-line-length
            if (tableAlignment !== 'Left' && (table.tableHolder.getTotalWidth(0) > containerWidth) && table.tableFormat.preferredWidthType === 'Auto') {
                if (table.tableHolder.isFitColumns(containerWidth, table.tableHolder.tableWidth, table.tableFormat.preferredWidthType === 'Auto')) {
                    // tslint:disable-next-line:max-line-length
                    table.tableHolder.fitColumns(containerWidth, table.tableHolder.tableWidth, table.tableFormat.preferredWidthType === 'Auto');
                }
                else {
                    rightColumn.preferredWidth = width;
                }
                dragOffset = 0;
            }
            if (tableAlignment === 'Center'
                && (table.tableHolder.getTotalWidth(0) < containerWidth || table.tableFormat.preferredWidthType !== 'Auto')) {
                dragOffset = dragOffset / 2;
            }
            table.tableFormat.leftIndent = tableAlignment === 'Left' ? newIndent : 0;
            table.tableHolder.tableWidth = table.tableHolder.getTotalWidth(0);
            this.updateCellPreferredWidths(table);
            this.updateGridValue(table, true, dragOffset);
        }
        else if (table !== null && this.resizerPosition === table.tableHolder.columns.length) {
            // Todo: need to handle the resizing of last column and table width.
            this.resizeColumnAtLastColumnIndex(table, dragValue, containerWidth);
        }
        else {
            if (this.resizerPosition === -1) {
                this.owner.isLayoutEnabled = true;
                return;
            }
            this.resizeCellAtMiddle(table, dragValue);
        }
        // table.PreserveGrid = false;
        this.owner.isLayoutEnabled = true;
        selection.selectPosition(selection.start, selection.end);
    };
    /**
     * Resize Selected Cells
     */
    TableResizer.prototype.resizeColumnWithSelection = function (selection, table, dragValue) {
        var newIndent = table.leftIndent;
        var cellwidget = this.getTableCellWidget(this.startingPoint);
        if (cellwidget && (selection.selectedWidgets.containsKey(cellwidget) || (cellwidget.previousWidget
            && selection.selectedWidgets.containsKey((cellwidget.previousWidget))))) {
            var selectedCells = selection.getSelectedCells();
            if (this.resizerPosition === 0) {
                this.resizeColumnAtStart(table, dragValue, selectedCells);
            }
            else if (table !== null && this.resizerPosition === table.tableHolder.columns.length) {
                var leftColumnCollection = this.getColumnCells(table, this.resizerPosition, true);
                for (var i = 0; i < leftColumnCollection.length; i++) {
                    var cell = leftColumnCollection[i];
                    if (selectedCells.indexOf(cell) !== -1) {
                        this.increaseOrDecreaseWidth(cell, dragValue, true);
                    }
                }
                //Updates the grid after value for all the rows.
                this.updateRowsGridAfterWidth(table);
                table.updateWidth(dragValue);
                table.tableFormat.allowAutoFit = false;
                this.updateGridValue(table, true, dragValue);
            }
            else {
                if (this.resizerPosition === -1) {
                    return false;
                }
                var columnIndex = this.resizerPosition;
                var leftColumnCollection = this.getColumnCells(table, columnIndex, true);
                var rightColumnCollection = this.getColumnCells(table, columnIndex, false);
                var isColumnResizing = this.isColumnSelected(table, columnIndex);
                if (leftColumnCollection.length > 0 && !isColumnResizing) {
                    for (var i = 0; i < leftColumnCollection.length; i++) {
                        if (selectedCells.indexOf(leftColumnCollection[i]) === -1) {
                            leftColumnCollection.splice(i, 1);
                            i--;
                        }
                    }
                }
                if (rightColumnCollection.length > 0 && !isColumnResizing) {
                    for (var i = 0; i < rightColumnCollection.length; i++) {
                        if (selectedCells.indexOf(rightColumnCollection[i]) === -1) {
                            rightColumnCollection.splice(i, 1);
                            i--;
                        }
                    }
                }
                //Getting the adjacent cell collections for left side selected cells in the right column collection.
                if (leftColumnCollection.length === 0 && rightColumnCollection.length > 0) {
                    for (var i = 0; i < rightColumnCollection.length; i++) {
                        var cell = rightColumnCollection[i];
                        if (cell.previousWidget) {
                            leftColumnCollection.push(cell.previousWidget);
                        }
                    }
                }
                else if (rightColumnCollection.length === 0 && leftColumnCollection.length > 0) {
                    for (var i = 0; i < leftColumnCollection.length; i++) {
                        var cell = leftColumnCollection[i];
                        if (cell.nextWidget) {
                            rightColumnCollection.push(cell.nextWidget);
                        }
                    }
                }
                this.changeWidthOfCells(table, leftColumnCollection, rightColumnCollection, dragValue, true);
                if (table.tableFormat.allowAutoFit) {
                    table.updateWidth(dragValue);
                }
                table.tableFormat.allowAutoFit = false;
                this.updateGridValue(table, true, dragValue);
            }
            selection.selectPosition(selection.start, selection.end);
        }
        return false;
    };
    /**
     * Resize selected cells at resizer position 0
     */
    TableResizer.prototype.resizeColumnAtStart = function (table, dragValue, selectedCells) {
        var newIndent = table.leftIndent;
        var rightColumnCollection = this.getColumnCells(table, this.resizerPosition, false);
        var offset = 0;
        var selectedRow = selectedCells[0].ownerRow;
        var rowFormat = selectedRow.rowFormat;
        if (rowFormat.beforeWidth > 0) {
            var newGridBefore = rowFormat.beforeWidth + dragValue;
            if (newGridBefore > 0) {
                this.updateGridBefore(selectedRow, dragValue);
            }
            else {
                var leastGridBefore = this.getLeastGridBefore(table, selectedRow);
                if (newGridBefore < leastGridBefore && offset !== newGridBefore) {
                    newIndent = table.leftIndent + newGridBefore;
                    table.tableFormat.leftIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                    for (var i = 0; i < table.childWidgets.length; i++) {
                        var tableRow = table.childWidgets[i];
                        if (selectedRow !== tableRow) {
                            this.updateGridBefore(tableRow, -newGridBefore);
                        }
                    }
                }
            }
        }
        else {
            if (dragValue < 0) {
                newIndent = table.leftIndent + dragValue;
                table.tableFormat.leftIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                this.updateWidthForCells(table, selectedCells, dragValue);
            }
            else {
                var leastGridBefore = this.getLeastGridBefore(table, selectedRow);
                var currentTableIndent = table.tableFormat.leftIndent;
                if (currentTableIndent === 0) {
                    for (var i = 0; i < table.childWidgets.length; i++) {
                        var tableRow = table.childWidgets[i];
                        if (selectedCells.indexOf(tableRow.childWidgets[0]) !== -1) {
                            this.updateGridBefore(tableRow, dragValue);
                            this.increaseOrDecreaseWidth(tableRow.childWidgets[0], dragValue, false);
                        }
                    }
                }
                else {
                    var difference = leastGridBefore - dragValue;
                    if (difference > 0) {
                        newIndent = table.leftIndent + dragValue;
                        table.tableFormat.leftIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                        this.updateWidthForCells(table, selectedCells, dragValue);
                    }
                    else {
                        newIndent = table.leftIndent + leastGridBefore;
                        table.tableFormat.leftIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                        for (var i = 0; i < table.childWidgets.length; i++) {
                            var tableRow = table.childWidgets[i];
                            if (selectedCells.indexOf(tableRow.childWidgets[0]) !== -1) {
                                this.increaseOrDecreaseWidth(tableRow.childWidgets[0], dragValue, false);
                                this.updateGridBefore(tableRow, dragValue - leastGridBefore);
                            }
                            else {
                                this.updateGridBefore(tableRow, -leastGridBefore);
                            }
                        }
                    }
                }
            }
        }
        table.tableFormat.allowAutoFit = false;
        this.updateGridValue(table, true, dragValue);
    };
    TableResizer.prototype.updateWidthForCells = function (table, selectedCells, dragValue) {
        for (var i = 0; i < table.childWidgets.length; i++) {
            var tableRow = table.childWidgets[i];
            if (selectedCells.indexOf(tableRow.childWidgets[0]) !== -1) {
                this.increaseOrDecreaseWidth(tableRow.childWidgets[0], dragValue, false);
            }
            else {
                this.updateGridBefore(tableRow, -dragValue);
            }
        }
    };
    /**
     * Resize selected cells at last column
     */
    TableResizer.prototype.resizeColumnAtLastColumnIndex = function (table, dragValue, containerWidth) {
        var tableAlignment = table.tableFormat.tableAlignment;
        var preferredWidth = table.tableFormat.preferredWidth;
        var hasTableWidth = preferredWidth;
        var columnIndex = this.resizerPosition;
        var leftColumn = table.tableHolder.columns[columnIndex - 1];
        var prevDragValue = 0;
        while (dragValue !== prevDragValue) {
            var newWidth = HelperMethods.round(leftColumn.preferredWidth + dragValue, 1);
            if (newWidth >= leftColumn.minWidth) {
                leftColumn.preferredWidth = newWidth;
                prevDragValue = dragValue;
            }
            else {
                prevDragValue = dragValue;
                dragValue -= newWidth - leftColumn.minWidth;
            }
        }
        this.updateCellPreferredWidths(table);
        if (hasTableWidth || table.tableHolder.getTotalWidth(0) > containerWidth) {
            table.tableFormat.allowAutoFit = false;
            table.updateWidth(dragValue);
            table.tableHolder.tableWidth = table.tableHolder.getTotalWidth(0);
        }
        var dragOffset = dragValue;
        if (tableAlignment === 'Right') {
            dragOffset = 0;
        }
        else if (tableAlignment === 'Center') {
            dragOffset = dragOffset / 2;
        }
        this.updateGridValue(table, true, dragOffset);
    };
    /**
     *  Resize selected cells at middle column
     */
    TableResizer.prototype.resizeCellAtMiddle = function (table, dragValue) {
        var columnIndex = this.resizerPosition;
        var leftColumn = table.tableHolder.columns[columnIndex - 1];
        var rightColumn = table.tableHolder.columns[columnIndex];
        if (dragValue > 0) {
            var isContinue = true;
            while (isContinue) {
                var newWidth = HelperMethods.round(rightColumn.preferredWidth - dragValue, 1);
                if (newWidth >= rightColumn.minWidth) {
                    rightColumn.preferredWidth = newWidth;
                    leftColumn.preferredWidth = leftColumn.preferredWidth + dragValue;
                    isContinue = false;
                }
                else {
                    dragValue += newWidth - rightColumn.minWidth;
                }
            }
        }
        else {
            var isContinue = true;
            while (isContinue) {
                var newWidth = HelperMethods.round(leftColumn.preferredWidth + dragValue, 1);
                if (newWidth >= leftColumn.minWidth) {
                    leftColumn.preferredWidth = newWidth;
                    rightColumn.preferredWidth = rightColumn.preferredWidth - dragValue;
                    isContinue = false;
                }
                else {
                    dragValue -= newWidth - leftColumn.minWidth;
                }
            }
        }
        // Update the cell widths based on the columns preferred width
        this.updateCellPreferredWidths(table);
        if (table.tableFormat.allowAutoFit) {
            table.updateWidth(dragValue);
        }
        table.tableFormat.allowAutoFit = false;
        table.tableHolder.tableWidth = table.tableHolder.getTotalWidth(0);
        this.updateGridValue(table, false, dragValue);
    };
    TableResizer.prototype.updateGridValue = function (table, isUpdate, dragValue) {
        if (isUpdate) {
            table.calculateGrid();
            table.isGridUpdated = false;
        }
        table.buildTableColumns();
        table.isGridUpdated = true;
        this.viewer.owner.isLayoutEnabled = true;
        if (table.isInsideTable) {
            var parentTable = this.viewer.layout.getParentTable(table);
            this.viewer.layout.reLayoutTable(parentTable); // Need to optmize this.
        }
        else {
            this.viewer.layout.reLayoutTable(table);
        }
        this.owner.editor.getOffsetValue(this.viewer.selection);
        this.owner.editorModule.reLayout(this.owner.selection);
        if (dragValue) {
            this.startingPoint.x += HelperMethods.convertPointToPixel(dragValue);
            this.resizerPosition = this.getCellReSizerPosition(this.startingPoint);
        }
    };
    TableResizer.prototype.getColumnCells = function (table, columnIndex, isLeftSideCollection) {
        var cells = [];
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                if (isLeftSideCollection) {
                    if (cell.columnIndex + cell.cellFormat.columnSpan === columnIndex) {
                        cells.push(cell);
                    }
                }
                else {
                    if (cell.columnIndex === columnIndex) {
                        cells.push(cell);
                    }
                }
            }
        }
        return cells;
    };
    TableResizer.prototype.updateGridBefore = function (row, offset) {
        if (row.rowFormat.beforeWidth + offset !== row.rowFormat.beforeWidth) {
            row.rowFormat.beforeWidth = row.rowFormat.beforeWidth + offset;
            row.rowFormat.gridBeforeWidth = row.rowFormat.beforeWidth;
        }
    };
    TableResizer.prototype.getLeastGridBefore = function (table, ignoreRow) {
        var gridBefore = 0;
        var flag = 0;
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            if (row !== ignoreRow) {
                if (flag === 0) {
                    gridBefore = row.rowFormat.beforeWidth;
                    flag++;
                }
                if (row.rowFormat.beforeWidth <= gridBefore) {
                    gridBefore = row.rowFormat.beforeWidth;
                }
            }
        }
        return gridBefore;
    };
    TableResizer.prototype.increaseOrDecreaseWidth = function (cell, dragValue, isIncrease) {
        var preferredWidth = cell.cellFormat.preferredWidth;
        if (cell.cellFormat.preferredWidthType === 'Auto') {
            preferredWidth = cell.cellFormat.cellWidth;
            cell.cellFormat.preferredWidthType = 'Point';
        }
        var minimumWidth = cell.ownerColumn.minWidth;
        if (cell.cellFormat.preferredWidthType === 'Percent') {
            minimumWidth = cell.convertPointToPercent(minimumWidth);
        }
        // Margins properties usedd for internal purpose.
        if (isIncrease) {
            cell.cellFormat.preferredWidth = preferredWidth + dragValue > minimumWidth ? preferredWidth + dragValue : minimumWidth;
        }
        else {
            cell.cellFormat.preferredWidth = preferredWidth - dragValue > minimumWidth ? preferredWidth - dragValue : minimumWidth;
        }
    };
    // tslint:disable-next-line:max-line-length
    TableResizer.prototype.changeWidthOfCells = function (table, leftColumnCollection, rightColumnCollection, dragValue, isSelection) {
        if (leftColumnCollection.length > 0) {
            var flag = false;
            for (var i = 0; i < leftColumnCollection.length; i++) {
                var cell = leftColumnCollection[i];
                this.increaseOrDecreaseWidth(cell, dragValue, true);
                if (cell.cellIndex === cell.ownerRow.childWidgets.length - 1) {
                    flag = true;
                }
            }
            if (flag) {
                this.updateRowsGridAfterWidth(table);
            }
        }
        if (rightColumnCollection.length > 0) {
            var diff = 0;
            for (var i = 0; i < rightColumnCollection.length; i++) {
                var cell = rightColumnCollection[i];
                if (cell.cellIndex === 0) {
                    var newGridBefore = cell.ownerRow.rowFormat.beforeWidth + dragValue;
                    if (newGridBefore >= 0) {
                        this.updateGridBefore(cell.ownerRow, dragValue);
                    }
                    else {
                        if (diff !== newGridBefore) {
                            diff = newGridBefore;
                        }
                        cell.ownerRow.rowFormat.gridBeforeWidth = 0;
                        cell.ownerRow.rowFormat.gridBeforeWidthType = 'Auto';
                    }
                }
                this.increaseOrDecreaseWidth(cell, dragValue, false);
            }
            if (diff !== 0) {
                var newIndent = table.leftIndent + diff;
                table.tableFormat.leftIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                for (var j = 0; j < table.childWidgets.length; j++) {
                    var row = table.childWidgets[j];
                    if (rightColumnCollection.indexOf(row.childWidgets[0]) === -1) {
                        this.updateGridBefore(row, diff > 0 ? diff : -diff);
                    }
                }
            }
        }
    };
    TableResizer.prototype.updateRowsGridAfterWidth = function (table) {
        var maxRowWidth = this.getMaxRowWidth(table, true);
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            var currentRowWidth = this.getRowWidth(row, true);
            if (maxRowWidth >= currentRowWidth && row.rowFormat.afterWidth !== maxRowWidth - currentRowWidth) {
                var value = maxRowWidth - currentRowWidth;
                row.rowFormat.gridAfterWidth = value;
                row.rowFormat.afterWidth = value;
            }
        }
    };
    TableResizer.prototype.getRowWidth = function (row, toUpdateGridAfter) {
        var rowWidth = 0;
        if (toUpdateGridAfter) {
            rowWidth = rowWidth + row.rowFormat.beforeWidth;
        }
        for (var i = 0; i < row.childWidgets.length; i++) {
            var cell = row.childWidgets[i];
            rowWidth += cell.cellFormat.cellWidth;
        }
        return rowWidth;
    };
    TableResizer.prototype.getMaxRowWidth = function (table, toUpdateGridAfter) {
        var width = 0;
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            var rowWidth = 0;
            if (toUpdateGridAfter) {
                rowWidth = rowWidth + row.rowFormat.beforeWidth;
            }
            for (var i_1 = 0; i_1 < row.childWidgets.length; i_1++) {
                var cell = row.childWidgets[i_1];
                rowWidth += cell.cellFormat.cellWidth;
            }
            if (width < rowWidth) {
                width = rowWidth;
            }
        }
        return width;
    };
    TableResizer.prototype.isColumnSelected = function (table, columnIndex) {
        var selection = this.owner.selection;
        var selectedCells = selection.getSelectedCells();
        var leftColumnCells = this.getColumnCells(table, columnIndex, true);
        var rightColumnCells = this.getColumnCells(table, columnIndex, false);
        var isColumnSelected = false;
        for (var i = 0; i < leftColumnCells.length; i++) {
            var columnCell = leftColumnCells[i];
            isColumnSelected = selectedCells.indexOf(columnCell) !== -1 ? true : false;
        }
        if (!isColumnSelected) {
            for (var i = 0; i < rightColumnCells.length; i++) {
                var columnCell = rightColumnCells[i];
                isColumnSelected = selectedCells.indexOf(columnCell) !== -1 ? true : false;
            }
        }
        return isColumnSelected;
    };
    TableResizer.prototype.applyProperties = function (table, tableHistoryInfo) {
        if (isNullOrUndefined(tableHistoryInfo)) {
            return;
        }
        table = table;
        // PreserveGrid = true;
        if (tableHistoryInfo.tableHolder) {
            table.tableHolder = tableHistoryInfo.tableHolder.clone();
        }
        if (tableHistoryInfo.tableFormat !== null) {
            table.tableFormat.leftIndent = tableHistoryInfo.tableFormat.leftIndent;
            table.tableFormat.preferredWidth = tableHistoryInfo.tableFormat.preferredWidth;
            table.tableFormat.preferredWidthType = tableHistoryInfo.tableFormat.preferredWidthType;
            table.tableFormat.allowAutoFit = tableHistoryInfo.tableFormat.allowAutoFit;
        }
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            var rowFormat = tableHistoryInfo.rows[i];
            row.rowFormat.gridBefore = rowFormat.gridBefore;
            row.rowFormat.gridBeforeWidth = rowFormat.gridBeforeWidth;
            row.rowFormat.gridBeforeWidthType = rowFormat.gridBeforeWidthType;
            row.rowFormat.gridAfter = rowFormat.gridAfter;
            row.rowFormat.gridAfterWidth = rowFormat.gridAfterWidth;
            row.rowFormat.gridAfterWidthType = rowFormat.gridAfterWidthType;
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                var cellFormat = rowFormat.cells[j];
                cell.columnIndex = cellFormat.columnIndex;
                cell.cellFormat.columnSpan = cellFormat.columnSpan;
                cell.cellFormat.preferredWidth = cellFormat.preferredWidth;
                cell.cellFormat.preferredWidthType = cellFormat.preferredWidthType;
            }
        }
        var containerWidth = table.getOwnerWidth(true);
        var tableWidth = table.getTableClientWidth(containerWidth);
        //Sets the width to cells
        table.setWidthToCells(tableWidth, table.tableFormat.preferredWidthType === 'Auto');
        // PreserveGrid = false;
    };
    /**
     * Return table row width
     */
    TableResizer.prototype.getActualWidth = function (row) {
        var width = 0;
        if (row.childWidgets.length > 0) {
            for (var i = 0; i < row.childWidgets.length; i++) {
                width += row.childWidgets[i].cellFormat.cellWidth;
            }
        }
        return width;
    };
    TableResizer.prototype.setPreferredWidth = function (table) {
        for (var i = 0; i < table.childWidgets.length; i++) {
            var rw = table.childWidgets[i];
            var rowFormat = rw.rowFormat;
            if (rowFormat.gridBefore > 0) {
                rowFormat.gridBeforeWidth = rowFormat.beforeWidth;
                rowFormat.gridBeforeWidthType = 'Point';
            }
            for (var j = 0; j < rw.childWidgets.length; j++) {
                var cell = rw.childWidgets[j];
                cell.cellFormat.preferredWidth = cell.cellFormat.cellWidth;
                cell.cellFormat.preferredWidthType = 'Point';
            }
            if (rowFormat.gridAfter > 0) {
                rowFormat.gridAfterWidth = rowFormat.afterWidth;
                rowFormat.gridAfterWidthType = 'Point';
            }
        }
    };
    TableResizer.prototype.updateCellPreferredWidths = function (table) {
        var tableWidth = table.tableHolder.tableWidth;
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            if (row.rowFormat.gridBefore > 0) {
                var width = table.tableHolder.getCellWidth(0, row.rowFormat.gridBefore, tableWidth);
                this.updateGridBeforeWidth(width, row);
            }
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                cell.updateWidth(table.tableHolder.getCellWidth(cell.columnIndex, cell.cellFormat.columnSpan, tableWidth));
            }
            if (row.rowFormat.gridAfter > 0) {
                // tslint:disable-next-line:max-line-length
                this.updateGridAfterWidth(table.tableHolder.getCellWidth(row.childWidgets.length, row.rowFormat.gridAfter, tableWidth), row);
            }
        }
    };
    /**
     * Update grid before width value
     */
    TableResizer.prototype.updateGridBeforeWidth = function (width, row) {
        var rowFormat = row.rowFormat;
        if (width !== rowFormat.beforeWidth) {
            rowFormat.beforeWidth = width;
            if (rowFormat.gridBeforeWidthType === 'Auto') {
                rowFormat.gridBeforeWidthType = 'Point';
            }
            if (rowFormat.gridBeforeWidthType === 'Point') {
                rowFormat.gridBeforeWidth = rowFormat.beforeWidth;
            }
            else {
                // The value is calculated from the pixel values hence, its converted to percent using method. 
                var ownerWidth = row.ownerTable.getTableClientWidth(row.ownerTable.getOwnerWidth(true));
                var value = row.ownerTable.convertPointToPercent(rowFormat.beforeWidth, ownerWidth);
                rowFormat.gridBeforeWidth = value;
            }
        }
    };
    /**
     * Update grid after width value
     */
    TableResizer.prototype.updateGridAfterWidth = function (width, row) {
        var rowFormat = row.rowFormat;
        if (width !== rowFormat.afterWidth) {
            rowFormat.afterWidth = width;
        }
        if (rowFormat.gridAfterWidthType === 'Auto') {
            rowFormat.gridAfterWidthType = 'Point';
        }
        if (rowFormat.gridAfterWidthType === 'Point') {
            rowFormat.gridAfterWidth = rowFormat.afterWidth;
        }
        else {
            // The value is calculated from the pixel values hence, its converted to percent using method. 
            var ownerWidth = row.ownerTable.getTableClientWidth(row.ownerTable.getOwnerWidth(true));
            var value = row.ownerTable.convertPointToPercent(rowFormat.afterWidth, ownerWidth);
            rowFormat.gridAfterWidth = value;
        }
    };
    return TableResizer;
}());

/**
 * Editor module
 */
var Editor = /** @__PURE__ @class */ (function () {
    /**
     * Initialize the editor module
     * @param  {LayoutViewer} viewer
     * @private
     */
    function Editor(viewer) {
        var _this = this;
        this.nodes = [];
        this.editHyperlinkInternal = false;
        this.startParagraph = undefined;
        this.endParagraph = undefined;
        this.removeEditRange = false;
        /**
         * @private
         */
        this.isHandledComplex = false;
        /**
         * @private
         */
        this.tableResize = undefined;
        /**
         * @private
         */
        this.tocStyles = {};
        this.refListNumber = undefined;
        this.incrementListNumber = -1;
        this.removedBookmarkElements = [];
        /**
         * @private
         */
        this.tocBookmarkId = 0;
        /**
         * @private
         */
        this.copiedData = undefined;
        this.pageRefFields = {};
        this.delBlockContinue = false;
        this.delBlock = undefined;
        this.delSection = undefined;
        /**
         * @private
         */
        this.isInsertingTOC = false;
        this.editStartRangeCollection = [];
        /* tslint:disable:no-any */
        this.copiedContent = '';
        /* tslint:enable:no-any */
        this.copiedTextContent = '';
        this.pasteTextPosition = undefined;
        this.isSkipHistory = false;
        this.isPaste = false;
        this.isPasteListUpdated = false;
        this.isInsertField = false;
        /**
         * @private
         */
        this.isBordersAndShadingDialog = false;
        /**
         * @private
         */
        this.onTextInputInternal = function (event) {
            if (Browser.isDevice) {
                var viewer = _this.viewer;
                var nbsp = new RegExp(String.fromCharCode(160), 'g');
                var lineFeed = new RegExp(String.fromCharCode(10), 'g');
                viewer.prefix = viewer.prefix.replace(nbsp, ' ').replace(lineFeed, ' ');
                var text = viewer.editableDiv.textContent.replace(nbsp, ' ').replace(lineFeed, ' ');
                var textBoxText = text.substring(2);
                if (viewer.isCompositionStart && viewer.isCompositionUpdated) {
                    viewer.isCompositionUpdated = false;
                    if (!viewer.owner.isReadOnlyMode && viewer.owner.isDocumentLoaded) {
                        if (viewer.prefix.substring(2) !== textBoxText) {
                            if (_this.selection.isEmpty) {
                                // tslint:disable-next-line:max-line-length
                                _this.selection.start.setPositionForLineWidget(viewer.selection.start.currentWidget, _this.selection.start.offset - (viewer.prefix.length - 2));
                                _this.handleTextInput(textBoxText);
                                viewer.prefix = '@' + String.fromCharCode(160) + textBoxText;
                            }
                            else {
                                _this.handleTextInput(textBoxText);
                                viewer.prefix = '@' + String.fromCharCode(160) + textBoxText;
                            }
                        }
                    }
                    return;
                }
                else if (viewer.isCompositionStart && viewer.isCompositionEnd && viewer.suffix === '') {
                    if (viewer.prefix.substring(2) !== textBoxText) {
                        if (_this.selection.isEmpty && viewer.isCompositionStart) {
                            viewer.isCompositionStart = false;
                            // tslint:disable-next-line:max-line-length
                            _this.selection.start.setPositionForLineWidget(viewer.selection.start.currentWidget, _this.selection.start.offset - viewer.prefix.substring(2).length);
                            _this.selection.retrieveCurrentFormatProperties();
                            if (viewer.suffix === '' || textBoxText === '') {
                                _this.handleTextInput(textBoxText);
                            }
                        }
                        else if (!_this.selection.isEmpty) {
                            viewer.isCompositionStart = false;
                            _this.handleTextInput(textBoxText);
                        }
                    }
                    else if (textBoxText === '') {
                        viewer.isCompositionStart = false;
                        _this.handleBackKey();
                    }
                    else if (viewer.prefix.substring(2) === textBoxText && viewer.suffix === '') {
                        viewer.isCompositionStart = false;
                        _this.handleTextInput(' ');
                    }
                    viewer.isCompositionEnd = false;
                    return;
                }
                else if (viewer.isCompositionEnd || viewer.isCompositionStart && !viewer.isCompositionUpdated) {
                    if (textBoxText.length < viewer.prefix.length &&
                        textBoxText === viewer.prefix.substring(2, viewer.prefix.length - 1) || viewer.editableDiv.innerText.length < 2) {
                        _this.handleBackKey();
                        return;
                    }
                    else if (viewer.suffix !== '' &&
                        viewer.editableDiv.innerText[viewer.editableDiv.innerText.length - 1] !== String.fromCharCode(160)) {
                        viewer.isCompositionStart = false;
                        //When cursor is placed in between a word and chosen a word from predicted words.
                        // tslint:disable-next-line:max-line-length
                        _this.selection.start.setPositionForLineWidget(viewer.selection.start.currentWidget, _this.selection.start.offset - (viewer.prefix.length - 2));
                        _this.selection.end.setPositionForLineWidget(viewer.selection.end.currentWidget, _this.selection.end.offset + viewer.suffix.length);
                        //Retrieve the character format properties. Since the selection was changed manually.
                        _this.selection.retrieveCurrentFormatProperties();
                        _this.handleTextInput(textBoxText);
                        return;
                    }
                }
                // tslint:disable-next-line:max-line-length
                if (text !== '\r' && text !== '\b' && text !== '\u001B' && !viewer.owner.isReadOnlyMode && viewer.isControlPressed === false) {
                    if (text === '@' || text[0] !== '@' || text === '' || text.length < viewer.prefix.length &&
                        textBoxText === viewer.prefix.substring(2, viewer.prefix.length - 1)) {
                        _this.handleBackKey();
                        if (viewer.editableDiv.innerText.length < 2) {
                            _this.predictText();
                        }
                    }
                    else if (text.indexOf(viewer.prefix) === 0 && text.length > viewer.prefix.length) {
                        _this.handleTextInput(text.substring(viewer.prefix.length));
                    }
                    else if (text.indexOf(viewer.prefix) === -1 && text[text.length - 1] !== String.fromCharCode(160)
                        && text[text.length - 1] !== ' ') {
                        if ((textBoxText.charAt(0).toLowerCase() + textBoxText.slice(1)) === viewer.prefix.substring(2)) {
                            // tslint:disable-next-line:max-line-length
                            _this.selection.start.setPositionParagraph(viewer.selection.start.currentWidget, _this.selection.start.offset - (viewer.prefix.length - 2));
                        }
                        _this.handleTextInput(textBoxText);
                    }
                    else if (text.length !== 2) {
                        _this.handleTextInput(' ');
                    }
                }
            }
            else {
                var text = _this.viewer.editableDiv.innerText;
                if (text !== String.fromCharCode(160)) {
                    // tslint:disable-next-line:max-line-length
                    if (text !== '\r' && text !== '\b' && text !== '\u001B' && !_this.owner.isReadOnlyMode && _this.viewer.isControlPressed === false) {
                        _this.handleTextInput(text);
                    }
                }
                else {
                    _this.handleTextInput(' ');
                }
                _this.viewer.editableDiv.innerText = '';
            }
        };
        /**
         * Fired on paste.
         * @param {ClipboardEvent} event
         * @private
         */
        this.onPaste = function (event) {
            if (!_this.owner.isReadOnlyMode) {
                _this.pasteInternal(event);
            }
            event.preventDefault();
        };
        this.viewer = viewer;
        this.tableResize = new TableResizer(this.viewer.owner);
        this.base64 = new Base64();
    }
    Object.defineProperty(Editor.prototype, "restrictFormatting", {
        /**
         * @private
         */
        get: function () {
            return this.viewer.isDocumentProtected && (this.viewer.restrictFormatting
                || (!this.viewer.restrictFormatting && !this.selection.isSelectionIsAtEditRegion(false)));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "restrictEditing", {
        /**
         * @private
         */
        get: function () {
            return this.viewer.isDocumentProtected && this.viewer.protectionType === 'ReadOnly'
                && !this.selection.isSelectionIsAtEditRegion(false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "editorHistory", {
        get: function () {
            return this.viewer.owner.editorHistory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "selection", {
        get: function () {
            if (this.viewer) {
                return this.viewer.selection;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "owner", {
        get: function () {
            return this.viewer.owner;
        },
        enumerable: true,
        configurable: true
    });
    Editor.prototype.getModuleName = function () {
        return 'Editor';
    };
    /**
     * Inserts the specified field at cursor position
     * @param code
     * @param result
     */
    Editor.prototype.insertField = function (code, result) {
        this.isInsertField = true;
        var fieldCode = code;
        if (isNullOrUndefined(result)) {
            fieldCode = HelperMethods.trimStart(fieldCode);
            if (fieldCode.substring(0, 10) === 'MERGEFIELD') {
                fieldCode = fieldCode.substring(10).trim();
                var index = fieldCode.indexOf('\\*');
                result = '' + fieldCode.substring(0, index).trim() + '';
            }
        }
        var paragraph = new ParagraphWidget();
        var insertFormat = new WCharacterFormat();
        var selectionFormat = this.copyInsertFormat(insertFormat, false);
        var line = new LineWidget(paragraph);
        var fieldBegin = new FieldElementBox(0);
        fieldBegin.characterFormat.mergeFormat(selectionFormat);
        line.children.push(fieldBegin);
        var fieldCodeSpan = new TextElementBox();
        fieldCodeSpan.text = code;
        line.children.push(fieldCodeSpan);
        var fieldSeparator = new FieldElementBox(2);
        fieldSeparator.fieldBegin = fieldBegin;
        fieldBegin.fieldSeparator = fieldSeparator;
        line.children.push(fieldSeparator);
        var fieldResultSpan = new TextElementBox();
        fieldResultSpan.text = result;
        fieldResultSpan.characterFormat.mergeFormat(selectionFormat);
        line.children.push(fieldResultSpan);
        var fieldEnd = new FieldElementBox(1);
        fieldEnd.characterFormat.mergeFormat(selectionFormat);
        fieldEnd.fieldSeparator = fieldSeparator;
        fieldEnd.fieldBegin = fieldBegin;
        fieldBegin.fieldEnd = fieldEnd;
        fieldSeparator.fieldEnd = fieldEnd;
        line.children.push(fieldEnd);
        fieldBegin.line = line;
        paragraph.childWidgets.push(line);
        this.viewer.fields.push(fieldBegin);
        var widgets = [];
        widgets.push(paragraph);
        this.pasteContentsInternal(widgets);
        this.isInsertField = false;
    };
    /**
     * To update style for paragraph
     * @param style - style name
     * @param clearDirectFormatting - Removes manual formatting (formatting not applied using a style)
     * from the selected text, to match the formatting of the applied style. Default value is false.
     */
    Editor.prototype.applyStyle = function (style, clearDirectFormatting) {
        clearDirectFormatting = isNullOrUndefined(clearDirectFormatting) ? false : clearDirectFormatting;
        if (clearDirectFormatting) {
            this.initComplexHistory('ApplyStyle');
            this.clearFormatting();
        }
        var styleObj = this.viewer.styles.findByName(style);
        if (styleObj !== undefined) {
            this.onApplyParagraphFormat('styleName', styleObj, false, true);
        }
        else {
            // tslint:disable-next-line:max-line-length
            this.viewer.owner.parser.parseStyle(JSON.parse(this.getCompleteStyles()), JSON.parse(this.viewer.preDefinedStyles.get(style)), this.viewer.styles);
            this.applyStyle(style);
        }
        if (this.editorHistory && this.editorHistory.currentHistoryInfo && this.editorHistory.currentHistoryInfo.action === 'ApplyStyle') {
            this.editorHistory.updateComplexHistory();
        }
    };
    // Public Implementation Starts
    /**
     * Moves the selected content in the document editor control to clipboard.
     */
    Editor.prototype.cut = function () {
        if (this.owner.isReadOnlyMode || this.selection.isEmpty) {
            return;
        }
        this.selection.copySelectedContent(true);
    };
    /**
     * Insert editing region in current selection range.
     */
    Editor.prototype.insertEditingRegion = function (user) {
        this.insertEditRangeElement(user && user !== '' ? user : 'Everyone');
    };
    /**
     * Enforce document protection.
     */
    Editor.prototype.enforceProtection = function (credential, limitToFormatting, isReadOnly) {
        this.viewer.restrictFormatting = limitToFormatting;
        this.viewer.protectionType = isReadOnly ? 'ReadOnly' : this.viewer.protectionType;
        this.selection.isHighlightEditRegion = true;
        this.addProtection(credential);
    };
    Editor.prototype.getCommentHierarchicalIndex = function (comment) {
        var index = '';
        while (comment.ownerComment) {
            index = comment.ownerComment.replyComments.indexOf(comment) + ';' + index;
            comment = comment.ownerComment;
        }
        index = 'C;' + this.viewer.comments.indexOf(comment) + ';' + index;
        return index;
    };
    /**
     * Insert comment
     * @param text - comment text.
     */
    // Comment implementation starts
    Editor.prototype.insertComment = function (text) {
        if (isNullOrUndefined(this.selection.start) || this.owner.isReadOnlyMode || this.viewer.owner.enableHeaderAndFooter
            || !this.viewer.owner.enableComment) {
            return;
        }
        if (isNullOrUndefined(text)) {
            text = '';
        }
        this.insertCommentInternal(text);
    };
    Editor.prototype.insertCommentInternal = function (text) {
        if (this.selection.isEmpty) {
            this.selection.selectCurrentWord();
        }
        var paragraphInfo = this.selection.getParagraphInfo(this.selection.start);
        var startIndex = this.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
        var endParagraphInfo = this.selection.getParagraphInfo(this.selection.start);
        var endIndex = this.selection.getHierarchicalIndex(endParagraphInfo.paragraph, endParagraphInfo.offset.toString());
        this.initComplexHistory('InsertComment');
        var startPosition = this.selection.start;
        var endPosition = this.selection.end;
        var position = new TextPosition(this.owner);
        if (!this.selection.isForward) {
            startPosition = this.selection.end;
            endPosition = this.selection.start;
        }
        // Clones the end position.
        position.setPositionInternal(endPosition);
        var commentRangeStart = new CommentCharacterElementBox(0);
        var commentRangeEnd = new CommentCharacterElementBox(1);
        var isAtSameParagraph = startPosition.isInSameParagraph(endPosition);
        // Adds comment start at selection start position.
        endPosition.setPositionInternal(startPosition);
        this.initInsertInline(commentRangeStart);
        // Updates the cloned position, since comment start is added in the same paragraph.
        if (isAtSameParagraph) {
            position.setPositionParagraph(position.currentWidget, position.offset + commentRangeStart.length);
        }
        // Adds comment end and comment at selection end position.
        startPosition.setPositionInternal(position);
        endPosition.setPositionInternal(position);
        this.initInsertInline(commentRangeEnd);
        var commentAdv = new CommentElementBox(new Date().toISOString());
        if (this.owner.editorHistory) {
            this.initHistory('InsertCommentWidget');
            this.owner.editorHistory.currentBaseHistoryInfo.removedNodes.push(commentAdv);
        }
        commentAdv.author = this.owner.currentUser ? this.owner.currentUser : 'Guest user';
        commentAdv.text = text;
        commentAdv.commentId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        commentRangeStart.comment = commentAdv;
        commentRangeStart.commentId = commentAdv.commentId;
        commentRangeEnd.comment = commentAdv;
        commentRangeEnd.commentId = commentAdv.commentId;
        commentAdv.commentStart = commentRangeStart;
        commentAdv.commentEnd = commentRangeEnd;
        this.addCommentWidget(commentAdv, true);
        if (this.editorHistory) {
            this.editorHistory.currentBaseHistoryInfo.insertPosition = this.getCommentHierarchicalIndex(commentAdv);
            this.editorHistory.updateHistory();
        }
        //tslint:disable-next-line:max-line-length
        // this.selection.selectPosition(this.selection.getTextPosBasedOnLogicalIndex(startIndex), this.selection.getTextPosBasedOnLogicalIndex(endIndex));
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistory();
        }
        this.reLayout(this.selection, false);
    };
    /**
     * Delete all the comments in current document
     */
    Editor.prototype.deleteAllComments = function () {
        if (this.viewer.comments.length === 0) {
            return;
        }
        // this.viewer.clearSearchHighlight();
        this.initComplexHistory('DeleteAllComments');
        this.owner.isLayoutEnabled = false;
        var historyInfo;
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            historyInfo = this.editorHistory.currentHistoryInfo;
        }
        while (this.viewer.comments.length > 0) {
            var comment = this.viewer.comments[0];
            this.initComplexHistory('DeleteComment');
            this.deleteCommentInternal(comment);
            if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
                historyInfo.addModifiedAction(this.editorHistory.currentHistoryInfo);
            }
        }
        this.selection.selectContent(this.owner.documentStart, true);
        if (this.editorHistory) {
            this.editorHistory.currentHistoryInfo = historyInfo;
            this.editorHistory.updateComplexHistory();
        }
    };
    /**
     * Delete current selected comment.
     */
    Editor.prototype.deleteComment = function () {
        if (this.owner.isReadOnlyMode || isNullOrUndefined(this.owner) || isNullOrUndefined(this.owner.viewer)
            || isNullOrUndefined(this.owner.viewer.currentSelectedComment) || this.owner.enableHeaderAndFooter
            || !this.viewer.owner.enableComment) {
            return;
        }
        this.deleteCommentInternal(this.owner.viewer.currentSelectedComment);
    };
    /**
     * @private
     */
    Editor.prototype.deleteCommentInternal = function (comment) {
        this.initComplexHistory('DeleteComment');
        if (comment) {
            var commentStart = comment.commentStart;
            var commentEnd = comment.commentEnd;
            this.removeInline(commentEnd);
            this.removeInline(commentStart);
            commentStart.removeCommentMark();
            if (comment.replyComments.length > 0) {
                for (var i = comment.replyComments.length - 1; i >= 0; i--) {
                    this.deleteCommentInternal(comment.replyComments[i]);
                }
            }
            if (this.owner.editorHistory) {
                this.initHistory('DeleteCommentWidget');
                this.owner.editorHistory.currentBaseHistoryInfo.insertPosition = this.getCommentHierarchicalIndex(comment);
                this.owner.editorHistory.currentBaseHistoryInfo.removedNodes.push(comment);
            }
            this.deleteCommentWidget(comment);
            if (this.editorHistory) {
                this.editorHistory.updateHistory();
            }
        }
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistory();
        }
    };
    /**
     * @private
     */
    Editor.prototype.deleteCommentWidget = function (comment) {
        var commentIndex = this.viewer.comments.indexOf(comment);
        if (commentIndex !== -1) {
            this.viewer.comments.splice(commentIndex, 1);
        }
        else if (comment.isReply && comment.ownerComment) {
            commentIndex = comment.ownerComment.replyComments.indexOf(comment);
            comment.ownerComment.replyComments.splice(commentIndex, 1);
        }
        if (this.owner.commentReviewPane) {
            this.owner.commentReviewPane.deleteComment(comment);
            if (this.viewer.currentSelectedComment === comment) {
                this.viewer.currentSelectedComment = undefined;
            }
        }
    };
    /**
     * @private
     */
    Editor.prototype.resolveComment = function (comment) {
        this.resolveOrReopenComment(comment, true);
        if (this.owner.commentReviewPane) {
            this.owner.commentReviewPane.resolveComment(comment);
        }
    };
    /**
     * @private
     */
    Editor.prototype.reopenComment = function (comment) {
        this.resolveOrReopenComment(comment, false);
        if (this.owner.commentReviewPane) {
            this.owner.commentReviewPane.reopenComment(comment);
        }
    };
    Editor.prototype.resolveOrReopenComment = function (comment, resolve) {
        comment.isResolved = resolve;
        for (var i = 0; i < comment.replyComments.length; i++) {
            comment.replyComments[i].isResolved = resolve;
        }
    };
    /**
     * @private
     */
    Editor.prototype.replyComment = function (parentComment, text) {
        var commentWidget = parentComment;
        if (parentComment) {
            this.initComplexHistory('InsertComment');
            var currentCmtStart = commentWidget.commentStart;
            var currentCmtEnd = commentWidget.commentEnd;
            var offset = currentCmtStart.line.getOffset(currentCmtStart, 1);
            var startPosition = new TextPosition(this.viewer.owner);
            startPosition.setPositionParagraph(currentCmtStart.line, offset);
            var endOffset = currentCmtEnd.line.getOffset(currentCmtEnd, 1);
            var endPosition = new TextPosition(this.viewer.owner);
            endPosition.setPositionParagraph(currentCmtEnd.line, endOffset);
            this.selection.start.setPositionInternal(startPosition);
            this.selection.end.setPositionInternal(endPosition);
            startPosition = this.selection.start;
            endPosition = this.selection.end;
            var position = new TextPosition(this.owner);
            // Clones the end position.
            position.setPositionInternal(endPosition);
            var commentRangeStart = new CommentCharacterElementBox(0);
            var commentRangeEnd = new CommentCharacterElementBox(1);
            var isAtSameParagraph = startPosition.isInSameParagraph(endPosition);
            // Adds comment start at selection start position.
            endPosition.setPositionInternal(startPosition);
            this.initInsertInline(commentRangeStart);
            // Updates the cloned position, since comment start is added in the same paragraph.
            if (isAtSameParagraph) {
                position.setPositionParagraph(position.currentWidget, position.offset + commentRangeStart.length);
            }
            // Adds comment end and comment at selection end position.
            startPosition.setPositionInternal(position);
            endPosition.setPositionInternal(position);
            this.initInsertInline(commentRangeEnd);
            var replyComment = new CommentElementBox(new Date().toISOString());
            replyComment.author = this.owner.currentUser ? this.owner.currentUser : 'Guest user';
            replyComment.text = text ? text : '';
            //tslint:disable-next-line:max-line-length
            replyComment.commentId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
            replyComment.isReply = true;
            commentWidget.replyComments.push(replyComment);
            replyComment.ownerComment = commentWidget;
            if (this.owner.editorHistory) {
                this.initHistory('InsertCommentWidget');
                this.owner.editorHistory.currentBaseHistoryInfo.removedNodes.push(replyComment);
            }
            commentRangeStart.comment = replyComment;
            commentRangeStart.commentId = replyComment.commentId;
            commentRangeEnd.comment = replyComment;
            commentRangeEnd.commentId = replyComment.commentId;
            replyComment.commentStart = commentRangeStart;
            replyComment.commentEnd = commentRangeEnd;
            if (this.owner.commentReviewPane) {
                this.owner.commentReviewPane.addReply(replyComment, false);
            }
            if (this.editorHistory) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = this.getCommentHierarchicalIndex(replyComment);
                this.editorHistory.updateHistory();
            }
            if (this.editorHistory) {
                this.editorHistory.updateComplexHistory();
            }
            this.reLayout(this.selection);
        }
    };
    Editor.prototype.removeInline = function (element) {
        this.selection.start.setPositionParagraph(element.line, element.line.getOffset(element, 0));
        this.selection.end.setPositionParagraph(this.selection.start.currentWidget, this.selection.start.offset + element.length);
        this.initHistory('RemoveInline');
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            this.updateHistoryPosition(this.selection.start, true);
        }
        this.removeSelectedContents(this.viewer.selection);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.fireContentChange();
    };
    /**
     * @private
     */
    Editor.prototype.addCommentWidget = function (commentWidget, isNewComment) {
        if (this.viewer.comments.indexOf(commentWidget) === -1) {
            var isInserted = false;
            if (this.viewer.comments.length > 0) {
                // tslint:disable-next-line:max-line-length
                var currentStart = this.selection.getElementPosition(commentWidget.commentStart).startPosition;
                for (var i = 0; i < this.viewer.comments.length; i++) {
                    var paraIndex = this.selection.getElementPosition(this.viewer.comments[i].commentStart).startPosition;
                    if (currentStart.isExistBefore(paraIndex)) {
                        isInserted = true;
                        this.viewer.comments.splice(i, 0, commentWidget);
                        break;
                    }
                }
            }
            if (!isInserted) {
                this.viewer.comments.push(commentWidget);
            }
            if (this.owner.commentReviewPane) {
                this.owner.showComments = true;
                this.owner.commentReviewPane.addComment(commentWidget, isNewComment);
                this.owner.selection.selectComment(commentWidget);
            }
        }
    };
    /**
     * @private
     */
    Editor.prototype.addReplyComment = function (comment, hierarchicalIndex) {
        var index = hierarchicalIndex.split(';');
        var ownerComment = this.viewer.comments[parseInt(index[1], 10)];
        if (index[2] !== '') {
            ownerComment.replyComments.splice(parseInt(index[2], 10), 0, comment);
            comment.ownerComment = ownerComment;
        }
        if (this.owner.commentReviewPane) {
            this.owner.showComments = true;
            this.owner.commentReviewPane.addReply(comment, false);
            this.owner.selection.selectComment(comment);
        }
    };
    /**
     * @private
     */
    Editor.prototype.addProtection = function (password) {
        var enforceProtectionHandler = new XmlHttpRequestHandler();
        var passwordBase64 = this.base64.encodeString(password);
        /* tslint:disable:no-any */
        var formObject = {
            passwordBase64: passwordBase64,
            saltBase64: '',
            spinCount: 100000
        };
        /* tslint:enable:no-any */
        var url = this.owner.serviceUrl + this.owner.serverActionSettings.restrictEditing;
        enforceProtectionHandler.url = url;
        enforceProtectionHandler.contentType = 'application/json;charset=UTF-8';
        enforceProtectionHandler.onSuccess = this.enforceProtectionInternal.bind(this);
        enforceProtectionHandler.onFailure = this.protectionFailureHandler.bind(this);
        enforceProtectionHandler.onError = this.protectionFailureHandler.bind(this);
        enforceProtectionHandler.customHeaders = this.owner.headers;
        enforceProtectionHandler.send(formObject);
    };
    /* tslint:disable:no-any */
    Editor.prototype.protectionFailureHandler = function (result) {
        var localeValue = new L10n('documenteditor', this.owner.defaultLocale);
        localeValue.setLocale(this.viewer.owner.locale);
        if (result.name === 'onError') {
            DialogUtility.alert(localeValue.getConstant('Error in establishing connection with web server'));
        }
        else {
            console.error(result.statusText);
        }
    };
    Editor.prototype.enforceProtectionInternal = function (result) {
        var data = JSON.parse(result.data);
        this.viewer.saltValue = data[0];
        this.viewer.hashValue = data[1];
        this.protectDocument();
    };
    /* tslint:enable:no-any */
    Editor.prototype.protectDocument = function () {
        this.protect(this.viewer.protectionType);
        var restrictPane = this.viewer.restrictEditingPane.restrictPane;
        if (restrictPane && restrictPane.style.display === 'block') {
            this.viewer.restrictEditingPane.showStopProtectionPane(true);
            this.viewer.restrictEditingPane.loadPaneValue();
            this.viewer.dialog.hide();
        }
    };
    /**
     * Stop document protection.
     */
    /* tslint:disable:no-any */
    Editor.prototype.stopProtection = function (password) {
        if (this.viewer.isDocumentProtected) {
            var unProtectDocumentHandler = new XmlHttpRequestHandler();
            var passwordBase64 = this.base64.encodeString(password);
            var formObject = {
                passwordBase64: passwordBase64,
                saltBase64: this.viewer.saltValue,
                spinCount: 100000
            };
            unProtectDocumentHandler.url = this.owner.serviceUrl + this.owner.serverActionSettings.restrictEditing;
            unProtectDocumentHandler.contentType = 'application/json;charset=UTF-8';
            unProtectDocumentHandler.customHeaders = this.owner.headers;
            unProtectDocumentHandler.onSuccess = this.onUnProtectionSuccess.bind(this);
            unProtectDocumentHandler.onFailure = this.protectionFailureHandler.bind(this);
            unProtectDocumentHandler.onError = this.protectionFailureHandler.bind(this);
            unProtectDocumentHandler.send(formObject);
        }
    };
    Editor.prototype.onUnProtectionSuccess = function (result) {
        var encodeString = JSON.parse(result.data);
        this.validateHashValue(encodeString[1]);
    };
    /* tslint:enable:no-any */
    Editor.prototype.validateHashValue = function (currentHashValue) {
        var localeValue = new L10n('documenteditor', this.owner.defaultLocale);
        localeValue.setLocale(this.viewer.owner.locale);
        var decodeUserHashValue = this.base64.decodeString(currentHashValue);
        var documentHashValue = this.viewer.hashValue;
        var defaultHashValue = this.base64.decodeString(documentHashValue);
        var stopProtection = true;
        if (decodeUserHashValue.length === defaultHashValue.length) {
            for (var i = 0; i < decodeUserHashValue.length; i++) {
                if (decodeUserHashValue[i] !== defaultHashValue[i]) {
                    stopProtection = false;
                    break;
                }
            }
        }
        else {
            stopProtection = false;
        }
        if (stopProtection) {
            this.viewer.isDocumentProtected = false;
            this.viewer.restrictFormatting = false;
            this.viewer.selection.highlightEditRegion();
            var restrictPane = this.viewer.restrictEditingPane.restrictPane;
            if (restrictPane && restrictPane.style.display === 'block') {
                this.viewer.restrictEditingPane.showStopProtectionPane(false);
            }
            this.viewer.dialog.hide();
        }
        else {
            DialogUtility.alert(localeValue.getConstant('The password is incorrect'));
        }
    };
    /**
     * Notify content change event
     * @private
     */
    Editor.prototype.fireContentChange = function () {
        if (this.selection.isHighlightEditRegion) {
            this.selection.onHighlight();
        }
        if (!this.isPaste) {
            this.copiedContent = undefined;
            this.copiedTextContent = '';
            this.selection.isViewPasteOptions = false;
            if (this.isPasteListUpdated) {
                this.isPasteListUpdated = false;
            }
            this.selection.showHidePasteOptions(undefined, undefined);
        }
        if (this.viewer.owner.isLayoutEnabled && !this.viewer.owner.isShiftingEnabled) {
            this.viewer.owner.fireContentChange();
        }
    };
    /**
     * Update physical location for text position
     * @private
     */
    Editor.prototype.updateSelectionTextPosition = function (isSelectionChanged) {
        this.getOffsetValue(this.selection);
        this.selection.start.updatePhysicalPosition(true);
        if (this.selection.isEmpty) {
            this.selection.end.setPositionInternal(this.selection.start);
        }
        else {
            this.selection.end.updatePhysicalPosition(true);
        }
        this.selection.upDownSelectionLength = this.selection.end.location.x;
        this.selection.fireSelectionChanged(isSelectionChanged);
    };
    /**
     * Predict text
     * @private
     */
    Editor.prototype.predictText = function () {
        this.viewer.suffix = '';
        if (this.selection.start.paragraph.isEmpty() || this.selection.start.offset === 0 &&
            this.selection.start.currentWidget.isFirstLine() || this.selection.end.offset === 0 &&
            this.selection.end.currentWidget.isFirstLine()) {
            this.viewer.prefix = '';
        }
        else {
            this.getPrefixAndSuffix();
        }
        this.viewer.prefix = '@' + String.fromCharCode(160) + this.viewer.prefix; // &nbsp;
        this.viewer.editableDiv.innerText = this.viewer.prefix;
        this.viewer.selection.setEditableDivCaretPosition(this.viewer.prefix.length);
    };
    /**
     * Gets prefix and suffix.
     * @private
     */
    /* tslint:disable:max-func-body-length */
    Editor.prototype.getPrefixAndSuffix = function () {
        var viewer = this.viewer;
        if (this.selection.text !== '') {
            viewer.prefix = '';
            return;
        }
        else {
            var startIndex = 0;
            var inlineInfo = this.selection.start.currentWidget.getInline(this.selection.start.offset, startIndex);
            var inline = inlineInfo.element;
            startIndex = inlineInfo.index;
            if (inline !== undefined) {
                var boxInfo = this.selection.getElementBoxInternal(inline, startIndex);
                var box = boxInfo.element;
                startIndex = boxInfo.index;
                var spaceIndex = 0;
                if (!isNullOrUndefined(box)) {
                    var prefixAdded = false;
                    if (box instanceof TextElementBox && startIndex > 0 && box.line.isFirstLine()) {
                        viewer.prefix = '';
                    }
                    if (!(inline instanceof TextElementBox)) {
                        inline = this.selection.getPreviousTextElement(inline);
                    }
                    /* tslint:disable:no-conditional-assignment */
                    while ((spaceIndex = viewer.prefix.lastIndexOf(' ')) < 0 && inline instanceof TextElementBox) {
                        if (inline.previousNode instanceof TextElementBox && viewer.prefix.indexOf(' ') === -1) {
                            if (!prefixAdded) {
                                viewer.prefix = inline.text.substring(0, startIndex);
                                prefixAdded = true;
                            }
                            else {
                                viewer.prefix = inline.text + viewer.prefix;
                            }
                            inline = inline.previousNode;
                            // If the line has no elements then break the loop to avoid the exception.
                            if (inline instanceof ListTextElementBox) {
                                break;
                            }
                            if (!(inline instanceof TextElementBox)) {
                                inline = this.selection.getPreviousTextElement(inline);
                            }
                        }
                        else if (!(inline.previousNode instanceof TextElementBox)) {
                            if (!prefixAdded) {
                                viewer.prefix = inline.text.substring(0, startIndex);
                                prefixAdded = true;
                            }
                            else {
                                viewer.prefix = inline.text + viewer.prefix;
                            }
                            break;
                        }
                    }
                    if (!(viewer.prefix.length > 1 && viewer.prefix[viewer.prefix.length - 1] === ' ' &&
                        viewer.prefix[viewer.prefix.length - 2] === '.')) {
                        spaceIndex = viewer.prefix.lastIndexOf(' ');
                    }
                    else {
                        spaceIndex = -1;
                        viewer.prefix = '';
                    }
                    viewer.prefix = spaceIndex < 0 ? viewer.prefix : viewer.prefix.substring(spaceIndex);
                    if (viewer.prefix.indexOf(' ') === 0 && viewer.prefix.length >= 1) {
                        viewer.prefix = viewer.prefix.substring(1);
                    }
                    // suffix text prediction
                    var endIndex = 0;
                    var endInlineInfo = this.selection.end.currentWidget.getInline(this.selection.end.offset, endIndex);
                    var endInline = endInlineInfo.element;
                    endIndex = endInlineInfo.index;
                    boxInfo = this.selection.getElementBoxInternal(endInline, endIndex);
                    box = boxInfo.element;
                    endIndex = boxInfo.index;
                    if (box) {
                        var suffixAdded = false;
                        if (box instanceof TextElementBox && endIndex < box.length) {
                            viewer.suffix = '';
                        }
                        // boxIndex = renderedElements.get(endInline).indexOf(box);
                        while ((spaceIndex = viewer.suffix.indexOf(' ')) < 0 && endInline instanceof TextElementBox) {
                            if (endInline.nextNode instanceof TextElementBox && viewer.suffix.indexOf(' ') === -1) {
                                if (!suffixAdded) {
                                    viewer.suffix = box.text.substring(endIndex);
                                    suffixAdded = true;
                                }
                                else {
                                    viewer.suffix = viewer.suffix + endInline.text;
                                }
                                endInline = endInline.nextNode;
                            }
                            else if (!(endInline.nextNode instanceof TextElementBox)) {
                                if (!suffixAdded) {
                                    viewer.suffix = box.text.substring(endIndex);
                                    suffixAdded = true;
                                }
                                else {
                                    viewer.suffix = viewer.suffix + endInline.text;
                                }
                                break;
                            }
                        }
                        spaceIndex = viewer.suffix.indexOf(' ');
                        viewer.suffix = spaceIndex < 0 ? viewer.suffix : viewer.suffix.substring(0, spaceIndex);
                    }
                }
            }
        }
    };
    /**
     * key action
     * @private
     */
    // tslint:disable:max-func-body-length
    Editor.prototype.onKeyDownInternal = function (event, ctrl, shift, alt) {
        var key = event.which || event.keyCode;
        if (ctrl && !shift && !alt) {
            this.viewer.isControlPressed = true;
            switch (key) {
                case 9:
                    event.preventDefault();
                    if (this.owner.acceptTab) {
                        this.selection.handleTabKey(false, false);
                    }
                    break;
                case 13:
                    event.preventDefault();
                    this.insertPageBreak();
                    break;
                case 48:
                    event.preventDefault();
                    this.onApplyParagraphFormat('beforeSpacing', 0, false, false);
                    break;
                case 49:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyParagraphFormat('lineSpacing', 1, false, false);
                    }
                    break;
                case 50:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyParagraphFormat('lineSpacing', 2, false, false);
                    }
                    break;
                case 53:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyParagraphFormat('lineSpacing', 1.5, false, false);
                    }
                    break;
                case 66:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleBold();
                    }
                    break;
                case 68:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode && this.owner.fontDialogModule) {
                        this.owner.fontDialogModule.showFontDialog();
                    }
                    break;
                case 69:
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleTextAlignment('Center');
                    }
                    event.preventDefault();
                    break;
                case 72:
                    event.preventDefault();
                    if (!this.owner.isReadOnly && this.owner.optionsPaneModule) {
                        this.owner.optionsPaneModule.isReplace = true;
                        this.owner.optionsPaneModule.showHideOptionsPane(true);
                    }
                    break;
                case 73:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleItalic();
                    }
                    break;
                case 74:
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleTextAlignment('Justify');
                    }
                    event.preventDefault();
                    break;
                case 75:
                    event.preventDefault();
                    if (this.owner.hyperlinkDialogModule && !this.owner.isReadOnlyMode) {
                        this.owner.hyperlinkDialogModule.show();
                    }
                    break;
                case 76:
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleTextAlignment('Left');
                    }
                    event.preventDefault();
                    break;
                case 77:
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.selection.increaseIndent();
                    }
                    event.preventDefault();
                    break;
                case 78:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.openBlank();
                    }
                    break;
                case 82:
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleTextAlignment('Right');
                    }
                    event.preventDefault();
                    break;
                case 85:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.selection.toggleUnderline('Single');
                    }
                    break;
                case 88:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.editor.cut();
                    }
                    break;
                case 89:
                    if (this.owner.enableEditorHistory) {
                        this.editorHistory.redo();
                        event.preventDefault();
                    }
                    break;
                case 90:
                    if (this.owner.enableEditorHistory) {
                        this.editorHistory.undo();
                        event.preventDefault();
                    }
                    break;
                case 219:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyCharacterFormat('fontSize', 'decrement', true);
                    }
                    break;
                case 221:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyCharacterFormat('fontSize', 'increment', true);
                    }
                    break;
                case 187:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleBaselineAlignment('Subscript');
                    }
                    break;
            }
        }
        else if (shift && !ctrl && !alt) {
            switch (key) {
                case 9:
                    event.preventDefault();
                    if (this.owner.acceptTab) {
                        this.selection.handleTabKey(false, true);
                    }
                    break;
                case 13:
                    this.handleShiftEnter();
                    event.preventDefault();
                    break;
            }
        }
        else if (shift && ctrl && !alt) {
            switch (key) {
                case 68:
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.selection.toggleUnderline('Double');
                    }
                    break;
                case 77:
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.selection.decreaseIndent();
                    }
                    event.preventDefault();
                    break;
                case 188:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyCharacterFormat('fontSize', 'decrement', true);
                    }
                    break;
                case 190:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyCharacterFormat('fontSize', 'increment', true);
                    }
                    break;
                case 187:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleBaselineAlignment('Superscript');
                    }
            }
        }
        else if (!shift && ctrl && alt) {
            switch (key) {
                case 72:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode && this.owner.isDocumentLoaded) {
                        this.toggleHighlightColor();
                    }
                    break;
            }
        }
        else {
            switch (key) {
                case 8:
                    event.preventDefault();
                    this.handleBackKey();
                    break;
                case 9:
                    event.preventDefault();
                    if (this.owner.acceptTab) {
                        this.selection.handleTabKey(true, false);
                    }
                    break;
                case 13:
                    event.preventDefault();
                    this.viewer.triggerSpellCheck = true;
                    this.handleEnterKey();
                    this.viewer.triggerSpellCheck = false;
                    break;
                case 27:
                    event.preventDefault();
                    if (!this.isPaste) {
                        this.copiedContent = undefined;
                        this.copiedTextContent = '';
                        this.selection.isViewPasteOptions = false;
                        if (this.isPasteListUpdated) {
                            this.isPasteListUpdated = false;
                        }
                        this.selection.showHidePasteOptions(undefined, undefined);
                    }
                    break;
                case 46:
                    this.handleDelete();
                    event.preventDefault();
                    break;
            }
        }
    };
    /**
     * @private
     */
    Editor.prototype.handleShiftEnter = function () {
        if (!this.owner.isReadOnlyMode) {
            this.handleTextInput('\v');
        }
        this.selection.checkForCursorVisibility();
    };
    /**
     * Handles back key.
     * @private
     */
    Editor.prototype.handleBackKey = function () {
        if (!this.owner.isReadOnlyMode) {
            this.owner.editorModule.onBackSpace();
        }
        this.selection.checkForCursorVisibility();
    };
    /**
     * Handles delete
     * @private
     */
    Editor.prototype.handleDelete = function () {
        if (!this.owner.isReadOnlyMode) {
            this.owner.editorModule.delete();
        }
        this.selection.checkForCursorVisibility();
    };
    /**
     * Handles enter key.
     * @private
     */
    Editor.prototype.handleEnterKey = function () {
        if (!this.owner.isReadOnlyMode) {
            if (Browser.isDevice) {
                this.viewer.isCompositionStart = false;
            }
            this.owner.editorModule.onEnter();
        }
        this.selection.checkForCursorVisibility();
    };
    /**
     * @private
     */
    Editor.prototype.handleTextInput = function (text) {
        var _this = this;
        if (!this.owner.isReadOnlyMode) {
            if (this.animationTimer) {
                clearTimeout(this.animationTimer);
            }
            classList(this.selection.caret, [], ['e-de-cursor-animation']);
            this.owner.editorModule.insertText(text);
            /* tslint:disable:align */
            this.animationTimer = setTimeout(function () {
                if (_this.animationTimer) {
                    clearTimeout(_this.animationTimer);
                }
                if (_this.selection && _this.selection.caret) {
                    classList(_this.selection.caret, ['e-de-cursor-animation'], []);
                }
            }, 600);
        }
        this.selection.checkForCursorVisibility();
    };
    /**
     * Copies to format.
     * @param  {WCharacterFormat} format
     * @private
     */
    Editor.prototype.copyInsertFormat = function (format, copy) {
        var insertFormat = new WCharacterFormat();
        var sFormat = this.selection.characterFormat;
        if (copy) {
            insertFormat.copyFormat(format);
        }
        if (!isNullOrUndefined(sFormat.bold) && format.bold !== sFormat.bold) {
            insertFormat.bold = sFormat.bold;
        }
        if (!isNullOrUndefined(sFormat.italic) && format.italic !== sFormat.italic) {
            insertFormat.italic = sFormat.italic;
        }
        if (sFormat.fontSize > 0 && format.fontSize !== sFormat.fontSize) {
            insertFormat.fontSize = sFormat.fontSize;
        }
        if (!isNullOrUndefined(sFormat.fontFamily) && format.fontFamily !== sFormat.fontFamily) {
            insertFormat.fontFamily = sFormat.fontFamily;
        }
        if (!isNullOrUndefined(sFormat.highlightColor) && format.highlightColor !== sFormat.highlightColor) {
            insertFormat.highlightColor = sFormat.highlightColor;
        }
        if (!isNullOrUndefined(sFormat.baselineAlignment) && format.baselineAlignment !== sFormat.baselineAlignment) {
            insertFormat.baselineAlignment = sFormat.baselineAlignment;
        }
        if (!isNullOrUndefined(sFormat.fontColor) && format.fontColor !== sFormat.fontColor) {
            insertFormat.fontColor = sFormat.fontColor;
        }
        if (!isNullOrUndefined(sFormat.underline) && format.underline !== sFormat.underline) {
            insertFormat.underline = sFormat.underline;
        }
        if (!isNullOrUndefined(sFormat.strikethrough) && format.strikethrough !== sFormat.strikethrough) {
            insertFormat.strikethrough = sFormat.strikethrough;
        }
        return insertFormat;
    };
    /**
     * Inserts the specified text at cursor position
     * @param  {string} text - text to insert
     */
    Editor.prototype.insertText = function (text) {
        if (isNullOrUndefined(text) || text === '') {
            return;
        }
        this.insertTextInternal(text, false);
    };
    /**
     * @private
     */
    //tslint:disable: max-func-body-length
    Editor.prototype.insertTextInternal = function (text, isReplace) {
        var selection = this.viewer.selection;
        var insertPosition;
        var isRemoved = true;
        this.isListTextSelected();
        this.initHistory('Insert');
        var paragraphInfo = this.selection.getParagraphInfo(selection.start);
        selection.editPosition = selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
        var bidi = selection.start.paragraph.paragraphFormat.bidi;
        if (!bidi && this.viewer.layout.isContainsRtl(selection.start.currentWidget)) {
            this.viewer.layout.reArrangeElementsForRtl(selection.start.currentWidget, bidi);
        }
        if ((!selection.isEmpty && !selection.isImageSelected) ||
            this.viewer.isListTextSelected && selection.contextType === 'List') {
            selection.isSkipLayouting = true;
            selection.skipFormatRetrieval = true;
            isRemoved = this.removeSelectedContents(selection);
            selection.skipFormatRetrieval = false;
            selection.isSkipLayouting = false;
        }
        else if (selection.isEmpty && !this.viewer.isListTextSelected && !isReplace) {
            this.viewer.isTextInput = true;
        }
        paragraphInfo = this.selection.getParagraphInfo(selection.start);
        if (isRemoved) {
            selection.owner.isShiftingEnabled = true;
            this.updateInsertPosition();
            insertPosition = selection.start;
            if (insertPosition.paragraph.isEmpty()) {
                var span = new TextElementBox();
                var insertFormat = this.copyInsertFormat(insertPosition.paragraph.characterFormat, true);
                span.characterFormat.copyFormat(insertFormat);
                span.text = text;
                var isBidi = this.viewer.textHelper.getRtlLanguage(text).isRtl;
                span.characterFormat.bidi = isBidi;
                span.line = insertPosition.paragraph.childWidgets[0];
                span.margin = new Margin(0, 0, 0, 0);
                span.line.children.push(span);
                if ((insertPosition.paragraph.paragraphFormat.textAlignment === 'Center'
                    || insertPosition.paragraph.paragraphFormat.textAlignment === 'Right') &&
                    insertPosition.paragraph.paragraphFormat.listFormat.listId === -1) {
                    insertPosition.paragraph.x = this.viewer.clientActiveArea.x;
                }
                this.viewer.layout.reLayoutParagraph(insertPosition.paragraph, 0, 0);
            }
            else {
                var indexInInline = 0;
                // tslint:disable-next-line:max-line-length
                var inlineObj = insertPosition.currentWidget.getInline(insertPosition.offset, indexInInline, bidi, (isReplace) ? false : true);
                var inline = inlineObj.element;
                indexInInline = inlineObj.index;
                inline.ischangeDetected = true;
                if (inline instanceof TextElementBox && text !== ' ' && this.viewer.owner.enableSpellCheck) {
                    this.owner.spellChecker.removeErrorsFromCollection({ 'element': inline, 'text': inline.text });
                    if (!isReplace) {
                        inline.ignoreOnceItems = [];
                    }
                }
                if (inline.canTrigger && inline.text.length <= 1) {
                    inline.canTrigger = false;
                }
                // Todo: compare selection format
                var insertFormat = this.copyInsertFormat(inline.characterFormat, true);
                var isBidi = this.viewer.textHelper.getRtlLanguage(text).isRtl;
                var insertLangId = this.viewer.textHelper.getRtlLanguage(text).id;
                var inlineLangId = 0;
                var isRtl = false;
                if (inline instanceof TextElementBox) {
                    inlineLangId = this.viewer.textHelper.getRtlLanguage(inline.text).id;
                    isRtl = this.viewer.textHelper.getRtlLanguage(inline.text).isRtl;
                }
                if (isBidi || !this.viewer.owner.enableSpellCheck) {
                    insertFormat.bidi = isBidi;
                }
                // tslint:disable-next-line:max-line-length
                if ((!this.viewer.owner.enableSpellCheck || (text !== ' ' && inline.text !== ' ')) && insertFormat.isSameFormat(inline.characterFormat) && (!isBidi || (isBidi && insertLangId === inlineLangId))
                    || (text.trim() === '' && !isBidi && inline.characterFormat.bidi)) {
                    this.insertTextInline(inline, selection, text, indexInInline);
                }
                else {
                    var tempSpan = new TextElementBox();
                    tempSpan.text = text;
                    tempSpan.line = inline.line;
                    tempSpan.characterFormat.copyFormat(insertFormat);
                    var insertIndex = inline.indexInOwner;
                    if (indexInInline === inline.length) {
                        var isParaBidi = inline.line.paragraph.bidi;
                        if (isParaBidi && inline instanceof FieldElementBox && inline.fieldType === 1) {
                            inline = inline.fieldBegin;
                            insertIndex = inline.indexInOwner;
                        }
                        inline.line.children.splice(isParaBidi ? insertIndex : insertIndex + 1, 0, tempSpan);
                    }
                    else if (indexInInline === 0) {
                        if (isRtl && !isBidi) {
                            inline.line.children.splice(insertIndex + 1, 0, tempSpan);
                        }
                        else {
                            inline.line.children.splice(insertIndex, 0, tempSpan);
                        }
                    }
                    else {
                        if (inline instanceof TextElementBox) {
                            var splittedSpan = new TextElementBox();
                            splittedSpan.line = inline.line;
                            splittedSpan.characterFormat.copyFormat(inline.characterFormat);
                            if (bidi && isRtl && !isBidi) {
                                splittedSpan.text = inline.text.slice(0, indexInInline);
                                inline.text = inline.text.substring(indexInInline);
                            }
                            else {
                                splittedSpan.text = inline.text.substring(indexInInline);
                                inline.text = inline.text.slice(0, indexInInline);
                            }
                            if (this.owner.enableSpellCheck) {
                                this.owner.spellChecker.updateSplittedElementError(inline, splittedSpan);
                            }
                            inline.line.children.splice(insertIndex + 1, 0, splittedSpan);
                        }
                        inline.line.children.splice(insertIndex + 1, 0, tempSpan);
                    }
                    this.viewer.layout.reLayoutParagraph(insertPosition.paragraph, inline.line.indexInOwner, 0);
                }
            }
            this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + text.length, true);
            this.updateEndPosition();
            if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)
                && (this.editorHistory.currentHistoryInfo.action === 'ListSelect') &&
                this.viewer.isListTextSelected) {
                this.editorHistory.updateHistory();
                this.editorHistory.updateComplexHistory();
            }
            this.reLayout(selection);
            this.viewer.isTextInput = false;
        }
        if (!isReplace && isRemoved && (text === ' ' || text === '\t' || text === '\v')) {
            var isList = false;
            if (!(text === '\v')) {
                isList = this.checkAndConvertList(selection, text === '\t');
            }
            if (!isList) {
                if (!isNullOrUndefined(selection.getHyperlinkField())) {
                    return;
                }
                //Checks if the previous text is URL, then it is auto formatted to hyperlink.
                this.checkAndConvertToHyperlink(selection, false);
            }
        }
    };
    /**
     * @private
     */
    Editor.prototype.insertIMEText = function (text, isUpdate) {
        if (this.viewer.lastComposedText === text && isUpdate) {
            return;
        }
        // Clone selection start position
        var paragraphInfo = this.selection.getParagraphInfo(this.selection.start);
        var startPosition = this.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
        // Insert IME text in current selection
        this.insertText(text);
        this.viewer.lastComposedText = text;
        // update selection start
        var start = this.selection.start;
        this.setPositionForCurrentIndex(start, startPosition);
        // Update selection end
        var endPosition = new TextPosition(this.owner);
        endPosition.setPositionForLineWidget(start.currentWidget, start.offset + text.length);
        this.selection.selectPosition(isUpdate ? start : endPosition, endPosition);
    };
    /**
     * Insert Section break at cursor position
     */
    Editor.prototype.insertSectionBreak = function () {
        var selection = this.viewer.selection;
        if (isNullOrUndefined(selection) || this.owner.isReadOnlyMode || selection.start.paragraph.isInHeaderFooter) {
            return;
        }
        this.initHistory('SectionBreak');
        if (!selection.isEmpty) {
            selection.selectContent(selection.isForward ? selection.start : selection.end, true);
        }
        this.viewer.owner.isShiftingEnabled = true;
        this.updateInsertPosition();
        this.insertSection(selection, true);
        this.updateEndPosition();
        this.reLayout(selection, true);
    };
    /**
     * @private
     */
    Editor.prototype.insertSection = function (selection, selectFirstBlock) {
        var newSectionFormat = this.selection.start.paragraph.bodyWidget.sectionFormat.cloneFormat();
        var lastBlock;
        var firstBlock;
        if (selection.start.paragraph.isInsideTable) {
            var table = this.viewer.layout.getParentTable(selection.start.paragraph);
            table = table.combineWidget(this.viewer);
            var insertBefore = false;
            if (selection.start.paragraph.associatedCell.rowIndex === 0) {
                insertBefore = true;
            }
            var newParagraph = new ParagraphWidget();
            var previousBlock = table.previousRenderedWidget;
            if (!insertBefore) {
                lastBlock = this.splitTable(table, selection.start.paragraph.associatedCell.ownerRow);
                this.viewer.layout.layoutBodyWidgetCollection(lastBlock.index, lastBlock.containerWidget, lastBlock, false);
                lastBlock = lastBlock.getSplitWidgets().pop();
            }
            else {
                lastBlock = table;
            }
            var insertIndex = 0;
            if ((isNullOrUndefined(previousBlock) || !previousBlock.bodyWidget.equals(lastBlock.bodyWidget)) && insertBefore) {
                insertIndex = 0;
                newParagraph.index = 0;
            }
            else {
                insertIndex = lastBlock.indexInOwner + 1;
                newParagraph.index = lastBlock.index + 1;
            }
            lastBlock.containerWidget.childWidgets.splice(insertIndex, 0, newParagraph);
            newParagraph.containerWidget = lastBlock.containerWidget;
            this.updateNextBlocksIndex(newParagraph, true);
            this.viewer.layout.layoutBodyWidgetCollection(newParagraph.index, newParagraph.containerWidget, newParagraph, false);
            lastBlock = newParagraph;
        }
        else {
            var paragraphInfo = this.selection.getParagraphInfo(selection.start);
            var selectionStart = this.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
            //Split Paragraph
            this.splitParagraphInternal(selection, selection.start.paragraph, selection.start.currentWidget, selection.start.offset);
            this.setPositionForCurrentIndex(selection.start, selectionStart);
            lastBlock = selection.start.paragraph.getSplitWidgets().pop();
        }
        //Split body widget
        firstBlock = this.splitBodyWidget(lastBlock.bodyWidget, newSectionFormat, lastBlock).firstChild;
        if (firstBlock instanceof TableWidget) {
            firstBlock.updateRowIndex(0);
        }
        this.viewer.layout.layoutBodyWidgetCollection(firstBlock.index, firstBlock.containerWidget, firstBlock, false);
        if (firstBlock instanceof TableWidget) {
            firstBlock = selection.getFirstParagraphInFirstCell(firstBlock);
        }
        if (selectFirstBlock) {
            selection.selectParagraphInternal(firstBlock, true);
        }
        return firstBlock;
    };
    Editor.prototype.splitBodyWidget = function (bodyWidget, sectionFormat, startBlock) {
        var newBodyWidget = this.viewer.layout.moveBlocksToNextPage(startBlock);
        //Update SectionIndex for splitted body widget
        this.updateSectionIndex(sectionFormat, newBodyWidget, true);
        // insert New header footer widget in to section index 
        this.insertRemoveHeaderFooter(newBodyWidget.sectionIndex, true);
        //update header and footer for splitted widget
        this.viewer.layout.layoutHeaderFooter(newBodyWidget, this.viewer, newBodyWidget.page);
        //Update Child item index from 0 for new Section
        this.updateBlockIndex(0, newBodyWidget.firstChild);
        // Start sinfting from first block
        this.viewer.updateClientArea(newBodyWidget.sectionFormat, newBodyWidget.page);
        return newBodyWidget;
    };
    Editor.prototype.insertRemoveHeaderFooter = function (sectionIndex, insert) {
        if (this.viewer.headersFooters[sectionIndex]) {
            // Need to handle further
        }
        else {
            this.viewer.headersFooters[sectionIndex] = {};
        }
    };
    Editor.prototype.updateBlockIndex = function (blockIndex, block) {
        var blocks;
        var sectionIndex = block.bodyWidget.sectionIndex;
        do {
            blocks = block.getSplitWidgets();
            for (var i = 0; i < blocks.length; i++) {
                blocks[i].index = blockIndex;
            }
            blockIndex++;
            block = blocks.pop().nextRenderedWidget;
        } while (!isNullOrUndefined(block) && block.bodyWidget.sectionIndex === sectionIndex);
    };
    Editor.prototype.updateSectionIndex = function (sectionFormat, startBodyWidget, increaseIndex) {
        var currentSectionIndex = startBodyWidget.sectionIndex;
        var bodyWidget = startBodyWidget;
        do {
            if (bodyWidget.index === currentSectionIndex && sectionFormat) {
                bodyWidget.sectionFormat = sectionFormat;
            }
            if (increaseIndex) {
                bodyWidget.index++;
            }
            else {
                bodyWidget.index--;
            }
            bodyWidget = bodyWidget.nextRenderedWidget;
        } while (bodyWidget);
    };
    //Auto convert List
    Editor.prototype.checkAndConvertList = function (selection, isTab) {
        var list = selection.paragraphFormat.getList();
        if (!isNullOrUndefined(list)) {
            return false;
        }
        var convertList = false;
        var isLeadingZero = false;
        var indexInInline = 0;
        var inlineObj = selection.start.currentWidget.getInline(selection.start.offset - 1, indexInInline);
        var inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (!(inline instanceof TextElementBox)) {
            return false;
        }
        var span = inline;
        var text = span.text.substring(0, indexInInline);
        var tabValue = 0;
        var length = 0;
        while (!isNullOrUndefined(span.previousNode)) {
            // tslint:disable-next-line:max-line-length
            if (span.previousNode instanceof TextElementBox && (span.previousNode.text === '\t' || span.previousNode.text.trim().length === 0)) {
                (span.previousNode.text === '\t') ? tabValue += 36 : length = span.previousNode.text.length * 2.5;
                span = span.previousNode;
                continue;
            }
            return false;
        }
        span = inline;
        var index = 0;
        var tabIndex = text.lastIndexOf('\t');
        index = (tabIndex >= 0) ? tabIndex + 1 : text.lastIndexOf(' ') + 1;
        while (span.previousNode instanceof TextElementBox && index === 0) {
            span = span.previousNode;
            var previousText = span.text;
            tabIndex = previousText.lastIndexOf('\t');
            index = (tabIndex >= 0) ? tabIndex + 1 : previousText.lastIndexOf(' ') + 1;
            text = span.text + text;
            text = text.substring(index);
        }
        text = HelperMethods.trimStart(text);
        var numberFormat = text.substring(1, 2);
        var previousList = undefined;
        var listLevelPattern = this.getListLevelPattern(text.substring(0, 1));
        if (listLevelPattern !== 'None' && this.checkNumberFormat(numberFormat, listLevelPattern === 'Bullet', text)) {
            convertList = true;
        }
        else if (this.checkLeadingZero(text)) {
            isLeadingZero = true;
            convertList = true;
        }
        else {
            previousList = this.checkNextLevelAutoList(text);
            if (!isNullOrUndefined(previousList)) {
                convertList = true;
            }
        }
        if (convertList) {
            this.initComplexHistory('AutoList');
            var paragraph = inline.paragraph;
            // tslint:disable-next-line:max-line-length
            selection.start.setPositionParagraph(paragraph.childWidgets[0], paragraph.childWidgets[0].getOffset(inline, indexInInline + 1));
            selection.end.setPositionParagraph(paragraph.childWidgets[0], 0);
            this.initHistory('Delete');
            this.deleteSelectedContents(selection, false);
            this.reLayout(selection, false);
            var followCharacter = isTab ? 'Tab' : 'Space';
            numberFormat = !isLeadingZero ? '%1' + numberFormat : '%1' + text.substring(text.length - 1, text.length);
            var leadingZeroText = text.substring(text.length - 3, text.length - 1);
            listLevelPattern = !isLeadingZero ? listLevelPattern : this.getListLevelPattern(leadingZeroText);
            var listLevel = new WListLevel(undefined);
            listLevel.listLevelPattern = listLevelPattern;
            if (listLevelPattern === 'Bullet') {
                if (text === '*') {
                    listLevel.numberFormat = '\uf0b7';
                    listLevel.characterFormat.fontFamily = 'Symbol';
                }
                else if (text === '-') {
                    listLevel.numberFormat = '-';
                }
            }
            else {
                listLevel.numberFormat = numberFormat;
            }
            listLevel.followCharacter = followCharacter;
            var leftIndent = selection.paragraphFormat.leftIndent;
            if (tabValue !== 0 || length !== 0) {
                listLevel.paragraphFormat.leftIndent = leftIndent + 18 + tabValue + length;
            }
            else if (indexInInline > 2) {
                listLevel.paragraphFormat.leftIndent = leftIndent + (indexInInline - 2) * 2.5 + 18;
            }
            else if (leftIndent > 0) {
                listLevel.paragraphFormat.leftIndent = leftIndent + 18;
            }
            else {
                listLevel.paragraphFormat.leftIndent = 36;
            }
            listLevel.paragraphFormat.firstLineIndent = -18;
            if ((!isLeadingZero && text.substring(0, 1) === '0') || leadingZeroText === '00') {
                listLevel.startAt = 0;
            }
            else {
                listLevel.startAt = 1;
            }
            if (!isNullOrUndefined(previousList)) {
                selection.paragraphFormat.setList(previousList);
            }
            else {
                this.autoConvertList(selection, listLevel);
            }
            if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
                this.editorHistory.updateComplexHistory();
            }
            else {
                this.reLayout(selection);
            }
        }
        return convertList;
    };
    Editor.prototype.checkNextLevelAutoList = function (text) {
        var selection = this.viewer.selection;
        var previousList = undefined;
        var convertList = false;
        var currentParagraph = selection.start.paragraph;
        var prevParagraph = selection.getPreviousParagraphBlock(currentParagraph);
        var isList = false;
        while (!isNullOrUndefined(prevParagraph) && prevParagraph instanceof ParagraphWidget) {
            if (prevParagraph.paragraphFormat.listFormat && prevParagraph.paragraphFormat.listFormat.listId !== -1) {
                isList = true;
                break;
            }
            prevParagraph = selection.getPreviousParagraphBlock(prevParagraph);
        }
        if (isList) {
            var listNumber = this.viewer.layout.getListNumber(prevParagraph.paragraphFormat.listFormat, true);
            var prevListText = listNumber.substring(0, listNumber.length - 1);
            var currentListText = text.substring(0, text.length - 1);
            //check if numberFormat equal
            var inputString = void 0;
            if (listNumber.substring(listNumber.length - 1) !== text.substring(text.length - 1)) {
                convertList = false;
            }
            else if (currentListText.match(/^[0-9]+$/) && prevListText.match(/^[0-9]+$/)) {
                inputString = parseInt(currentListText, 10);
                if (parseInt(prevListText, 10) === inputString || parseInt(prevListText, 10) + 1 === inputString
                    || parseInt(prevListText, 10) + 2 === inputString) {
                    convertList = true;
                }
            }
            else if (currentListText.match(/^[a-zA-Z]+$/) && prevListText.match(/^[a-zA-Z]+$/)) {
                if (prevListText.charCodeAt(0) === text.charCodeAt(0) || prevListText.charCodeAt(0) + 1 === text.charCodeAt(0)
                    || prevListText.charCodeAt(0) + 2 === text.charCodeAt(0)) {
                    convertList = true;
                }
                else if (currentListText.match(/^[MDCLXVImdclxvi]+$/) && prevListText.match(/^[MDCLXVImdclxvi]+$/)) {
                    var prevListNumber = this.getNumber(prevListText.toUpperCase());
                    var currentListNumber = this.getNumber(currentListText.toUpperCase());
                    if (prevListNumber === currentListNumber || prevListNumber + 1 === currentListNumber
                        || prevListNumber + 2 === currentListNumber) {
                        convertList = true;
                    }
                }
            }
            if (convertList) {
                previousList = this.viewer.getListById(prevParagraph.paragraphFormat.listFormat.listId);
            }
        }
        return previousList;
    };
    Editor.prototype.getNumber = function (roman) {
        var conversion = { 'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1 };
        var arr = roman.split('');
        var num = 0;
        for (var i = 0; i < arr.length; i++) {
            var currentValue = conversion[arr[i]];
            var nextValue = conversion[arr[i + 1]];
            if (currentValue < nextValue) {
                num -= (currentValue);
            }
            else {
                num += (currentValue);
            }
        }
        return num;
    };
    Editor.prototype.getListLevelPattern = function (value) {
        switch (value) {
            case '0':
            case '1':
                return 'Arabic';
            case 'I':
                return 'UpRoman';
            case 'i':
                return 'LowRoman';
            case 'A':
                return 'UpLetter';
            case 'a':
                return 'LowLetter';
            case '*':
            case '-':
                return 'Bullet';
            case '00':
            case '01':
                return 'LeadingZero';
            default:
                return 'None';
        }
    };
    Editor.prototype.autoConvertList = function (selection, listLevel) {
        var start = selection.start;
        if (!selection.isForward) {
            start = selection.end;
        }
        var newList = new WList();
        if (this.viewer.lists.length > 0) {
            newList.listId = this.viewer.lists[this.viewer.lists.length - 1].listId + 1;
        }
        else {
            newList.listId = 0;
        }
        var newAbstractList = new WAbstractList();
        var layout = this.viewer;
        if (layout.abstractLists.length > 0) {
            newAbstractList.abstractListId = layout.abstractLists[layout.abstractLists.length - 1].abstractListId + 1;
        }
        else {
            newAbstractList.abstractListId = 0;
        }
        newList.abstractListId = newAbstractList.abstractListId;
        newList.abstractList = newAbstractList;
        layout.abstractLists.push(newAbstractList);
        newAbstractList.levels.push(listLevel);
        listLevel.ownerBase = newAbstractList;
        selection.paragraphFormat.setList(newList);
        selection.paragraphFormat.listLevelNumber = 0;
    };
    Editor.prototype.checkNumberFormat = function (numberFormat, isBullet, text) {
        if (isBullet) {
            return numberFormat === '';
        }
        else {
            var index = text.indexOf(numberFormat);
            return (numberFormat === '.' || numberFormat === ')'
                || numberFormat === '>' || numberFormat === '-') && text.substring(index, text.length - 1) === '';
        }
    };
    Editor.prototype.checkLeadingZero = function (text) {
        var j;
        var isZero = false;
        for (var i = 0; i <= text.length - 1; i++) {
            if (text.charAt(i) === '0') {
                isZero = true;
                continue;
            }
            j = i;
            break;
        }
        var numberFormat = undefined;
        if (text.charAt(j) === '1') {
            numberFormat = text.charAt(j + 1);
        }
        else {
            numberFormat = text.charAt(j);
        }
        return isZero && this.checkNumberFormat(numberFormat, false, text);
    };
    Editor.prototype.getPageFromBlockWidget = function (block) {
        var page = undefined;
        if (block.containerWidget instanceof BodyWidget) {
            page = block.containerWidget.page;
        }
        else if (block.containerWidget instanceof HeaderFooterWidget) {
            page = block.containerWidget.page;
        }
        else if (block.containerWidget instanceof TableCellWidget) {
            page = block.containerWidget.bodyWidget.page;
        }
        return page;
    };
    /**
     * @private
     */
    Editor.prototype.insertTextInline = function (element, selection, text, index) {
        if (element instanceof TextElementBox) {
            element.text = HelperMethods.insert(element.text, index, text);
            var paragraph = element.line.paragraph;
            var lineIndex = paragraph.childWidgets.indexOf(element.line);
            var elementIndex = element.line.children.indexOf(element);
            if (element.line.paragraph.bidi) {
                this.viewer.layout.reArrangeElementsForRtl(element.line, element.line.paragraph.bidi);
            }
            this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, elementIndex, element.line.paragraph.bidi);
        }
        else if (element instanceof ImageElementBox) {
            this.insertImageText(element, selection, text, index);
        }
        else if (element instanceof FieldElementBox) {
            if (element.fieldType === 0) {
                this.insertFieldBeginText(element, selection, text, index);
            }
            else if (element.fieldType === 2) {
                this.insertFieldSeparatorText(element, selection, text, index);
            }
            else {
                this.insertFieldEndText(element, selection, text, index);
            }
        }
        else if (element instanceof BookmarkElementBox) {
            this.insertBookMarkText(element, selection, text, index);
        }
    };
    Editor.prototype.insertFieldBeginText = function (fieldBegin, selection, text, index) {
        var spanObj = new TextElementBox();
        spanObj.text = text;
        var lineIndex = fieldBegin.line.paragraph.childWidgets.indexOf(fieldBegin.line);
        var spanIndex = fieldBegin.line.children.indexOf(fieldBegin);
        spanObj.characterFormat.copyFormat(fieldBegin.characterFormat);
        fieldBegin.line.children.splice(spanIndex, 0, spanObj);
        spanObj.line = fieldBegin.line;
        this.viewer.layout.reLayoutParagraph(fieldBegin.line.paragraph, lineIndex, spanIndex);
    };
    Editor.prototype.insertBookMarkText = function (element, selection, text, index) {
        var spanObj = new TextElementBox();
        spanObj.text = text;
        var lineIndex = element.line.paragraph.childWidgets.indexOf(element.line);
        var spanIndex = element.line.children.indexOf(element);
        spanObj.characterFormat.copyFormat(element.characterFormat);
        element.line.children.splice(spanIndex, 0, spanObj);
        spanObj.line = element.line;
        this.viewer.layout.reLayoutParagraph(element.line.paragraph, lineIndex, spanIndex);
    };
    Editor.prototype.insertFieldSeparatorText = function (fieldSeparator, selection, text, index) {
        var previousInline = selection.getPreviousTextInline(fieldSeparator);
        var nextInline = selection.getNextTextInline(fieldSeparator);
        var span = new TextElementBox();
        span.text = text;
        var spanIndex = fieldSeparator.line.children.indexOf(fieldSeparator);
        if (index === fieldSeparator.length) {
            spanIndex++;
        }
        if (isNullOrUndefined(previousInline) && isNullOrUndefined(nextInline)) {
            span.characterFormat.copyFormat(fieldSeparator.line.paragraph.characterFormat);
        }
        else if (isNullOrUndefined(previousInline)) {
            span.characterFormat.copyFormat(nextInline.characterFormat);
        }
        else {
            span.characterFormat.copyFormat(previousInline.characterFormat);
        }
        fieldSeparator.line.children.splice(spanIndex, 0, span);
        span.line = fieldSeparator.line;
        var lineIndex = fieldSeparator.line.paragraph.childWidgets.indexOf(fieldSeparator.line);
        this.viewer.layout.reLayoutParagraph(fieldSeparator.line.paragraph, lineIndex, spanIndex);
    };
    Editor.prototype.insertFieldEndText = function (fieldEnd, selection, text, index) {
        var span = new TextElementBox();
        span.text = text;
        var spanIndex = fieldEnd.line.children.indexOf(fieldEnd);
        span.characterFormat.copyFormat(fieldEnd.characterFormat);
        fieldEnd.line.children.splice(spanIndex + 1, 0, span);
        span.line = fieldEnd.line;
        var lineIndex = fieldEnd.line.paragraph.childWidgets.indexOf(fieldEnd.line);
        this.viewer.layout.reLayoutParagraph(fieldEnd.line.paragraph, lineIndex, spanIndex);
    };
    Editor.prototype.insertImageText = function (image, selection, text, index) {
        var previousInlineObj = selection.getPreviousTextInline(image);
        var nextInlineObj = selection.getNextTextInline(image);
        var line = image.line;
        var element = new TextElementBox();
        var paragraph = line.paragraph;
        var lineIndex = paragraph.childWidgets.indexOf(line);
        element.text = text;
        var spanIndex = line.children.indexOf(image);
        if (index === image.length) {
            spanIndex++;
        }
        if (isNullOrUndefined(previousInlineObj) && isNullOrUndefined(nextInlineObj)) {
            element.characterFormat.copyFormat(paragraph.characterFormat);
        }
        else if (isNullOrUndefined(previousInlineObj)) {
            element.characterFormat.copyFormat(nextInlineObj.characterFormat);
        }
        else {
            element.characterFormat.copyFormat(previousInlineObj.characterFormat);
        }
        line.children.splice(spanIndex, 0, element);
        element.line = line;
        this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, spanIndex);
    };
    /**
     * @private
     */
    Editor.prototype.isListTextSelected = function () {
        if (this.viewer.isListTextSelected) {
            this.initComplexHistory('ListSelect');
            // tslint:disable-next-line:max-line-length
            if (this.viewer.selection.start.paragraph.paragraphFormat.listFormat && this.viewer.selection.start.paragraph.paragraphFormat.listFormat.listId !== -1) {
                this.onApplyList(undefined);
            }
        }
    };
    //Auto Format and insert Hyperlink Implementation starts
    Editor.prototype.checkAndConvertToHyperlink = function (selection, isEnter, paragraph) {
        var text;
        var span;
        if (isEnter) {
            span = paragraph.lastChild.children[paragraph.lastChild.children.length - 1];
            text = span.text;
        }
        else {
            var indexInInline = 0;
            var inlineObj = selection.start.currentWidget.getInline(selection.start.offset - 1, indexInInline);
            var inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!(inline instanceof TextElementBox)) {
                return;
            }
            span = inline;
            text = span.text.substring(0, indexInInline);
        }
        var index = 0;
        var tabCharIndex = text.lastIndexOf('\t');
        index = (tabCharIndex >= 0) ? tabCharIndex + 1 : text.lastIndexOf(' ') + 1;
        while (span.previousNode instanceof TextElementBox && index === 0) {
            span = span.previousNode;
            var previousText = span.text;
            tabCharIndex = previousText.lastIndexOf('\t');
            index = (tabCharIndex >= 0) ? tabCharIndex + 1 : previousText.lastIndexOf(' ') + 1;
            text = span.text + text;
        }
        text = text.substring(index);
        var lowerCaseText = text.toLowerCase();
        var containsURL = false;
        if (lowerCaseText.substring(0, 8) === 'file:///'
            || (lowerCaseText.substring(0, 7) === 'http://' && lowerCaseText.length > 7)
            || (lowerCaseText.substring(0, 8) === 'https://' && lowerCaseText.length > 8)
            || (lowerCaseText.substring(0, 4) === 'www.' && lowerCaseText.length > 4)
            || (lowerCaseText.substring(0, 3) === '\\' && lowerCaseText.length > 3)
            || (lowerCaseText.substring(0, 7) === 'mailto:' && lowerCaseText.length > 7)) {
            containsURL = true;
            if (lowerCaseText.substring(0, 4) === 'www.' && lowerCaseText.length > 4) {
                text = 'http://' + text;
            }
        }
        else {
            var atIndex = text.indexOf('@');
            var dotIndex = text.indexOf('.');
            if (atIndex > 0 && atIndex < dotIndex && dotIndex < text.length - 1) {
                containsURL = true;
                text = 'mailto:' + text;
            }
        }
        if (containsURL) {
            var startPos = new TextPosition(this.viewer.owner);
            startPos.setPositionParagraph(span.line, span.line.getOffset(span, index));
            var endPos = new TextPosition(this.viewer.owner);
            if (isEnter) {
                endPos.setPositionParagraph(span.line, span.line.getEndOffset());
            }
            else {
                if (selection.end.currentWidget.children.length === 0 && selection.end.offset === 0) {
                    var prevLine = selection.end.currentWidget.previousLine;
                    endPos.setPositionParagraph(prevLine, prevLine.getEndOffset());
                }
                else {
                    endPos.setPositionParagraph(selection.end.currentWidget, selection.end.offset - 1);
                }
            }
            this.autoFormatHyperlink(selection, text, startPos, endPos);
        }
    };
    Editor.prototype.autoFormatHyperlink = function (selection, url, startPosition, endPosition) {
        this.initComplexHistory('AutoFormatHyperlink');
        var blockInfo = this.selection.getParagraphInfo(startPosition);
        var start = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.editorHistory.currentHistoryInfo.insertPosition = start;
        }
        // Moves the selection to URL text start and end position.
        selection.start.setPositionInternal(startPosition);
        selection.end.setPositionInternal(endPosition);
        // Preserves the character format for hyperlink field.
        var temp = this.getCharacterFormat(selection);
        var format = new WCharacterFormat();
        format.copyFormat(temp);
        var fieldEnd = this.createHyperlinkElement(url, startPosition, endPosition, format);
        // Moves the selection to the end of field end position.
        selection.start.setPositionParagraph(fieldEnd.line, (fieldEnd.line).getOffset(fieldEnd, 1));
        // Moves to next text position. (To achieve common behavior for space and enter).
        selection.start.moveNextPosition();
        selection.end.setPositionInternal(selection.start);
        blockInfo = this.selection.getParagraphInfo(selection.end);
        var end = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.editorHistory.currentHistoryInfo.endPosition = end;
            this.editorHistory.updateComplexHistory();
            this.reLayout(selection);
        }
        else {
            this.updateComplexWithoutHistory(0, start, end);
        }
    };
    Editor.prototype.appylingHyperlinkFormat = function (selection) {
        this.initHistory('Underline');
        this.updateCharacterFormatWithUpdate(selection, 'underline', 'Single', false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.reLayout(selection, false);
        // Applies font color for field result.
        this.initHistory('FontColor');
        this.updateCharacterFormatWithUpdate(selection, 'fontColor', '#0563c1', false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.reLayout(selection, false);
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.createHyperlinkElement = function (url, startPosition, endPosition, format) {
        var selection = this.selection;
        this.viewer.layout.allowLayout = false;
        this.appylingHyperlinkFormat(selection);
        this.viewer.layout.allowLayout = true;
        // Adds the field end at the URL text end position.
        var fieldEnd = new FieldElementBox(1);
        fieldEnd.characterFormat.copyFormat(format);
        fieldEnd.line = selection.end.currentWidget;
        selection.start.setPositionInternal(selection.end);
        // this.insertElementInCurrentLine(selection, fieldEnd, true);
        this.initInsertInline(fieldEnd);
        // Moves the selection to URL text start position.        
        selection.start.setPositionInternal(startPosition);
        selection.end.setPositionInternal(selection.start);
        // Adds field begin, field code and field separator at the URL text start position.
        var begin = this.insertHyperlinkfield(selection, format, url);
        var lineIndex = selection.start.paragraph.childWidgets.indexOf(begin.line);
        var index = begin.line.children.indexOf(begin);
        fieldEnd.linkFieldCharacter(this.viewer);
        this.viewer.layout.reLayoutParagraph(selection.start.paragraph, lineIndex, index);
        return fieldEnd;
    };
    Editor.prototype.insertHyperlinkfield = function (selection, format, url, isBookmark) {
        // Adds field begin, field code and field separator at the URL text start position.
        var begin = new FieldElementBox(0);
        begin.characterFormat.copyFormat(format);
        begin.line = selection.start.currentWidget;
        this.initInsertInline(begin);
        var span = new TextElementBox();
        span.characterFormat.copyFormat(format);
        if (isBookmark) {
            span.text = ' HYPERLINK \\l \"' + url + '\" ';
        }
        else {
            span.text = ' HYPERLINK \"' + url + '\" ';
        }
        span.line = selection.start.currentWidget;
        this.initInsertInline(span);
        var separator = new FieldElementBox(2);
        separator.characterFormat.copyFormat(format);
        separator.line = selection.start.currentWidget;
        this.initInsertInline(separator);
        return begin;
    };
    Editor.prototype.unLinkFieldCharacter = function (inline) {
        if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            if (inline.fieldEnd) {
                if (this.viewer) {
                    this.viewer.fieldToLayout = inline;
                    this.viewer.fieldEndParagraph = inline.line.paragraph;
                }
                // inline.line.paragraph.addFieldCharacter(inline.fieldEnd);
                inline.fieldEnd = undefined;
            }
        }
        if (inline instanceof FieldElementBox && inline.fieldType === 2) {
            if (!isNullOrUndefined(inline.fieldEnd)) {
                if (this.viewer) {
                    this.viewer.fieldToLayout = inline.fieldBegin;
                    this.viewer.fieldEndParagraph = inline.line.paragraph;
                }
                inline.fieldBegin.fieldSeparator = undefined;
                inline.fieldEnd.fieldSeparator = undefined;
            }
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 1) {
            if (inline.fieldBegin) {
                if (!isNullOrUndefined(this.viewer)) {
                    this.viewer.fieldToLayout = inline.fieldBegin;
                    this.viewer.fieldEndParagraph = inline.line.paragraph;
                }
                var fieldIndex = this.viewer.fields.indexOf(inline.fieldBegin);
                if (fieldIndex !== -1) {
                    this.viewer.fields.splice(fieldIndex, 1);
                }
                inline.fieldBegin = undefined;
            }
        }
    };
    Editor.prototype.getCharacterFormat = function (selection) {
        if (selection.start.paragraph.isEmpty()) {
            return selection.start.paragraph.characterFormat;
        }
        else {
            var info = selection.start.currentWidget.getInline(selection.start.offset, 0);
            return info.element.characterFormat;
        }
    };
    /**
     * Insert Hyperlink
     * @param  {string} address - Hyperlink URL
     * @param  {string} displayText - Display text for the hyperlink
     */
    Editor.prototype.insertHyperlink = function (address, displayText) {
        if (isNullOrUndefined(displayText)) {
            displayText = address;
        }
        this.insertHyperlinkInternal(address, displayText, this.owner.selection.text !== displayText, false);
    };
    /**
     * @private
     */
    Editor.prototype.insertHyperlinkInternal = function (url, displayText, remove, isBookmark) {
        var selection = this.viewer.selection;
        if (selection.start.paragraph.associatedCell !== selection.end.paragraph.associatedCell) {
            return;
        }
        if (remove) {
            //Empty selection Hyperlink insert
            this.insertHyperlinkInternalInternal(selection, url, displayText, isBookmark);
        }
        else {
            //Non-Empty Selection- change the selected text to Field       
            // this.preservedFontCol = this.getFontColor();
            var startPosition = selection.start;
            var endPosition = selection.end;
            if (!selection.isForward) {
                startPosition = selection.end;
                endPosition = selection.start;
            }
            var fieldStartPosition = new TextPosition(this.viewer.owner);
            fieldStartPosition.setPositionInternal(startPosition);
            var temp = this.getCharacterFormat(selection);
            var format = new WCharacterFormat(undefined);
            format.copyFormat(temp);
            this.initComplexHistory('InsertHyperlink');
            var blockInfo = this.selection.getParagraphInfo(startPosition);
            var start = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
                // tslint:disable-next-line:max-line-length
                this.editorHistory.currentHistoryInfo.insertPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            }
            this.appylingHyperlinkFormat(selection);
            this.viewer.layout.allowLayout = true;
            startPosition.setPositionInternal(endPosition);
            // Adds the field end at the URL text end position.
            var fieldEnd = new FieldElementBox(1);
            fieldEnd.characterFormat.copyFormat(format);
            fieldEnd.line = selection.end.currentWidget;
            startPosition.setPositionInternal(endPosition);
            // this.insertElementInCurrentLine(selection, fieldEnd, true);
            this.initInsertInline(fieldEnd);
            // Moves the selection to URL text start position.        
            startPosition.setPositionInternal(fieldStartPosition);
            endPosition.setPositionInternal(startPosition);
            // Adds field begin, field code and field separator at the URL text start position.
            var begin = this.insertHyperlinkfield(selection, format, url, isBookmark);
            fieldEnd.linkFieldCharacter(this.viewer);
            var lineIndex = selection.start.paragraph.childWidgets.indexOf(begin.line);
            var index = begin.line.children.indexOf(begin);
            this.viewer.layout.reLayoutParagraph(selection.start.paragraph, lineIndex, index);
            var lineWidget = fieldEnd.line;
            selection.selects(lineWidget, lineWidget.getOffset(fieldEnd, fieldEnd.length), true);
            blockInfo = this.selection.getParagraphInfo(endPosition);
            var end = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
                // tslint:disable-next-line:max-line-length
                this.editorHistory.currentHistoryInfo.endPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
                this.editorHistory.updateComplexHistory();
            }
            else {
                this.updateComplexWithoutHistory(1, start, end);
            }
        }
    };
    Editor.prototype.insertHyperlinkInternalInternal = function (selection, url, displayText, isBookmark) {
        if (isNullOrUndefined(selection.start)) {
            return;
        }
        if (this.editHyperlink(selection, url, displayText)) {
            return;
        }
        this.initHistory('InsertHyperlink');
        var isRemoved = true;
        if (!selection.isEmpty) {
            isRemoved = this.removeSelectedContents(selection);
        }
        if (isRemoved) {
            // Preserves the character format for hyperlink field.
            var temp = this.getCharacterFormat(selection);
            var format = new WCharacterFormat();
            format.copyFormat(temp);
            this.insertHyperlinkByFormat(selection, url, displayText, format, isBookmark);
        }
        //else
        //    this.Select(Start, true);
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.insertHyperlinkByFormat = function (selection, url, displayText, format, isBookmark) {
        this.updateInsertPosition();
        selection.owner.isShiftingEnabled = true;
        var element = [];
        var fieldBegin = new FieldElementBox(0);
        element.push(fieldBegin);
        var span = new TextElementBox();
        if (isBookmark) {
            span.text = ' HYPERLINK \\l \"' + url + '\" ';
        }
        else {
            span.text = ' HYPERLINK \"' + url + '\" ';
        }
        element.push(span);
        var fieldSeparator = new FieldElementBox(2);
        element.push(fieldSeparator);
        if (!isNullOrUndefined(displayText) && displayText !== '') {
            span = new TextElementBox();
            span.characterFormat.underline = 'Single';
            span.characterFormat.fontColor = '#0563c1';
            span.text = displayText;
            element.push(span);
        }
        var fieldEnd = new FieldElementBox(1);
        element.push(fieldEnd);
        this.insertElement(element);
        var paragraph = selection.start.paragraph;
        fieldEnd.linkFieldCharacter(this.viewer);
        if (this.viewer.fields.indexOf(fieldBegin) === -1) {
            this.viewer.fields.push(fieldBegin);
        }
        var offset = fieldEnd.line.getOffset(fieldEnd, 1);
        selection.selects(fieldEnd.line, fieldEnd.line.getOffset(fieldEnd, fieldEnd.length), true);
        this.updateEndPosition();
        this.reLayout(selection, true);
    };
    Editor.prototype.initInsertInline = function (element, insertHyperlink) {
        this.initHistory('InsertInline');
        this.insertInlineInSelection(this.viewer.selection, element);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
    };
    /**
     * @private
     */
    Editor.prototype.insertElementInCurrentLine = function (selection, inline) {
        if (this.checkIsNotRedoing()) {
            selection.owner.isShiftingEnabled = true;
        }
        if (!selection.isEmpty) {
            this.removeSelectedContents(selection);
        }
        this.updateInsertPosition();
        this.insertElement([inline]);
        if (this.checkEndPosition(selection)) {
            this.updateHistoryPosition(selection.start, false);
        }
        this.fireContentChange();
    };
    /**
     * Edit Hyperlink
     * @param  {Selection} selection
     * @param  {string} url
     * @param  {string} displayText
     * @private
     */
    Editor.prototype.editHyperlink = function (selection, url, displayText, isBookmark) {
        var fieldBegin = selection.getHyperlinkField();
        if (isNullOrUndefined(fieldBegin)) {
            return false;
        }
        this.initHistory('InsertHyperlink');
        this.editHyperlinkInternal = isNullOrUndefined(this.editorHistory)
            || (this.editorHistory && isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo));
        var fieldResult = '';
        var isNestedField = false;
        // Preserves the character format for hyperlink field.
        var temp = this.getCharacterFormat(selection);
        var format = new WCharacterFormat();
        format.copyFormat(temp);
        var fieldSeparator = undefined;
        if (!isNullOrUndefined(fieldBegin.fieldSeparator)) {
            fieldSeparator = fieldBegin.fieldSeparator;
            // tslint:disable-next-line:max-line-length
            var fieldObj = selection.getHyperlinkDisplayText(fieldBegin.fieldSeparator.line.paragraph, fieldBegin.fieldSeparator, fieldBegin.fieldEnd, isNestedField, format);
            fieldResult = fieldObj.displayText;
            isNestedField = fieldObj.isNestedField;
            format = fieldObj.format;
        }
        var offset = fieldBegin.line.getOffset(fieldBegin, 0);
        selection.start.setPositionParagraph(fieldBegin.line, offset);
        offset = fieldBegin.fieldEnd.line.getOffset(fieldBegin.fieldEnd, 1);
        selection.end.setPositionParagraph(fieldBegin.fieldEnd.line, offset);
        this.deleteSelectedContents(selection, false);
        if (!isNestedField && fieldResult !== displayText || isNullOrUndefined(fieldSeparator)) {
            this.insertHyperlinkByFormat(selection, url, displayText, format, isBookmark);
        }
        else {
            //Modify the new hyperlink url. Inserts field begin, url and field separator.
            this.updateInsertPosition();
            var newFieldBegin = new FieldElementBox(0);
            newFieldBegin.characterFormat.copyFormat(fieldBegin.characterFormat);
            newFieldBegin.line = selection.start.currentWidget;
            this.insertInlineInternal(newFieldBegin);
            var span = new TextElementBox();
            span.characterFormat.copyFormat(fieldBegin.characterFormat);
            if (isBookmark) {
                span.text = ' HYPERLINK \\l \"' + url + '\" ';
            }
            else {
                span.text = ' HYPERLINK \"' + url + '\" ';
            }
            span.line = selection.start.currentWidget;
            this.insertInlineInternal(span);
            var nodes = this.editorHistory && this.editorHistory.currentBaseHistoryInfo ?
                this.editorHistory.currentBaseHistoryInfo.removedNodes : this.nodes;
            this.insertClonedFieldResult(selection, nodes, fieldSeparator);
            var fieldEnd = selection.end.currentWidget.getInline(selection.end.offset, 0).element;
            fieldEnd.linkFieldCharacter(this.viewer);
            var paragraph = newFieldBegin.line.paragraph;
            var lineIndex = newFieldBegin.line.paragraph.childWidgets.indexOf(newFieldBegin.line);
            var elementIndex = newFieldBegin.line.children.indexOf(newFieldBegin);
            this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, elementIndex);
            selection.selects(newFieldBegin.fieldEnd.line, offset, true);
            this.updateEndPosition();
            this.reLayout(selection, true);
        }
        this.editHyperlinkInternal = false;
        this.nodes = [];
        return true;
    };
    /* tslint:disable:no-any */
    Editor.prototype.insertClonedFieldResult = function (selection, nodes, fieldSeparator) {
        var isStarted = false;
        for (var i = nodes.length - 1; i > -1; i--) {
            var node = nodes[i];
            /* tslint:enable:no-any */
            if (!isStarted) {
                if (fieldSeparator === node) {
                    isStarted = true;
                }
                else {
                    if (node instanceof ParagraphWidget && node === fieldSeparator.line.paragraph) {
                        isStarted = true;
                        var paragraph = undefined;
                        if (i === nodes.length - 1) {
                            paragraph = selection.start.paragraph;
                            var fieldParagraph = fieldSeparator.line.paragraph;
                            this.getClonedFieldResultWithSel(fieldParagraph, selection, fieldSeparator);
                        }
                        else {
                            paragraph = this.getClonedFieldResult(fieldSeparator.line.paragraph, fieldSeparator);
                            this.insertParagraph(paragraph, true);
                        }
                        selection.selectParagraphInternal(selection.getNextParagraphBlock(paragraph), true);
                    }
                    continue;
                }
            }
            if (node instanceof ElementBox) {
                this.insertInlineInternal(node.clone());
            }
            else if (node instanceof BlockWidget) {
                this.insertBlock(node.clone());
            }
            // else if (node instanceof WSection)
            //     editor.insertSection((node as WSection)._Clone());
        }
    };
    Editor.prototype.getClonedFieldResultWithSel = function (paragraph, selection, fieldSeparator) {
        var lineIndex = paragraph.childWidgets.indexOf(fieldSeparator.line);
        var elementIndex = paragraph.childWidgets[lineIndex].children.indexOf(fieldSeparator);
        for (var j = lineIndex; j < paragraph.childWidgets.length; j++) {
            var lineWidget = paragraph.childWidgets[j];
            if (j !== lineIndex) {
                elementIndex = 0;
            }
            for (var i = elementIndex; i < lineWidget.children.length; i++) {
                this.insertInlineInternal(lineWidget.children[i].clone());
            }
        }
    };
    Editor.prototype.getClonedFieldResult = function (curParagraph, fieldSeparator) {
        var paragraph = new ParagraphWidget();
        paragraph.characterFormat.copyFormat(curParagraph.characterFormat);
        paragraph.paragraphFormat.copyFormat(curParagraph.paragraphFormat);
        var lineIndex = curParagraph.childWidgets.indexOf(fieldSeparator.line);
        var elementIndex = curParagraph.childWidgets[lineIndex].children.indexOf(fieldSeparator);
        for (var j = lineIndex; j < curParagraph.childWidgets.length; j++) {
            var lineWidget = curParagraph.childWidgets[j];
            if (j !== lineIndex) {
                elementIndex = 0;
            }
            for (var i = elementIndex; i < lineWidget.children.length; i++) {
                paragraph.childWidgets[0].children.push(lineWidget.children[i]);
            }
        }
        return paragraph;
    };
    /**
     * Removes the hyperlink if selection is within hyperlink.
     */
    Editor.prototype.removeHyperlink = function () {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        var selection = this.selection;
        var fieldBegin = selection.getHyperlinkField();
        if (isNullOrUndefined(fieldBegin)) {
            return;
        }
        var fieldEnd = fieldBegin.fieldEnd;
        var fieldSeparator = fieldBegin.fieldSeparator;
        var fieldStartPosition = new TextPosition(selection.owner);
        // tslint:disable-next-line:max-line-length
        fieldStartPosition.setPositionParagraph(fieldBegin.line, (fieldBegin.line).getOffset(fieldBegin, 0));
        var fieldSeparatorPosition = new TextPosition(selection.owner);
        // tslint:disable-next-line:max-line-length
        fieldSeparatorPosition.setPositionParagraph(fieldSeparator.line, (fieldSeparator.line).getOffset(fieldSeparator, fieldSeparator.length));
        this.initComplexHistory('RemoveHyperlink');
        selection.start.setPositionParagraph(fieldEnd.line, (fieldEnd.line).getOffset(fieldEnd, 0));
        selection.end.setPositionInternal(selection.start);
        this.delete();
        selection.start.setPositionInternal(fieldSeparatorPosition);
        this.initHistory('Underline');
        this.updateCharacterFormatWithUpdate(selection, 'underline', 'None', false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        // Applies font color for field result.
        this.initHistory('FontColor');
        this.updateCharacterFormatWithUpdate(selection, 'fontColor', undefined, false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.reLayout(selection, false);
        selection.end.setPositionInternal(selection.start);
        selection.start.setPositionInternal(fieldStartPosition);
        this.initHistory('Delete');
        this.deleteSelectedContents(selection, false);
        this.reLayout(selection, true);
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
            this.editorHistory.updateComplexHistory();
        }
    };
    //Paste Implementation starts
    /**
     * Paste copied clipboard content on Paste event
     * @param  {ClipboardEvent} event
     * @param  {any} pasteWindow?
     * @private
     */
    /* tslint:disable:no-any */
    Editor.prototype.pasteInternal = function (event, pasteWindow) {
        this.currentPasteOptions = this.owner.defaultPasteOption;
        if (this.viewer.owner.enableLocalPaste) {
            this.paste();
        }
        else {
            this.selection.isViewPasteOptions = true;
            if (this.selection.pasteElement) {
                this.selection.pasteElement.style.display = 'none';
            }
            if (isNullOrUndefined(pasteWindow)) {
                pasteWindow = window;
            }
            /* tslint:enable:no-any */
            var textContent = '';
            var htmlContent = '';
            var rtfContent = '';
            var clipbordData = pasteWindow.clipboardData ? pasteWindow.clipboardData : event.clipboardData;
            if (Browser.info.name !== 'msie') {
                rtfContent = clipbordData.getData('Text/Rtf');
                htmlContent = clipbordData.getData('Text/Html');
            }
            this.copiedTextContent = textContent = clipbordData.getData('Text');
            if (rtfContent !== '') {
                this.pasteAjax(rtfContent, '.rtf');
            }
            else if (htmlContent !== '') {
                var doc = new DOMParser().parseFromString(htmlContent, 'text/html');
                var result = new XMLSerializer().serializeToString(doc);
                result = result.replace(/<!--StartFragment-->/gi, '');
                result = result.replace(/<!--EndFragment-->/gi, '');
                this.pasteAjax(result, '.html');
            }
            else if (textContent !== null && textContent !== '') {
                this.pasteContents(textContent);
                this.applyPasteOptions(this.currentPasteOptions);
                this.viewer.editableDiv.innerHTML = '';
            }
            else if (Browser.info.name !== 'msie' && clipbordData.items !== undefined && clipbordData.items.length !== 0 &&
                clipbordData.items[0].type === 'image/png') {
                this.pasteImage(clipbordData.items[0].getAsFile());
            }
            else if (Browser.info.name === 'msie' && clipbordData.files !== undefined && clipbordData.files.length !== 0 &&
                clipbordData.files[0].type === 'image/png') {
                this.pasteImage(clipbordData.files[0]);
            }
            // if (textContent !== '') {
            //     this.pasteContents(textContent);
            //     this.viewer.editableDiv.innerHTML = '';
            // }
        }
        this.viewer.updateFocus();
    };
    Editor.prototype.pasteImage = function (imgFile) {
        var _this = this;
        var fileReader = new FileReader();
        fileReader.onload = function () {
            _this.onPasteImage(fileReader.result);
        };
        fileReader.readAsDataURL(imgFile);
    };
    /**
     * @private
     */
    Editor.prototype.onPasteImage = function (data) {
        var image = document.createElement('img');
        var editor = this;
        image.addEventListener('load', function () {
            editor.insertImage(data, this.width, this.height);
        });
        image.src = data;
    };
    /**
     * @private
     */
    Editor.prototype.pasteAjax = function (content, type) {
        var proxy = this;
        /* tslint:disable:no-any */
        var formObject = {
            content: content,
            type: type
        };
        this.pasteRequestHandler = new XmlHttpRequestHandler();
        this.pasteRequestHandler.url = proxy.owner.serviceUrl + this.owner.serverActionSettings.systemClipboard;
        this.pasteRequestHandler.responseType = 'json';
        this.pasteRequestHandler.contentType = 'application/json;charset=UTF-8';
        this.pasteRequestHandler.customHeaders = proxy.owner.headers;
        this.pasteRequestHandler.send(formObject);
        showSpinner(this.owner.element);
        this.pasteRequestHandler.onSuccess = this.pasteFormattedContent.bind(this);
        this.pasteRequestHandler.onFailure = this.onPasteFailure.bind(this);
        this.pasteRequestHandler.onError = this.onPasteFailure.bind(this);
    };
    /**
     * @private
     */
    Editor.prototype.pasteFormattedContent = function (result) {
        if (this.isPasteListUpdated) {
            this.isPasteListUpdated = false;
        }
        this.pasteContents(isNullOrUndefined(result.data) ? this.copiedTextContent : result.data);
        this.applyPasteOptions(this.currentPasteOptions);
        hideSpinner(this.owner.element);
    };
    Editor.prototype.onPasteFailure = function (result) {
        console.error(result.status, result.statusText);
        hideSpinner(this.owner.element);
    };
    /**
     * Pastes provided sfdt content or the data present in local clipboard if any .
     * @param {string} sfdt? insert the specified sfdt content at current position
     */
    Editor.prototype.paste = function (sfdt, defaultPasteOption) {
        if (isNullOrUndefined(sfdt)) {
            sfdt = this.owner.enableLocalPaste ? this.copiedData : undefined;
        }
        if (!isNullOrUndefined(defaultPasteOption)) {
            this.currentPasteOptions = defaultPasteOption;
        }
        /* tslint:disable:no-any */
        if (sfdt) {
            var document_1 = JSON.parse(sfdt);
            this.pasteContents(document_1);
            this.applyPasteOptions(this.currentPasteOptions);
        }
    };
    Editor.prototype.getUniqueListOrAbstractListId = function (isList) {
        if (isList && this.viewer.lists.length) {
            var sortedList = this.viewer.lists.slice().sort(function (a, b) {
                return a.listId - b.listId;
            });
            return sortedList[sortedList.length - 1].listId + 1;
        }
        else if (this.viewer.abstractLists.length) {
            var sortedAbsList = this.viewer.abstractLists.slice().sort(function (a, b) {
                return a.abstractListId - b.abstractListId;
            });
            return sortedAbsList[sortedAbsList.length - 1].abstractListId + 1;
        }
        return 0;
    };
    Editor.prototype.checkSameLevelFormat = function (lstLevelNo, abstractList, list) {
        return abstractList.levels[lstLevelNo].listLevelPattern === list.abstractList.levels[lstLevelNo].listLevelPattern
            && abstractList.levels[lstLevelNo].numberFormat === list.abstractList.levels[lstLevelNo].numberFormat
            && (abstractList.levels[lstLevelNo].listLevelPattern === 'Bullet'
                || abstractList.levels[lstLevelNo].startAt === list.abstractList.levels[lstLevelNo].startAt);
    };
    Editor.prototype.listLevelPatternInCollection = function (lstLevelNo, listLevel) {
        return this.viewer.lists.filter(function (list) {
            return list.abstractList.levels[lstLevelNo].listLevelPattern === listLevel.listLevelPattern
                && list.abstractList.levels[lstLevelNo].numberFormat === listLevel.numberFormat
                && (listLevel.listLevelPattern === 'Bullet' || list.abstractList.levels[lstLevelNo].startAt === listLevel.startAt);
        })[0];
    };
    Editor.prototype.getBlocksToUpdate = function (blocks) {
        var blcks = [];
        for (var i = 0; i < blocks.length; i++) {
            var obj = blocks[i];
            if (obj.paragraphFormat && obj.paragraphFormat.listFormat
                && Object.keys(obj.paragraphFormat.listFormat).length > 0) {
                blcks.push(obj);
            }
            else if (obj.rows) {
                for (var j = 0; j < obj.rows.length; j++) {
                    var currentRow = obj.rows[j];
                    for (var k = 0; k < currentRow.cells.length; k++) {
                        var cell = currentRow.cells[k];
                        blcks = blcks.concat(this.getBlocksToUpdate(cell.blocks));
                    }
                }
            }
        }
        return blcks;
    };
    Editor.prototype.updateListIdForBlocks = function (blocks, abstractList, list, id, idToUpdate) {
        var update = false;
        for (var i = 0; i < blocks.length; i++) {
            var obj = blocks[i];
            if (obj.paragraphFormat && obj.paragraphFormat.listFormat
                && Object.keys(obj.paragraphFormat.listFormat).length > 0) {
                var format = obj.paragraphFormat.listFormat;
                // tslint:disable-next-line:max-line-length
                var existingList = this.listLevelPatternInCollection(format.listLevelNumber, abstractList.levels[format.listLevelNumber]);
                if (format.listId === id) {
                    if (isNullOrUndefined(existingList) && (!list || (list
                        && !this.checkSameLevelFormat(format.listLevelNumber, abstractList, list)))) {
                        update = true;
                        format.listId = idToUpdate;
                    }
                    else if (!isNullOrUndefined(existingList)
                        && this.checkSameLevelFormat(format.listLevelNumber, abstractList, existingList)) {
                        if (!format.isUpdated) {
                            format.listId = existingList.listId;
                            format.isUpdated = true;
                        }
                        update = false;
                    }
                }
            }
            else if (obj.rows) {
                for (var j = 0; j < obj.rows.length; j++) {
                    var row = obj.rows[j];
                    for (var k = 0; k < row.cells.length; k++) {
                        var cell = row.cells[k];
                        var toUpdate = this.updateListIdForBlocks(cell.blocks, abstractList, list, id, idToUpdate);
                        if (!update) {
                            update = toUpdate;
                        }
                    }
                }
            }
        }
        return update;
    };
    Editor.prototype.updatePasteContent = function (pasteContent, sectionId) {
        var uniqueListId = this.getUniqueListOrAbstractListId(true);
        if (pasteContent.lists.filter(function (obj) { return obj.listId === uniqueListId; }).length > 0) {
            var sortedPasteList = pasteContent.lists.slice().sort(function (a, b) {
                return a.listId - b.listId;
            });
            uniqueListId = sortedPasteList[sortedPasteList.length - 1].listId + 1;
        }
        var uniqueAbsLstId = this.getUniqueListOrAbstractListId(false);
        if (pasteContent.abstractLists.filter(function (obj) {
            return obj.abstractListId === uniqueAbsLstId;
        }).length > 0) {
            var sortedPasteAbsList = pasteContent.abstractLists.slice().sort(function (a, b) {
                return a.abstractListId - b.abstractListId;
            });
            uniqueAbsLstId = sortedPasteAbsList[sortedPasteAbsList.length - 1].abstractListId + 1;
        }
        var _loop_1 = function (k) {
            var list = pasteContent.lists[k];
            var abstractList = pasteContent.abstractLists.filter(function (obj) {
                return obj.abstractListId === list.abstractListId;
            })[0];
            var lstDup = this_1.viewer.lists.filter(function (obj) {
                return obj.listId === list.listId;
            });
            // tslint:disable-next-line:max-line-length
            var isUpdate = this_1.updateListIdForBlocks(pasteContent.sections[sectionId].blocks, abstractList, lstDup[0], list.listId, uniqueListId);
            if (isUpdate) {
                abstractList.abstractListId = uniqueAbsLstId;
                list.listId = uniqueListId;
                list.abstractListId = uniqueAbsLstId;
                uniqueListId++;
                uniqueAbsLstId++;
            }
            else {
                pasteContent.lists.splice(k, 1);
                pasteContent.abstractLists.splice(pasteContent.abstractLists.indexOf(abstractList), 1);
                k--;
            }
            out_k_1 = k;
        };
        var this_1 = this, out_k_1;
        for (var k = 0; k < pasteContent.lists.length; k++) {
            _loop_1(k);
            k = out_k_1;
        }
        var blocks = this.getBlocksToUpdate(pasteContent.sections[sectionId].blocks);
        for (var i = 0; i < blocks.length; i++) {
            var blck = blocks[i];
            delete blck.paragraphFormat.listFormat.isUpdated;
        }
    };
    Editor.prototype.getBlocks = function (pasteContent) {
        var widgets = [];
        if (typeof (pasteContent) === 'string') {
            var startParagraph = this.selection.start.paragraph;
            if (!this.selection.isForward) {
                startParagraph = this.selection.end.paragraph;
            }
            var arr = [];
            var txt = pasteContent;
            txt = txt.replace(/\r\n/g, '\r');
            arr = txt.split('\r');
            for (var i = 0; i < arr.length; i++) {
                var currentInline = this.selection.start.currentWidget.getInline(this.selection.start.offset, 0);
                var element = this.selection.getPreviousValidElement(currentInline.element);
                if (element !== currentInline.element) {
                    element = this.selection.getNextValidElement(currentInline.element);
                }
                var insertFormat = element && element === currentInline.element ? startParagraph.characterFormat :
                    element ? element.characterFormat : this.copyInsertFormat(startParagraph.characterFormat, false);
                var insertParaFormat = this.viewer.selection.copySelectionParagraphFormat();
                var paragraph = new ParagraphWidget();
                paragraph.paragraphFormat.copyFormat(insertParaFormat);
                var line = new LineWidget(paragraph);
                if (arr[i].length > 0) {
                    var textElement = new TextElementBox();
                    textElement.characterFormat.copyFormat(insertFormat);
                    textElement.text = arr[i];
                    line.children.push(textElement);
                    textElement.line = line;
                }
                paragraph.childWidgets.push(line);
                widgets.push(paragraph);
            }
        }
        else {
            this.viewer.owner.parser.addCustomStyles(pasteContent);
            for (var i = 0; i < pasteContent.sections.length; i++) {
                var parser = this.viewer.owner.parser;
                if (!this.isPasteListUpdated && !isNullOrUndefined(pasteContent.lists)) {
                    if (this.viewer.lists.length > 0) {
                        this.updatePasteContent(pasteContent, i);
                    }
                    this.isPasteListUpdated = true;
                    if (!isNullOrUndefined(pasteContent.abstractLists)) {
                        parser.parseAbstractList(pasteContent, this.viewer.abstractLists);
                    }
                    if (!isNullOrUndefined(pasteContent.lists)) {
                        parser.parseList(pasteContent, this.viewer.lists);
                    }
                }
                parser.parseBody(pasteContent.sections[i].blocks, widgets);
            }
        }
        if (this.currentPasteOptions === 'MergeWithExistingFormatting') {
            this.applyMergeFormat(widgets);
        }
        return widgets;
    };
    Editor.prototype.applyMergeFormat = function (widgets) {
        var startParagraph = this.selection.start.paragraph;
        var currentInline = this.selection.start.currentWidget.getInline(this.selection.start.offset, 0);
        var element = this.selection.getPreviousValidElement(currentInline.element);
        var insertFormat = element ? element.characterFormat :
            this.copyInsertFormat(startParagraph.characterFormat, false);
        var insertParaFormat = this.viewer.selection.copySelectionParagraphFormat();
        for (var i = 0; i < widgets.length; i++) {
            var widget = widgets[i];
            if (widget instanceof ParagraphWidget) {
                widget.paragraphFormat.copyFormat(insertParaFormat);
                this.applyFormatInternal(widget, insertFormat);
            }
            else {
                for (var j = 0; j < widget.childWidgets.length; j++) {
                    var row = widget.childWidgets[j];
                    for (var k = 0; k < row.childWidgets.length; k++) {
                        var cell = row.childWidgets[k];
                        for (var l = 0; l < cell.childWidgets.length; l++) {
                            this.applyFormatInternal(cell.childWidgets[l], insertFormat);
                        }
                    }
                }
            }
        }
    };
    Editor.prototype.applyFormatInternal = function (widget, insertFormat) {
        if (widget instanceof ParagraphWidget) {
            for (var j = 0; j < widget.childWidgets.length; j++) {
                var lineWidget = widget.childWidgets[j];
                for (var k = 0; k < lineWidget.children.length; k++) {
                    var inlineCharacterFormat = lineWidget.children[k].characterFormat;
                    var characterFormat = inlineCharacterFormat.cloneFormat();
                    if (isNullOrUndefined(insertFormat.uniqueCharacterFormat)) {
                        lineWidget.children[k].characterFormat = insertFormat;
                    }
                    else {
                        lineWidget.children[k].characterFormat.copyFormat(insertFormat);
                    }
                    if (characterFormat.bold) {
                        lineWidget.children[k].characterFormat.bold = characterFormat.bold;
                    }
                    if (characterFormat.italic) {
                        lineWidget.children[k].characterFormat.italic = characterFormat.italic;
                    }
                }
            }
        }
        else {
            for (var j = 0; j < widget.childWidgets.length; j++) {
                var rowWidget = widget.childWidgets[j];
                for (var k = 0; k < rowWidget.childWidgets.length; k++) {
                    var cellWidget = rowWidget.childWidgets[k];
                    for (var l = 0; l < cellWidget.childWidgets.length; l++) {
                        this.applyFormatInternal(cellWidget.childWidgets[l], insertFormat);
                    }
                }
            }
        }
    };
    Editor.prototype.applyPasteOptions = function (options) {
        if (isNullOrUndefined(this.copiedContent) || this.copiedTextContent === '') {
            return;
        }
        this.isSkipHistory = true;
        this.currentPasteOptions = options;
        this.selection.start.setPositionInternal(this.pasteTextPosition.startPosition);
        this.selection.end.setPositionInternal(this.pasteTextPosition.endPosition);
        switch (options) {
            case 'KeepSourceFormatting':
                this.pasteContents(this.copiedContent !== '' ? this.copiedContent : this.copiedTextContent);
                break;
            case 'MergeWithExistingFormatting':
                var start = this.selection.isForward ? this.selection.start : this.selection.end;
                var currentFormat = start.paragraph.paragraphFormat;
                this.pasteContents(this.copiedContent !== '' ? this.copiedContent : this.copiedTextContent, currentFormat);
                break;
            case 'KeepTextOnly':
                this.pasteContents(this.copiedTextContent);
                break;
        }
        this.isSkipHistory = false;
    };
    Editor.prototype.pasteContents = function (content, currentFormat) {
        if (typeof (content) !== 'string') {
            this.copiedContent = content;
        }
        this.pasteContentsInternal(this.getBlocks(content), currentFormat);
    };
    Editor.prototype.pasteContentsInternal = function (widgets, currentFormat) {
        this.isPaste = true;
        /* tslint:enable:no-any */
        var selection = this.viewer.selection;
        var isRemoved = true;
        if (!this.isSkipHistory) {
            this.initComplexHistory('Paste');
        }
        if (this.viewer.isListTextSelected) {
            var paragraph = selection.start.paragraph;
            if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId !== -1) {
                this.onApplyList(undefined);
            }
        }
        if (!this.isSkipHistory) {
            this.initHistory('Paste');
        }
        if (!selection.isEmpty || this.viewer.isListTextSelected) {
            isRemoved = this.removeSelectedContentInternal(selection, selection.start, selection.end);
        }
        if (isRemoved) {
            this.pasteContent(widgets, currentFormat);
        }
        else if (this.editorHistory) {
            this.editorHistory.currentBaseHistoryInfo = undefined;
        }
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.editorHistory.updateHistory();
            this.editorHistory.updateComplexHistory();
        }
        else {
            this.reLayout(selection, selection.isEmpty);
        }
        this.isPaste = false;
    };
    /* tslint:disable:no-any */
    Editor.prototype.pasteContent = function (widgets, currentFormat) {
        /* tslint:enable:no-any */
        this.viewer.owner.isShiftingEnabled = true;
        var insertPosition = '';
        this.updateInsertPosition();
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            insertPosition = this.editorHistory.currentBaseHistoryInfo.insertPosition;
        }
        else {
            var position = this.selection.start;
            if (!this.selection.isForward) {
                position = this.selection.end;
            }
            var blockInfo = this.selection.getParagraphInfo(position);
            insertPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        }
        this.viewer.owner.isLayoutEnabled = true;
        this.viewer.owner.isPastingContent = true;
        this.pasteCopiedData(widgets, currentFormat);
        var endPosition = '';
        this.updateEndPosition();
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            endPosition = this.editorHistory.currentBaseHistoryInfo.endPosition;
        }
        else {
            var blockInfo = this.selection.getParagraphInfo(this.selection.start);
            endPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        }
        var startPosition = new TextPosition(this.viewer.owner);
        this.setPositionForCurrentIndex(startPosition, insertPosition);
        var end = new TextPosition(this.viewer.owner);
        this.setPositionForCurrentIndex(end, endPosition);
        this.pasteTextPosition = { startPosition: startPosition, endPosition: end };
        this.viewer.owner.isPastingContent = false;
        this.viewer.selection.fireSelectionChanged(true);
    };
    Editor.prototype.pasteCopiedData = function (widgets, currentFormat) {
        if (this.viewer.layout.isBidiReLayout) {
            this.viewer.layout.isBidiReLayout = false;
        }
        for (var j = 0; j < widgets.length; j++) {
            var widget = widgets[j];
            if (widget instanceof ParagraphWidget && widget.childWidgets.length === 0) {
                widget.childWidgets[0] = new LineWidget(widget);
            }
            if (widget instanceof ParagraphWidget && !isNullOrUndefined(currentFormat)) {
                widget.paragraphFormat.copyFormat(currentFormat);
                var insertFormat = this.copyInsertFormat(this.selection.start.paragraph.characterFormat, false);
                widget.characterFormat.mergeFormat(insertFormat);
            }
            if (j === widgets.length - 1 && widget instanceof ParagraphWidget) {
                var newParagraph = widget;
                if (newParagraph.childWidgets.length > 0
                    && newParagraph.childWidgets[0].children.length > 0) {
                    var insertPosition = this.selection.start;
                    if ((insertPosition.paragraph.paragraphFormat.textAlignment === 'Center'
                        || insertPosition.paragraph.paragraphFormat.textAlignment === 'Right') &&
                        insertPosition.paragraph.paragraphFormat.listFormat.listId === -1) {
                        insertPosition.paragraph.x = this.viewer.clientActiveArea.x;
                    }
                    this.insertElement(newParagraph.childWidgets[0].children, newParagraph.paragraphFormat);
                }
            }
            else if (widget instanceof BlockWidget) {
                var startParagraph = this.selection.start.paragraph;
                if (widget instanceof TableWidget && startParagraph.isInsideTable) {
                    var table = widget;
                    //Handled to resize table based on parent cell width.
                    var clientWidth = startParagraph.getContainerWidth();
                    table.fitCellsToClientArea(clientWidth);
                }
                if (widget instanceof TableWidget && startParagraph.isEmpty()
                    && startParagraph.previousWidget instanceof TableWidget) {
                    this.insertTableRows(widget, startParagraph.previousWidget);
                }
                else {
                    this.insertBlockInternal(widget);
                }
            }
        }
    };
    /**
     * Insert Table on undo
     * @param  {WTable} table
     * @param  {WTable} newTable
     * @param  {boolean} moveRows
     * @private
     */
    Editor.prototype.insertTableInternal = function (table, newTable, moveRows) {
        //Gets the index of current table.
        var insertIndex = table.getIndex();
        if (moveRows) {
            //Moves the rows to table.
            for (var i = 0, index = 0; i < table.childWidgets.length; i++, index++) {
                var row = table.childWidgets[i];
                newTable.childWidgets.splice(index, 0, row);
                row.containerWidget = newTable;
                table.childWidgets.splice(i, 1);
                i--;
            }
        }
        var owner = table.containerWidget;
        this.removeBlock(table, true);
        //Inserts table in the current table position.        
        var blockAdvCollection = owner.childWidgets;
        blockAdvCollection.splice(insertIndex, 0, newTable);
        newTable.index = table.index;
        table.containerWidget = undefined;
        newTable.containerWidget = owner;
        this.viewer.layout.clearTableWidget(newTable, true, true, true);
        newTable.buildTableColumns();
        newTable.isGridUpdated = true;
        this.updateNextBlocksIndex(newTable, true);
        this.viewer.layout.linkFieldInTable(newTable);
        this.viewer.layout.layoutBodyWidgetCollection(newTable.index, owner, newTable, false);
    };
    /**
     * Insert Table on undo
     * @param  {Selection} selection
     * @param  {WBlock} block
     * @param  {WTable} table
     * @private
     */
    Editor.prototype.insertBlockTable = function (selection, block, table) {
        var offset = selection.start.offset;
        var lineIndex = selection.start.paragraph.childWidgets.indexOf(selection.start.currentWidget);
        if (block instanceof ParagraphWidget && offset > 0) {
            //Moves the inline items before selection start to the inserted paragraph.
            // tslint:disable-next-line:max-line-length
            this.moveInlines(selection.start.paragraph, block, 0, 0, selection.start.paragraph.firstChild, offset, selection.start.currentWidget);
            selection.selectParagraphInternal(selection.start.paragraph, true);
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(this.selection.getHierarchicalIndex(block, offset.toString()), true);
            }
        }
        if (offset > 0 && this.checkInsertPosition(selection)) {
            this.updateHistoryPosition(selection.start, true);
        }
        var index = table.indexInOwner;
        table.containerWidget.childWidgets.splice(index, 0, block);
        block.containerWidget = table.containerWidget;
        block.index = table.index;
        this.updateNextBlocksIndex(block, true);
        this.viewer.layout.layoutBodyWidgetCollection(block.index, block.containerWidget, block, false);
        if (this.checkInsertPosition(selection)) {
            var paragraph = undefined;
            if (block instanceof ParagraphWidget) {
                paragraph = block;
            }
            if (block instanceof TableWidget) {
                paragraph = selection.getFirstParagraphInFirstCell(block);
            }
            this.updateHistoryPosition(this.selection.getHierarchicalIndex(paragraph, '0'), true);
        }
    };
    /**
     * On cut handle selected content remove and relayout
     * @param  {Selection} selection
     * @param  {TextPosition} startPosition
     * @param  {TextPosition} endPosition
     * @private
     */
    Editor.prototype.handleCut = function (selection) {
        var startPosition = selection.start;
        var endPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        // this.owner.isShiftingEnabled = true;
        var blockInfo = this.selection.getParagraphInfo(startPosition);
        selection.editPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        if (startPosition.paragraph === endPosition.paragraph && startPosition.offset + 1 === endPosition.offset) {
            //Gets selected image and copy image to clipboard.
            var index = 0;
            var currentInline = startPosition.paragraph.getInline(endPosition.offset, index);
            var inline = currentInline.element;
            
        }
        this.initHistory('Cut');
        selection.owner.isShiftingEnabled = true;
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(selection.editPosition, true);
            }
        }
        this.deleteSelectedContent(endPosition.paragraph, selection, startPosition, endPosition, 3);
        var textPosition = new TextPosition(selection.owner);
        this.setPositionForCurrentIndex(textPosition, selection.editPosition);
        selection.selectContent(textPosition, true);
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            if (this.checkEndPosition(selection)) {
                this.updateHistoryPosition(selection.end, false);
            }
        }
        this.reLayout(selection);
    };
    Editor.prototype.insertInlineInternal = function (element) {
        var selection = this.selection;
        var length = element.length;
        var paragraphInfo = this.selection.getParagraphInfo(selection.start);
        if (selection.start.paragraph.isEmpty()) {
            var paragraph = selection.start.paragraph;
            if ((paragraph.paragraphFormat.textAlignment === 'Center' || paragraph.paragraphFormat.textAlignment === 'Right')
                && paragraph.paragraphFormat.listFormat.listId === -1) {
                paragraph.x = this.viewer.clientActiveArea.x;
            }
            paragraph.childWidgets[0].children.push(element);
            element.line = paragraph.childWidgets[0];
            element.linkFieldCharacter(this.viewer);
            this.viewer.layout.reLayoutParagraph(paragraph, 0, 0);
        }
        else {
            var indexInInline = 0;
            var inlineObj = selection.start.currentWidget.getInline(selection.start.offset, indexInInline);
            var curInline = inlineObj.element;
            indexInInline = inlineObj.index;
            this.insertElementInternal(curInline, element, indexInInline, true);
        }
        this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + length, true);
    };
    Editor.prototype.insertElement = function (element, paragraphFormat) {
        var selection = this.selection;
        var length = 0;
        var paragraph = undefined;
        var lineIndex = -1;
        var lineWidget = undefined;
        var insertIndex = 0;
        var paragraphInfo = this.selection.getParagraphInfo(selection.start);
        if (selection.start.paragraph.isEmpty()) {
            paragraph = selection.start.paragraph;
            lineWidget = paragraph.childWidgets[0];
            lineIndex = 0;
        }
        else {
            var indexInInline = 0;
            var bidi = selection.start.paragraph.paragraphFormat.bidi;
            var inlineObj = selection.start.currentWidget.getInline(selection.start.offset, indexInInline, bidi);
            var curInline = inlineObj.element;
            indexInInline = inlineObj.index;
            paragraph = curInline.line.paragraph;
            lineIndex = paragraph.childWidgets.indexOf(curInline.line);
            insertIndex = curInline.indexInOwner;
            lineWidget = curInline.line;
            var isRtl = false;
            if (curInline instanceof TextElementBox) {
                isRtl = this.viewer.textHelper.getRtlLanguage(curInline.text).isRtl;
            }
            if (indexInInline === curInline.length) { // Add new Element in current 
                if (!bidi) {
                    insertIndex++;
                }
            }
            else if (indexInInline === 0) {
                if (isRtl && bidi && this.isInsertField) {
                    insertIndex++;
                }
                else if (isNullOrUndefined(curInline.previousNode)) {
                    insertIndex = 0;
                }
            }
            else {
                insertIndex++;
                var prevElement = new TextElementBox();
                prevElement.characterFormat.copyFormat(curInline.characterFormat);
                if (bidi && this.isInsertField && isRtl) {
                    prevElement.text = curInline.text.slice(0, indexInInline);
                    curInline.text = curInline.text.substring(indexInInline);
                }
                else {
                    prevElement.text = curInline.text.substring(indexInInline);
                    curInline.text = curInline.text.slice(0, indexInInline);
                }
                lineWidget.children.splice(insertIndex, 0, prevElement);
                prevElement.line = curInline.line;
            }
        }
        for (var i = 0; i < element.length; i++) {
            length += element[i].length;
            if (element[i] instanceof TextElementBox && element[i].text.indexOf(' ') >= 0) {
                this.viewer.triggerSpellCheck = true;
            }
            element[i].ischangeDetected = true;
            lineWidget.children.splice(insertIndex, 0, element[i]);
            element[i].line = lineWidget;
            element[i].linkFieldCharacter(this.viewer);
            insertIndex++;
        }
        if (paragraphFormat) {
            paragraph.paragraphFormat.copyFormat(paragraphFormat);
        }
        if (paragraph.paragraphFormat.bidi && this.isInsertField) {
            this.viewer.layout.reArrangeElementsForRtl(lineWidget, paragraph.paragraphFormat.bidi);
        }
        this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, 0, paragraph.paragraphFormat.bidi);
        this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + length, true);
    };
    Editor.prototype.insertElementInternal = function (element, newElement, index, relayout) {
        var line = element.line;
        var paragraph = line.paragraph;
        var lineIndex = line.indexInOwner;
        var insertIndex = element.indexInOwner;
        var isBidi = paragraph.paragraphFormat.bidi && element.isRightToLeft;
        if (index === element.length) {
            // Add new Element in current 
            if (!isBidi) {
                insertIndex++;
            }
            line.children.splice(insertIndex, 0, newElement);
        }
        else if (index === 0) {
            if (isNullOrUndefined(element.previousNode)) {
                element.line.children.splice(0, 0, newElement);
                insertIndex = 0;
            }
            else {
                element.line.children.splice(insertIndex, 0, newElement);
            }
        }
        else {
            if (!isBidi) {
                insertIndex++;
            }
            var textElement = new TextElementBox();
            textElement.characterFormat.copyFormat(element.characterFormat);
            textElement.text = element.text.substring(index);
            element.text = element.text.substr(0, index);
            line.children.splice(insertIndex, 0, textElement);
            textElement.line = element.line;
            //Inserts the new inline.
            line.children.splice(isBidi ? insertIndex + 1 : insertIndex, 0, newElement);
            insertIndex -= 1;
        }
        newElement.line = element.line;
        newElement.linkFieldCharacter(this.viewer);
        if (relayout) {
            this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, insertIndex);
        }
    };
    /**
     * Insert Block on undo
     * @param  {Selection} selection
     * @param  {WBlock} block
     * @private
     */
    Editor.prototype.insertBlock = function (block) {
        var isRemoved = true;
        var selection = this.selection;
        if (!selection.isEmpty) {
            isRemoved = this.removeSelectedContents(selection);
        }
        if (!isRemoved) {
            selection.selectContent(selection.start, false);
        }
        this.insertBlockInternal(block);
        if (this.checkInsertPosition(selection)) {
            var paragraph = undefined;
            if (block instanceof ParagraphWidget) {
                paragraph = block;
            }
            else {
                paragraph = this.selection.getFirstParagraphInFirstCell(block);
            }
            // tslint:disable-next-line:max-line-length
            this.updateHistoryPosition(this.selection.getHierarchicalIndex(paragraph, '0'), true);
        }
        this.fireContentChange();
    };
    /**
     * Insert new Block on specific index
     * @param  {Selection} selection
     * @param  {BlockWidget} block
     * @private
     */
    Editor.prototype.insertBlockInternal = function (block) {
        var selection = this.selection;
        var startPara = this.selection.start.paragraph;
        if (!selection.start.isAtParagraphStart) {
            if (block instanceof ParagraphWidget) {
                this.insertNewParagraphWidget(block, false);
                return;
            }
            this.updateInsertPosition();
            startPara = startPara.combineWidget(this.viewer);
            // tslint:disable-next-line:max-line-length
            this.splitParagraph(startPara, startPara.firstChild, 0, selection.start.currentWidget, selection.start.offset, false);
            selection.selectParagraphInternal(this.selection.start.paragraph, true);
        }
        var bodyWidget = selection.start.paragraph.containerWidget;
        var blockIndex = selection.start.paragraph.index;
        var insertIndex = bodyWidget.childWidgets.indexOf(selection.start.paragraph);
        if (!isNullOrUndefined(bodyWidget)) {
            bodyWidget.childWidgets.splice(insertIndex, 0, block);
            block.containerWidget = bodyWidget;
            block.index = blockIndex;
            block.height = 0;
            if (block instanceof TableWidget) {
                block.isGridUpdated = false;
                block.buildTableColumns();
                block.isGridUpdated = true;
            }
            this.updateNextBlocksIndex(block, true);
            this.viewer.layout.layoutBodyWidgetCollection(blockIndex, bodyWidget, block, false);
        }
    };
    /**
     * Inserts the image with specified size at cursor position in the document editor.
     * @param {string} imageString  Base64 string, web URL or file URL.
     * @param {number} width? Image width
     * @param {number} height? Image height
     */
    Editor.prototype.insertImage = function (imageString, width, height) {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        if (isNullOrUndefined(width)) {
            width = 100;
        }
        if (isNullOrUndefined(height)) {
            height = 100;
        }
        this.insertPicture(imageString, width, height);
    };
    /**
     * Inserts a table of specified size at cursor position
     *  in the document editor.
     * @param {number} rows Default value of rows parameter is 1.
     * @param {number} columns Default value of columns parameter is 1.
     */
    Editor.prototype.insertTable = function (rows, columns) {
        var startPos = this.selection.start;
        if (this.owner.isReadOnlyMode) {
            return;
        }
        rows = rows || 1;
        columns = columns || 1;
        var table = this.createTable(rows, columns);
        var clientWidth = startPos.paragraph.getContainerWidth();
        table.splitWidthToTableCells(clientWidth);
        var prevBlock = startPos.paragraph.previousWidget;
        if (startPos.currentWidget.isFirstLine() && startPos.offset === 0 && prevBlock instanceof TableWidget) {
            this.insertTableRows(table, prevBlock);
            table.destroy();
            return;
        }
        else {
            this.initHistory('InsertTable');
            this.viewer.owner.isShiftingEnabled = true;
            this.insertBlock(table);
        }
        var startLine = this.selection.getFirstParagraphInFirstCell(table).childWidgets[0];
        startPos.setPosition(startLine, true);
        this.selection.end.setPositionInternal(startPos);
        var lastParagraph = this.selection.getLastParagraphInLastCell(table.getSplitWidgets().pop());
        var endOffset = lastParagraph.getLength() + 1;
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            // tslint:disable-next-line:max-line-length
            this.editorHistory.currentBaseHistoryInfo.endPosition = this.selection.getHierarchicalIndex(lastParagraph, endOffset.toString());
        }
        this.reLayout(this.selection);
    };
    /**
     * Inserts the specified number of rows to the table above or below to the row at cursor position.
     * @param {boolean} above The above parameter is optional and if omitted,
     * it takes the value as false and inserts below the row at cursor position.
     * @param {number} count The count parameter is optional and if omitted, it takes the value as 1.
     */
    Editor.prototype.insertRow = function (above, count) {
        var rowPlacement = above ? 'Above' : 'Below';
        if (this.owner.isReadOnlyMode) {
            return;
        }
        var startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        var endPos = this.selection.isForward ? this.selection.end : this.selection.start;
        if (startPos.paragraph.isInsideTable) {
            if (this.checkIsNotRedoing()) {
                this.initHistory(rowPlacement === 'Above' ? 'InsertRowAbove' : 'InsertRowBelow');
            }
            this.viewer.owner.isShiftingEnabled = true;
            var startCell = this.getOwnerCell(this.selection.isForward).getSplitWidgets()[0];
            var endCell = this.getOwnerCell(!this.selection.isForward).getSplitWidgets()[0];
            var table = startCell.ownerTable.combineWidget(this.viewer);
            var row = rowPlacement === 'Below' ? endCell.ownerRow : startCell.ownerRow;
            if (this.editorHistory) {
                var clonedTable = this.cloneTableToHistoryInfo(table);
            }
            var rowCount = count ? count : this.getRowCountToInsert();
            var rows = [];
            var index = row.rowIndex;
            if (rowPlacement === 'Below') {
                index++;
                var isAffectedByRowSpannedCell = isNullOrUndefined(endCell.previousWidget)
                    || endCell.columnIndex === endCell.previousWidget.columnIndex + 1;
                var isRowSpanEnd = endCell.cellIndex !== endCell.columnIndex && isAffectedByRowSpannedCell
                    && row.rowIndex + startCell.cellFormat.rowSpan - 1 === endCell.ownerRow.rowIndex;
                if (!isRowSpanEnd) {
                    if (endCell.cellFormat.rowSpan > 1) {
                        if (!isNullOrUndefined(row.nextWidget) && row.nextWidget instanceof TableRowWidget) {
                            endCell.cellFormat.rowSpan += rowCount;
                            row = row.nextWidget;
                        }
                    }
                }
            }
            for (var i = 0; i < rowCount; i++) {
                var cellCountInfo = this.updateRowspan(row, rowPlacement === 'Below' ? endCell : startCell, rowPlacement);
                var newRow = this.createRowAndColumn(cellCountInfo.count, i);
                newRow.rowFormat.copyFormat(row.rowFormat);
                this.updateCellFormatForInsertedRow(newRow, cellCountInfo.cellFormats);
                rows.push(newRow);
            }
            table.insertTableRowsInternal(rows, index);
            var cell = undefined;
            var paragraph = undefined;
            if ((table.childWidgets[index] instanceof TableRowWidget)) {
                cell = table.childWidgets[index].firstChild;
                paragraph = this.selection.getFirstParagraph(cell);
            }
            else {
                var widget = undefined;
                while (!(widget instanceof TableWidget)) {
                    widget = table.nextRenderedWidget;
                }
                paragraph = this.selection.getFirstParagraphInFirstCell(widget);
            }
            this.viewer.layout.reLayoutTable(table);
            this.selection.selectParagraphInternal(paragraph, true);
        }
        this.reLayout(this.selection, true);
    };
    /**
     * Fits the table based on AutoFitType.
     * @param {AutoFitType} - auto fit type
     */
    Editor.prototype.autoFitTable = function (fitType) {
        if (this.viewer.owner.isReadOnlyMode) {
            return;
        }
        var startPosition = this.selection.start;
        var endPosition = this.selection.end;
        if (!this.selection.isForward) {
            startPosition = this.selection.end;
            endPosition = this.selection.start;
        }
        var tableAdv = this.selection.getTable(startPosition, endPosition);
        tableAdv = tableAdv.getSplitWidgets()[0];
        var parentTable = this.viewer.layout.getParentTable(tableAdv);
        if (!isNullOrUndefined(parentTable)) {
            this.setOffsetValue(this.selection);
            parentTable = parentTable.combineWidget(this.viewer);
            // tslint:disable-next-line:max-line-length
            this.initHistory(fitType === 'FitToContents' ? 'TableAutoFitToContents' : fitType === 'FitToWindow' ? 'TableAutoFitToWindow' : 'TableFixedColumnWidth');
            if (this.viewer.owner.editorHistoryModule) {
                this.cloneTableToHistoryInfo(parentTable);
            }
            parentTable.updateProperties(true, tableAdv, fitType);
            this.viewer.owner.isShiftingEnabled = true;
            //Layouts the table.
            this.viewer.layout.reLayoutTable(tableAdv);
            this.reLayout(this.selection, true);
        }
    };
    Editor.prototype.updateCellFormatForInsertedRow = function (newRow, cellFormats) {
        for (var i = 0; i < newRow.childWidgets.length; i++) {
            newRow.childWidgets[i].cellFormat.copyFormat(cellFormats[i]);
            newRow.childWidgets[i].cellFormat.rowSpan = 1;
        }
    };
    Editor.prototype.updateRowspan = function (row, startCell, rowPlacement) {
        var spannedCells = row.getPreviousRowSpannedCells(true);
        var count = 0;
        var cellFormats = [];
        for (var i = 0; i < row.childWidgets.length; i++) {
            var cell = row.childWidgets[i];
            var isCellIncluded = false;
            // Need to check with all the row spanned cells. if the start cell contains rowspan greater than 1, 
            // and when inserting below, need to increment rowspan for all row spanned cells by 1 except
            // if the spanned cells is placed in the same column or cell to be cloned has the same row index of cloned cell row index.
            // and when inserting above, if cloned cell placed in the same row of start cell or
            // if the cloned cell has equal column index, need to skip updating rowspan value of cloned cell.
            // else update row span value for spanned cell except 
            // if the spanned cells is placed in the same column or cell to be cloned has the same row index of cloned cell row index.
            var isRowSpanned = (isNullOrUndefined(cell.previousWidget)
                || cell.columnIndex !== cell.previousWidget.columnIndex + 1);
            for (var j = 0; j < spannedCells.length; j++) {
                if (isRowSpanned) {
                    var spannedCell = spannedCells[j];
                    var clonedRowIndex = spannedCell.ownerRow.rowIndex + spannedCell.cellFormat.rowSpan - 1;
                    if (cell.columnIndex < spannedCell.columnIndex && cell.cellIndex !== cell.columnIndex) {
                        isCellIncluded = true;
                        count++;
                        cellFormats.push(cell.cellFormat);
                    }
                    if (startCell.cellFormat.rowSpan === 1) {
                        // Need to check whether cell is affected by a row spanned cell. if cell is placed on the row where it is affected 
                        // by row spanned cell, then if we are inserting row below, need to add new cell with spanned cell width
                        // or if we are inserting above, need to update row span value of the spanned cell.
                        // if cell is placed inbetween the spanned cell , 
                        // then if we are inserting below, need to update row span value of spanned cell or
                        // if we are inserting above, need to skip updating row span value except
                        // if start cell is placed on the same row of spanned cell or if start cell placed in the same column.
                        if (clonedRowIndex > cell.ownerRow.rowIndex) {
                            if (rowPlacement === 'Above'
                                && spannedCell.ownerRow === startCell.ownerRow) {
                                continue;
                            }
                            else {
                                spannedCell.cellFormat.rowSpan += 1;
                                spannedCells.splice(j, 1);
                                j--;
                            }
                        }
                        else if (cell.cellIndex !== cell.columnIndex && isRowSpanned && clonedRowIndex === cell.ownerRow.rowIndex) {
                            if (rowPlacement === 'Above') {
                                spannedCell.cellFormat.rowSpan += 1;
                                spannedCells.splice(j, 1);
                                j--;
                            }
                            else {
                                count++;
                                cellFormats.push(spannedCell.cellFormat);
                                spannedCells.splice(j, 1);
                                j--;
                            }
                        }
                    }
                    else {
                        if (spannedCell !== startCell) {
                            if (rowPlacement === 'Above'
                                && (spannedCell.ownerRow === startCell.ownerRow || spannedCell.columnIndex === startCell.columnIndex)) {
                                continue;
                            }
                            else {
                                if (spannedCell.columnIndex !== startCell.columnIndex
                                    && spannedCell.ownerRow.rowIndex !== cell.ownerRow.rowIndex
                                    && (clonedRowIndex > startCell.ownerRow.rowIndex
                                        || (rowPlacement === 'Above' && clonedRowIndex === startCell.ownerRow.rowIndex))) {
                                    spannedCell.cellFormat.rowSpan += 1;
                                    spannedCells.splice(j, 1);
                                    j--;
                                }
                            }
                        }
                    }
                }
            }
            if (spannedCells.indexOf(cell) === -1 && cell.cellFormat.rowSpan > 1) {
                isCellIncluded = true;
            }
            if (!isCellIncluded) {
                count++;
                cellFormats.push(cell.cellFormat);
            }
        }
        return { count: count, cellFormats: cellFormats };
    };
    Editor.prototype.insertTableRows = function (table, prevBlock) {
        this.initHistory('InsertRowBelow');
        table.containerWidget = prevBlock.containerWidget;
        prevBlock = prevBlock.combineWidget(this.viewer);
        if (this.editorHistory) {
            var clonedTable = this.cloneTableToHistoryInfo(prevBlock);
        }
        var row = prevBlock.childWidgets[prevBlock.childWidgets.length - 1];
        prevBlock.insertTableRowsInternal(table.childWidgets, prevBlock.childWidgets.length);
        var paragraph = this.selection.getFirstParagraph(row.nextWidget.childWidgets[0]);
        prevBlock.isDefaultFormatUpdated = false;
        this.viewer.layout.reLayoutTable(prevBlock);
        this.selection.selectParagraphInternal(paragraph, true);
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            this.updateHistoryPosition(this.selection.start, true);
            this.updateHistoryPosition(this.selection.end, false);
        }
        this.reLayout(this.selection);
    };
    /**
     * Inserts the specified number of columns to the table left or right to the column at cursor position.
     * @param {number} left The left parameter is optional and if omitted, it takes the value as false and
     * inserts to the right of column at cursor position.
     * @param {number} count The count parameter is optional and if omitted, it takes the value as 1.
     */
    Editor.prototype.insertColumn = function (left, count) {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        var columnPlacement = left ? 'Left' : 'Right';
        if (this.selection.start.paragraph.isInsideTable) {
            if (this.checkIsNotRedoing()) {
                this.initHistory(columnPlacement === 'Left' ? 'InsertColumnLeft' : 'InsertColumnRight');
            }
            this.selection.owner.isShiftingEnabled = true;
            var startCell = this.getOwnerCell(this.selection.isForward);
            var endCell = this.getOwnerCell(!this.selection.isForward);
            var table = startCell.ownerRow.ownerTable.combineWidget(this.viewer);
            if (this.editorHistory) {
                //Clones the entire table to preserve in history.
                var clonedTable = this.cloneTableToHistoryInfo(table);
            }
            this.selection.owner.isLayoutEnabled = false;
            var cellIndex = startCell.columnIndex;
            if (columnPlacement === 'Right') {
                cellIndex = endCell.columnIndex + endCell.cellFormat.columnSpan;
            }
            var startParagraph = undefined;
            var newCell = undefined;
            var columnCount = count ? count : this.getColumnCountToInsert();
            var rowSpannedCells = [];
            for (var i = 0; i < columnCount; i++) {
                for (var j = 0; j < table.childWidgets.length; j++) {
                    var row = table.childWidgets[j];
                    newCell = this.createColumn(this.selection.getLastParagraph(startCell));
                    newCell.index = j;
                    newCell.rowIndex = row.rowIndex;
                    newCell.containerWidget = row;
                    newCell.cellFormat.copyFormat(startCell.cellFormat);
                    newCell.cellFormat.rowSpan = 1;
                    if (isNullOrUndefined(startParagraph)) {
                        startParagraph = this.selection.getFirstParagraph(newCell);
                    }
                    if (cellIndex === 0) {
                        row.childWidgets.splice(cellIndex, 0, newCell);
                    }
                    else {
                        var isCellInserted = false;
                        for (var j_1 = 0; j_1 < row.childWidgets.length; j_1++) {
                            var rowCell = row.childWidgets[j_1];
                            // Add the row spanned cells to colection for adding column before / after row spnned cells.
                            if (rowCell.cellFormat.rowSpan > 1) {
                                rowSpannedCells.push(rowCell);
                            }
                            if (rowCell.columnIndex + rowCell.cellFormat.columnSpan === cellIndex) {
                                row.childWidgets.splice(rowCell.cellIndex + 1, 0, newCell);
                                isCellInserted = true;
                            }
                            else if (cellIndex > rowCell.columnIndex && rowCell.columnIndex + rowCell.cellFormat.columnSpan > cellIndex
                                && cellIndex < rowCell.columnIndex + rowCell.cellFormat.columnSpan) {
                                row.childWidgets.splice(rowCell.cellIndex, 0, newCell);
                                isCellInserted = true;
                            }
                            if (isCellInserted) {
                                break;
                            }
                        }
                        // If the cell is not inserted for row, then check for row spanned cells.
                        if (!isCellInserted) {
                            if (rowSpannedCells.length > 0) {
                                for (var k = 0; k < rowSpannedCells.length; k++) {
                                    var rowSpannedCell = rowSpannedCells[k];
                                    if (rowSpannedCell.ownerRow !== row
                                        && row.rowIndex <= rowSpannedCell.ownerRow.rowIndex + rowSpannedCell.cellFormat.rowSpan - 1) {
                                        if (rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan === cellIndex) {
                                            if (rowSpannedCell.cellIndex > row.childWidgets.length) {
                                                row.childWidgets.push(newCell);
                                            }
                                            else {
                                                row.childWidgets.splice(rowSpannedCell.cellIndex, 0, newCell);
                                            }
                                            isCellInserted = true;
                                        }
                                        else if (cellIndex > rowSpannedCell.columnIndex &&
                                            rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan > cellIndex
                                            && cellIndex < rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan) {
                                            row.childWidgets.splice(rowSpannedCell.columnIndex, 0, newCell);
                                            isCellInserted = true;
                                        }
                                    }
                                    if (isCellInserted) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            table.updateRowIndex(0);
            var parentTable = this.viewer.layout.getParentTable(table);
            if (parentTable) {
                parentTable.fitChildToClientArea();
            }
            else {
                table.fitChildToClientArea();
            }
            this.selection.owner.isLayoutEnabled = true;
            table.isGridUpdated = false;
            table.buildTableColumns();
            table.isGridUpdated = true;
            this.viewer.skipScrollToPosition = true;
            this.viewer.layout.reLayoutTable(table);
            this.selection.start.setPosition(startParagraph.firstChild, true);
            this.selection.end.setPosition(this.selection.getLastParagraph(newCell).firstChild, false);
            if (this.checkIsNotRedoing() || isNullOrUndefined(this.editorHistory)) {
                this.reLayout(this.selection);
            }
        }
    };
    /**
     * Creates table with specified rows and columns.
     * @private
     */
    Editor.prototype.createTable = function (rows, columns) {
        var startPara = this.selection.start.paragraph;
        var table = new TableWidget();
        table.tableFormat = new WTableFormat(table);
        table.tableFormat.preferredWidthType = 'Auto';
        table.tableFormat.initializeTableBorders();
        var index = 0;
        while (index < rows) {
            var tableRow = this.createRowAndColumn(columns, index);
            tableRow.rowFormat.heightType = 'Auto';
            tableRow.containerWidget = table;
            table.childWidgets.push(tableRow);
            index++;
        }
        return table;
    };
    Editor.prototype.createRowAndColumn = function (columns, rowIndex) {
        var startPara = this.selection.start.paragraph;
        var tableRow = new TableRowWidget();
        tableRow.rowFormat = new WRowFormat(tableRow);
        tableRow.index = rowIndex;
        for (var i = 0; i < columns; i++) {
            var tableCell = this.createColumn(startPara);
            tableCell.index = i;
            tableCell.rowIndex = rowIndex;
            tableCell.containerWidget = tableRow;
            tableRow.childWidgets.push(tableCell);
        }
        return tableRow;
    };
    Editor.prototype.createColumn = function (paragraph) {
        var tableCell = new TableCellWidget();
        var para = new ParagraphWidget();
        para.paragraphFormat.copyFormat(paragraph.paragraphFormat);
        para.characterFormat.copyFormat(paragraph.characterFormat);
        para.containerWidget = tableCell;
        tableCell.childWidgets.push(para);
        tableCell.cellFormat = new WCellFormat(tableCell);
        return tableCell;
    };
    Editor.prototype.getColumnCountToInsert = function () {
        var count = 1;
        var start = this.selection.start;
        var end = this.selection.end;
        if (!this.selection.isForward) {
            start = this.selection.end;
            end = this.selection.start;
        }
        if (start && end && this.selection.getTable(start, end)) {
            if (start.paragraph.associatedCell === end.paragraph.associatedCell) {
                return count = 1;
            }
            if (start.paragraph.associatedCell.ownerRow === end.paragraph.associatedCell.ownerRow) {
                return count = count + end.paragraph.associatedCell.cellIndex - start.paragraph.associatedCell.cellIndex;
            }
            else {
                count = 0;
                // tslint:disable-next-line:max-line-length
                var selectedCells = start.paragraph.associatedCell.ownerTable.getColumnCellsForSelection(start.paragraph.associatedCell, end.paragraph.associatedCell);
                for (var i = 0; i < selectedCells.length; i++) {
                    if (start.paragraph.associatedCell.ownerRow === selectedCells[i].ownerRow) {
                        count++;
                    }
                }
            }
        }
        return count === 0 ? 1 : count;
    };
    Editor.prototype.getRowCountToInsert = function () {
        var count = 1;
        var start = this.selection.start;
        var end = this.selection.end;
        if (!this.selection.isForward) {
            start = this.selection.end;
            end = this.selection.start;
        }
        if (!isNullOrUndefined(start) && !isNullOrUndefined(end) && !isNullOrUndefined(this.selection.getTable(start, end))) {
            if (start.paragraph.associatedCell === end.paragraph.associatedCell ||
                start.paragraph.associatedCell.ownerRow === end.paragraph.associatedCell.ownerRow) {
                return count = 1;
            }
            else {
                return count = count +
                    this.getOwnerRow(!this.selection.isForward).rowIndex - this.getOwnerRow(this.selection.isForward).rowIndex;
            }
        }
        return count === 0 ? 1 : count;
    };
    Editor.prototype.getOwnerCell = function (isStart) {
        var cell = undefined;
        var startCell = isStart ? this.selection.start.paragraph.associatedCell
            : this.selection.end.paragraph.associatedCell;
        var endCell = isStart ? this.selection.end.paragraph.associatedCell
            : this.selection.start.paragraph.associatedCell;
        cell = startCell;
        var owner = cell.ownerTable;
        while (!isNullOrUndefined(owner) && owner.containerWidget instanceof TableCellWidget && owner !== endCell.ownerTable) {
            cell = owner.containerWidget;
            owner = cell.ownerTable;
        }
        return cell;
    };
    Editor.prototype.getOwnerRow = function (isStart) {
        var row;
        var startRow = isStart ? this.selection.start.paragraph.associatedCell.ownerRow
            : this.selection.end.paragraph.associatedCell.ownerRow;
        var endRow = isStart ? this.selection.end.paragraph.associatedCell.ownerRow
            : this.selection.start.paragraph.associatedCell.ownerRow;
        row = startRow;
        var owner = row.ownerTable;
        while (!isNullOrUndefined(owner) && owner.containerWidget instanceof TableCellWidget && owner !== endRow.ownerTable) {
            row = owner.containerWidget.ownerRow;
            owner = row.ownerTable;
        }
        return row;
    };
    Editor.prototype.getOwnerTable = function (isStart) {
        var table = undefined;
        var startTable = this.selection.start.paragraph.associatedCell.ownerTable;
        var endTable = this.selection.end.paragraph.associatedCell.ownerTable;
        table = isStart ? startTable : endTable;
        while (table.containerWidget instanceof TableCellWidget && table !== (isStart ? endTable : startTable)) {
            table = table.containerWidget.ownerTable;
        }
        return table;
    };
    /**
     * Merge Selected cells
     * @private
     */
    Editor.prototype.mergeSelectedCellsInTable = function () {
        if (!this.canMergeCells()) {
            return;
        }
        if (this.checkIsNotRedoing()) {
            this.initHistory('MergeCells');
        }
        this.selection.owner.isShiftingEnabled = true;
        var startPosition = this.selection.start;
        var endPosition = this.selection.end;
        if (!this.selection.isForward) {
            startPosition = this.selection.end;
            endPosition = this.selection.start;
        }
        var startOwnerCell = this.getOwnerCell(this.selection.isForward);
        var endOwnerCell = this.getOwnerCell(!this.selection.isForward);
        var containerCell = this.selection.getContainerCellOf(startOwnerCell, endOwnerCell);
        if (containerCell.ownerTable.contains(endOwnerCell)) {
            if (!this.selection.containsCell(containerCell, endOwnerCell)) {
                //Start and End are in different cells.               
                var table = startOwnerCell.ownerTable.combineWidget(this.viewer);
                startOwnerCell = this.selection.getSelectedCell(startOwnerCell, containerCell);
                endOwnerCell = this.selection.getSelectedCell(endOwnerCell, containerCell);
                //Merges the selected cells.               
                var mergedCell = this.mergeSelectedCells(table, startOwnerCell, endOwnerCell);
                var firstParagraph = this.selection.getFirstParagraph(mergedCell);
                startPosition.setPosition(firstParagraph.firstChild, true);
                var lastParagraph = this.selection.getLastParagraph(mergedCell);
                endPosition.setPosition(lastParagraph.lastChild, false);
            }
        }
        if (this.checkIsNotRedoing() || isNullOrUndefined(this.editorHistory)) {
            this.reLayout(this.selection, false);
        }
    };
    Editor.prototype.mergeSelectedCells = function (table, startCell, endCell) {
        //Clones the entire table to preserve in history.
        var clonedTable = this.cloneTableToHistoryInfo(table);
        this.selection.owner.isLayoutEnabled = false;
        //Merges the selected cells.
        var start = this.selection.getCellLeft(startCell.ownerRow, startCell);
        var end = start + startCell.cellFormat.cellWidth;
        var endCellLeft = this.selection.getCellLeft(endCell.ownerRow, endCell);
        var endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        var cellInfo = this.updateSelectedCellsInTable(start, end, endCellLeft, endCellRight);
        start = cellInfo.start;
        end = cellInfo.end;
        var count = table.childWidgets.indexOf(endCell.ownerRow);
        var rowStartIndex = table.childWidgets.indexOf(startCell.ownerRow);
        var mergedCell = undefined;
        var firstBlock;
        for (var i = rowStartIndex; i <= count; i++) {
            var row = table.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                var cellStart = this.selection.getCellLeft(row, cell);
                if (HelperMethods.round(start, 2) <= HelperMethods.round(cellStart, 2)
                    && HelperMethods.round(cellStart, 2) < HelperMethods.round(end, 2)) {
                    var lastBlock = cell.lastChild;
                    if (lastBlock instanceof ParagraphWidget && lastBlock.isEmpty()) {
                        cell.childWidgets.pop();
                    }
                    if (isNullOrUndefined(mergedCell)) {
                        mergedCell = cell;
                        firstBlock = lastBlock;
                    }
                    else {
                        if (i === rowStartIndex) {
                            mergedCell.cellFormat.preferredWidth += cell.cellFormat.preferredWidth;
                            mergedCell.cellFormat.columnSpan += cell.cellFormat.columnSpan;
                            this.mergeBorders(mergedCell, cell);
                        }
                        for (var k = 0; k < cell.childWidgets.length; k++) {
                            var block = cell.childWidgets[k];
                            var newBlock = block.clone();
                            newBlock.containerWidget = mergedCell;
                            mergedCell.childWidgets.push(newBlock);
                        }
                        row.childWidgets.splice(j, 1);
                        cell.destroy();
                        j--;
                    }
                }
            }
            //To Ensure minimul content. 
            // tslint:disable-next-line:max-line-length
            if ((mergedCell.childWidgets.length === 0 || mergedCell.childWidgets.length === 1 && mergedCell.childWidgets[0] instanceof TableWidget) && firstBlock) {
                var newBlock = firstBlock.clone();
                mergedCell.childWidgets.push(newBlock);
                newBlock.containerWidget = mergedCell;
            }
            if (row.childWidgets.length === 0) {
                var rowIndex = table.childWidgets.indexOf(row);
                row.updateRowBySpannedCells();
                table.childWidgets.splice(rowIndex, 1);
                row.destroy();
                count--;
                i--;
            }
        }
        if (!isNullOrUndefined(mergedCell) && rowStartIndex < count) {
            mergedCell.cellFormat.rowSpan = count - rowStartIndex + 1;
        }
        this.updateBlockIndexAfterMerge(mergedCell);
        table.updateRowIndex(0);
        table.calculateGrid();
        table.isGridUpdated = false;
        table.buildTableColumns();
        table.isGridUpdated = true;
        this.viewer.layout.reLayoutTable(table);
        //Layouts the table after merging cells.
        this.selection.owner.isLayoutEnabled = true;
        return mergedCell;
    };
    Editor.prototype.mergeBorders = function (mergedCell, tableCell) {
        var mergedCellborders = undefined;
        var cellBorders = null;
        if (!isNullOrUndefined(mergedCell.cellFormat.borders)) {
            mergedCellborders = mergedCell.cellFormat.borders;
        }
        if (!isNullOrUndefined(tableCell.cellFormat.borders)) {
            cellBorders = tableCell.cellFormat.borders;
        }
        if (isNullOrUndefined(mergedCellborders) && isNullOrUndefined(cellBorders)) {
            return;
        }
        if (isNullOrUndefined(mergedCellborders)) {
            mergedCellborders = new WBorders(mergedCell.cellFormat);
            mergedCellborders.copyFormat(cellBorders);
        }
        else if (isNullOrUndefined(cellBorders)) {
            return;
        }
        else {
            if (mergedCell.ownerRow.rowIndex === tableCell.ownerRow.rowIndex) {
                mergedCellborders.top = mergedCell.getBorderBasedOnPriority(mergedCellborders.top, cellBorders.bottom);
                mergedCellborders.bottom = mergedCell.getBorderBasedOnPriority(mergedCellborders.bottom, cellBorders.bottom);
            }
        }
    };
    Editor.prototype.updateBlockIndexAfterMerge = function (cell) {
        for (var i = 0; i < cell.childWidgets.length; i++) {
            cell.childWidgets[i].index = i;
        }
    };
    /**
     * Determines whether merge cell operation can be done.
     */
    Editor.prototype.canMergeCells = function () {
        if (this.selection.isEmpty || !this.selection.start.paragraph.isInsideTable || !this.selection.end.paragraph.isInsideTable) {
            return false;
        }
        var startPos = this.selection.start;
        var endPos = this.selection.end;
        if (!this.selection.isForward) {
            startPos = this.selection.end;
            endPos = this.selection.start;
        }
        var startCell = this.getOwnerCell(this.selection.isForward);
        var endCell = this.getOwnerCell(!this.selection.isForward);
        var containerCell = this.selection.getContainerCellOf(startCell, endCell);
        if (containerCell.ownerTable.contains(endCell)) {
            if (!this.selection.containsCell(containerCell, endCell)) {
                startCell = this.selection.getSelectedCell(startCell, containerCell);
                endCell = this.selection.getSelectedCell(endCell, containerCell);
                var rowSpan = 1;
                if (startCell.ownerRow === endCell.ownerRow) {
                    var startCellIndex = startCell.ownerRow.childWidgets.indexOf(startCell);
                    for (var i = startCellIndex; i <= startCell.ownerRow.childWidgets.indexOf(endCell); i++) {
                        var cell = startCell.ownerRow.childWidgets[i];
                        var prevCell = cell.previousWidget;
                        if (i !== startCellIndex) {
                            if (cell.cellFormat.rowSpan !== rowSpan) {
                                return false;
                            }
                            if (!isNullOrUndefined(prevCell)
                                && cell.columnIndex !== (prevCell.cellFormat.columnSpan + prevCell.columnIndex)) {
                                return false;
                            }
                        }
                        rowSpan = cell.cellFormat.rowSpan;
                    }
                    return true;
                }
                return this.canMergeSelectedCellsInTable(startCell.ownerTable, startCell, endCell);
            }
        }
        return false;
    };
    Editor.prototype.canMergeSelectedCellsInTable = function (table, startCell, endCell) {
        var count = table.childWidgets.indexOf(endCell.ownerRow);
        var rowStartIndex = table.childWidgets.indexOf(startCell.ownerRow);
        var startLeft = this.selection.getCellLeft(startCell.ownerRow, startCell);
        var endLeft = startLeft + startCell.cellFormat.cellWidth;
        var endCellLeft = this.selection.getCellLeft(endCell.ownerRow, endCell);
        var endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        var cellInfo = this.updateSelectedCellsInTable(startLeft, endLeft, endCellLeft, endCellRight);
        startLeft = cellInfo.start;
        endLeft = cellInfo.end;
        var selectionLeft = 0;
        var selectionRight = 0;
        var isRowLeftWithinSel = false;
        var isRowRightWithinSel = false;
        var rowSpannedCells = [];
        for (var i = rowStartIndex; i <= count; i++) {
            var row = table.childWidgets[i];
            var rowLeft = 0;
            var rowRight = 0;
            var isStarted = false;
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                var cellStart = this.selection.getCellLeft(row, cell);
                if (this.checkCellWithInSelection(startLeft, endLeft, cellStart)) {
                    isRowLeftWithinSel = false;
                    isRowRightWithinSel = false;
                    if (cell.cellFormat.rowSpan > 1) {
                        rowSpannedCells.push(cell);
                    }
                    if (!isStarted) {
                        rowLeft = cellStart;
                        rowRight = cellStart;
                        isStarted = true;
                    }
                    var prevCell = cell.previousWidget;
                    if (rowRight !== 0 && HelperMethods.round(rowRight, 0) !== HelperMethods.round(cellStart, 0)) {
                        rowRight = cellStart;
                    }
                    rowRight += HelperMethods.convertPointToPixel(cell.cellFormat.cellWidth);
                    var isPrevCellWithinSel = this.checkPrevOrNextCellIsWithinSel(startLeft, endLeft, cell, true);
                    var isNextCellWithinSel = this.checkPrevOrNextCellIsWithinSel(startLeft, endLeft, cell, false);
                    // When selected cell not having row spanned cells and column index is not having immediate cell index value,
                    // then returned false.
                    var isNoRowSpan = rowSpannedCells.length === 0 || rowSpannedCells.length === 1 && rowSpannedCells[0] === cell;
                    // checks whether current cell is with in selection.
                    var isCellWithInSel = this.checkCurrentCell(rowSpannedCells, cell, isPrevCellWithinSel, isNextCellWithinSel);
                    // when last selected row not having equal row span then returned false.
                    if (i === count && !isNullOrUndefined(prevCell) && cell.cellFormat.rowSpan > prevCell.cellFormat.rowSpan
                        && !isCellWithInSel) {
                        return false;
                    }
                    if (i !== rowStartIndex) {
                        for (var m = 0; m < rowSpannedCells.length; m++) {
                            {
                                var rowSpan = (rowSpannedCells[m].ownerRow.rowIndex + rowSpannedCells[m].cellFormat.rowSpan) - 1;
                                if (rowSpan >= row.rowIndex) {
                                    if (rowSpannedCells[m].columnIndex > cell.columnIndex) {
                                        isRowRightWithinSel = true;
                                    }
                                    else {
                                        isRowLeftWithinSel = true;
                                    }
                                    if (i === count && rowSpannedCells[m] !== cell
                                        && rowSpan > (cell.ownerRow.rowIndex + cell.cellFormat.rowSpan - 1)) {
                                        return false;
                                    }
                                    if (rowSpan === row.rowIndex && !this.checkPrevOrNextCellIsWithinSel(startLeft, endLeft, cell, false)) {
                                        rowSpannedCells.splice(rowSpannedCells.indexOf(rowSpannedCells[m]), 1);
                                    }
                                }
                            }
                        }
                    }
                    if (isPrevCellWithinSel && !isNullOrUndefined(prevCell)
                        && isNoRowSpan
                        && (cell.columnIndex !== prevCell.columnIndex + 1 && this.checkCellWidth(cell))) {
                        return false;
                    }
                }
            }
            if (i === rowStartIndex) {
                selectionLeft = rowLeft;
                selectionRight = rowRight;
            }
            else {
                if (rowRight > 0 && rowLeft > 0) {
                    if (!((isRowLeftWithinSel || Math.round(selectionLeft) === Math.round(rowLeft))
                        && (isRowRightWithinSel || Math.round(selectionRight) === Math.round(rowRight)))) {
                        return false;
                    }
                }
                if (i === count) {
                    return true;
                }
            }
        }
        return false;
    };
    Editor.prototype.checkCellWidth = function (cell) {
        var prevCell = cell.previousWidget;
        var cellLeft = this.viewer.selection.getCellLeft(cell.ownerRow, cell);
        var prevCellLeft = this.viewer.selection.getCellLeft(cell.ownerRow, prevCell);
        var left = prevCellLeft + HelperMethods.convertPointToPixel(prevCell.cellFormat.cellWidth);
        if (HelperMethods.round(left, 2) !== HelperMethods.round(cellLeft, 2)) {
            return true;
        }
        return false;
    };
    
    Editor.prototype.checkCellWithInSelection = function (startLeft, endLeft, cellStart) {
        if (HelperMethods.round(startLeft, 2) <= HelperMethods.round(cellStart, 2)
            && HelperMethods.round(cellStart, 2) < HelperMethods.round(endLeft, 2)) {
            return true;
        }
        return false;
    };
    
    Editor.prototype.checkPrevOrNextCellIsWithinSel = function (startLeft, endLeft, cell, isPrev) {
        var prevOrNextCell = isPrev ? cell.previousWidget : cell.nextWidget;
        var cellStart = 0;
        if (isNullOrUndefined(prevOrNextCell)) {
            return false;
        }
        cellStart = this.viewer.selection.getCellLeft(prevOrNextCell.ownerRow, prevOrNextCell);
        return this.checkCellWithInSelection(startLeft, endLeft, cellStart);
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.checkCurrentCell = function (rowSpannedCells, cell, isPrevCellWithInSel, isNextCellWithinSel) {
        var cellOwner = cell.ownerRow;
        if (rowSpannedCells.length > 0) {
            for (var i = 0; i < rowSpannedCells.length; i++) {
                var spannedCellOwner = rowSpannedCells[i].ownerRow;
                var rowSpan = (spannedCellOwner.rowIndex + rowSpannedCells[i].cellFormat.rowSpan) - 1;
                if (rowSpannedCells[i] === cell && (rowSpannedCells.length === 1 || this.checkRowSpannedCells(rowSpannedCells, cell))
                    && !(isNextCellWithinSel || isPrevCellWithInSel)) {
                    return true;
                }
                if (rowSpannedCells[i] !== cell && spannedCellOwner.rowIndex < cellOwner.rowIndex
                    && rowSpan === (cellOwner.rowIndex + cell.cellFormat.rowSpan - 1)) {
                    return true;
                }
            }
        }
        return false;
    };
    Editor.prototype.checkRowSpannedCells = function (rowSpannedCells, cell) {
        for (var i = 0; i < rowSpannedCells.length; i++) {
            if (rowSpannedCells[i] !== cell && rowSpannedCells[i].columnIndex === cell.columnIndex) {
                return true;
            }
        }
        return false;
    };
    /**
     * @private
     */
    Editor.prototype.insertNewParagraphWidget = function (newParagraph, insertAfter) {
        this.updateInsertPosition();
        this.insertParagraph(newParagraph, insertAfter);
        if (!insertAfter) {
            var nextParagraph = void 0;
            var currentParagraph = newParagraph;
            do {
                nextParagraph = this.selection.getNextParagraphBlock(currentParagraph);
                currentParagraph = nextParagraph;
            } while (nextParagraph && nextParagraph.equals(newParagraph));
            if (!isNullOrUndefined(nextParagraph)) {
                this.selection.selectParagraphInternal(nextParagraph, true);
            }
            else {
                this.selection.selectParagraphInternal(newParagraph, true);
            }
        }
        this.fireContentChange();
    };
    Editor.prototype.insertParagraph = function (newParagraph, insertAfter) {
        var lineWidget = this.selection.start.currentWidget;
        var offset = this.selection.start.offset;
        var currentParagraph = this.selection.start.paragraph;
        currentParagraph = currentParagraph.combineWidget(this.viewer);
        if (insertAfter) {
            // tslint:disable-next-line:max-line-length
            var length_1 = this.selection.getLineLength(currentParagraph.lastChild);
            var insertIndex_1 = newParagraph.firstChild ? newParagraph.firstChild.children.length : 0;
            // tslint:disable-next-line:max-line-length
            this.moveInlines(currentParagraph, newParagraph, insertIndex_1, offset, lineWidget, length_1, currentParagraph.lastChild);
        }
        else if (offset > 0) {
            this.moveInlines(currentParagraph, newParagraph, 0, 0, currentParagraph.firstChild, offset, lineWidget);
        }
        var splittedWidget = currentParagraph.getSplitWidgets();
        currentParagraph = insertAfter ? splittedWidget[splittedWidget.length - 1] : splittedWidget[0];
        var insertIndex = currentParagraph.containerWidget.childWidgets.indexOf(currentParagraph);
        if (insertAfter) {
            insertIndex++;
        }
        var bodyWidget = currentParagraph.containerWidget;
        newParagraph.index = currentParagraph.index;
        newParagraph.containerWidget = bodyWidget;
        bodyWidget.childWidgets.splice(insertIndex, 0, newParagraph);
        this.updateNextBlocksIndex(insertAfter ? currentParagraph : newParagraph, true);
        newParagraph.height = 0;
        this.viewer.layout.layoutBodyWidgetCollection(newParagraph.index, bodyWidget, newParagraph, false);
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.moveInlines = function (currentParagraph, newParagraph, insertIndex, startOffset, startLine, endOffset, endLine) {
        if (newParagraph.childWidgets.length === 0) {
            var line = new LineWidget(newParagraph);
            newParagraph.childWidgets.push(line);
        }
        var isMoved = false;
        this.viewer.layout.clearListElementBox(currentParagraph);
        this.viewer.layout.clearListElementBox(newParagraph);
        for (var j = 0; j < currentParagraph.childWidgets.length; j++) {
            var lineWidget = currentParagraph.childWidgets[j];
            if (startLine === lineWidget && endLine === lineWidget) {
                insertIndex = this.moveContent(lineWidget, startOffset, endOffset, insertIndex, newParagraph);
                break;
            }
            if (endLine === lineWidget) {
                insertIndex = this.moveContent(lineWidget, 0, endOffset, insertIndex, newParagraph);
                break;
            }
            else if (startLine === lineWidget) {
                isMoved = true;
                // tslint:disable-next-line:max-line-length
                insertIndex = this.moveContent(lineWidget, startOffset, this.viewer.selection.getLineLength(lineWidget), insertIndex, newParagraph);
            }
            else if (isMoved) {
                insertIndex = this.moveContent(lineWidget, 0, this.viewer.selection.getLineLength(lineWidget), insertIndex, newParagraph);
            }
        }
        this.removeEmptyLine(currentParagraph);
        if (!currentParagraph.isInsideTable) {
            this.viewer.layout.reLayoutParagraph(currentParagraph, 0, 0);
        }
    };
    /**
     * @private
     */
    //tslint:disable-next-line:max-line-length
    Editor.prototype.moveContent = function (lineWidget, startOffset, endOffset, insertIndex, paragraph) {
        var count = 0;
        var lineIndex = lineWidget.paragraph.childWidgets.indexOf(lineWidget);
        for (var i = 0; i < lineWidget.children.length; i++) {
            var inline = lineWidget.children[i];
            if (startOffset >= count + inline.length || inline instanceof ListTextElementBox) {
                if (!(inline instanceof ListTextElementBox)) {
                    count += inline.length;
                }
                continue;
            }
            var startIndex = 0;
            if (startOffset > count) {
                startIndex = startOffset - count;
            }
            var endIndex = endOffset - count;
            if (endIndex > inline.length) {
                endIndex = inline.length;
            }
            if (startIndex > 0) {
                count += startIndex;
            }
            if (startIndex === 0 && endIndex === inline.length) {
                paragraph.firstChild.children.splice(insertIndex, 0, inline);
                inline.line = paragraph.firstChild;
                insertIndex++;
                // if (editAction < 4) {
                // this.unLinkFieldCharacter(inline);
                lineWidget.children.splice(i, 1);
                i--;
                // }
            }
            else if (inline instanceof TextElementBox) {
                // if (editAction < 4) {
                var span = new TextElementBox();
                span.characterFormat.copyFormat(inline.characterFormat);
                span.text = inline.text.substr(startIndex, endIndex - startIndex);
                inline.ischangeDetected = true;
                span.ischangeDetected = true;
                paragraph.firstChild.children.splice(insertIndex, 0, span);
                span.line = paragraph.firstChild;
                insertIndex++;
                inline.text = inline.text.slice(0, startIndex) + inline.text.slice(endIndex);
                inline.ischangeDetected = true;
            }
            if (endOffset <= count + endIndex - startIndex) {
                break;
            }
            count += endIndex - startIndex;
        }
        return insertIndex;
    };
    /**
     * update complex changes when history is not preserved
     * @param  {number} action?
     * @param  {string} start?
     * @param  {string} end?
     * @private
     */
    Editor.prototype.updateComplexWithoutHistory = function (action, start, end) {
        var selection = this.viewer.selection;
        if (action === 0) {
            var startPosition = new TextPosition(selection.owner);
            this.setPositionForCurrentIndex(startPosition, start);
            this.viewer.layout.reLayoutParagraph(startPosition.paragraph, 0, 0);
            this.setPositionForCurrentIndex(selection.start, end);
            this.setPositionForCurrentIndex(selection.end, end);
        }
        if (action === 1) {
            var startPosition = new TextPosition(selection.owner);
            this.setPositionForCurrentIndex(startPosition, start);
            var endPosition = new TextPosition(selection.owner);
            this.setPositionForCurrentIndex(endPosition, end);
            this.viewer.layout.reLayoutParagraph(startPosition.paragraph, 0, 0);
            if (endPosition.paragraph !== startPosition.paragraph) {
                this.viewer.layout.reLayoutParagraph(endPosition.paragraph, 0, 0);
            }
        }
        if (selection.owner.isShiftingEnabled) {
            this.viewer.layout.shiftLayoutedItems();
            if (this.viewer.owner.enableHeaderAndFooter) {
                this.updateHeaderFooterWidget();
            }
        }
        selection.owner.isShiftingEnabled = false;
        selection.start.updatePhysicalPosition(true);
        if (selection.isEmpty) {
            selection.end.setPositionInternal(selection.start);
        }
        else {
            selection.end.updatePhysicalPosition(true);
        }
        selection.upDownSelectionLength = selection.end.location.x;
        selection.fireSelectionChanged(true);
        this.viewer.updateFocus();
        this.viewer.updateScrollBars();
        this.fireContentChange();
        this.isHandledComplex = true;
    };
    /**
     * reLayout
     * @param selection
     * @param isSelectionChanged
     * @private
     */
    Editor.prototype.reLayout = function (selection, isSelectionChanged) {
        if (!this.viewer.isComposingIME && this.editorHistory && this.editorHistory.isHandledComplexHistory()) {
            if (this.editorHistory.currentHistoryInfo && this.editorHistory.currentHistoryInfo.action !== 'ClearFormat') {
                this.startParagraph = undefined;
                this.endParagraph = undefined;
            }
            this.isHandledComplex = false;
            return;
        }
        if (isNullOrUndefined(this.viewer.blockToShift)) {
            this.viewer.removeEmptyPages();
            this.viewer.layout.updateFieldElements();
            this.viewer.updateScrollBars();
            if (!selection.owner.isShiftingEnabled) {
                selection.fireSelectionChanged(true);
                this.startParagraph = undefined;
                this.endParagraph = undefined;
            }
        }
        if (isNullOrUndefined(isSelectionChanged)) {
            isSelectionChanged = selection.isEmpty;
        }
        if (selection.owner.isShiftingEnabled) {
            selection.owner.isShiftingEnabled = false;
            selection.owner.isLayoutEnabled = true;
            this.viewer.layout.shiftLayoutedItems();
            if (this.viewer.owner.enableHeaderAndFooter) {
                this.updateHeaderFooterWidget();
            }
            this.getOffsetValue(selection);
            selection.upDownSelectionLength = selection.end.location.x;
            selection.fireSelectionChanged(true);
            this.viewer.updateFocus();
            this.startParagraph = undefined;
            this.endParagraph = undefined;
            this.viewer.layout.allowLayout = true;
        }
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo &&
            ((this.editorHistory.currentBaseHistoryInfo.action !== 'RowResizing'
                && this.editorHistory.currentBaseHistoryInfo.action !== 'CellResizing')
                || (this.editorHistory.isUndoing || this.editorHistory.isRedoing))) {
            if (this.editorHistory.currentBaseHistoryInfo.modifiedProperties.length > 0) {
                this.editorHistory.currentBaseHistoryInfo.updateSelection();
            }
            this.editorHistory.updateHistory();
        }
        this.fireContentChange();
    };
    /**
     * @private
     */
    Editor.prototype.updateHeaderFooterWidget = function (headerFooterWidget) {
        if (isNullOrUndefined(headerFooterWidget)) {
            headerFooterWidget = this.selection.start.paragraph.bodyWidget;
        }
        this.updateHeaderFooterWidgetToPage(headerFooterWidget);
        this.shiftPageContent(headerFooterWidget.headerFooterType, headerFooterWidget.sectionFormat);
    };
    /**
     * @private
     */
    Editor.prototype.updateHeaderFooterWidgetToPage = function (node) {
        var currentPage = node.page;
        node = this.viewer.layout.updateHeaderFooterToParent(node);
        var isEvenPage = (node.headerFooterType === 'EvenHeader' || node.headerFooterType === 'EvenFooter');
        for (var i = 0; i < this.viewer.pages.length; i++) {
            var page = this.viewer.pages[i];
            if ((i + 1 === 1) && page.bodyWidgets[0].sectionFormat.differentFirstPage &&
                node.headerFooterType.indexOf('FirstPage') !== -1) {
                return;
            }
            if (page.index === 0 && page.bodyWidgets[0].sectionFormat.differentFirstPage &&
                node.headerFooterType.indexOf('FirstPage') === -1) {
                continue;
            }
            if (currentPage !== page) {
                if (page.bodyWidgets[0].sectionFormat.differentOddAndEvenPages) {
                    if (isEvenPage && (i + 1) % 2 === 0) {
                        this.updateHeaderFooterWidgetToPageInternal(page, node, node.headerFooterType.indexOf('Header') !== -1);
                    }
                    else if ((!isEvenPage && (i + 1) % 2 !== 0)) {
                        if (page.bodyWidgets[0].sectionFormat.differentFirstPage && (i + 1 !== 1)) {
                            this.updateHeaderFooterWidgetToPageInternal(page, node, node.headerFooterType.indexOf('Header') !== -1);
                        }
                    }
                }
                else {
                    this.updateHeaderFooterWidgetToPageInternal(page, node, node.headerFooterType.indexOf('Header') !== -1);
                }
            }
        }
    };
    /**
     * @private
     */
    Editor.prototype.updateHeaderFooterWidgetToPageInternal = function (page, widget, isHeader) {
        if (widget.page !== page) {
            var hfWidget = widget.clone();
            hfWidget.page = page;
            this.viewer.updateHFClientArea(hfWidget.sectionFormat, isHeader);
            hfWidget = this.viewer.layout.layoutHeaderFooterItems(this.viewer, hfWidget);
            var headerOrFooter = void 0;
            if (isHeader) {
                headerOrFooter = page.headerWidget;
                page.headerWidget = hfWidget;
            }
            else {
                headerOrFooter = page.footerWidget;
                page.footerWidget = hfWidget;
            }
            this.removeFieldInWidget(headerOrFooter);
            headerOrFooter.destroy();
        }
    };
    /**
     * @private
     */
    Editor.prototype.removeFieldInWidget = function (widget, isBookmark) {
        if (isNullOrUndefined(isBookmark)) {
            isBookmark = false;
        }
        for (var i = 0; i < widget.childWidgets.length; i++) {
            this.removeFieldInBlock(widget.childWidgets[i], isBookmark);
        }
    };
    /**
     * @private
     */
    Editor.prototype.removeFieldInBlock = function (block, isBookmark) {
        if (block instanceof TableWidget) {
            this.removeFieldTable(block, isBookmark);
        }
        else {
            this.removeField(block, isBookmark);
        }
    };
    /**
     * @private
     */
    Editor.prototype.removeFieldTable = function (table, isBookmark) {
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                this.removeFieldInWidget(row.childWidgets[j], isBookmark);
            }
        }
    };
    /**
     * @private
     */
    Editor.prototype.shiftPageContent = function (type, sectionFormat) {
        // let type: HeaderFooterType = headerFooter.headerFooterType;
        var pageIndex;
        if (type.indexOf('First') !== -1) {
            pageIndex = 0;
        }
        else if (sectionFormat.differentOddAndEvenPages) {
            var isEven = type.indexOf('Even') !== -1;
            if (sectionFormat.differentFirstPage) {
                pageIndex = isEven ? 1 : 2;
            }
            else {
                pageIndex = !isEven ? 0 : 1;
            }
        }
        else {
            pageIndex = sectionFormat.differentFirstPage ? 1 : 0;
            if (pageIndex === 1 && this.viewer.pages.length === 1) {
                pageIndex = 0;
            }
        }
        var section = this.viewer.pages[pageIndex].bodyWidgets[0];
        do {
            if (type.indexOf('Header') !== -1) {
                var widget = section.page.headerWidget;
                var isNotEmpty = !widget.isEmpty || widget.isEmpty && this.owner.enableHeaderAndFooter;
                var firstBlock = section.firstChild;
                var top_1 = HelperMethods.convertPointToPixel(sectionFormat.topMargin);
                var headerDistance = HelperMethods.convertPointToPixel(sectionFormat.headerDistance);
                if (isNotEmpty) {
                    top_1 = Math.max(headerDistance + section.page.headerWidget.height, top_1);
                }
                if (firstBlock.y !== top_1) {
                    this.viewer.updateClientArea(section.sectionFormat, section.page);
                    firstBlock = firstBlock.combineWidget(this.viewer);
                    var prevWidget = firstBlock.previousRenderedWidget;
                    if (prevWidget) {
                        if (firstBlock.containerWidget.equals(prevWidget.containerWidget)) {
                            this.viewer.cutFromTop(prevWidget.y + prevWidget.height);
                            // tslint:disable-next-line:max-line-length
                            this.viewer.layout.updateContainerWidget(firstBlock, prevWidget.containerWidget, prevWidget.indexInOwner + 1, false);
                        }
                    }
                    this.viewer.blockToShift = firstBlock;
                }
            }
            else {
                this.checkAndShiftFromBottom(section.page, section.page.footerWidget);
            }
            if (this.viewer.blockToShift) {
                this.viewer.renderedLists.clear();
                this.viewer.renderedLevelOverrides = [];
                this.viewer.layout.shiftLayoutedItems();
            }
            while (section) {
                var splittedSection = section.getSplitWidgets();
                section = splittedSection[splittedSection.length - 1].nextRenderedWidget;
                if (section) {
                    if (pageIndex === 0) {
                        break;
                    }
                    else {
                        if (section.page.index + 1 % 2 === 0 && pageIndex === 1 ||
                            (section.page.index + 1 % 2 !== 0 && pageIndex === 2)) {
                            break;
                        }
                        var nextPage = section.page.nextPage;
                        if (nextPage.bodyWidgets[0].equals(section)) {
                            section = nextPage.bodyWidgets[0];
                            break;
                        }
                    }
                }
            }
        } while (section);
    };
    /**
     * @private
     */
    Editor.prototype.checkAndShiftFromBottom = function (page, footerWidget) {
        var bodyWidget = page.bodyWidgets[0];
        var blockToShift;
        for (var i = 0; i < bodyWidget.childWidgets.length; i++) {
            var block = bodyWidget.childWidgets[i];
            if (block.y + block.height > footerWidget.y) {
                blockToShift = block;
                break;
            }
            if (bodyWidget.childWidgets.length - 1 === i && block.y + block.height < footerWidget.y) {
                blockToShift = block;
                break;
            }
        }
        this.viewer.updateClientArea(bodyWidget.sectionFormat, page);
        this.viewer.cutFromTop(blockToShift.y);
        this.viewer.blockToShift = blockToShift;
    };
    //Paste Implementation ends
    //Character Format apply implementation starts
    /**
     * Change HighlightColor
     * @param  {HighlightColor} highlightColor
     * Applies character format for selection.
     * @param {string} property
     * @param {Object} value
     * @param {boolean} update
     * @private
     */
    Editor.prototype.onApplyCharacterFormat = function (property, value, update) {
        if (this.restrictFormatting) {
            return;
        }
        this.viewer.layout.isBidiReLayout = true;
        var selection = this.viewer.selection;
        if (selection.owner.isReadOnlyMode || !selection.owner.isDocumentLoaded) {
            return;
        }
        update = isNullOrUndefined(update) ? false : update;
        var action = (property[0].toUpperCase() + property.slice(1));
        var paragraph = selection.start.paragraph;
        var lastLine = paragraph.childWidgets[paragraph.childWidgets.length - 1];
        if (selection.isEmpty && selection.contextType !== 'List') {
            selection.skipFormatRetrieval = true;
            if (selection.end.isAtParagraphEnd) {
                this.initHistory(action);
                this.viewer.owner.isShiftingEnabled = true;
                this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
                this.reLayout(this.viewer.selection);
                this.viewer.updateFocus();
            }
            else {
                selection.fireSelectionChanged(true);
            }
            selection.skipFormatRetrieval = false;
            return;
        }
        //Skip consider highlightcolor if paragraph mark alone is selected similar to Microsoft Word behaviour
        if (property === 'highlightColor' && selection.start.isInSameParagraph(selection.end)) {
            var start = selection.start;
            var end = selection.end;
            if (!this.selection.isForward) {
                end = selection.start;
                start = selection.end;
            }
            if (end.offset === selection.getLineLength(end.currentWidget) + 1 && end.offset - 1 === start.offset) {
                return;
            }
        }
        this.setOffsetValue(selection);
        this.initHistory(action);
        // Todo: Complete Microsoft Word behavior on apply formatting in empty selection
        // if (selection.isEmpty) {
        //     this.viewer.owner.isShiftingEnabled = true;
        //     this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
        //     this.reLayout(this.viewer.selection);
        //     this.viewer.updateFocus();
        //     return;
        // }
        if (selection.contextType === 'List') {
            // this.updateCharacterFormatForListText(selection, action, value, update);
            this.applyCharacterFormatForListText(selection, property, value, update);
        }
        else {
            //Iterate and update format.
            this.updateSelectionCharacterFormatting(property, value, update);
        }
        this.viewer.layout.isBidiReLayout = false;
    };
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyCharacterFormatForListText = function (selection, property, values, update) {
        var listLevel = this.getListLevel(selection.start.paragraph);
        if (isNullOrUndefined(listLevel)) {
            return;
        }
        var characterFormat = listLevel.characterFormat;
        switch (property) {
            case 'bold':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'bold', !(characterFormat.bold));
                break;
            case 'italic':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'italic', !(characterFormat.italic));
                break;
            case 'fontColor':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'fontColor', values);
                break;
            case 'fontFamily':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'fontFamily', values);
                break;
            case 'fontSize':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'fontSize', values);
                break;
            case 'highlightColor':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'highlightColor', values);
                break;
            case 'baselineAlignment':
                if (characterFormat.baselineAlignment === values) {
                    values = 'Normal';
                }
                this.applyListCharacterFormatByValue(selection, characterFormat, 'baselineAlignment', values);
                break;
            case 'strikethrough':
                if (characterFormat.strikethrough === values) {
                    values = 'None';
                }
                this.applyListCharacterFormatByValue(selection, characterFormat, 'strikethrough', values);
                break;
            case 'underline':
                if (characterFormat.underline === values) {
                    values = 'None';
                }
                this.applyListCharacterFormatByValue(selection, characterFormat, 'underline', values);
                break;
            case 'characterFormat':
                this.applyListCharacterFormatByValue(selection, characterFormat, undefined, values);
                break;
        }
    };
    Editor.prototype.applyListCharacterFormatByValue = function (selection, format, property, value) {
        this.initHistory('ListCharacterFormat');
        this.applyCharFormatValue(format, property, value, false);
        this.editorHistory.updateHistory();
        this.reLayout(selection);
        this.fireContentChange();
    };
    /**
     * @private
     */
    Editor.prototype.updateListCharacterFormat = function (selection, property, value) {
        this.updateListTextSelRange(selection, property, value, false);
    };
    Editor.prototype.updateListTextSelRange = function (selection, property, value, update) {
        this.viewer.owner.isShiftingEnabled = true;
        var startPositionInternal = selection.start;
        var endPositionInternal = selection.end;
        if (!selection.isForward) {
            startPositionInternal = selection.end;
            endPositionInternal = selection.start;
        }
        this.initHistoryPosition(selection, startPositionInternal);
        var listLevel = this.getListLevel(selection.start.paragraph);
        this.applyCharFormatValue(listLevel.characterFormat, property, value, update);
        this.startSelectionReLayouting(startPositionInternal.paragraph, selection, startPositionInternal, endPositionInternal);
    };
    /**
     * @private
     */
    Editor.prototype.getListLevel = function (paragraph) {
        var currentList = undefined;
        var listLevelNumber = 0;
        if (!isNullOrUndefined(paragraph.paragraphFormat) && !isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
            currentList = this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId);
            listLevelNumber = paragraph.paragraphFormat.listFormat.listLevelNumber;
        }
        if (!isNullOrUndefined(currentList) &&
            !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId))
            // && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId).levels.getItem(listLevelNumber))) {
            && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId).levels)) {
            return this.viewer.layout.getListLevel(currentList, listLevelNumber);
        }
        return undefined;
    };
    Editor.prototype.updateInsertPosition = function () {
        var selection = this.viewer.selection;
        var position = selection.start;
        if (!selection.isForward) {
            position = selection.end;
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)
            && !isNullOrUndefined(position)) {
            if (isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition)) {
                this.updateHistoryPosition(position, true);
            }
        }
    };
    /**
     * preserve paragraph and offset value for selection
     * @private
     */
    Editor.prototype.setOffsetValue = function (selection) {
        var info = this.selection.getParagraphInfo(selection.start);
        this.startParagraph = info.paragraph;
        this.startOffset = info.offset;
        info = this.selection.getParagraphInfo(selection.end);
        this.endParagraph = info.paragraph;
        this.endOffset = info.offset;
    };
    /**
     * Toggles the highlight color property of selected contents.
     * @param {HighlightColor} highlightColor Default value of underline parameter is Yellow.
     */
    Editor.prototype.toggleHighlightColor = function (highlightColor) {
        var selection = this.viewer.selection;
        if (isNullOrUndefined(highlightColor) || highlightColor === 'NoColor') {
            highlightColor = 'Yellow';
        }
        //In Ms Word the highlight color is took from the ribbon. So we Have given yellow as constant.
        if (selection.characterFormat.highlightColor === highlightColor) {
            highlightColor = 'NoColor';
        }
        this.selection.characterFormat.highlightColor = highlightColor;
    };
    /**
     * Toggles the subscript formatting of selected contents.
     */
    Editor.prototype.toggleSubscript = function () {
        if (!this.owner.isReadOnlyMode) {
            var value = this.selection.characterFormat.baselineAlignment === 'Subscript' ? 'Normal' : 'Subscript';
            this.selection.characterFormat.baselineAlignment = value;
        }
    };
    /**
     * Toggles the superscript formatting of selected contents.
     */
    Editor.prototype.toggleSuperscript = function () {
        if (!this.owner.isReadOnlyMode) {
            var value = this.selection.characterFormat.baselineAlignment === 'Superscript' ? 'Normal' : 'Superscript';
            this.selection.characterFormat.baselineAlignment = value;
        }
    };
    /**
     * Toggles the text alignment property of selected contents.
     * @param {TextAlignment} textAlignment Default value of textAlignment parameter is TextAlignment.Left.
     */
    /**
     * Increases the left indent of selected paragraphs to a factor of 36 points.
     */
    Editor.prototype.increaseIndent = function () {
        if (!this.owner.isReadOnlyMode) {
            this.onApplyParagraphFormat('leftIndent', this.viewer.defaultTabWidth, true, false);
        }
    };
    /**
     * Decreases the left indent of selected paragraphs to a factor of 36 points.
     */
    Editor.prototype.decreaseIndent = function () {
        if (!this.owner.isReadOnlyMode) {
            this.onApplyParagraphFormat('leftIndent', -this.viewer.defaultTabWidth, true, false);
        }
    };
    /**
     * Clears the list format for selected paragraphs.
     */
    Editor.prototype.clearList = function () {
        this.selection.owner.editorModule.onApplyList(undefined);
    };
    /**
     * Applies the bullet list to selected paragraphs.
     * @param {string} bullet Bullet character
     * @param {string} fontFamily Bullet font family
     */
    Editor.prototype.applyBullet = function (bullet, fontFamily) {
        if (!this.owner.isReadOnlyMode) {
            this.applyBulletOrNumbering(bullet, 'Bullet', fontFamily);
        }
    };
    /**
     * Applies the numbering list to selected paragraphs.
     * @param numberFormat  %n representations in numberFormat parameter will be replaced by respective list levels value.
     * `%1) will be displayed as 1) `
     * @param listLevelPattern  Default value of listLevelPattern parameter is ListLevelPattern.Arabic
     */
    Editor.prototype.applyNumbering = function (numberFormat, listLevelPattern) {
        if (!this.owner.isReadOnlyMode) {
            this.applyBulletOrNumbering(numberFormat, listLevelPattern, 'Verdana');
        }
    };
    /**
     * Toggles the baseline alignment property of selected contents.
     * @param  {Selection} selection
     * @param  {BaselineAlignment} baseAlignment
     */
    Editor.prototype.toggleBaselineAlignment = function (baseAlignment) {
        this.updateProperty(2, baseAlignment);
    };
    /**
     * Clears the formatting.
     */
    Editor.prototype.clearFormatting = function () {
        var selection = this.viewer.selection;
        this.initComplexHistory('ClearFormat');
        // let startIndex: string = selection.start.getHierarchicalIndexInternal();
        // let endIndex: string = selection.end.getHierarchicalIndexInternal();
        if (selection.isEmpty) {
            selection.start.moveToParagraphStartInternal(selection, false);
            selection.end.moveToParagraphEndInternal(selection, false);
        }
        this.setOffsetValue(selection);
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('ClearCharacterFormat');
        }
        this.updateSelectionCharacterFormatting('ClearCharacterFormat', undefined, false);
        this.getOffsetValue(selection);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.setOffsetValue(selection);
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('ClearParagraphFormat');
        }
        this.updateParagraphFormatInternal('ClearParagraphFormat', undefined, false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.getOffsetValue(selection);
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
            this.editorHistory.updateComplexHistory();
        }
        this.startParagraph = undefined;
        this.endParagraph = undefined;
        // else {
        //     this.checkAndUpdatedSelection(startIndex, endIndex);
        // }
    };
    /**
     * Toggles the specified property. If property is assigned already. Then property will be changed
     * @param  {Selection} selection
     * @param  {number} type
     * @param  {Object} value
     * @private
     */
    Editor.prototype.updateProperty = function (type, value) {
        var selection = this.selection;
        if (selection.owner.isReadOnlyMode || !selection.owner.isDocumentLoaded) {
            return;
        }
        var startPosition = selection.start;
        var endPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        var indexInInline = 0;
        var inlineObj = startPosition.currentWidget.getInline(startPosition.offset, indexInInline);
        var inline = inlineObj.element;
        indexInInline = inlineObj.index;
        var paragraph = startPosition.paragraph;
        if (!isNullOrUndefined(inline) && inline.length === indexInInline && !this.selection.isEmpty) {
            inline = inline.nextNode;
        }
        if (type === 1) {
            var currentUnderline = 'None';
            if (!isNullOrUndefined(inline)) {
                currentUnderline = inline.characterFormat.underline;
            }
            else if (!isNullOrUndefined(paragraph)) {
                currentUnderline = paragraph.characterFormat.underline;
            }
            this.selection.characterFormat.underline = value === currentUnderline ? 'None' : value;
        }
        else {
            var script = 'Normal';
            if (!isNullOrUndefined(inline)) {
                script = inline.characterFormat.baselineAlignment;
            }
            else if (!isNullOrUndefined(paragraph)) {
                script = paragraph.characterFormat.baselineAlignment;
            }
            if (script === value) {
                value = 'Normal';
            }
            this.selection.characterFormat.baselineAlignment = value;
        }
    };
    Editor.prototype.getCompleteStyles = function () {
        var completeStylesString = '{"styles":[';
        for (var _i = 0, _a = this.viewer.preDefinedStyles.keys; _i < _a.length; _i++) {
            var name_1 = _a[_i];
            completeStylesString += (this.viewer.preDefinedStyles.get(name_1) + ',');
        }
        return completeStylesString.slice(0, -1) + ']}';
    };
    /**
     * Initialize default styles
     * @private
     */
    Editor.prototype.intializeDefaultStyles = function () {
        var existingStyles = this.owner.getStyleNames('Paragraph');
        var defaultStyleNames = ['Normal', 'Heading 1', 'Heading 2', 'Heading 3', 'Heading 4', 'Heading 5', 'Heading 6'];
        var styleNames = defaultStyleNames.filter(function (val) {
            return existingStyles.indexOf(val) === -1;
        });
        for (var _i = 0, styleNames_1 = styleNames; _i < styleNames_1.length; _i++) {
            var name_2 = styleNames_1[_i];
            this.createStyle(this.viewer.preDefinedStyles.get(name_2));
        }
    };
    /**
     * Creates a new instance of Style.
     */
    Editor.prototype.createStyle = function (styleString) {
        this.createStyleIn(styleString);
    };
    /**
     * Create a Style.
     * @private
     */
    Editor.prototype.createStyleIn = function (styleString) {
        /* tslint:disable:no-any */
        var style = JSON.parse(styleString);
        var styleObj = this.viewer.styles.findByName(style.name);
        if (styleObj !== undefined) {
            //Create a new style with new name and add it to collection.
            style.name = this.getUniqueStyleName(style.name);
        }
        this.viewer.owner.parser.parseStyle(JSON.parse(this.getCompleteStyles()), style, this.viewer.styles);
        return this.viewer.styles.findByName(style.name);
    };
    /**
     * @private
     */
    Editor.prototype.getUniqueStyleName = function (name) {
        var uniqueName = this.getUniqueName(name);
        var style = this.viewer.styles.findByName(uniqueName);
        while (!isNullOrUndefined(style)) {
            uniqueName = this.getUniqueStyleName(style.name);
            style = this.viewer.styles.findByName(uniqueName);
        }
        return uniqueName;
    };
    Editor.prototype.getUniqueName = function (name) {
        var matchArray = name.match(/\d+$/);
        if (!isNullOrUndefined(matchArray) && matchArray.length > 0) {
            return name.replace(matchArray[0], (parseInt(matchArray[0], 10) + 1).toString());
        }
        else {
            return name + '_1';
        }
    };
    /**
     * Update Character format for selection
     * @private
     */
    Editor.prototype.updateSelectionCharacterFormatting = function (property, values, update) {
        if (isNullOrUndefined(property)) {
            property = 'CharacterFormat';
        }
        switch (property) {
            case 'bold':
                this.updateCharacterFormat('bold', values);
                break;
            case 'italic':
                this.updateCharacterFormat('italic', values);
                break;
            case 'fontColor':
                this.updateCharacterFormat('fontColor', values);
                break;
            case 'fontFamily':
                this.updateCharacterFormat('fontFamily', values);
                break;
            case 'fontSize':
                this.viewer.layout.isBidiReLayout = false;
                this.updateCharacterFormatWithUpdate(this.viewer.selection, 'fontSize', values, update);
                break;
            case 'highlightColor':
                this.updateCharacterFormat('highlightColor', values);
                break;
            case 'baselineAlignment':
                this.updateCharacterFormat('baselineAlignment', values);
                break;
            case 'strikethrough':
                this.updateCharacterFormat('strikethrough', values);
                break;
            case 'underline':
                this.updateCharacterFormat('underline', values);
                break;
            case 'styleName':
                this.updateCharacterFormatWithUpdate(this.viewer.selection, 'styleName', values, true);
                break;
            case 'CharacterFormat':
                this.updateCharacterFormat(undefined, values);
                break;
            case 'ClearCharacterFormat':
                this.updateCharacterFormat(undefined, values);
                break;
        }
        this.reLayout(this.viewer.selection);
    };
    /**
     * Update character format for selection range
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @returns void
     * @private
     */
    Editor.prototype.updateCharacterFormat = function (property, value) {
        this.updateCharacterFormatWithUpdate(this.viewer.selection, property, value, false);
    };
    Editor.prototype.updateCharacterFormatWithUpdate = function (selection, property, value, update) {
        this.viewer.owner.isShiftingEnabled = true;
        var startPosition = selection.start;
        var endPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        this.applyCharFormatSelectedContent(startPosition.paragraph, selection, startPosition, endPosition, property, value, update);
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyCharFormatSelectedContent = function (paragraph, selection, start, end, property, value, update) {
        //Selection start in cell.
        if (start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
            || start.paragraph.associatedCell !== end.paragraph.associatedCell
            || selection.isCellSelected(start.paragraph.associatedCell, start, end))) {
            var cell = void 0;
            start.paragraph.associatedCell.ownerTable.combineWidget(this.viewer);
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(start, true);
            }
            cell = start.paragraph.associatedCell;
            this.applyCharFormatCell(cell, selection, start, end, property, value, update);
            var table = cell.ownerTable;
            // tslint:disable-next-line:max-line-length
            this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        }
        else {
            this.applyCharFormat(paragraph, selection, start, end, property, value, update);
        }
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyCharFormatForSelectedPara = function (paragraph, selection, property, value, update) {
        for (var i = 0; i < paragraph.childWidgets.length; i++) {
            var line = paragraph.childWidgets[i];
            for (var j = 0; j < line.children.length; j++) {
                var element = line.children[j];
                this.applyCharFormatValue(element.characterFormat, property, value, update);
            }
        }
        this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
    };
    Editor.prototype.splittedLastParagraph = function (paragraph) {
        var splittedWidets = paragraph.getSplitWidgets();
        return splittedWidets[splittedWidets.length - 1];
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.getNextParagraphForCharacterFormatting = function (block, start, end, property, value, update) {
        var widgetCollection = block.getSplitWidgets();
        block = widgetCollection[widgetCollection.length - 1];
        block = this.viewer.selection.getNextRenderedBlock(block);
        if (!isNullOrUndefined(block)) { //Goto the next block.
            if (block instanceof ParagraphWidget) {
                this.applyCharFormat(block, this.viewer.selection, start, end, property, value, update);
            }
            else {
                this.applyCharFormatForTable(0, block, this.viewer.selection, start, end, property, value, update);
            }
        }
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyCharFormat = function (paragraph, selection, start, end, property, value, update) {
        paragraph = paragraph.combineWidget(this.viewer);
        var startOffset = 0;
        var length = selection.getParagraphLength(paragraph);
        var startLineWidget = paragraph.childWidgets.indexOf(start.currentWidget) !== -1 ?
            paragraph.childWidgets.indexOf(start.currentWidget) : 0;
        var endOffset = end.offset;
        var endLineWidget = paragraph.childWidgets.indexOf(end.currentWidget) !== -1 ?
            paragraph.childWidgets.indexOf(end.currentWidget) : paragraph.childWidgets.length - 1;
        if (!isNullOrUndefined(selection)) {
            if (paragraph === start.paragraph) {
                startOffset = start.offset;
            }
        }
        if (!paragraph.equals(end.paragraph)) {
            var lastLine = paragraph.childWidgets[paragraph.childWidgets.length - 1];
            //Skip consider highlightcolor if paragraph mark alone is selected similar to Microsoft Word behaviour
            if (!(property === 'highlightColor' && selection.isParagraphLastLine(lastLine)
                && start.currentWidget === lastLine && start.offset === selection.getLineLength(lastLine))) {
                this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
            }
            endOffset = length;
        }
        else {
            var lastLine = paragraph.childWidgets[paragraph.childWidgets.length - 1];
            if (selection.isParagraphLastLine(lastLine) && end.currentWidget === lastLine
                && ((endOffset === selection.getLineLength(lastLine) + 1) || (selection.isEmpty && selection.end.isAtParagraphEnd))) {
                this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
            }
        }
        // let count: number = 0;
        for (var i = startLineWidget; i <= endLineWidget; i++) {
            var line = paragraph.childWidgets[i];
            if (i !== startLineWidget) {
                startOffset = selection.getStartLineOffset(line);
            }
            if (line === end.currentWidget) {
                endOffset = end.offset;
            }
            else {
                endOffset = selection.getLineLength(line);
            }
            var count = 0;
            for (var j = 0; j < line.children.length; j++) {
                var inlineObj = line.children[j];
                if (inlineObj instanceof ListTextElementBox) {
                    continue;
                }
                if (startOffset >= count + inlineObj.length) {
                    count += inlineObj.length;
                    continue;
                }
                var startIndex = 0;
                if (startOffset > count) {
                    startIndex = startOffset - count;
                }
                var endIndex = endOffset - count;
                var inlineLength = inlineObj.length;
                if (endIndex > inlineLength) {
                    endIndex = inlineLength;
                }
                j += this.applyCharFormatInline(inlineObj, selection, startIndex, endIndex, property, value, update);
                if (endOffset <= count + inlineLength) {
                    break;
                }
                count += inlineLength;
            }
        }
        var endParagraph = end.paragraph;
        this.viewer.layout.reLayoutParagraph(paragraph, startLineWidget, 0);
        if (paragraph.equals(endParagraph)) {
            return;
        }
        this.getNextParagraphForCharacterFormatting(paragraph, start, end, property, value, update);
    };
    /**
     * Toggles the bold property of selected contents.
     */
    Editor.prototype.toggleBold = function () {
        if (this.viewer.owner.isReadOnlyMode) {
            return;
        }
        var value = this.getCurrentSelectionValue('bold');
        this.selection.characterFormat.bold = value;
    };
    /**
     * Toggles the bold property of selected contents.
     */
    Editor.prototype.toggleItalic = function () {
        if (this.viewer.owner.isReadOnlyMode) {
            return;
        }
        var value = this.getCurrentSelectionValue('italic');
        this.selection.characterFormat.italic = value;
    };
    Editor.prototype.getCurrentSelectionValue = function (property) {
        var value = false;
        if ((property === 'bold' || property === 'italic')) {
            var index = 0;
            var start = this.selection.start;
            if (!this.selection.isForward) {
                start = this.selection.end;
            }
            var lineWidget = start.currentWidget;
            var inlineObj = lineWidget.getInline(start.offset, index);
            var inline = inlineObj.element;
            // inline.ownerBase
            index = inlineObj.index;
            var characterFormat = lineWidget.paragraph.characterFormat;
            if (!isNullOrUndefined(inline)) {
                if (!this.selection.isEmpty && index === inline.length) {
                    characterFormat = isNullOrUndefined(inline.nextNode) ? lineWidget.paragraph.characterFormat
                        : inline.nextNode.characterFormat;
                }
                else {
                    characterFormat = inline.characterFormat;
                }
            }
            if (property === 'bold') {
                value = !(characterFormat.bold);
            }
            if (property === 'italic') {
                value = !(characterFormat.italic);
            }
        }
        return value;
    };
    /**
     * Toggles the underline property of selected contents.
     * @param underline Default value of underline parameter is Single.
     */
    Editor.prototype.toggleUnderline = function (underline) {
        if (!this.owner.isReadOnlyMode) {
            this.updateProperty(1, underline);
        }
    };
    /**
     * Toggles the strike through property of selected contents.
     * @param {Strikethrough} strikethrough Default value of strikethrough parameter is SingleStrike.
     */
    Editor.prototype.toggleStrikethrough = function (strikethrough) {
        if (!this.owner.isReadOnlyMode) {
            var value = void 0;
            if (isNullOrUndefined(strikethrough)) {
                value = this.selection.characterFormat.strikethrough === 'SingleStrike' ? 'None' : 'SingleStrike';
            }
            else {
                value = strikethrough;
            }
            this.selection.characterFormat.strikethrough = value;
        }
    };
    Editor.prototype.updateFontSize = function (format, value) {
        if (typeof (value) === 'number' && !(value < 0 && format.fontSize === 1)) {
            return format.fontSize + value;
        }
        var fontsizeCollection = [8, 9, 10, 11, 12, 14, 16, 18, 20, 24, 26, 28, 36, 48, 72];
        if (typeof (value) === 'string' && value === 'increment') {
            if (format.fontSize < 8) {
                return format.fontSize + 1;
            }
            else if (format.fontSize >= 72 && format.fontSize < 80) {
                return 80;
            }
            else if (format.fontSize >= 80) {
                return format.fontSize + 10;
            }
            else {
                for (var i = 0; i < fontsizeCollection.length; i++) {
                    if (format.fontSize < fontsizeCollection[i]) {
                        return fontsizeCollection[i];
                    }
                }
            }
        }
        else if (typeof (value) === 'string' && value === 'decrement' && format.fontSize > 1) {
            if (format.fontSize <= 8) {
                return format.fontSize - 1;
            }
            else if (format.fontSize > 72 && format.fontSize <= 80) {
                return 72;
            }
            else if (format.fontSize > 80) {
                return format.fontSize - 10;
            }
            else {
                for (var i = 0; i < fontsizeCollection.length; i++) {
                    if (format.fontSize <= fontsizeCollection[i]) {
                        return fontsizeCollection[i - 1];
                    }
                }
            }
        }
        return format.fontSize;
    };
    // Inline
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyCharFormatInline = function (inline, selection, startIndex, endIndex, property, value, update) {
        if (startIndex === 0 && endIndex === inline.length) {
            this.applyCharFormatValue(inline.characterFormat, property, value, update);
            return 0;
        }
        else if (inline instanceof TextElementBox) {
            return this.formatInline(inline, selection, startIndex, endIndex, property, value, update);
        }
        return 0;
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.formatInline = function (inline, selection, startIndex, endIndex, property, value, update) {
        var x = 0;
        var node = inline;
        var index = inline.line.children.indexOf(node);
        var paragraph = inline.paragraph;
        var lineIndex = paragraph.childWidgets.indexOf(inline.line);
        var textElement;
        if (startIndex > 0) {
            textElement = new TextElementBox();
            textElement.characterFormat.copyFormat(inline.characterFormat);
            textElement.line = inline.line;
            textElement.text = inline.text.substr(startIndex, endIndex - startIndex);
            this.applyCharFormatValue(textElement.characterFormat, property, value, update);
            index++;
            node.line.children.splice(index, 0, textElement);
            x++;
            // this.addToLinkedFields(span);                      
        }
        if (endIndex < node.length) {
            textElement = new TextElementBox();
            textElement.characterFormat.copyFormat(inline.characterFormat);
            textElement.text = node.text.substring(endIndex);
            textElement.line = inline.line;
            index++;
            node.line.children.splice(index, 0, textElement);
            x++;
            // this.addToLinkedFields(span);                       
        }
        if (startIndex === 0) {
            inline.text = inline.text.substr(0, endIndex);
            this.applyCharFormatValue(inline.characterFormat, property, value, update);
        }
        else {
            inline.text = inline.text.substr(0, startIndex);
        }
        return x;
    };
    // Cell
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyCharFormatCell = function (cell, selection, start, end, property, value, update) {
        if (end.paragraph.isInsideTable) {
            var containerCell = selection.getContainerCellOf(cell, end.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(end.paragraph.associatedCell)) {
                var startCell = selection.getSelectedCell(cell, containerCell);
                var endCell = selection.getSelectedCell(end.paragraph.associatedCell, containerCell);
                if (selection.containsCell(containerCell, end.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (selection.isCellSelected(containerCell, start, end)) {
                        value = this.getCharacterFormatValueOfCell(cell, selection, value, property);
                        this.applyCharFormatForSelectedCell(containerCell, selection, property, value, update);
                    }
                    else {
                        if (startCell === containerCell) {
                            this.applyCharFormat(start.paragraph, selection, start, end, property, value, update);
                        }
                        else {
                            this.applyCharFormatRow(startCell.ownerRow, selection, start, end, property, value, update);
                        }
                    }
                }
                else { //Format other selected cells in current table.
                    this.applyCharFormatForTableCell(containerCell.ownerTable, selection, containerCell, endCell, property, value, update);
                }
            }
            else {
                this.applyCharFormatRow(containerCell.ownerRow, selection, start, end, property, value, update);
            }
        }
        else {
            var tableCell = selection.getContainerCell(cell);
            this.applyCharFormatRow(tableCell.ownerRow, selection, start, end, property, value, update);
        }
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyCharFormatForSelectedCell = function (cell, selection, property, value, update) {
        for (var i = 0; i < cell.childWidgets.length; i++) {
            var block = cell.childWidgets[i];
            if (block instanceof ParagraphWidget) {
                this.applyCharFormatForSelectedPara(block, selection, property, value, update);
            }
            else {
                this.applyCharFormatForSelTable(block, selection, property, value, update);
            }
        }
    };
    // Row
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyCharFormatRow = function (row, selection, start, end, property, value, update) {
        value = this.getCharacterFormatValueOfCell(row.childWidgets[0], selection, value, property);
        this.applyCharFormatForTable(row.rowIndex, row.ownerTable, selection, start, end, property, value, update);
    };
    // Table
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyCharFormatForTable = function (index, table, selection, start, end, property, value, update) {
        table = table.combineWidget(this.viewer);
        for (var i = index; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                this.applyCharFormatForSelectedCell(row.childWidgets[j], selection, property, value, update);
            }
            if (end.paragraph.isInsideTable && selection.containsRow(row, end.paragraph.associatedCell)) {
                this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
                return;
            }
        }
        this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        this.getNextParagraphForCharacterFormatting(table, start, end, property, value, update);
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyCharFormatForSelTable = function (tableWidget, selection, property, value, update) {
        for (var i = 0; i < tableWidget.childWidgets.length; i++) {
            var row = tableWidget.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                this.applyCharFormatForSelectedCell(row.childWidgets[j], selection, property, value, update);
            }
        }
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyCharFormatForTableCell = function (table, selection, startCell, endCell, property, value, update) {
        var startCellLeft = selection.getCellLeft(startCell.ownerRow, startCell);
        var startCellRight = startCellLeft + startCell.cellFormat.cellWidth;
        var endCellLeft = selection.getCellLeft(endCell.ownerRow, endCell);
        var endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        var cellInfo = this.updateSelectedCellsInTable(startCellLeft, startCellRight, endCellLeft, endCellRight);
        startCellLeft = cellInfo.start;
        startCellRight = cellInfo.end;
        var count = table.childWidgets.indexOf(endCell.ownerRow);
        var isStarted = false;
        for (var i = table.childWidgets.indexOf(startCell.ownerRow); i <= count; i++) {
            var row = table.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                var left = selection.getCellLeft(row, row.childWidgets[j]);
                if (HelperMethods.round(startCellLeft, 2) <= HelperMethods.round(left, 2) &&
                    HelperMethods.round(left, 2) < HelperMethods.round(startCellRight, 2)) {
                    if (!isStarted) {
                        value = this.getCharacterFormatValueOfCell(row.childWidgets[j], selection, value, property);
                        isStarted = true;
                    }
                    this.applyCharFormatForSelectedCell(row.childWidgets[j], selection, property, value, update);
                }
            }
        }
    };
    Editor.prototype.updateSelectedCellsInTable = function (start, end, endCellLeft, endCellRight) {
        var selection = this.viewer.selection;
        if (start > endCellLeft) {
            start = endCellLeft;
        }
        if (end < endCellRight) {
            end = endCellRight;
        }
        if (start > selection.upDownSelectionLength) {
            start = selection.upDownSelectionLength;
        }
        if (end < selection.upDownSelectionLength) {
            end = selection.upDownSelectionLength;
        }
        return { start: start, end: end };
    };
    Editor.prototype.getCharacterFormatValueOfCell = function (cell, selection, value, property) {
        if (typeof (value) === 'boolean' || (value === undefined && (property === 'bold' || property === 'italic'))) {
            var firstParagraph = selection.getFirstParagraph(cell);
            var format = firstParagraph.characterFormat;
            if (firstParagraph.childWidgets.length > 0 && firstParagraph.childWidgets[0].children.length > 0) {
                format = firstParagraph.childWidgets[0].children[0].characterFormat;
            }
            value = !format.getPropertyValue(property);
        }
        return value;
    };
    /**
     * Apply Character format for selection
     * @private
     */
    Editor.prototype.applyCharFormatValueInternal = function (selection, format, property, value) {
        this.applyCharFormatValue(format, property, value, false);
    };
    Editor.prototype.copyInlineCharacterFormat = function (sourceFormat, destFormat) {
        destFormat.uniqueCharacterFormat = sourceFormat.uniqueCharacterFormat;
        destFormat.baseCharStyle = sourceFormat.baseCharStyle;
    };
    Editor.prototype.applyCharFormatValue = function (format, property, value, update) {
        if (update && property === 'fontSize') {
            value = this.updateFontSize(format, value);
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedProperties(format, property, value);
        }
        if (value instanceof WCharacterFormat) {
            if (this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
                this.copyInlineCharacterFormat(value, format);
            }
            else {
                format.copyFormat(value);
            }
            return;
        }
        if (isNullOrUndefined(value)) {
            format.clearFormat();
            return;
        }
        if (property === 'bold') {
            format.bold = value;
        }
        else if (property === 'italic') {
            format.italic = value;
        }
        else if (property === 'fontColor') {
            format.fontColor = value;
        }
        else if (property === 'fontFamily') {
            format.fontFamily = value;
        }
        else if (property === 'fontSize') {
            format.fontSize = value;
        }
        else if (property === 'highlightColor') {
            format.highlightColor = value;
        }
        else if (property === 'baselineAlignment') {
            format.baselineAlignment = value;
        }
        else if (property === 'strikethrough') {
            format.strikethrough = value;
        }
        else if (property === 'underline') {
            format.underline = value;
        }
        else if (property === 'styleName') {
            format.baseCharStyle = value;
        }
    };
    /**
     * @private
     */
    Editor.prototype.onImageFormat = function (elementBox, width, height) {
        var modifiedFormat = new ImageFormat(elementBox);
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('ImageResizing');
            this.editorHistory.currentBaseHistoryInfo.modifiedProperties.push(modifiedFormat);
        }
        this.setOffsetValue(this.selection);
        elementBox.width = width;
        elementBox.height = height;
        // tslint:disable-next-line:max-line-length
        this.viewer.layout.reLayoutParagraph(elementBox.line.paragraph, elementBox.line.indexInOwner, 0);
        this.reLayout(this.selection, false);
        if (this.viewer.owner.imageResizerModule) {
            this.viewer.owner.imageResizerModule.positionImageResizer(elementBox);
        }
    };
    /**
     * Toggles the text alignment of selected paragraphs.
     * @param  {TextAlignment} textAlignment
     */
    Editor.prototype.toggleTextAlignment = function (textAlignment) {
        if (this.viewer.owner.isReadOnlyMode || !this.viewer.owner.isDocumentLoaded) {
            return;
        }
        // Toggle performed based on current selection format similar to MS word behavior.
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(this.viewer.selection.paragraphFormat.textAlignment) && this.viewer.selection.paragraphFormat.textAlignment === textAlignment) {
            if (textAlignment === 'Left') {
                this.onApplyParagraphFormat('textAlignment', 'Justify', false, true);
            }
            else {
                this.onApplyParagraphFormat('textAlignment', 'Left', false, true);
            }
        }
        else {
            this.onApplyParagraphFormat('textAlignment', textAlignment, false, true);
        }
    };
    /**
     * Applies paragraph format for the selection ranges.
     * @param {string} property
     * @param {Object} value
     * @param {boolean} update
     * @param {boolean} isSelectionChanged
     * @private
     */
    Editor.prototype.onApplyParagraphFormat = function (property, value, update, isSelectionChanged) {
        if (this.restrictFormatting) {
            return;
        }
        var action = property === 'bidi' ? 'ParagraphBidi' : (property[0].toUpperCase() + property.slice(1));
        this.viewer.owner.isShiftingEnabled = true;
        var selection = this.viewer.selection;
        this.initHistory(action);
        if (this.viewer.owner.isReadOnlyMode || !this.viewer.owner.isDocumentLoaded) {
            return;
        }
        if (property === 'leftIndent') {
            if (selection.paragraphFormat.listId !== -1 && update) {
                this.updateListLevel(value > 0);
                return;
            }
        }
        if (selection.isEmpty) {
            this.setOffsetValue(selection);
            var isBidiList = selection.paragraphFormat.bidi &&
                (property === 'listFormat' || selection.paragraphFormat.listId !== -1);
            if (!isBidiList) {
                this.viewer.layout.isBidiReLayout = true;
            }
            if (update && property === 'leftIndent') {
                value = this.getIndentIncrementValue(selection.start.paragraph, value);
            }
            var para = selection.start.paragraph.combineWidget(this.viewer);
            this.applyParaFormatProperty(para, property, value, update);
            this.layoutItemBlock(para, false);
            if (!isBidiList) {
                this.viewer.layout.isBidiReLayout = false;
            }
        }
        else {
            //Iterate and update formatting's.      
            if (action !== 'ParagraphBidi') {
                this.setOffsetValue(selection);
            }
            this.updateSelectionParagraphFormatting(property, value, update);
        }
        this.reLayout(selection);
    };
    /**
     * Update the list level
     * @param  {boolean} increaseLevel
     * @private
     */
    Editor.prototype.updateListLevel = function (increaseLevel) {
        // Increment or Decrement list level for Multilevel lists.
        var viewer = this.viewer;
        var listFormat = this.viewer.selection.start.paragraph.paragraphFormat.listFormat;
        var paragraphFormat = this.viewer.selection.start.paragraph.paragraphFormat;
        var list = viewer.getListById(paragraphFormat.listFormat.listId);
        var listLevel = viewer.layout.getListLevel(list, paragraphFormat.listFormat.listLevelNumber);
        var levelNumber;
        if (increaseLevel) {
            levelNumber = paragraphFormat.listFormat.listLevelNumber + 1;
        }
        else {
            levelNumber = paragraphFormat.listFormat.listLevelNumber - 1;
        }
        var nextListLevel = viewer.layout.getListLevel(list, levelNumber);
        if (!isNullOrUndefined(nextListLevel)) {
            this.onApplyListInternal(list, levelNumber);
            viewer.selection.start.updatePhysicalPosition(true);
            viewer.selection.end.updatePhysicalPosition(true);
            viewer.selection.updateCaretPosition();
        }
    };
    /**
     * Applies list
     * @param  {WList} list
     * @param  {number} listLevelNumber
     * @private
     */
    Editor.prototype.onApplyListInternal = function (list, listLevelNumber) {
        var selection = this.viewer.selection;
        var listFormat = new WListFormat();
        if (!isNullOrUndefined(list) && listLevelNumber >= 0 && listLevelNumber < 9) {
            listFormat.listId = list.listId;
            listFormat.listLevelNumber = listLevelNumber;
        }
        this.onApplyParagraphFormat('listFormat', listFormat, false, false);
    };
    /**
     * Apply paragraph format to selection range
     * @private
     */
    Editor.prototype.updateSelectionParagraphFormatting = function (property, value, update) {
        var selection = this.viewer.selection;
        if (property === 'leftIndent' && update) {
            if (!isNullOrUndefined(selection.start) && selection.start.isExistBefore(selection.end)) {
                value = this.getIndentIncrementValue(selection.start.paragraph, value);
            }
            else {
                value = this.getIndentIncrementValue(selection.end.paragraph, value);
            }
        }
        this.updateParagraphFormatInternal(property, value, update);
    };
    Editor.prototype.getIndentIncrementValue = function (currentParagraph, incrementFactor) {
        var currentParagraphIndent = currentParagraph.paragraphFormat.leftIndent;
        if (currentParagraphIndent < 0) {
            // In MS Word, if the current paragraph left indent is lesser that or equal to 0
            // then performing decrement indent will set left indent to 0. 
            if (incrementFactor < 0 || currentParagraphIndent + incrementFactor >= 0) {
                return -currentParagraphIndent;
            }
            else {
                var incrementValue = -this.getIndentIncrementValueInternal(-currentParagraphIndent, -incrementFactor);
                return incrementValue % incrementFactor === 0 ? incrementValue : incrementValue + incrementFactor;
            }
        }
        else {
            return this.getIndentIncrementValueInternal(currentParagraphIndent, incrementFactor);
        }
    };
    Editor.prototype.getIndentIncrementValueInternal = function (position, incrementFactor) {
        var tabValue = Math.abs(incrementFactor);
        if (position === 0 || tabValue === 0) {
            return incrementFactor > 0 ? tabValue : 0;
        }
        else {
            var diff = ((Math.round(position) * 100) % (Math.round(tabValue) * 100)) / 100;
            var cnt = (Math.round(position) - diff) / Math.round(tabValue);
            var fPosition = cnt * tabValue;
            if (incrementFactor > 0) {
                fPosition += tabValue;
            }
            return (fPosition - position) === 0 ? incrementFactor : fPosition - position;
        }
    };
    Editor.prototype.updateParagraphFormatInternal = function (property, value, update) {
        if (isNullOrUndefined(property)) {
            property = 'ParagraphFormat';
        }
        switch (property) {
            case 'afterSpacing':
                this.updateParagraphFormat('afterSpacing', value, false);
                break;
            case 'beforeSpacing':
                this.updateParagraphFormat('beforeSpacing', value, false);
                break;
            case 'rightIndent':
                this.updateParagraphFormat('rightIndent', value, false);
                break;
            case 'leftIndent':
                this.updateParagraphFormat('leftIndent', value, update);
                break;
            case 'firstLineIndent':
                this.updateParagraphFormat('firstLineIndent', value, false);
                break;
            case 'lineSpacing':
                this.updateParagraphFormat('lineSpacing', value, false);
                break;
            case 'lineSpacingType':
                this.updateParagraphFormat('lineSpacingType', value, false);
                break;
            case 'textAlignment':
                this.updateParagraphFormat('textAlignment', value, false);
                break;
            case 'listFormat':
                this.updateParagraphFormat('listFormat', value, false);
                break;
            case 'ParagraphFormat':
                this.updateParagraphFormat(undefined, value, false);
                break;
            case 'styleName':
                this.updateParagraphFormat('styleName', value, false);
                break;
            case 'ClearParagraphFormat':
                // this.initializeHistory('ClearParagraphFormat', selectionRange);
                this.updateParagraphFormat(undefined, value, false);
                break;
            case 'bidi':
                var isBidiList = this.selection.paragraphFormat.listId !== -1;
                if (!isBidiList) {
                    this.viewer.layout.isBidiReLayout = true;
                }
                this.updateParagraphFormat('bidi', value, false);
                if (!isBidiList) {
                    this.viewer.layout.isBidiReLayout = false;
                }
                break;
            case 'contextualSpacing':
                this.updateParagraphFormat('contextualSpacing', value, false);
                break;
        }
    };
    /**
     * Update paragraph format on undo
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @param  {boolean} update
     * @private
     */
    Editor.prototype.updateParagraphFormat = function (property, value, update) {
        var selection = this.viewer.selection;
        var startPosition = selection.start;
        var endPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        // this.updateInsertPosition(selection, startPosition);
        this.applyParaFormatSelectedContent(startPosition, endPosition, property, value, update);
        // this.startSelectionReLayouting(startPosition.paragraph, selection, startPosition, endPosition);
    };
    Editor.prototype.applyParaFormatSelectedContent = function (start, end, property, value, update) {
        var selection = this.viewer.selection;
        if (start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
            || start.paragraph.associatedCell !== end.paragraph.associatedCell
            || selection.isCellSelected(start.paragraph.associatedCell, start, end))) {
            var cell = void 0;
            start.paragraph.associatedCell.ownerTable.combineWidget(this.viewer);
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(start, true);
            }
            cell = start.paragraph.associatedCell;
            this.applyParaFormatInCell(cell, start, end, property, value, update);
            var table = cell.ownerTable;
            this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        }
        else {
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(value) && !this.selection.isEmpty && property === 'styleName' && this.applyCharacterStyle(start.paragraph, start, end, property, value, update)) {
                return;
            }
            else {
                this.applyParaFormat(start.paragraph, start, end, property, value, update);
            }
        }
    };
    /**
     * Apply Paragraph format
     * @private
     */
    Editor.prototype.applyParaFormatProperty = function (paragraph, property, value, update) {
        var format = paragraph.paragraphFormat;
        if (update && property === 'leftIndent') {
            value = format.leftIndent + value;
        }
        if (property === 'listFormat' && value instanceof WListFormat) {
            var listFormat = value;
            if (!listFormat.hasValue('listLevelNumber')) {
                listFormat.listLevelNumber = format.listFormat.listLevelNumber;
            }
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedPropertiesForParagraphFormat(format, property, value);
        }
        if (value instanceof WParagraphFormat) {
            if (isNullOrUndefined(property)) {
                if (this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
                    this.copyParagraphFormat(value, format);
                }
                else {
                    format.copyFormat(value);
                }
            }
            else if (property === 'listFormat') {
                format.listFormat = value.listFormat;
                // this.handleListFormat(format, value as WParagraphFormat);
            }
        }
        if (isNullOrUndefined(value)) {
            format.clearFormat();
            this.viewer.layout.reLayoutParagraph(format.ownerBase, 0, 0);
            return;
        }
        if (property === 'afterSpacing') {
            format.afterSpacing = value;
        }
        else if (property === 'beforeSpacing') {
            format.beforeSpacing = value;
        }
        else if (property === 'leftIndent') {
            format.leftIndent = value;
        }
        else if (property === 'lineSpacingType') {
            format.lineSpacingType = value;
        }
        else if (property === 'lineSpacing') {
            format.lineSpacing = value;
        }
        else if (property === 'rightIndent') {
            format.rightIndent = value;
        }
        else if (property === 'firstLineIndent') {
            format.firstLineIndent = value;
        }
        else if (property === 'textAlignment') {
            format.textAlignment = value;
            this.viewer.layout.allowLayout = false;
        }
        else if (property === 'styleName') {
            if (typeof (value) === 'string') {
                value = this.viewer.styles.findByName(value);
            }
            format.ApplyStyle(value);
        }
        else if (property === 'listFormat') {
            if (value instanceof WParagraphFormat) {
                this.copyFromListLevelParagraphFormat(format, value);
                value = value.listFormat;
            }
            format.listFormat.copyFormat(value);
            this.viewer.layout.clearListElementBox(format.ownerBase);
            this.onListFormatChange(format.ownerBase, value, format);
            this.layoutItemBlock(format.ownerBase, false);
            return;
        }
        else if (property === 'bidi') {
            format.bidi = value;
        }
        else if (property === 'contextualSpacing') {
            format.contextualSpacing = value;
        }
    };
    Editor.prototype.copyParagraphFormat = function (sourceFormat, destFormat) {
        destFormat.uniqueParagraphFormat = sourceFormat.uniqueParagraphFormat;
        destFormat.listFormat = sourceFormat.listFormat;
        destFormat.baseStyle = sourceFormat.baseStyle;
    };
    Editor.prototype.onListFormatChange = function (paragraph, listFormat, paraFormat) {
        if (listFormat instanceof WListFormat) {
            this.updateListParagraphFormat(paragraph, listFormat);
        }
    };
    Editor.prototype.updateListParagraphFormat = function (paragraph, listFormat) {
        var list = this.viewer.getListById(listFormat.listId);
        var listlevel = undefined;
        if (!isNullOrUndefined(list)) {
            listlevel = this.viewer.layout.getListLevel(list, listFormat.listLevelNumber);
        }
        var isUpdateIndent = !this.editorHistory || (this.editorHistory && !this.editorHistory.isUndoing);
        if (isUpdateIndent) {
            if (paragraph instanceof ParagraphWidget && !isNullOrUndefined(listlevel)
                && !isNullOrUndefined(listlevel.paragraphFormat) && !isNullOrUndefined(paragraph.containerWidget)) {
                this.copyFromListLevelParagraphFormat(paragraph.paragraphFormat, listlevel.paragraphFormat);
            }
            else if (isNullOrUndefined(list)) {
                paragraph.paragraphFormat.leftIndent = undefined;
                paragraph.paragraphFormat.firstLineIndent = undefined;
            }
        }
    };
    /**
     * Copies list level paragraph format
     * @param  {WParagraphFormat} oldFormat
     * @param  {WParagraphFormat} newFormat
     * @private
     */
    Editor.prototype.copyFromListLevelParagraphFormat = function (oldFormat, newFormat) {
        if (!isNullOrUndefined(newFormat.leftIndent)) {
            oldFormat.leftIndent = newFormat.leftIndent;
        }
        if (!isNullOrUndefined(newFormat.firstLineIndent)) {
            oldFormat.firstLineIndent = newFormat.firstLineIndent;
        }
    };
    /**
     * @private
     */
    Editor.prototype.applyContinueNumbering = function (selection) {
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('ContinueNumbering');
        }
        this.applyContinueNumberingInternal(selection);
    };
    /**
     * @private
     */
    Editor.prototype.applyContinueNumberingInternal = function (selection) {
        var paragraph = selection.start.paragraph;
        var numberingInfo = this.getContinueNumberingInfo(paragraph);
        var paraFormat = this.getParagraphFormat(paragraph, numberingInfo.listLevelNumber, numberingInfo.listPattern);
        this.changeListId(numberingInfo.currentList, paragraph, paraFormat, numberingInfo.listLevelNumber, numberingInfo.listPattern);
        this.reLayout(selection, false);
        this.viewer.updateFocus();
    };
    /**
     * @private
     */
    Editor.prototype.getContinueNumberingInfo = function (paragraph) {
        var currentList = undefined;
        var listLevelNumber = 0;
        var listPattern = 'None';
        if (!isNullOrUndefined(paragraph.paragraphFormat)
            && !isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
            currentList = this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId);
            listLevelNumber = paragraph.paragraphFormat.listFormat.listLevelNumber;
        }
        var viewer = this.viewer;
        if (listLevelNumber !== 0 && !isNullOrUndefined(currentList) &&
            !isNullOrUndefined(viewer.getAbstractListById(currentList.abstractListId))
            && !isNullOrUndefined(viewer.getAbstractListById(currentList.abstractListId).levels[listLevelNumber])) {
            var listLevel = this.viewer.layout.getListLevel(currentList, listLevelNumber);
            if (!isNullOrUndefined(listLevel)) {
                listPattern = listLevel.listLevelPattern;
            }
        }
        return {
            currentList: currentList,
            listLevelNumber: listLevelNumber,
            listPattern: listPattern
        };
    };
    /**
     * @private
     */
    Editor.prototype.revertContinueNumbering = function (selection, format) {
        var paragraph = selection.start.paragraph;
        var numberingInfo = this.getContinueNumberingInfo(paragraph);
        this.changeListId(numberingInfo.currentList, paragraph, format, numberingInfo.listLevelNumber, numberingInfo.listPattern);
        this.reLayout(selection, false);
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.editorHistory.updateHistory();
        }
    };
    Editor.prototype.changeListId = function (list, block, format, levelNum, listType) {
        if (isNullOrUndefined(block)) {
            return;
        }
        if (block instanceof ParagraphWidget) {
            if (list.listId === block.paragraphFormat.listFormat.listId
                && levelNum === block.paragraphFormat.listFormat.listLevelNumber) {
                if (this.editorHistory) {
                    var baseHistoryInfo = this.editorHistory.currentBaseHistoryInfo;
                    if (!isNullOrUndefined(baseHistoryInfo)) {
                        format = baseHistoryInfo.addModifiedPropertiesForContinueNumbering(block.paragraphFormat, format);
                    }
                }
                block.paragraphFormat.copyFormat(format);
                this.viewer.layout.reLayoutParagraph(block, 0, 0);
            }
        }
        return this.changeListId(list, block.nextRenderedWidget, format, levelNum, listType);
    };
    Editor.prototype.getParagraphFormat = function (paragraph, levelNumber, listType) {
        if (!isNullOrUndefined(paragraph.previousRenderedWidget)) {
            if (paragraph.previousRenderedWidget instanceof ParagraphWidget) {
                if (!isNullOrUndefined(paragraph.previousRenderedWidget.paragraphFormat.listFormat)
                    && paragraph.previousRenderedWidget.paragraphFormat.listFormat.listId !== -1) {
                    var listLevel = this.getListLevel(paragraph.previousRenderedWidget);
                    if (levelNumber === 0) {
                        return paragraph.previousRenderedWidget.paragraphFormat;
                    }
                    else if (listType === listLevel.listLevelPattern
                        || this.checkNumberArabic(listType, listLevel.listLevelPattern)) {
                        return paragraph.previousRenderedWidget.paragraphFormat;
                    }
                    else {
                        return this.getParagraphFormat(paragraph.previousRenderedWidget, levelNumber, listType);
                    }
                }
                else {
                    return this.getParagraphFormat(paragraph.previousRenderedWidget, levelNumber, listType);
                }
            }
        }
        return undefined;
    };
    Editor.prototype.checkNumberArabic = function (listType, levelPattern) {
        if ((listType === 'Number' && levelPattern === 'Arabic')
            || (levelPattern === 'Number' && listType === 'Arabic')) {
            return true;
        }
        return false;
    };
    /**
     * @private
     */
    Editor.prototype.applyRestartNumbering = function (selection) {
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('RestartNumbering');
        }
        this.restartListAt(selection);
    };
    /**
     * @private
     */
    Editor.prototype.restartListAt = function (selection) {
        var currentList = selection.paragraphFormat.getList();
        var list = currentList.clone();
        list.listId = this.viewer.lists[(this.viewer.lists.length - 1)].listId + 1;
        this.viewer.lists.push(list);
        var abstractList = currentList.abstractList.clone();
        abstractList.abstractListId = this.viewer.abstractLists[(this.viewer.abstractLists.length - 1)].abstractListId + 1;
        list.abstractListId = abstractList.abstractListId;
        list.abstractList = abstractList;
        this.viewer.abstractLists.push(abstractList);
        this.restartListAtInternal(selection, list.listId);
    };
    /**
     * @private
     */
    Editor.prototype.restartListAtInternal = function (selection, listId) {
        var numberingInfo = this.getContinueNumberingInfo(selection.start.paragraph);
        this.changeRestartNumbering(numberingInfo.currentList, selection.start.paragraph, listId);
        this.reLayout(selection, false);
        this.incrementListNumber = -1;
        this.refListNumber = undefined;
        this.viewer.updateFocus();
    };
    Editor.prototype.changeRestartNumbering = function (list, block, listId) {
        if (isNullOrUndefined(block)) {
            return;
        }
        if (block instanceof ParagraphWidget) {
            if (list.listId === block.paragraphFormat.listFormat.listId) {
                if (this.editorHistory) {
                    var baseHistoryInfo = this.editorHistory.currentBaseHistoryInfo;
                    if (!isNullOrUndefined(baseHistoryInfo)) {
                        listId = baseHistoryInfo.addModifiedPropertiesForRestartNumbering(block.paragraphFormat.listFormat, listId);
                    }
                }
                block.paragraphFormat.listFormat.listId = listId;
                if (this.refListNumber === undefined && this.incrementListNumber === -1) {
                    this.incrementListNumber = block.paragraphFormat.listFormat.listLevelNumber - 1;
                }
                if (this.refListNumber !== block.paragraphFormat.listFormat.listLevelNumber) {
                    this.incrementListNumber += 1;
                    this.refListNumber = block.paragraphFormat.listFormat.listLevelNumber;
                }
                block.paragraphFormat.listFormat.listLevelNumber = this.incrementListNumber;
                this.viewer.layout.reLayoutParagraph(block, 0, 0);
            }
        }
        return this.changeRestartNumbering(list, block.nextRenderedWidget, listId);
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyParaFormat = function (paragraph, start, end, property, value, update) {
        this.setOffsetValue(this.selection);
        paragraph = paragraph.combineWidget(this.viewer);
        //Apply Paragraph Format for spitted paragraph
        this.applyParaFormatProperty(paragraph, property, value, update);
        this.layoutItemBlock(paragraph, false);
        this.getOffsetValue(this.selection);
        if (paragraph.equals(end.paragraph)) {
            return;
        }
        this.getNextParagraphForFormatting(paragraph, start, end, property, value, update);
    };
    /*tslint:disable-next-line:max-line-length */
    Editor.prototype.applyCharacterStyle = function (paragraph, start, end, property, value, update) {
        var paragraphWidget = paragraph.getSplitWidgets();
        var selection = end.owner.selection;
        var lastLine = end.currentWidget;
        var isParaSelected = start.offset === 0 && (selection.isParagraphLastLine(lastLine) && end.currentWidget === lastLine
            && end.offset === selection.getLineLength(lastLine) + 1 || end.isAtParagraphEnd);
        if (!isParaSelected && (end.paragraph === paragraph || paragraphWidget.indexOf(end.paragraph) !== -1)) {
            if (((value.type === 'Paragraph') && ((value.link) instanceof WCharacterStyle)) || (value.type === 'Character')) {
                var obj = (value.type === 'Character') ? value : value.link;
                this.updateSelectionCharacterFormatting(property, obj, update);
                return true;
            }
        }
        return false;
    };
    // Cell
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyParaFormatInCell = function (cell, start, end, property, value, update) {
        var selection = this.viewer.selection;
        if (end.paragraph.isInsideTable) {
            var cellContainer = selection.getContainerCellOf(cell, end.paragraph.associatedCell);
            if (cellContainer.ownerTable.contains(end.paragraph.associatedCell)) {
                var startCell = selection.getSelectedCell(cell, cellContainer);
                var endCell = selection.getSelectedCell(end.paragraph.associatedCell, cellContainer);
                if (selection.containsCell(cellContainer, end.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (selection.isCellSelected(cellContainer, start, end)) {
                        value = this.getParaFormatValueInCell(cellContainer, property, value);
                        this.applyParaFormatCellInternal(cellContainer, property, value, update);
                    }
                    else {
                        if (startCell === cellContainer) {
                            this.applyParaFormat(start.paragraph, start, end, property, value, update);
                        }
                        else {
                            this.applyParagraphFormatRow(startCell.ownerRow, start, end, property, value, update);
                        }
                    }
                }
                else {
                    //Format other selected cells in current table.
                    this.applyParaFormatTableCell(cellContainer.ownerTable, cellContainer, endCell, property, value, update);
                }
            }
            else {
                this.applyParagraphFormatRow(cellContainer.ownerRow, start, end, property, value, update);
            }
        }
        else {
            var wCell = selection.getContainerCell(cell);
            this.applyParagraphFormatRow(wCell.ownerRow, start, end, property, value, update);
        }
    };
    Editor.prototype.applyParaFormatCellInternal = function (cell, property, value, update) {
        for (var i = 0; i < cell.childWidgets.length; i++) {
            var block = cell.childWidgets[i];
            if (block instanceof ParagraphWidget) {
                this.applyParaFormatProperty(block, property, value, update);
            }
            else {
                this.applyParagraphFormatTableInternal(block, property, value, update);
            }
        }
    };
    Editor.prototype.getParaFormatValueInCell = function (cell, property, value) {
        if (typeof value === 'boolean') {
            var firstPara = this.viewer.selection.getFirstParagraph(cell);
            value = !firstPara.paragraphFormat.getPropertyValue(property);
        }
        return value;
    };
    // Row
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyParagraphFormatRow = function (wRow, start, end, property, value, update) {
        value = this.getParaFormatValueInCell(wRow.childWidgets[0], property, value);
        for (var i = wRow.rowIndex; i < wRow.ownerTable.childWidgets.length; i++) {
            var row = wRow.ownerTable.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                this.applyParaFormatCellInternal(row.childWidgets[j], property, value, update);
            }
            if (end.paragraph.isInsideTable && this.viewer.selection.containsRow(row, end.paragraph.associatedCell)) {
                return;
            }
        }
        this.getNextParagraphForFormatting(wRow.ownerTable, start, end, property, value, update);
    };
    // Table
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyParaFormatTableCell = function (table, startCell, endCell, property, value, update) {
        var selection = this.viewer.selection;
        var startValue = selection.getCellLeft(startCell.ownerRow, startCell);
        var endValue = startValue + startCell.cellFormat.cellWidth;
        var endCellLeft = selection.getCellLeft(endCell.ownerRow, endCell);
        var endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        var cellInfo = this.updateSelectedCellsInTable(startValue, endValue, endCellLeft, endCellRight);
        startValue = cellInfo.start;
        endValue = cellInfo.end;
        var count = table.childWidgets.indexOf(endCell.ownerRow);
        var isStarted = false;
        for (var m = table.childWidgets.indexOf(startCell.ownerRow); m <= count; m++) {
            var row = table.childWidgets[m];
            for (var j = 0; j < row.childWidgets.length; j++) {
                var left = selection.getCellLeft(row, row.childWidgets[j]);
                if (Math.round(startValue) <= Math.round(left) && Math.round(left) < Math.round(endValue)) {
                    if (!isStarted) {
                        value = this.getParaFormatValueInCell(row.childWidgets[j], property, value);
                        isStarted = true;
                    }
                    this.applyParaFormatCellInternal(row.childWidgets[j], property, value, update);
                }
            }
        }
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyParaFormatTable = function (table, start, end, property, value, update) {
        table = table.combineWidget(this.viewer);
        var selection = this.viewer.selection;
        for (var m = 0; m < table.childWidgets.length; m++) {
            var tableRow = table.childWidgets[m];
            for (var k = 0; k < tableRow.childWidgets.length; k++) {
                this.applyParaFormatCellInternal(tableRow.childWidgets[k], property, value, update);
            }
            if (end.paragraph.isInsideTable && selection.containsRow(tableRow, end.paragraph.associatedCell)) {
                this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
                return;
            }
        }
        this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        this.getNextParagraphForFormatting(table, start, end, property, value, update);
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.getNextParagraphForFormatting = function (block, start, end, property, value, update) {
        var widgetCollection = block.getSplitWidgets();
        block = widgetCollection[widgetCollection.length - 1];
        block = this.viewer.selection.getNextRenderedBlock(block);
        if (!isNullOrUndefined(block)) { //Goto the next block.
            if (block instanceof ParagraphWidget) {
                this.applyParaFormat(block, start, end, property, value, update);
            }
            else {
                this.applyParaFormatTable(block, start, end, property, value, update);
            }
        }
    };
    Editor.prototype.applyParagraphFormatTableInternal = function (table, property, value, update) {
        for (var x = 0; x < table.childWidgets.length; x++) {
            var row = table.childWidgets[x];
            for (var y = 0; y < row.childWidgets.length; y++) {
                this.applyParaFormatCellInternal(row.childWidgets[y], property, value, update);
            }
        }
    };
    //Paragraph Format apply implementation Ends
    // Apply Selection Section Format Option Implementation Starts
    /**
     * Apply section format selection changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    Editor.prototype.onApplySectionFormat = function (property, value) {
        if (this.restrictFormatting) {
            return;
        }
        if (!isNullOrUndefined(property)) {
            var action = (property[0].toUpperCase() + property.slice(1));
            this.initHistory(action);
        }
        else {
            this.initHistory('SectionFormat');
        }
        this.updateSectionFormat(property, value);
    };
    /**
     * Update section format
     * @param  {string} property
     * @param  {Object} value
     * @returns TextPosition
     * @private
     */
    Editor.prototype.updateSectionFormat = function (property, value) {
        var selection = this.viewer.selection;
        selection.owner.isShiftingEnabled = true;
        var startPosition = selection.start;
        var endPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        var startPageIndex;
        var endPageIndex;
        this.viewer.clearContent();
        var startSectionIndex = startPosition.paragraph.bodyWidget.sectionIndex;
        var endSectionIndex = endPosition.paragraph.bodyWidget.sectionIndex;
        for (var i = 0; i < this.viewer.pages.length; i++) {
            if (this.viewer.pages[i].bodyWidgets[0].index === startSectionIndex) {
                startPageIndex = i;
                break;
            }
        }
        for (var i = startPageIndex; i < this.viewer.pages.length; i++) {
            var bodyWidget = this.viewer.pages[i].bodyWidgets[0];
            endPageIndex = i;
            if ((bodyWidget.index === startSectionIndex)) {
                continue;
            }
            else if ((bodyWidget.index >= startSectionIndex) && bodyWidget.index <= endSectionIndex) {
                continue;
            }
            else {
                endPageIndex = i - 1;
                break;
            }
        }
        // let startPageIndex: number = this.viewer.pages.indexOf((selection.start.paragraph.containerWidget as BodyWidget).page);
        // let endPageIndex: number = this.viewer.pages.indexOf((selection.end.paragraph.containerWidget as BodyWidget).page);
        var update = true;
        var index = 0;
        for (var i = startPageIndex; i <= endPageIndex; i++) {
            if (index !== this.viewer.pages[i].bodyWidgets[0].index && !update) {
                update = true;
            }
            this.applyPropertyValueForSection(this.viewer.pages[i].bodyWidgets[0].sectionFormat, property, value, update);
            index = this.viewer.pages[i].bodyWidgets[0].index;
            update = false;
        }
        this.layoutWholeDocument();
        this.fireContentChange();
    };
    //Apply Selection Table Format option implementation starts
    /**
     * Apply table format property changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    Editor.prototype.onApplyTableFormat = function (property, value) {
        if (this.restrictFormatting) {
            return;
        }
        var action = this.getTableFormatAction(property);
        this.viewer.owner.isShiftingEnabled = true;
        var selection = this.viewer.selection;
        var table = selection.start.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.viewer);
        if (selection.isEmpty) {
            this.initHistory(action);
            this.applyTablePropertyValue(selection, property, value, table);
        }
        else {
            this.updateSelectionTableFormat(this.selection, action, value);
        }
        table.calculateGrid();
        this.selection.owner.isLayoutEnabled = true;
        this.viewer.layout.reLayoutTable(table);
        this.reLayout(selection, false);
    };
    Editor.prototype.getTableFormatAction = function (property) {
        switch (property) {
            case 'tableAlignment':
                return 'TableAlignment';
            case 'leftIndent':
                return 'TableLeftIndent';
            case 'leftMargin':
                return 'DefaultCellLeftMargin';
            case 'rightMargin':
                return 'DefaultCellRightMargin';
            case 'bottomMargin':
                return 'DefaultCellBottomMargin';
            case 'topMargin':
                return 'DefaultCellTopMargin';
            case 'preferredWidth':
                return 'TablePreferredWidth';
            case 'preferredWidthType':
                return 'TablePreferredWidthType';
            case 'shading':
                return 'Shading';
            case 'bidi':
                return 'TableBidi';
            default:
                return 'DefaultCellSpacing';
        }
    };
    // Apply Selection Row Format Option Implementation Starts
    /**
     * Apply table row format property changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    Editor.prototype.onApplyTableRowFormat = function (property, value) {
        if (this.restrictFormatting) {
            return;
        }
        var action = this.getRowAction(property);
        this.viewer.owner.isShiftingEnabled = true;
        var selection = this.viewer.selection;
        if (selection.isEmpty) {
            this.initHistory(action);
            var table = selection.start.paragraph.associatedCell.ownerRow.ownerTable;
            this.applyRowPropertyValue(selection, property, value, selection.start.paragraph.associatedCell.ownerRow);
        }
        else {
            this.updateSelectionTableFormat(this.selection, action, value);
        }
        this.reLayout(selection, false);
    };
    Editor.prototype.getRowAction = function (property) {
        switch (property) {
            case 'height':
                return 'RowHeight';
            case 'heightType':
                return 'RowHeightType';
            case 'isHeader':
                return 'RowHeader';
            default:
                return 'AllowBreakAcrossPages';
        }
    };
    /**
     * Apply table cell property changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    Editor.prototype.onApplyTableCellFormat = function (property, value) {
        if (this.restrictFormatting) {
            return;
        }
        var action = this.getTableCellAction(property);
        this.viewer.owner.isShiftingEnabled = true;
        var selection = this.viewer.selection;
        var table = selection.start.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.viewer);
        if (selection.isEmpty) {
            this.initHistory(action);
            this.applyCellPropertyValue(selection, property, value, selection.start.paragraph.associatedCell.cellFormat);
            table.calculateGrid();
            this.selection.owner.isLayoutEnabled = true;
            this.viewer.layout.reLayoutTable(table);
        }
        else {
            this.updateSelectionTableFormat(this.selection, action, value);
        }
        this.reLayout(selection, false);
    };
    Editor.prototype.getTableCellAction = function (property) {
        switch (property) {
            case 'verticalAlignment':
                return 'CellContentVerticalAlignment';
            case 'leftMargin':
                return 'CellLeftMargin';
            case 'rightMargin':
                return 'CellRightMargin';
            case 'bottomMargin':
                return 'CellBottomMargin';
            case 'topMargin':
                return 'CellTopMargin';
            case 'preferredWidth':
                return 'CellPreferredWidth';
            case 'shading':
                return 'Shading';
            default:
                return 'CellPreferredWidthType';
        }
    };
    Editor.prototype.applyPropertyValueForSection = function (sectionFormat, property, value, update) {
        var selection = this.viewer.selection;
        if (update && this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedPropertiesForSection(sectionFormat, property, value);
        }
        if (isNullOrUndefined(value)) {
            return;
        }
        if (value instanceof WSectionFormat) {
            if (isNullOrUndefined(property)) {
                sectionFormat.copyFormat(value, this.editorHistory);
            }
            return;
        }
        if (property === 'pageHeight') {
            sectionFormat.pageHeight = value;
        }
        else if (property === 'pageWidth') {
            sectionFormat.pageWidth = value;
        }
        else if (property === 'leftMargin') {
            sectionFormat.leftMargin = value;
        }
        else if (property === 'rightMargin') {
            sectionFormat.rightMargin = value;
        }
        else if (property === 'topMargin') {
            sectionFormat.topMargin = value;
        }
        else if (property === 'bottomMargin') {
            sectionFormat.bottomMargin = value;
        }
        else if (property === 'differentFirstPage') {
            sectionFormat.differentFirstPage = value;
        }
        else if (property === 'differentOddAndEvenPages') {
            sectionFormat.differentOddAndEvenPages = value;
        }
        else if (property === 'headerDistance') {
            sectionFormat.headerDistance = value;
        }
        else if (property === 'footerDistance') {
            sectionFormat.footerDistance = value;
        }
    };
    /**
     * @private
     */
    Editor.prototype.layoutWholeDocument = function () {
        var startPosition = this.viewer.selection.start;
        var endPosition = this.viewer.selection.end;
        if (startPosition.isExistAfter(endPosition)) {
            startPosition = this.viewer.selection.end;
            endPosition = this.viewer.selection.start;
        }
        var startInfo = this.selection.getParagraphInfo(startPosition);
        var endInfo = this.selection.getParagraphInfo(startPosition);
        var startIndex = this.selection.getHierarchicalIndex(startInfo.paragraph, startInfo.offset.toString());
        var endIndex = this.selection.getHierarchicalIndex(endInfo.paragraph, endInfo.offset.toString());
        this.viewer.renderedLists.clear();
        this.viewer.renderedLevelOverrides = [];
        // this.viewer.owner.isLayoutEnabled = true;
        var sections = this.combineSection();
        this.viewer.clearContent();
        this.viewer.layout.layoutItems(sections);
        this.viewer.owner.isShiftingEnabled = false;
        this.setPositionForCurrentIndex(startPosition, startIndex);
        this.setPositionForCurrentIndex(endPosition, endIndex);
        this.viewer.selection.selectPosition(startPosition, endPosition);
        this.reLayout(this.viewer.selection);
    };
    Editor.prototype.combineSection = function () {
        var sections = [];
        var nextSection = this.viewer.pages[0].bodyWidgets[0];
        do {
            nextSection = this.combineSectionChild(nextSection, sections);
        } while (nextSection);
        return sections;
    };
    Editor.prototype.combineSectionChild = function (bodyWidget, sections) {
        var previousBodyWidget = bodyWidget;
        var temp = new BodyWidget();
        temp.sectionFormat = bodyWidget.sectionFormat;
        temp.index = previousBodyWidget.index;
        do {
            previousBodyWidget = bodyWidget;
            if (bodyWidget.lastChild) {
                bodyWidget.lastChild.combineWidget(this.viewer);
            }
            bodyWidget = bodyWidget.nextRenderedWidget;
            for (var j = 0; j < previousBodyWidget.childWidgets.length; j++) {
                var block = previousBodyWidget.childWidgets[j];
                if (block instanceof TableWidget) {
                    this.viewer.layout.clearTableWidget(block, true, true, true);
                }
                else {
                    block.x = 0;
                    block.y = 0;
                    block.width = 0;
                    block.height = 0;
                }
                temp.childWidgets.push(block);
                previousBodyWidget.childWidgets.splice(j, 1);
                j--;
                block.containerWidget = temp;
            }
            previousBodyWidget.page.destroy();
            // this.viewer.pages.splice(previousBodyWidget.page.index, 1);
        } while (bodyWidget && previousBodyWidget.equals(bodyWidget));
        sections.push(temp);
        return bodyWidget;
    };
    Editor.prototype.updateSelectionTableFormat = function (selection, action, value) {
        switch (action) {
            case 'TableAlignment':
                this.editorHistory.initializeHistory('TableAlignment');
                this.updateTableFormat(selection, 'tableAlignment', value);
                break;
            case 'TableLeftIndent':
                this.editorHistory.initializeHistory('TableLeftIndent');
                this.updateTableFormat(selection, 'leftIndent', value);
                break;
            case 'DefaultCellSpacing':
                this.editorHistory.initializeHistory('DefaultCellSpacing');
                this.updateTableFormat(selection, 'cellSpacing', value);
                break;
            case 'DefaultCellLeftMargin':
                this.editorHistory.initializeHistory('DefaultCellLeftMargin');
                this.updateTableFormat(selection, 'leftMargin', value);
                break;
            case 'DefaultCellRightMargin':
                this.editorHistory.initializeHistory('DefaultCellRightMargin');
                this.updateTableFormat(selection, 'rightMargin', value);
                break;
            case 'DefaultCellTopMargin':
                this.editorHistory.initializeHistory('DefaultCellTopMargin');
                this.updateTableFormat(selection, 'topMargin', value);
                break;
            case 'TablePreferredWidth':
                this.editorHistory.initializeHistory('TablePreferredWidth');
                this.updateTableFormat(selection, 'preferredWidth', value);
                break;
            case 'TablePreferredWidthType':
                this.editorHistory.initializeHistory('TablePreferredWidthType');
                this.updateTableFormat(selection, 'preferredWidthType', value);
                break;
            case 'DefaultCellBottomMargin':
                this.editorHistory.initializeHistory('DefaultCellBottomMargin');
                this.updateTableFormat(selection, 'bottomMargin', value);
                break;
            case 'CellContentVerticalAlignment':
                this.editorHistory.initializeHistory('CellContentVerticalAlignment');
                this.updateCellFormat(selection, 'verticalAlignment', value);
                break;
            case 'CellLeftMargin':
                this.editorHistory.initializeHistory('CellLeftMargin');
                this.updateCellFormat(selection, 'leftMargin', value);
                break;
            case 'CellRightMargin':
                this.editorHistory.initializeHistory('CellRightMargin');
                this.updateCellFormat(selection, 'rightMargin', value);
                break;
            case 'CellTopMargin':
                this.editorHistory.initializeHistory('CellTopMargin');
                this.updateCellFormat(selection, 'topMargin', value);
                break;
            case 'CellBottomMargin':
                this.editorHistory.initializeHistory('CellBottomMargin');
                this.updateCellFormat(selection, 'bottomMargin', value);
                break;
            case 'CellPreferredWidth':
                this.editorHistory.initializeHistory('CellPreferredWidth');
                this.updateCellFormat(selection, 'preferredWidth', value);
                break;
            case 'CellPreferredWidthType':
                this.editorHistory.initializeHistory('CellPreferredWidthType');
                this.updateCellFormat(selection, 'preferredWidthType', value);
                break;
            case 'Shading':
                this.editorHistory.initializeHistory('Shading');
                this.updateCellFormat(selection, 'shading', value);
                break;
            case 'RowHeight':
                this.editorHistory.initializeHistory('RowHeight');
                this.updateRowFormat(selection, 'height', value);
                break;
            case 'RowHeightType':
                this.editorHistory.initializeHistory('RowHeightType');
                this.updateRowFormat(selection, 'heightType', value);
                break;
            case 'RowHeader':
                this.editorHistory.initializeHistory('RowHeader');
                this.updateRowFormat(selection, 'isHeader', value);
                break;
            case 'AllowBreakAcrossPages':
                this.editorHistory.initializeHistory('AllowBreakAcrossPages');
                this.updateRowFormat(selection, 'allowBreakAcrossPages', value);
                break;
            case 'TableBidi':
                this.editorHistory.initializeHistory(action);
                this.updateTableFormat(selection, 'bidi', value);
                break;
        }
    };
    // Update Table Properties
    /**
     * Update Table Format on undo
     * @param  {Selection} selection
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {object} value
     * @private
     */
    Editor.prototype.updateTableFormat = function (selection, property, value) {
        var tableStartPosition = selection.start;
        var tableEndPosition = selection.end;
        if (!selection.isForward) {
            tableStartPosition = selection.end;
            tableEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, tableStartPosition);
        // tslint:disable-next-line:max-line-length
        this.applyTablePropertyValue(selection, property, value, tableStartPosition.paragraph.associatedCell.ownerTable);
        if (this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
            this.viewer.layout.reLayoutTable(tableStartPosition.paragraph.associatedCell.ownerTable);
        }
    };
    /**
     * update cell format on undo
     * @param  {Selection} selection
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    Editor.prototype.updateCellFormat = function (selection, property, value) {
        selection.owner.isShiftingEnabled = true;
        var newStartPosition = selection.start;
        var newEndPosition = selection.end;
        if (!selection.isForward) {
            newStartPosition = selection.end;
            newEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, newStartPosition);
        this.updateFormatForCell(selection, property, value);
    };
    /**
     * update row format on undo
     * @param  {Selection} selection
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    Editor.prototype.updateRowFormat = function (selection, property, value) {
        var rowStartPosition = selection.start;
        var rowEndPosition = selection.end;
        if (!selection.isForward) {
            rowStartPosition = selection.end;
            rowEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, rowStartPosition);
        // tslint:disable-next-line:max-line-length
        this.applyRowFormat(rowStartPosition.paragraph.associatedCell.ownerRow, rowStartPosition, rowEndPosition, property, value);
    };
    Editor.prototype.initHistoryPosition = function (selection, position) {
        if (this.viewer.owner.editorHistoryModule && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            if (!isNullOrUndefined(position)) {
                if (isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition)) {
                    this.editorHistory.currentBaseHistoryInfo.insertPosition = position.getHierarchicalIndexInternal();
                }
            }
            else if (isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition)) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = selection.start.getHierarchicalIndexInternal();
            }
        }
    };
    Editor.prototype.startSelectionReLayouting = function (paragraph, selection, start, end) {
        selection.owner.isLayoutEnabled = true;
        if (start.paragraph.isInsideTable) {
            var table = start.paragraph.associatedCell.ownerTable;
            while (table.isInsideTable) {
                table = table.associatedCell.ownerTable;
            }
            this.reLayoutSelectionOfTable(table, selection, start, end);
        }
        else {
            this.reLayoutSelection(paragraph, selection, start, end);
        }
    };
    Editor.prototype.reLayoutSelectionOfTable = function (table, selection, start, end) {
        var isEnded = false;
        this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        // If the selection ends in the current table, need to stop relayouting.
        if (!isNullOrUndefined(end.paragraph.associatedCell) && table.contains(end.paragraph.associatedCell)) {
            return true;
        }
        var block = selection.getNextRenderedBlock(table);
        // Relayout the next block.
        if (!isNullOrUndefined(block)) {
            isEnded = this.reLayoutSelectionOfBlock(block, selection, start, end);
        }
        return isEnded;
    };
    Editor.prototype.reLayoutSelection = function (paragraph, selection, start, end) {
        if (start.paragraph === paragraph) {
            var startOffset = start.offset;
            var length_2 = selection.getParagraphLength(paragraph);
            var indexInInline = 0;
            var index = 0;
            var inlineObj = paragraph.getInline(start.offset, indexInInline);
            var inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!isNullOrUndefined(inline)) {
                if (indexInInline === inline.length && !isNullOrUndefined(inline.nextNode)) {
                    inline = inline.nextNode;
                }
                index = inline.line.children.indexOf(inline);
            }
            var lineIndex = 0;
            if (start.currentWidget.paragraph === paragraph) {
                lineIndex = paragraph.childWidgets.indexOf(start.currentWidget);
                index = start.currentWidget.children.indexOf(inline);
            }
            // If selection start inline is at new inline, need to relayout from the previous inline.
            if (inline instanceof TextElementBox && !inline.line && index > 0) {
                this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, index - 1);
            }
            else {
                this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, index);
            }
        }
        else {
            this.viewer.layout.reLayoutParagraph(paragraph, 0, 0);
        }
        // If the selection ends at the current paragraph, need to stop relayouting.
        if (end.paragraph === paragraph) {
            return true;
        }
        // _Relayout the next block.
        var block = selection.getNextRenderedBlock(paragraph);
        if (!isNullOrUndefined(block)) {
            return this.reLayoutSelectionOfBlock(block, selection, start, end);
        }
        return false;
    };
    //Relayouting Start    
    Editor.prototype.reLayoutSelectionOfBlock = function (block, selection, start, end) {
        if (block instanceof ParagraphWidget) {
            return this.reLayoutSelection(block, selection, start, end);
        }
        else {
            return undefined;
            // return this.reLayoutSelectionOfTable(block as TableWidget, selection, start, end);
        }
    };
    /**
     * @private
     */
    Editor.prototype.layoutItemBlock = function (block, shiftNextWidget) {
        var section = undefined;
        if (block.containerWidget instanceof BlockContainer) {
            section = block.containerWidget;
            var index = section.childWidgets.indexOf(block);
            if (!isNullOrUndefined(this.viewer.owner)
                && this.viewer.owner.isLayoutEnabled) {
                // tslint:disable-next-line:max-line-length
                this.viewer.layout.layoutBodyWidgetCollection(block.index, section, block, false);
            }
        }
        else if (block.containerWidget instanceof TableCellWidget) {
            var cell = block.containerWidget;
            cell = this.viewer.selection.getContainerCell(cell);
            if (!isNullOrUndefined(this.viewer.owner)
                && this.viewer.owner.isLayoutEnabled) {
                this.viewer.layout.reLayoutTable(block);
            }
        }
    };
    /**
     * @private
     */
    Editor.prototype.removeSelectedContents = function (selection) {
        return this.removeSelectedContentInternal(selection, selection.start, selection.end);
    };
    Editor.prototype.removeSelectedContentInternal = function (selection, startPosition, endPosition) {
        var startPos = startPosition;
        var endPos = endPosition;
        if (!startPosition.isExistBefore(endPosition)) {
            startPos = endPosition;
            endPos = startPosition;
        }
        // tslint:disable-next-line:max-line-length
        if (startPos.paragraph === endPos.paragraph && startPos.paragraph.childWidgets.indexOf(startPos.currentWidget) === startPos.paragraph.childWidgets.length - 1 &&
            startPos.offset === selection.getParagraphLength(startPos.paragraph) && startPos.offset + 1 === endPos.offset) {
            selection.owner.isShiftingEnabled = true;
            selection.selectContent(startPos, true);
            return true;
        }
        var paragraphInfo = this.selection.getParagraphInfo(startPos);
        selection.editPosition = this.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
        var isRemoved = this.removeSelectedContent(endPos.paragraph, selection, startPos, endPos);
        var textPosition = new TextPosition(selection.owner);
        this.setPositionForCurrentIndex(textPosition, selection.editPosition);
        selection.selectContent(textPosition, true);
        return isRemoved;
    };
    Editor.prototype.removeSelectedContent = function (paragraph, selection, start, end) {
        //If end is not table end and start is outside the table, then skip removing the contents and move caret to start position.
        if (end.paragraph.isInsideTable
            && end.paragraph !== selection.getLastParagraphInLastCell(end.paragraph.associatedCell.ownerTable)
            && (!start.paragraph.isInsideTable || start.paragraph.associatedCell.ownerTable !== end.paragraph.associatedCell.ownerTable)) {
            return false;
        }
        selection.owner.isShiftingEnabled = true;
        this.deleteSelectedContent(paragraph, selection, start, end, 2);
        return true;
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.deleteSelectedContent = function (paragraph, selection, start, end, editAction) {
        var indexInInline = 0;
        var inlineObj = start.currentWidget.getInline(start.offset, indexInInline);
        var inline = inlineObj.element;
        indexInInline = inlineObj.index;
        // if (!isNullOrUndefined(inline)) {
        //     inline = selection.getNextRenderedInline(inline, indexInInline);
        // }
        // if (inline instanceof WFieldBegin && !isNullOrUndefined((inline as WFieldBegin).fieldEnd)) {
        // tslint:disable-next-line:max-line-length
        //     let fieldEndOffset: number = ((inline as WFieldBegin).fieldEnd.owner as WParagraph).getOffset((inline as WFieldBegin).fieldEnd, 1);
        //     let fieldEndIndex: string = WordDocument.getHierarchicalIndexOf((inline as WFieldBegin).fieldEnd.owner as WParagraph, fieldEndOffset.toString());
        //     let selectionEndIndex: string = end.getHierarchicalIndexInternal();
        //     if (!TextPosition.isForwardSelection(fieldEndIndex, selectionEndIndex)) {
        //         //If selection end is after field begin, moves selection start to field separator.
        //         start.moveToInline((inline as WFieldBegin).fieldSeparator, 1);
        //         selection.editPosition = start.getHierarchicalIndexInternal();
        //         if (!isNullOrUndefined(selection.currentBaseHistoryInfo)) {
        //             selection.currentBaseHistoryInfo.insertPosition = selection.editPosition;
        //         }
        //     }
        // }
        indexInInline = 0;
        inlineObj = end.currentWidget.getInline(end.offset, indexInInline);
        inline = inlineObj.element;
        indexInInline = inlineObj.index;
        // if (!isNullOrUndefined(inline)) {
        //     inline = selection.getNextRenderedInline(inline, indexInInline);
        // }
        // if (inline instanceof WFieldEnd && !isNullOrUndefined((inline as WFieldEnd).fieldBegin)) {
        // tslint:disable-next-line:max-line-length
        //     let fieldBeginOffset: number = ((inline as WFieldEnd).fieldBegin.owner as WParagraph).getOffset((inline as WFieldEnd).fieldBegin, 0);
        //     let fieldBeginIndex: string = WordDocument.getHierarchicalIndexOf((inline as WFieldEnd).fieldBegin.owner as WParagraph, fieldBeginOffset.toString());
        //     let selectionStartIndex: string = start.getHierarchicalIndexInternal();
        //     if (!TextPosition.isForwardSelection(selectionStartIndex, fieldBeginIndex)) {
        //         //If field begin is before selection start, move selection end to inline item before field end.
        //         let prevInline: WInline = selection.getPreviousTextInline(inline);
        //         if (isNullOrUndefined(prevInline)) {
        //             end.moveBackward();
        //         } else {
        //             end.moveToInline(prevInline, prevInline.length);
        //         }
        //     }
        // }
        if (end.paragraph !== paragraph) {
            this.deleteSelectedContent(end.paragraph, selection, start, end, editAction);
            return;
        }
        //  Selection start in cell.
        if (end.paragraph.isInsideTable && (!start.paragraph.isInsideTable
            || start.paragraph.associatedCell !== end.paragraph.associatedCell
            || selection.isCellSelected(end.paragraph.associatedCell, start, end))) {
            end.paragraph.associatedCell.ownerTable.combineWidget(this.viewer);
            this.deleteTableCell(end.paragraph.associatedCell, selection, start, end, editAction);
        }
        else {
            this.deletePara(paragraph, start, end, editAction);
            if (this.delBlockContinue && this.delBlock) {
                if (this.delSection) {
                    var bodyWidget = paragraph.bodyWidget instanceof BodyWidget ? paragraph.bodyWidget : undefined;
                    this.deleteSection(selection, this.delSection, bodyWidget, editAction);
                    this.delSection = undefined;
                }
                this.deleteBlock(this.delBlock, selection, start, end, editAction);
                this.delBlockContinue = false;
                this.delBlock = undefined;
            }
        }
    };
    /**
     * Merge the selected cells.
     */
    Editor.prototype.mergeCells = function () {
        if (this.owner.isReadOnlyMode || !this.owner.isDocumentLoaded) {
            return;
        }
        if (!isNullOrUndefined(this.viewer) && !this.selection.isEmpty) {
            this.mergeSelectedCellsInTable();
        }
    };
    /**
     * Deletes the entire table at selection.
     */
    Editor.prototype.deleteTable = function () {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        var startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        if (startPos.paragraph.isInsideTable) {
            var table = this.getOwnerTable(this.selection.isForward).combineWidget(this.viewer);
            this.selection.owner.isShiftingEnabled = true;
            if (this.checkIsNotRedoing()) {
                this.initHistory('DeleteTable');
                //Sets the insert position in history info as current table.    
                this.updateHistoryPosition(startPos, true);
            }
            var paragraph = this.getParagraphForSelection(table);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                this.editorHistory.currentBaseHistoryInfo.removedNodes.push(table.clone());
            }
            this.removeBlock(table);
            this.selection.selectParagraphInternal(paragraph, true);
            if (this.checkIsNotRedoing() || isNullOrUndefined(this.editorHistory)) {
                this.reLayout(this.selection);
            }
        }
    };
    /**
     * Deletes the selected column(s).
     */
    Editor.prototype.deleteColumn = function () {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        var startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        var endPos = this.selection.isForward ? this.selection.end : this.selection.start;
        if (startPos.paragraph.isInsideTable) {
            this.selection.owner.isShiftingEnabled = true;
            if (this.checkIsNotRedoing()) {
                this.initHistory('DeleteColumn');
            }
            var startCell = this.getOwnerCell(this.selection.isForward);
            var endCell = this.getOwnerCell(!this.selection.isForward);
            var table = startCell.ownerTable.combineWidget(this.viewer);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                this.cloneTableToHistoryInfo(table);
            }
            var paragraph = undefined;
            if (endCell.nextWidget) {
                var nextCell = endCell.nextWidget;
                paragraph = this.selection.getFirstParagraph(nextCell);
            }
            else if (startCell.previousWidget) {
                var previousCell = startCell.previousWidget;
                paragraph = this.selection.getFirstParagraph(previousCell);
            }
            if (isNullOrUndefined(paragraph)) {
                paragraph = this.getParagraphForSelection(table);
            }
            //retrieve the cell collection based on start and end cell to remove. 
            var deleteCells = table.getColumnCellsForSelection(startCell, endCell);
            for (var i = 0; i < table.childWidgets.length; i++) {
                var row = table.childWidgets[i];
                if (row.childWidgets.length === 1) {
                    if (deleteCells.indexOf(row.childWidgets[0]) >= 0) {
                        table.childWidgets.splice(table.childWidgets.indexOf(row), 1);
                        row.destroy();
                        i--;
                    }
                }
                else {
                    for (var j = 0; j < row.childWidgets.length; j++) {
                        var tableCell = row.childWidgets[j];
                        if (deleteCells.indexOf(tableCell) >= 0) {
                            row.childWidgets.splice(j, 1);
                            tableCell.destroy();
                            j--;
                        }
                    }
                    if (row.childWidgets.length === 0) {
                        table.childWidgets.splice(table.childWidgets.indexOf(row), 1);
                        row.destroy();
                        i--;
                    }
                }
            }
            if (table.childWidgets.length === 0) {
                // Before disposing table reset the paragrph.
                paragraph = this.getParagraphForSelection(table);
                this.removeBlock(table);
                if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                    this.editorHistory.currentBaseHistoryInfo.action = 'DeleteTable';
                }
                table.destroy();
            }
            else {
                table.isGridUpdated = false;
                table.buildTableColumns();
                table.isGridUpdated = true;
                this.viewer.layout.reLayoutTable(table);
            }
            this.selection.selectParagraphInternal(paragraph, true);
            if (isNullOrUndefined(this.editorHistory) || this.checkIsNotRedoing()) {
                this.reLayout(this.selection, true);
            }
        }
    };
    /**
     * Deletes the selected row(s).
     */
    Editor.prototype.deleteRow = function () {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        var startPos = !this.selection.isForward ? this.selection.end : this.selection.start;
        var endPos = !this.selection.isForward ? this.selection.start : this.selection.end;
        if (startPos.paragraph.isInsideTable) {
            var startCell = this.getOwnerCell(this.selection.isForward);
            var endCell = this.getOwnerCell(!this.selection.isForward);
            if (this.checkIsNotRedoing()) {
                this.initHistory('DeleteRow');
            }
            this.selection.owner.isShiftingEnabled = true;
            var table = startCell.ownerTable.combineWidget(this.viewer);
            var row = this.getOwnerRow(true);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                this.cloneTableToHistoryInfo(table);
            }
            var paragraph = undefined;
            if (row.nextWidget) {
                var nextCell = row.nextWidget.childWidgets[0];
                paragraph = this.selection.getFirstParagraph(nextCell);
            }
            if (isNullOrUndefined(paragraph)) {
                paragraph = this.getParagraphForSelection(table);
            }
            if (!this.selection.isEmpty) {
                //tslint:disable-next-line:max-line-length
                var containerCell = this.selection.getContainerCellOf(startCell, endCell);
                if (containerCell.ownerTable.contains(endCell)) {
                    startCell = this.selection.getSelectedCell(startCell, containerCell);
                    endCell = this.selection.getSelectedCell(endCell, containerCell);
                    if (this.selection.containsCell(containerCell, endCell)) {
                        row = startCell.ownerRow;
                        this.removeRow(row);
                    }
                    else {
                        row = startCell.ownerRow;
                        var endRow = endCell.ownerRow;
                        //Update the selection paragraph.
                        paragraph = undefined;
                        if (endRow.nextWidget) {
                            var nextCell = endRow.nextWidget.childWidgets[0];
                            paragraph = this.selection.getFirstParagraph(nextCell);
                        }
                        if (isNullOrUndefined(paragraph)) {
                            paragraph = this.getParagraphForSelection(table);
                        }
                        for (var i = 0; i < table.childWidgets.length; i++) {
                            var tableRow = table.childWidgets[i];
                            if (tableRow.rowIndex >= row.rowIndex && tableRow.rowIndex <= endRow.rowIndex) {
                                table.childWidgets.splice(i, 1);
                                tableRow.destroy();
                                i--;
                            }
                        }
                        if (table.childWidgets.length === 0) {
                            this.removeBlock(table);
                            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                                this.editorHistory.currentBaseHistoryInfo.action = 'DeleteTable';
                            }
                            table.destroy();
                        }
                        else {
                            this.updateTable(table);
                        }
                    }
                }
            }
            else {
                this.removeRow(row);
            }
            this.selection.selectParagraphInternal(paragraph, true);
            if (isNullOrUndefined(this.editorHistory) || this.checkIsNotRedoing()) {
                this.reLayout(this.selection, true);
            }
        }
    };
    Editor.prototype.removeRow = function (row) {
        var table = row.ownerTable;
        if (table.childWidgets.length === 1) {
            this.removeBlock(table);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                this.editorHistory.currentBaseHistoryInfo.action = 'Delete';
            }
            table.destroy();
        }
        else {
            table.childWidgets.splice(table.childWidgets.indexOf(row), 1);
            row.destroy();
            this.updateTable(table);
        }
    };
    Editor.prototype.updateTable = function (table) {
        table.updateRowIndex(0);
        table.isGridUpdated = false;
        table.buildTableColumns();
        table.isGridUpdated = true;
        this.viewer.layout.reLayoutTable(table);
    };
    Editor.prototype.getParagraphForSelection = function (table) {
        var paragraph = undefined;
        var nextWidget = table.nextWidget ? table.nextWidget : table.nextRenderedWidget;
        var previousWidget = table.previousWidget ? table.previousWidget : table.previousRenderedWidget;
        if (nextWidget) {
            paragraph = nextWidget instanceof ParagraphWidget ? nextWidget
                : this.selection.getFirstParagraphInFirstCell(nextWidget);
        }
        else if (previousWidget) {
            paragraph = previousWidget instanceof ParagraphWidget ? previousWidget
                : this.selection.getLastParagraphInLastCell(previousWidget);
        }
        return paragraph;
    };
    Editor.prototype.deletePara = function (paragraph, start, end, editAction) {
        paragraph = paragraph.combineWidget(this.viewer);
        var selection = this.viewer.selection;
        var paragraphStart = selection.getStartOffset(paragraph);
        var endParagraphStartOffset = selection.getStartOffset(end.paragraph);
        var startOffset = paragraphStart;
        var endOffset = 0;
        var isCombineNextParagraph = false;
        var lastLinelength = this.selection.getLineLength(paragraph.lastChild);
        var currentParagraph = paragraph;
        var section = paragraph.bodyWidget instanceof BodyWidget ? paragraph.bodyWidget : undefined;
        var startLine = undefined;
        var endLineWidget = undefined;
        if (paragraph === start.paragraph) {
            startOffset = start.offset;
            startLine = start.currentWidget;
            if (end.paragraph.isInsideTable) {
                isCombineNextParagraph = this.isEndInAdjacentTable(paragraph, end.paragraph);
            }
        }
        else {
            startLine = paragraph.firstChild;
        }
        if (paragraph !== start.paragraph && selection.isSkipLayouting) {
            selection.isSkipLayouting = false;
        }
        if (paragraph === end.paragraph) {
            endLineWidget = end.currentWidget;
            endOffset = end.offset;
        }
        else {
            endLineWidget = paragraph.lastChild;
            endOffset = this.viewer.selection.getLineLength(paragraph.lastChild);
        }
        var block = paragraph.previousRenderedWidget;
        if (startOffset > paragraphStart && start.currentWidget === paragraph.lastChild &&
            startOffset === lastLinelength && (paragraph === end.paragraph && end.offset === startOffset + 1 ||
            paragraph.nextRenderedWidget === end.paragraph && end.offset === endParagraphStartOffset) ||
            (this.editorHistory && this.editorHistory.isUndoing && this.editorHistory.currentHistoryInfo &&
                this.editorHistory.currentHistoryInfo.action === 'PageBreak' && block && block.isPageBreak()
                && (startOffset === 0 && !start.currentWidget.isFirstLine || startOffset > 0))) {
            isCombineNextParagraph = true;
        }
        if (end.paragraph === paragraph && end.currentWidget !== paragraph.lastChild ||
            (end.currentWidget === paragraph.lastChild && end.offset <= selection.getLineLength(paragraph.lastChild))) {
            var isStartParagraph = start.paragraph === paragraph;
            if (end.currentWidget.isFirstLine() && end.offset > paragraphStart || !end.currentWidget.isFirstLine()) {
                //If selection end with this paragraph and selection doesnot include paragraph mark.               
                this.removeInlines(paragraph, startLine, startOffset, endLineWidget, endOffset, editAction);
                //Removes the splitted paragraph.
            }
            if (!isNullOrUndefined(block) && !isStartParagraph) {
                this.delBlockContinue = true;
                this.delBlock = block;
                var nextSection = block.bodyWidget instanceof BodyWidget ? block.bodyWidget : undefined;
                if (nextSection && !section.equals(nextSection) && section.index !== nextSection.index) {
                    this.delSection = nextSection;
                }
                else {
                    this.delSection = undefined;
                }
            }
            else {
                this.delBlockContinue = false;
                this.delBlock = undefined;
            }
        }
        else if (start.paragraph === paragraph && (start.currentWidget !== paragraph.firstChild ||
            (start.currentWidget === paragraph.firstChild && startOffset > paragraphStart))) {
            // If selection start is after paragraph start
            //And selection does not end with this paragraph Or selection include paragraph mark.
            this.delBlockContinue = false;
            this.delBlock = undefined;
            if (editAction === 4) {
                return;
            }
            else {
                currentParagraph = this.splitParagraph(paragraph, paragraph.firstChild, 0, startLine, startOffset, true);
                this.insertParagraphPaste(paragraph, currentParagraph, start, end, isCombineNextParagraph, editAction);
                this.addRemovedNodes(paragraph);
                return;
            }
        }
        else {
            var newParagraph = undefined;
            var previousBlock = paragraph.previousWidget;
            var prevParagraph = (previousBlock instanceof ParagraphWidget) ? previousBlock : undefined;
            var nextWidget = paragraph.nextRenderedWidget;
            if (editAction < 4) {
                //Checks whether this is last paragraph of owner text body and previousBlock is not paragraph.
                newParagraph = this.checkAndInsertBlock(paragraph, start, end, editAction, prevParagraph);
                this.removeBlock(paragraph);
                if (this.viewer.blockToShift === paragraph) {
                    this.viewer.blockToShift = undefined;
                }
                this.addRemovedNodes(paragraph);
                if (!isNullOrUndefined(newParagraph)) {
                    selection.editPosition = this.selection.getHierarchicalIndex(newParagraph, '0');
                    var offset = selection.getParagraphLength(newParagraph) + 1;
                    if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                        //tslint:disable-next-line:max-line-length
                        this.editorHistory.currentBaseHistoryInfo.endPosition = this.selection.getHierarchicalIndex(newParagraph, offset.toString());
                    }
                }
                else if (paragraph === start.paragraph && isNullOrUndefined(nextWidget) && !isNullOrUndefined(prevParagraph)) {
                    var offset = this.selection.getParagraphLength(prevParagraph);
                    // if (isNullOrUndefined(block)) {
                    selection.editPosition = this.selection.getHierarchicalIndex(prevParagraph, offset.toString());
                    if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                        this.updateHistoryPosition(selection.editPosition, true);
                        this.editorHistory.currentBaseHistoryInfo.endPosition = selection.editPosition;
                    }
                    // } else {
                    //     let offset: number = selection.getParagraphLength(paragraph) + 1;
                    //     if (block instanceof ParagraphWidget) {
                    //         prevParagraph = block as ParagraphWidget;
                    //     }
                    //     // if (block instanceof WTable) {
                    //     //     prevParagraph = (block as WTable).getFirstParagraphInFirstCell();
                    //     // }
                    //     selection.editPosition = prevLineWidget.getHierarchicalIndex('0');
                    // }
                }
            }
            if (start.paragraph !== paragraph && !isNullOrUndefined(block)) {
                this.delBlockContinue = true;
                this.delBlock = block;
            }
            else {
                this.delBlockContinue = false;
                this.delBlock = undefined;
            }
        }
        this.insertParagraphPaste(paragraph, currentParagraph, start, end, isCombineNextParagraph, editAction);
    };
    Editor.prototype.deleteSection = function (selection, section, nextSection, editAction) {
        if (editAction < 4) {
            this.combineSectionInternal(selection, section, nextSection);
        }
        //Copies the section properties, if this is last paragraph of section.
        if (editAction > 2) {
            section.sectionFormat.copyFormat(nextSection.sectionFormat);
        }
    };
    Editor.prototype.combineSectionInternal = function (selection, section, nextSection) {
        // if (section.sectionFormat.isEqualFormat(nextSection.sectionFormat)) {
        // } else {
        var bodyWidget = section.getSplitWidgets()[0];
        var currentSection = [];
        this.combineSectionChild(bodyWidget, currentSection);
        bodyWidget = currentSection[0];
        var lastBlockIndex = bodyWidget.lastChild.index;
        this.updateBlockIndex(lastBlockIndex + 1, nextSection.firstChild);
        var insertIndex = 0;
        var containerWidget = nextSection;
        for (var i = 0; i < bodyWidget.childWidgets.length; i++) {
            var block = bodyWidget.childWidgets.splice(i, 1)[0];
            containerWidget.childWidgets.splice(insertIndex, 0, block);
            block.containerWidget = containerWidget;
            this.viewer.layout.layoutBodyWidgetCollection(block.index, block.bodyWidget, block, false);
            block = block.getSplitWidgets().pop();
            containerWidget = block.containerWidget;
            insertIndex = block.indexInOwner + 1;
            i--;
        }
        this.updateSectionIndex(undefined, nextSection, false);
        this.addRemovedNodes(bodyWidget);
        // this.insert
        // }
    };
    //tslint:disable:max-line-length
    /**
     * @private
     */
    Editor.prototype.checkAndInsertBlock = function (block, start, end, editAction, previousParagraph) {
        if (block instanceof ParagraphWidget && block === start.paragraph || block instanceof TableWidget) {
            var newParagraph = void 0; //Adds an empty paragraph, to ensure minimal content.
            if (isNullOrUndefined(block.nextWidget) && (isNullOrUndefined(previousParagraph) || previousParagraph.nextRenderedWidget instanceof TableWidget)) {
                newParagraph = new ParagraphWidget();
                if (editAction === 1 && block instanceof ParagraphWidget) {
                    newParagraph.characterFormat.copyFormat(block.characterFormat);
                    newParagraph.paragraphFormat.copyFormat(block.paragraphFormat);
                }
                newParagraph.index = block.index + 1;
                newParagraph.containerWidget = block.containerWidget;
                this.viewer.layout.layoutBodyWidgetCollection(newParagraph.index, newParagraph.bodyWidget, newParagraph, false);
                if (block.containerWidget instanceof Widget) {
                    block.containerWidget.childWidgets.push(newParagraph);
                }
            }
            return newParagraph;
        }
        return undefined;
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.splitParagraph = function (paragraphAdv, startLine, startOffset, endLine, endOffset, removeBlock) {
        var paragraph = new ParagraphWidget();
        paragraph.paragraphFormat = new WParagraphFormat(paragraph);
        paragraph.characterFormat = new WCharacterFormat(paragraph);
        paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
        paragraph.characterFormat.copyFormat(paragraphAdv.characterFormat);
        var lineWidget = new LineWidget(paragraph);
        paragraph.childWidgets.push(lineWidget);
        var blockIndex = paragraphAdv.index;
        var insertIndex = paragraphAdv.indexInOwner;
        this.moveInlines(paragraphAdv, paragraph, 0, startOffset, startLine, endOffset, endLine);
        //Inserts new paragraph in the current text position.
        paragraphAdv.containerWidget.childWidgets.splice(insertIndex, 0, paragraph);
        paragraph.index = blockIndex;
        paragraph.containerWidget = paragraphAdv.containerWidget;
        this.updateNextBlocksIndex(paragraph, true);
        if (removeBlock) {
            this.removeBlock(paragraphAdv);
        }
        // tslint:disable-next-line:max-line-length
        this.viewer.layout.layoutBodyWidgetCollection(blockIndex, paragraph.containerWidget, paragraph, false);
        return paragraph;
    };
    /**
     * @private
     */
    Editor.prototype.removeBlock = function (block, isSkipShifting) {
        var index;
        var blockCollection;
        var containerWidget;
        this.removeFieldInBlock(block);
        this.removeFieldInBlock(block, true);
        if (block.isInsideTable) {
            containerWidget = block.associatedCell;
            index = block.associatedCell.childWidgets.indexOf(block);
            blockCollection = block.associatedCell.childWidgets;
            this.updateNextBlocksIndex(block, false);
            block.associatedCell.childWidgets.splice(index, 1);
            block.containerWidget = undefined;
            this.viewer.layout.layoutBodyWidgetCollection(block.index, containerWidget, block, false);
        }
        else {
            containerWidget = block.containerWidget;
            index = containerWidget.childWidgets.indexOf(block);
            blockCollection = containerWidget.childWidgets;
            this.updateNextBlocksIndex(block, false);
            containerWidget.childWidgets.splice(index, 1);
            block.containerWidget = undefined;
            containerWidget.height -= block.height;
            this.viewer.layout.layoutBodyWidgetCollection(block.index, containerWidget, block, false, isSkipShifting);
        }
    };
    Editor.prototype.removeField = function (block, isBookmark) {
        var collection = this.viewer.fields;
        if (isBookmark) {
            collection = this.viewer.bookmarks.keys;
        }
        for (var i = 0; i < collection.length; i++) {
            var element = isBookmark ?
                this.viewer.bookmarks.get(collection[i]) : collection[i];
            if (element.line.paragraph === block) {
                if (isBookmark) {
                    this.viewer.bookmarks.remove(collection[i]);
                }
                else {
                    this.viewer.fields.splice(i, 1);
                }
                i--;
            }
        }
    };
    Editor.prototype.addRemovedNodes = function (node) {
        if (node instanceof CommentCharacterElementBox && node.commentType === 0 && node.commentMark) {
            node.removeCommentMark();
        }
        if (node instanceof FieldElementBox && node.fieldType === 0) {
            if (this.viewer.fields.indexOf(node) !== -1) {
                this.viewer.fields.splice(this.viewer.fields.indexOf(node), 1);
            }
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.editorHistory.currentBaseHistoryInfo.removedNodes.push(node);
        }
        else if (this.editHyperlinkInternal) {
            this.nodes.push(node);
        }
    };
    Editor.prototype.deleteBlock = function (block, selection, start, end, editAction) {
        if (block instanceof ParagraphWidget) {
            this.deletePara(block, start, end, editAction);
            if (this.delBlockContinue && this.delBlock) {
                if (this.delSection) {
                    var bodyWidget = block.bodyWidget instanceof BodyWidget ? block.bodyWidget : undefined;
                    this.deleteSection(selection, this.delSection, bodyWidget, editAction);
                    this.delSection = undefined;
                }
                this.deleteBlock(this.delBlock, selection, start, end, editAction);
                this.delBlockContinue = false;
                this.delBlock = undefined;
            }
        }
        else {
            this.deleteTableBlock(block, selection, start, end, editAction);
        }
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.deleteTableCell = function (cellAdv, selection, start, end, editAction) {
        var deletePreviousBlock = !(start.paragraph.isInsideTable && cellAdv.ownerTable.contains(start.paragraph.associatedCell));
        var previousBlock = cellAdv.ownerTable.previousRenderedWidget;
        if (start.paragraph.isInsideTable) {
            var containerCell = selection.getContainerCellOf(cellAdv, start.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(start.paragraph.associatedCell)) {
                var startCell = selection.getSelectedCell(cellAdv, containerCell);
                var endCell = selection.getSelectedCell(start.paragraph.associatedCell, containerCell);
                if (selection.containsCell(containerCell, start.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (selection.isCellSelected(containerCell, start, end)) {
                        //Container cell is completely selected.
                        this.updateEditPosition(containerCell, selection);
                        if (editAction === 1) {
                            //Specifically handled for backspace. Delete selected cell in current table.
                            this.deleteCellsInTable(cellAdv.ownerRow.ownerTable, selection, start, end, editAction);
                        }
                        else {
                            //Delete contents within table cell or Copy contents within table cell to clipboard.
                            var isCellCleared = this.deleteCell(containerCell, selection, editAction, true);
                            if (!isCellCleared && editAction !== 2 && this.editorHistory) {
                                this.editorHistory.currentBaseHistoryInfo = undefined;
                            }
                            else if (isCellCleared) {
                                this.viewer.layout.reLayoutTable(containerCell.ownerRow.ownerTable);
                            }
                        }
                    }
                    else {
                        if (startCell === containerCell) {
                            this.deletePara(end.paragraph, start, end, editAction);
                            if (this.delBlockContinue && this.delBlock) {
                                if (this.delSection) {
                                    var para = end.paragraph;
                                    var bodyWidget = para.bodyWidget instanceof BodyWidget ? para.bodyWidget : undefined;
                                    this.deleteSection(selection, this.delSection, bodyWidget, editAction);
                                    this.delSection = undefined;
                                }
                                this.deleteBlock(this.delBlock, selection, start, end, editAction);
                                this.delBlockContinue = false;
                                this.delBlock = undefined;
                            }
                        }
                        else {
                            this.deleteContainer(startCell, selection, start, end, editAction);
                        }
                    }
                }
                else {
                    if (editAction === 2) {
                        //Delete contents within table cell.
                        this.deleteCell(cellAdv, selection, 2, false);
                    }
                    else {
                        //Delete other selected cells in current table.
                        this.deleteCellsInTable(containerCell.ownerTable, selection, start, end, editAction);
                    }
                }
            }
            else {
                //Selection end is different table.
                this.deleteContainer(containerCell, selection, start, end, editAction);
            }
        }
        else {
            //Selection end is outside table.
            var cell = selection.getContainerCell(cellAdv);
            this.deleteContainer(cell, selection, start, end, editAction);
        }
        if (deletePreviousBlock) {
            var sectionAdv = previousBlock.bodyWidget instanceof BodyWidget ? previousBlock.bodyWidget : undefined;
            // this.deleteContent(cellAdv.ownerTable, selection, editAction);
            if (!isNullOrUndefined(previousBlock)) {
                // let nextSection: WSection = blockAdv.section instanceof WSection ? blockAdv.section as WSection : undefined;
                // if (sectionAdv !== nextSection) {
                //     this.deleteSection(selection, sectionAdv, nextSection, editAction);
                // }
                //Goto the next block.
                this.deleteBlock(previousBlock, selection, start, end, editAction);
            }
        }
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.deleteCellsInTable = function (table, selection, start, end, editAction) {
        var clonedTable = undefined;
        var isDeleteCells = false;
        var action = 'Delete';
        var startCell = start.paragraph.associatedCell;
        var endCell = end.paragraph.associatedCell;
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            action = this.editorHistory.currentBaseHistoryInfo.action;
            //tslint:disable-next-line:max-line-length
            isDeleteCells = this.editorHistory.currentBaseHistoryInfo.action === 'BackSpace' || this.editorHistory.currentBaseHistoryInfo.action === 'DeleteCells'
                || this.editorHistory.currentBaseHistoryInfo.action === 'InsertTable' || (isNullOrUndefined(startCell.ownerRow.previousWidget)
                && isNullOrUndefined(endCell.ownerRow.nextWidget) && this.editorHistory.currentBaseHistoryInfo.action === 'Cut');
            this.editorHistory.currentBaseHistoryInfo.action = isDeleteCells ? 'DeleteCells' : 'ClearCells';
            clonedTable = this.cloneTableToHistoryInfo(table);
            selection.owner.isLayoutEnabled = false;
        }
        var startColumnIndex = startCell.columnIndex;
        var endColumnIndex = endCell.columnIndex + endCell.cellFormat.columnSpan - 1;
        var startRowIndex = startCell.rowIndex;
        var endRowIndex = endCell.rowIndex;
        var isStarted = false;
        var isCellCleared = false;
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            if (row.index >= startRowIndex && row.index <= endRowIndex) {
                for (var j = 0; j < row.childWidgets.length; j++) {
                    var cell = row.childWidgets[j];
                    if (cell.columnIndex >= startColumnIndex && cell.columnIndex <= endColumnIndex) {
                        if (!isStarted) {
                            this.updateEditPosition(cell, selection);
                            isStarted = true;
                        }
                        if (isDeleteCells) {
                            //Specific for Backspace and Cut if selection includes all rows.
                            var cell_1 = row.childWidgets[j];
                            this.updateNextBlocksIndex(cell_1, false);
                            row.childWidgets.splice(j, 1);
                            j--;
                        }
                        else if (editAction < 4) {
                            isCellCleared = this.deleteCell(cell, selection, editAction, false);
                        }
                    }
                }
                if (row.childWidgets.length === 0) {
                    this.updateNextBlocksIndex(table.childWidgets[i], false);
                    table.childWidgets.splice(i, 1);
                    i--;
                    endRowIndex--;
                }
            }
        }
        //Layouts the table after delete cells.
        selection.owner.isLayoutEnabled = true;
        if (table.childWidgets.length === 0) {
            selection.editPosition = this.selection.getHierarchicalIndex(table, '0');
            this.setActionInternal(selection, action);
            this.removeBlock(table);
        }
        else {
            // Before lay outing need to update table grid.
            table.isGridUpdated = false;
            table.buildTableColumns();
            table.isGridUpdated = true;
            this.viewer.layout.reLayoutTable(table);
        }
    };
    Editor.prototype.deleteCell = function (cell, selection, editAction, copyChildToClipboard) {
        //Checks whether this is last paragraph of owner textbody.
        var block = cell.childWidgets[0];
        if (cell.childWidgets.length === 1 && block instanceof ParagraphWidget && block.isEmpty()) {
            return false;
        }
        for (var i = 0; i < cell.childWidgets.length; i++) {
            block = cell.childWidgets[i];
            if (editAction < 4) {
                //Checks whether this is last paragraph of owner textbody.
                if (block instanceof ParagraphWidget && cell.childWidgets.length === 1) {
                    //Preserves empty paragraph, to ensure minimal content.
                    var paragraph = block;
                    //Removes all the inlines in the paragraph.
                    for (var j = 0; j < paragraph.childWidgets.length; j++) {
                        var inline = paragraph.childWidgets[j];
                        for (var k = 0; k < inline.children.length; k++) {
                            var element = inline.children[k];
                            this.unLinkFieldCharacter(element);
                            inline.children.splice(k, 1);
                            // this.layoutInlineCollection(true, paragraph.inlines.indexOf(inline), paragraph.inlines, inline);
                            k--;
                            if (this.checkClearCells(selection)) {
                                this.addRemovedNodes(element);
                            }
                        }
                        if (paragraph.childWidgets.length > 1) {
                            paragraph.childWidgets.splice(j, 1);
                            j--;
                        }
                    }
                    if (this.checkClearCells(selection)) {
                        //Add Index for line Widget
                        selection.editPosition = this.selection.getHierarchicalIndex(paragraph, '0');
                        this.updateHistoryPosition(selection.editPosition, true);
                    }
                    break;
                }
                this.removeBlock(block);
                i--;
                if (this.checkClearCells(selection)) {
                    this.addRemovedNodes(block);
                }
            }
        }
        return true;
    };
    Editor.prototype.deleteContainer = function (cell, selection, start, end, editAction) {
        var ownerTable = cell.ownerTable;
        if (selection.containsRow(ownerTable.lastChild, end.paragraph.associatedCell)) {
            this.deleteContent(ownerTable, selection, editAction);
        }
        else {
            for (var i = 0; i < ownerTable.childWidgets.length; i++) {
                var row = ownerTable.childWidgets[i];
                if (editAction < 4) {
                    this.updateNextBlocksIndex(row, false);
                    ownerTable.childWidgets.splice(i, 1);
                    this.addRemovedNodes(row);
                    i--;
                }
                if (end.paragraph.isInsideTable && selection.containsRow(row, end.paragraph.associatedCell)) {
                    this.viewer.layout.reLayoutTable(ownerTable);
                    return;
                }
            }
        }
    };
    Editor.prototype.deleteTableBlock = function (table, selection, start, end, editAction) {
        table = table.combineWidget(this.viewer);
        if (start.paragraph.isInsideTable && table.contains(start.paragraph.associatedCell)) {
            var block = table.previousRenderedWidget;
            // tslint:disable-next-line:max-line-length
            var previousBlock = this.checkAndInsertBlock(table, start, end, editAction, block instanceof ParagraphWidget ? block : undefined);
            if (selection.containsRow(table.firstChild, start.paragraph.associatedCell)) {
                this.deleteContent(table, selection, editAction);
            }
            else {
                var newTable = this.splitTable(table, start.paragraph.associatedCell.ownerRow);
                this.deleteContent(table, selection, editAction);
                this.viewer.layout.layoutBodyWidgetCollection(newTable.index, newTable.containerWidget, newTable, false);
            }
            if (!isNullOrUndefined(previousBlock)) {
                selection.editPosition = this.selection.getHierarchicalIndex(previousBlock, '0');
                if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                    this.editorHistory.currentBaseHistoryInfo.endPosition = selection.editPosition;
                }
            }
        }
        else {
            var blockAdv = table.previousRenderedWidget;
            var sectionAdv = table.bodyWidget instanceof BodyWidget ? table.bodyWidget : undefined;
            this.deleteContent(table, selection, editAction);
            if (!isNullOrUndefined(blockAdv)) {
                // let nextSection: WSection = blockAdv.section instanceof WSection ? blockAdv.section as WSection : undefined;
                // if (sectionAdv !== nextSection) {
                //     this.deleteSection(selection, sectionAdv, nextSection, editAction);
                // }
                //Goto the next block.
                this.deleteBlock(blockAdv, selection, start, end, editAction);
            }
        }
    };
    Editor.prototype.splitTable = function (table, splitEndRow) {
        var newTable = new TableWidget();
        newTable.tableFormat.copyFormat(table.tableFormat);
        newTable.index = table.index;
        //Moves the rows to new table.
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            if (row === splitEndRow) {
                break;
            }
            newTable.childWidgets.push(row);
            row.containerWidget = newTable;
            table.childWidgets.splice(i, 1);
            i--;
        }
        //Inserts new table in the current text position.
        var insertIndex = table.getIndex();
        table.containerWidget.childWidgets.splice(insertIndex, 0, newTable);
        newTable.containerWidget = table.containerWidget;
        this.updateNextBlocksIndex(newTable, true);
        return newTable;
    };
    Editor.prototype.updateEditPosition = function (cell, selection) {
        var firstParagraph = selection.getFirstParagraphInCell(cell);
        selection.editPosition = this.selection.getHierarchicalIndex(firstParagraph, '0');
    };
    /**
     * @private
     */
    Editor.prototype.deleteContent = function (table, selection, editAction) {
        if (editAction < 4) {
            this.removeBlock(table);
            this.addRemovedNodes(table);
        }
    };
    Editor.prototype.setActionInternal = function (selection, action) {
        if (this.viewer.owner.enableHistoryMode && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.editorHistory.currentBaseHistoryInfo.action = action;
        }
    };
    Editor.prototype.checkClearCells = function (selection) {
        // tslint:disable-next-line:max-line-length
        return this.editorHistory && this.editorHistory.currentBaseHistoryInfo && this.editorHistory.currentBaseHistoryInfo.action !== 'ClearCells';
    };
    Editor.prototype.isEndInAdjacentTable = function (paragraph, endParagraph) {
        var start = this.selection.getHierarchicalIndex(paragraph, '');
        var end = this.selection.getHierarchicalIndex(endParagraph, '');
        var selectionStart = start.split(';');
        var selectionEnd = end.split(';');
        return selectionStart.length < selectionEnd.length;
    };
    Editor.prototype.cloneTableToHistoryInfo = function (table) {
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            //Clones the entire table to preserve in history.
            var clonedTable = table.clone();
            //Preserves the cloned table in history info, for future undo operation.
            this.editorHistory.currentBaseHistoryInfo.removedNodes.push(clonedTable);
            //Sets the insert position in history info as current table.
            if (this.viewer.selection.start.paragraph.isInsideTable &&
                this.viewer.selection.start.paragraph.associatedCell.ownerTable === table) {
                this.updateHistoryPosition(this.selection.getHierarchicalIndex(table, '0'), true);
            }
            return clonedTable;
        }
        return undefined;
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.insertParagraphPaste = function (paragraph, currentParagraph, start, end, isCombineNextParagraph, editAction) {
        if (this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing) && this.editorHistory.currentBaseHistoryInfo.action === 'Paste') {
            var nextParagraph = this.selection.getNextParagraphBlock(currentParagraph);
            if (nextParagraph) {
                if (start.offset > 0 && nextParagraph === end.paragraph && paragraph === start.paragraph
                    && this.editorHistory.currentBaseHistoryInfo.action === 'Paste') {
                    //Combines the current paragraph with end paragraph specific for undo/redo paste action.
                    var insertIndex = 0;
                    this.removeBlock(currentParagraph);
                    this.viewer.layout.clearListElementBox(nextParagraph);
                    this.viewer.layout.clearListElementBox(currentParagraph);
                    for (var i = 0; i < currentParagraph.childWidgets.length; i++) {
                        var line = currentParagraph.childWidgets[i];
                        nextParagraph.childWidgets.splice(insertIndex, 0, line);
                        currentParagraph.childWidgets.splice(i, 1);
                        i--;
                        insertIndex++;
                        line.paragraph = nextParagraph;
                    }
                    this.viewer.layout.reLayoutParagraph(nextParagraph, 0, 0);
                    isCombineNextParagraph = false;
                    var offset = this.selection.editPosition.substring(this.selection.editPosition.lastIndexOf(';') + 1);
                    this.selection.editPosition = this.selection.getHierarchicalIndex(nextParagraph, offset);
                }
            }
        }
        if (isCombineNextParagraph) {
            this.deleteParagraphMark(currentParagraph, this.selection, editAction);
        }
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.removeInlines = function (paragraph, startLine, startOffset, endLine, endOffset, editAction) {
        var isRemoved = false;
        this.viewer.layout.clearListElementBox(paragraph);
        var startIndex = paragraph.childWidgets.indexOf(startLine);
        for (var i = paragraph.childWidgets.length - 1; i >= 0; i--) {
            var lineWidget = paragraph.childWidgets[i];
            if (startLine === lineWidget && endLine === lineWidget) {
                this.removeContent(lineWidget, startOffset, endOffset);
                isRemoved = true;
                break;
            }
            if (endLine === lineWidget) {
                isRemoved = true;
                this.removeContent(lineWidget, 0, endOffset);
            }
            else if (startLine === lineWidget) {
                this.removeContent(lineWidget, startOffset, this.viewer.selection.getLineLength(lineWidget));
                break;
            }
            else if (isRemoved) {
                this.removeContent(lineWidget, 0, this.viewer.selection.getLineLength(lineWidget));
            }
        }
        if (isRemoved) {
            this.removeEmptyLine(paragraph);
            this.viewer.layout.reLayoutParagraph(paragraph, 0, 0);
        }
    };
    /**
     * @private
     */
    Editor.prototype.removeContent = function (lineWidget, startOffset, endOffset) {
        var count = this.selection.getLineLength(lineWidget);
        var isBidi = lineWidget.paragraph.paragraphFormat.bidi;
        var childLength = lineWidget.children.length;
        for (var i = isBidi ? 0 : childLength - 1; isBidi ? i < childLength : i >= 0; isBidi ? i++ : i--) {
            var inline = lineWidget.children[i];
            if (endOffset <= count - inline.length) {
                count -= inline.length;
                continue;
            }
            var endIndex = inline.length;
            if (count > endOffset && (count - endIndex < endOffset)) {
                endIndex = endOffset - (count - inline.length);
            }
            var startIndex = 0;
            if (count - inline.length < startOffset) {
                startIndex = startOffset - (count - inline.length);
            }
            if (count > endOffset) {
                count -= (inline.length - endIndex);
            }
            if (startIndex === 0 && endIndex === inline.length) {
                if (!(this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing))) {
                    if (inline instanceof BookmarkElementBox) {
                        this.removedBookmarkElements.push(inline);
                    }
                }
                if (inline instanceof BookmarkElementBox) {
                    if (this.viewer.bookmarks.containsKey(inline.name)) {
                        this.viewer.bookmarks.remove(inline.name);
                    }
                }
                // if (editAction < 4) {
                this.unLinkFieldCharacter(inline);
                this.addRemovedNodes(lineWidget.children[i]);
                lineWidget.children.splice(i, 1);
                // }
            }
            else if (inline instanceof TextElementBox) {
                // if (editAction < 4) {
                var span = new TextElementBox();
                span.characterFormat.copyFormat(inline.characterFormat);
                span.text = inline.text.substr(startIndex, endIndex - startIndex);
                this.addRemovedNodes(span);
                inline.text = inline.text.slice(0, startIndex) + inline.text.slice(endIndex);
            }
            if (startOffset >= count - (endIndex - startIndex)) {
                break;
            }
            count -= (endIndex - startIndex);
        }
    };
    /**
     * @private
     */
    Editor.prototype.removeEmptyLine = function (paragraph) {
        if (paragraph.childWidgets.length > 1) {
            for (var i = 0; i < paragraph.childWidgets.length; i++) {
                var lineWidget = paragraph.childWidgets[i];
                if (lineWidget.children.length === 0 && paragraph.childWidgets.length > 1) {
                    paragraph.childWidgets.splice(i, 1);
                    i--;
                }
            }
        }
    };
    //#endregion
    /**
     * clone the list level
     * @param  {WListLevel} source
     * @private
     */
    Editor.prototype.cloneListLevel = function (source) {
        var listLevel = new WListLevel(undefined);
        this.copyListLevel(listLevel, source);
        return listLevel;
    };
    /**
     * Copies the list level
     * @param  {WListLevel} destination
     * @param  {WListLevel} listLevel
     * @private
     */
    Editor.prototype.copyListLevel = function (destination, listLevel) {
        if (!isNullOrUndefined(listLevel.paragraphFormat)) {
            destination.paragraphFormat = new WParagraphFormat(destination);
            destination.paragraphFormat.copyFormat(listLevel.paragraphFormat);
        }
        if (!isNullOrUndefined(listLevel.characterFormat)) {
            destination.characterFormat = new WCharacterFormat(destination);
            destination.characterFormat.copyFormat(listLevel.characterFormat);
        }
        if (!isNullOrUndefined(listLevel.followCharacter)) {
            destination.followCharacter = listLevel.followCharacter;
        }
        if (!isNullOrUndefined(listLevel.listLevelPattern)) {
            destination.listLevelPattern = listLevel.listLevelPattern;
        }
        if (!isNullOrUndefined(listLevel.numberFormat)) {
            destination.numberFormat = listLevel.numberFormat;
        }
        if (!isNullOrUndefined(listLevel.restartLevel)) {
            destination.restartLevel = listLevel.restartLevel;
        }
        if (!isNullOrUndefined(listLevel.startAt)) {
            destination.startAt = listLevel.startAt;
        }
    };
    /**
     * Clone level override
     * @param  {WLevelOverride} source
     * @private
     */
    Editor.prototype.cloneLevelOverride = function (source) {
        var levelOverride = new WLevelOverride();
        if (!isNullOrUndefined(source.startAt)) {
            levelOverride.startAt = source.startAt;
        }
        if (!isNullOrUndefined(source.overrideListLevel)) {
            levelOverride.overrideListLevel = source.overrideListLevel;
        }
        if (!isNullOrUndefined(source.levelNumber)) {
            levelOverride.levelNumber = source.levelNumber;
        }
        return levelOverride;
    };
    /**
     * Update List Paragraph
     * @private
     */
    Editor.prototype.updateListParagraphs = function () {
        this.viewer.listParagraphs = [];
        for (var j = 0; j < this.viewer.pages.length; j++) {
            var bodyWidget = this.viewer.pages[j].bodyWidgets[0];
            for (var i = 0; i < bodyWidget.childWidgets.length; i++) {
                this.updateListParagraphsInBlock(bodyWidget.childWidgets[i]);
            }
        }
    };
    /**
     * @private
     */
    Editor.prototype.updateListParagraphsInBlock = function (block) {
        if (block instanceof ParagraphWidget) {
            if (!isNullOrUndefined(block.paragraphFormat)
                && !isNullOrUndefined(block.paragraphFormat.listFormat)
                && !isNullOrUndefined(block.paragraphFormat.listFormat.listId)) {
                if (isNullOrUndefined(this.viewer.listParagraphs)) {
                    this.viewer.listParagraphs = [];
                }
                this.viewer.listParagraphs.push(block);
            }
        }
        else if (block instanceof TableWidget) {
            for (var i = 0; i < block.childWidgets.length; i++) {
                for (var j = 0; j < block.childWidgets[i].childWidgets.length; j++) {
                    var cell = block.childWidgets[i].childWidgets[j];
                    for (var k = 0; k < cell.childWidgets.length; k++) {
                        this.updateListParagraphsInBlock(cell.childWidgets[k]);
                    }
                }
            }
        }
    };
    /**
     * Applies list format
     * @param  {WList} list
     * @private
     */
    Editor.prototype.onApplyList = function (list) {
        var selection = this.viewer.selection;
        this.setOffsetValue(this.viewer.selection);
        this.initHistory('ListFormat');
        var format = new WListFormat();
        if (!isNullOrUndefined(list)) {
            format.listId = list.listId;
        }
        this.viewer.owner.isShiftingEnabled = true;
        if (selection.isEmpty) {
            this.applyParaFormatProperty(selection.start.paragraph, 'listFormat', format, false);
            this.layoutItemBlock(selection.start.paragraph, false);
        }
        else {
            this.updateSelectionParagraphFormatting('listFormat', format, false);
        }
        this.reLayout(selection);
    };
    /**
     * Applies bullets or numbering list
     * @param  {string} format
     * @param  {ListLevelPattern} listLevelPattern
     * @param  {string} fontFamily
     * @private
     */
    Editor.prototype.applyBulletOrNumbering = function (format, listLevelPattern, fontFamily) {
        var selection = this.viewer.selection;
        var list = selection.paragraphFormat.getList();
        var isUpdate = false;
        var start = selection.start;
        if (!selection.isForward) {
            start = selection.end;
        }
        var currentParagraph = start.paragraph;
        if (isNullOrUndefined(list)) {
            while (!isNullOrUndefined(currentParagraph.previousWidget) && currentParagraph.previousWidget instanceof ParagraphWidget
                && currentParagraph.previousWidget.isEmpty() && currentParagraph.previousWidget.paragraphFormat.listFormat.listId === -1) {
                currentParagraph = currentParagraph.previousWidget;
            }
            if (currentParagraph.previousWidget && currentParagraph.previousWidget instanceof ParagraphWidget
                && currentParagraph.previousWidget.paragraphFormat.listFormat.listId !== -1) {
                currentParagraph = currentParagraph.previousWidget;
                list = this.viewer.getListById(currentParagraph.paragraphFormat.listFormat.listId);
                isUpdate = true;
            }
            if (!isUpdate) {
                while (!isNullOrUndefined(currentParagraph.nextWidget) && currentParagraph.nextWidget instanceof ParagraphWidget
                    && currentParagraph.nextWidget.isEmpty() && currentParagraph.nextWidget.paragraphFormat.listFormat.listId === -1) {
                    currentParagraph = currentParagraph.nextWidget;
                }
                if (currentParagraph.nextWidget && currentParagraph.nextWidget instanceof ParagraphWidget
                    && currentParagraph.nextWidget.paragraphFormat.listFormat.listId !== -1) {
                    currentParagraph = currentParagraph.nextWidget;
                    list = this.viewer.getListById(currentParagraph.paragraphFormat.listFormat.listId);
                    isUpdate = true;
                }
            }
        }
        var startListLevel = undefined;
        var levelNumber = -1;
        var initialListLevel = undefined;
        var isSameList = false;
        if (!isNullOrUndefined(list)) {
            levelNumber = currentParagraph.paragraphFormat.listFormat.listLevelNumber;
            var tempList = this.viewer.getListById(currentParagraph.paragraphFormat.listFormat.listId);
            startListLevel = this.viewer.layout.getListLevel(tempList, levelNumber);
            if (levelNumber > 0) {
                initialListLevel = this.viewer.layout.getListLevel(tempList, 0);
                isSameList = !isNullOrUndefined(initialListLevel) && levelNumber > 0 && selection.start.isInSameParagraph(selection.end);
            }
            var abstractList = tempList.abstractList;
            if (!abstractList) {
                abstractList = this.viewer.getAbstractListById(list.abstractListId);
            }
            if (abstractList.levels.length === 0) {
                startListLevel = this.viewer.layout.getListLevel(tempList, currentParagraph.paragraphFormat.listFormat.listLevelNumber);
            }
            if (isUpdate) {
                if (listLevelPattern !== 'Bullet' && startListLevel.listLevelPattern === listLevelPattern
                    && (startListLevel.numberFormat === format || startListLevel.numberFormat.indexOf(format) !== -1)) {
                    selection.paragraphFormat.listId = list.listId;
                    selection.paragraphFormat.listLevelNumber = levelNumber;
                    selection.paragraphFormat.setList(list);
                    return;
                }
                else {
                    startListLevel = abstractList.levels[0];
                }
            }
        }
        if (isNullOrUndefined(list) || (!isNullOrUndefined(list) && levelNumber === 0
            && ((startListLevel.listLevelPattern !== listLevelPattern) || startListLevel.numberFormat !== format
                || (startListLevel.characterFormat.fontFamily !== fontFamily && startListLevel.listLevelPattern === 'Bullet')))) {
            isUpdate = false;
            list = new WList();
            if (this.viewer.lists.length > 0) {
                list.listId = this.viewer.lists[this.viewer.lists.length - 1].listId + 1;
            }
            else {
                list.listId = 0;
            }
            var abstractList = new WAbstractList();
            if (this.viewer.abstractLists.length > 0) {
                abstractList.abstractListId = this.viewer.abstractLists[this.viewer.abstractLists.length - 1].abstractListId + 1;
            }
            else {
                abstractList.abstractListId = 0;
            }
            list.abstractListId = abstractList.abstractListId;
            list.abstractList = abstractList;
            this.viewer.abstractLists.push(abstractList);
            if (format === 'bullet' || format === 'multiLevel' || format === 'numbering') {
                this.addListLevels(abstractList, format, selection);
            }
            else {
                var listLevel = new WListLevel(abstractList);
                listLevel.listLevelPattern = listLevelPattern;
                listLevel.numberFormat = format;
                if (listLevelPattern !== 'Bullet') {
                    listLevel.startAt = 1;
                }
                else {
                    listLevel.characterFormat.fontFamily = fontFamily;
                }
                listLevel.paragraphFormat.leftIndent = 36;
                listLevel.paragraphFormat.firstLineIndent = -18;
                abstractList.levels.push(listLevel);
                selection.paragraphFormat.listLevelNumber = 0;
            }
            selection.paragraphFormat.setList(list);
        }
        else if (isSameList && !isNullOrUndefined(list)) {
            var tempList = this.viewer.getListById(currentParagraph.paragraphFormat.listFormat.listId);
            var listLevel = this.viewer.layout.getListLevel(tempList, levelNumber);
            if (listLevelPattern === 'Bullet') {
                listLevel.numberFormat = format;
                listLevel.characterFormat.fontFamily = fontFamily;
            }
            else {
                listLevel.listLevelPattern = listLevelPattern;
                var currentFormat = listLevel.numberFormat.substring(listLevel.numberFormat.length - 1);
                if (format.substring(format.length - 1) !== listLevel.numberFormat.substring(listLevel.numberFormat.length - 1)) {
                    listLevel.numberFormat = listLevel.numberFormat.replace(currentFormat, format.substring(format.length - 1));
                }
            }
            selection.paragraphFormat.setList(tempList);
        }
        else if (!isNullOrUndefined(list) && isUpdate) {
            selection.paragraphFormat.setList(list);
        }
        else {
            selection.paragraphFormat.setList(undefined);
        }
    };
    Editor.prototype.addListLevels = function (abstractListAdv, listName, selection) {
        var bulletCharacters = ['\uf076', '\uf0d8', '\uf0a7', '\uf0b7', '\uf0a8'];
        for (var i = abstractListAdv.levels.length; i < 9; i++) {
            var listLevel = new WListLevel(abstractListAdv);
            if (listName.match('bullet')) {
                listLevel.listLevelPattern = 'Bullet';
                listLevel.numberFormat = bulletCharacters[i < 5 ? i % 5 : i % 5 + 1];
                listLevel.characterFormat.fontFamily = i < 3 || i === 5 ? 'Wingdings' : 'Symbol';
            }
            else {
                if (listName.match('multiLevel')) {
                    for (var j = 0; j < i + 1; j++) {
                        listLevel.numberFormat += '%' + (j + 1).toString() + '.';
                    }
                    listLevel.listLevelPattern = 'Number';
                }
                else {
                    listLevel.numberFormat = '%' + (i + 1).toString() + ')';
                    listLevel.listLevelPattern = i % 3 === 0 ? 'Number'
                        : i % 3 === 1 ? 'LowLetter' : 'LowRoman';
                }
                listLevel.startAt = 1;
                listLevel.restartLevel = i;
            }
            if (i === 0) {
                listLevel.paragraphFormat.leftIndent = 36;
            }
            else {
                listLevel.paragraphFormat.leftIndent = 36 * i;
            }
            listLevel.paragraphFormat.firstLineIndent = -18;
            abstractListAdv.levels.push(listLevel);
            selection.paragraphFormat.listLevelNumber = i;
        }
    };
    /**
     * Insert page break at cursor position
     */
    Editor.prototype.insertPageBreak = function () {
        if (!this.owner.isReadOnlyMode) {
            if (this.viewer.selection.start.paragraph.isInsideTable ||
                this.viewer.selection.start.paragraph.isInHeaderFooter) {
                return;
            }
            this.initComplexHistory('PageBreak');
            this.onEnter(true);
            if (this.editorHistory && this.editorHistory.currentHistoryInfo != null) {
                this.editorHistory.updateComplexHistory();
            }
            this.selection.checkForCursorVisibility();
        }
    };
    /**
     * @private
     */
    Editor.prototype.onEnter = function (isInsertPageBreak) {
        var selection = this.viewer.selection;
        if (selection.isEmpty) {
            //ToDo: Need to handle the CTRL + Enter (Page Break) and SHIFT + Enter (Line Break) behavior.
            var hyperlinkField = selection.getHyperlinkField();
            var isSelectionOnHyperlink = !isNullOrUndefined(hyperlinkField);
            if (isSelectionOnHyperlink) {
                selection.fireRequestNavigate(hyperlinkField);
                return;
            }
            var paragraph = selection.start.paragraph;
            if (paragraph.isEmpty() && paragraph.paragraphFormat.listFormat.listId !== -1) {
                // tslint:disable-next-line:max-line-length
                this.onApplyListInternal(this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId), paragraph.paragraphFormat.listFormat.listLevelNumber - 1);
                return;
            }
        }
        this.initHistory('Enter');
        var isRemoved = true;
        if (!selection.isEmpty) {
            // this.initHistoryWithSelection(selection, 'Enter');
            isRemoved = this.removeSelectedContents(selection);
        }
        if (isRemoved) {
            selection.owner.isShiftingEnabled = true;
            this.updateInsertPosition();
            var blockInfo = this.selection.getParagraphInfo(selection.start);
            var initialStart = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            this.splitParagraphInternal(selection, selection.start.paragraph, selection.start.currentWidget, selection.start.offset);
            this.setPositionForCurrentIndex(selection.start, initialStart);
            if (isInsertPageBreak) {
                var currentParagraph = selection.start.paragraph;
                var breakParagraph = new ParagraphWidget();
                breakParagraph.characterFormat.copyFormat(currentParagraph.characterFormat);
                breakParagraph.paragraphFormat.copyFormat(currentParagraph.paragraphFormat);
                var pageBreak = new TextElementBox();
                pageBreak.text = '\f';
                var line = new LineWidget(breakParagraph);
                line.children.push(pageBreak);
                pageBreak.line = line;
                breakParagraph.childWidgets.push(line);
                this.insertParagraph(breakParagraph, true);
                selection.selectParagraphInternal(breakParagraph, true);
            }
            var nextNode = selection.start.paragraph.nextWidget;
            if (isNullOrUndefined(nextNode)) {
                nextNode = selection.getNextRenderedBlock(selection.start.paragraph);
            }
            selection.selectParagraphInternal(nextNode, true);
            this.updateEndPosition();
            if (isInsertPageBreak && this.editorHistory) {
                this.owner.editorHistory.updateHistory();
            }
            // if (!isNullOrUndefined(selection.currentHistoryInfo)) {
            //     this.updateComplexHistory();
            // } else {
            this.reLayout(selection);
            // tslint:disable-next-line:max-line-length
            var currentPara = this.selection.start.paragraph.containerWidget.firstChild;
            if (!isNullOrUndefined(currentPara)) {
                currentPara.isChangeDetected = false;
                var nextPara = currentPara.nextRenderedWidget;
                // tslint:disable-next-line:max-line-length
                while (this.owner.enableSpellCheck && !isNullOrUndefined(nextPara)) {
                    currentPara = nextPara;
                    currentPara.isChangeDetected = false;
                    nextPara = currentPara.nextRenderedWidget;
                }
            }
            // }
            var paragraph = selection.start.paragraph.previousWidget;
            if (!isNullOrUndefined(paragraph) && !paragraph.isEmpty() &&
                // tslint:disable-next-line:max-line-length
                paragraph.lastChild.children[paragraph.lastChild.children.length - 1] instanceof TextElementBox) {
                this.checkAndConvertToHyperlink(selection, true, paragraph);
            }
        }
    };
    Editor.prototype.splitParagraphInternal = function (selection, paragraphAdv, currentLine, offset) {
        var insertIndex = 0;
        var blockIndex = paragraphAdv.index;
        var currentPara = paragraphAdv;
        currentPara.isChangeDetected = (offset === 0) ? true : false;
        while (this.owner.enableSpellCheck && !isNullOrUndefined(currentPara.nextRenderedWidget)) {
            currentPara = currentPara.nextRenderedWidget;
            currentPara.isChangeDetected = true;
        }
        var paragraph = new ParagraphWidget();
        var lineWidget = new LineWidget(paragraph);
        paragraph.childWidgets.push(lineWidget);
        //Copies the format to new paragraph.
        paragraph.paragraphFormat.ownerBase = paragraph;
        if (currentLine === paragraphAdv.lastChild && offset === selection.getLineLength(currentLine)) {
            // tslint:disable-next-line:max-line-length
            if (paragraphAdv.paragraphFormat.baseStyle
                && paragraphAdv.paragraphFormat.baseStyle.name !== 'Normal' && paragraphAdv.paragraphFormat.baseStyle.next instanceof WParagraphStyle) {
                if (paragraphAdv.paragraphFormat.baseStyle.name === paragraphAdv.paragraphFormat.baseStyle.next.name) {
                    paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
                    paragraph.characterFormat.copyFormat(paragraphAdv.characterFormat);
                }
                else {
                    paragraph.paragraphFormat.baseStyle = paragraphAdv.paragraphFormat.baseStyle.next;
                }
                this.selection.skipFormatRetrieval = false;
            }
            else {
                paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
                paragraph.characterFormat.copyFormat(paragraphAdv.characterFormat);
            }
            //ToDo in future: Need to skip copying formattings to new paragraph, if the style for following paragraph is same style.
            insertIndex++;
            blockIndex++;
        }
        else {
            paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
            paragraph.characterFormat.copyFormat(paragraphAdv.characterFormat);
            if (offset > 0 || !currentLine.isFirstLine()) {
                paragraphAdv = paragraphAdv.combineWidget(this.viewer);
                this.moveInlines(paragraphAdv, paragraph, 0, 0, paragraphAdv.firstChild, offset, currentLine);
            }
            paragraphAdv = paragraphAdv.getSplitWidgets()[0];
        }
        insertIndex += paragraphAdv.getIndex();
        var container = paragraphAdv.containerWidget;
        var childNodes = container.childWidgets;
        childNodes.splice(insertIndex, 0, paragraph);
        paragraph.containerWidget = container;
        paragraph.index = blockIndex;
        this.updateNextBlocksIndex(paragraph, true);
        // tslint:disable-next-line:max-line-length
        this.viewer.layout.layoutBodyWidgetCollection(blockIndex, container, paragraph, false);
    };
    /**
     * @private
     */
    Editor.prototype.updateNextBlocksIndex = function (block, increaseIndex) {
        var nextIndex = block.containerWidget.childWidgets.indexOf(block) + 1;
        if (block.containerWidget instanceof BodyWidget) {
            var currentSectionIndex = block.containerWidget.index;
            for (var j = this.viewer.pages.indexOf(block.containerWidget.page); j < this.viewer.pages.length; j++) {
                var page = this.viewer.pages[j];
                if (page.bodyWidgets[0].index === currentSectionIndex) {
                    for (var k = nextIndex; k < page.bodyWidgets[0].childWidgets.length; k++) {
                        var childWidget = page.bodyWidgets[0].childWidgets[k];
                        this.updateIndex(childWidget, increaseIndex);
                    }
                    nextIndex = 0;
                }
                else {
                    return;
                }
            }
        }
        else if (block.containerWidget instanceof TableCellWidget) {
            var cells = block.containerWidget.getSplitWidgets();
            var currentCellIndex = cells.indexOf(block.containerWidget);
            for (var x = currentCellIndex; x < cells.length; x++) {
                var blocks = cells[x].childWidgets;
                for (var y = nextIndex; y < blocks.length; y++) {
                    this.updateIndex(blocks[y], increaseIndex);
                }
                currentCellIndex = 0;
                nextIndex = 0;
            }
        }
        else if (block.containerWidget instanceof TableRowWidget) {
            for (var i = nextIndex; i < block.containerWidget.childWidgets.length; i++) {
                var cell = block.containerWidget.childWidgets[i];
                if (cell.rowIndex === block.containerWidget.index) {
                    this.updateIndex(cell, increaseIndex);
                }
            }
        }
        else if (block.containerWidget instanceof TableWidget) {
            for (var i = nextIndex; i < block.containerWidget.childWidgets.length; i++) {
                var row = block.containerWidget.childWidgets[i];
                this.updateIndex(row, increaseIndex);
                for (var j = 0; j < row.childWidgets.length; j++) {
                    row.childWidgets[j].rowIndex = row.index;
                }
            }
            //update Row index of all the cell
        }
        else if (block.containerWidget instanceof HeaderFooterWidget) {
            for (var i = nextIndex; i < block.containerWidget.childWidgets.length; i++) {
                var nextBlock = block.containerWidget.childWidgets[i];
                this.updateIndex(nextBlock, increaseIndex);
            }
        }
    };
    Editor.prototype.updateIndex = function (widget, increment) {
        if (increment) {
            widget.index++;
        }
        else {
            widget.index--;
        }
    };
    Editor.prototype.updateEndPosition = function () {
        var selection = this.viewer.selection;
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.updateHistoryPosition(selection.start, false);
        }
    };
    /**
     * @private
     */
    Editor.prototype.onBackSpace = function () {
        this.removeEditRange = true;
        var selection = this.viewer.selection;
        this.viewer.triggerSpellCheck = true;
        if (selection.isEmpty) {
            this.singleBackspace(selection, false);
        }
        else {
            this.initHistory('BackSpace');
            var skipBackSpace = this.deleteSelectedContents(selection, true);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                if (skipBackSpace) {
                    this.editorHistory.currentBaseHistoryInfo = undefined;
                }
                else {
                    if (this.checkEndPosition(selection)) {
                        this.updateHistoryPosition(selection.end, false);
                    }
                    this.reLayout(selection);
                }
            }
            this.viewer.triggerSpellCheck = false;
        }
        this.removeEditRange = false;
    };
    /**
     * @private
     */
    Editor.prototype.insertRemoveBookMarkElements = function () {
        var isHandledComplexHistory = false;
        for (var i = 0; i < this.removedBookmarkElements.length; i++) {
            var bookMark = this.removedBookmarkElements[i];
            if (bookMark.bookmarkType === 0) {
                if (!this.viewer.bookmarks.containsKey(bookMark.name)) {
                    this.viewer.bookmarks.add(bookMark.name, bookMark);
                }
                var bookMarkStart = bookMark;
                if (bookMarkStart && bookMarkStart.reference && this.removedBookmarkElements.indexOf(bookMarkStart.reference) !== -1) {
                    var endIndex = this.removedBookmarkElements.indexOf(bookMarkStart.reference);
                    var startIndex = this.removedBookmarkElements.indexOf(bookMarkStart);
                    this.removedBookmarkElements.splice(endIndex, 1);
                    this.removedBookmarkElements.splice(startIndex, 1);
                    i--;
                }
                else {
                    if (this.editorHistory.currentBaseHistoryInfo) {
                        this.initComplexHistory(this.editorHistory.currentBaseHistoryInfo.action);
                        this.editorHistory.updateHistory();
                    }
                    this.initInsertInline(bookMarkStart.clone());
                    if (this.editorHistory.currentHistoryInfo) {
                        this.editorHistory.updateComplexHistory();
                        isHandledComplexHistory = true;
                    }
                }
            }
            else {
                var bookMarkEnd = bookMark;
                if (bookMarkEnd && bookMarkEnd.reference && this.removedBookmarkElements.indexOf(bookMarkEnd.reference) !== -1) {
                    var endIndex = this.removedBookmarkElements.indexOf(bookMarkEnd.reference);
                    var startIndex = this.removedBookmarkElements.indexOf(bookMarkEnd);
                    this.removedBookmarkElements.splice(endIndex, 1);
                    this.removedBookmarkElements.splice(startIndex, 1);
                    i--;
                }
                else {
                    if (this.editorHistory.currentBaseHistoryInfo) {
                        this.initComplexHistory(this.editorHistory.currentBaseHistoryInfo.action);
                        this.editorHistory.updateHistory();
                    }
                    this.initInsertInline(bookMarkEnd.clone());
                    if (this.editorHistory.currentHistoryInfo) {
                        this.editorHistory.updateComplexHistory();
                        isHandledComplexHistory = true;
                    }
                }
            }
        }
        this.removedBookmarkElements = [];
        return isHandledComplexHistory;
    };
    /**
     * @private
     */
    Editor.prototype.deleteSelectedContents = function (selection, isBackSpace) {
        var skipBackSpace = this.deleteSelectedContentInternal(selection, isBackSpace, selection.start, selection.end);
        var textPosition = selection.getTextPosBasedOnLogicalIndex(selection.editPosition);
        selection.selectContent(textPosition, true);
        return skipBackSpace;
    };
    Editor.prototype.removeWholeElement = function (selection) {
        this.initHistory('BackSpace');
        this.deleteSelectedContents(selection, true);
        if (this.checkEndPosition(selection)) {
            this.updateHistoryPosition(selection.end, false);
        }
        this.reLayout(selection);
    };
    /**
     * @private
     */
    Editor.prototype.singleBackspace = function (selection, isRedoing) {
        var history = this.editorHistory;
        // If backspace is pressed after auto format to hyperlink is done, need to undo auto format.
        if (history && !isRedoing && !history.canRedo() && history.canUndo()) {
            var historyInfo = history.undoStack[history.undoStack.length - 1];
            var startBlockInfo = this.selection.getParagraphInfo(selection.start);
            var endBlockInfo = this.selection.getParagraphInfo(selection.end);
            // tslint:disable-next-line:max-line-length
            if (historyInfo.action === 'AutoFormatHyperlink' && historyInfo.insertPosition === this.selection.getHierarchicalIndex(startBlockInfo.paragraph, startBlockInfo.offset.toString()) &&
                historyInfo.endPosition === this.selection.getHierarchicalIndex(endBlockInfo.paragraph, endBlockInfo.offset.toString())) {
                history.undo();
                return;
            }
        }
        var paragraph = selection.start.paragraph;
        var currentLineWidget = selection.start.currentWidget;
        var offset = selection.start.offset;
        var indexInInline = 0;
        var inlineObj = currentLineWidget.getInline(offset, indexInInline);
        var inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (inline instanceof TextElementBox) {
            inline.ignoreOnceItems = [];
        }
        if (inline instanceof TextElementBox) {
            inline.ignoreOnceItems = [];
        }
        if (inline instanceof FieldElementBox && inline.fieldType === 2) {
            if (HelperMethods.isLinkedFieldCharacter(inline)) {
                var begin = inline.fieldBegin;
                var end = inline.fieldEnd;
                selection.start.setPositionParagraph(begin.line, begin.line.getOffset(begin, 0));
                selection.end.setPositionParagraph(end.line, end.line.getOffset(end, 0) + 1);
                selection.fireSelectionChanged(true);
                return;
            }
        }
        if (inline instanceof FieldElementBox && inline.fieldType === 1) {
            var prevInline = selection.getPreviousValidElement(inline);
            if (prevInline instanceof FieldElementBox) {
                inline = prevInline.fieldBegin;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 0);
                selection.end.setPositionParagraph(inline.line, offset); //Selects the entire field.
                selection.fireSelectionChanged(true);
                return;
            }
            else if (prevInline !== inline) {
                inline = prevInline; //Updates the offset to delete next content.
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, inline.length);
            }
        }
        if (inline instanceof EditRangeStartElementBox || inline instanceof EditRangeEndElementBox) {
            if ((inline.nextNode instanceof EditRangeEndElementBox && inline.editRangeEnd === inline.nextNode)
                || (inline.previousNode instanceof EditRangeStartElementBox
                    && inline.editRangeStart === inline.previousNode)) {
                return;
            }
            if (inline instanceof EditRangeStartElementBox && !(inline.previousNode instanceof EditRangeEndElementBox)) {
                return;
            }
            if (inline instanceof EditRangeEndElementBox) {
                inline = inline.previousNode;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, inline.length);
            }
            if (inline.length === 1 && inline.nextNode instanceof EditRangeEndElementBox
                && inline.previousNode instanceof EditRangeStartElementBox) {
                var start = inline.previousNode;
                var end = inline.nextNode;
                selection.start.setPositionParagraph(start.line, start.line.getOffset(start, 0));
                selection.end.setPositionParagraph(end.line, end.line.getOffset(end, 0) + 1);
                this.removeWholeElement(selection);
                return;
            }
        }
        if (inline && (inline instanceof BookmarkElementBox || inline.previousNode instanceof BookmarkElementBox)) {
            if (inline instanceof BookmarkElementBox && inline.bookmarkType === 1) {
                if (inline.previousNode) {
                    inline = inline.previousNode;
                    paragraph = inline.line.paragraph;
                    offset = inline.line.getOffset(inline, inline.length);
                }
                else {
                    // remove paragraph mark and move bookmark to previous paragraph
                    if (paragraph.previousRenderedWidget instanceof ParagraphWidget) {
                        var prevParagraph = paragraph.previousRenderedWidget;
                        var line = prevParagraph.lastChild;
                        selection.start.setPositionParagraph(inline.line, inline.line.getOffset(inline, 0));
                        selection.end.setPositionParagraph(line, line.getEndOffset());
                        this.removeWholeElement(selection);
                        return;
                    }
                }
                // Remove bookmark if selection is in between bookmark start and end element.
            }
            else if (inline.nextNode instanceof BookmarkElementBox && inline instanceof BookmarkElementBox &&
                inline.bookmarkType === 0 && inline.reference === inline.nextNode) {
                this.deleteBookmark(inline.name);
                return;
            }
            if (inline.length === 1 && inline.nextNode instanceof BookmarkElementBox && inline.previousNode instanceof BookmarkElementBox) {
                var begin = inline.previousNode;
                var end = inline.nextNode;
                selection.start.setPositionParagraph(begin.line, begin.line.getOffset(begin, 0));
                selection.end.setPositionParagraph(end.line, end.line.getOffset(end, 0) + 1);
                this.removeWholeElement(selection);
                return;
            }
        }
        if (!isRedoing) {
            this.initHistory('BackSpace');
        }
        if (offset === selection.getStartOffset(paragraph) && selection.start.currentWidget.isFirstLine()) {
            if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId !== -1) {
                this.onApplyList(undefined);
                return;
            }
            if (paragraph.paragraphFormat.firstLineIndent !== 0) {
                this.onApplyParagraphFormat('firstLineIndent', 0, false, false);
                return;
            }
            if (paragraph.paragraphFormat.leftIndent !== 0) {
                this.onApplyParagraphFormat('leftIndent', 0, false, false);
                return;
            }
            if (paragraph.paragraphFormat.textAlignment !== 'Left') {
                this.onApplyParagraphFormat('textAlignment', 'Left', false, true);
                return;
            }
            if (paragraph.previousRenderedWidget instanceof ParagraphWidget) {
                selection.owner.isShiftingEnabled = true;
                var previousParagraph = paragraph.previousRenderedWidget;
                // if (isNullOrUndefined(previousParagraph)) {
                //     previousParagraph = this.viewer.selection.getPreviousBlock(paragraph) as ParagraphWidget;
                // }
                if (previousParagraph.isEmpty()) {
                    this.removeBlock(previousParagraph);
                    this.addRemovedNodes(previousParagraph);
                }
                else {
                    this.removeBlock(paragraph);
                    var endOffset = this.viewer.selection.getLineLength(previousParagraph.lastChild);
                    var previousIndex = previousParagraph.childWidgets.length - 1;
                    var lineWidget = void 0;
                    if (!paragraph.isEmpty()) {
                        for (var i = 0; i < paragraph.childWidgets.length; i++) {
                            lineWidget = paragraph.childWidgets[i];
                            previousParagraph.childWidgets.push(lineWidget);
                            paragraph.childWidgets.splice(i, 1);
                            i--;
                            lineWidget.paragraph = previousParagraph;
                        }
                    }
                    this.viewer.layout.reLayoutParagraph(previousParagraph, previousIndex, 0);
                    selection.selects(previousParagraph.childWidgets[previousIndex], endOffset, true);
                    this.addRemovedNodes(paragraph);
                }
                this.setPositionForHistory();
                // if (!isRedoing) {
                this.reLayout(selection);
                // }
            }
            else {
                if (this.editorHistory) {
                    this.editorHistory.currentBaseHistoryInfo = undefined;
                }
            }
        }
        else {
            if (!isRedoing) {
                selection.owner.isShiftingEnabled = true;
            }
            var paragraphInfo = this.selection.getParagraphInfo(selection.start);
            var lineWidget = selection.start.currentWidget;
            var removeOffset = offset - 1;
            if (removeOffset < 0) {
                lineWidget = lineWidget.previousLine;
                removeOffset = this.viewer.selection.getLineLength(lineWidget) + removeOffset;
            }
            this.removeAtOffset(lineWidget, selection, removeOffset);
            this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset - 1, false);
            this.setPositionForHistory();
            if (!isRedoing) {
                this.reLayout(selection);
            }
            else {
                this.fireContentChange();
            }
        }
    };
    Editor.prototype.setPositionForHistory = function (editPosition) {
        var selection = this.viewer.selection;
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            if (isNullOrUndefined(editPosition)) {
                this.updateHistoryPosition(selection.start, true);
                this.editorHistory.currentBaseHistoryInfo.endPosition = this.editorHistory.currentBaseHistoryInfo.insertPosition;
            }
            else {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = editPosition;
                this.editorHistory.currentBaseHistoryInfo.endPosition = editPosition;
            }
        }
    };
    Editor.prototype.removeAtOffset = function (lineWidget, selection, offset) {
        var count = 0;
        var lineIndex = lineWidget.paragraph.childWidgets.indexOf(lineWidget);
        for (var i = 0; i < lineWidget.children.length; i++) {
            var inline = lineWidget.children[i];
            if (inline instanceof ListTextElementBox) {
                continue;
            }
            if (offset < count + inline.length) {
                var indexInInline = offset - count;
                inline.ischangeDetected = true;
                if (this.owner.enableSpellCheck) {
                    this.owner.spellChecker.removeErrorsFromCollection({ 'element': inline, 'text': inline.text });
                }
                if (!inline.canTrigger) {
                    this.viewer.triggerSpellCheck = false;
                }
                if (offset === count && inline.length === 1) {
                    this.unLinkFieldCharacter(inline);
                    lineWidget.children.splice(i, 1);
                    this.viewer.layout.reLayoutParagraph(lineWidget.paragraph, lineIndex, i);
                    this.addRemovedNodes(inline);
                }
                else {
                    var span = new TextElementBox();
                    span.characterFormat.copyFormat(inline.characterFormat);
                    span.text = inline.text.substr(indexInInline, 1);
                    inline.text = HelperMethods.remove(inline.text, indexInInline, 1);
                    this.viewer.layout.reLayoutParagraph(lineWidget.paragraph, lineIndex, i);
                    this.addRemovedNodes(span);
                }
                break;
            }
            count += inline.length;
        }
    };
    /**
     * Remove the current selected content or one character right of cursor.
     */
    Editor.prototype.delete = function () {
        this.removeEditRange = true;
        var selection = this.viewer.selection;
        if (selection.isEmpty) {
            this.singleDelete(selection, false);
        }
        else {
            // this.initComplexHistory('MultiSelection');
            // for (let i: number = 0; i < selection.selectionRanges.length; i++) {
            // let selectionRange: SelectionRange = selection.selectionRanges.getRange(i);
            this.initHistory('Delete');
            this.deleteSelectedContentInternal(selection, false, selection.start, selection.end);
            var textPosition = new TextPosition(selection.owner);
            this.setPositionForCurrentIndex(textPosition, selection.editPosition);
            selection.selectContent(textPosition, true);
            // if (this.viewer.owner.enableEditorHistory) {
            this.reLayout(selection);
            // }
            // this.updateSelectionRangeOffSet(selection.start, selection.end);
            // }
            // let textPosition: TextPosition = new TextPosition(selection.owner, this.viewer);
            // this.setPositionForCurrentIndex(textPosition,selection.editPosition);
            // selection.selectContent(textPosition, true);
            // if (!isNullOrUndefined(selection.currentHistoryInfo)) {
            //     this.updateComplexHistory();
            // } else {
            //     this.updateComplexWithoutHistory();
            // }
        }
        this.removeEditRange = false;
    };
    Editor.prototype.deleteEditElement = function (selection) {
        this.initHistory('Delete');
        this.deleteSelectedContentInternal(selection, false, selection.start, selection.end);
        var textPosition = new TextPosition(selection.owner);
        this.setPositionForCurrentIndex(textPosition, selection.editPosition);
        selection.selectContent(textPosition, true);
        this.reLayout(selection);
    };
    /**
     * Remove single character on right of cursor position
     * @param  {Selection} selection
     * @param  {boolean} isRedoing
     * @private
     */
    Editor.prototype.singleDelete = function (selection, isRedoing) {
        // tslint:disable-next-line:max-line-length
        var paragraph = selection.start.paragraph;
        var offset = selection.start.offset;
        var indexInInline = 0;
        var inlineObj = paragraph.getInline(selection.start.offset, indexInInline);
        var inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId !== -1 &&
            this.viewer.isListTextSelected && selection.contextType === 'List') {
            this.onApplyList(undefined);
            return;
        }
        if (!isNullOrUndefined(inline) && indexInInline === inline.length && !isNullOrUndefined(inline.nextNode)) {
            inline = inline.nextNode;
            indexInInline = 0;
        }
        if (!isNullOrUndefined(inline)) {
            var nextRenderedInline = undefined;
            var nextInline = selection.getNextValidElement(inline);
            if (nextInline instanceof ElementBox) {
                nextRenderedInline = nextInline;
            }
            if (!isNullOrUndefined(nextRenderedInline) && nextRenderedInline instanceof FieldElementBox
                && nextRenderedInline.fieldType === 0) { //Selects the entire field.
                inline = nextRenderedInline.fieldEnd;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 1);
                selection.end.setPositionParagraph(inline.line, offset);
                selection.fireSelectionChanged(true);
                return;
            }
            else if (inline !== nextRenderedInline) { //Updates the offset to delete next content.               
                inline = nextRenderedInline;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 0);
                if (inline instanceof FieldElementBox && inline.fieldType === 1) {
                    offset++;
                }
            }
        }
        if (inline instanceof EditRangeStartElementBox || inline instanceof EditRangeEndElementBox) {
            if ((inline.nextNode instanceof EditRangeEndElementBox && inline.editRangeEnd === inline.nextNode)
                || (inline.previousNode instanceof EditRangeStartElementBox
                    && inline.editRangeStart === inline.previousNode)) {
                return;
            }
            if (inline instanceof EditRangeStartElementBox) {
                inline = inline.nextNode;
                offset = inline.line.getOffset(inline, 0);
                paragraph = inline.line.paragraph;
            }
            if (inline.length === 1 && inline.nextNode instanceof EditRangeEndElementBox
                && inline.previousNode instanceof EditRangeStartElementBox) {
                var editStart = inline.previousNode;
                var editEnd = inline.nextNode;
                selection.start.setPositionParagraph(editStart.line, editStart.line.getOffset(editStart, 0));
                selection.end.setPositionParagraph(editEnd.line, editEnd.line.getOffset(editEnd, 0) + 1);
                this.deleteEditElement(selection);
                return;
            }
        }
        if (inline && (inline instanceof BookmarkElementBox && inline.bookmarkType === 0
            || inline.nextNode instanceof BookmarkElementBox)) {
            if (inline instanceof BookmarkElementBox) {
                inline = inline.nextNode;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 0);
            }
            if (inline.length === 1 && inline.nextNode instanceof BookmarkElementBox
                && inline.previousNode instanceof BookmarkElementBox) {
                var bookMarkBegin = inline.previousNode;
                var bookMarkEnd = inline.nextNode;
                selection.start.setPositionParagraph(bookMarkBegin.line, bookMarkBegin.line.getOffset(bookMarkBegin, 0));
                selection.end.setPositionParagraph(bookMarkEnd.line, bookMarkEnd.line.getOffset(bookMarkEnd, 0) + 1);
                this.deleteEditElement(selection);
                return;
            }
        }
        if (selection.start.currentWidget.isLastLine() && offset === this.viewer.selection.getLineLength(selection.start.currentWidget)) {
            if (paragraph.isInsideTable && isNullOrUndefined(paragraph.nextWidget)) {
                return;
            }
            var previousParagraph = undefined;
            var newParagraph = undefined;
            var nextParagraph = selection.getNextParagraphBlock(paragraph);
            if (isNullOrUndefined(nextParagraph)) {
                if (offset > 0) {
                    return;
                }
                else {
                    if (paragraph.previousWidget instanceof ParagraphWidget) {
                        previousParagraph = paragraph.previousWidget;
                    }
                    if (paragraph.previousWidget instanceof TableWidget) {
                        return;
                    }
                    if (isNullOrUndefined(previousParagraph)) {
                        return;
                        //Adds an empty paragraph, to ensure minimal content.
                    }
                }
            }
            if (!isRedoing) {
                this.initHistory('Delete');
            }
            if (paragraph.isEndsWithPageBreak) {
                var lastLine = paragraph.lastChild;
                var lastChild = lastLine.children[lastLine.children.length - 1];
                this.selection.start.setPositionForSelection(lastLine, lastChild, 0, this.selection.start.location);
            }
            var blockInfo = this.selection.getParagraphInfo(selection.start);
            selection.editPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            if (this.checkInsertPosition(selection)) {
                this.setPositionForHistory(selection.editPosition);
            }
            selection.owner.isShiftingEnabled = true;
            if (paragraph.isEmpty()) {
                this.removeBlock(paragraph);
                this.addRemovedNodes(paragraph);
                if (isNullOrUndefined(nextParagraph)) {
                    if (isNullOrUndefined(previousParagraph)) {
                        // selection.selectParagraphInternal(newParagraph, true, true);
                        var paraEndOffset = selection.getParagraphLength(newParagraph) + 1;
                        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                            this.updateHistoryPosition(selection.start, true);
                            //tslint:disable-next-line:max-line-length
                            this.editorHistory.currentBaseHistoryInfo.endPosition = this.selection.getHierarchicalIndex(newParagraph, paraEndOffset.toString());
                        }
                    }
                    else {
                        selection.selectParagraphInternal(previousParagraph, false);
                        this.setPositionForHistory();
                    }
                }
                else {
                    selection.selectParagraphInternal(nextParagraph, true);
                }
            }
            else {
                paragraph = paragraph.combineWidget(this.viewer);
                // tslint:disable-next-line:max-line-length
                var currentParagraph = this.splitParagraph(paragraph, paragraph.firstChild, 0, selection.start.currentWidget, selection.start.offset, true);
                this.deleteParagraphMark(currentParagraph, selection, 0);
                this.addRemovedNodes(paragraph);
                this.setPositionForCurrentIndex(selection.start, selection.editPosition);
                selection.selectContent(selection.start, true);
            }
            // if (!isRedoing) {
            this.reLayout(selection);
            // }
        }
        else {
            this.singleDeleteInternal(selection, isRedoing, paragraph);
        }
    };
    Editor.prototype.singleDeleteInternal = function (selection, isRedoing, paragraph) {
        if (!isRedoing) {
            selection.owner.isShiftingEnabled = true;
            this.initHistory('Delete');
        }
        if (this.checkInsertPosition(selection)) {
            this.updateHistoryPosition(selection.start, true);
            this.editorHistory.currentBaseHistoryInfo.endPosition = this.editorHistory.currentBaseHistoryInfo.insertPosition;
        }
        var paragraphInfo = this.selection.getParagraphInfo(selection.start);
        var lineWidget = selection.start.currentWidget;
        var removeOffset = selection.start.offset;
        var lineLength = selection.getLineLength(selection.start.currentWidget);
        if (removeOffset >= lineLength) {
            lineWidget = lineWidget.nextLine;
            removeOffset = removeOffset - lineLength;
        }
        this.removeAtOffset(lineWidget, selection, removeOffset);
        this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset, false);
        if (!isRedoing) {
            this.reLayout(selection);
        }
        else {
            this.fireContentChange();
        }
    };
    Editor.prototype.deleteParagraphMark = function (paragraph, selection, editAction) {
        if (isNullOrUndefined(paragraph.containerWidget)) {
            return;
        }
        paragraph = paragraph.combineWidget(this.viewer);
        var nextParagraph = selection.getNextParagraphBlock(paragraph);
        if (paragraph.isInsideTable && isNullOrUndefined(paragraph.nextWidget) || isNullOrUndefined(nextParagraph)) {
            return;
        }
        //BodyWidget
        var section = paragraph.containerWidget instanceof BodyWidget ? paragraph.containerWidget : undefined;
        var table = undefined;
        if (selection.getNextRenderedBlock(paragraph) instanceof TableWidget) {
            table = selection.getNextRenderedBlock(paragraph);
        }
        else {
            table = undefined;
        }
        if (nextParagraph.isInsideTable && !isNullOrUndefined(table) && table.contains(nextParagraph.associatedCell)) {
            if (editAction < 4) {
                // let nextSection: BodyWidget = table.containerWidget instanceof BodyWidget ? table.containerWidget : undefined;
                // if (section !== nextSection) {
                //     this.combineSection(section, selection, nextSection);
                // }                
                var offset = 0;
                this.removeBlock(paragraph);
                this.viewer.layout.clearListElementBox(nextParagraph);
                this.viewer.layout.clearListElementBox(paragraph);
                for (var i = paragraph.childWidgets.length - 1; i >= 0; i--) {
                    var line = paragraph.childWidgets[i];
                    for (var j = line.children.length - 1; j >= 0; j--) {
                        var element = line.children[j];
                        offset += element.length;
                        nextParagraph.firstChild.children.unshift(element);
                        element.line = nextParagraph.firstChild;
                        // this.layoutInlineCollection(false, 0, nextParagraph.inlines, inline);
                    }
                }
                this.viewer.layout.reLayoutParagraph(nextParagraph, 0, 0);
                if (offset > 0) {
                    selection.editPosition = this.selection.getHierarchicalIndex(nextParagraph, offset.toString());
                }
            }
        }
        else {
            if (editAction < 4) {
                // let nextSection: WSection = nextParagraph.section instanceof WSection ? nextParagraph.section as WSection : undefined;
                // if (section !== nextSection) {
                //     this.combineSection(section, selection, nextSection);
                // }
                var prevLength = paragraph.childWidgets.length - 1;
                var nextPara = nextParagraph.getSplitWidgets();
                nextParagraph = nextParagraph.combineWidget(this.viewer);
                this.viewer.layout.clearListElementBox(nextParagraph);
                this.viewer.layout.clearListElementBox(paragraph);
                this.updateEditPositionOnMerge(paragraph, nextParagraph);
                for (var i = 0; i < nextParagraph.childWidgets.length; i++) {
                    var inline = nextParagraph.childWidgets[i];
                    nextParagraph.childWidgets.splice(i, 1);
                    paragraph.childWidgets.push(inline);
                    inline.paragraph = paragraph;
                    i--;
                }
                if (nextParagraph.childWidgets.length === 0) {
                    nextParagraph.childWidgets.push(new LineWidget(nextParagraph));
                }
                this.removeBlock(nextParagraph);
                this.viewer.layout.reLayoutParagraph(paragraph, 0, 0);
                this.addRemovedNodes(nextParagraph);
            }
        }
    };
    Editor.prototype.updateEditPositionOnMerge = function (currentParagraph, nextParagraph) {
        if (this.viewer.selection.editPosition === this.selection.getHierarchicalIndex(nextParagraph, '0') &&
            nextParagraph.nextRenderedWidget === undefined) {
            // tslint:disable-next-line:max-line-length
            this.viewer.selection.editPosition = this.selection.getHierarchicalIndex(currentParagraph, this.viewer.selection.getLineLength(currentParagraph.lastChild).toString());
        }
    };
    Editor.prototype.checkEndPosition = function (selection) {
        return (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)
            && isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.endPosition));
    };
    Editor.prototype.checkInsertPosition = function (selection) {
        return (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)
            && isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition));
    };
    Editor.prototype.checkIsNotRedoing = function () {
        return this.viewer.owner.enableHistoryMode && !this.editorHistory.isRedoing;
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.deleteSelectedContentInternal = function (selection, isBackSpace, startPosition, endPosition) {
        var startPos = startPosition;
        var endPos = endPosition;
        if (!startPosition.isExistBefore(endPosition)) {
            startPos = endPosition;
            endPos = startPosition;
        }
        var blockInfo = this.selection.getParagraphInfo(startPos);
        selection.editPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        var skipBackSpace = false;
        if (isBackSpace && startPos.isInSameParagraph(endPos)) {
            //Handled specifically to skip removal of contents, if selection is only paragraph mark and next rendered block is table.
            if (startPos.offset < endPos.offset && startPos.offset === selection.getParagraphLength(endPos.paragraph)) {
                var nextBlock = selection.getNextRenderedBlock(startPos.paragraph);
                skipBackSpace = nextBlock instanceof TableWidget;
            }
            //Handled specifically to remove paragraph completely (Delete behavior), if the selected paragraph is empty.
            if (endPos.offset === 1 && endPos.offset > selection.getParagraphLength(endPos.paragraph)
                && !(endPos.paragraph.isInsideTable && isNullOrUndefined(endPos.paragraph.nextWidget))) {
                isBackSpace = false;
            }
        }
        if (!skipBackSpace) {
            selection.owner.isShiftingEnabled = true;
            if (this.checkInsertPosition(selection)) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = selection.editPosition;
            }
            var editAction = (isBackSpace ? 1 : 0);
            this.deleteSelectedContent(endPos.paragraph, selection, startPos, endPos, editAction);
        }
        return skipBackSpace;
    };
    /**
     * Init EditorHistory
     * @private
     */
    Editor.prototype.initHistory = function (action) {
        if (this.viewer.owner.enableHistoryMode) {
            this.editorHistory.initializeHistory(action);
        }
    };
    /**
     * Init Complex EditorHistory
     * @private
     */
    Editor.prototype.initComplexHistory = function (action) {
        if (this.viewer.owner.enableHistoryMode) {
            this.editorHistory.initComplexHistory(this.viewer.selection, action);
        }
    };
    //Insert Picture implementation starts
    /**
     * Insert image
     * @param  {string} base64String
     * @param  {number} width
     * @param  {number} height
     * @private
     */
    Editor.prototype.insertPicture = function (base64String, width, height) {
        var imageElementBox = new ImageElementBox(true);
        imageElementBox.imageString = base64String;
        imageElementBox.width = width;
        imageElementBox.height = height;
        this.insertPictureInternal(imageElementBox);
    };
    Editor.prototype.insertPictureInternal = function (imageElementBox) {
        var selection = this.viewer.selection;
        this.initHistory('InsertInline');
        this.fitImageToPage(selection, imageElementBox);
        this.insertInlineInSelection(selection, imageElementBox);
        this.reLayout(selection);
    };
    Editor.prototype.fitImageToPage = function (selection, imageElementBox) {
        var section = selection.start.paragraph.bodyWidget;
        var pageWidth = section.sectionFormat.pageWidth - section.sectionFormat.leftMargin - section.sectionFormat.rightMargin;
        var pageHeight = section.sectionFormat.pageHeight - section.sectionFormat.topMargin - section.sectionFormat.topMargin;
        //Resizes image to page size.
        if (imageElementBox.width > pageWidth) {
            imageElementBox.height = imageElementBox.height * pageWidth / imageElementBox.width;
            imageElementBox.width = pageWidth;
        }
        if (imageElementBox.height > pageHeight) {
            imageElementBox.width = imageElementBox.width * pageHeight / imageElementBox.height;
            imageElementBox.height = pageHeight;
        }
    };
    //Insert Picture implementation ends
    /**
     * @private
     */
    Editor.prototype.insertInlineInSelection = function (selection, elementBox) {
        if (this.checkIsNotRedoing()) {
            selection.owner.isShiftingEnabled = true;
        }
        if (!selection.isEmpty) {
            this.removeSelectedContents(selection);
        }
        this.updateInsertPosition();
        this.insertInlineInternal(elementBox);
        if (this.checkEndPosition(selection)) {
            this.updateHistoryPosition(selection.start, false);
        }
        this.fireContentChange();
    };
    /**
     * @private
     */
    Editor.prototype.onPortrait = function () {
        var sectionFormat = new WSectionFormat();
        var width = this.viewer.selection.sectionFormat.pageWidth;
        var height = this.viewer.selection.sectionFormat.pageHeight;
        if (width > height) {
            sectionFormat.pageWidth = height;
            sectionFormat.pageHeight = width;
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    };
    /**
     * @private
     */
    Editor.prototype.onLandscape = function () {
        var sectionFormat = new WSectionFormat();
        var width = this.viewer.selection.sectionFormat.pageWidth;
        var height = this.viewer.selection.sectionFormat.pageHeight;
        if (width < height) {
            sectionFormat.pageWidth = height;
            sectionFormat.pageHeight = width;
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    };
    Editor.prototype.copyValues = function () {
        var format = new WSectionFormat();
        format.bottomMargin = this.viewer.selection.sectionFormat.bottomMargin;
        format.topMargin = this.viewer.selection.sectionFormat.topMargin;
        format.leftMargin = this.viewer.selection.sectionFormat.leftMargin;
        format.rightMargin = this.viewer.selection.sectionFormat.rightMargin;
        format.pageHeight = this.viewer.selection.sectionFormat.pageHeight;
        format.pageWidth = this.viewer.selection.sectionFormat.pageWidth;
        format.footerDistance = this.viewer.selection.sectionFormat.footerDistance;
        format.headerDistance = this.viewer.selection.sectionFormat.headerDistance;
        return format;
    };
    /**
     * @private
     */
    Editor.prototype.changeMarginValue = function (property) {
        var sectionFormat = this.copyValues();
        if (property === 'lastCustomSetting' || property === 'normal') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 72;
            sectionFormat.rightMargin = 72;
        }
        else if (property === 'narrow') {
            sectionFormat.topMargin = 36;
            sectionFormat.bottomMargin = 36;
            sectionFormat.leftMargin = 36;
            sectionFormat.rightMargin = 36;
        }
        else if (property === 'moderate') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 54;
            sectionFormat.rightMargin = 54;
        }
        else if (property === 'wide') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 144;
            sectionFormat.rightMargin = 144;
        }
        else if (property === 'mirrored') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 90;
            sectionFormat.rightMargin = 72;
        }
        else if (property === 'office2003Default') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 90;
            sectionFormat.rightMargin = 90;
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    };
    /**
     * @private
     */
    Editor.prototype.onPaperSize = function (property) {
        var sectionFormat = this.copyValues();
        var width = this.viewer.selection.sectionFormat.pageWidth;
        var height = this.viewer.selection.sectionFormat.pageHeight;
        if (property === 'letter') {
            if (width < height) {
                sectionFormat.pageWidth = 611.9;
                sectionFormat.pageHeight = 791.9;
            }
            else {
                sectionFormat.pageWidth = 791.9;
                sectionFormat.pageHeight = 611.9;
            }
        }
        else if (property === 'tabloid') {
            if (width < height) {
                sectionFormat.pageWidth = 791.9;
                sectionFormat.pageHeight = 1223.9;
            }
            else {
                sectionFormat.pageWidth = 1223.9;
                sectionFormat.pageHeight = 791.9;
            }
        }
        else if (property === 'legal') {
            if (width < height) {
                sectionFormat.pageWidth = 611.9;
                sectionFormat.pageHeight = 1007.9;
            }
            else {
                sectionFormat.pageWidth = 1007.9;
                sectionFormat.pageHeight = 611.9;
            }
        }
        else if (property === 'statement') {
            if (width < height) {
                sectionFormat.pageWidth = 396;
                sectionFormat.pageHeight = 611.9;
            }
            else {
                sectionFormat.pageWidth = 611.9;
                sectionFormat.pageHeight = 396;
            }
        }
        else if (property === 'executive') {
            if (width < height) {
                sectionFormat.pageWidth = 521.9;
                sectionFormat.pageHeight = 755.9;
            }
            else {
                sectionFormat.pageWidth = 755.9;
                sectionFormat.pageHeight = 521.9;
            }
        }
        else if (property === 'a3') {
            if (width < height) {
                sectionFormat.pageWidth = 841.8;
                sectionFormat.pageHeight = 1190.4;
            }
            else {
                sectionFormat.pageWidth = 1190.4;
                sectionFormat.pageHeight = 841.8;
            }
        }
        else if (property === 'a4') {
            if (width < height) {
                sectionFormat.pageWidth = 595.2;
                sectionFormat.pageHeight = 841.8;
            }
            else {
                sectionFormat.pageWidth = 841.8;
                sectionFormat.pageHeight = 595.2;
            }
        }
        else if (property === 'a5') {
            if (width < height) {
                sectionFormat.pageWidth = 419.5;
                sectionFormat.pageHeight = 595.2;
            }
            else {
                sectionFormat.pageWidth = 595.2;
                sectionFormat.pageHeight = 419.5;
            }
        }
        else if (property === 'b4') {
            if (width < height) {
                sectionFormat.pageWidth = 728.4;
                sectionFormat.pageHeight = 1031.7;
            }
            else {
                sectionFormat.pageWidth = 1031.7;
                sectionFormat.pageHeight = 728.4;
            }
        }
        else if (property === 'b5') {
            if (width < height) {
                sectionFormat.pageWidth = 515.8;
                sectionFormat.pageHeight = 728.4;
            }
            else {
                sectionFormat.pageWidth = 728.4;
                sectionFormat.pageHeight = 515.8;
            }
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    };
    //Update List Items
    /**
     * @private
     */
    Editor.prototype.updateListItemsTillEnd = function (blockAdv, updateNextBlockList) {
        var block = updateNextBlockList ? this.viewer.selection.getNextRenderedBlock(blockAdv) : blockAdv;
        while (!isNullOrUndefined(block) && !this.viewer.isTextInput) {
            //Updates the list value of the rendered paragraph. 
            this.updateRenderedListItems(block);
            block = block.getSplitWidgets().pop().nextRenderedWidget;
        }
    };
    /**
     * @private
     */
    Editor.prototype.updateWholeListItems = function (block) {
        this.viewer.renderedLists.clear();
        this.viewer.renderedLevelOverrides = [];
        var sectionIndex = block.bodyWidget.index;
        var currentBlock;
        for (var j = 0; j < this.viewer.pages.length; j++) {
            var page = this.viewer.pages[j];
            if (page.bodyWidgets[0].index === sectionIndex) {
                currentBlock = page.bodyWidgets[0].firstChild;
                if (!isNullOrUndefined(currentBlock)) {
                    break;
                }
            }
        }
        var isListUpdated = false;
        do {
            isListUpdated = this.updateListItems(currentBlock, block);
            if (isListUpdated) {
                break;
            }
            currentBlock = currentBlock.getSplitWidgets().pop().nextRenderedWidget;
        } while (currentBlock);
    };
    Editor.prototype.updateListItems = function (blockAdv, block) {
        var isListUpdated = false;
        if (blockAdv instanceof ParagraphWidget) {
            isListUpdated = this.updateListItemsForPara(blockAdv, block);
        }
        else {
            isListUpdated = this.updateListItemsForTable(blockAdv, block);
        }
        return isListUpdated;
    };
    Editor.prototype.updateListItemsForTable = function (table, block) {
        if (block instanceof TableWidget && table.equals(block)) {
            return true;
        }
        var row = table.firstChild;
        do {
            var isListUpdated = this.updateListItemsForRow(row, block);
            if (isListUpdated) {
                return true;
            }
            row = row.getSplitWidgets().pop().nextRenderedWidget;
        } while (row);
        return false;
    };
    Editor.prototype.updateListItemsForRow = function (row, block) {
        if (block.isInsideTable && row.childWidgets.indexOf(this.viewer.selection.getContainerCell(block.associatedCell)) !== -1) {
            //Returns as list updated, inorder to start list numbering from first list paragraph of this row.
            return true;
        }
        var cell = row.firstChild;
        do {
            this.updateListItemsForCell(cell, block);
            cell = cell.nextRenderedWidget;
        } while (cell);
        return false;
    };
    Editor.prototype.updateListItemsForCell = function (cell, block) {
        if (cell.childWidgets.length === 0) {
            return;
        }
        var currentBlock = cell.firstChild;
        do {
            this.updateListItems(currentBlock, block);
            currentBlock = currentBlock.getSplitWidgets().pop().nextRenderedWidget;
        } while (currentBlock);
    };
    // public abstract updateListParagraphs(): void;
    /**
     * @private
     */
    Editor.prototype.updateRenderedListItems = function (block) {
        if (block instanceof ParagraphWidget) {
            this.updateRenderedListItemsForPara(block);
        }
        else {
            this.updateRenderedListItemsForTable(block);
        }
    };
    Editor.prototype.updateRenderedListItemsForTable = function (table) {
        var row = table.firstChild;
        do {
            this.updateRenderedListItemsForRow(row);
            row = row.getSplitWidgets().pop().nextRenderedWidget;
        } while (row);
    };
    Editor.prototype.updateRenderedListItemsForRow = function (row) {
        var cell = row.firstChild;
        do {
            this.updateRenderedListItemsForCell(cell);
            cell = cell.nextRenderedWidget;
        } while (cell);
    };
    Editor.prototype.updateRenderedListItemsForCell = function (cell) {
        if (cell.childWidgets.length === 0) {
            return;
        }
        var currentBlock = cell.firstChild;
        do {
            this.updateRenderedListItems(currentBlock);
            currentBlock = currentBlock.getSplitWidgets().pop().nextRenderedWidget;
        } while (currentBlock);
    };
    Editor.prototype.updateListItemsForPara = function (paragraph, block) {
        if (paragraph.equals(block)) {
            return true;
        }
        else {
            var currentList = undefined;
            var levelNumber = 0;
            if (!isNullOrUndefined(paragraph.paragraphFormat) && !isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
                currentList = this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId);
                levelNumber = paragraph.paragraphFormat.listFormat.listLevelNumber;
            }
            if (!isNullOrUndefined(currentList) && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId))
                && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId).levels[levelNumber])) {
                var currentListLevel = this.viewer.layout.getListLevel(currentList, levelNumber);
                //Updates the list numbering from document start for reLayouting.
                this.updateListNumber(currentListLevel, paragraph, false);
            }
        }
        return false;
    };
    Editor.prototype.updateRenderedListItemsForPara = function (paragraph) {
        if (!isNullOrUndefined(this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId))) {
            var currentList = this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId);
            var listLevelNumber = paragraph.paragraphFormat.listFormat.listLevelNumber;
            if (!isNullOrUndefined(currentList) && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId))
                // tslint:disable-next-line:max-line-length
                && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId).levels[paragraph.paragraphFormat.listFormat.listLevelNumber])) {
                var currentListLevel = this.viewer.layout.getListLevel(currentList, listLevelNumber);
                //Updates the list numbering from document start for reLayouting.
                this.updateListNumber(currentListLevel, paragraph, true);
            }
        }
    };
    Editor.prototype.updateListNumber = function (currentListLevel, paragraph, isUpdate) {
        if (currentListLevel.listLevelPattern !== 'Bullet') {
            var element = undefined;
            if (paragraph.childWidgets.length > 0) {
                var lineWidget = paragraph.childWidgets[0];
                if (lineWidget.children.length > 0) {
                    if (paragraph.paragraphFormat.bidi) {
                        element = lineWidget.children[lineWidget.children.length - 1];
                    }
                    else {
                        element = lineWidget.children[0];
                    }
                }
            }
            if (!isNullOrUndefined(element) && element instanceof ListTextElementBox) {
                var text = this.viewer.layout.getListNumber(paragraph.paragraphFormat.listFormat);
                if (isUpdate) {
                    element.text = text;
                }
            }
        }
    };
    /**
     * Get offset value to update in selection
     * @private
     */
    Editor.prototype.getOffsetValue = function (selection) {
        if (this.startParagraph) {
            var lineInfo = selection.getLineInfoBasedOnParagraph(this.startParagraph, this.startOffset);
            selection.start.setPositionFromLine(lineInfo.line, lineInfo.offset);
        }
        selection.start.updatePhysicalPosition(true);
        if (selection.isEmpty) {
            selection.end.setPositionInternal(selection.start);
        }
        else {
            if (this.endParagraph) {
                var lineInfo = selection.getLineInfoBasedOnParagraph(this.endParagraph, this.endOffset);
                selection.end.setPositionFromLine(lineInfo.line, lineInfo.offset);
            }
            selection.end.updatePhysicalPosition(true);
        }
    };
    /**
     * @private
     */
    Editor.prototype.setPositionParagraph = function (paragraph, offset, skipSelectionChange) {
        var selection = this.viewer.selection;
        var lineInfo = selection.getLineInfoBasedOnParagraph(paragraph, offset);
        selection.start.setPositionFromLine(lineInfo.line, lineInfo.offset);
        selection.end.setPositionInternal(selection.start);
        if (!skipSelectionChange) {
            selection.fireSelectionChanged(true);
        }
    };
    /**
     * @private
     */
    Editor.prototype.setPositionForCurrentIndex = function (textPosition, editPosition) {
        var blockInfo = this.selection.getParagraph({ index: editPosition });
        var lineInfo = this.selection.getLineInfoBasedOnParagraph(blockInfo.paragraph, blockInfo.offset);
        textPosition.setPositionForLineWidget(lineInfo.line, lineInfo.offset);
    };
    /**
     * @private
     */
    Editor.prototype.insertPageNumber = function (numberFormat) {
        if (isNullOrUndefined(numberFormat)) {
            numberFormat = '';
        }
        else {
            numberFormat = ' \\*' + numberFormat;
        }
        var fieldCode = 'PAGE ' + numberFormat + ' \\* MERGEFORMAT';
        this.createFields(fieldCode);
    };
    /**
     * @private
     */
    Editor.prototype.insertPageCount = function (numberFormat) {
        if (isNullOrUndefined(numberFormat)) {
            numberFormat = '';
        }
        else {
            numberFormat = ' \*' + numberFormat;
        }
        var fieldCode = 'NUMPAGES ' + numberFormat + ' \* MERGEFORMAT';
        this.createFields(fieldCode);
    };
    Editor.prototype.createFields = function (fieldCode) {
        var paragraph = new ParagraphWidget();
        var line = new LineWidget(paragraph);
        var fieldBegin = new FieldElementBox(0);
        line.children.push(fieldBegin);
        var fieldtext = new FieldTextElementBox();
        fieldtext.fieldBegin = fieldBegin;
        fieldtext.text = '1';
        var text = new TextElementBox();
        text.text = fieldCode;
        line.children.push(text);
        var fieldSeparator = new FieldElementBox(2);
        fieldSeparator.fieldBegin = fieldBegin;
        fieldBegin.fieldSeparator = fieldSeparator;
        line.children.push(fieldSeparator);
        line.children.push(fieldtext);
        var fieldEnd = new FieldElementBox(1);
        fieldEnd.fieldBegin = fieldBegin;
        fieldEnd.fieldSeparator = fieldSeparator;
        fieldSeparator.fieldEnd = fieldEnd;
        fieldBegin.fieldEnd = fieldEnd;
        line.children.push(fieldEnd);
        fieldBegin.line = line;
        paragraph.childWidgets.push(line);
        var widgets = [];
        widgets.push(paragraph);
        this.viewer.fields.push(fieldBegin);
        this.pasteContentsInternal(widgets);
    };
    /**
     * Insert Bookmark at current selection range
     * @param  {string} name - Name of bookmark
     */
    Editor.prototype.insertBookmark = function (name) {
        var bookmark = new BookmarkElementBox(0);
        bookmark.name = name;
        var bookmarkEnd = new BookmarkElementBox(1);
        bookmarkEnd.name = name;
        bookmark.reference = bookmarkEnd;
        bookmarkEnd.reference = bookmark;
        this.initComplexHistory('InsertBookmark');
        this.insertElements([bookmarkEnd], [bookmark]);
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistoryInternal();
        }
        if (this.viewer.owner.enableHeaderAndFooter) {
            this.updateHeaderFooterWidget();
        }
        this.viewer.bookmarks.add(name, bookmark);
        this.selection.start.setPositionForSelection(bookmark.line, bookmark, 1, this.selection.start.location);
        this.selection.end.setPositionForSelection(bookmarkEnd.line, bookmarkEnd, 0, this.selection.end.location);
        this.selection.fireSelectionChanged(true);
        this.fireContentChange();
    };
    /**
     * @private
     */
    Editor.prototype.deleteBookmark = function (bookmarkName) {
        var bookmarks = this.viewer.bookmarks;
        var bookmark = bookmarks.get(bookmarkName);
        if (bookmark instanceof BookmarkElementBox) {
            var bookmarkEnd = bookmark.reference;
            this.initHistory('DeleteBookmark');
            if (this.editorHistory) {
                this.editorHistory.currentBaseHistoryInfo.setBookmarkInfo(bookmark);
                this.editorHistory.updateHistory();
            }
            this.deleteBookmarkInternal(bookmark);
        }
        this.fireContentChange();
    };
    /**
     * @private
     */
    Editor.prototype.deleteBookmarkInternal = function (bookmark) {
        this.viewer.bookmarks.remove(bookmark.name);
        bookmark.line.children.splice(bookmark.indexInOwner, 1);
        bookmark.reference.line.children.splice(bookmark.reference.indexInOwner, 1);
        // Remove bookmark from header footer collections
        var paragraph = bookmark.line.paragraph;
        if (bookmark.line.paragraph.isInHeaderFooter) {
            var headerFooterWidget = undefined;
            if (paragraph.containerWidget instanceof TableCellWidget) {
                // tslint:disable-next-line:max-line-length
                headerFooterWidget = paragraph.containerWidget.getContainerTable().containerWidget;
            }
            else if (paragraph.containerWidget instanceof HeaderFooterWidget) {
                headerFooterWidget = paragraph.containerWidget;
            }
            this.updateHeaderFooterWidget(headerFooterWidget);
        }
    };
    /**
     * @private
     */
    Editor.prototype.getSelectionInfo = function () {
        var start = this.selection.start;
        var end = this.selection.end;
        if (!this.selection.isForward) {
            start = this.selection.end;
            end = this.selection.start;
        }
        if (!(end.offset === this.selection.getLineLength(end.currentWidget) + 1
            && this.selection.isParagraphLastLine(end.currentWidget))) {
            end.offset += 1;
        }
        var blockInfo = this.selection.getParagraphInfo(start);
        var startIndex = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        blockInfo = this.selection.getParagraphInfo(end);
        var endIndex = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        return { 'start': startIndex, 'end': endIndex };
    };
    /**
     * @private
     */
    Editor.prototype.insertElements = function (endElements, startElements) {
        var info = this.getSelectionInfo();
        if (!isNullOrUndefined(startElements)) {
            this.insertElementsInternal(this.selection.getTextPosBasedOnLogicalIndex(info.start), startElements);
        }
        if (!isNullOrUndefined(endElements)) {
            this.insertElementsInternal(this.selection.getTextPosBasedOnLogicalIndex(info.end), endElements);
        }
    };
    /**
     * @private
     */
    Editor.prototype.insertElementsInternal = function (position, elements, isRelayout) {
        this.selection.selectPosition(position, position);
        this.initHistory('InsertElements');
        this.updateInsertPosition();
        var indexInInline = 0;
        var paragraphInfo = this.selection.getParagraphInfo(this.selection.start);
        if (this.selection.start.paragraph.isEmpty()) {
            var paragraph = this.selection.start.paragraph;
            paragraph.childWidgets[0].children.push(elements[0]);
            elements[0].line = paragraph.childWidgets[0];
            elements[0].linkFieldCharacter(this.viewer);
            this.viewer.layout.reLayoutParagraph(paragraph, 0, 0);
            this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + length, true);
            position.setPositionForSelection(elements[0].line, elements[0], elements[0].length, this.selection.start.location);
            this.selection.selectPosition(position, position);
        }
        else {
            var inlineObj = this.selection.start.currentWidget.getInline(this.viewer.selection.start.offset, indexInInline);
            var curInline = inlineObj.element;
            indexInInline = inlineObj.index;
            var firstElement = elements[0];
            this.insertElementInternal(curInline, firstElement, indexInInline, true);
            var index = firstElement.indexInOwner;
            var lastElement = firstElement;
            for (var i = 1; i < elements.length; i++) {
                lastElement = elements[i];
                firstElement.line.children.splice(index + i, 0, lastElement);
            }
            position.setPositionForSelection(lastElement.line, lastElement, lastElement.length, this.selection.start.location);
            this.selection.selectPosition(position, position);
        }
        if (this.editorHistory) {
            if (this.checkEndPosition()) {
                this.updateHistoryPosition(this.selection.start, false);
            }
            this.editorHistory.updateHistory();
        }
    };
    /**
     * @private
     */
    Editor.prototype.getCommentElementBox = function (index) {
        var position = index.split(';');
        var comment = this.viewer.comments[parseInt(position[1], 10)];
        if (position.length > 2 && position[2] !== '') {
            return comment.replyComments[parseInt(position[2], 10)];
        }
        return comment;
    };
    /**
     * @private
     */
    Editor.prototype.getBlock = function (position) {
        var bodyWidget = this.selection.getBodyWidget(position);
        return this.getBlockInternal(bodyWidget, position);
    };
    /**
     * Return Block relative to position
     * @private
     */
    Editor.prototype.getBlockInternal = function (widget, position) {
        if (position.index === '' || isNullOrUndefined(position)) {
            return undefined;
        }
        var index = position.index.indexOf(';');
        var value = position.index.substring(0, index);
        position.index = position.index.substring(index).replace(';', '');
        var node = widget;
        // if (node instanceof WSection && value === 'HF') {
        //     //Gets the block in Header footers.
        //     let blockObj: BlockInfo = this.getBlock((node as WSection).headerFooters, position);
        // tslint:disable-next-line:max-line-length
        //     return { 'node': (!isNullOrUndefined(blockObj)) ? blockObj.node : undefined, 'position': (!isNullOrUndefined(blockObj)) ? blockObj.position : undefined };
        // }
        index = parseInt(value, 10);
        var childWidget = this.selection.getBlockByIndex(widget, index);
        if (childWidget) {
            var child = childWidget;
            if (position.index.indexOf(';') >= 0) {
                if (child instanceof ParagraphWidget) {
                    if (position.index.indexOf(';') >= 0) {
                        position.index = '0';
                    }
                    return { 'node': child, 'position': position };
                }
                if (child instanceof Widget) {
                    var blockObj = this.getBlockInternal(child, position);
                    // tslint:disable-next-line:max-line-length
                    return { 'node': (!isNullOrUndefined(blockObj)) ? blockObj.node : undefined, 'position': (!isNullOrUndefined(blockObj)) ? blockObj.position : undefined };
                }
            }
            else {
                return { 'node': child, 'position': position };
            }
        }
        else {
            return { 'node': node, 'position': position };
        }
        return { 'node': node, 'position': position };
    };
    /**
     * @private
     */
    Editor.prototype.updateHistoryPosition = function (position, isInsertPosition) {
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            var hierarchicalIndex = void 0;
            if (position instanceof TextPosition) {
                var blockInfo = this.selection.getParagraphInfo(position);
                hierarchicalIndex = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            }
            else {
                hierarchicalIndex = position;
            }
            if (isInsertPosition) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = hierarchicalIndex;
            }
            else {
                this.editorHistory.currentBaseHistoryInfo.endPosition = hierarchicalIndex;
            }
        }
    };
    /**
     * Applies the borders based on given settings.
     * @param {BorderSettings} settings
     */
    Editor.prototype.applyBorders = function (settings) {
        this.initHistory('Borders');
        var startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        var endPos = this.selection.isForward ? this.selection.end : this.selection.start;
        var table = startPos.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.viewer);
        if (this.editorHistory) {
            var clonedTable = this.cloneTableToHistoryInfo(table);
        }
        var startCell = startPos.paragraph.associatedCell;
        var endCell = endPos.paragraph.associatedCell;
        var cells;
        var border = this.getBorder(settings.borderColor, settings.lineWidth, settings.borderStyle);
        if (this.selection.isEmpty) {
            //Apply borders for current selected cell initially.                    
            if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                settings.type === 'LeftBorder') {
                endCell.cellFormat.borders.left.copyFormat(border);
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                settings.type === 'TopBorder') {
                endCell.cellFormat.borders.top.copyFormat(border);
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                settings.type === 'RightBorder') {
                endCell.cellFormat.borders.right.copyFormat(border);
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                settings.type === 'BottomBorder') {
                endCell.cellFormat.borders.bottom.copyFormat(border);
            }
            if (settings.type === 'AllBorders' || settings.type === 'InsideBorders'
                || settings.type === 'InsideVerticalBorder') {
                endCell.cellFormat.borders.vertical.copyFormat(border);
            }
            if (settings.type === 'AllBorders' || settings.type === 'InsideBorders'
                || settings.type === 'InsideHorizontalBorder') {
                endCell.cellFormat.borders.horizontal.copyFormat(border);
            }
            if (settings.type === 'NoBorder') {
                this.clearAllBorderValues(endCell.cellFormat.borders);
            }
        }
        else {
            if (settings.type === 'OutsideBorders' || settings.type === 'TopBorder') {
                var selectedCell = this.getTopBorderCellsOnSelection();
                for (var i = 0; i < selectedCell.length; i++) {
                    selectedCell[i].cellFormat.borders.top.copyFormat(border);
                }
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'LeftBorder') {
                var selectedCell = this.getLeftBorderCellsOnSelection();
                for (var i = 0; i < selectedCell.length; i++) {
                    selectedCell[i].cellFormat.borders.left.copyFormat(border);
                }
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'RightBorder') {
                var selectedCell = this.getRightBorderCellsOnSelection();
                for (var i = 0; i < selectedCell.length; i++) {
                    selectedCell[i].cellFormat.borders.right.copyFormat(border);
                }
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'BottomBorder') {
                var selectedCell = this.getBottomBorderCellsOnSelection();
                for (var i = 0; i < selectedCell.length; i++) {
                    selectedCell[i].cellFormat.borders.bottom.copyFormat(border);
                }
            }
        }
        //Apply Only borders property to selected cells      
        if (settings.type === 'BottomBorder' || settings.type === 'AllBorders' || settings.type === 'OutsideBorders'
            || settings.type === 'NoBorder') {
            cells = this.getAdjacentCellToApplyBottomBorder();
            for (var i = 0; i < cells.length; i++) {
                var cell = cells[i];
                if (settings.type === 'NoBorder') {
                    cell.cellFormat.borders.top.copyFormat(this.clearBorder());
                }
                else {
                    cell.cellFormat.borders.top.copyFormat(border);
                }
            }
        }
        if (settings.type === 'AllBorders' || settings.type === 'OutsideBorders' || settings.type === 'RightBorder'
            || settings.type === 'NoBorder') {
            cells = this.getAdjacentCellToApplyRightBorder();
            for (var i = 0; i < cells.length; i++) {
                var cell = cells[i];
                if (settings.type === 'NoBorder') {
                    cell.cellFormat.borders.left.copyFormat(this.clearBorder());
                }
                else {
                    cell.cellFormat.borders.left.copyFormat(border);
                }
            }
        }
        if (settings.type === 'AllBorders' || settings.type === 'NoBorder') {
            this.applyAllBorders(border, settings.type);
        }
        if (settings.type === 'InsideBorders' || settings.type === 'InsideVerticalBorder'
            || settings.type === 'InsideHorizontalBorder' || settings.type === 'NoBorder') {
            this.applyInsideBorders(border, settings.type, table);
        }
        this.updateGridForTableDialog(table, false);
        this.reLayout(this.selection, false);
        this.editorHistory.updateHistory();
    };
    Editor.prototype.applyAllBorders = function (border, borderType) {
        var cells = this.selection.getSelectedCells();
        for (var i = 0; i < cells.length; i++) {
            if (borderType === 'NoBorder') {
                cells[i].cellFormat.borders.left.copyFormat(this.clearBorder());
                cells[i].cellFormat.borders.right.copyFormat(this.clearBorder());
                cells[i].cellFormat.borders.top.copyFormat(this.clearBorder());
                cells[i].cellFormat.borders.bottom.copyFormat(this.clearBorder());
            }
            else {
                cells[i].cellFormat.borders.left.copyFormat(border);
                cells[i].cellFormat.borders.right.copyFormat(border);
                cells[i].cellFormat.borders.top.copyFormat(border);
                cells[i].cellFormat.borders.bottom.copyFormat(border);
            }
        }
    };
    Editor.prototype.applyInsideBorders = function (border, borderType, table) {
        var cells = this.selection.getSelectedCells();
        for (var i = 0; i < cells.length; i++) {
            var cell = cells[i];
            var isLastSelectedRow = cell.ownerRow === cells[cells.length - 1].ownerRow;
            var isLastRightCell = (cell.columnIndex + cell.cellFormat.columnSpan - 1) === cells[cells.length - 1].columnIndex;
            if (borderType === 'NoBorder') {
                cell.cellFormat.borders.right.copyFormat(this.clearBorder());
                cell.cellFormat.borders.bottom.copyFormat(this.clearBorder());
            }
            else {
                if (!isLastRightCell && borderType !== 'InsideHorizontalBorder') {
                    cell.cellFormat.borders.right.copyFormat(border);
                }
                if (!isLastSelectedRow && borderType !== 'InsideVerticalBorder') {
                    cell.cellFormat.borders.bottom.copyFormat(border);
                }
            }
            if (!isLastSelectedRow && borderType !== 'InsideVerticalBorder') {
                // Apply adjacent bottom borders.
                var nextRowIndex = cell.ownerRow.rowIndex + cell.cellFormat.rowSpan;
                var nextRow = table.childWidgets[nextRowIndex];
                if (nextRow) {
                    var selectedCells = this.getAdjacentBottomBorderOnEmptyCells(nextRow, cell, true);
                    for (var j = 0; j < selectedCells.length; j++) {
                        if (borderType === 'NoBorder') {
                            selectedCells[j].cellFormat.borders.top.copyFormat(this.clearBorder());
                        }
                        else {
                            selectedCells[j].cellFormat.borders.top.copyFormat(border);
                        }
                    }
                }
            }
            if (!isLastRightCell && borderType !== 'InsideHorizontalBorder') {
                // Apply adjacent right borders.
                var rightBorderCells = this.getSelectedCellsNextWidgets(cell, table);
                for (var k = 0; k < rightBorderCells.length; k++) {
                    if (borderType === 'NoBorder') {
                        rightBorderCells[k].cellFormat.borders.left.copyFormat(this.clearBorder());
                    }
                    else {
                        rightBorderCells[k].cellFormat.borders.left.copyFormat(border);
                    }
                }
            }
        }
    };
    /**
     * @private
     */
    Editor.prototype.getTopBorderCellsOnSelection = function () {
        var startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        var startCell = startPos.paragraph.associatedCell;
        var topBorderCells = [];
        var cells = this.selection.getSelectedCells();
        for (var i = 0; i < cells.length; i++) {
            if (cells[i].ownerRow === startCell.ownerRow) {
                topBorderCells.push(cells[i]);
            }
        }
        return topBorderCells;
    };
    /**
     * @private
     */
    Editor.prototype.getLeftBorderCellsOnSelection = function () {
        var startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        var startCell = startPos.paragraph.associatedCell;
        var cells = this.selection.getSelectedCells();
        var leftBorderCells = [];
        for (var i = 0; i < cells.length; i++) {
            if (cells[i].columnIndex === startCell.columnIndex) {
                leftBorderCells.push(cells[i]);
            }
        }
        return leftBorderCells;
    };
    /**
     * @private
     */
    Editor.prototype.getRightBorderCellsOnSelection = function () {
        var cells = this.selection.getSelectedCells();
        var rightBorderCells = [];
        for (var i = 0; i < cells.length; i++) {
            if ((cells[i].columnIndex + cells[i].cellFormat.columnSpan - 1) === cells[cells.length - 1].columnIndex) {
                rightBorderCells.push(cells[i]);
            }
        }
        return rightBorderCells;
    };
    /**
     * @private
     */
    Editor.prototype.getBottomBorderCellsOnSelection = function () {
        var endPos = this.selection.isForward ? this.selection.end : this.selection.start;
        var endCell = endPos.paragraph.associatedCell;
        var cells = this.selection.getSelectedCells();
        var bottomBorderCells = [];
        for (var i = 0; i < cells.length; i++) {
            if (cells[i].ownerRow === endCell.ownerRow) {
                bottomBorderCells.push(cells[i]);
            }
        }
        return bottomBorderCells;
    };
    /**
     * @private
     */
    Editor.prototype.clearAllBorderValues = function (borders) {
        var border = this.clearBorder();
        borders.bottom.copyFormat(border);
        borders.left.copyFormat(border);
        borders.right.copyFormat(border);
        borders.top.copyFormat(border);
        borders.vertical.copyFormat(border);
        borders.horizontal.copyFormat(border);
    };
    Editor.prototype.clearBorder = function () {
        var border = new WBorder();
        border.lineStyle = 'Cleared';
        return border;
    };
    /**
     * @private
     */
    Editor.prototype.getAdjacentCellToApplyBottomBorder = function () {
        var cells = [];
        var startPos = this.selection.start;
        var endPos = this.selection.end;
        if (!this.selection.isForward) {
            startPos = this.selection.end;
            endPos = this.selection.start;
        }
        var table = startPos.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.viewer);
        var startCell = startPos.paragraph.associatedCell;
        var endCell = endPos.paragraph.associatedCell;
        var nextRowIndex = endCell.ownerRow.rowIndex + endCell.cellFormat.rowSpan;
        var nextRow = table.childWidgets[nextRowIndex];
        if (nextRow) {
            if (endCell.cellFormat.columnSpan > 1) {
                for (var i = endCell.columnIndex; i < endCell.columnIndex + endCell.cellFormat.columnSpan; i++) {
                    cells.push(nextRow.childWidgets[i]);
                }
            }
            else {
                cells = this.getAdjacentBottomBorderOnEmptyCells(nextRow, endCell);
                if (!this.selection.isEmpty) {
                    for (var i = 0; i < nextRow.childWidgets.length; i++) {
                        var nextCellColIndex = nextRow.childWidgets[i].columnIndex;
                        if (nextCellColIndex >= startCell.columnIndex && nextCellColIndex <= endCell.columnIndex) {
                            cells.push(nextRow.childWidgets[i]);
                        }
                    }
                }
            }
        }
        return cells;
    };
    Editor.prototype.getAdjacentBottomBorderOnEmptyCells = function (nextRow, cell, isSingleCell) {
        var cells = [];
        if (cell.cellFormat.columnSpan > 1) {
            for (var i = cell.columnIndex; i < cell.columnIndex + cell.cellFormat.columnSpan; i++) {
                cells.push(nextRow.childWidgets[i]);
            }
        }
        else {
            if (this.selection.isEmpty || isSingleCell) {
                for (var i = 0; i < nextRow.childWidgets.length; i++) {
                    if (nextRow.childWidgets[i].columnIndex === cell.columnIndex) {
                        cells.push(nextRow.childWidgets[i]);
                    }
                }
            }
        }
        return cells;
    };
    /**
     * @private
     */
    Editor.prototype.getAdjacentCellToApplyRightBorder = function () {
        var cells = [];
        var startPosIn = this.selection.start;
        var endPosIn = this.selection.end;
        if (!this.selection.isForward) {
            startPosIn = this.selection.end;
            endPosIn = this.selection.start;
        }
        var table = startPosIn.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.viewer);
        var startCell = startPosIn.paragraph.associatedCell;
        var endCell = endPosIn.paragraph.associatedCell;
        if (this.selection.isEmpty) {
            var selectedCell = startPosIn.paragraph.associatedCell;
            cells = this.getSelectedCellsNextWidgets(selectedCell, table);
        }
        else {
            // tslint:disable-next-line:max-line-length
            var selectedCells = this.getRightBorderCellsOnSelection();
            for (var i = 0; i < selectedCells.length; i++) {
                var cell = selectedCells[i];
                cells = cells.concat(this.getSelectedCellsNextWidgets(cell, table));
            }
        }
        return cells;
    };
    Editor.prototype.getSelectedCellsNextWidgets = function (selectedCell, table) {
        var cells = [];
        if (selectedCell.nextWidget) {
            cells.push(selectedCell.nextWidget);
        }
        if (selectedCell.cellFormat.rowSpan > 1) {
            var nextRowIndex = selectedCell.ownerRow.rowIndex + selectedCell.cellFormat.rowSpan;
            for (var i = selectedCell.ownerRow.rowIndex + 1; i < nextRowIndex; i++) {
                var nextRow = table.childWidgets[i];
                if (nextRow) {
                    for (var j = 0; j < nextRow.childWidgets.length; j++) {
                        if (nextRow.childWidgets[j].columnIndex ===
                            selectedCell.nextWidget.columnIndex) {
                            cells.push(nextRow.childWidgets[j]);
                        }
                    }
                }
            }
        }
        return cells;
    };
    /**
     * @private
     */
    Editor.prototype.getBorder = function (borderColor, lineWidth, borderStyle) {
        var border = new WBorder();
        border.color = borderColor || '#000000';
        border.lineWidth = lineWidth || 1;
        border.lineStyle = borderStyle || 'Single';
        return border;
    };
    /**
     * Applies borders
     * @param  {WBorders} sourceBorders
     * @param  {WBorders} applyBorders
     * @private
     */
    Editor.prototype.applyBordersInternal = function (sourceBorders, applyBorders) {
        if (!isNullOrUndefined(sourceBorders) && !isNullOrUndefined(sourceBorders)) {
            if (!isNullOrUndefined(sourceBorders.top)) {
                this.applyBorder(sourceBorders.top, applyBorders.top);
            }
            if (!isNullOrUndefined(sourceBorders.bottom)) {
                this.applyBorder(sourceBorders.bottom, applyBorders.bottom);
            }
            if (!isNullOrUndefined(sourceBorders.left)) {
                this.applyBorder(sourceBorders.left, applyBorders.left);
            }
            if (!isNullOrUndefined(sourceBorders.right)) {
                this.applyBorder(sourceBorders.right, applyBorders.right);
            }
            if (!isNullOrUndefined(sourceBorders.horizontal)) {
                this.applyBorder(sourceBorders.horizontal, applyBorders.horizontal);
            }
            if (!isNullOrUndefined(sourceBorders.vertical)) {
                this.applyBorder(sourceBorders.vertical, applyBorders.vertical);
            }
            if (!isNullOrUndefined(sourceBorders.diagonalUp)) {
                this.applyBorder(sourceBorders.diagonalUp, applyBorders.diagonalUp);
            }
            if (!isNullOrUndefined(sourceBorders.diagonalDown)) {
                this.applyBorder(sourceBorders.diagonalDown, applyBorders.diagonalDown);
            }
        }
    };
    /**
     * Apply shading to table
     * @param  {WShading} sourceShading
     * @param  {WShading} applyShading
     * @private
     */
    Editor.prototype.applyShading = function (sourceShading, applyShading) {
        if (!isNullOrUndefined(applyShading) && !isNullOrUndefined(sourceShading)) {
            if (!isNullOrUndefined(applyShading.backgroundColor)
                && sourceShading.backgroundColor !== applyShading.backgroundColor) {
                sourceShading.backgroundColor = applyShading.backgroundColor;
            }
            if (!isNullOrUndefined(applyShading.foregroundColor)
                && sourceShading.foregroundColor !== applyShading.foregroundColor) {
                sourceShading.foregroundColor = applyShading.foregroundColor;
            }
            if (!isNullOrUndefined(applyShading.textureStyle)
                && sourceShading.textureStyle !== applyShading.textureStyle) {
                sourceShading.textureStyle = applyShading.textureStyle;
            }
        }
    };
    Editor.prototype.applyBorder = function (sourceBorder, applyBorder) {
        if (!isNullOrUndefined(sourceBorder) && !isNullOrUndefined(applyBorder)) {
            if (!isNullOrUndefined(applyBorder.color)
                && sourceBorder.color !== applyBorder.color) {
                sourceBorder.color = applyBorder.color;
            }
            if (!isNullOrUndefined(applyBorder.lineStyle)
                && sourceBorder.lineStyle !== applyBorder.lineStyle) {
                sourceBorder.lineStyle = applyBorder.lineStyle;
            }
            if (!isNullOrUndefined(applyBorder.lineWidth)
                && sourceBorder.lineWidth !== applyBorder.lineWidth) {
                sourceBorder.lineWidth = applyBorder.lineWidth;
            }
            if (!isNullOrUndefined(applyBorder.shadow)
                && sourceBorder.shadow !== applyBorder.shadow) {
                sourceBorder.shadow = applyBorder.shadow;
            }
            if (!isNullOrUndefined(applyBorder.space)
                && sourceBorder.space !== applyBorder.space) {
                sourceBorder.space = applyBorder.space;
            }
        }
    };
    /**
     * Apply Table Format changes
     * @param  {Selection} selection
     * @param  {WTableFormat} format
     * @private
     */
    Editor.prototype.onTableFormat = function (format, isShading) {
        if (!isNullOrUndefined(this.selection.tableFormat)) {
            if (isNullOrUndefined(isShading)) {
                isShading = false;
            }
            this.viewer.owner.isShiftingEnabled = true;
            this.editorHistory.initializeHistory('TableFormat');
            var table = this.selection.start.paragraph.associatedCell.ownerTable.combineWidget(this.viewer);
            if (isShading) {
                for (var i = 0; i < table.childWidgets.length; i++) {
                    var rowWidget = table.childWidgets[i];
                    for (var j = 0; j < rowWidget.childWidgets.length; j++) {
                        var cellWidget = rowWidget.childWidgets[j];
                        cellWidget.cellFormat.shading.copyFormat(format.shading);
                    }
                }
            }
            this.applyTableFormat(table, undefined, format);
            this.reLayout(this.selection, false);
        }
    };
    /**
     * @private
     */
    Editor.prototype.applyTableFormat = function (table, property, value) {
        this.applyTablePropertyValue(this.viewer.selection, undefined, value, table);
    };
    // tslint:disable-next-line:max-line-length
    Editor.prototype.applyTablePropertyValue = function (selection, property, value, table) {
        var sourceFormat = table.tableFormat;
        if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedTableProperties(sourceFormat, property, value);
        }
        if (value instanceof WTableFormat) {
            if (isNullOrUndefined(property)) {
                this.handleTableFormat(sourceFormat, value);
            }
            return;
        }
        if (property === 'preferredWidth') {
            sourceFormat.preferredWidth = value;
        }
        else if (property === 'leftIndent') {
            sourceFormat.leftIndent = value;
        }
        else if (property === 'tableAlignment') {
            sourceFormat.tableAlignment = value;
        }
        else if (property === 'cellSpacing') {
            sourceFormat.cellSpacing = value;
        }
        else if (property === 'leftMargin') {
            sourceFormat.leftMargin = value;
        }
        else if (property === 'rightMargin') {
            sourceFormat.rightMargin = value;
        }
        else if (property === 'topMargin') {
            sourceFormat.topMargin = value;
        }
        else if (property === 'bottomMargin') {
            sourceFormat.bottomMargin = value;
        }
        else if (property === 'preferredWidthType') {
            sourceFormat.preferredWidthType = value;
        }
        else if (property === 'bidi') {
            sourceFormat.bidi = value;
        }
        if (property === 'shading') {
            sourceFormat.shading = value;
        }
        else if (property === 'borders') {
            sourceFormat.borders = value;
        }
        // if (!isNullOrUndefined(table)) {
        //     this.layoutItemBlock(table, true);
        // }
    };
    Editor.prototype.handleTableFormat = function (tableFormat, applyFormat) {
        if (this.isBordersAndShadingDialog || this.editorHistory.isUndoing
            || this.editorHistory.isRedoing) {
            if (!isNullOrUndefined(tableFormat.borders)) {
                this.applyBordersInternal(tableFormat.borders, applyFormat.borders);
            }
            if (!isNullOrUndefined(tableFormat.shading)) {
                this.applyShading(tableFormat.shading, applyFormat.shading);
            }
        }
        if (!this.isBordersAndShadingDialog) {
            if (applyFormat.hasValue('bidi') && applyFormat.bidi !== tableFormat.bidi) {
                tableFormat.bidi = applyFormat.bidi;
            }
            if (applyFormat.hasValue('preferredWidth') && applyFormat.preferredWidth !== tableFormat.preferredWidth) {
                tableFormat.preferredWidth = applyFormat.preferredWidth;
            }
            if (applyFormat.hasValue('preferredWidthType') && applyFormat.preferredWidthType !== tableFormat.preferredWidthType) {
                tableFormat.preferredWidthType = applyFormat.preferredWidthType;
            }
            if (applyFormat.hasValue('tableAlignment') && applyFormat.tableAlignment !== tableFormat.tableAlignment) {
                tableFormat.tableAlignment = applyFormat.tableAlignment;
            }
            if (applyFormat.hasValue('leftIndent') && applyFormat.leftIndent !== tableFormat.leftIndent) {
                tableFormat.leftIndent = applyFormat.leftIndent;
            }
        }
        this.updateGridForTableDialog(tableFormat.ownerBase, false);
    };
    Editor.prototype.updateGridForTableDialog = function (table, shiftNextItem) {
        if (table.tableHolder) {
            table.updateRowIndex(0);
            table.calculateGrid();
            table.isGridUpdated = false;
        }
        this.viewer.layout.reLayoutTable(table);
    };
    /**
     * Applies Row Format Changes
     * @param  {Selection} selection
     * @param  {WRowFormat} format
     * @param  {WRow} row
     * @private
     */
    Editor.prototype.onRowFormat = function (format) {
        if (isNullOrUndefined(this.selection) || isNullOrUndefined(format)) {
            return;
        }
        this.editorHistory.initializeHistory('RowFormat');
        this.viewer.owner.isShiftingEnabled = true;
        var rowStartPos = this.selection.isForward ? this.selection.start : this.selection.end;
        var rowEndPos = this.selection.isForward ? this.selection.end : this.selection.start;
        var table = rowStartPos.paragraph.associatedCell.ownerTable.combineWidget(this.viewer);
        this.applyRowFormat(rowStartPos.paragraph.associatedCell.ownerRow, rowStartPos, rowEndPos, undefined, format);
        this.reLayout(this.selection, false);
    };
    Editor.prototype.applyRowFormat = function (row, start, end, property, value) {
        this.applyRowPropertyValue(this.viewer.selection, property, value, row);
        if (end.paragraph.associatedCell.ownerRow === row) {
            return;
        }
        var newRow = row.nextWidget;
        if (!isNullOrUndefined(newRow)) {
            this.applyRowFormat(newRow, start, end, property, value);
        }
    };
    Editor.prototype.applyRowPropertyValue = function (selection, property, value, row) {
        var applyFormat = row.rowFormat;
        if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedRowProperties(applyFormat, property, value);
        }
        if (value instanceof WRowFormat) {
            if (isNullOrUndefined(property)) {
                this.handleRowFormat(value, applyFormat);
            }
            return;
        }
        if (property === 'heightType') {
            applyFormat.heightType = value;
        }
        else if (property === 'height') {
            applyFormat.height = value;
        }
        else if (property === 'isHeader') {
            applyFormat.isHeader = value;
        }
        else if (property === 'allowBreakAcrossPages') {
            applyFormat.allowBreakAcrossPages = value;
        }
        if (!isNullOrUndefined(row.ownerTable)) {
            this.layoutItemBlock(row.ownerTable, true);
        }
    };
    Editor.prototype.handleRowFormat = function (format, applyFormat) {
        if (format.hasValue('allowBreakAcrossPages') && format.allowBreakAcrossPages !== applyFormat.allowBreakAcrossPages) {
            applyFormat.allowBreakAcrossPages = format.allowBreakAcrossPages;
        }
        if (format.hasValue('isHeader') && format.isHeader !== applyFormat.isHeader) {
            applyFormat.isHeader = format.isHeader;
        }
        if (format.hasValue('heightType') && format.heightType !== applyFormat.heightType) {
            applyFormat.heightType = format.heightType;
        }
        if (format.hasValue('height') && format.height !== applyFormat.height) {
            applyFormat.height = format.height;
        }
        this.updateGridForTableDialog(applyFormat.ownerBase.ownerTable, true);
    };
    /**
     * Applies Cell Format changes
     * @param  {Selection} selection
     * @param  {WCellFormat} format
     * @param  {WCell} cell
     * @private
     */
    Editor.prototype.onCellFormat = function (format) {
        if (isNullOrUndefined(this.selection) || isNullOrUndefined(format)) {
            return;
        }
        this.editorHistory.initializeHistory('CellFormat');
        this.updateFormatForCell(this.selection, undefined, format);
        this.reLayout(this.selection, false);
    };
    /**
     * @private
     */
    Editor.prototype.updateCellMargins = function (selection, value) {
        var cellStartPosition = selection.start;
        var cellEndPosition = selection.end;
        if (!selection.isForward) {
            cellStartPosition = selection.end;
            cellEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, cellStartPosition);
        // tslint:disable-next-line:max-line-length
        this.viewer.owner.cellOptionsDialogModule.applyCellmarginsValue(cellStartPosition.paragraph.associatedCell.ownerRow, cellStartPosition, cellEndPosition, value);
    };
    /**
     * @private
     */
    Editor.prototype.updateFormatForCell = function (selection, property, value) {
        var start = selection.start;
        var end = selection.end;
        if (!selection.isForward) {
            start = selection.end;
            end = selection.start;
        }
        var startCell = start.paragraph.associatedCell;
        var endCell = end.paragraph.associatedCell;
        var cells;
        var table = startCell.ownerTable.combineWidget(this.viewer);
        var appliedFormat;
        for (var k = startCell.columnIndex; k <= endCell.columnIndex; k++) {
            cells = this.getSelectedCellInColumn(startCell.ownerTable, startCell.ownerRow.rowIndex, k, endCell.ownerRow.rowIndex);
            for (var i = 0; i < cells.length; i++) {
                appliedFormat = this.applyCellPropertyValue(this.viewer.selection, property, value, cells[i].cellFormat);
            }
        }
        this.updateGridForTableDialog(table, false);
    };
    /**
     * @private
     */
    Editor.prototype.getSelectedCellInColumn = function (table, rowStartIndex, columnIndex, rowEndIndex) {
        var cells = [];
        for (var i = rowStartIndex; i <= rowEndIndex; i++) {
            var row = table.childWidgets[i];
            for (var j = 0; j < row.childWidgets.length; j++) {
                if (row.childWidgets[j].columnIndex === columnIndex) {
                    cells.push(row.childWidgets[j]);
                }
            }
        }
        return cells;
    };
    Editor.prototype.getColumnCells = function (table, columnIndex, isLeftSideCollection) {
        var cells = [];
        for (var k = 0; k < table.childWidgets.length; k++) {
            var row = table.childWidgets[k];
            for (var i = 0; i < row.childWidgets.length; i++) {
                var cell = row.childWidgets[i];
                if (isLeftSideCollection) {
                    if (cell.columnIndex + cell.cellFormat.columnSpan === columnIndex) {
                        cells.push(cell);
                    }
                }
                else {
                    if (cell.columnIndex === columnIndex) {
                        cells.push(cell);
                    }
                }
            }
        }
        return cells;
    };
    /**
     * @private
     */
    Editor.prototype.getTableWidth = function (table) {
        if (table.tableFormat.preferredWidth !== 0 || table.tableFormat.preferredWidthType === 'Percent') {
            if (table.tableFormat.preferredWidthType === 'Auto' || table.tableFormat.preferredWidthType === 'Point') {
                return table.tableFormat.preferredWidth;
            }
            else {
                if (table.tableFormat.preferredWidth === 0) {
                    return 0;
                }
                else {
                    return HelperMethods.convertPixelToPoint(this.viewer.clientArea.width) / 100 * table.tableFormat.preferredWidth;
                }
            }
        }
        return HelperMethods.convertPixelToPoint(this.viewer.layout.getTableWidth(table));
    };
    Editor.prototype.applyCellPropertyValue = function (selection, property, value, applyFormat) {
        if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedCellProperties(applyFormat, property, value);
        }
        if (value instanceof WCellFormat) {
            if (isNullOrUndefined(property)) {
                this.handleCellFormat(value, applyFormat);
            }
            return value;
        }
        if (property === 'leftMargin') {
            applyFormat.leftMargin = value;
        }
        else if (property === 'topMargin') {
            applyFormat.topMargin = value;
        }
        else if (property === 'rightMargin') {
            applyFormat.rightMargin = value;
        }
        else if (property === 'bottomMargin') {
            applyFormat.bottomMargin = value;
        }
        else if (property === 'preferredWidth') {
            applyFormat.preferredWidth = value;
            applyFormat.cellWidth = value;
        }
        else if (property === 'cellWidth') {
            applyFormat.cellWidth = value;
        }
        else if (property === 'columnSpan') {
            applyFormat.columnSpan = value;
        }
        else if (property === 'rowSpan') {
            applyFormat.rowSpan = value;
        }
        else if (property === 'preferredWidthType') {
            applyFormat.preferredWidthType = value;
        }
        else if (property === 'verticalAlignment') {
            applyFormat.verticalAlignment = value;
        }
        if (property === 'shading') {
            applyFormat.shading = value;
        }
        else if (property === 'borders') {
            applyFormat.borders = value;
        }
        return undefined;
    };
    Editor.prototype.handleCellFormat = function (cellFormat, applyFormat) {
        if (!isNullOrUndefined(cellFormat) && !isNullOrUndefined(applyFormat)) {
            if (this.isBordersAndShadingDialog) {
                if (!isNullOrUndefined(cellFormat.borders)) {
                    this.applyBordersInternal(applyFormat.borders, cellFormat.borders);
                }
                if (!isNullOrUndefined(cellFormat.shading)) {
                    this.applyShading(applyFormat.shading, cellFormat.shading);
                }
                // this.layoutRow((applyFormat.ownerBase as TableCellWidget).ownerRow, this.viewer, false);
            }
            else {
                if (cellFormat.hasValue('preferredWidth') && applyFormat.preferredWidth !== cellFormat.preferredWidth) {
                    applyFormat.preferredWidth = cellFormat.preferredWidth;
                }
                if (cellFormat.hasValue('preferredWidthType') && applyFormat.preferredWidthType !== cellFormat.preferredWidthType) {
                    applyFormat.preferredWidthType = cellFormat.preferredWidthType;
                }
                if (cellFormat.hasValue('verticalAlignment') && applyFormat.verticalAlignment !== cellFormat.verticalAlignment) {
                    applyFormat.verticalAlignment = cellFormat.verticalAlignment;
                }
            }
        }
    };
    /**
     * @private
     */
    Editor.prototype.destroy = function () {
        this.viewer = undefined;
        this.nodes = [];
    };
    Editor.prototype.isTocField = function (element) {
        if (element instanceof FieldElementBox) {
            var nextElement = element.nextNode;
            if (element instanceof FieldElementBox && element.fieldType === 0 && nextElement instanceof TextElementBox
                && nextElement.text.trim().toLowerCase().indexOf('toc') === 0) {
                return true;
            }
        }
        return false;
    };
    /**
     * Updates the table of contents.
     * @private
     */
    Editor.prototype.updateToc = function (tocField) {
        if (isNullOrUndefined(tocField)) {
            tocField = this.selection.getTocFieldInternal();
        }
        if (!this.isTocField(tocField)) {
            return;
        }
        // Decode field code to get parameters
        var code = this.selection.getFieldCode(tocField);
        if (code.toLocaleLowerCase().indexOf('toc') !== -1) {
            this.insertTableOfContents(this.validateTocSettings(this.getTocSettings(code, tocField)));
        }
    };
    Editor.prototype.getTocSettings = function (code, tocField) {
        var tocSettings = {};
        tocSettings.includePageNumber = true;
        tocSettings.rightAlign = true;
        // Decode field code to get parameters
        if (code.toLowerCase() === 'toc \\mergeformat') {
            tocSettings.startLevel = 1;
            tocSettings.endLevel = 3;
        }
        else {
            var swtiches = code.split('\\');
            for (var i = 0; i < swtiches.length; i++) {
                var swtch = swtiches[i];
                if (swtch.length === 0) {
                    continue;
                }
                switch (swtch[0]) {
                    case 'o':
                        if (!isNullOrUndefined(swtch.match(/\d+/g))) {
                            var levels = swtch.match(/\d+/g).map(Number);
                            tocSettings.startLevel = levels[0];
                            tocSettings.endLevel = levels[1];
                        }
                        else {
                            tocSettings.startLevel = 1;
                            tocSettings.endLevel = 9;
                        }
                        break;
                    case 'h':
                        tocSettings.includeHyperlink = true;
                        break;
                    case 'n':
                        tocSettings.includePageNumber = false;
                        break;
                    case 'p':
                        tocSettings.rightAlign = false;
                        break;
                    case 'u':
                        tocSettings.includeOutlineLevels = true;
                        break;
                    case 't':
                        this.decodeTSwitch(tocSettings, swtch);
                        break;
                }
            }
        }
        //assigns tab leader.
        var tabs = tocField.paragraph.paragraphFormat.getUpdatedTabs();
        if (tabs.length > 0) {
            tocSettings.tabLeader = tabs[tabs.length - 1].tabLeader;
        }
        if (tocSettings.rightAlign && isNullOrUndefined(tocSettings.tabLeader)) {
            tocSettings.tabLeader = 'Dot';
        }
        return tocSettings;
    };
    Editor.prototype.decodeTSwitch = function (tocSettings, tSwitch) {
        tocSettings.levelSettings = {};
        tSwitch = tSwitch.replace('t', '');
        tSwitch = tSwitch.replace('"', '');
        tSwitch = tSwitch.replace('"', '');
        tSwitch = tSwitch.trim();
        var levels = tSwitch.split(',');
        for (var index = 0; index < levels.length; index++) {
            tocSettings.levelSettings[levels[index]] = parseInt(levels[index + 1], 10);
            index++;
        }
    };
    /**
     * Inserts, modifies or updates the table of contents based on given settings.
     * @param {TableOfContentsSettings} tableOfContentsSettings
     */
    Editor.prototype.insertTableOfContents = function (tableOfContentsSettings) {
        this.isInsertingTOC = true;
        this.initComplexHistory('TOC');
        if (isNullOrUndefined(tableOfContentsSettings)) {
            //Initializes with default value.
            tableOfContentsSettings = {};
            tableOfContentsSettings.startLevel = 1;
            tableOfContentsSettings.endLevel = 3;
            tableOfContentsSettings.includeHyperlink = true;
            tableOfContentsSettings.includeOutlineLevels = true;
            tableOfContentsSettings.includePageNumber = true;
            tableOfContentsSettings.rightAlign = true;
            tableOfContentsSettings.tabLeader = 'Dot';
        }
        var tocField = undefined;
        var code = undefined;
        if (this.selection.contextType === 'TableOfContents') {
            tocField = this.selection.getTocFieldInternal();
        }
        if (tocField instanceof FieldElementBox) {
            this.selection.start.setPositionForSelection(tocField.line, tocField, 0, this.selection.start.location);
            this.selection.end.setPositionForSelection(tocField.fieldEnd.line, tocField.fieldEnd, 2, this.selection.end.location);
            this.delete();
        }
        // Build TOC field code based on parameter
        code = this.constructTocFieldCode(tableOfContentsSettings);
        var isStartParagraph = this.selection.start.isAtParagraphStart;
        var blockInfo = this.selection.getParagraphInfo(this.selection.start);
        var initialStart = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        // Build TOC fields
        // tslint:disable-next-line:max-line-length
        var widgets = this.buildToc(this.validateTocSettings(tableOfContentsSettings), code, true, isStartParagraph);
        if (widgets.length > 0) {
            var tocLastPara = new ParagraphWidget();
            var tocLastLine = new LineWidget(tocLastPara);
            tocLastPara.childWidgets.push(tocLastLine);
            var index = 0;
            if (!isStartParagraph) {
                index = 1;
            }
            var line = widgets[index].childWidgets[0];
            var fieldBegin = line.children[0];
            this.appendEndField(fieldBegin, tocLastLine);
            widgets.push(tocLastPara);
            this.appendEmptyPara(widgets);
        }
        else {
            var localizeValue = new L10n('documenteditor', this.owner.defaultLocale);
            localizeValue.setLocale(this.owner.locale);
            DialogUtility.alert({
                title: localizeValue.getConstant('No Headings'),
                content: localizeValue.getConstant('Add Headings'),
                showCloseIcon: true,
                closeOnEscape: true,
                position: { X: 'center', Y: 'center' },
                animationSettings: { effect: 'Zoom' }
            });
        }
        this.setPositionForCurrentIndex(this.selection.start, initialStart);
        this.selection.end.setPositionInternal(this.selection.start);
        this.pasteContentsInternal(widgets);
        this.isInsertingTOC = false;
        this.updatePageRef();
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistoryInternal();
        }
        if (widgets.length === 0) {
            this.owner.editorHistory.undo();
            this.owner.editorHistory.redoStack.pop();
        }
    };
    Editor.prototype.appendEmptyPara = function (widgets) {
        var emptyPara = new ParagraphWidget();
        var emptyLine = new LineWidget(emptyPara);
        emptyPara.childWidgets.push(emptyLine);
        widgets.push(emptyPara);
    };
    Editor.prototype.constructTocFieldCode = function (tocSettings) {
        var tocFieldCode = 'TOC';
        //appends styles level
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(tocSettings.startLevel) && tocSettings.startLevel !== 0 && !isNullOrUndefined(tocSettings.endLevel) && tocSettings.endLevel !== 0) {
            tocFieldCode = tocFieldCode + ' \\o "' + tocSettings.startLevel + '-' + tocSettings.endLevel + '"';
        }
        if (tocSettings.includePageNumber && !tocSettings.rightAlign) {
            tocFieldCode = tocFieldCode + ' \\p " "';
        }
        if (!tocSettings.includePageNumber) {
            tocFieldCode = tocFieldCode + ' \\n';
        }
        if (tocSettings.includeHyperlink) {
            tocFieldCode = tocFieldCode + ' \\h \\z';
        }
        if (tocSettings.includeOutlineLevels) {
            tocFieldCode = tocFieldCode + ' \\u';
        }
        var tSwitch = this.constructTSwitch(tocSettings);
        if (tSwitch.length > 6) {
            tocFieldCode = tocFieldCode + tSwitch;
        }
        return tocFieldCode;
    };
    Editor.prototype.constructTSwitch = function (tocSettings) {
        var tSwitch = '';
        var prefix = ' \\t ';
        if (!isNullOrUndefined(tocSettings.levelSettings)) {
            for (var _i = 0, _a = Object.keys(tocSettings.levelSettings); _i < _a.length; _i++) {
                var key = _a[_i];
                tSwitch = tSwitch + key + ',' + tocSettings.levelSettings[key].toString() + ',';
            }
        }
        tSwitch = tSwitch.slice(0, -1);
        tSwitch = prefix + '"' + tSwitch + '"';
        return tSwitch;
    };
    /**
     * Appends the end filed to the given line.
     */
    Editor.prototype.appendEndField = function (fieldBegin, lineWidget) {
        var fieldEnd = new FieldElementBox(1);
        fieldEnd.fieldSeparator = fieldBegin.fieldSeparator;
        fieldBegin.fieldSeparator.fieldEnd = fieldEnd;
        fieldEnd.fieldBegin = fieldBegin;
        fieldEnd.fieldBegin.fieldEnd = fieldEnd;
        fieldEnd.line = lineWidget;
        lineWidget.children.push(fieldEnd);
    };
    Editor.prototype.validateTocSettings = function (tocSettings) {
        if (isNullOrUndefined(tocSettings.startLevel) || tocSettings.startLevel < 1) {
            tocSettings.startLevel = 1;
        }
        if (isNullOrUndefined(tocSettings.endLevel) || tocSettings.endLevel < tocSettings.endLevel) {
            tocSettings.endLevel = tocSettings.startLevel > 3 ? tocSettings.startLevel : 3;
        }
        if (isNullOrUndefined(tocSettings.includeHyperlink)) {
            tocSettings.includeHyperlink = false;
        }
        if (isNullOrUndefined(tocSettings.includePageNumber)) {
            tocSettings.includePageNumber = false;
        }
        if (isNullOrUndefined(tocSettings.rightAlign)) {
            tocSettings.rightAlign = false;
        }
        if (isNullOrUndefined(tocSettings.levelSettings)) {
            tocSettings.levelSettings = {};
        }
        return tocSettings;
    };
    /**
     * Builds the TOC
     * @private
     */
    // tslint:disable-next-line:max-line-length
    Editor.prototype.buildToc = function (tocSettings, fieldCode, isFirstPara, isStartParagraph) {
        var tocDomBody = this.viewer.pages[0].bodyWidgets[0];
        var widgets = [];
        this.createHeadingLevels(tocSettings);
        if (tocSettings.includeOutlineLevels) {
            this.createOutlineLevels(tocSettings);
        }
        var sectionFormat = this.selection.start.paragraph.bodyWidget.sectionFormat;
        var widget = tocDomBody.childWidgets[0];
        while (widget !== undefined) {
            // tslint:disable-next-line:max-line-length
            if (widget instanceof ParagraphWidget && (this.isHeadingStyle(widget) || (tocSettings.includeOutlineLevels && this.isOutlineLevelStyle(widget)))) {
                var bookmarkName = this.insertTocBookmark(widget);
                // tslint:disable-next-line:max-line-length
                this.createTOCWidgets(widget, widgets, fieldCode, bookmarkName, tocSettings, isFirstPara, isStartParagraph, sectionFormat);
                isFirstPara = false;
            }
            widget = this.selection.getNextParagraphBlock(widget.getSplitWidgets().pop());
        }
        this.tocStyles = {};
        return widgets;
    };
    Editor.prototype.createOutlineLevels = function (settings) {
        for (var i = settings.startLevel; i <= settings.endLevel; i++) {
            var levelStyle = 'Level' + i.toString();
            if (isNullOrUndefined(this.tocStyles[levelStyle])) {
                this.tocStyles[levelStyle] = i;
            }
        }
    };
    /**
     * Creates TOC heading styles
     * @param start - lower heading level
     * @param end - higher heading level
     */
    Editor.prototype.createHeadingLevels = function (settings) {
        for (var i = settings.startLevel; i <= settings.endLevel; i++) {
            var headingStyle = 'Heading ' + i.toString();
            if (isNullOrUndefined(this.tocStyles[headingStyle])) {
                this.tocStyles[headingStyle] = i;
            }
        }
        if (!isNullOrUndefined(settings.levelSettings)) {
            for (var _i = 0, _a = Object.keys(settings.levelSettings); _i < _a.length; _i++) {
                var key = _a[_i];
                this.tocStyles[key] = settings.levelSettings[key];
            }
        }
    };
    /**
     * Checks the current style is heading style.
     */
    Editor.prototype.isHeadingStyle = function (para) {
        var style = para.paragraphFormat.baseStyle;
        if (style !== undefined) {
            return isNullOrUndefined(this.tocStyles[style.name]) ? false : true;
        }
        return false;
    };
    Editor.prototype.isOutlineLevelStyle = function (para) {
        var styleName = para.paragraphFormat.outlineLevel;
        return isNullOrUndefined(this.tocStyles[styleName]) ? false : true;
    };
    /**
     * Creates TOC field element.
     */
    Editor.prototype.createTocFieldElement = function (lineWidget, fieldCode) {
        //begin
        var fieldBegin = new FieldElementBox(0);
        fieldBegin.hasFieldEnd = true;
        fieldBegin.line = lineWidget;
        lineWidget.children.push(fieldBegin);
        //format toc
        var textElement = new TextElementBox();
        textElement.text = fieldCode;
        textElement.line = lineWidget;
        lineWidget.children.push(textElement);
        //field separator
        var fieldSeparator = new FieldElementBox(2);
        fieldSeparator.fieldBegin = fieldBegin;
        fieldSeparator.fieldBegin.fieldSeparator = fieldSeparator;
        fieldSeparator.line = lineWidget;
        lineWidget.children.push(fieldSeparator);
        return fieldBegin;
    };
    /**
     * Updates TOC para
     */
    // tslint:disable-next-line:max-line-length
    Editor.prototype.createTOCWidgets = function (widget, widgets, fieldCode, bookmarkName, tocSettings, isFirstPara, isStartParagraph, sectionFormat) {
        var fieldBegin = undefined;
        var tocPara = undefined;
        var tocLine = undefined;
        // tslint:disable-next-line:max-line-length
        if (widgets.length === 1 && widgets[0].childWidgets[0].children.length === 3 && !isNullOrUndefined(isFirstPara) && !isFirstPara) {
            tocLine = widgets[0].childWidgets[0];
        }
        else {
            tocPara = new ParagraphWidget();
            var styleName = undefined;
            //Adds toc syles into paragraph
            var headingStyleName = widget.paragraphFormat.baseStyle.name;
            if (tocSettings.includeOutlineLevels && isNullOrUndefined(this.tocStyles[headingStyleName])) {
                styleName = widget.paragraphFormat.outlineLevel;
            }
            else {
                styleName = headingStyleName;
            }
            var tocStyleName = 'Toc' + this.tocStyles[styleName];
            var paraStyle = this.viewer.styles.findByName(tocStyleName, 'Paragraph');
            if (isNullOrUndefined(paraStyle)) {
                // tslint:disable-next-line:max-line-length
                this.viewer.owner.parser.parseStyle(JSON.parse(this.getCompleteStyles()), JSON.parse(this.viewer.preDefinedStyles.get(tocStyleName)), this.viewer.styles);
                paraStyle = this.viewer.styles.findByName(tocStyleName, 'Paragraph');
            }
            tocPara.paragraphFormat.ApplyStyle(paraStyle);
            //Creates right tab for page number.
            if (tocSettings.rightAlign && tocSettings.includePageNumber) {
                var tabStop = new WTabStop();
                tabStop.position = sectionFormat.pageWidth - (sectionFormat.leftMargin + sectionFormat.rightMargin);
                tabStop.tabLeader = tocSettings.tabLeader;
                tabStop.deletePosition = 0;
                tabStop.tabJustification = 'Right';
                tocPara.paragraphFormat.tabs.push(tabStop);
            }
            tocLine = new LineWidget(tocPara);
            tocPara.childWidgets.push(tocLine);
        }
        //creates toc field element if it is insert
        if ((isFirstPara !== undefined) && isFirstPara) {
            if (!isNullOrUndefined(isStartParagraph) && !isStartParagraph) {
                this.appendEmptyPara(widgets);
            }
            this.createTocFieldElement(tocLine, fieldCode);
        }
        var text = '';
        var isFieldCode = false;
        var paragraph = widget;
        while (paragraph instanceof ParagraphWidget) {
            for (var lineIndex = 0; lineIndex < paragraph.childWidgets.length; lineIndex++) {
                var lineWidget = paragraph.childWidgets[lineIndex];
                for (var elementIndex = 0; elementIndex < lineWidget.children.length; elementIndex++) {
                    var element = lineWidget.children[elementIndex];
                    if (element.isPageBreak) {
                        continue;
                    }
                    if ((element instanceof FieldElementBox) || (element instanceof BookmarkElementBox) || isFieldCode) {
                        if (element instanceof FieldElementBox) {
                            if (element.fieldType === 0) {
                                isFieldCode = true;
                            }
                            else if (element.fieldType === 2) {
                                isFieldCode = false;
                            }
                        }
                    }
                    else if (element instanceof TextElementBox || element instanceof ListTextElementBox) {
                        var temp = element.text;
                        var tabChar = '\t';
                        if (temp.indexOf(tabChar) !== -1) {
                            temp = temp.replace(new RegExp(tabChar, 'g'), ' ');
                        }
                        text = text + temp;
                    }
                }
            }
            paragraph = paragraph.nextSplitWidget;
        }
        if (text !== '') {
            // inserts hyperlink
            if (tocSettings.includeHyperlink && (bookmarkName !== undefined)) {
                fieldBegin = this.insertTocHyperlink(tocLine, bookmarkName, text);
            }
            else {
                var span = new TextElementBox();
                span.text = text;
                span.line = tocLine;
                tocLine.children.push(span);
            }
            //inserts page number
            if (tocSettings.includePageNumber && (bookmarkName !== undefined)) {
                if (tocSettings.rightAlign) {
                    var tabText = new TabElementBox();
                    tabText.text = '\t';
                    tabText.line = tocLine;
                    tocLine.children.push(tabText);
                }
                var pageField = this.insertTocPageNumber(bookmarkName, tocLine, tocSettings.rightAlign, widget);
                this.appendEndField(pageField, tocLine);
            }
            if (tocSettings.includeHyperlink && fieldBegin !== undefined) {
                this.appendEndField(fieldBegin, tocLine);
            }
        }
        if (!isNullOrUndefined(tocPara) && (text !== '' || isFirstPara)) {
            widgets.push(tocPara);
        }
    };
    /**
     * Inserts toc hyperlink.
     */
    Editor.prototype.insertTocHyperlink = function (lineWidget, bookmarkName, text) {
        var fieldCode = ' HYPERLINK \\l \"' + bookmarkName + '\" ';
        var fieldBegin = this.createTocFieldElement(lineWidget, fieldCode);
        //text element.
        var span = new TextElementBox();
        span.text = text;
        span.line = lineWidget;
        lineWidget.children.push(span);
        return fieldBegin;
    };
    /**
     * Inserts toc page number.
     */
    // tslint:disable-next-line:max-line-length
    Editor.prototype.insertTocPageNumber = function (bookMarkname, lineWidget, isRightAlign, widget) {
        var fieldCode = ' PAGEREF' + bookMarkname + ' \\h ';
        var fieldBegin = this.createTocFieldElement(lineWidget, fieldCode);
        var text = (this.viewer.pages.indexOf(widget.bodyWidget.page) + 1).toString();
        //text element.
        var span = new FieldTextElementBox();
        span.fieldBegin = fieldBegin;
        if (!isRightAlign) {
            text = ' ' + text;
        }
        span.text = text;
        span.line = lineWidget;
        lineWidget.children.push(span);
        this.pageRefFields[bookMarkname] = span;
        return fieldBegin;
    };
    Editor.prototype.updatePageRef = function () {
        for (var _i = 0, _a = Object.keys(this.pageRefFields); _i < _a.length; _i++) {
            var key = _a[_i];
            var bookmark = this.viewer.bookmarks.get(key);
            var pageRef = (bookmark.paragraph.bodyWidget.page.index + 1).toString();
            var span = this.pageRefFields[key];
            if (pageRef !== span.text) {
                span.text = pageRef;
                var paragraph = span.paragraph;
                var lineIndex = paragraph.childWidgets.indexOf(span.line);
                var elementIndex = span.line.children.indexOf(span);
                this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, elementIndex);
            }
        }
    };
    /**
     * Inserts toc bookmark.
     */
    Editor.prototype.insertTocBookmark = function (widget) {
        var bookmarkName = undefined;
        var lineLength = widget.childWidgets.length;
        if (lineLength > 0) {
            var splitParagraph = widget.getSplitWidgets();
            var firstParagraph = splitParagraph[0];
            var lastParagraph = splitParagraph.pop();
            var startLine = firstParagraph.childWidgets[0];
            var endLine = lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1];
            if ((startLine !== undefined) && (endLine !== undefined)) {
                var startElement = startLine.children[0];
                if (startElement instanceof ListTextElementBox) {
                    do {
                        startElement = startElement.nextNode;
                    } while (startElement instanceof ListTextElementBox);
                }
                //Returns the bookmark if already present for paragraph.
                // tslint:disable-next-line:max-line-length
                if (!isNullOrUndefined(startElement) && startElement instanceof BookmarkElementBox && startElement.bookmarkType === 0 && (startElement.name.toLowerCase().match('^_toc'))) {
                    return startElement.name;
                }
                var endElement = endLine.children[endLine.children.length - 1];
                if ((startElement !== undefined) && (endElement !== undefined)) {
                    this.selection.start.setPositionForSelection(startLine, startElement, 0, this.selection.start.location);
                    this.selection.end.setPositionForSelection(endLine, endElement, endElement.length, this.selection.end.location);
                    bookmarkName = this.generateBookmarkName();
                    this.insertBookmark(bookmarkName);
                }
            }
        }
        return bookmarkName;
    };
    /**
     * Generates bookmark id.
     */
    Editor.prototype.generateBookmarkName = function () {
        this.tocBookmarkId++;
        var count = 10 - this.tocBookmarkId.toString().length;
        var formatString = '';
        while (count - 1 > 0) {
            formatString = '0' + formatString;
            count--;
        }
        var bookmarkName = '_Toc' + formatString + this.tocBookmarkId;
        return bookmarkName;
    };
    /**
     * Change cell content alignment
     * @private
     */
    Editor.prototype.onCellContentAlignment = function (verticalAlignment, textAlignment) {
        this.owner.isShiftingEnabled = true;
        var selection = this.owner.selection;
        if (selection.isEmpty && selection.start.paragraph.isInsideTable) {
            if (this.owner.editorHistory) {
                this.owner.editorHistory.initComplexHistory(selection, 'MultiSelection');
            }
            //Selecting the table cell to update the all the paragraph format.
            selection.selectTableCell();
            this.initHistory('CellContentVerticalAlignment');
            var cellFormat = selection.start.paragraph.associatedCell.cellFormat;
            this.applyCellPropertyValue(selection, 'verticalAlignment', verticalAlignment, cellFormat);
            this.reLayout(selection, false);
            this.initHistory('TextAlignment');
            this.updateParagraphFormat('textAlignment', textAlignment, false);
            this.reLayout(this.owner.selection, false);
            if (this.owner.editorHistory) {
                this.owner.editorHistory.updateComplexHistory();
            }
        }
        else {
            if (this.owner.editorHistory) {
                this.owner.editorHistory.initComplexHistory(selection, 'MultiSelection');
            }
            if (!isNullOrUndefined(selection.getTable(selection.start, selection.end))) {
                //Table cell vertical alignment.
                this.updateSelectionTableFormat(selection, 'CellContentVerticalAlignment', verticalAlignment);
                this.reLayout(this.owner.selection, false);
                this.initHistory('TextAlignment');
                //Paragraph text alignment.
                this.updateSelectionParagraphFormatting('textAlignment', textAlignment, false);
                this.reLayout(selection, false);
            }
            if (this.owner.editorHistory) {
                this.owner.editorHistory.updateComplexHistory();
            }
        }
    };
    //Restrict editing implementation starts
    /**
     * @private
     */
    Editor.prototype.insertEditRangeElement = function (user) {
        if (this.viewer.isDocumentProtected || this.viewer.selection.isEmpty) {
            return;
        }
        this.initComplexHistory('RestrictEditing');
        this.selection.skipEditRangeRetrieval = true;
        var selection = this.viewer.selection;
        var startPos = this.selection.start;
        var endPos = this.selection.end;
        if (!this.selection.isForward) {
            startPos = this.selection.end;
            endPos = this.selection.start;
        }
        if (selection.start.paragraph.isInsideTable && selection.end.paragraph.isInsideTable
            && selection.start.paragraph.associatedCell.ownerTable.contains(selection.end.paragraph.associatedCell)) {
            var startCell = this.getOwnerCell(this.selection.isForward);
            var endCell = this.getOwnerCell(!this.selection.isForward);
            if (startCell.rowIndex === endCell.rowIndex) {
                var startIndex = startCell.ownerRow.childWidgets.indexOf(startCell);
                var endIndex = startCell.ownerRow.childWidgets.indexOf(endCell);
                var startElement = [];
                var endElement = [];
                for (var i = startIndex; i <= endIndex; i++) {
                    var editStart = this.addEditElement(user);
                    editStart.columnFirst = i;
                    editStart.columnLast = i;
                    editStart.line = selection.start.currentWidget;
                    var editEnd = editStart.editRangeEnd;
                    editEnd.line = selection.end.currentWidget;
                    startElement.push(editStart);
                    endElement.push(editEnd);
                }
                this.insertElements(endElement, startElement);
                var offset = startElement[0].line.getOffset(startElement[0], 1);
                this.selection.start.setPositionParagraph(startElement[0].line, offset);
                offset = endElement[0].line.getOffset(endElement[0], 1);
                this.selection.end.setPositionParagraph(endElement[0].line, offset);
                this.selection.fireSelectionChanged(true);
                this.fireContentChange();
            }
            else {
                this.insertEditRangeInsideTable(startCell, endCell, user);
                var startLine = this.selection.getFirstParagraphInCell(startCell).childWidgets[0];
                var endLine = this.selection.getLastParagraph(endCell).childWidgets[0];
                var offset = startLine.getOffset(startLine.children[0], 1);
                this.selection.start.setPositionParagraph(startLine, offset);
                offset = endLine.getOffset(endLine.children[0], 1);
                this.selection.end.setPositionParagraph(endLine, offset);
                this.selection.fireSelectionChanged(true);
                this.fireContentChange();
            }
        }
        else {
            this.addRestrictEditingForSelectedArea(user);
        }
        this.selection.skipEditRangeRetrieval = false;
    };
    /**
     * @private
     */
    Editor.prototype.insertEditRangeInsideTable = function (startCell, endCell, user) {
        var table = startCell.ownerTable;
        var count = table.childWidgets.indexOf(endCell.ownerRow);
        var rowStartIndex = table.childWidgets.indexOf(startCell.ownerRow);
        var startLeft = this.selection.getCellLeft(startCell.ownerRow, startCell);
        var endLeft = startLeft + startCell.cellFormat.cellWidth;
        var endCellLeft = this.selection.getCellLeft(endCell.ownerRow, endCell);
        var endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        var cellInfo = this.updateSelectedCellsInTable(startLeft, endLeft, endCellLeft, endCellRight);
        startLeft = cellInfo.start;
        endLeft = cellInfo.end;
        var endElement = [];
        for (var i = rowStartIndex; i <= count; i++) {
            var row = table.childWidgets[i];
            var cellSelectionStartIndex = -1;
            var cellSelectionEndIndex = -1;
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                var cellStart = this.selection.getCellLeft(row, cell);
                if (this.checkCellWithInSelection(startLeft, endLeft, cellStart)) {
                    if (cellSelectionStartIndex === -1) {
                        cellSelectionStartIndex = j;
                    }
                    cellSelectionEndIndex = j;
                }
            }
            var newEndElement = [];
            for (var z = cellSelectionStartIndex; z <= cellSelectionEndIndex; z++) {
                var index = 0;
                var startCell_1 = void 0;
                var startParagraph = void 0;
                if (z === cellSelectionStartIndex) {
                    startCell_1 = row.childWidgets[cellSelectionStartIndex];
                    startParagraph = this.selection.getFirstParagraphInCell(startCell_1).childWidgets[0];
                }
                var editStart = this.addEditElement(user);
                editStart.columnFirst = z;
                editStart.columnLast = z;
                editStart.line = startParagraph;
                editStart.line.children.splice(index, 0, editStart);
                index++;
                var editEnd = editStart.editRangeEnd;
                newEndElement.push(editEnd);
                if (endElement.length > 0 && z === cellSelectionEndIndex) {
                    for (var l = 0; l < endElement.length; l++) {
                        endElement[l].line = editStart.line;
                        editStart.line.children.splice(index, 0, endElement[l]);
                        index++;
                    }
                    endElement = [];
                }
            }
            endElement = newEndElement;
            if (i === count && endElement.length > 0) {
                var cellWidget = row.childWidgets[cellSelectionEndIndex];
                var lastLine = this.selection.getLastParagraph(cellWidget).lastChild;
                var index = lastLine.children.length - 1;
                for (var l = 0; l < endElement.length; l++) {
                    endElement[l].line = lastLine;
                    lastLine.children.splice(index, 0, endElement[l]);
                    index++;
                }
            }
        }
    };
    /**
     * @private
     */
    Editor.prototype.addRestrictEditingForSelectedArea = function (user) {
        var editStart = this.addEditElement(user);
        var editEnd = editStart.editRangeEnd;
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.editorHistory.currentHistoryInfo.editRangeStart = editStart;
        }
        this.insertElements([editEnd], [editStart]);
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistoryInternal();
        }
        var offset = editStart.line.getOffset(editStart, 1);
        this.selection.start.setPositionParagraph(editStart.line, offset);
        offset = editEnd.line.getOffset(editEnd, 1);
        this.selection.end.setPositionParagraph(editEnd.line, offset);
        this.selection.fireSelectionChanged(true);
        this.fireContentChange();
    };
    /**
     * @private
     */
    Editor.prototype.addEditElement = function (user) {
        var editStart = new EditRangeStartElementBox();
        if (user.toLocaleLowerCase() === 'everyone') {
            editStart.group = user;
        }
        else {
            editStart.user = user;
        }
        var editEnd = new EditRangeEndElementBox();
        editEnd.editRangeStart = editStart;
        editStart.editRangeEnd = editEnd;
        this.editStartRangeCollection.push(editStart);
        this.addEditCollectionToDocument();
        this.editStartRangeCollection = [];
        return editStart;
    };
    /**
     * @private
     */
    Editor.prototype.protect = function (protectionType) {
        this.viewer.isDocumentProtected = true;
        this.viewer.protectionType = protectionType;
        this.selection.highlightEditRegion();
    };
    /**
     * @private
     */
    Editor.prototype.addEditCollectionToDocument = function () {
        for (var i = 0; i < this.editStartRangeCollection.length; i++) {
            var editStart = this.editStartRangeCollection[i];
            var user = editStart.user === '' ? editStart.group : editStart.user;
            if (this.viewer.editRanges.length > 0 && this.viewer.editRanges.containsKey(user)) {
                this.viewer.editRanges.get(user).push(editStart);
            }
            else {
                var collection = [];
                collection.push(editStart);
                this.viewer.editRanges.add(user, collection);
            }
        }
        this.selection.updateEditRangeCollection();
    };
    /**
     * @private
     */
    Editor.prototype.updateRangeCollection = function (editStart, user) {
        if (this.viewer.editRanges.length > 0 && this.viewer.editRanges.containsKey(user)) {
            this.viewer.editRanges.get(user).push(editStart);
        }
        else {
            var collection = [];
            collection.push(editStart);
            this.viewer.editRanges.add(user, collection);
        }
    };
    /**
     * @private
     */
    Editor.prototype.removeUserRestrictions = function (user) {
        if (!this.selection.checkSelectionIsAtEditRegion()) {
            return;
        }
        this.selection.skipEditRangeRetrieval = true;
        var editStart = this.selection.getEditRangeStartElement();
        this.initHistory('RemoveEditRange');
        if (this.editorHistory) {
            this.editorHistory.currentBaseHistoryInfo.setEditRangeInfo(editStart);
            this.editorHistory.updateHistory();
        }
        if (editStart.user === user || editStart.group === user) {
            this.removeUserRestrictionsInternal(editStart, user);
        }
        this.selection.updateEditRangeCollection();
        this.fireContentChange();
        this.selection.skipEditRangeRetrieval = false;
    };
    /**
     * @private
     */
    Editor.prototype.removeUserRestrictionsInternal = function (editStart, currentUser) {
        var user = currentUser;
        if (isNullOrUndefined(currentUser)) {
            user = editStart.user === '' ? editStart.group : editStart.user;
        }
        var index = this.viewer.editRanges.get(user).indexOf(editStart);
        this.viewer.editRanges.get(user).splice(index, 1);
        editStart.editRangeEnd.line.children.splice(editStart.editRangeEnd.indexInOwner, 1);
        editStart.line.children.splice(editStart.indexInOwner, 1);
    };
    /**
     * @private
     */
    Editor.prototype.removeAllEditRestrictions = function () {
        this.selection.skipEditRangeRetrieval = true;
        var startPosition = this.selection.start;
        var endPosition = this.selection.end;
        var editStart = [];
        var keys = this.viewer.editRanges.keys;
        for (var j = 0; j < keys.length; j++) {
            editStart = this.viewer.editRanges.get(keys[j]);
            for (var i = 0; i < editStart.length; i++) {
                editStart[i].editRangeEnd.line.children.splice(editStart[i].editRangeEnd.indexInOwner, 1);
                editStart[i].line.children.splice(editStart[i].indexInOwner, 1);
            }
        }
        this.viewer.editRanges.clear();
        this.selection.updateEditRangeCollection();
        this.selection.start.setPositionInternal(startPosition);
        this.selection.end.setPositionInternal(endPosition);
        this.selection.editRegionHighlighters.clear();
        this.viewer.updateScrollBars();
        this.selection.fireSelectionChanged(false);
        this.selection.skipEditRangeRetrieval = false;
    };
    return Editor;
}());

/**
 * @private
 */
var ModifiedLevel = /** @__PURE__ @class */ (function () {
    function ModifiedLevel(owner, modified) {
        this.ownerListLevelIn = undefined;
        this.modifiedListLevelIn = undefined;
        this.ownerListLevel = owner;
        this.modifiedListLevel = modified;
    }
    Object.defineProperty(ModifiedLevel.prototype, "ownerListLevel", {
        /**
         * @private
         */
        get: function () {
            return this.ownerListLevelIn;
        },
        /**
         * @private
         */
        set: function (value) {
            this.ownerListLevelIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModifiedLevel.prototype, "modifiedListLevel", {
        /**
         * @private
         */
        get: function () {
            return this.modifiedListLevelIn;
        },
        /**
         * @private
         */
        set: function (value) {
            this.modifiedListLevelIn = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ModifiedLevel.prototype.destroy = function () {
        this.ownerListLevel = undefined;
        this.modifiedListLevel = undefined;
    };
    return ModifiedLevel;
}());
/**
 * @private
 */
var ModifiedParagraphFormat = /** @__PURE__ @class */ (function () {
    function ModifiedParagraphFormat(ownerFormat, modifiedFormat) {
        this.ownerFormatIn = undefined;
        this.modifiedFormatIn = undefined;
        this.ownerFormat = ownerFormat;
        this.modifiedFormat = modifiedFormat;
    }
    Object.defineProperty(ModifiedParagraphFormat.prototype, "ownerFormat", {
        /**
         * @private
         */
        get: function () {
            return this.ownerFormatIn;
        },
        /**
         * @private
         */
        set: function (value) {
            this.ownerFormatIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModifiedParagraphFormat.prototype, "modifiedFormat", {
        /**
         * hidden
         */
        get: function () {
            return this.modifiedFormatIn;
        },
        /**
         * @private
         */
        set: function (value) {
            this.modifiedFormatIn = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ModifiedParagraphFormat.prototype.destroy = function () {
        this.ownerFormat = undefined;
        this.modifiedFormat.destroy();
        this.modifiedFormat = undefined;
    };
    return ModifiedParagraphFormat;
}());
/**
 * @private
 */
var RowHistoryFormat = /** @__PURE__ @class */ (function () {
    function RowHistoryFormat(startingPoint, rowFormat) {
        this.startingPoint = startingPoint;
        this.rowFormat = rowFormat;
        this.rowHeightType = rowFormat.heightType;
    }
    RowHistoryFormat.prototype.revertChanges = function (isRedo, owner) {
        //backup current format values.
        var currentRowHeightType = this.rowFormat.heightType;
        //Restore old values.
        owner.editorModule.tableResize.updateRowHeight(this.rowFormat.ownerBase, isRedo ? this.displacement : (-this.displacement));
        owner.viewer.layout.reLayoutTable(this.rowFormat.ownerBase.ownerTable);
        if (this.rowFormat.heightType !== this.rowHeightType) {
            this.rowFormat.heightType = this.rowHeightType;
        }
        //backup the current format values for redo.
        this.rowHeightType = currentRowHeightType;
    };
    return RowHistoryFormat;
}());
/**
 * @private
 */
var TableHistoryInfo = /** @__PURE__ @class */ (function () {
    function TableHistoryInfo(table, owner) {
        this.tableHolder = new WTableHolder();
        this.tableFormat = new TableFormatHistoryInfo();
        this.rows = [];
        this.owner = owner;
        this.copyProperties(table);
    }
    TableHistoryInfo.prototype.copyProperties = function (table) {
        if (table.tableHolder) {
            this.tableHolder = table.tableHolder.clone();
        }
        if (table.tableFormat) {
            this.tableFormat.leftIndent = table.tableFormat.leftIndent;
            this.tableFormat.preferredWidth = table.tableFormat.preferredWidth;
            this.tableFormat.preferredWidthType = table.tableFormat.preferredWidthType;
            this.tableFormat.allowAutoFit = table.tableFormat.allowAutoFit;
        }
        for (var i = 0; i < table.childWidgets.length; i++) {
            var row = table.childWidgets[i];
            var rowFormat = new RowFormatHistoryInfo();
            rowFormat.gridBefore = row.rowFormat.gridBefore;
            rowFormat.gridBeforeWidth = row.rowFormat.gridBeforeWidth;
            rowFormat.gridBeforeWidthType = row.rowFormat.gridBeforeWidthType;
            rowFormat.gridAfter = row.rowFormat.gridAfter;
            rowFormat.gridAfterWidth = row.rowFormat.gridAfterWidth;
            rowFormat.gridAfterWidthType = row.rowFormat.gridAfterWidthType;
            for (var j = 0; j < row.childWidgets.length; j++) {
                var cell = row.childWidgets[j];
                var cellFormat = new CellFormatHistoryInfo();
                cellFormat.columnIndex = cell.columnIndex;
                cellFormat.columnSpan = cell.cellFormat.columnSpan;
                cellFormat.preferredWidth = cell.cellFormat.preferredWidth;
                cellFormat.preferredWidthType = cell.cellFormat.preferredWidthType;
                rowFormat.cells.push(cellFormat);
            }
            this.rows.push(rowFormat);
        }
        this.tableHierarchicalIndex = this.owner.selection.getHierarchicalIndex(table, '0');
    };
    TableHistoryInfo.prototype.destroy = function () {
        this.tableHierarchicalIndex = undefined;
        if (this.tableHolder) {
            this.tableHolder.destroy();
            this.tableHolder = undefined;
        }
        if (this.tableFormat) {
            this.tableFormat = null;
        }
        if (this.rows) {
            this.rows = [];
            this.rows = undefined;
        }
    };
    return TableHistoryInfo;
}());
/**
 * @private
 */
var TableFormatHistoryInfo = /** @__PURE__ @class */ (function () {
    function TableFormatHistoryInfo() {
        /* tslint:disable:no-empty */
    }
    return TableFormatHistoryInfo;
}());
/**
 * @private
 */
var RowFormatHistoryInfo = /** @__PURE__ @class */ (function () {
    function RowFormatHistoryInfo() {
        this.cells = [];
    }
    return RowFormatHistoryInfo;
}());
/**
 * @private
 */
var CellFormatHistoryInfo = /** @__PURE__ @class */ (function () {
    function CellFormatHistoryInfo() {
        /* tslint:disable:no-empty */
    }
    return CellFormatHistoryInfo;
}());
/**
 * @private
 */
var CellHistoryFormat = /** @__PURE__ @class */ (function () {
    function CellHistoryFormat(point) {
        this.startingPoint = point; // starting point preserved to calculate the displacement on after cell resizing finished.
    }
    return CellHistoryFormat;
}());

/**
 * @private
 */
var BaseHistoryInfo = /** @__PURE__ @class */ (function () {
    function BaseHistoryInfo(node) {
        this.ownerIn = node;
        this.viewer = node.viewer;
        this.modifiedPropertiesIn = [];
        this.modifiedNodeLength = [];
        this.removedNodesIn = [];
    }
    Object.defineProperty(BaseHistoryInfo.prototype, "owner", {
        //Properties
        //gets owner control
        /**
         * gets the owner control
         * @private
         */
        get: function () { return this.ownerIn; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseHistoryInfo.prototype, "editorHistory", {
        /**
         * gets or sets action
         * @private
         */
        get: function () {
            return this.owner.editorHistory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseHistoryInfo.prototype, "action", {
        /**
         * gets or sets action
         * @private
         */
        get: function () { return this.actionIn; },
        set: function (value) { this.actionIn = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseHistoryInfo.prototype, "modifiedProperties", {
        /**
         * gets modified properties
         * @returns Object
         * @private
         */
        get: function () { return this.modifiedPropertiesIn; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseHistoryInfo.prototype, "removedNodes", {
        /**
         * @private
         */
        get: function () {
            return this.removedNodesIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseHistoryInfo.prototype, "selectionStart", {
        /**
         * Gets or Sets the selection start
         * @private
         */
        //gets or sets selection start
        get: function () { return this.selectionStartIn; },
        set: function (value) { this.selectionStartIn = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseHistoryInfo.prototype, "selectionEnd", {
        /**
         * Gets or Sets the selection end
         * @private
         */
        get: function () { return this.selectionEndIn; },
        set: function (value) { this.selectionEndIn = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseHistoryInfo.prototype, "insertPosition", {
        /**
         * Gets or sets the insert position
         * @private
         */
        get: function () { return this.insertPositionIn; },
        set: function (value) { this.insertPositionIn = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseHistoryInfo.prototype, "endPosition", {
        /**
         * Gets or sets end position
         * @private
         */
        get: function () { return this.endPositionIn; },
        set: function (value) { this.endPositionIn = value; },
        enumerable: true,
        configurable: true
    });
    /**
     * Update the selection
     * @param selection
     * @private
     */
    BaseHistoryInfo.prototype.updateSelection = function () {
        var blockInfo = this.owner.selection.getParagraphInfo(this.owner.selection.start);
        this.selectionStart = this.owner.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        blockInfo = this.owner.selection.getParagraphInfo(this.owner.selection.end);
        this.selectionEnd = this.owner.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
    };
    BaseHistoryInfo.prototype.setBookmarkInfo = function (bookmark) {
        this.removedNodes.push({ 'bookmark': bookmark, 'startIndex': bookmark.indexInOwner, 'endIndex': bookmark.reference.indexInOwner });
    };
    BaseHistoryInfo.prototype.setEditRangeInfo = function (editStart) {
        // tslint:disable-next-line:max-line-length
        this.removedNodes.push({ 'editStart': editStart, 'startIndex': editStart.indexInOwner, 'endIndex': editStart.editRangeEnd.indexInOwner });
    };
    BaseHistoryInfo.prototype.revertBookmark = function () {
        var bookmarkInfo = this.removedNodes[0];
        var bookmark = bookmarkInfo.bookmark;
        if (this.editorHistory.isUndoing) {
            this.viewer.bookmarks.add(bookmark.name, bookmark);
            bookmark.line.children.splice(bookmarkInfo.startIndex, 0, bookmark);
            bookmark.reference.line.children.splice(bookmarkInfo.endIndex, 0, bookmark.reference);
            this.editorHistory.recordChanges(this);
        }
        else {
            this.owner.editorModule.deleteBookmarkInternal(bookmark);
            this.editorHistory.undoStack.push(this);
        }
    };
    BaseHistoryInfo.prototype.revertComment = function () {
        var editPosition = this.insertPosition;
        var comment = this.removedNodes[0];
        var insert = false;
        if (this.action === 'InsertCommentWidget') {
            insert = (this.editorHistory.isRedoing);
        }
        else if (this.action === 'DeleteCommentWidget') {
            insert = (this.editorHistory.isUndoing);
        }
        if (insert) {
            if (comment) {
                if (comment.isReply) {
                    this.owner.editor.addReplyComment(comment, this.insertPosition);
                }
                else {
                    this.owner.editor.addCommentWidget(comment, false);
                }
            }
        }
        else {
            var commentElement = this.owner.editor.getCommentElementBox(editPosition);
            this.owner.editor.deleteCommentWidget(commentElement);
        }
    };
    BaseHistoryInfo.prototype.revertEditRangeRegion = function () {
        var editRangeInfo = this.removedNodes[0];
        var editStart = editRangeInfo.editStart;
        if (this.editorHistory.isUndoing) {
            var user = editStart.user === '' ? editStart.group : editStart.user;
            this.owner.editor.updateRangeCollection(editStart, user);
            editStart.line.children.splice(editRangeInfo.startIndex, 0, editStart);
            editStart.editRangeEnd.line.children.splice(editRangeInfo.endIndex, 0, editStart.editRangeEnd);
            this.editorHistory.recordChanges(this);
        }
        else {
            this.owner.editorModule.removeUserRestrictionsInternal(editStart);
            this.editorHistory.undoStack.push(this);
        }
        this.owner.editor.fireContentChange();
    };
    /**
     * Reverts this instance
     * @private
     */
    // tslint:disable: max-func-body-length
    BaseHistoryInfo.prototype.revert = function () {
        if (this.action === 'DeleteBookmark') {
            this.revertBookmark();
            return;
        }
        if (this.action === 'RemoveEditRange') {
            this.revertEditRangeRegion();
            return;
        }
        if (this.action === 'InsertCommentWidget' || this.action === 'DeleteCommentWidget') {
            this.revertComment();
            return;
        }
        this.owner.isShiftingEnabled = true;
        var selectionStartTextPosition = undefined;
        var selectionEndTextPosition = undefined;
        var start = this.selectionStart;
        var end = this.selectionEnd;
        var isForwardSelection = TextPosition.isForwardSelection(start, end);
        if (this.modifiedProperties.length > 0 || this.action === 'Selection' || this.action === 'ClearCharacterFormat'
            || this.action === 'ClearParagraphFormat') {
            selectionStartTextPosition = this.owner.selection.getTextPosBasedOnLogicalIndex(start);
            selectionEndTextPosition = this.owner.selection.getTextPosBasedOnLogicalIndex(end);
            this.revertModifiedProperties(selectionStartTextPosition, selectionEndTextPosition);
        }
        else {
            var sel = this.owner.selection;
            var deletedNodes = this.removedNodes;
            this.removedNodesIn = [];
            var isForward = TextPosition.isForwardSelection(this.insertPosition, this.endPosition);
            var insertTextPosition = sel.getTextPosBasedOnLogicalIndex(isForward ? this.insertPosition : this.endPosition);
            var endTextPosition = sel.getTextPosBasedOnLogicalIndex(isForward ? this.endPosition : this.insertPosition);
            if (insertTextPosition.isAtSamePosition(endTextPosition)) {
                sel.selectContent(insertTextPosition, true);
            }
            else {
                sel.selectPosition(insertTextPosition, endTextPosition);
            }
            if (this.action === 'InsertHyperlink' && this.editorHistory.isRedoing) {
                var fieldBegin = this.owner.selection.getHyperlinkField();
                if (!isNullOrUndefined(fieldBegin)) {
                    var offset = (fieldBegin.line).getOffset(fieldBegin, 0);
                    insertTextPosition.setPositionParagraph(fieldBegin.line, offset);
                    this.owner.selection.start.setPositionInternal(insertTextPosition);
                    offset = fieldBegin.fieldEnd.line.getOffset(fieldBegin.fieldEnd, 1);
                    endTextPosition.setPositionParagraph(fieldBegin.fieldEnd.line, offset);
                }
            }
            this.editorHistory.currentBaseHistoryInfo = this;
            this.selectionStart = this.insertPosition;
            this.insertPosition = undefined;
            this.selectionEnd = this.endPosition;
            this.endPosition = undefined;
            var isRemoveContent = false;
            if (!insertTextPosition.isAtSamePosition(endTextPosition)) {
                isRemoveContent = this.action === 'BackSpace' || this.action === 'Delete' || this.action === 'ClearCells'
                    || this.action === 'DeleteCells';
                if (!(isRemoveContent) && this.action !== 'MergeCells' && this.action !== 'InsertRowAbove'
                    && this.action !== 'InsertRowBelow' && this.action !== 'InsertColumnLeft'
                    && this.action !== 'InsertColumnRight' && this.action !== 'Borders'
                    && this.action !== 'DeleteTable' && this.action !== 'DeleteColumn' && this.action !== 'DeleteRow') {
                    sel.end.setPositionInternal(endTextPosition);
                    if (!this.owner.selection.isEmpty) {
                        if (this.editorHistory.isRedoing) {
                            this.owner.editorModule.removeSelectedContents(sel);
                        }
                        else {
                            this.owner.editorModule.deleteSelectedContents(sel, true);
                        }
                        if (!isNullOrUndefined(this.editorHistory.currentHistoryInfo) &&
                            this.editorHistory.currentHistoryInfo.action === 'PageBreak' && this.viewer.blockToShift) {
                            this.viewer.layout.shiftLayoutedItems();
                        }
                    }
                }
            }
            var isRedoAction = this.editorHistory.isRedoing && !isRemoveContent;
            this.revertModifiedNodes(deletedNodes, isRedoAction, isForwardSelection ? start : end, start === end);
            if (isRemoveContent) {
                this.removeContent(insertTextPosition, endTextPosition);
            }
            //this.owner.editorModule.reLayout(this.viewer.selection);
        }
        var isSelectionChanged = false;
        if ((this.editorHistory.isUndoing && isNullOrUndefined(this.editorHistory.currentHistoryInfo)) ||
            ((this.action === 'InsertRowAbove' || this.action === 'Borders' || this.action === 'InsertRowBelow'
                || this.action === 'InsertColumnLeft'
                || this.action === 'InsertColumnRight') && (this.editorHistory.isRedoing
                || this.editorHistory.currentHistoryInfo.action === 'Paste'))) {
            selectionStartTextPosition = this.owner.selection.getTextPosBasedOnLogicalIndex(start);
            selectionEndTextPosition = this.owner.selection.getTextPosBasedOnLogicalIndex(end);
            this.owner.selection.selectRange(selectionStartTextPosition, selectionEndTextPosition);
            isSelectionChanged = true;
        }
        // Updates insert position of history info instance.
        this.insertPosition = start;
        this.endPosition = end;
        this.owner.editorModule.reLayout(this.owner.selection, this.owner.selection.isEmpty);
        if (isSelectionChanged) {
            this.viewer.scrollToPosition(this.owner.selection.start, this.owner.selection.end);
        }
        this.highlightListText();
    };
    BaseHistoryInfo.prototype.highlightListText = function () {
        if (!isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
            // tslint:disable-next-line:max-line-length
            if (this.action === 'ListCharacterFormat' || (this.editorHistory.currentHistoryInfo.action === 'ListSelect' && this.action === 'ListFormat')) {
                var selectionStartTextPosition = this.owner.selection.getTextPosBasedOnLogicalIndex(this.selectionStart);
                var widget = selectionStartTextPosition.currentWidget;
                this.viewer.selection.highlightListText(widget);
            }
        }
    };
    BaseHistoryInfo.prototype.removeContent = function (insertTextPosition, endTextPosition) {
        //If the base parent of the insert text position and end text position is null 
        //then the paragraphs already removed.
        //Example scenario: In table editing that is delete cells operation 
        // we will backed up the entire table ad it will be replaced on undo operation.
        //At that time if the positions are in table 
        //which is already replaced in undo (revert modified nodes method) then the base parent of the paragraph will be null.
        //So again, selecting the content and deleting is unnecessary
        // and it will cause improper position updates and null reference exceptions. 
        if ((!isNullOrUndefined(insertTextPosition.paragraph.containerWidget) &&
            insertTextPosition.paragraph.containerWidget instanceof BodyWidget &&
            (!isNullOrUndefined(endTextPosition.paragraph.containerWidget)
                && endTextPosition.paragraph.containerWidget instanceof BodyWidget))
            || (!isNullOrUndefined(insertTextPosition.paragraph.containerWidget)
                && !isNullOrUndefined(endTextPosition.paragraph.containerWidget)
                && insertTextPosition.paragraph.containerWidget instanceof TableCellWidget
                && endTextPosition.paragraph.containerWidget instanceof TableCellWidget
                && !isNullOrUndefined(insertTextPosition.paragraph.bodyWidget))) {
            //Removes if any empty paragraph is added while delete.
            this.owner.selection.selectRange(insertTextPosition, endTextPosition);
            var isDelete = (this.action === 'BackSpace') ? true : false;
            this.owner.editorModule.deleteSelectedContents(this.owner.selection, isDelete);
        }
    };
    BaseHistoryInfo.prototype.revertModifiedProperties = function (start, end) {
        if (this.action === 'CellFormat' || this.action === 'CellOptions' || this.action === 'TableOptions') {
            this.owner.isShiftingEnabled = false;
        }
        this.owner.selection.selectRange(start, end);
        if (this.action === 'RowResizing' || this.action === 'CellResizing') {
            this.revertResizing();
        }
        else if (this.action === 'CellOptions' || this.action === 'TableOptions') {
            this.revertTableDialogProperties(this.action);
        }
        else if (this.action !== 'Selection') {
            this.revertProperties();
        }
    };
    // Redoes the Action
    BaseHistoryInfo.prototype.redoAction = function () {
        var editor = this.owner.editorModule;
        switch (this.action) {
            case 'BackSpace':
                editor.singleBackspace(this.owner.selection, true);
                break;
            case 'Delete':
                editor.singleDelete(this.owner.selection, true);
                break;
            case 'DeleteTable':
                editor.deleteTable();
                break;
            case 'DeleteColumn':
                editor.deleteColumn();
                break;
            case 'DeleteRow':
                editor.deleteRow();
                break;
            case 'MergeCells':
                editor.mergeSelectedCellsInTable();
                break;
            case 'InsertRowAbove':
                editor.insertRow(true);
                break;
            case 'InsertRowBelow':
                editor.insertRow(false);
                break;
            case 'InsertColumnLeft':
                editor.insertColumn(true);
                break;
            case 'InsertColumnRight':
                editor.insertColumn(true);
                break;
            case 'SectionBreak':
                editor.insertSection(this.owner.selection, true);
                break;
            case 'TableAutoFitToContents':
                editor.autoFitTable('FitToContents');
                break;
            case 'TableAutoFitToWindow':
                editor.autoFitTable('FitToWindow');
                break;
            case 'TableFixedColumnWidth':
                editor.autoFitTable('FixedColumnWidth');
                break;
        }
    };
    /**
     * Revert the modified nodes
     * @param  {WNode[]} deletedNodes
     * @param  {boolean} isRedoAction
     * @param  {string} start
     * @param  {boolean} isEmptySelection
     */
    BaseHistoryInfo.prototype.revertModifiedNodes = function (deletedNodes, isRedoAction, start, isEmptySelection) {
        if (isRedoAction && (this.action === 'BackSpace' || this.action === 'Delete' || this.action === 'DeleteTable'
            || this.action === 'DeleteColumn' || this.action === 'DeleteRow' || this.action === 'InsertRowAbove' ||
            this.action === 'InsertRowBelow' || this.action === 'InsertColumnLeft' || this.action === 'InsertColumnRight'
            || this.action === 'MergeCells' || this.action === 'SectionBreak' || this.action === 'TableAutoFitToContents' ||
            this.action === 'TableAutoFitToWindow' || this.action === 'TableFixedColumnWidth')) {
            this.redoAction();
            if (this.action === 'SectionBreak') {
                return;
            }
        }
        if (deletedNodes.length > 0) {
            if ((this.editorHistory.isUndoing && (this.action === 'DeleteCells' || this.action === 'DeleteColumn'
                || this.action === 'DeleteRow' || this.action === 'MergeCells'))
                || (this.action === 'InsertRowAbove' || this.action === 'InsertRowBelow' || this.action === 'InsertColumnLeft'
                    || this.action === 'ClearCells' || this.action === 'InsertColumnRight' || this.action === 'Borders' ||
                    this.action === 'TableAutoFitToContents' || this.action === 'TableAutoFitToWindow' ||
                    this.action === 'TableFixedColumnWidth')) {
                var insertIndex = this.selectionStart;
                var block = this.owner.editorModule.getBlock({ index: insertIndex }).node;
                var lastNode = deletedNodes[deletedNodes.length - 1];
                if ((block instanceof TableWidget || block.previousRenderedWidget instanceof TableWidget || block.isInsideTable)
                    && lastNode instanceof TableWidget) {
                    if (block instanceof ParagraphWidget && !block.isInsideTable) {
                        block = block.previousRenderedWidget;
                    }
                    block = block.combineWidget(this.viewer);
                    this.owner.editorModule.insertTableInternal(block, lastNode, false);
                    deletedNodes.splice(deletedNodes.indexOf(lastNode), 1);
                }
                else if (lastNode instanceof TableWidget) {
                    this.owner.editorModule.insertBlock(lastNode);
                }
            }
            else {
                var initialStart = start;
                var block = this.owner.editorModule.getBlock({ index: initialStart }).node;
                // initialStart = blockObj.position;
                if (deletedNodes.length > 0 && (this.action === 'BackSpace' && isEmptySelection
                    || (!(block instanceof TableWidget) && !(block instanceof HeaderFooterWidget)))) {
                    var lastNode = deletedNodes[0];
                    if (this.action === 'SectionBreak' && lastNode instanceof BodyWidget ||
                        !isNullOrUndefined(this.editorHistory.currentHistoryInfo) &&
                            this.editorHistory.currentHistoryInfo.action === 'PageBreak') {
                        lastNode = deletedNodes[1];
                    }
                    if (lastNode instanceof ParagraphWidget && this.owner.selection.start.offset > 0) {
                        this.owner.editorModule.insertNewParagraphWidget(lastNode, true);
                        deletedNodes.splice(deletedNodes.indexOf(lastNode), 1);
                        if (isNullOrUndefined(block)) {
                            // tslint:disable-next-line:max-line-length
                            var nextBlock = this.viewer.selection.getNextParagraphBlock(lastNode.getSplitWidgets().pop());
                            this.owner.selection.getNextRenderedBlock(lastNode);
                            if (isNullOrUndefined(nextBlock)) {
                                //Sets the selection as starting of last paragraph.
                                this.owner.selection.selectParagraphInternal(lastNode, true);
                            }
                        }
                    }
                    if (lastNode instanceof TableWidget && this.owner.selection.start.offset > 0) {
                        var firstBlock = deletedNodes[deletedNodes.length - 1];
                        if (firstBlock instanceof ParagraphWidget) {
                            this.owner.editorModule.insertNewParagraphWidget(firstBlock, true);
                            deletedNodes.splice(deletedNodes.indexOf(firstBlock), 1);
                            if (isNullOrUndefined(block)) {
                                // tslint:disable-next-line:max-line-length
                                var nextBlock = this.viewer.selection.getNextParagraphBlock(firstBlock.getSplitWidgets().pop());
                                if (isNullOrUndefined(nextBlock)) {
                                    //Sets the selection as starting of last paragraph.
                                    this.owner.selection.selectParagraphInternal(firstBlock, true);
                                }
                            }
                        }
                    }
                }
                if (deletedNodes.length > 0) {
                    var firstNode = deletedNodes[deletedNodes.length - 1];
                    if (block instanceof TableWidget) {
                        block = block.combineWidget(this.viewer);
                        if (firstNode instanceof TableWidget) {
                            this.owner.editorModule.insertTableInternal(block, firstNode, true);
                            deletedNodes.splice(deletedNodes.indexOf(firstNode), 1);
                            this.insertPosition = start;
                            var nextWidget = firstNode.getSplitWidgets().pop();
                            if (nextWidget.nextRenderedWidget instanceof TableWidget) {
                                block = nextWidget.nextRenderedWidget;
                            }
                            else {
                                initialStart = start;
                                block = this.owner.editorModule.getBlock({ index: initialStart }).node;
                            }
                        }
                    }
                    //Checks if first node is paragraph and current insert position is paragraph end.
                    // tslint:disable-next-line:max-line-length
                    if (firstNode instanceof ParagraphWidget && this.owner.selection.start.offset > 0
                        && this.owner.selection.start.offset === this.owner.selection.getLineLength(this.owner.selection.start.paragraph.lastChild)) {
                        var editor = this.owner.editorModule;
                        editor.insertNewParagraphWidget(firstNode, false);
                        deletedNodes.splice(deletedNodes.indexOf(firstNode), 1);
                        //Removes the intermediate empty paragraph instance.
                        if (this.action !== 'Paste') {
                            editor.removeBlock(this.owner.selection.start.paragraph);
                        }
                        // tslint:disable-next-line:max-line-length
                        var paragraph = this.viewer.selection.getNextParagraphBlock(firstNode.getSplitWidgets().pop());
                        if (!isNullOrUndefined(paragraph)) {
                            this.owner.selection.selectParagraphInternal(paragraph, true);
                        }
                    }
                    else if (deletedNodes[0] instanceof TableWidget && deletedNodes.length !== 1) {
                        var nextNode = deletedNodes[1];
                        if (nextNode instanceof ParagraphWidget && nextNode.isEmpty()) {
                            deletedNodes.splice(deletedNodes.indexOf(nextNode), 1);
                        }
                    }
                }
                if (deletedNodes.length > 0) {
                    if (block instanceof TableWidget) {
                        block = block.combineWidget(this.viewer);
                    }
                    this.insertRemovedNodes(deletedNodes, block);
                }
            }
        }
    };
    BaseHistoryInfo.prototype.insertRemovedNodes = function (deletedNodes, block) {
        for (var i = deletedNodes.length - 1, index = 0; i > -1; i--) {
            var node = deletedNodes[i];
            if (node instanceof ElementBox) {
                this.owner.editorModule.insertInlineInSelection(this.owner.selection, node);
            }
            else if (node instanceof BlockWidget) {
                if (node instanceof TableRowWidget) {
                    if (block instanceof TableWidget) {
                        block.childWidgets.splice(index, 0, node);
                        this.owner.editorModule.updateNextBlocksIndex(node, true);
                        if (i === 0 || !(deletedNodes[i - 1] instanceof TableRowWidget)) {
                            // tslint:disable-next-line:max-line-length
                            this.viewer.layout.layoutBodyWidgetCollection(block.index, block.containerWidget, block, false);
                        }
                    }
                }
                else if (block instanceof TableWidget) {
                    this.owner.editorModule.insertBlockTable(this.owner.selection, node, block);
                }
                else {
                    this.owner.editorModule.insertBlock(node);
                }
            }
            else if (node instanceof BodyWidget) {
                this.owner.editorModule.insertSection(this.owner.selection, false);
            }
        }
        deletedNodes = [];
    };
    BaseHistoryInfo.prototype.revertResizing = function () {
        this.editorHistory.currentBaseHistoryInfo = this;
        if (this.action === 'RowResizing') {
            if (this.modifiedProperties[0] instanceof RowHistoryFormat) {
                // tslint:disable-next-line:max-line-length
                this.modifiedProperties[0].revertChanges(this.editorHistory.isRedoing, this.owner);
            }
        }
        else {
            if (this.modifiedProperties[0] instanceof TableHistoryInfo) {
                //selected cell resizing the condition checks done based on the selected widgets only. so need to highlight the selection.
                if (this.owner.selection.selectedWidgets.length === 0) {
                    this.owner.selection.highlightSelection(true);
                }
                var prevTableHistoryInfo = this.modifiedProperties[0];
                var position = prevTableHistoryInfo.tableHierarchicalIndex;
                var block = this.owner.editorModule.getBlock({ index: position }).node;
                if (block instanceof TableWidget) {
                    var tableResize = this.owner.editorModule.tableResize;
                    this.owner.editor.setOffsetValue(this.owner.selection);
                    block = block.combineWidget(this.owner.viewer);
                    tableResize.currentResizingTable = block;
                    this.modifiedProperties.splice(0, 1);
                    if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
                        var tableHistoryInfoCurrent = new TableHistoryInfo(block, this.owner);
                        this.modifiedProperties.splice(0, 0, tableHistoryInfoCurrent);
                        this.owner.isLayoutEnabled = false;
                        tableResize.applyProperties(tableResize.currentResizingTable, prevTableHistoryInfo);
                        tableResize.currentResizingTable.isGridUpdated = true;
                        this.owner.isLayoutEnabled = true;
                        tableResize.updateGridValue(tableResize.currentResizingTable, false);
                        prevTableHistoryInfo.destroy();
                        prevTableHistoryInfo = undefined;
                    }
                }
            }
        }
    };
    BaseHistoryInfo.prototype.revertTableDialogProperties = function (action) {
        this.owner.isShiftingEnabled = false;
        this.editorHistory.currentBaseHistoryInfo = this;
        this.currentPropertyIndex = 0;
        if (action === 'CellOptions') {
            var selection = this.owner.selection;
            var cellFormat = this.modifiedProperties[0];
            this.owner.editorModule.updateCellMargins(selection, cellFormat);
        }
        else if (action === 'TableOptions') {
            this.owner.tableOptionsDialogModule.applyTableOptionsHelper(this.modifiedProperties[0]);
        }
        this.currentPropertyIndex = 0;
        this.owner.isShiftingEnabled = true;
    };
    /**
     * Add modified properties for section format
     * @param  {WSectionFormat} format
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    BaseHistoryInfo.prototype.addModifiedPropertiesForSection = function (format, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            var modifiedProperties = this.modifiedProperties;
            var previousFormat = (this.currentPropertyIndex < modifiedProperties.length ?
                modifiedProperties[this.currentPropertyIndex] : modifiedProperties[modifiedProperties.length - 1]);
            if (isNullOrUndefined(property)) {
                value = previousFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = format.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = format.cloneFormat();
                }
            }
            else {
                value = previousFormat.getPropertyValue(property);
                previousFormat.copyFormat(format);
            }
            this.currentPropertyIndex++;
        }
        else {
            if (isNullOrUndefined(property)) {
                this.modifiedProperties.push(format.cloneFormat());
            }
            else {
                var currentFormat = new WSectionFormat();
                currentFormat.copyFormat(format);
                this.modifiedProperties.push(currentFormat);
            }
        }
        return value;
    };
    /**
     * Add the modified properties for character format
     * @param  {WCharacterFormat} format
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    BaseHistoryInfo.prototype.addModifiedProperties = function (format, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length           
            var previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            var skipRemove = false;
            if (format.ownerBase instanceof ElementBox) {
                var prevLength = this.modifiedNodeLength[this.currentPropertyIndex];
                if (format.ownerBase.length < prevLength) {
                    skipRemove = true;
                    this.modifiedNodeLength[this.currentPropertyIndex] = format.ownerBase.length;
                    this.modifiedNodeLength.splice(this.currentPropertyIndex + 1, 0, prevLength - format.ownerBase.length);
                    //Adds a copy of character format at next position for splitted inline.
                    var nextFormat = new WCharacterFormat(undefined);
                    nextFormat.copyFormat(previousFormat);
                    this.modifiedProperties.splice(this.currentPropertyIndex + 1, 0, nextFormat);
                }
            }
            if (this.action === 'ClearCharacterFormat') {
                if (this.editorHistory.isUndoing) {
                    value = previousFormat;
                    if (!skipRemove) {
                        this.modifiedProperties.splice(this.currentPropertyIndex, 1);
                        this.currentPropertyIndex--;
                    }
                }
                else {
                    this.modifiedProperties.push(format.cloneFormat());
                }
            }
            else {
                value = previousFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = format.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = format.cloneFormat();
                }
            }
            this.currentPropertyIndex++;
        }
        else {
            if (isNullOrUndefined(property)) {
                this.modifiedProperties.push(format.cloneFormat());
            }
            else {
                var currentFormat = new WCharacterFormat(undefined);
                currentFormat.copyFormat(format);
                this.modifiedProperties.push(currentFormat);
            }
            if (format.ownerBase instanceof ElementBox) {
                this.modifiedNodeLength.push(format.ownerBase.length);
            }
            else {
                this.modifiedNodeLength.push(0);
            }
        }
        return value;
    };
    /**
     * Add the modified properties for paragraph format
     * @param  {WParagraphFormat} format
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    BaseHistoryInfo.prototype.addModifiedPropertiesForParagraphFormat = function (format, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            var previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            if (this.action === 'ClearParagraphFormat') {
                if (this.editorHistory.isUndoing) {
                    value = previousFormat;
                    this.modifiedProperties.splice(this.currentPropertyIndex, 1);
                    this.currentPropertyIndex--;
                }
                else {
                    this.modifiedProperties.push(format.cloneFormat());
                }
                this.currentPropertyIndex++;
                return value;
            }
            if (isNullOrUndefined(property)) {
                value = previousFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = format.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = format.cloneFormat();
                }
                this.currentPropertyIndex++;
                return value;
            }
            if (property === 'listFormat') {
                value = new WParagraphFormat(undefined);
                value.copyFormat(previousFormat);
                previousFormat.listFormat = new WListFormat();
                previousFormat.listFormat.copyFormat(format.listFormat);
                this.currentPropertyIndex++;
                return value;
            }
            if (property === 'styleName') {
                if (!isNullOrUndefined(previousFormat.baseStyle)) {
                    value = new WParagraphStyle();
                    value.copyStyle(previousFormat.baseStyle);
                    this.currentPropertyIndex++;
                    if (!isNullOrUndefined(format.baseStyle)) {
                        previousFormat.baseStyle = new WParagraphStyle();
                        previousFormat.baseStyle.copyStyle(format.baseStyle);
                    }
                    return value;
                }
                else {
                    if (!isNullOrUndefined(format.baseStyle)) {
                        previousFormat.baseStyle = new WParagraphStyle();
                        previousFormat.baseStyle.copyStyle(format.baseStyle);
                    }
                    return undefined;
                }
            }
            value = previousFormat.getPropertyValue(property);
            previousFormat.copyFormat(format);
            this.currentPropertyIndex++;
        }
        else {
            if (isNullOrUndefined(property)) {
                this.modifiedProperties.push(format.cloneFormat());
            }
            else {
                var currentFormat = new WParagraphFormat(undefined);
                currentFormat.copyFormat(format);
                this.modifiedProperties.push(currentFormat);
            }
        }
        return value;
    };
    /**
     * @private
     */
    BaseHistoryInfo.prototype.addModifiedPropertiesForContinueNumbering = function (paragraphFormat, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            var previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            value = previousFormat;
            if (this.currentPropertyIndex < this.modifiedProperties.length) {
                this.modifiedProperties[this.currentPropertyIndex] = paragraphFormat.cloneFormat();
            }
            else {
                this.modifiedProperties[this.modifiedProperties.length - 1] = paragraphFormat.cloneFormat();
            }
            this.currentPropertyIndex++;
            return value;
        }
        else {
            var currentFormat = new WParagraphFormat();
            currentFormat.copyFormat(paragraphFormat);
            this.modifiedProperties.push(currentFormat);
        }
        return value;
    };
    /**
     * @param listFormat
     * @param value
     * @private
     */
    BaseHistoryInfo.prototype.addModifiedPropertiesForRestartNumbering = function (listFormat, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            var listId = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            value = listId;
            if (this.currentPropertyIndex < this.modifiedProperties.length) {
                this.modifiedProperties[this.currentPropertyIndex] = listFormat.listId;
            }
            else {
                this.modifiedProperties[this.modifiedProperties.length - 1] = listFormat.listId;
            }
            this.currentPropertyIndex++;
            return value;
        }
        else {
            this.modifiedProperties.push(listFormat.listId);
        }
        return value;
    };
    /**
     * Add modified properties for list format
     * @param  {WListLevel} listLevel
     * @private
     */
    BaseHistoryInfo.prototype.addModifiedPropertiesForList = function (listLevel) {
        var value;
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            var previousLevel = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            value = previousLevel;
            previousLevel = new ModifiedLevel(listLevel, this.owner.editorModule.cloneListLevel(listLevel));
            if (this.currentPropertyIndex < this.modifiedProperties.length) {
                this.modifiedProperties[this.currentPropertyIndex] = previousLevel;
            }
            else {
                this.modifiedProperties[this.modifiedProperties.length - 1] = previousLevel;
            }
            this.currentPropertyIndex++;
        }
        else {
            this.modifiedProperties.push(new ModifiedLevel(listLevel, this.owner.editorModule.cloneListLevel(listLevel)));
            value = listLevel;
        }
        return value;
    };
    /**
     * Revert the properties
     * @param  {SelectionRange} selectionRange
     */
    BaseHistoryInfo.prototype.revertProperties = function () {
        this.editorHistory.currentBaseHistoryInfo = this;
        this.currentPropertyIndex = 0;
        var property = this.getProperty();
        this.viewer.owner.editorModule.setOffsetValue(this.viewer.selection);
        if (this.action === 'ClearCharacterFormat' || this.modifiedProperties[0] instanceof WCharacterFormat) {
            if (this.action === 'ListCharacterFormat') {
                this.owner.editorModule.updateListCharacterFormat(this.viewer.selection, property, undefined);
                return;
            }
            this.owner.editorModule.updateSelectionCharacterFormatting(property, undefined, false);
        }
        else if (this.action === 'ClearParagraphFormat' || this.modifiedProperties[0] instanceof WParagraphFormat) {
            if (this.action === 'ContinueNumbering') {
                // tslint:disable-next-line:max-line-length
                this.owner.editorModule.revertContinueNumbering(this.owner.selection, this.modifiedProperties[0]);
                return;
            }
            if (this.action === 'StyleName' && this.modifiedProperties[0] instanceof WParagraphFormat) {
                // tslint:disable-next-line:max-line-length
                this.owner.editorModule.updateSelectionParagraphFormatting(property, this.modifiedProperties[0].baseStyle, false);
                return;
            }
            var selection = this.owner.viewer.selection;
            var isBidiList = (selection.paragraphFormat.bidi ||
                (this.modifiedProperties[0] instanceof WParagraphFormat && this.modifiedProperties[0]).bidi) && (selection.paragraphFormat.listId !== -1 || property === 'listFormat');
            if (!isBidiList) {
                this.owner.viewer.layout.isBidiReLayout = true;
            }
            this.owner.editorModule.updateSelectionParagraphFormatting(property, undefined, false);
            if (!isBidiList) {
                this.owner.viewer.layout.isBidiReLayout = false;
            }
        }
        else if (this.modifiedProperties[0] instanceof WSectionFormat) {
            this.owner.editorModule.updateSectionFormat(property, undefined);
        }
        else if (this.action === 'RestartNumbering') {
            this.owner.editorModule.restartListAtInternal(this.owner.selection, this.modifiedProperties[0]);
            return;
        }
        else if (this.modifiedProperties[0] instanceof ImageFormat) {
            this.owner.selection.updateImageSize(this.modifiedProperties[0]);
        }
        else if (this.modifiedProperties[0] instanceof ModifiedLevel) {
            var modified = new Dictionary();
            for (var i = 0; i < this.modifiedProperties.length; i++) {
                var modifiedLevel = this.modifiedProperties[i];
                // modified.modifiedLevels.add(modifiedLevel.ownerListLevel.levelNumber, modifiedLevel);
                modified.add(i, modifiedLevel);
            }
            this.editorHistory.updateListChanges(modified);
            modified.destroy();
            modified = undefined;
        }
        else if (this.modifiedProperties[0] instanceof WTableFormat) {
            this.owner.editorModule.updateTableFormat(this.owner.selection, property, undefined);
        }
        else if (this.modifiedProperties[0] instanceof WCellFormat) {
            this.owner.isShiftingEnabled = true;
            this.owner.editorModule.updateCellFormat(this.owner.selection, property, undefined);
        }
        else if (this.modifiedProperties[0] instanceof WRowFormat) {
            this.owner.editorModule.updateRowFormat(this.owner.selection, property, undefined);
        }
        this.currentPropertyIndex = 0;
        if (this.action === 'ClearCharacterFormat' || this.action === 'ClearParagraphFormat') {
            this.owner.editorModule.getOffsetValue(this.viewer.selection);
        }
    };
    /**
     * Add modified properties for cell options dialog
     * @param  {WCellFormat} format
     * @param  {WTable} table
     * @private
     */
    BaseHistoryInfo.prototype.addModifiedCellOptions = function (applyFormat, format, table) {
        var currentFormat;
        if (isNullOrUndefined(applyFormat.bottomMargin) && isNullOrUndefined(applyFormat.topMargin)
            && isNullOrUndefined(applyFormat.rightMargin) && isNullOrUndefined(applyFormat.leftMargin)) {
            currentFormat = this.copyCellOptions(table.tableFormat);
        }
        else {
            currentFormat = this.copyCellOptions(applyFormat);
        }
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            var previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            format = previousFormat;
            if (this.currentPropertyIndex < this.modifiedProperties.length) {
                this.modifiedProperties[this.currentPropertyIndex] = this.copyCellOptions(applyFormat);
            }
            else {
                this.modifiedProperties[this.modifiedProperties.length - 1] = this.copyCellOptions(applyFormat);
            }
            this.currentPropertyIndex++;
            return format;
        }
        else {
            this.modifiedProperties.push(currentFormat);
        }
        return format;
    };
    BaseHistoryInfo.prototype.copyCellOptions = function (format) {
        var cellFormat = new WCellFormat();
        cellFormat.topMargin = format.topMargin;
        cellFormat.rightMargin = format.rightMargin;
        cellFormat.bottomMargin = format.bottomMargin;
        cellFormat.leftMargin = format.leftMargin;
        return cellFormat;
    };
    /**
     * Add modified properties for cell options dialog
     * @param  {WTableFormat} format
     * @private
     */
    BaseHistoryInfo.prototype.addModifiedTableOptions = function (format) {
        var currentFormat = this.copyTableOptions(format);
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length           
            var previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            if (this.currentPropertyIndex < this.modifiedProperties.length) {
                this.modifiedProperties.splice(this.currentPropertyIndex, 1, currentFormat);
            }
            else {
                this.modifiedProperties.splice(this.modifiedProperties.length - 1, 1, currentFormat);
            }
            this.currentPropertyIndex++;
        }
        else {
            this.modifiedProperties.push(currentFormat);
        }
    };
    BaseHistoryInfo.prototype.copyTableOptions = function (format) {
        var tableFormat = new WTableFormat();
        tableFormat.topMargin = format.topMargin;
        tableFormat.rightMargin = format.rightMargin;
        tableFormat.bottomMargin = format.bottomMargin;
        tableFormat.leftMargin = format.leftMargin;
        tableFormat.cellSpacing = format.cellSpacing;
        return tableFormat;
    };
    BaseHistoryInfo.prototype.getProperty = function () {
        switch (this.action) {
            case 'Bold':
                return 'bold';
            case 'Italic':
                return 'italic';
            case 'FontColor':
                return 'fontColor';
            case 'FontFamily':
                return 'fontFamily';
            case 'FontSize':
                return 'fontSize';
            case 'HighlightColor':
                return 'highlightColor';
            case 'BaselineAlignment':
                return 'baselineAlignment';
            case 'Strikethrough':
                return 'strikethrough';
            case 'Underline':
                return 'underline';
            case 'AfterSpacing':
                return 'afterSpacing';
            case 'BeforeSpacing':
                return 'beforeSpacing';
            case 'LeftIndent':
                return 'leftIndent';
            case 'RightIndent':
                return 'rightIndent';
            case 'FirstLineIndent':
                return 'firstLineIndent';
            case 'LineSpacingType':
                return 'lineSpacingType';
            case 'LineSpacing':
                return 'lineSpacing';
            case 'TextAlignment':
                return 'textAlignment';
            case 'ListFormat':
                return 'listFormat';
            case 'PageHeight':
                return 'pageHeight';
            case 'PageWidth':
                return 'pageWidth';
            case 'TableAlignment':
                return 'tableAlignment';
            case 'TableLeftIndent':
                return 'leftIndent';
            case 'DefaultCellSpacing':
                return 'cellSpacing';
            case 'LeftMargin':
            case 'CellLeftMargin':
            case 'DefaultCellLeftMargin':
                return 'leftMargin';
            case 'RightMargin':
            case 'CellRightMargin':
            case 'DefaultCellRightMargin':
                return 'rightMargin';
            case 'TopMargin':
            case 'CellTopMargin':
            case 'DefaultCellTopMargin':
                return 'topMargin';
            case 'BottomMargin':
            case 'CellBottomMargin':
            case 'DefaultCellBottomMargin':
                return 'bottomMargin';
            case 'CellContentVerticalAlignment':
                return 'verticalAlignment';
            case 'RowHeight':
                return 'height';
            case 'RowHeightType':
                return 'heightType';
            case 'RowHeader':
                return 'isHeader';
            case 'AllowBreakAcrossPages':
                return 'allowBreakAcrossPages';
            case 'TablePreferredWidth':
            case 'CellPreferredWidth':
                return 'preferredWidth';
            case 'TablePreferredWidthType':
            case 'CellPreferredWidthType':
                return 'preferredWidthType';
            case 'Shading':
                return 'shading';
            case 'StyleName':
                return 'styleName';
            case 'ParagraphBidi':
            case 'TableBidi':
                return 'bidi';
            case 'ContextualSpacing':
                return 'contextualSpacing';
        }
        return undefined;
    };
    BaseHistoryInfo.prototype.getCharacterPropertyValue = function (property, modifiedProperty) {
        var value;
        if (property === 'bold') {
            value = modifiedProperty.bold;
        }
        else if (property === 'italic') {
            value = modifiedProperty.italic;
        }
        else if (property === 'fontColor') {
            value = modifiedProperty.fontColor;
        }
        else if (property === 'fontFamily') {
            value = modifiedProperty.fontFamily;
        }
        else if (property === 'fontSize') {
            value = modifiedProperty.fontSize;
        }
        else if (property === 'highlightColor') {
            value = modifiedProperty.highlightColor;
        }
        else if (property === 'baselineAlignment') {
            value = modifiedProperty.baselineAlignment;
        }
        else if (property === 'strikethrough') {
            value = modifiedProperty.strikethrough;
        }
        else if (property === 'underline') {
            value = modifiedProperty.underline;
        }
        return value;
    };
    /**
     * Add modified properties for table format
     * @param  {WTableFormat} format
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    BaseHistoryInfo.prototype.addModifiedTableProperties = function (format, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            var previousTableFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            if (isNullOrUndefined(property)) {
                value = previousTableFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = format.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = format.cloneFormat();
                }
                this.currentPropertyIndex++;
                return value;
            }
            if (property === 'shading') {
                value = previousTableFormat.shading;
            }
            else {
                value = previousTableFormat.getPropertyValue(property);
            }
            previousTableFormat.copyFormat(format);
            this.currentPropertyIndex++;
        }
        else {
            var currentFormat = new WTableFormat();
            currentFormat.copyFormat(format);
            this.modifiedProperties.push(currentFormat);
        }
        return value;
    };
    /**
     * Add modified properties for row format
     * @param  {WRowFormat} rowFormat
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    BaseHistoryInfo.prototype.addModifiedRowProperties = function (rowFormat, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            var previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            if (isNullOrUndefined(property)) {
                value = previousFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = rowFormat.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = rowFormat.cloneFormat();
                }
                this.currentPropertyIndex++;
                return value;
            }
            value = previousFormat.getPropertyValue(property);
            previousFormat.copyFormat(rowFormat);
            this.currentPropertyIndex++;
        }
        else {
            var currentFormat = new WRowFormat();
            currentFormat.copyFormat(rowFormat);
            this.modifiedProperties.push(currentFormat);
        }
        return value;
    };
    /**
     * Add modified properties for cell format
     * @param  {WCellFormat} cellFormat
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    BaseHistoryInfo.prototype.addModifiedCellProperties = function (cellFormat, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            var previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            if (isNullOrUndefined(property)) {
                value = previousFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = cellFormat.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = cellFormat.cloneFormat();
                }
                this.currentPropertyIndex++;
                return value;
            }
            if (property === 'shading') {
                value = previousFormat.shading;
            }
            else {
                value = previousFormat.getPropertyValue(property);
            }
            previousFormat.copyFormat(cellFormat);
            this.currentPropertyIndex++;
        }
        else {
            var currentFormat = new WCellFormat();
            currentFormat.copyFormat(cellFormat);
            this.modifiedProperties.push(currentFormat);
        }
        return value;
    };
    /**
     * @private
     */
    BaseHistoryInfo.prototype.destroy = function () {
        this.selectionStart = undefined;
        this.selectionEnd = undefined;
        this.insertPosition = undefined;
        this.endPosition = undefined;
        if (!isNullOrUndefined(this.modifiedNodeLength)) {
            this.modifiedNodeLength = [];
            this.modifiedNodeLength = undefined;
        }
        if (!isNullOrUndefined(this.modifiedProperties)) {
            for (var i = 0; i < this.modifiedProperties.length; i++) {
                var property = this.modifiedProperties[i];
                if (property instanceof WCharacterFormat) {
                    property.destroy();
                }
                else if (property instanceof WParagraphFormat) {
                    property.destroy();
                }
                else if (property instanceof WSectionFormat) {
                    property.destroy();
                }
                else if (property instanceof ModifiedLevel) {
                    property.destroy();
                }
                this.modifiedProperties.splice(this.modifiedProperties.indexOf(property), 1);
                i--;
            }
            this.modifiedPropertiesIn = undefined;
        }
        if (!isNullOrUndefined(this.removedNodes)) {
            for (var i = 0; i < this.removedNodes.length; i++) {
                var node = this.removedNodes[i];
                if (node instanceof ParagraphWidget) {
                    node.destroyInternal(this.viewer);
                }
                else if (node instanceof ElementBox) {
                    node.destroy();
                }
                this.removedNodes.splice(this.removedNodes.indexOf(node), 1);
                i--;
            }
            this.removedNodesIn = undefined;
        }
        this.ownerIn = undefined;
    };
    return BaseHistoryInfo;
}());

/**
 * Image resizer implementation.
 */
var ImageResizer = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for image resizer module.
     * @param {DocumentEditor} node
     * @param {LayoutViewer} viewer
     * @private
     */
    function ImageResizer(node, viewer) {
        /**
         * @private
         */
        this.resizeContainerDiv = undefined;
        /**
         * @private
         */
        this.topLeftRect = undefined;
        /**
         * @private
         */
        this.topMiddleRect = undefined;
        /**
         * @private
         */
        this.topRightRect = undefined;
        /**
         * @private
         */
        this.bottomLeftRect = undefined;
        /**
         * @private
         */
        this.bottomMiddleRect = undefined;
        /**
         * @private
         */
        this.bottomRightRect = undefined;
        /**
         * @private
         */
        this.leftMiddleRect = undefined;
        /**
         * @private
         */
        this.rightMiddleRect = undefined;
        /**
         * @private
         */
        this.topLeftRectParent = undefined;
        /**
         * @private
         */
        this.topMiddleRectParent = undefined;
        /**
         * @private
         */
        this.topRightRectParent = undefined;
        /**
         * @private
         */
        this.bottomLeftRectParent = undefined;
        /**
         * @private
         */
        this.bottomMiddleRectParent = undefined;
        /**
         * @private
         */
        this.bottomRightRectParent = undefined;
        /**
         * @private
         */
        this.leftMiddleRectParent = undefined;
        /**
         * @private
         */
        this.rightMiddleRectParent = undefined;
        /**
         * @private
         */
        this.resizeMarkSizeIn = 7;
        /**
         * @private
         */
        this.selectedImageWidget = undefined;
        /**
         * @private
         */
        this.baseHistoryInfo = undefined;
        /**
         * @private
         */
        this.isImageResizing = false;
        /**
         * @private
         */
        this.isImageResizerVisible = false;
        /**
         * @private
         */
        this.isImageMoveToNextPage = false;
        /**
         * @private
         */
        this.selectedResizeElement = undefined;
        /**
         * @private
         */
        this.topValue = undefined;
        /**
         * @private
         */
        this.leftValue = undefined;
        this.owner = node;
        this.selectedImageWidget = new Dictionary();
        this.viewer = viewer;
        this.imageResizerPoints = new ImageResizingPoints();
        if (isNullOrUndefined(this.imageResizerDiv) && this.viewer && this.viewer.pageContainer) {
            this.initializeImageResizer();
        }
    }
    Object.defineProperty(ImageResizer.prototype, "currentImageElementBox", {
        /**
         * Gets or Sets the current image element box.
         * @private
         */
        get: function () {
            return this.currentImageElementBoxIn;
        },
        /**
         * @private
         */
        set: function (value) {
            this.currentImageElementBoxIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageResizer.prototype, "resizeMarkSize", {
        /**
         * Gets or Sets the resize mark size.
         * @private
         */
        get: function () {
            return this.resizeMarkSizeIn;
        },
        /**
         * @private
         */
        set: function (value) {
            this.resizeMarkSizeIn = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets module name.
     */
    ImageResizer.prototype.getModuleName = function () {
        return 'ImageResizer';
    };
    //Image Resizing Methods
    /**
     * Sets image resizer position.
     * @param {number} x - Specifies for image resizer left value.
     * @param {number} y - Specifies for image resizer top value.
     * @param {number} width - Specifies for image resizer width value.
     * @param {number} height - Specifies for image resizer height value.
     * @private
     */
    ImageResizer.prototype.setImageResizerPositions = function (x, y, width, height) {
        this.imageResizerDivElement.style.top = y.toString() + 'px';
        this.imageResizerDivElement.style.left = x.toString() + 'px';
        this.imageResizerDivElement.style.borderWidth = '0px';
        this.imageResizerDivElement.style.height = height + 'px';
        this.imageResizerDivElement.style.width = width + 'px';
        this.imageResizerDivElement.style.backgroundColor = 'transparent';
        this.imageResizerDivElement.style.overflow = 'hidden';
        this.imageResizerDivElement.style.position = 'absolute';
    };
    /**
     * Creates image resizer DOM element.
     * @private
     */
    ImageResizer.prototype.initializeImageResizer = function () {
        this.imageResizerDivElement = document.createElement('div');
        this.imageResizerDivElement.style.zIndex = '1';
        this.imageResizerDivElement.style.display = 'none';
        this.viewer.pageContainer.appendChild(this.imageResizerDivElement);
    };
    /**
     * Position an image resizer
     * @param {ImageElementBox} elementBox - Specifies the image position.
     * @private
     */
    ImageResizer.prototype.positionImageResizer = function (elementBox) {
        this.selectedImageWidget.clear();
        // Initializes the image resizer on demand, i.e at the time of selecting an image for the first time.
        var resizeDiv;
        if (!isNullOrUndefined(this.viewer.currentPage)) {
            resizeDiv = this.imageResizerDivElement;
        }
        if (!isNullOrUndefined(resizeDiv) && !resizeDiv.contains(this.imageResizerDiv)) {
            this.imageResizerDiv = this.initResizeMarks(resizeDiv, this);
        }
        this.imageResizerDiv.style.width = (elementBox.width) + 'px';
        this.imageResizerDiv.style.height = (elementBox.height) + 'px';
        this.currentImageElementBox = elementBox;
        var lineWidget = elementBox.line;
        var top = this.viewer.selection.getTop(lineWidget) + elementBox.margin.top;
        var left = this.viewer.selection.getLeftInternal(lineWidget, elementBox, 0);
        var page = this.viewer.selection.getPage(lineWidget.paragraph);
        this.currentPage = page;
        var x = 0;
        var y = 0;
        if (!isNullOrUndefined(resizeDiv)) {
            this.imageResizerDivElement.style.display = 'block';
            resizeDiv.style.width = page.boundingRectangle.width + 'px';
            resizeDiv.style.height = page.boundingRectangle.height + 'px';
            resizeDiv.style.left = page.boundingRectangle.x + 'px';
            resizeDiv.style.top = page.boundingRectangle.y + 'px';
            resizeDiv.style.borderWidth = '0px';
            resizeDiv.style.backgroundColor = 'transparent';
            resizeDiv.style.overflow = 'hidden';
            resizeDiv.style.position = 'absolute';
        }
        var horizontalWidth = 0;
        var pageWidth = this.viewer.getPageWidth(page);
        var pagelayout = this.viewer;
        // tslint:disable-next-line:max-line-length
        horizontalWidth = parseFloat(this.imageResizerDivElement.style.width);
        x = (this.viewer.visibleBounds.width - horizontalWidth * this.viewer.zoomFactor) / 2;
        if (x < 30) {
            x = 30;
        }
        if (pageWidth < horizontalWidth) {
            x += (horizontalWidth - pageWidth) * this.viewer.zoomFactor / 2;
        }
        // tslint:disable-next-line:max-line-length           
        y = page.boundingRectangle.y * this.viewer.zoomFactor + (this.viewer.pages.indexOf(page) + 1) * 20 * (1 - this.viewer.zoomFactor);
        var currentPageDiv = this.imageResizerDivElement;
        var currentPageDivWidth = parseFloat(currentPageDiv.style.width);
        var currentPageDivHeight = parseFloat(currentPageDiv.style.height);
        var imageResizerDivWidth = parseFloat(this.imageResizerDiv.style.width);
        var imageResizerDivHeight = parseFloat(this.imageResizerDiv.style.height);
        var margin = (this.resizeMarkSize - 1) / 2;
        var width = imageResizerDivWidth + 2 * margin;
        var height = imageResizerDivHeight + 2 * margin;
        if (width > (currentPageDivWidth - left) * this.viewer.zoomFactor + margin) {
            width = (currentPageDivWidth - left) * this.viewer.zoomFactor;
        }
        if (height > (currentPageDivHeight - top) * this.viewer.zoomFactor + margin) {
            height = (currentPageDivHeight - top) * this.viewer.zoomFactor;
        }
        // if (width < imageResizerDivHeight + margin || height < imageResizerDivHeight + margin) {
        // }
        // tslint:disable-next-line:max-line-length
        this.imageResizerDivElement.style.width = parseInt(this.imageResizerDivElement.style.width.replace('px', ''), 10) * this.viewer.zoomFactor + 'px';
        this.imageResizerDivElement.style.height = parseInt(this.imageResizerDivElement.style.height.replace('px', ''), 10) * this.viewer.zoomFactor + 'px';
        height = this.viewer.render.getScaledValue(elementBox.height);
        width = this.viewer.render.getScaledValue(elementBox.width);
        left = this.viewer.render.getScaledValue(left);
        top = this.viewer.render.getScaledValue(top);
        this.setImageResizerPosition(left, top, width, height, this);
        if (!this.selectedImageWidget.containsKey(lineWidget)) {
            var selectedImageInfo = new SelectedImageInfo(elementBox.height, elementBox.width);
            this.selectedImageWidget.add(lineWidget, selectedImageInfo);
        }
    };
    /**
     * Shows the image resizer.
     * @private
     */
    ImageResizer.prototype.showImageResizer = function () {
        if (!isNullOrUndefined(this.imageResizerDivElement)) {
            this.imageResizerDivElement.style.display = '';
        }
        if (!isNullOrUndefined(this.resizeContainerDiv)) {
            this.resizeContainerDiv.style.display = '';
        }
        if (!isNullOrUndefined(this.bottomLeftRect)) {
            this.bottomLeftRect.style.display = '';
            this.bottomLeftRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.bottomRightRect)) {
            this.bottomRightRect.style.display = '';
            this.bottomRightRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.bottomMiddleRect)) {
            this.bottomMiddleRect.style.display = '';
            this.bottomMiddleRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.rightMiddleRect)) {
            this.rightMiddleRect.style.display = '';
            this.rightMiddleRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.topRightRect)) {
            this.topRightRect.style.display = '';
            this.topRightRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.topLeftRect)) {
            this.topLeftRect.style.display = '';
            this.topLeftRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.leftMiddleRect)) {
            this.leftMiddleRect.style.display = '';
            this.leftMiddleRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.topMiddleRect)) {
            this.topMiddleRect.style.display = '';
            this.topMiddleRectParent.style.display = '';
        }
        this.isImageResizerVisible = true;
    };
    /**
     * Hides the image resizer.
     * @private
     */
    ImageResizer.prototype.hideImageResizer = function () {
        if (!isNullOrUndefined(this.imageResizerDivElement)) {
            this.imageResizerDivElement.style.display = 'none';
        }
        if (!isNullOrUndefined(this.resizeContainerDiv)) {
            this.resizeContainerDiv.style.display = 'none';
        }
        if (!isNullOrUndefined(this.bottomLeftRect)) {
            this.bottomLeftRect.style.display = 'none';
            this.bottomLeftRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.bottomRightRect)) {
            this.bottomRightRect.style.display = 'none';
            this.bottomRightRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.bottomMiddleRect)) {
            this.bottomMiddleRect.style.display = 'none';
            this.bottomMiddleRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.rightMiddleRect)) {
            this.rightMiddleRect.style.display = 'none';
            this.rightMiddleRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.topRightRect)) {
            this.topRightRect.style.display = 'none';
            this.topRightRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.topLeftRect)) {
            this.topLeftRect.style.display = 'none';
            this.topLeftRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.leftMiddleRect)) {
            this.leftMiddleRect.style.display = 'none';
            this.leftMiddleRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.topMiddleRect)) {
            this.topMiddleRect.style.display = 'none';
            this.topMiddleRectParent.style.display = 'none';
        }
        this.isImageResizerVisible = false;
        this.currentPage = undefined;
    };
    /**
     * Initialize the resize marks.
     * @param {HTMLElement} resizeDiv - Specifies to appending resizer container div element.
     * @param {ImageResizer} imageResizer - Specifies to creating div element of each position.
     * @private
     */
    // tslint:disable:max-func-body-length
    ImageResizer.prototype.initResizeMarks = function (resizeDiv, imageResizer) {
        this.initResizeContainerDiv(imageResizer);
        resizeDiv.appendChild(imageResizer.resizeContainerDiv);
        imageResizer.topRightRectParent = document.createElement('div');
        imageResizer.topRightRectParent.style.cursor = 'ne-resize';
        imageResizer.topRightRectParent.id = this.viewer.owner.containerId + '_TopRightRectParent';
        this.applyProperties(imageResizer.topRightRectParent);
        imageResizer.topRightRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topRightRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topRightRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.topRightRectParent);
        imageResizer.topRightRect = document.createElement('div');
        imageResizer.topRightRect.id = this.viewer.owner.containerId + '_TopRightRect';
        imageResizer.topRightRect.style.cursor = 'ne-resize';
        this.applyProperties(imageResizer.topRightRect);
        resizeDiv.appendChild(imageResizer.topRightRect);
        imageResizer.topLeftRectParent = document.createElement('div');
        imageResizer.topLeftRectParent.style.cursor = 'nw-resize';
        imageResizer.topLeftRectParent.id = this.viewer.owner.containerId + '_TopLeftRectParent';
        this.applyProperties(imageResizer.topLeftRectParent);
        imageResizer.topLeftRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topLeftRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topLeftRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.topLeftRectParent);
        imageResizer.topLeftRect = document.createElement('div');
        imageResizer.topLeftRect.id = this.viewer.owner.containerId + '_TopLeftRect';
        imageResizer.topLeftRect.style.cursor = 'nw-resize';
        this.applyProperties(imageResizer.topLeftRect);
        resizeDiv.appendChild(imageResizer.topLeftRect);
        imageResizer.topMiddleRectParent = document.createElement('div');
        imageResizer.topMiddleRectParent.style.cursor = 'n-resize';
        imageResizer.topMiddleRectParent.id = this.viewer.owner.containerId + '_TopMiddleRectParent';
        this.applyProperties(imageResizer.topMiddleRectParent);
        imageResizer.topMiddleRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topMiddleRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topMiddleRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.topMiddleRectParent);
        imageResizer.topMiddleRect = document.createElement('div');
        imageResizer.topMiddleRect.id = this.viewer.owner.containerId + '_TopMiddleRect';
        imageResizer.topMiddleRect.style.cursor = 'n-resize';
        this.applyProperties(imageResizer.topMiddleRect);
        resizeDiv.appendChild(imageResizer.topMiddleRect);
        imageResizer.bottomRightRectParent = document.createElement('div');
        imageResizer.bottomRightRectParent.style.cursor = 'se-resize';
        imageResizer.bottomRightRectParent.id = this.viewer.owner.containerId + '_BottomRightRectParent';
        this.applyProperties(imageResizer.bottomRightRectParent);
        imageResizer.bottomRightRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomRightRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomRightRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.bottomRightRectParent);
        imageResizer.bottomRightRect = document.createElement('div');
        imageResizer.bottomRightRect.id = this.viewer.owner.containerId + '_BottomRightRect';
        imageResizer.bottomRightRect.style.cursor = 'se-resize';
        this.applyProperties(imageResizer.bottomRightRect);
        resizeDiv.appendChild(imageResizer.bottomRightRect);
        imageResizer.bottomLeftRectParent = document.createElement('div');
        imageResizer.bottomLeftRectParent.style.cursor = 'sw-resize';
        imageResizer.bottomLeftRectParent.id = this.viewer.owner.containerId + '_BottomLeftRectParent';
        this.applyProperties(imageResizer.bottomLeftRectParent);
        imageResizer.bottomLeftRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomLeftRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomLeftRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.bottomLeftRectParent);
        imageResizer.bottomLeftRect = document.createElement('div');
        imageResizer.bottomLeftRect.id = this.viewer.owner.containerId + '_BottomLeftRect';
        imageResizer.bottomLeftRect.style.cursor = 'sw-resize';
        this.applyProperties(imageResizer.bottomLeftRect);
        resizeDiv.appendChild(imageResizer.bottomLeftRect);
        imageResizer.bottomMiddleRectParent = document.createElement('div');
        imageResizer.bottomMiddleRectParent.style.cursor = 's-resize';
        imageResizer.bottomMiddleRectParent.id = this.viewer.owner.containerId + '_BottomMiddleRectParent';
        this.applyProperties(imageResizer.bottomMiddleRectParent);
        imageResizer.bottomMiddleRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomMiddleRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomMiddleRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.bottomMiddleRectParent);
        imageResizer.bottomMiddleRect = document.createElement('div');
        imageResizer.bottomMiddleRect.id = this.viewer.owner.containerId + '_BottomMiddleRect';
        imageResizer.bottomMiddleRect.style.cursor = 's-resize';
        this.applyProperties(imageResizer.bottomMiddleRect);
        resizeDiv.appendChild(imageResizer.bottomMiddleRect);
        imageResizer.rightMiddleRectParent = document.createElement('div');
        imageResizer.rightMiddleRectParent.style.cursor = 'e-resize';
        imageResizer.rightMiddleRectParent.id = this.viewer.owner.containerId + '_RightMiddleRectParent';
        this.applyProperties(imageResizer.rightMiddleRectParent);
        imageResizer.rightMiddleRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.rightMiddleRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.rightMiddleRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.rightMiddleRectParent);
        imageResizer.rightMiddleRect = document.createElement('div');
        imageResizer.rightMiddleRect.id = this.viewer.owner.containerId + '_RightMiddleRect';
        imageResizer.rightMiddleRect.style.cursor = 'e-resize';
        this.applyProperties(imageResizer.rightMiddleRect);
        resizeDiv.appendChild(imageResizer.rightMiddleRect);
        imageResizer.leftMiddleRectParent = document.createElement('div');
        imageResizer.leftMiddleRectParent.style.cursor = 'w-resize';
        imageResizer.leftMiddleRectParent.id = this.viewer.owner.containerId + '_LeftMiddleRectParent';
        this.applyProperties(imageResizer.leftMiddleRectParent);
        imageResizer.leftMiddleRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.leftMiddleRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.leftMiddleRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.leftMiddleRectParent);
        imageResizer.leftMiddleRect = document.createElement('div');
        imageResizer.leftMiddleRect.id = this.viewer.owner.containerId + '_LeftMiddleRect';
        imageResizer.leftMiddleRect.style.cursor = 'w-resize';
        this.applyProperties(imageResizer.leftMiddleRect);
        resizeDiv.appendChild(imageResizer.leftMiddleRect);
        return imageResizer.resizeContainerDiv;
    };
    /**
     * Sets the image resizer position.
     * @param {number} left - Specifies for image resizer left value.
     * @param {number} top - Specifies for image resizer top value.
     * @param {number} width - Specifies for image resizer width value.
     * @param {number} height - Specifies for image resizer height value.
     * @param {ImageResizer} imageResizer - Specifies for image resizer.
     * @private
     */
    ImageResizer.prototype.setImageResizerPosition = function (left, top, width, height, imageResizer) {
        //Positions Updating For Image Resize Div
        imageResizer.resizeContainerDiv.style.width = width + 'px';
        imageResizer.resizeContainerDiv.style.height = height + 'px';
        imageResizer.resizeContainerDiv.style.left = left - 1 + 'px';
        imageResizer.resizeContainerDiv.style.top = top + 'px';
        //Positions Updating For Image Resizing Points
        imageResizer.topRightRect.style.left = ((left + width) - 5) + 'px';
        imageResizer.topRightRect.style.top = (top - 4) + 'px';
        imageResizer.topLeftRect.style.left = (left - 5) + 'px';
        imageResizer.topLeftRect.style.top = (top - 4) + 'px';
        imageResizer.topMiddleRect.style.left = ((parseFloat(imageResizer.topLeftRect.style.left) + (width / 2)) - 4) + 'px';
        imageResizer.topMiddleRect.style.top = (top - 4) + 'px';
        imageResizer.bottomRightRect.style.left = imageResizer.topRightRect.style.left;
        imageResizer.bottomRightRect.style.top = (parseFloat(imageResizer.topRightRect.style.top) + height) + 'px';
        imageResizer.bottomLeftRect.style.left = imageResizer.topLeftRect.style.left;
        imageResizer.bottomLeftRect.style.top = (parseFloat(imageResizer.topLeftRect.style.top) + height) + 'px';
        imageResizer.bottomMiddleRect.style.left = imageResizer.topMiddleRect.style.left;
        imageResizer.bottomMiddleRect.style.top = (parseFloat(imageResizer.topMiddleRect.style.top) + height) + 'px';
        imageResizer.rightMiddleRect.style.left = ((left + width) - 4) + 'px';
        imageResizer.rightMiddleRect.style.top = (parseFloat(imageResizer.topRightRect.style.top) + (height / 2)) + 'px';
        imageResizer.leftMiddleRect.style.left = imageResizer.topLeftRect.style.left;
        imageResizer.leftMiddleRect.style.top = (parseFloat(imageResizer.topLeftRect.style.top) + (height / 2)) + 'px';
        imageResizer.topRightRectParent.style.left = !this.viewer.isTouchInput ? ((left + width) - 8) + 'px' : ((left + width) - 15) + 'px';
        imageResizer.topRightRectParent.style.top = !this.viewer.isTouchInput ? (top - 7) + 'px' : (top - 15) + 'px';
        imageResizer.topLeftRectParent.style.left = !this.viewer.isTouchInput ? (left - 8) + 'px' : (left - 15) + 'px';
        imageResizer.topLeftRectParent.style.top = !this.viewer.isTouchInput ? (top - 7) + 'px' : (top - 15) + 'px';
        imageResizer.topMiddleRectParent.style.left = ((parseFloat(imageResizer.topLeftRectParent.style.left) + (width / 2)) - 4) + 'px';
        imageResizer.topMiddleRectParent.style.top = !this.viewer.isTouchInput ? (top - 7) + 'px' : (top - 15) + 'px';
        imageResizer.bottomRightRectParent.style.left = imageResizer.topRightRectParent.style.left;
        imageResizer.bottomRightRectParent.style.top = (parseFloat(imageResizer.topRightRectParent.style.top) + height) + 'px';
        imageResizer.bottomLeftRectParent.style.left = imageResizer.topLeftRectParent.style.left;
        imageResizer.bottomLeftRectParent.style.top = (parseFloat(imageResizer.topLeftRectParent.style.top) + height) + 'px';
        imageResizer.bottomMiddleRectParent.style.left = imageResizer.topMiddleRectParent.style.left;
        imageResizer.bottomMiddleRectParent.style.top = (parseFloat(imageResizer.topMiddleRectParent.style.top) + height) + 'px';
        // tslint:disable-next-line:max-line-length 
        imageResizer.rightMiddleRectParent.style.left = !this.viewer.isTouchInput ? ((left + width) - 7) + 'px' : ((left + width) - 15) + 'px';
        imageResizer.rightMiddleRectParent.style.top = (parseFloat(imageResizer.topRightRectParent.style.top) + (height / 2)) + 'px';
        imageResizer.leftMiddleRectParent.style.left = imageResizer.topLeftRectParent.style.left;
        imageResizer.leftMiddleRectParent.style.top = (parseFloat(imageResizer.topLeftRectParent.style.top) + (height / 2)) + 'px';
        this.setImageResizingPoints(imageResizer);
        if (this.viewer.isTouchInput) {
            this.applyPropertiesForTouch();
        }
        else {
            this.applyPropertiesForMouse();
        }
    };
    /**
     * Sets the image resizing points.
     * @param {ImageResizer} imageResizer - Specifies for position of each resizing elements.
     * @private
     */
    ImageResizer.prototype.setImageResizingPoints = function (imageResizer) {
        this.imageResizerPoints.resizeContainerDiv.x = parseFloat(imageResizer.resizeContainerDiv.style.left);
        this.imageResizerPoints.resizeContainerDiv.y = parseFloat(imageResizer.resizeContainerDiv.style.top);
        this.imageResizerPoints.bottomLeftRectParent.x = parseFloat(imageResizer.bottomLeftRectParent.style.left);
        this.imageResizerPoints.bottomLeftRectParent.y = parseFloat(imageResizer.bottomLeftRectParent.style.top);
        this.imageResizerPoints.bottomRightRectParent.x = parseFloat(imageResizer.bottomRightRectParent.style.left);
        this.imageResizerPoints.bottomRightRectParent.y = parseFloat(imageResizer.bottomRightRectParent.style.top);
        this.imageResizerPoints.bottomMiddleRectParent.x = parseFloat(imageResizer.bottomMiddleRectParent.style.left);
        this.imageResizerPoints.bottomMiddleRectParent.y = parseFloat(imageResizer.bottomMiddleRectParent.style.top);
        this.imageResizerPoints.topLeftRectParent.x = parseFloat(imageResizer.topLeftRectParent.style.left);
        this.imageResizerPoints.topLeftRectParent.y = parseFloat(imageResizer.topLeftRectParent.style.top);
        this.imageResizerPoints.topRightRectParent.x = parseFloat(imageResizer.topRightRectParent.style.left);
        this.imageResizerPoints.topRightRectParent.y = parseFloat(imageResizer.topRightRectParent.style.top);
        this.imageResizerPoints.topMiddleRectParent.x = parseFloat(imageResizer.topMiddleRectParent.style.left);
        this.imageResizerPoints.topMiddleRectParent.y = parseFloat(imageResizer.topMiddleRectParent.style.top);
        this.imageResizerPoints.leftMiddleRectParent.x = parseFloat(imageResizer.leftMiddleRectParent.style.left);
        this.imageResizerPoints.leftMiddleRectParent.y = parseFloat(imageResizer.leftMiddleRectParent.style.top);
        this.imageResizerPoints.rightMiddleRectParent.x = parseFloat(imageResizer.rightMiddleRectParent.style.left);
        this.imageResizerPoints.rightMiddleRectParent.y = parseFloat(imageResizer.rightMiddleRectParent.style.top);
    };
    /**
     * Initialize the resize container div element.
     * @param {ImageResizer} imageResizer - Specifies for creating resize container div element.
     * @private
     */
    ImageResizer.prototype.initResizeContainerDiv = function (imageResizer) {
        imageResizer.resizeContainerDiv = document.createElement('div');
        imageResizer.resizeContainerDiv.id = this.viewer.owner.containerId + '_ResizeDivElement';
        imageResizer.resizeContainerDiv.style.position = 'absolute';
        imageResizer.resizeContainerDiv.style.border = '1px solid #bfbfbf';
        imageResizer.resizeContainerDiv.style.zIndex = '30';
        imageResizer.resizeContainerDiv.style.backgroundColor = 'transparent';
        imageResizer.resizeContainerDiv.style.display = 'block';
    };
    /**
     * Apply the properties of each resize rectangle element.
     * @param {HTMLDivElement} resizeRectElement - Specifies for applying properties to resize rectangle element.
     * @private
     */
    ImageResizer.prototype.applyProperties = function (resizeRectElement) {
        resizeRectElement.style.position = 'absolute';
        resizeRectElement.style.width = '8px';
        resizeRectElement.style.height = '8px';
        resizeRectElement.style.fontSize = '0px';
        resizeRectElement.style.zIndex = ' 551';
        resizeRectElement.style.backgroundColor = '#ffffff';
        resizeRectElement.style.border = '1px solid #bfbfbf';
        resizeRectElement.style.boxShadow = '0 1px 2px 0 #bfbfbf 0.35';
        resizeRectElement.style.color = '#000000';
    };
    /**
     * Handles an image resizing.
     * @param {number} x  - Specifies for left value while resizing.
     * @param {number} y - Specifies for top value while resizing.
     */
    ImageResizer.prototype.handleImageResizing = function (touchPoint, prevX, prevY) {
        prevX = prevX / this.viewer.zoomFactor;
        prevY = prevY / this.viewer.zoomFactor;
        this.leftValue = isNullOrUndefined(this.leftValue) ? prevX : this.leftValue;
        this.topValue = isNullOrUndefined(this.topValue) ? prevY : this.topValue;
        var points;
        var id = this.selectedResizeElement.id.split('_');
        var currentElementId = id[id.length - 1];
        switch (currentElementId) {
            case 'TopRightRectParent':
                points = this.topRightResizing(touchPoint);
                prevX = points.left;
                prevY = points.top;
                break;
            case 'TopLeftRectParent':
                points = this.topLeftResizing(touchPoint);
                prevX = -points.left;
                prevY = -points.top;
                break;
            case 'TopMiddleRectParent':
                prevX = 0;
                prevY = this.topMiddleResizing(touchPoint);
                break;
            case 'BottomRightRectParent':
                points = this.bottomRightResizing(touchPoint);
                prevX = points.left;
                prevY = points.top;
                break;
            case 'BottomLeftRectParent':
                points = this.bottomLeftResizing(touchPoint);
                prevX = -points.left;
                prevY = -points.top;
                break;
            case 'BottomMiddleRectParent':
                prevY = touchPoint.y - prevY;
                prevX = 0;
                break;
            case 'RightMiddleRectParent':
                prevX = touchPoint.x - prevX;
                prevY = 0;
                break;
            case 'LeftMiddleRectParent':
                prevX = this.leftMiddleResizing(touchPoint);
                prevY = 0;
                break;
            default:
                break;
        }
        if (prevX !== 0 || prevY !== 0) {
            var widget = this.currentImageElementBox.line.paragraph;
            var image = this.currentImageElementBox;
            if (!isNullOrUndefined(widget) && widget.isInsideTable) {
                var cellWidget = widget.containerWidget;
                if (!isNullOrUndefined(cellWidget)) {
                    var rowWidget = cellWidget.containerWidget;
                    var imageHeight = HelperMethods.convertPointToPixel(image.height);
                    var widgetHeight = rowWidget.height - imageHeight;
                    if (prevY > 0 && rowWidget.y + widgetHeight + imageHeight + prevY > this.viewer.clientArea.bottom) {
                        this.isImageMoveToNextPage = true;
                    }
                }
            }
            // tslint:disable-next-line:max-line-length 
            if (this.owner.enableHistoryMode) {
                this.initHistoryForImageResizer(this.currentImageElementBox);
            }
            if (!isNullOrUndefined(this.currentImageElementBox)) {
                // tslint:disable-next-line:max-line-length   
                var width = this.currentImageElementBox.width + prevX > 10 ? this.currentImageElementBox.width + prevX : 10;
                // tslint:disable-next-line:max-line-length 
                var height = this.currentImageElementBox.height + prevY > 10 ? this.currentImageElementBox.height + prevY : 10;
                if (currentElementId === 'BottomRightRectParent'
                    || currentElementId === 'TopRightRectParent'
                    || currentElementId === 'BottomLeftRectParent'
                    || currentElementId === 'TopLeftRectParent') {
                    height = this.currentImageElementBox.height / this.currentImageElementBox.width * width;
                    width = this.currentImageElementBox.width / this.currentImageElementBox.height * height;
                }
                this.currentImageElementBox.width = width;
                this.currentImageElementBox.height = height;
                var owner = this.currentImageElementBox.line.paragraph;
                this.positionImageResizer(this.currentImageElementBox);
            }
            this.isImageResizing = true;
        }
    };
    /**
     * Handles image resizing on mouse.
     * @param {MouseEvent} event - Specifies for image resizing using mouse event.
     * @private
     */
    ImageResizer.prototype.handleImageResizingOnMouse = function (event) {
        if (!isNullOrUndefined(this.selectedResizeElement)) {
            var prevX = parseFloat(this.selectedResizeElement.style.left);
            var prevY = parseFloat(this.selectedResizeElement.style.top);
            var cursorPoint = new Point(event.offsetX, event.offsetY);
            var touchPoint = this.viewer.findFocusedPage(cursorPoint, true);
            this.handleImageResizing(touchPoint, prevX, prevY);
        }
    };
    ImageResizer.prototype.topMiddleResizing = function (touchPoint) {
        var prevY;
        if (this.topValue >= touchPoint.y) {
            prevY = this.topValue / touchPoint.y;
            this.topValue = touchPoint.y;
            if (this.viewer instanceof PageLayoutViewer) {
                if (this.topValue <= this.viewer.pageGap) {
                    prevY = 1;
                }
            }
        }
        else {
            prevY = -(touchPoint.y / this.topValue);
            this.topValue = touchPoint.y;
            if (this.topValue === 0) {
                prevY = -1;
            }
        }
        return prevY;
    };
    ImageResizer.prototype.leftMiddleResizing = function (touchPoint) {
        var prevX;
        if (this.leftValue >= touchPoint.x) {
            prevX = this.leftValue / touchPoint.x;
            this.leftValue = touchPoint.x;
            if (this.leftValue === 0) {
                prevX = 1;
                this.leftValue = parseFloat(this.selectedResizeElement.style.left);
            }
        }
        else {
            prevX = -(touchPoint.x / this.leftValue);
            this.leftValue = touchPoint.x;
        }
        return prevX;
    };
    ImageResizer.prototype.topRightResizing = function (touchPoint) {
        var points;
        if (this.leftValue <= touchPoint.x && this.topValue >= touchPoint.y) {
            points = this.getOuterResizingPoint(touchPoint);
        }
        else {
            points = this.getInnerResizingPoint(touchPoint);
        }
        return points;
    };
    ImageResizer.prototype.topLeftResizing = function (touchPoint) {
        var points;
        if (this.leftValue >= touchPoint.x && this.topValue >= touchPoint.y) {
            points = this.getOuterResizingPoint(touchPoint);
        }
        else {
            points = this.getInnerResizingPoint(touchPoint);
        }
        return points;
    };
    ImageResizer.prototype.bottomRightResizing = function (touchPoint) {
        var points;
        if (this.leftValue <= touchPoint.x && this.topValue <= touchPoint.y) {
            points = this.getOuterResizingPoint(touchPoint);
        }
        else {
            points = this.getInnerResizingPoint(touchPoint);
        }
        return points;
    };
    ImageResizer.prototype.bottomLeftResizing = function (touchPoint) {
        var points;
        if (this.leftValue >= touchPoint.x && this.topValue <= touchPoint.y) {
            points = this.getOuterResizingPoint(touchPoint);
        }
        else {
            points = this.getInnerResizingPoint(touchPoint);
        }
        return points;
    };
    ImageResizer.prototype.getOuterResizingPoint = function (touchPoint) {
        var prevX;
        var prevY;
        prevX = touchPoint.x - this.leftValue;
        this.leftValue = touchPoint.x;
        prevY = touchPoint.y - this.topValue;
        this.topValue = touchPoint.y;
        return { left: prevX, top: prevY };
    };
    ImageResizer.prototype.getInnerResizingPoint = function (touchPoint) {
        var prevX;
        var prevY;
        prevX = -(this.leftValue - touchPoint.x);
        this.leftValue = touchPoint.x;
        prevY = -(this.topValue - touchPoint.y);
        this.topValue = touchPoint.y;
        return { left: prevX, top: prevY };
    };
    /**
     * Handles image resizing on touch.
     * @param {TouchEvent} touchEvent - Specifies for image resizing using touch event.
     * @private
     */
    ImageResizer.prototype.handleImageResizingOnTouch = function (touchEvent) {
        if (!isNullOrUndefined(this.selectedResizeElement)) {
            var prevX = parseFloat(this.selectedResizeElement.style.left) + 24;
            var prevY = parseFloat(this.selectedResizeElement.style.top) + 24;
            var touch = touchEvent.touches;
            var cursorPoint = new Point(touch[0].clientX, touch[0].clientY);
            var touchPoint = this.viewer.findFocusedPage(cursorPoint, true);
            if (isNullOrUndefined(this.currentImageElementBox) || isNullOrUndefined(this.currentImageElementBox)) {
                return;
            }
            this.handleImageResizing(touchPoint, prevX, prevY);
        }
    };
    /**
     * Gets the image point of mouse.
     * @param {Point} touchPoint - Specifies for resizer cursor position.
     * @private
     */
    ImageResizer.prototype.getImagePoint = function (touchPoint) {
        var x = this.viewer.render.getScaledValue(touchPoint.x, 1);
        var y = this.viewer.render.getScaledValue(touchPoint.y, 2);
        touchPoint = new Point(x, y);
        var imageResizingPoints = this.imageResizerPoints;
        var resizePosition = '';
        var selectedElement = undefined;
        var bottomMiddle = imageResizingPoints.bottomMiddleRectParent;
        var bottomRight = imageResizingPoints.bottomRightRectParent;
        var bottomLeft = imageResizingPoints.bottomLeftRectParent;
        var topMiddle = imageResizingPoints.topMiddleRectParent;
        var topRight = imageResizingPoints.topRightRectParent;
        var topLeft = imageResizingPoints.topLeftRectParent;
        var rightMiddle = imageResizingPoints.rightMiddleRectParent;
        var leftMiddle = imageResizingPoints.leftMiddleRectParent;
        if (!isNullOrUndefined(this.bottomMiddleRectParent) && this.bottomMiddleRectParent.style.display !== 'none') {
            // tslint:disable-next-line:max-line-length   
            if ((touchPoint.x > bottomMiddle.x && touchPoint.x <= bottomMiddle.x + 15) && (touchPoint.y > bottomMiddle.y && touchPoint.y <= bottomMiddle.y + 15)) {
                selectedElement = this.bottomMiddleRectParent;
                resizePosition = 's-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > bottomRight.x && touchPoint.x <= bottomRight.x + 15) && (touchPoint.y > bottomRight.y && touchPoint.y <= bottomRight.y + 15)) {
                selectedElement = this.bottomRightRectParent;
                resizePosition = 'se-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > bottomLeft.x && touchPoint.x <= bottomLeft.x + 15) && (touchPoint.y > bottomLeft.y && touchPoint.y <= bottomLeft.y + 15)) {
                selectedElement = this.bottomLeftRectParent;
                resizePosition = 'sw-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > topMiddle.x && touchPoint.x <= topMiddle.x + 15) && (touchPoint.y > topMiddle.y && touchPoint.y <= topMiddle.y + 15)) {
                selectedElement = this.topMiddleRectParent;
                resizePosition = 'n-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > topRight.x && touchPoint.x <= topRight.x + 15) && (touchPoint.y > topRight.y && touchPoint.y <= topRight.y + 15)) {
                selectedElement = this.topRightRectParent;
                resizePosition = 'ne-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > topLeft.x && touchPoint.x <= topLeft.x + 15) && (touchPoint.y > topLeft.y && touchPoint.y <= topLeft.y + 15)) {
                selectedElement = this.topLeftRectParent;
                resizePosition = 'nw-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > leftMiddle.x && touchPoint.x <= leftMiddle.x + 15) && (touchPoint.y > leftMiddle.y && touchPoint.y <= leftMiddle.y + 15)) {
                selectedElement = this.leftMiddleRectParent;
                resizePosition = 'w-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > rightMiddle.x && touchPoint.x <= rightMiddle.x + 15) && (touchPoint.y > rightMiddle.y && touchPoint.y <= rightMiddle.y + 15)) {
                selectedElement = this.rightMiddleRectParent;
                resizePosition = 'e-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if (!isNullOrUndefined(this.resizeContainerDiv) && (touchPoint.x > parseFloat(this.resizeContainerDiv.style.left)
                && touchPoint.x <= (parseFloat(this.resizeContainerDiv.style.left) + parseFloat(this.resizeContainerDiv.style.width)))
                && (touchPoint.y > parseFloat(this.resizeContainerDiv.style.top)
                    // tslint:disable-next-line:max-line-length 
                    && touchPoint.y <= (parseFloat(this.resizeContainerDiv.style.top) + parseFloat(this.resizeContainerDiv.style.height)))) {
                resizePosition = 'move';
            }
        }
        return { 'selectedElement': selectedElement, 'resizePosition': resizePosition };
    };
    ImageResizer.prototype.applyPropertiesForMouse = function () {
        if (!isNullOrUndefined(this.bottomLeftRectParent)) {
            this.bottomMiddleRectParent.style.width = '14px';
            this.bottomMiddleRectParent.style.height = '14px';
            this.bottomRightRectParent.style.width = '14px';
            this.bottomRightRectParent.style.height = '14px';
            this.bottomLeftRectParent.style.width = '14px';
            this.bottomLeftRectParent.style.height = '14px';
            this.topMiddleRectParent.style.width = '14px';
            this.topMiddleRectParent.style.height = '14px';
            this.topRightRectParent.style.width = '14px';
            this.topRightRectParent.style.height = '14px';
            this.topLeftRectParent.style.width = '14px';
            this.topLeftRectParent.style.height = '14px';
            this.leftMiddleRectParent.style.width = '14px';
            this.leftMiddleRectParent.style.height = '14px';
            this.rightMiddleRectParent.style.width = '14px';
            this.rightMiddleRectParent.style.height = '14px';
        }
    };
    /**
     * Gets the image point of touch.
     * @param {Point} touchPoints - Specifies for resizer cursor position.
     * @private
     */
    ImageResizer.prototype.getImagePointOnTouch = function (touchPoints) {
        var x = this.viewer.render.getScaledValue(touchPoints.x, 1);
        var y = this.viewer.render.getScaledValue(touchPoints.y, 2);
        touchPoints = new Point(x, y);
        var imageResizingPointsOnTouch = this.imageResizerPoints;
        var resizePosition = '';
        var selectedElements = undefined;
        var bottomMiddle = imageResizingPointsOnTouch.bottomMiddleRectParent;
        var bottomRight = imageResizingPointsOnTouch.bottomRightRectParent;
        var bottomLeft = imageResizingPointsOnTouch.bottomLeftRectParent;
        var topMiddle = imageResizingPointsOnTouch.topMiddleRectParent;
        var topRight = imageResizingPointsOnTouch.topRightRectParent;
        var topLeft = imageResizingPointsOnTouch.topLeftRectParent;
        var rightMiddle = imageResizingPointsOnTouch.rightMiddleRectParent;
        var leftMiddle = imageResizingPointsOnTouch.leftMiddleRectParent;
        if (!isNullOrUndefined(this.bottomMiddleRectParent) && this.bottomMiddleRectParent.style.display !== 'none') {
            // tslint:disable-next-line:max-line-length   
            if ((touchPoints.x > bottomMiddle.x && touchPoints.x <= bottomMiddle.x + 25) && (touchPoints.y > bottomMiddle.y && touchPoints.y <= bottomMiddle.y + 25)) {
                selectedElements = this.bottomMiddleRectParent;
                resizePosition = 's-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > bottomRight.x && touchPoints.x <= bottomRight.x + 25) && (touchPoints.y > bottomRight.y && touchPoints.y <= bottomRight.y + 25)) {
                selectedElements = this.bottomRightRectParent;
                resizePosition = 'se-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > bottomLeft.x && touchPoints.x <= bottomLeft.x + 25) && (touchPoints.y > bottomLeft.y && touchPoints.y <= bottomLeft.y + 25)) {
                selectedElements = this.bottomLeftRectParent;
                resizePosition = 'sw-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > topMiddle.x && touchPoints.x <= topMiddle.x + 25) && (touchPoints.y > topMiddle.y && touchPoints.y <= topMiddle.y + 25)) {
                selectedElements = this.topMiddleRectParent;
                resizePosition = 'n-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > topRight.x && touchPoints.x <= topRight.x + 25) && (touchPoints.y > topRight.y && touchPoints.y <= topRight.y + 25)) {
                selectedElements = this.topRightRectParent;
                resizePosition = 'ne-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > topLeft.x && touchPoints.x <= topLeft.x + 25) && (touchPoints.y > topLeft.y && touchPoints.y <= topLeft.y + 25)) {
                selectedElements = this.topLeftRectParent;
                resizePosition = 'nw-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > leftMiddle.x && touchPoints.x <= leftMiddle.x + 25) && (touchPoints.y > leftMiddle.y && touchPoints.y <= leftMiddle.y + 25)) {
                selectedElements = this.leftMiddleRectParent;
                resizePosition = 'w-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > rightMiddle.x && touchPoints.x <= rightMiddle.x + 25) && (touchPoints.y > rightMiddle.y && touchPoints.y <= rightMiddle.y + 25)) {
                selectedElements = this.rightMiddleRectParent;
                resizePosition = 'e-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if (!isNullOrUndefined(this.resizeContainerDiv) && (touchPoints.x > parseFloat(this.resizeContainerDiv.style.left)
                && touchPoints.x <= (parseFloat(this.resizeContainerDiv.style.left) + parseFloat(this.resizeContainerDiv.style.width)))
                && (touchPoints.y > parseFloat(this.resizeContainerDiv.style.top)
                    // tslint:disable-next-line:max-line-length 
                    && touchPoints.y <= (parseFloat(this.resizeContainerDiv.style.top) + parseFloat(this.resizeContainerDiv.style.height)))) {
                resizePosition = 'move';
            }
        }
        return { 'selectedElement': selectedElements, 'resizePosition': resizePosition };
    };
    ImageResizer.prototype.applyPropertiesForTouch = function () {
        if (!isNullOrUndefined(this.bottomLeftRectParent)) {
            this.bottomMiddleRectParent.style.width = '30px';
            this.bottomMiddleRectParent.style.height = '30px';
            this.bottomRightRectParent.style.width = '30px';
            this.bottomRightRectParent.style.height = '30px';
            this.bottomLeftRectParent.style.width = '30px';
            this.bottomLeftRectParent.style.height = '30px';
            this.topMiddleRectParent.style.width = '30px';
            this.topMiddleRectParent.style.height = '30px';
            this.topRightRectParent.style.width = '30px';
            this.topRightRectParent.style.height = '30px';
            this.topLeftRectParent.style.width = '30px';
            this.topLeftRectParent.style.height = '30px';
            this.leftMiddleRectParent.style.width = '30px';
            this.leftMiddleRectParent.style.height = '30px';
            this.rightMiddleRectParent.style.width = '30px';
            this.rightMiddleRectParent.style.height = '30px';
        }
    };
    /**
     * @private
     */
    ImageResizer.prototype.mouseUpInternal = function () {
        this.currentImageElementBox.width = parseFloat(this.imageResizerDiv.style.width) / this.viewer.zoomFactor;
        this.currentImageElementBox.height = parseFloat(this.imageResizerDiv.style.height) / this.viewer.zoomFactor;
        this.owner.isShiftingEnabled = true;
        this.owner.editorModule.setOffsetValue(this.owner.selection);
        this.viewer.layout.reLayoutParagraph(this.currentImageElementBox.line.paragraph, 0, 0);
        this.owner.editorModule.reLayout(this.owner.selection, true);
        this.viewer.updateScrollBars();
    };
    /**
     * Initialize history for image resizer.
     * @param {ImageResizer} imageResizer - Specifies for image resizer.
     * @param {WImage} imageContainer - Specifies for an image.
     * @private
     */
    ImageResizer.prototype.initHistoryForImageResizer = function (imageContainer) {
        if (!isNullOrUndefined(this.owner) && isNullOrUndefined(this.baseHistoryInfo)) {
            this.baseHistoryInfo = new BaseHistoryInfo(this.owner);
            this.baseHistoryInfo.action = 'ImageResizing';
            this.baseHistoryInfo.updateSelection();
            this.baseHistoryInfo.modifiedProperties.push(new ImageFormat(imageContainer));
        }
    };
    /**
     * Updates histroy for image resizer.
     * @private
     */
    ImageResizer.prototype.updateHistoryForImageResizer = function () {
        if (!isNullOrUndefined(this.owner) && !isNullOrUndefined(this.baseHistoryInfo)) {
            var imageFormat = this.baseHistoryInfo.modifiedProperties[0];
            if (this.currentImageElementBox.width === imageFormat.width
                && this.currentImageElementBox.height === imageFormat.height) {
                this.baseHistoryInfo.modifiedProperties.pop();
            }
            else {
                //Records the image size modifications
                this.owner.editorHistory.recordChanges(this.baseHistoryInfo);
            }
            //Fires the content changed event for the image size modifications
            this.baseHistoryInfo = undefined;
        }
    };
    /**
     * Updates image resize container when applying zooming
     * @private
     */
    ImageResizer.prototype.updateImageResizerPosition = function () {
        if (!isNullOrUndefined(this.currentImageElementBox)) {
            var elementBox = this.currentImageElementBox;
            var lineWidget = elementBox.line;
            var top_1 = this.viewer.selection.getTop(lineWidget) + elementBox.margin.top;
            var left = this.viewer.selection.getLeftInternal(lineWidget, elementBox, 0);
            var topValue = top_1 * this.viewer.zoomFactor;
            var leftValue = left * this.viewer.zoomFactor;
            var height = this.viewer.render.getScaledValue(elementBox.height, 2);
            var width = this.viewer.render.getScaledValue(elementBox.width, 1);
            this.setImageResizerPosition(leftValue, topValue, width, height, this);
        }
    };
    /**
     * Dispose the internal objects which are maintained.
     * @private
     */
    ImageResizer.prototype.destroy = function () {
        if (!isNullOrUndefined(this.resizeContainerDiv)) {
            this.resizeContainerDiv.innerHTML = '';
        }
        if (!isNullOrUndefined(this.topLeftRect)) {
            this.topLeftRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.topMiddleRect)) {
            this.topMiddleRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.topRightRect)) {
            this.topRightRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.bottomLeftRect)) {
            this.bottomLeftRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.bottomMiddleRect)) {
            this.bottomMiddleRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.bottomRightRect)) {
            this.bottomRightRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.leftMiddleRect)) {
            this.leftMiddleRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.rightMiddleRect)) {
            this.rightMiddleRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.imageResizerDiv)) {
            this.imageResizerDiv.innerHTML = '';
        }
        if (!isNullOrUndefined(this.selectedImageWidget)) {
            this.selectedImageWidget.destroy();
        }
        if (!isNullOrUndefined(this.imageResizerDivElement)) {
            this.imageResizerDivElement.innerHTML = '';
        }
        this.imageResizerDivElement = undefined;
        this.resizeContainerDiv = undefined;
        this.topLeftRect = undefined;
        this.topMiddleRect = undefined;
        this.topRightRect = undefined;
        this.bottomLeftRect = undefined;
        this.bottomMiddleRect = undefined;
        this.bottomRightRect = undefined;
        this.leftMiddleRect = undefined;
        this.rightMiddleRect = undefined;
        this.imageResizerDiv = undefined;
        this.selectedImageWidget = undefined;
        this.isImageResizing = false;
        this.isImageResizerVisible = false;
        this.currentImageElementBoxIn = undefined;
        //this.baseHistoryInfo = undefined;
        this.resizeMarkSizeIn = undefined;
        this.viewer = undefined;
        this.owner = undefined;
    };
    return ImageResizer;
}());
/**
 * @private
 */
var ImageResizingPoints = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for image resizing points class.
     */
    function ImageResizingPoints() {
        /**
         * @private
         */ this.resizeContainerDiv = new Point(0, 0);
        /**
         * @private
         */
        this.topLeftRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.topMiddleRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.topRightRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.bottomLeftRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.bottomMiddleRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.bottomRightRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.leftMiddleRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.rightMiddleRectParent = new Point(0, 0);
        
    }
    return ImageResizingPoints;
}());
/**
 * @private
 */
var SelectedImageInfo = /** @__PURE__ @class */ (function () {
    /**
     * Constructor for selected image info class.
     * @param {number} height - Specifies for height value.
     * @param {number} width - Specifies for width value.
     */
    function SelectedImageInfo(height, width) {
        this.heightIn = 0;
        this.widthIn = 0;
        this.heightIn = height;
        this.widthIn = width;
    }
    Object.defineProperty(SelectedImageInfo.prototype, "height", {
        /**
         * Gets or Sets the height value.
         * @private
         */
        get: function () {
            return this.heightIn;
        },
        /**
         * @private
         */
        set: function (value) {
            this.heightIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectedImageInfo.prototype, "width", {
        /**
         * Gets or Sets the width value.
         * @private
         */
        get: function () {
            return this.widthIn;
        },
        /**
         * @private
         */
        set: function (value) {
            this.widthIn = value;
        },
        enumerable: true,
        configurable: true
    });
    return SelectedImageInfo;
}());

/**
 * Editor Export
 */

var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * EditorHistory preservation class
 */
/**
 * @private
 */
var HistoryInfo = /** @__PURE__ @class */ (function (_super) {
    __extends$4(HistoryInfo, _super);
    function HistoryInfo(node, isChild) {
        var _this = _super.call(this, node) || this;
        _this.isChildHistoryInfo = false;
        _this.editRangeStart = undefined;
        _this.isChildHistoryInfo = isChild;
        return _this;
    }
    Object.defineProperty(HistoryInfo.prototype, "hasAction", {
        /**
         * @private
         */
        get: function () {
            return !isNullOrUndefined(this.modifiedActions);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds the modified actions
     * @param  {BaseHistoryInfo} baseHistoryInfo
     * @private
     */
    HistoryInfo.prototype.addModifiedAction = function (baseHistoryInfo) {
        // For complex actions such as Replace text, Insert/Remove Hyperlink etc.
        if (!(this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
            if (isNullOrUndefined(this.modifiedActions)) {
                this.modifiedActions = [];
            }
            this.modifiedActions.push(baseHistoryInfo);
        }
    };
    /**
     * Reverts this instance
     * @private
     */
    HistoryInfo.prototype.revert = function () {
        this.editorHistory.currentHistoryInfo = this;
        if (this.action === 'BordersAndShading') {
            this.owner.editorModule.isBordersAndShadingDialog = true;
        }
        if (!isNullOrUndefined(this.modifiedActions)) {
            if (this.editorHistory.isUndoing) {
                var i = this.modifiedActions.length;
                while (i > 0) {
                    var baseHistoryInfo = this.modifiedActions[i - 1];
                    baseHistoryInfo.revert();
                    i = i - 1;
                }
            }
            else {
                var i = 0;
                while (i < this.modifiedActions.length) {
                    var baseHistoryInfo = this.modifiedActions[i];
                    baseHistoryInfo.revert();
                    i = i + 1;
                }
            }
        }
        if (this.action === 'RestrictEditing') {
            var user = this.editRangeStart.user !== '' ? this.editRangeStart.user : this.editRangeStart.group;
            if (this.editorHistory.isUndoing) {
                var index = this.owner.viewer.editRanges.get(user).indexOf(this.editRangeStart);
                if (index !== -1) {
                    this.owner.viewer.editRanges.get(user).splice(index, 1);
                }
            }
            else {
                this.owner.editor.updateRangeCollection(this.editRangeStart, user);
            }
            this.owner.selection.updateEditRangeCollection();
        }
        if (!this.isChildHistoryInfo) {
            this.editorHistory.updateComplexHistory();
        }
        else {
            this.editorHistory.updateComplexHistoryInternal();
        }
    };
    /**
     * @private
     */
    HistoryInfo.prototype.destroy = function () {
        if (!isNullOrUndefined(this.modifiedActions)) {
            while (this.modifiedActions.length > 0) {
                var baseHistoryInfo = this.modifiedActions[this.modifiedActions.length - 1];
                baseHistoryInfo.destroy();
                this.modifiedActions.splice(this.modifiedActions.indexOf(baseHistoryInfo), 1);
            }
            this.modifiedActions = undefined;
        }
        _super.prototype.destroy.call(this);
    };
    return HistoryInfo;
}(BaseHistoryInfo));

/**
 *  `EditorHistory` Module class is used to handle history preservation
 */
var EditorHistory = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function EditorHistory(node) {
        //Fields
        this.undoStackIn = [];
        this.redoStackIn = [];
        this.historyInfoStack = [];
        /**
         * @private
         */
        this.isUndoing = false;
        /**
         * @private
         */
        this.isRedoing = false;
        this.owner = node;
        this.viewer = node.viewer;
        this.modifiedParaFormats = new Dictionary();
        this.undoLimitIn = 500;
        this.redoLimitIn = 500;
    }
    Object.defineProperty(EditorHistory.prototype, "currentHistoryInfo", {
        /**
         * @private
         */
        get: function () {
            return this.historyInfoStack && this.historyInfoStack.length > 0 ?
                this.historyInfoStack[this.historyInfoStack.length - 1] : undefined;
        },
        set: function (value) {
            if (value instanceof HistoryInfo) {
                this.historyInfoStack.push(value);
            }
            else {
                this.historyInfoStack.pop();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorHistory.prototype, "undoStack", {
        //Properties
        /**
         * gets undo stack
         * @private
         */
        get: function () { return this.undoStackIn; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorHistory.prototype, "redoStack", {
        /**
         * gets redo stack
         * @private
         */
        get: function () { return this.redoStackIn; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorHistory.prototype, "undoLimit", {
        /**
         * Gets or Sets the limit of undo operations can be done.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return isNullOrUndefined(this.undoLimitIn) ? 0 : this.undoLimitIn;
        },
        /**
         * Sets the limit of undo operations can be done.
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value < 0) {
                throw new Error('The limit should be greater than or equal to zero.');
            }
            this.undoLimitIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorHistory.prototype, "redoLimit", {
        /**
         * Gets or Sets the limit of redo operations can be done.
         * @aspType int
         * @blazorType int
         */
        get: function () {
            return isNullOrUndefined(this.redoLimitIn) ? 0 : this.redoLimitIn;
        },
        /**
         * Gets or Sets the limit of redo operations can be done.
         * @aspType int
         * @blazorType int
         */
        set: function (value) {
            if (value < 0) {
                throw new Error('The limit should be greater than or equal to zero.');
            }
            this.redoLimitIn = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    EditorHistory.prototype.getModuleName = function () {
        return 'EditorHistory';
    };
    /**
     * Determines whether undo operation can be done.
     * @returns boolean
     */
    EditorHistory.prototype.canUndo = function () {
        return !isNullOrUndefined(this.undoStack) && this.undoStack.length > 0;
    };
    /**
     * Determines whether redo operation can be done.
     * @returns boolean
     */
    EditorHistory.prototype.canRedo = function () {
        return !isNullOrUndefined(this.redoStack) && this.redoStack.length > 0;
    };
    //EditorHistory Initialization    
    /**
     * initialize EditorHistory
     * @param  {Selection} selection
     * @param  {Action} action
     * @param  {SelectionRange} selectionRange
     * @private
     */
    EditorHistory.prototype.initializeHistory = function (action) {
        this.currentBaseHistoryInfo = new BaseHistoryInfo(this.owner);
        this.currentBaseHistoryInfo.action = action;
        this.currentBaseHistoryInfo.updateSelection();
    };
    /**
     * Initialize complex history
     * @param  {Selection} selection
     * @param  {Action} action
     * @private
     */
    EditorHistory.prototype.initComplexHistory = function (selection, action) {
        this.currentHistoryInfo = new HistoryInfo(selection.owner, !isNullOrUndefined(this.currentHistoryInfo));
        this.currentHistoryInfo.action = action;
        this.currentHistoryInfo.updateSelection();
    };
    /**
     * @private
     */
    EditorHistory.prototype.initResizingHistory = function (startingPoint, tableResize) {
        if (tableResize.resizeNode === 1) {
            this.initializeHistory('RowResizing');
            if (!isNullOrUndefined(this.currentBaseHistoryInfo)) {
                // tslint:disable-next-line:max-line-length
                this.currentBaseHistoryInfo.modifiedProperties.push(new RowHistoryFormat(startingPoint, tableResize.currentResizingTable.childWidgets[tableResize.resizerPosition].rowFormat));
            }
        }
        else {
            this.initializeHistory('CellResizing');
            if (this.currentBaseHistoryInfo) {
                tableResize.currentResizingTable = tableResize.currentResizingTable.combineWidget(this.viewer);
                var tableHistoryInfo = new TableHistoryInfo(tableResize.currentResizingTable, this.owner);
                tableHistoryInfo.startingPoint = startingPoint;
                this.currentBaseHistoryInfo.modifiedProperties.push(tableHistoryInfo);
            }
        }
    };
    /**
     * Update resizing history
     * @param  {Point} point
     * @param  {Selection} selection
     * @private
     */
    EditorHistory.prototype.updateResizingHistory = function (point, tableResize) {
        if (tableResize.resizeNode === 1) {
            if (!isNullOrUndefined(this.currentBaseHistoryInfo)) {
                var rowHistoryFormat = this.currentBaseHistoryInfo.modifiedProperties[0];
                if (rowHistoryFormat.startingPoint.y === point.y) {
                    this.currentBaseHistoryInfo.modifiedProperties.length = 0;
                }
                else {
                    rowHistoryFormat.displacement = HelperMethods.convertPixelToPoint(point.y - rowHistoryFormat.startingPoint.y);
                    this.recordChanges(this.currentBaseHistoryInfo);
                    this.currentBaseHistoryInfo = undefined;
                }
            }
        }
        else {
            if (!isNullOrUndefined(this.currentBaseHistoryInfo)) {
                var cellHistoryFormat = this.currentBaseHistoryInfo.modifiedProperties[0];
                if (cellHistoryFormat.startingPoint.x === point.x) {
                    this.currentBaseHistoryInfo.modifiedProperties.length = 0;
                }
                else {
                    cellHistoryFormat.displacement = HelperMethods.convertPixelToPoint(point.x - cellHistoryFormat.startingPoint.x);
                    cellHistoryFormat.endIndex = tableResize.getCellReSizerPosition(point);
                    this.owner.editorHistory.recordChanges(this.currentBaseHistoryInfo);
                    this.currentBaseHistoryInfo = undefined;
                }
            }
        }
    };
    /**
     * Record the changes
     * @param  {BaseHistoryInfo} baseHistoryInfo
     * @private
     */
    EditorHistory.prototype.recordChanges = function (baseHistoryInfo) {
        if (!this.owner.enableHistoryMode) {
            return;
        }
        if (this.isUndoing) {
            if (isNullOrUndefined(this.redoStack)) {
                this.redoStackIn = [];
            }
            if (this.redoStack.length === this.redoLimit && this.redoLimit > 0) {
                var count = this.undoLimit > 20 ? 10 : 1;
                this.redoStackIn.splice(0, count);
            }
            if (this.redoStack.length < this.redoLimit) {
                this.redoStack.push(baseHistoryInfo);
            }
        }
        else {
            if (!this.isRedoing) {
                this.clearRedoStack();
            }
            if (isNullOrUndefined(this.undoStack)) {
                this.undoStackIn = [];
            }
            if (this.undoStack.length === this.undoLimit && this.undoLimit > 0) {
                var count = this.undoLimit > 20 ? 10 : 1;
                this.undoStackIn.splice(0, count);
            }
            if (this.undoStack.length < this.undoLimit) {
                this.undoStackIn.push(baseHistoryInfo);
            }
        }
    };
    /**
     * update EditorHistory
     * @private
     */
    EditorHistory.prototype.updateHistory = function () {
        if (this.viewer.owner.enableHistoryMode && !isNullOrUndefined(this.currentBaseHistoryInfo)) {
            //Updates the current end position
            if (!isNullOrUndefined(this.currentBaseHistoryInfo)
                && isNullOrUndefined(this.currentBaseHistoryInfo.endPosition)) {
                this.currentBaseHistoryInfo.endPosition = this.currentBaseHistoryInfo.insertPosition;
            }
            if (!isNullOrUndefined(this.currentHistoryInfo)) {
                this.currentHistoryInfo.addModifiedAction(this.currentBaseHistoryInfo);
            }
            else {
                this.recordChanges(this.currentBaseHistoryInfo);
            }
            this.currentBaseHistoryInfo = undefined;
        }
    };
    /**
     * @private
     */
    EditorHistory.prototype.isHandledComplexHistory = function () {
        var isHandledComplexHistory = false;
        if (!(this.isUndoing || this.isRedoing)) {
            isHandledComplexHistory = this.owner.editorModule.insertRemoveBookMarkElements();
        }
        if (this.viewer.owner.enableHistoryMode && !isNullOrUndefined(this.currentHistoryInfo)) {
            this.updateHistory();
            isHandledComplexHistory = true;
        }
        else if (this.owner.editorModule.isHandledComplex) {
            isHandledComplexHistory = true;
        }
        return isHandledComplexHistory;
    };
    /**
     * Update complex history
     * @private
     */
    EditorHistory.prototype.updateComplexHistory = function () {
        var selection = this.viewer.selection;
        if (this.currentHistoryInfo.hasAction) {
            if (this.currentHistoryInfo.action === 'AutoFormatHyperlink') {
                var startPosition = new TextPosition(selection.owner);
                this.owner.editorModule.setPositionForCurrentIndex(startPosition, this.currentHistoryInfo.insertPosition);
                // this.reLayoutParagraph(startPosition.paragraph, 0);
                if (selection.owner.editorHistory.isUndoing) {
                    this.owner.editorModule.setPositionForCurrentIndex(selection.start, this.currentHistoryInfo.selectionStart);
                    this.owner.editorModule.setPositionForCurrentIndex(selection.end, this.currentHistoryInfo.selectionEnd);
                }
                else {
                    this.owner.editorModule.setPositionForCurrentIndex(selection.start, this.currentHistoryInfo.endPosition);
                    this.owner.editorModule.setPositionForCurrentIndex(selection.end, this.currentHistoryInfo.endPosition);
                }
            }
            if (this.currentHistoryInfo.action === 'InsertHyperlink') {
                var startPosition = new TextPosition(selection.owner);
                this.owner.editorModule.setPositionForCurrentIndex(startPosition, this.currentHistoryInfo.insertPosition);
                var endPosition = new TextPosition(selection.owner);
                this.owner.editorModule.setPositionForCurrentIndex(endPosition, this.currentHistoryInfo.endPosition);
                this.viewer.layout.reLayoutParagraph(startPosition.paragraph, 0, 0);
                if (endPosition.paragraph !== startPosition.paragraph) {
                    this.viewer.layout.reLayoutParagraph(endPosition.paragraph, 0, 0);
                }
            }
            if (this.currentHistoryInfo.action === 'ReplaceAll') {
                this.owner.editorModule.layoutWholeDocument();
            }
            else if (selection.owner.isShiftingEnabled) {
                this.viewer.layout.shiftLayoutedItems();
                if (this.owner.enableHeaderAndFooter) {
                    this.owner.editorModule.updateHeaderFooterWidget();
                }
                this.viewer.removeEmptyPages();
            }
        }
        selection.owner.isShiftingEnabled = false;
        selection.owner.isLayoutEnabled = true;
        // // selection.addMultipleSelectionRanges();
        selection.start.updatePhysicalPosition(true);
        if (selection.isEmpty) {
            selection.end.setPositionInternal(selection.start);
        }
        else {
            selection.end.updatePhysicalPosition(true);
        }
        selection.upDownSelectionLength = selection.end.location.x;
        this.viewer.isScrollHandler = true;
        this.viewer.updateScrollBars();
        selection.fireSelectionChanged(true);
        this.viewer.isScrollHandler = false;
        this.viewer.updateFocus();
        this.updateComplexHistoryInternal();
        this.owner.editorModule.fireContentChange();
    };
    /**
     * @private
     */
    EditorHistory.prototype.updateComplexHistoryInternal = function () {
        if (!isNullOrUndefined(this.currentHistoryInfo)) {
            //Updates the current end position
            if (isNullOrUndefined(this.currentHistoryInfo.endPosition)) {
                this.currentHistoryInfo.endPosition = this.currentHistoryInfo.insertPosition;
            }
            if (this.historyInfoStack.length > 1) {
                var historyInfo = this.historyInfoStack[this.historyInfoStack.length - 2];
                historyInfo.addModifiedAction(this.currentHistoryInfo);
            }
            else {
                this.recordChanges(this.currentHistoryInfo);
            }
            this.currentHistoryInfo = undefined;
        }
    };
    //List history preservation undo API
    /**
     * update list changes for history preservation
     * @param  {Selection} selection
     * @param  {WAbstractList} currentAbstractList
     * @param  {WList} list
     * @private
     */
    EditorHistory.prototype.updateListChangesInHistory = function (currentAbstractList, list) {
        this.currentBaseHistoryInfo = new BaseHistoryInfo(this.viewer.owner);
        this.currentBaseHistoryInfo.action = 'List';
        this.currentBaseHistoryInfo.updateSelection();
        var collection = new Dictionary();
        for (var i = 0; i < currentAbstractList.levels.length; i++) {
            var levels = this.viewer.getAbstractListById(list.abstractListId).levels[i];
            var value = this.currentBaseHistoryInfo.addModifiedPropertiesForList(levels);
            var modifiedLevel = new ModifiedLevel(levels, currentAbstractList.levels[i]);
            if (!isNullOrUndefined(levels)) {
                this.viewer.owner.editorModule.copyListLevel(levels, currentAbstractList.levels[i]);
            }
            collection.add(i, modifiedLevel);
        }
        return collection;
    };
    /**
     * Apply list changes
     * @param  {Selection} selection
     * @param  {Dictionary<number, ModifiedLevel>} modifiedLevelsInternal
     * @private
     */
    EditorHistory.prototype.applyListChanges = function (selection, modifiedLevelsInternal) {
        if (isNullOrUndefined(this.modifiedParaFormats)) {
            this.modifiedParaFormats = new Dictionary();
        }
        var collection = [];
        for (var i = 0; i < this.viewer.listParagraphs.length; i++) {
            var paragraph = this.viewer.listParagraphs[i];
            var paraFormat = paragraph.paragraphFormat;
            var currentList = this.viewer.getListById(paraFormat.listFormat.listId);
            var listLevel = this.viewer.layout.getListLevel(currentList, paraFormat.listFormat.listLevelNumber);
            // tslint:disable-next-line:max-line-length
            if (modifiedLevelsInternal.containsKey(paraFormat.listFormat.listLevelNumber)
                && modifiedLevelsInternal.get(paraFormat.listFormat.listLevelNumber).ownerListLevel === listLevel) {
                var modifiedFormat = new WParagraphFormat(null);
                modifiedFormat.leftIndent = paraFormat.leftIndent;
                modifiedFormat.firstLineIndent = paraFormat.firstLineIndent;
                var modified = new ModifiedParagraphFormat(paraFormat, modifiedFormat);
                collection.push(modified);
                this.owner.editorModule.copyFromListLevelParagraphFormat(paraFormat, listLevel.paragraphFormat);
            }
        }
        this.modifiedParaFormats.add(this.currentBaseHistoryInfo, collection);
    };
    /**
     * Update list changes
     * @param  {Dictionary<number, ModifiedLevel>} modifiedCollection
     * @param  {Selection} selection
     * @private
     */
    EditorHistory.prototype.updateListChanges = function (modifiedCollection) {
        this.viewer.owner.isLayoutEnabled = false;
        this.owner.editorModule.updateListParagraphs();
        for (var i = 0; i < modifiedCollection.keys.length; i++) {
            var levelNumber = modifiedCollection.keys[0];
            var modifiedLevel = modifiedCollection.get(levelNumber);
            if (!isNullOrUndefined(this.currentBaseHistoryInfo)) {
                // tslint:disable-next-line:max-line-length
                modifiedLevel = this.currentBaseHistoryInfo.addModifiedPropertiesForList(modifiedLevel.ownerListLevel);
            }
            this.owner.editorModule.copyListLevel(modifiedLevel.ownerListLevel, modifiedLevel.modifiedListLevel);
        }
        this.revertListChanges();
        this.viewer.owner.isLayoutEnabled = true;
        this.viewer.renderedLists.clear();
        this.viewer.renderedLevelOverrides = [];
        this.viewer.pages = [];
        this.viewer.layout.layout();
        var selection = this.viewer.selection;
        selection.start.updatePhysicalPosition(true);
        if (selection.isEmpty) {
            selection.end.setPositionInternal(selection.start);
        }
        else {
            selection.end.updatePhysicalPosition(true);
        }
        selection.upDownSelectionLength = selection.end.location.x;
        selection.fireSelectionChanged(false);
        this.updateHistory();
    };
    /**
     * Revert list changes
     * @param  {Selection} selection
     */
    EditorHistory.prototype.revertListChanges = function () {
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(this.currentBaseHistoryInfo)
            && this.viewer.owner.editorHistory.modifiedParaFormats.containsKey(this.currentBaseHistoryInfo)) {
            // tslint:disable-next-line:max-line-length
            var collection = this.modifiedParaFormats.get(this.currentBaseHistoryInfo);
            for (var i = 0; i < collection.length; i++) {
                var modified = new WParagraphFormat(null);
                modified.leftIndent = collection[i].ownerFormat.leftIndent;
                modified.firstLineIndent = collection[i].ownerFormat.firstLineIndent;
                collection[i].ownerFormat.copyFormat(collection[i].modifiedFormat);
                collection[i].modifiedFormat.leftIndent = modified.leftIndent;
                collection[i].modifiedFormat.firstLineIndent = modified.firstLineIndent;
            }
        }
    };
    /**
     * Reverts the last editing action.
     */
    EditorHistory.prototype.undo = function () {
        if (this.owner.isReadOnlyMode || !this.canUndo() || !this.owner.enableHistoryMode) {
            return;
        }
        //this.owner.ClearTextSearchResults();
        var historyInfo = this.undoStack.pop();
        this.isUndoing = true;
        historyInfo.revert();
        this.isUndoing = false;
        this.owner.selection.checkForCursorVisibility();
        this.owner.editorModule.isBordersAndShadingDialog = false;
    };
    /**
     * Performs the last reverted action.
     */
    EditorHistory.prototype.redo = function () {
        if (this.owner.isReadOnlyMode || !this.canRedo() || !this.owner.enableHistoryMode) {
            return;
        }
        //this.owner.ClearTextSearchResults();
        var historyInfo = this.redoStack.pop();
        if (historyInfo.action === 'BordersAndShading') {
            this.owner.editorModule.isBordersAndShadingDialog = true;
        }
        this.isRedoing = true;
        historyInfo.revert();
        this.isRedoing = false;
        this.owner.selection.checkForCursorVisibility();
        this.owner.editorModule.isBordersAndShadingDialog = false;
    };
    /**
     * @private
     */
    EditorHistory.prototype.destroy = function () {
        this.clearHistory();
        this.undoStackIn = undefined;
        this.redoStackIn = undefined;
    };
    EditorHistory.prototype.clearHistory = function () {
        this.clearUndoStack();
        this.clearRedoStack();
    };
    EditorHistory.prototype.clearUndoStack = function () {
        if (this.canUndo()) {
            while (this.undoStack.length > 0) {
                var historyInfo = this.undoStack.pop();
                historyInfo.destroy();
                historyInfo = undefined;
            }
        }
    };
    EditorHistory.prototype.clearRedoStack = function () {
        if (this.canRedo()) {
            while (this.redoStack.length > 0) {
                var historyInfo = this.redoStack.pop();
                historyInfo.destroy();
                historyInfo = undefined;
            }
        }
    };
    return EditorHistory;
}());

/**
 * EditorHistory implementation
 */

/**
 * Exports the document to Word format.
 */
var WordExport = /** @__PURE__ @class */ (function () {
    function WordExport() {
        //Part path
        this.documentPath = 'word/document.xml';
        this.stylePath = 'word/styles.xml';
        this.chartPath = 'word/charts';
        this.numberingPath = 'word/numbering.xml';
        this.settingsPath = 'word/settings.xml';
        this.headerPath = 'word/header';
        this.footerPath = 'word/footer';
        //private commentsPath: string = 'word/comments.xml';
        this.imagePath = 'word/media/image';
        // private footnotesPath: string = 'word/footnotes.xml';
        // private endnotesPath: string = 'word/endnotes.xml';
        this.appPath = 'docProps/app.xml';
        this.corePath = 'docProps/core.xml';
        // private CustomPath: string = 'docProps/custom.xml';
        // private FontTablePath: string = 'word/fontTable.xml';
        this.contentTypesPath = '[Content_Types].xml';
        // private ChartsPath: string = 'word/charts/';
        this.defaultEmbeddingPath = 'word/embeddings/';
        this.commentsPath = 'word/comments.xml';
        this.commentsExtendedPath = 'word/commentsExtended.xml';
        // private EmbeddingPath:string = 'word\embeddings\';
        // private DrawingPath:string = 'word\drawings\';
        // private ThemePath: string = 'word/theme/theme1.xml';
        // private FontsPath:string = 'word\fonts\';
        // private DiagramPath:string = "word/diagrams/';
        // private ControlPath:string = "word/activeX/';
        // private VbaProject: string = 'vbaProject.bin';
        // private VbaData: string = 'vbaData.xml';
        // private VbaProjectPath: string = 'word/vbaProject.bin';
        // private VbaDataPath: string = 'word/vbaData.xml';
        // private CustomXMLPath:string = 'customXml\';
        //Relationship path
        this.generalRelationPath = '_rels/.rels';
        this.wordRelationPath = 'word/_rels/document.xml.rels';
        this.excelRelationPath = 'xl/_rels/workbook.xml.rels';
        // private FontRelationPath: string = 'word/_rels/fontTable.xml.rels';
        // private CommentsRelationPath: string = 'word/_rels/comments.xml.rels';
        // private FootnotesRelationPath: string = 'word/_rels/footnotes.xml.rels';
        // private EndnotesRelationPath: string = 'word/_rels/endnotes.xml.rels';
        // private NumberingRelationPath: string = 'word/_rels/numbering.xml.rels';
        this.headerRelationPath = 'word/_rels/header';
        this.footerRelationPath = 'word/_rels/footer';
        // private SettingsRelationpath: string = 'word/_rels/settings.xml.rels';
        // private VbaProjectRelsPath: string = 'word/_rels/vbaProject.bin.rels';
        //Content type of the parts
        this.xmlContentType = 'application/xml';
        this.fontContentType = 'application/vnd.openxmlformats-officedocument.obfuscatedFont';
        this.documentContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml';
        // private TemplateContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml';
        // private CommentsContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml';
        this.settingsContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml';
        this.commentsContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml';
        this.commentsExContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtended+xml';
        // private EndnoteContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml';
        // private FontTableContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml';
        this.footerContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml';
        // private FootnoteContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml';
        // private GlossaryDocumentContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml';
        this.headerContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml';
        this.numberingContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml';
        this.stylesContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml';
        this.webSettingsContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml';
        this.appContentType = 'application/vnd.openxmlformats-officedocument.extended-properties+xml';
        this.coreContentType = 'application/vnd.openxmlformats-package.core-properties+xml';
        this.customContentType = 'application/vnd.openxmlformats-officedocument.custom-properties+xml';
        this.customXmlContentType = 'application/vnd.openxmlformats-officedocument.customXmlProperties+xml';
        this.relationContentType = 'application/vnd.openxmlformats-package.relationships+xml';
        // private DiagramColor: string = 'application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml';
        // private DiagramData: string = 'application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml';
        // private DiagramLayout: string = 'application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml';
        // private DiagramStyle: string = 'application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml';
        this.chartsContentType = 'application/vnd.openxmlformats-officedocument.drawingml.chart+xml';
        // private ThemeContentType: string = 'application/vnd.openxmlformats-officedocument.theme+xml';
        // private ChartDrawingContentType: string = 'application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml';
        // private ActiveXContentType: string = 'application/vnd.ms-office.activeX+xml';
        // private ActiveXBinContentType: string = 'application/vnd.ms-office.activeX';
        this.tableStyleContentType = 'application/vnd.openxmlformats-officedocument.presentationml.tableStyles+xml';
        // private ChartStyleContentType: string = 'application/vnd.ms-office.chartstyle+xml';
        this.chartColorStyleContentType = 'application/vnd.ms-office.chartcolorstyle+xml';
        // private VbaProjectContentType: string = 'application/vnd.ms-office.vbaProject';
        // private VbaDataContentType: string = 'application/vnd.ms-word.vbaData+xml';
        // private MacroDocumentContentType: string = 'application/vnd.ms-word.document.macroEnabled.main+xml';
        // private MacroTemplateContentType: string = 'application/vnd.ms-word.template.macroEnabledTemplate.main+xml';
        // private OleObjectContentType: string = 'application/vnd.openxmlformats-officedocument.oleObject';
        // Relationship types of document parts
        // private AltChunkRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/aFChunk';
        this.commentsRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments';
        this.commentsExRelType = 'http://schemas.microsoft.com/office/2011/relationships/commentsExtended';
        this.settingsRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings';
        // private EndnoteRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/endnotes';
        // private FontTableRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable';
        this.footerRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer';
        // private FootnoteRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes';
        this.headerRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/header';
        this.documentRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument';
        this.numberingRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering';
        this.stylesRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles';
        // private OleObjectRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject';
        this.chartRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart';
        // private ThemeRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme';
        this.fontRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/font';
        this.tableStyleRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/tableStyles';
        this.coreRelType = 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties';
        this.appRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties';
        this.customRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties';
        this.imageRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image';
        this.hyperlinkRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink';
        this.controlRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/control';
        this.packageRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/package';
        // private VbaProjectRelType: string = 'http://schemas.microsoft.com/office/2006/relationships/vbaProject';
        // private VbaDataRelType: string = 'http://schemas.microsoft.com/office/2006/relationships/wordVbaData';
        this.customXmlRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml';
        this.customUIRelType = 'http://schemas.microsoft.com/office/2006/relationships/ui/extensibility';
        this.attachedTemplateRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/attachedTemplate';
        this.chartColorStyleRelType = 'http://schemas.microsoft.com/office/2011/relationships/chartColorStyle';
        // private ChartStyleRelType: string = 'http://schemas.microsoft.com/office/2011/relationships/chartStyle';
        // private ChartUserShapesRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartUserShapes';
        // private ChartContentType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/package';
        // Namespaces
        // private PKG_namespace: string = 'http://schemas.microsoft.com/office/2006/xmlPackage';
        this.wNamespace = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main';
        this.wpNamespace = 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing';
        this.pictureNamespace = 'http://schemas.openxmlformats.org/drawingml/2006/picture';
        this.aNamespace = 'http://schemas.openxmlformats.org/drawingml/2006/main';
        this.a14Namespace = 'http://schemas.microsoft.com/office/drawing/2010/main';
        // private SVG_namespace: string = 'http://schemas.microsoft.com/office/drawing/2016/SVG/main';
        this.rNamespace = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships';
        this.rpNamespace = 'http://schemas.openxmlformats.org/package/2006/relationships';
        this.vNamespace = 'urn:schemas-microsoft-com:vml';
        this.oNamespace = 'urn:schemas-microsoft-com:office:office';
        this.xmlNamespace = 'http://www.w3.org/XML/1998/namespace';
        this.w10Namespace = 'urn:schemas-microsoft-com:office:word';
        this.cpNamespace = 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties';
        this.dcNamespace = 'http://purl.org/dc/elements/1.1/';
        // private DCTERMS_namespace: string = 'http://purl.org/dc/terms/';
        // private XSI_namespace: string = 'http://www.w3.org/2001/XMLSchema-instance';
        this.docPropsNamespace = 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties';
        this.veNamespace = 'http://schemas.openxmlformats.org/markup-compatibility/2006';
        this.mNamespace = 'http://schemas.openxmlformats.org/officeDocument/2006/math';
        this.wneNamespace = 'http://schemas.microsoft.com/office/word/2006/wordml';
        // private DCMI_namespace: string = 'http://purl.org/dc/dcmitype/';
        this.customPropsNamespace = 'http://schemas.openxmlformats.org/officeDocument/2006/custom-properties';
        this.vtNamespace = 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes';
        this.chartNamespace = 'http://schemas.openxmlformats.org/drawingml/2006/chart';
        this.slNamespace = 'http://schemas.openxmlformats.org/schemaLibrary/2006/main';
        //2003WML namespace
        // private amlNamespace: string = 'http://schemas.microsoft.com/aml/2001/core';
        this.dtNamespace = 'uuid:C2F41010-65B3-11d1-A29F-00AA00C14882';
        this.wmlNamespace = 'http://schemas.microsoft.com/office/word/2003/wordml';
        //2010 namespaces
        this.w14Namespace = 'http://schemas.microsoft.com/office/word/2010/wordml';
        this.wpCanvasNamespace = 'http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas';
        this.wpDrawingNamespace = 'http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing';
        this.wpGroupNamespace = 'http://schemas.microsoft.com/office/word/2010/wordprocessingGroup';
        this.wpInkNamespace = 'http://schemas.microsoft.com/office/word/2010/wordprocessingInk';
        this.wpShapeNamespace = 'http://schemas.microsoft.com/office/word/2010/wordprocessingShape';
        //2013 namespaces
        this.w15Namespace = 'http://schemas.microsoft.com/office/word/2012/wordml';
        this.diagramNamespace = 'http://schemas.openxmlformats.org/drawingml/2006/diagram';
        //Encryption namespaces
        this.eNamespace = 'http://schemas.microsoft.com/office/2006/encryption';
        this.pNamespace = 'http://schemas.microsoft.com/office/2006/keyEncryptor/password';
        this.certNamespace = 'http://schemas.microsoft.com/office/2006/keyEncryptor/certificate';
        this.cxNamespace = 'http://schemas.microsoft.com/office/drawing/2014/chartex';
        // chart
        this.c15Namespace = 'http://schemas.microsoft.com/office/drawing/2015/06/chart';
        this.c7Namespace = 'http://schemas.microsoft.com/office/drawing/2007/8/2/chart';
        this.csNamespace = 'http://schemas.microsoft.com/office/drawing/2012/chartStyle';
        // worksheet
        this.spreadSheetNamespace = 'http://schemas.openxmlformats.org/spreadsheetml/2006/main';
        this.spreadSheet9 = 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main';
        // Dls xml tags
        this.cRelationshipsTag = 'Relationships';
        this.cRelationshipTag = 'Relationship';
        this.cIdTag = 'Id';
        this.cTypeTag = 'Type';
        this.cTargetTag = 'Target';
        this.cUserShapesTag = 'userShapes';
        this.cExternalData = 'externalData';
        this.twipsInOnePoint = 20;
        this.twentiethOfPoint = 20;
        this.borderMultiplier = 8;
        this.percentageFactor = 50;
        this.emusPerPoint = 12700;
        // private const TOC_SYMBOL:string = (char)0x01;
        // private const FOOTNOTE_SYMBOL:string = (char)0x02;
        // private const PAGENUMBER_SYMBOL:string = (char)0xB;
        // private DEF_FIT_TEXT_TO_SHAPE: string = 'mso-fit-shape-to-text:t';
        // Document tags
        this.cConditionalTableStyleTag = 'tblStylePr';
        this.cTableFormatTag = 'tblPr';
        this.cTowFormatTag = 'trPr';
        this.cCellFormatTag = 'tcPr';
        this.cParagraphFormatTag = 'pPr';
        this.cCharacterFormatTag = 'rPr';
        this.packageType = 'http://schemas.microsoft.com/office/2006/xmlPackage';
        this.relsPartPath = '/_rels/.rels';
        this.documentRelsPartPath = '/word/_rels/document.xml.rels';
        this.webSettingsPath = '/word/webSettings.xml';
        this.wordMLDocumentPath = '/word/document.xml';
        this.wordMLStylePath = '/word/styles.xml';
        this.wordMLNumberingPath = '/word/numbering.xml';
        this.wordMLSettingsPath = '/word/settings.xml';
        this.wordMLHeaderPath = '/word/header';
        this.wordMLFooterPath = '/word/footer';
        this.wordMLCommentsPath = '/word/comments.xml';
        this.wordMLImagePath = '/word/media/image';
        this.wordMLFootnotesPath = '/word/footnotes.xml';
        this.wordMLEndnotesPath = '/word/endnotes.xml';
        this.wordMLAppPath = '/docProps/app.xml';
        this.wordMLCorePath = '/docProps/core.xml';
        this.wordMLCustomPath = '/docProps/custom.xml';
        this.wordMLFontTablePath = '/word/fontTable.xml';
        this.wordMLChartsPath = '/word/charts/';
        this.wordMLDefaultEmbeddingPath = '/word/embeddings/';
        this.wordMLEmbeddingPath = '/word/embeddings/';
        this.wordMLDrawingPath = '/word/drawings/';
        this.wordMLThemePath = '/word/theme/theme1.xml';
        this.wordMLFontsPath = '/word/fonts/';
        this.wordMLDiagramPath = '/word/diagrams/';
        this.wordMLControlPath = '/word/activeX/';
        this.wordMLVbaProject = '/vbaProject.bin';
        this.wordMLVbaData = '/vbaData.xml';
        this.wordMLVbaProjectPath = '/word/vbaProject.bin';
        this.wordMLVbaDataPath = '/word/vbaData.xml';
        // private WordMLCustomXMLPath: string = '/customXml/';
        this.wordMLWebSettingsPath = '/word/webSettings.xml';
        this.wordMLCustomItemProp1Path = '/customXml/itemProps1.xml';
        // private WordMLCustomXMLRelPath: string = '/customXml/_rels/item1.xml.rels';
        this.wordMLFootnoteRelPath = '/word/_rels/footnotes.xml.rels';
        this.wordMLEndnoteRelPath = '/word/_rels/endnotes.xml.rels';
        this.wordMLSettingsRelPath = '/word/_rels/settings.xml.rels';
        this.wordMLNumberingRelPath = '/word/_rels/numbering.xml.rels';
        this.wordMLFontTableRelPath = '/word/_rels/fontTable.xml.rels';
        this.wordMLCustomXmlPropsRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps';
        this.wordMLControlRelType = 'http://schemas.microsoft.com/office/2006/relationships/activeXControlBinary';
        this.wordMLDiagramContentType = 'application/vnd.ms-office.drawingml.diagramDrawing+xml';
        this.lastSection = false;
        this.mRelationShipID = 0;
        this.cRelationShipId = 0;
        this.eRelationShipId = 0;
        this.mDocPrID = 0;
        this.chartCount = 0;
        this.seriesCount = 0;
        this.chartStringCount = 0;
        this.mDifferentFirstPage = false;
        this.mBookmarks = undefined;
        this.mComments = [];
        this.paraID = 0;
        this.commentParaID = 0;
        this.commentParaIDInfo = {};
        this.isInsideComment = false;
        this.commentId = {};
        this.currentCommentId = 0;
        /* tslint:enable:no-any */
    }
    WordExport.prototype.getModuleName = function () {
        return 'WordExport';
    };
    Object.defineProperty(WordExport.prototype, "bookmarks", {
        // Gets the bookmark name
        get: function () {
            if (isNullOrUndefined(this.mBookmarks)) {
                this.mBookmarks = [];
            }
            return this.mBookmarks;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WordExport.prototype, "documentImages", {
        // Gets the collection of images present in the document body
        get: function () {
            if (this.mDocumentImages === undefined) {
                this.mDocumentImages = new Dictionary();
            }
            return this.mDocumentImages;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WordExport.prototype, "externalImages", {
        // Gets the collection of images present in the document body
        get: function () {
            if (this.mExternalLinkImages === undefined) {
                this.mExternalLinkImages = new Dictionary();
            }
            return this.mExternalLinkImages;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WordExport.prototype, "headerFooterImages", {
        // Gets the collections of images present in the HeaderFooters
        get: function () {
            if (this.mHeaderFooterImages === undefined) {
                this.mHeaderFooterImages = new Dictionary();
            }
            return this.mHeaderFooterImages;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WordExport.prototype, "documentCharts", {
        // Gets the collection of charts present in the document body
        get: function () {
            if (this.mDocumentCharts === undefined) {
                this.mDocumentCharts = new Dictionary();
            }
            return this.mDocumentCharts;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WordExport.prototype, "headersFooters", {
        /// Gets the HeaderFooter Collection
        get: function () {
            if (this.mHeaderFooterColl === undefined) {
                this.mHeaderFooterColl = new Dictionary();
            }
            return this.mHeaderFooterColl;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    WordExport.prototype.save = function (viewer, fileName) {
        this.fileName = fileName;
        this.serialize(viewer);
        this.mArchive.save(fileName + '.docx').then(function (mArchive) {
            mArchive.destroy();
        });
        this.close();
    };
    /**
     * @private
     */
    WordExport.prototype.saveAsBlob = function (viewer) {
        var _this = this;
        this.serialize(viewer);
        return new Promise(function (resolve, reject) {
            _this.mArchive.saveAsBlob().then(function (blob) {
                _this.mArchive.destroy();
                blob = new Blob([blob], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
                resolve(blob);
            });
        });
    };
    /**
     * @private
     */
    WordExport.prototype.saveExcel = function () {
        var _this = this;
        var xlsxPath = this.defaultEmbeddingPath + 'Microsoft_Excel_Worksheet' + this.chartCount + '.xlsx';
        var promise;
        var blobData;
        return promise = new Promise(function (resolve, reject) {
            _this.mArchiveExcel.saveAsBlob().then(function (blob) {
                blobData = blob;
                var zipArchiveItem = new ZipArchiveItem(blob, xlsxPath);
                _this.mArchive.addItem(zipArchiveItem);
                _this.mArchive.save(_this.fileName + '.docx').then(function (mArchive) {
                    mArchive.destroy();
                });
            });
            resolve(blobData);
            _this.mArchiveExcel = undefined;
        });
    };
    /**
     * @private
     */
    WordExport.prototype.destroy = function () {
        this.clearDocument();
        this.mRelationShipID = undefined;
        this.mDocPrID = undefined;
        this.mDifferentFirstPage = undefined;
        this.fileName = undefined;
        if (this.mArchive) {
            this.mArchive.destroy();
            this.mArchive = undefined;
        }
        if (this.mArchiveExcel) {
            this.mArchiveExcel.destroy();
            this.mArchiveExcel = undefined;
        }
    };
    // Saves the word document in the stream
    WordExport.prototype.serialize = function (viewer) {
        /* tslint:disable:no-any */
        var document = viewer.owner.sfdtExportModule.write();
        this.setDocument(document);
        this.mComments = viewer.comments;
        this.mArchive = new ZipArchive();
        this.mArchive.compressionLevel = 'Normal';
        this.commentParaIDInfo = {};
        this.commentParaID = 0;
        this.currentCommentId = 0;
        this.commentId = {};
        this.mVerticalMerge = new Dictionary();
        this.mGridSpans = new Dictionary();
        var contenttype;
        //document.xml
        this.serializeDocument();
        //Styles.xml
        this.serializeStyles();
        //numbering.xml
        this.serializeNumberings();
        //comments.xml
        this.serializeComments();
        //commentsExtended.xml
        this.serializeCommentsExtended();
        //theme.xml
        // if (m_document.DocHasThemes && !isNullOrUndefined(m_document.Themes))
        //     SerializeThemes();
        // else
        // this.serializeDefaultThemes();
        //settings.xml
        this.serializeSettings();
        //core.xml
        this.serializeCoreProperties();
        //app.xml
        this.serializeAppProperties();
        //fontTable.xml
        this.serializeFontTable(contenttype);
        //custom.xml
        // if (!isNullOrUndefined(this.wordDocument.CustomDocumentProperties) && m_document.CustomDocumentProperties.length > 0) {
        //     SerializeCustomProperties();
        // }
        //Settings Relations
        this.serializeSettingsRelation();
        //Numbering relation if the document has picture bullet
        // if (PictureBullets.length > 0) {
        //     SerializeNumberingsRelation();
        // }
        this.serializeHeaderFooters();
        //document relations
        this.serializeDocumentRelations();
        // // Add controls to archieve.
        // if (ControlsPathNames.length > 0) {
        //     AddControlsToZip(m_document.DocxPackage);
        // }
        // if (!isNullOrUndefined(m_document.CustomUIPartContainer))
        //     AddPartContainerToArchive(m_document.CustomUIPartContainer);
        // if (!isNullOrUndefined(m_document.CustomXMLContainer))
        //     AddPartContainerToArchive(m_document.CustomXMLContainer);
        //general relations
        this.serializeGeneralRelations();
        //[ContentTypes].xml
        this.serializeContentTypes(contenttype);
        // Clears the internal fields maintained for serializing.
        this.clearDocument();
    };
    // Sets the document
    WordExport.prototype.setDocument = function (document) {
        this.document = document;
        this.mSections = document.sections;
        this.mLists = document.lists;
        this.mAbstractLists = document.abstractLists;
        this.defCharacterFormat = document.characterFormat;
        this.defParagraphFormat = document.paragraphFormat;
        this.defaultTabWidthValue = document.defaultTabWidth;
        this.mStyles = document.styles;
        this.formatting = document.formatting;
        this.enforcement = document.enforcement;
        this.hashValue = document.hashValue;
        this.saltValue = document.saltValue;
        this.protectionType = document.protectionType;
    };
    // Clears the document
    WordExport.prototype.clearDocument = function () {
        // Owner Nodes
        this.section = undefined;
        this.lastSection = undefined;
        this.blockOwner = undefined;
        this.paragraph = undefined;
        this.table = undefined;
        this.row = undefined;
        this.headerFooter = undefined;
        this.commentParaIDInfo = {};
        this.commentParaID = 0;
        this.currentCommentId = 0;
        this.commentId = {};
        this.document = undefined;
        this.mSections = undefined;
        this.mLists = undefined;
        this.mAbstractLists = undefined;
        this.defCharacterFormat = undefined;
        this.defParagraphFormat = undefined;
        this.defaultTabWidthValue = undefined;
        this.mRelationShipID = 0;
        this.eRelationShipId = 0;
        this.cRelationShipId = 0;
        this.mDocPrID = 0;
        this.chartCount = 0;
        this.mDifferentFirstPage = false;
        if (this.mHeaderFooterColl) {
            this.mHeaderFooterColl.destroy();
            this.mHeaderFooterColl = undefined;
        }
        if (this.mVerticalMerge) {
            this.mVerticalMerge.destroy();
            this.mVerticalMerge = undefined;
        }
        if (this.mGridSpans) {
            this.mGridSpans.destroy();
            this.mGridSpans = undefined;
        }
        if (this.mDocumentImages) {
            this.mDocumentImages.destroy();
            this.mDocumentImages = undefined;
        }
        if (this.mExternalLinkImages) {
            this.mExternalLinkImages.destroy();
            this.mExternalLinkImages = undefined;
        }
        if (this.mHeaderFooterImages) {
            this.mHeaderFooterImages.destroy();
            this.mHeaderFooterImages = undefined;
        }
        if (this.mDocumentCharts) {
            this.mDocumentCharts.destroy();
            this.mDocumentCharts = undefined;
        }
    };
    // Serializes the document elements (document.xml)
    WordExport.prototype.serializeDocument = function () {
        var writer = new XmlWriter();
        writer.writeStartElement('w', 'document', this.wNamespace);
        this.writeCommonAttributeStrings(writer);
        this.serializeDocumentBody(writer);
        writer.writeEndElement(); //end of document tag
        var archiveItem = new ZipArchiveItem(writer.buffer, this.documentPath);
        this.mArchive.addItem(archiveItem);
    };
    WordExport.prototype.writeCommonAttributeStrings = function (writer) {
        writer.writeAttributeString('xmlns', 'wpc', undefined, this.wpCanvasNamespace);
        this.writeCustom(writer);
        writer.writeAttributeString('xmlns', 'wp14', undefined, this.wpDrawingNamespace);
        writer.writeAttributeString('xmlns', 'wp', undefined, this.wpNamespace);
        writer.writeAttributeString('xmlns', 'w10', undefined, this.w10Namespace);
        writer.writeAttributeString('xmlns', 'w', undefined, this.wNamespace);
        this.writeDup(writer);
        writer.writeAttributeString('xmlns', 'wne', undefined, this.wneNamespace);
        writer.writeAttributeString('xmlns', 'wps', undefined, this.wpShapeNamespace);
        writer.writeAttributeString('mc', 'Ignorable', undefined, 'w14 w15 wp14');
    };
    WordExport.prototype.writeDup = function (writer) {
        writer.writeAttributeString('xmlns', 'w14', undefined, this.w14Namespace);
        writer.writeAttributeString('xmlns', 'w15', undefined, this.w15Namespace);
        writer.writeAttributeString('xmlns', 'wpg', undefined, this.wpGroupNamespace);
        writer.writeAttributeString('xmlns', 'wpi', undefined, this.wpInkNamespace);
    };
    WordExport.prototype.writeCustom = function (writer) {
        writer.writeAttributeString('xmlns', 'mc', undefined, this.veNamespace);
        writer.writeAttributeString('xmlns', 'o', undefined, this.oNamespace);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', 'm', undefined, this.mNamespace);
        writer.writeAttributeString('xmlns', 'v', undefined, this.vNamespace);
    };
    // Serializes the document body
    WordExport.prototype.serializeDocumentBody = function (writer) {
        writer.writeStartElement(undefined, 'body', this.wNamespace);
        var count = this.document.sections.length;
        for (var i = 0; i < count; i++) {
            this.section = this.document.sections[i];
            this.lastSection = i === count - 1;
            this.serializeSection(writer, this.section, i === count - 1);
            this.section = undefined;
        }
        writer.writeEndElement();
    };
    // Serializes the Section.
    WordExport.prototype.serializeSection = function (writer, section, last) {
        this.blockOwner = section;
        this.serializeBodyItems(writer, section.blocks, last);
        if (last) {
            this.serializeSectionProperties(writer, section);
        }
        this.blockOwner = undefined;
    };
    // Serialize the comments (comments.xml)
    WordExport.prototype.serializeComments = function () {
        if (this.mComments.length === 0) {
            return;
        }
        var writer = new XmlWriter();
        writer.writeStartElement('w', 'comments', this.wNamespace);
        this.serializeCommentCommonAttribute(writer);
        this.serializeCommentInternal(writer, this.mComments, false);
        writer.writeEndElement();
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, this.commentsPath);
        this.mArchive.addItem(zipArchiveItem);
    };
    WordExport.prototype.serializeCommentCommonAttribute = function (writer) {
        writer.writeAttributeString('xmlns', 'wpc', undefined, this.wpCanvasNamespace);
        writer.writeAttributeString('xmlns', 'cx', undefined, this.cxNamespace);
        writer.writeAttributeString('xmlns', 'mc', undefined, this.veNamespace);
        writer.writeAttributeString('xmlns', 'o', undefined, this.oNamespace);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', 'm', undefined, this.mNamespace);
        writer.writeAttributeString('xmlns', 'v', undefined, this.vNamespace);
        writer.writeAttributeString('xmlns', 'wp14', undefined, this.wpDrawingNamespace);
        writer.writeAttributeString('xmlns', 'wp', undefined, this.wpNamespace);
        writer.writeAttributeString('xmlns', 'w10', undefined, this.w10Namespace);
        writer.writeAttributeString('xmlns', 'w', undefined, this.wNamespace);
        writer.writeAttributeString('xmlns', 'w14', undefined, this.w14Namespace);
        writer.writeAttributeString('xmlns', 'w15', undefined, this.w15Namespace);
        writer.writeAttributeString('mc', 'Ignorable', undefined, 'w14 w15');
    };
    WordExport.prototype.serializeCommentInternal = function (writer, comments, isreplay) {
        for (var i = 0; i < comments.length; i++) {
            var comment = comments[i];
            writer.writeStartElement('w', 'comment', this.wNamespace);
            writer.writeAttributeString('w', 'id', this.wNamespace, this.commentId[comment.commentId].toString());
            if (comment.author && comment.author !== ' ') {
                writer.writeAttributeString('w', 'author', this.wNamespace, comment.author);
            }
            if (comment.date) {
                writer.writeAttributeString('w', 'date', this.wNamespace, comment.date);
            }
            if (comment.initial && comment.initial !== '') {
                writer.writeAttributeString('w', 'initials', this.wNamespace, comment.initial);
            }
            var blocks = this.retrieveCommentText(comment.text);
            for (var k = 0; k < blocks.length; k++) {
                this.isInsideComment = true;
                this.commentParaID++;
                this.serializeBodyItem(writer, blocks[k], true);
                this.isInsideComment = false;
            }
            //if (blocks.length > 0) {
            this.commentParaIDInfo[comment.commentId] = this.commentParaID;
            //}
            //}
            this.isInsideComment = false;
            //}
            writer.writeEndElement();
            if (comment.replyComments.length > 0) {
                this.serializeCommentInternal(writer, comment.replyComments, true);
            }
        }
    };
    WordExport.prototype.retrieveCommentText = function (text) {
        var blocks = [];
        var multiText = text.split('\n');
        multiText = multiText.filter(function (x) { return x !== ''; });
        while (multiText.length > 0) {
            var block = {};
            block.inlines = [{ text: multiText[0] }];
            blocks.push(block);
            multiText.splice(0, 1);
        }
        return blocks;
    };
    // Serialize the comments (commentsExtended.xml)
    WordExport.prototype.serializeCommentsExtended = function () {
        if (this.mComments.length === 0) {
            return;
        }
        var writer = new XmlWriter();
        writer.writeStartElement('w15', 'commentsEx', this.wNamespace);
        this.serializeCommentCommonAttribute(writer);
        this.serializeCommentsExInternal(writer, this.mComments, false);
        writer.writeEndElement();
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, this.commentsExtendedPath);
        this.mArchive.addItem(zipArchiveItem);
    };
    WordExport.prototype.serializeCommentsExInternal = function (writer, comments, isReply) {
        for (var i = 0; i < comments.length; i++) {
            var comment = comments[i];
            writer.writeStartElement('w15', 'commentEx', this.wNamespace);
            //if (comment.blocks.length > 0) {
            var syncParaID = this.commentParaIDInfo[comment.commentId];
            if (isReply) {
                var paraID = this.commentParaIDInfo[comment.ownerComment.commentId];
                writer.writeAttributeString('w15', 'paraIdParent', this.wNamespace, paraID.toString());
            }
            writer.writeAttributeString('w15', 'paraId', this.wNamespace, syncParaID.toString());
            //}
            var val = comment.done ? 1 : 0;
            writer.writeAttributeString('w15', 'done', this.wNamespace, val.toString());
            writer.writeEndElement();
            if (comment.replyComments.length > 0) {
                this.serializeCommentsExInternal(writer, comment.replyComments, true);
            }
        }
    };
    // Serialize the section properties.
    WordExport.prototype.serializeSectionProperties = function (writer, section) {
        writer.writeStartElement('w', 'sectPr', this.wNamespace);
        if (section.headersFooters) {
            this.serializeHFReference(writer, section.headersFooters);
        }
        // if (IsNeedToSerializeSectionFootNoteProperties(section))
        //     SerializeFootnoteProperties(section);
        // if (IsNeedToSerializeSectionEndNoteProperties(section))
        //     SerializeEndnoteProperties(section);      
        this.serializeSectionType(writer, 'nextPage');
        this.serializePageSetup(writer, section.sectionFormat);
        this.serializeColumns(writer, section);
        // this.serializeSectionProtection(section);
        // if (section.PageSetup.VerticalAlignment !== PageAlignment.Top) {
        //     writer.writeStartElement('vAlign', this.wNamespace);
        //     switch (section.PageSetup.VerticalAlignment) {
        //         case PageAlignment.Top:
        //             writer.WriteAttributeString('val', this.wNamespace, 'top');
        //             break;
        //         case PageAlignment.Middle:
        //             writer.WriteAttributeString('val', this.wNamespace, 'center');
        //             break;
        //         case PageAlignment.Justified:
        //             writer.WriteAttributeString('val', this.wNamespace, 'both');
        //             break;
        //         case PageAlignment.Bottom:
        //             writer.WriteAttributeString('val', this.wNamespace, 'bottom');
        //             break;
        //     }
        //     writer.WriteEndElement();
        // }
        if (section.sectionFormat !== undefined && section.sectionFormat.differentFirstPage) {
            writer.writeStartElement(undefined, 'titlePg', this.wNamespace);
            writer.writeEndElement();
        }
        // SerializeTextDirection(section);
        if (!isNullOrUndefined(section.sectionFormat) && section.sectionFormat.bidi) {
            writer.writeStartElement(undefined, 'bidi', this.wNamespace);
            writer.writeEndElement();
        }
        //rtlGutter
        // SerializeDocGrid(section);
        //printerSettings
        writer.writeEndElement(); //end of sectPr tag
    };
    // Serialize the column properties of section.
    WordExport.prototype.serializeColumns = function (writer, section) {
        writer.writeStartElement(undefined, 'cols', this.wNamespace);
        writer.writeAttributeString(undefined, 'equalWidth', this.wNamespace, '1');
        writer.writeAttributeString(undefined, 'space', this.wNamespace, '0');
        writer.writeEndElement();
        // ColumnCollection columns = section.Columns;
        // writer.WriteStartElement('cols', this.wNamespace);
        // if (columns.length > 0)
        // {
        //     writer.WriteAttributeString('num', this.wNamespace, columns.length.ToString());
        // }
        // if (section.PageSetup.DrawLinesBetweenCols)
        //     writer.WriteAttributeString('sep', this.wNamespace, '1');
        // if (columns.OwnerSection.PageSetup.EqualColumnWidth)
        // {
        //     writer.WriteAttributeString('equalWidth', this.wNamespace, '1');
        //     //When the column count is negative, MS word just reset the column's count to zero
        //     //To avoid index out of exception, checked the columns count
        // tslint:disable-next-line:max-line-length
        //     writer.WriteAttributeString('space', this.wNamespace, ToString(columns.length > 0 ? columns[0].Space * this.TwentiethOfPoint : 0));
        // }
        // else if (columns.length > 0)
        // {
        //     writer.WriteAttributeString('equalWidth', this.wNamespace, '0');
        //     foreach (Column column in columns)
        //     {
        //         writer.WriteStartElement('col', this.wNamespace);
        //         writer.WriteAttributeString('w', this.wNamespace, ToString(column.Width * this.TwentiethOfPoint));
        // tslint:disable-next-line:max-line-length
        //         writer.WriteAttributeString('space', this.wNamespace, ToString(column.Space * this.TwentiethOfPoint));
        //         writer.WriteEndElement();
        //     }
        // }
        // writer.WriteEndElement();
    };
    // Serialize the page setup properties.
    WordExport.prototype.serializePageSetup = function (writer, pageSetup) {
        if (pageSetup !== undefined) {
            this.serializePageSize(writer, pageSetup);
            this.serializePageMargins(writer, pageSetup);
        }
        // // StartElement paperSrc (if any)
        // if (pageSetup.FirstPageTray > 0 || pageSetup.OtherPagesTray > 0) {
        //     writer.WriteStartElement('paperSrc', this.wNamespace);
        //     if (pageSetup.FirstPageTray > 0) {
        //         writer.WriteAttributeString('first', this.wNamespace, pageSetup.FirstPageTray.ToString());
        //     }
        //     if (pageSetup.OtherPagesTray > 0) {
        //         writer.WriteAttributeString('other', this.wNamespace, pageSetup.OtherPagesTray.ToString());
        //     }
        //     writer.WriteEndElement();
        // }
        writer.writeStartElement(undefined, 'pgBorders', this.wNamespace);
        // //zOrder
        // if (pageSetup.PageBordersApplyType === PageBordersApplyType.FirstPage)
        //     writer.WriteAttributeString('display', this.wNamespace, 'firstPage');
        // else if (pageSetup.PageBordersApplyType === PageBordersApplyType.AllExceptFirstPage)
        //     writer.WriteAttributeString('display', this.wNamespace, 'notFirstPage');
        // if (pageSetup.PageBorderOffsetFrom === PageBorderOffsetFrom.PageEdge) {
        //     writer.WriteAttributeString('offsetFrom', this.wNamespace, 'page');
        // }
        // //Serializing zOrder of the front page border
        // if (!pageSetup.IsFrontPageBorder) {
        //     writer.WriteAttributeString('zOrder', this.wNamespace, 'back');
        // }
        // SerializePageBorders(pageSetup.Borders);
        writer.writeEndElement();
        // this.serializeLineNumberType(writer, pageSetup);
        //this.serializePageNumberType(writer, pageSetup);
    };
    // serialize the page size
    WordExport.prototype.serializePageSize = function (writer, pageSetup) {
        writer.writeStartElement(undefined, 'pgSz', this.wNamespace);
        // tslint:disable-next-line:max-line-length
        writer.writeAttributeString(undefined, 'w', this.wNamespace, this.roundToTwoDecimal(pageSetup.pageWidth * this.twentiethOfPoint).toString());
        // tslint:disable-next-line:max-line-length
        writer.writeAttributeString(undefined, 'h', this.wNamespace, this.roundToTwoDecimal(pageSetup.pageHeight * this.twentiethOfPoint).toString());
        // if (pageSetup.Orientation === PageOrientation.Landscape)
        // {
        //     writer.WriteAttributeString('orient', this.wNamespace, 'landscape');
        // }
        writer.writeEndElement();
    };
    // Serialize the border.
    WordExport.prototype.serializePageMargins = function (writer, pageSetup) {
        writer.writeStartElement(undefined, 'pgMar', this.wNamespace);
        var marginValue = Math.round(pageSetup.topMargin * this.twentiethOfPoint);
        writer.writeAttributeString(undefined, 'top', this.wNamespace, marginValue.toString());
        marginValue = Math.round(pageSetup.rightMargin * this.twentiethOfPoint);
        writer.writeAttributeString(undefined, 'right', this.wNamespace, marginValue.toString());
        marginValue = Math.round(pageSetup.bottomMargin * this.twentiethOfPoint);
        writer.writeAttributeString(undefined, 'bottom', this.wNamespace, marginValue.toString());
        marginValue = Math.round(pageSetup.leftMargin * this.twentiethOfPoint);
        writer.writeAttributeString(undefined, 'left', this.wNamespace, marginValue.toString());
        // tslint:disable-next-line:max-line-length
        writer.writeAttributeString(undefined, 'header', this.wNamespace, this.roundToTwoDecimal(pageSetup.headerDistance * this.twentiethOfPoint).toString());
        // tslint:disable-next-line:max-line-length
        writer.writeAttributeString(undefined, 'footer', this.wNamespace, this.roundToTwoDecimal(pageSetup.footerDistance * this.twentiethOfPoint).toString());
        writer.writeAttributeString(undefined, 'gutter', this.wNamespace, '0');
        writer.writeEndElement();
    };
    // Serialize the section type.
    WordExport.prototype.serializeSectionType = function (writer, sectionBreakCode) {
        writer.writeStartElement('w', 'type', this.wNamespace);
        writer.writeAttributeString('w', 'val', this.wNamespace, sectionBreakCode); //GetSectionBreakCode(sectionBreakCode));
        writer.writeEndElement();
    };
    // Serialize the heeader/footer reference.
    WordExport.prototype.serializeHFReference = function (writer, headersFooters) {
        var hfId = '';
        if (headersFooters !== undefined) {
            this.mDifferentFirstPage = this.section.sectionFormat.differentOddAndEvenPages;
            var hf = headersFooters.firstPageHeader;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'headerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'first');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'FirstPageHeader', hfId);
                writer.writeEndElement();
            }
            hf = headersFooters.firstPageFooter;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'footerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'first');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'FirstPageFooter', hfId);
                writer.writeEndElement();
            }
            hf = headersFooters.evenHeader;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'headerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'even');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'EvenHeader', hfId);
                writer.writeEndElement();
            }
            hf = headersFooters.evenFooter;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'footerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'even');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'EvenFooter', hfId);
                writer.writeEndElement();
            }
            hf = headersFooters.header;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'headerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'default');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'OddHeader', hfId);
                writer.writeEndElement();
            }
            hf = headersFooters.footer;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'footerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'default');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'OddFooter', hfId);
                writer.writeEndElement();
            }
        }
    };
    // Adds the header footer details to the collection.
    WordExport.prototype.addHeaderFooter = function (hf, hfType, id) {
        var hfColl = new Dictionary();
        this.headersFooters.add(hfType, hfColl);
        this.headersFooters.get(hfType).add(id, hf);
    };
    // Serializes the bodyItems
    WordExport.prototype.serializeBodyItems = function (writer, blockCollection, isLastSection) {
        for (var i = 0; i < blockCollection.length; i++) {
            this.serializeBodyItem(writer, blockCollection[i], isLastSection);
        }
    };
    // Serialize the TextBody item
    WordExport.prototype.serializeBodyItem = function (writer, item, isLastSection) {
        if (isNullOrUndefined(item)) {
            throw new Error('BodyItem should not be undefined');
        }
        if (item.hasOwnProperty('inlines')) {
            this.paragraph = item;
            this.serializeParagraph(writer, item, isLastSection);
            this.paragraph = undefined;
        }
        else {
            var table = item;
            for (var i = 0; i < table.rows.length; i++) {
                if (table.rows[i].cells.length > 0) {
                    this.serializeTable(writer, table);
                    break;
                }
            }
        }
        var sec = this.blockOwner;
        //Need to write the Section Properties if the Paragraph is last item in the section
        if (!isLastSection && sec.hasOwnProperty('sectionFormat')
            && sec.blocks.indexOf(item) === sec.blocks.length - 1) {
            writer.writeStartElement('w', 'p', this.wNamespace);
            writer.writeStartElement(undefined, 'pPr', this.wNamespace);
            this.serializeSectionProperties(writer, sec);
            writer.writeEndElement();
            writer.writeEndElement();
        }
    };
    // Serialize the paragraph
    WordExport.prototype.serializeParagraph = function (writer, paragraph, isLastSection) {
        if (isNullOrUndefined(paragraph)) {
            throw new Error('Paragraph should not be undefined');
        }
        // if (paragraph.ParagraphFormat.PageBreakAfter && !IsPageBreakNeedToBeSkipped(paragraph as Entity))
        //     paragraph.InsertBreak(BreakType.PageBreak);
        // if (paragraph.ParagraphFormat.ColumnBreakAfter && !IsPageBreakNeedToBeSkipped(paragraph as Entity))
        //     paragraph.InsertBreak(BreakType.ColumnBreak);
        //Splits the paragraph based on the newline character
        // paragraph.SplitTextRange();
        writer.writeStartElement('w', 'p', this.wNamespace);
        if (this.isInsideComment) {
            writer.writeAttributeString('w14', 'paraId', undefined, this.commentParaID.toString());
        }
        writer.writeStartElement(undefined, 'pPr', this.wNamespace);
        if (!isNullOrUndefined(paragraph.paragraphFormat)) {
            this.serializeParagraphFormat(writer, paragraph.paragraphFormat, paragraph);
        }
        if (!isNullOrUndefined(paragraph.characterFormat)) {
            this.serializeCharacterFormat(writer, paragraph.characterFormat);
        }
        writer.writeEndElement(); //end of pPr
        // Serialize watermark if paragraph is the first item of Header document.
        // EnsureWatermark(paragraph);
        this.serializeParagraphItems(writer, paragraph.inlines);
        writer.writeEndElement(); //end of paragraph tag.
    };
    // Serialize the paragraph items
    WordExport.prototype.serializeParagraphItems = function (writer, paraItems) {
        var previousNode = undefined;
        var isContinueOverride = false;
        for (var i = 0; i < paraItems.length; i++) {
            var item = paraItems[i];
            var isBdo = false;
            if (item.characterFormat) {
                isBdo = !isNullOrUndefined(item.characterFormat.bdo) && item.characterFormat.bdo !== 'None';
                if (isBdo && !isContinueOverride) {
                    this.serializeBiDirectionalOverride(writer, item.characterFormat);
                    isContinueOverride = true;
                }
            }
            if (isContinueOverride && !isBdo) {
                writer.writeEndElement();
                isContinueOverride = false;
            }
            if (item.hasOwnProperty('fieldType')) {
                this.serializeFieldCharacter(writer, item);
            }
            else if (item.hasOwnProperty('imageString')) {
                this.serializePicture(writer, item);
            }
            else if (item.hasOwnProperty('bookmarkType')) {
                this.serializeBookMark(writer, item);
            }
            else if (item.hasOwnProperty('editRangeId')) {
                this.serializeEditRange(writer, item);
            }
            else if (item.hasOwnProperty('chartType')) {
                this.chart = item;
                this.serializeChart(writer, item);
                // chart.xml
                this.serializeChartStructure();
            }
            else if (item.hasOwnProperty('commentCharacterType')) {
                this.serializeComment(writer, item);
            }
            else {
                this.serializeTextRange(writer, item, previousNode);
            }
            previousNode = item;
        }
        if (isContinueOverride) {
            writer.writeEndElement();
        }
    };
    // Serialize the comment
    WordExport.prototype.serializeComment = function (writer, comment) {
        if (comment.commentCharacterType === 0) {
            writer.writeStartElement('w', 'commentRangeStart', this.wNamespace);
        }
        else if (comment.commentCharacterType === 1) {
            writer.writeStartElement('w', 'commentRangeEnd', this.wNamespace);
        }
        var commentId = this.commentId[comment.commentId];
        if (isNullOrUndefined(commentId)) {
            commentId = this.commentId[comment.commentId] = this.currentCommentId++;
        }
        writer.writeAttributeString('w', 'id', this.wNamespace, commentId.toString());
        writer.writeEndElement();
        if (comment.commentCharacterType === 1) {
            this.serializeCommentItems(writer, commentId);
        }
    };
    WordExport.prototype.serializeCommentItems = function (writer, commentId) {
        writer.writeStartElement('w', 'r', this.wNamespace);
        writer.writeStartElement('w', 'commentReference', this.wNamespace);
        writer.writeAttributeString('w', 'id', this.wNamespace, commentId.toString());
        writer.writeEndElement();
        writer.writeEndElement();
    };
    WordExport.prototype.serializeBiDirectionalOverride = function (writer, characterFormat) {
        writer.writeStartElement(undefined, 'bdo', this.wNamespace);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, characterFormat.bdo.toLowerCase());
    };
    // Serialize Document Protection
    //<w:permStart w:id="627587516" w:edGrp="everyone" />
    WordExport.prototype.serializeEditRange = function (writer, editElement) {
        if (editElement.hasOwnProperty('editableRangeStart')) {
            writer.writeStartElement('w', 'permEnd', this.wNamespace);
        }
        else {
            writer.writeStartElement('w', 'permStart', this.wNamespace);
            if (editElement.user && editElement.user !== '') {
                writer.writeAttributeString('w', 'ed', this.wNamespace, editElement.user);
            }
            if (editElement.group && editElement.group !== '') {
                writer.writeAttributeString('w', 'edGrp', this.wNamespace, editElement.group.toLowerCase());
            }
            if (editElement.columnFirst && editElement.columnFirst !== -1) {
                writer.writeAttributeString('w', 'colFirst', this.wNamespace, editElement.columnFirst.toString());
            }
            if (editElement.columnLast && editElement.columnLast !== -1) {
                writer.writeAttributeString('w', 'colLast', this.wNamespace, editElement.columnLast.toString());
            }
        }
        writer.writeAttributeString('w', 'id', this.wNamespace, editElement.editRangeId);
        writer.writeEndElement();
    };
    // Serialize the book mark
    WordExport.prototype.serializeBookMark = function (writer, bookmark) {
        var bookmarkId = this.getBookmarkId(bookmark.name);
        var bookmarkName = bookmark.name;
        if (bookmark.bookmarkType === 0) {
            writer.writeStartElement('w', 'bookmarkStart', this.wNamespace);
            writer.writeAttributeString('w', 'name', this.wNamespace, bookmarkName);
        }
        else if (bookmark.bookmarkType === 1) {
            writer.writeStartElement('w', 'bookmarkEnd', this.wNamespace);
        }
        writer.writeAttributeString('w', 'id', this.wNamespace, bookmarkId.toString());
        writer.writeEndElement();
    };
    WordExport.prototype.getBookmarkId = function (name) {
        var index = this.bookmarks.indexOf(name);
        if (index < 0) {
            index = this.bookmarks.length;
            this.bookmarks.push(name);
        }
        return index;
    };
    // Serialize the picture.
    WordExport.prototype.serializePicture = function (writer, image) {
        if (image.width >= 0 && image.height >= 0) {
            writer.writeStartElement(undefined, 'r', this.wNamespace);
            this.serializeCharacterFormat(writer, image.characterFormat);
            this.serializeDrawing(writer, image);
            writer.writeEndElement(); //end of run element
        }
    };
    // Serialize the drawing element.
    WordExport.prototype.serializeDrawing = function (writer, draw) {
        writer.writeStartElement(undefined, 'drawing', this.wNamespace);
        if (draw.hasOwnProperty('chartType')) {
            this.serializeInlineCharts(writer, draw);
        }
        else {
            this.serializeInlinePicture(writer, draw);
        }
        writer.writeEndElement();
    };
    // Serialize the inline picture.
    WordExport.prototype.serializeInlinePicture = function (writer, image) {
        writer.writeStartElement(undefined, 'inline', this.wpNamespace);
        writer.writeStartElement(undefined, 'extent', this.wpNamespace);
        var cx = Math.round(image.width * this.emusPerPoint);
        writer.writeAttributeString(undefined, 'cx', undefined, cx.toString());
        var cy = Math.round(image.height * this.emusPerPoint);
        writer.writeAttributeString(undefined, 'cy', undefined, cy.toString());
        writer.writeEndElement();
        // double borderWidth = (double)picture.PictureShape.PictureDescriptor.BorderLeft.LineWidth / DLSConstants.BorderLineFactor;
        // if (borderWidth > 0 && picture.DocxProps.length === 0) {
        //     long leftTop = 0, rightBottom = 0;
        //     picture.PictureShape.GetEffectExtent(borderWidth, ref leftTop, ref rightBottom);
        //     m_writer.WriteStartElement('effectExtent', WP_namespace);
        //     m_writer.WriteAttributeString('l', leftTop.ToString(CultureInfo.InvariantCulture));
        //     m_writer.WriteAttributeString('t', leftTop.ToString(CultureInfo.InvariantCulture));
        //     m_writer.WriteAttributeString('r', rightBottom.ToString(CultureInfo.InvariantCulture));
        //     m_writer.WriteAttributeString('b', rightBottom.ToString(CultureInfo.InvariantCulture));
        //     m_writer.WriteEndElement();
        // }
        //this.serializePicProperties(writer, image);
        this.serializeDrawingGraphics(writer, image);
        writer.writeEndElement();
    };
    // serialize inline chart
    WordExport.prototype.serializeInlineCharts = function (writer, item) {
        writer.writeStartElement(undefined, 'inline', this.wpNamespace);
        writer.writeAttributeString(undefined, 'distT', undefined, '0');
        writer.writeAttributeString(undefined, 'distB', undefined, '0');
        writer.writeAttributeString(undefined, 'distL', undefined, '0');
        writer.writeAttributeString(undefined, 'distR', undefined, '0');
        writer.writeStartElement(undefined, 'extent', this.wpNamespace);
        var cx = Math.round(item.width * this.emusPerPoint);
        writer.writeAttributeString(undefined, 'cx', undefined, cx.toString());
        var cy = Math.round(item.height * this.emusPerPoint);
        writer.writeAttributeString(undefined, 'cy', undefined, cy.toString());
        writer.writeEndElement(); // end of wp:extend
        writer.writeStartElement(undefined, 'effectExtent', this.wpNamespace);
        writer.writeAttributeString(undefined, 'l', undefined, '0');
        writer.writeAttributeString(undefined, 't', undefined, '0');
        writer.writeAttributeString(undefined, 'r', undefined, '0');
        writer.writeAttributeString(undefined, 'b', undefined, '0');
        writer.writeEndElement(); // end of wp: effectExtent
        this.serializeDrawingGraphicsChart(writer, item);
        writer.writeEndElement(); // end of inline
    };
    // Serialize the graphics element for chart.
    WordExport.prototype.serializeDrawingGraphicsChart = function (writer, chart) {
        var id = '';
        id = this.updatechartId(chart);
        // Processing chart
        writer.writeStartElement('wp', 'docPr', this.wpNamespace);
        writer.writeAttributeString(undefined, 'id', undefined, (this.mDocPrID++).toString());
        writer.writeAttributeString(undefined, 'name', undefined, this.getNextChartName());
        writer.writeEndElement(); // end of wp docPr
        writer.writeStartElement('wp', 'cNvGraphicFramePr', this.wpNamespace);
        writer.writeEndElement(); // end of cNvGraphicFramePr
        writer.writeStartElement('a', 'graphic', this.aNamespace);
        writer.writeStartElement('a', 'graphicData', this.aNamespace);
        writer.writeAttributeString(undefined, 'uri', undefined, this.chartNamespace);
        writer.writeStartElement('c', 'chart', this.chartNamespace);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('r', 'id', undefined, id);
        writer.writeEndElement(); // end of chart
        writer.writeEndElement(); // end of graphic data
        writer.writeEndElement(); // end of graphic
    };
    WordExport.prototype.getNextChartName = function () {
        return 'Chart' + (++this.chartCount);
    };
    // serialize chart
    WordExport.prototype.serializeChart = function (writer, chart) {
        writer.writeStartElement('w', 'r', this.wNamespace);
        this.serializeCharacterFormat(writer, chart.characterFormat);
        this.serializeDrawing(writer, chart);
        writer.writeEndElement();
    };
    WordExport.prototype.serializeChartStructure = function () {
        this.serializeChartXML();
        this.serializeChartColors();
        this.serializeChartExcelData();
        this.serializeChartRelations();
        this.chart = undefined;
        this.saveExcel();
    };
    // serialize Chart.xml
    WordExport.prototype.serializeChartXML = function () {
        var chartPath = '';
        var writer = new XmlWriter();
        writer.writeStartElement('c', 'chartSpace', this.chartNamespace);
        writer.writeAttributeString('xmlns', 'a', undefined, this.aNamespace);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', 'c16r2', undefined, this.c15Namespace);
        this.serializeChartData(writer, this.chart);
        writer.writeStartElement('c', 'externalData', this.chartNamespace);
        writer.writeAttributeString('r', 'id', undefined, 'rId1');
        writer.writeStartElement('c', 'autoUpdate', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of autoUpdate
        writer.writeEndElement(); // end of externalData
        writer.writeEndElement(); // end of chartSpace
        chartPath = this.chartPath + '/chart' + this.chartCount + '.xml';
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, chartPath);
        this.mArchive.addItem(zipArchiveItem);
    };
    // serialize chart colors.xml
    WordExport.prototype.serializeChartColors = function () {
        var writer = new XmlWriter();
        var colorPath = '';
        writer.writeStartElement('cs', 'colorStyle', this.csNamespace);
        writer.writeAttributeString('xmlns', 'a', undefined, this.aNamespace);
        writer.writeAttributeString(undefined, 'meth', undefined, 'cycle');
        writer.writeAttributeString(undefined, 'id', undefined, '10');
        this.serializeChartColor(writer, this.chart);
        colorPath = this.chartPath + '/colors' + this.chartCount + '.xml';
        writer.writeEndElement(); // end of cs:colorStyle chart color
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, colorPath);
        this.mArchive.addItem(zipArchiveItem);
        colorPath = '';
    };
    WordExport.prototype.serializeChartColor = function (writer, chart) {
        for (var i = 1; i <= 6; i++) {
            writer.writeStartElement('a', 'schemeClr', this.aNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'accent' + i);
            writer.writeEndElement(); // end of a:schemeClr
        }
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '60000');
        writer.writeEndElement(); // end of lumMod
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '80000');
        writer.writeEndElement(); // end of lumMod
        writer.writeStartElement('a', 'lumOff', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '20000');
        writer.writeEndElement(); // end of lumoff
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '80000');
        writer.writeEndElement(); // end of lumMod
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '60000');
        writer.writeEndElement(); // end of lumMod
        writer.writeStartElement('a', 'lumOff', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '40000');
        writer.writeEndElement(); // end of lumoff
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '50000');
        writer.writeEndElement(); // end of lumMod
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '70000');
        writer.writeEndElement(); // end of lumMod
        writer.writeStartElement('a', 'lumOff', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '30000');
        writer.writeEndElement(); // end of lumoff
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '70000');
        writer.writeEndElement(); // end of lumMod
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '50000');
        writer.writeEndElement(); // end of lumMod
        writer.writeStartElement('a', 'lumOff', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '50000');
        writer.writeEndElement(); // end of lumoff
        writer.writeEndElement(); // end of cs:variation
    };
    // serialize chart Excel Data
    WordExport.prototype.serializeChartExcelData = function () {
        this.mArchiveExcel = new ZipArchive();
        this.mArchiveExcel.compressionLevel = 'Normal';
        var type = this.chart.chartType;
        var isScatterType = (type === 'Scatter_Markers' || type === 'Bubble');
        this.serializeWorkBook();
        this.serializeSharedString(isScatterType);
        this.serializeExcelContentTypes();
        this.serializeExcelData(isScatterType);
        this.serializeExcelStyles();
        this.serializeExcelRelation();
        this.serializeExcelGeneralRelations();
        this.chartStringCount = 0;
    };
    WordExport.prototype.serializeWorkBook = function () {
        var writer = new XmlWriter();
        var workbookPath = 'xl/workbook.xml';
        this.resetExcelRelationShipId();
        writer.writeStartElement(undefined, 'workbook', undefined);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', undefined, undefined, this.spreadSheetNamespace);
        writer.writeStartElement(undefined, 'sheets', undefined);
        writer.writeStartElement(undefined, 'sheet', undefined);
        writer.writeAttributeString(undefined, 'name', undefined, 'Sheet1');
        writer.writeAttributeString(undefined, 'sheetId', undefined, '1');
        writer.writeAttributeString('r', 'id', undefined, this.getNextExcelRelationShipID());
        writer.writeEndElement(); // end of sheet
        writer.writeEndElement(); // end of sheets
        writer.writeEndElement(); // end of workbook
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, workbookPath);
        this.mArchiveExcel.addItem(zipArchiveItem);
    };
    WordExport.prototype.serializeExcelStyles = function () {
        var writer = new XmlWriter();
        var stylePath = 'xl/styles.xml';
        writer.writeStartElement(undefined, 'styleSheet', undefined);
        writer.writeAttributeString('xmlns', 'mc', undefined, this.veNamespace);
        writer.writeAttributeString('mc', 'Ignorable', undefined, 'x14ac');
        writer.writeAttributeString('xmlns', 'x14ac', undefined, 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac');
        writer.writeAttributeString('xmlns', undefined, undefined, this.spreadSheetNamespace);
        writer.writeEndElement(); // end of styleSheet
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, stylePath);
        this.mArchiveExcel.addItem(zipArchiveItem);
    };
    WordExport.prototype.serializeExcelData = function (isScatterType) {
        // excel data
        var sheetPath = '';
        var writer = new XmlWriter();
        writer.writeStartElement(undefined, 'worksheet', undefined);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', 'x14', undefined, this.spreadSheet9);
        writer.writeAttributeString('xmlns', 'mc', undefined, this.veNamespace);
        writer.writeAttributeString('xmlns', undefined, undefined, this.spreadSheetNamespace);
        this.serializeExcelSheet(writer, isScatterType);
        writer.writeEndElement(); // end of worksheet
        sheetPath = 'xl/worksheets' + '/sheet1.xml';
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, sheetPath);
        this.mArchiveExcel.addItem(zipArchiveItem);
    };
    WordExport.prototype.serializeSharedString = function (isScatterType) {
        var chart = this.chart;
        var writer = new XmlWriter();
        var sharedStringPath = '';
        var chartSharedString = [];
        var type = this.chart.chartType;
        var seriesLength = chart.chartSeries.length;
        for (var column = 0; column < seriesLength; column++) {
            var series = chart.chartSeries[column];
            var seriesName = series.seriesName;
            var isString = seriesName.match(/[a-z]/i);
            if (isScatterType && column === 0) {
                chartSharedString.push('X-Values');
            }
            if (isString) {
                chartSharedString.push(series.seriesName);
                this.chartStringCount++;
            }
        }
        if (type === 'Bubble') {
            chartSharedString.push('Size');
        }
        for (var row = 0; row < chart.chartCategory.length; row++) {
            var category = chart.chartCategory[row];
            var format = chart.chartPrimaryCategoryAxis.numberFormat;
            var categoryName = category.categoryXName;
            var isString = categoryName.match(/[a-z]/i);
            if (isString || format === 'm/d/yyyy') {
                chartSharedString.push(category.categoryXName);
                this.chartStringCount++;
            }
        }
        var uniqueCount = this.chartStringCount + 1;
        writer.writeStartElement(undefined, 'sst', undefined);
        writer.writeAttributeString('xmlns', undefined, undefined, this.spreadSheetNamespace);
        writer.writeAttributeString(undefined, 'count', undefined, uniqueCount.toString());
        writer.writeAttributeString(undefined, 'uniqueCount', undefined, uniqueCount.toString());
        for (var i = 0; i <= chartSharedString.length; i++) {
            writer.writeStartElement(undefined, 'si', undefined);
            writer.writeStartElement(undefined, 't', undefined);
            if (i !== chartSharedString.length) {
                writer.writeString(chartSharedString[i]);
            }
            else if (!isScatterType) {
                writer.writeAttributeString('xml', 'space', this.xmlNamespace, 'preserve');
                writer.writeString(' ');
            }
            writer.writeEndElement(); // end of t
            writer.writeEndElement(); // end of si
        }
        writer.writeEndElement(); // end of sst
        sharedStringPath = 'xl/sharedStrings' + '.xml';
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, sharedStringPath);
        this.mArchiveExcel.addItem(zipArchiveItem);
    };
    // excel sheet data
    WordExport.prototype.serializeExcelSheet = function (writer, isScatterType) {
        var chart = this.chart;
        var type = 's';
        var isBubbleType = (chart.chartType === 'Bubble');
        var bubbleLength;
        var categoryLength = chart.chartCategory.length + 1;
        var format = chart.chartPrimaryCategoryAxis.numberFormat;
        var seriesLength = chart.chartSeries.length + 1;
        if (isBubbleType) {
            bubbleLength = seriesLength;
            seriesLength = seriesLength + 1;
        }
        var category = undefined;
        var series = undefined;
        var count = 0;
        writer.writeStartElement(undefined, 'sheetData', undefined);
        for (var row = 0; row < categoryLength; row++) {
            writer.writeStartElement(undefined, 'row', undefined);
            writer.writeAttributeString(undefined, 'r', undefined, (row + 1).toString());
            for (var column = 0; column < seriesLength; column++) {
                var alphaNumeric = String.fromCharCode('A'.charCodeAt(0) + column) + (row + 1).toString();
                writer.writeStartElement(undefined, 'c', undefined);
                writer.writeAttributeString(undefined, 'r', undefined, alphaNumeric);
                if (row !== 0 && column === 0) {
                    category = chart.chartCategory[row - 1];
                    var categoryName = category.categoryXName;
                    var isString = categoryName.match(/[a-z]/i);
                    if (isNullOrUndefined(isString) && format === 'm/d/yyyy') {
                        type = 's';
                    }
                    else if ((!isString && !isNullOrUndefined(isString)) || isScatterType) {
                        type = 'n';
                    }
                    else {
                        type = 's';
                    }
                }
                else if (row === 0 && column !== 0 && column !== (bubbleLength)) {
                    series = chart.chartSeries[column - 1];
                    var seriesName = series.seriesName;
                    var isString = seriesName.match(/[a-z]/i);
                    if (!isString) {
                        type = 'n';
                    }
                    else {
                        type = 's';
                    }
                }
                else if (row === 0 && isBubbleType && column === (bubbleLength)) {
                    type = 's';
                }
                else if (row === 0 && column === 0) {
                    type = 's';
                }
                else {
                    type = 'n';
                }
                writer.writeAttributeString(undefined, 't', undefined, type);
                writer.writeStartElement(undefined, 'v', undefined);
                if (row === 0 && column === 0 && !isScatterType) {
                    writer.writeString(this.chartStringCount.toString());
                }
                else if (type === 's') {
                    writer.writeString(count.toString());
                    count++;
                }
                else if (row !== 0 && type !== 's' && column === 0 && column !== (bubbleLength)) {
                    writer.writeString(category.categoryXName);
                }
                else if (column !== 0 && type !== 's' && row === 0 && column !== (bubbleLength)) {
                    writer.writeString(series.seriesName);
                }
                else if (column !== 0 && column !== (bubbleLength)) {
                    var data = category.chartData[column - 1];
                    var yValue = data.yValue;
                    writer.writeString(yValue.toString());
                }
                else if (isBubbleType && column === (bubbleLength)) {
                    var data = category.chartData[column - 2];
                    var size = data.size;
                    writer.writeString(size.toString());
                }
                writer.writeEndElement(); // end of v[value]
                writer.writeEndElement(); // end of c[column]
                type = '';
            }
            writer.writeEndElement(); // end of row
        }
        writer.writeEndElement(); // end of sheetData
    };
    // excel content types
    WordExport.prototype.serializeExcelContentTypes = function () {
        var writer = new XmlWriter();
        writer.writeStartElement(undefined, 'Types', 'http://schemas.openxmlformats.org/package/2006/content-types');
        this.serializeDefaultContentType(writer, 'xml', this.xmlContentType);
        this.serializeDefaultContentType(writer, 'rels', this.relationContentType);
        // tslint:disable-next-line:max-line-length
        this.serializeOverrideContentType(writer, 'xl/styles.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml');
        this.serializeOverrideContentType(writer, 'xl/workbook.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml');
        // tslint:disable-next-line:max-line-length
        // this.serializeOverrideContentType(writer, '/docProps/app.xml', 'application/vnd.openxmlformats-officedocument.extended-properties+xml');
        // this.serializeOverrideContentType(writer, '/docProps/core.xml', 'application/vnd.openxmlformats-package.core-properties+xml');
        // tslint:disable-next-line:max-line-length
        this.serializeOverrideContentType(writer, 'xl/sharedStrings.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml');
        this.serializeOverrideContentType(writer, 'xl/worksheets/sheet1.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml');
        writer.writeEndElement(); // end of types tag
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, this.contentTypesPath);
        this.mArchiveExcel.addItem(zipArchiveItem);
    };
    WordExport.prototype.serializeExcelRelation = function () {
        var writer = new XmlWriter();
        this.resetExcelRelationShipId();
        var worksheetType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet';
        var sharedStringType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings';
        writer.writeStartElement(undefined, 'Relationships', this.rpNamespace);
        this.serializeRelationShip(writer, this.getNextExcelRelationShipID(), worksheetType, 'worksheets/sheet1.xml');
        this.serializeRelationShip(writer, this.getNextExcelRelationShipID(), this.stylesRelType, 'styles.xml');
        this.serializeRelationShip(writer, this.getNextExcelRelationShipID(), sharedStringType, 'sharedStrings.xml');
        writer.writeEndElement(); // end of relationships
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, this.excelRelationPath);
        this.mArchiveExcel.addItem(zipArchiveItem);
    };
    WordExport.prototype.serializeExcelGeneralRelations = function () {
        var writer = new XmlWriter();
        this.resetExcelRelationShipId();
        writer.writeStartElement(undefined, 'Relationships', this.rpNamespace);
        this.serializeRelationShip(writer, this.getNextExcelRelationShipID(), this.documentRelType, 'xl/workbook.xml');
        writer.writeEndElement(); // end of relationships
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, this.generalRelationPath);
        this.mArchiveExcel.addItem(zipArchiveItem);
    };
    // get the next Excel relationship ID
    WordExport.prototype.getNextExcelRelationShipID = function () {
        return 'rId' + (++this.eRelationShipId);
    };
    // get the next Chart relationship ID
    WordExport.prototype.getNextChartRelationShipID = function () {
        return 'rId' + (++this.cRelationShipId);
    };
    //  chart data
    WordExport.prototype.serializeChartData = function (writer, chart) {
        writer.writeStartElement('c', 'date1904', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement();
        writer.writeStartElement('c', 'lang', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, 'en-US');
        writer.writeEndElement();
        writer.writeStartElement('c', 'roundedCorners', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement();
        writer.writeStartElement('mc', 'AlternateContent', this.veNamespace);
        writer.writeStartElement('mc', 'Choice', this.veNamespace);
        writer.writeAttributeString('xmlns', 'c14', undefined, this.c7Namespace);
        writer.writeAttributeString(undefined, 'Requires', undefined, 'c14');
        writer.writeStartElement('c14', 'style', undefined);
        writer.writeAttributeString(undefined, 'val', undefined, '102');
        writer.writeEndElement(); // c14 style end
        writer.writeEndElement(); // mc:choice ened
        writer.writeStartElement('mc', 'Fallback', this.veNamespace);
        writer.writeStartElement('c', 'style', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '2');
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement(); // end tag of mc alternate content
        writer.writeStartElement('c', 'chart', this.chartNamespace);
        if (!isNullOrUndefined(this.chart.chartTitle)) {
            writer.writeStartElement('c', 'title', this.chartNamespace);
            this.serializeTextProperties(writer, this.chart.chartTitleArea, this.chart.chartTitle);
            writer.writeEndElement(); // end tag of title
        }
        // serialize plot area
        this.serializeChartPlotArea(writer, chart);
        writer.writeEndElement(); // end tag of chart
        this.serializeShapeProperties(writer, 'D9D9D9', true);
        writer.writeStartElement('c', 'txPr', this.chartNamespace);
        writer.writeAttributeString('xmlns', 'c', undefined, this.chartNamespace);
        writer.writeStartElement('a', 'bodyPr', this.aNamespace);
        writer.writeAttributeString('xmlns', 'a', undefined, this.aNamespace);
        writer.writeEndElement(); // end tag of bodyPr
        writer.writeStartElement('a', 'lstStyle', this.aNamespace);
        writer.writeAttributeString('xmlns', 'a', undefined, this.aNamespace);
        writer.writeEndElement(); // end of a:lstStyle
        writer.writeStartElement('a', 'p', this.aNamespace);
        writer.writeAttributeString('xmlns', 'a', undefined, this.aNamespace);
        writer.writeStartElement('a', 'pPr', this.aNamespace);
        writer.writeStartElement('a', 'defRPr', this.aNamespace);
        writer.writeEndElement(); // end tag of defRPr
        writer.writeEndElement(); // end tag of pPr
        writer.writeStartElement('a', 'endParaRPr', this.aNamespace);
        writer.writeAttributeString(undefined, 'lang', undefined, 'en-US');
        writer.writeEndElement(); // end of a:endParaRPr
        writer.writeEndElement(); // end tag of p
        writer.writeEndElement(); // end tag of txPr
    };
    //  chart plot area
    // tslint:disable:max-func-body-length
    WordExport.prototype.serializeChartPlotArea = function (writer, chart) {
        writer.writeStartElement('c', 'autoTitleDeleted', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of autoTitleDeleted
        writer.writeStartElement('c', 'plotArea', this.chartNamespace);
        writer.writeStartElement('c', 'layout', this.chartNamespace);
        writer.writeEndElement();
        // chart Type
        var serializationChartType = this.chartType(chart);
        var isPieTypeSerialization = (serializationChartType === 'pieChart' || serializationChartType === 'doughnutChart');
        var isScatterType = (serializationChartType === 'scatterChart' || serializationChartType === 'bubbleChart');
        writer.writeStartElement('c', serializationChartType, this.chartNamespace);
        if (serializationChartType === 'barChart') {
            var barDiv = '';
            if (chart.chartType === 'Column_Clustered' || chart.chartType === 'Column_Stacked'
                || chart.chartType === 'Column_Stacked_100') {
                barDiv = 'col';
            }
            else {
                barDiv = 'bar';
            }
            writer.writeStartElement('c', 'barDir', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, barDiv);
            writer.writeEndElement(); // end of barDir
        }
        if (!isPieTypeSerialization && !isScatterType) {
            var grouping = this.chartGrouping(chart.chartType);
            writer.writeStartElement('c', 'grouping', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, grouping);
            writer.writeEndElement(); // end of grouping
        }
        if (serializationChartType === 'scatterChart') {
            writer.writeStartElement('c', 'scatterStyle', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'marker');
            writer.writeEndElement(); // end of scatterStyle
        }
        writer.writeStartElement('c', 'varyColors', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c:varyColors
        var valueSheet = '';
        for (var i = 0; i < chart.chartSeries.length; i++) {
            var series = chart.chartSeries[i];
            this.seriesCount = i;
            writer.writeStartElement('c', 'ser', this.chartNamespace);
            writer.writeStartElement('c', 'idx', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, i.toString());
            writer.writeEndElement(); // end of c:idx
            writer.writeStartElement('c', 'order', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, i.toString());
            writer.writeEndElement(); // end of c:order
            writer.writeStartElement('c', 'tx', this.chartNamespace);
            writer.writeStartElement('c', 'strRef', this.chartNamespace);
            writer.writeStartElement('c', 'f', this.chartNamespace);
            var alphaNumeric = String.fromCharCode('B'.charCodeAt(0) + i);
            valueSheet = 'Sheet1!$' + alphaNumeric;
            writer.writeString(valueSheet + '$1');
            valueSheet = valueSheet + '$2:$' + alphaNumeric + '$';
            writer.writeEndElement(); // end of c:f
            writer.writeStartElement('c', 'strCache', this.chartNamespace);
            writer.writeStartElement('c', 'ptCount', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '1');
            writer.writeEndElement(); // end of ptCount
            writer.writeStartElement('c', 'pt', this.chartNamespace);
            writer.writeAttributeString(undefined, 'idx', undefined, '0');
            writer.writeStartElement('c', 'v', this.chartNamespace);
            writer.writeString(series.seriesName);
            writer.writeEndElement(); // end of c:v
            writer.writeEndElement(); // end of pt
            writer.writeEndElement(); // end of strCache
            writer.writeEndElement(); // end of strRef
            writer.writeEndElement(); // end of tx
            if (chart.chartType === 'Pie' || chart.chartType === 'Doughnut') {
                this.parseChartDataPoint(writer, series);
                writer.writeStartElement('c', 'explosion', this.chartNamespace);
                writer.writeAttributeString(undefined, 'val', undefined, '0');
                writer.writeEndElement(); // end of explosion
            }
            else if (!isScatterType) {
                this.parseChartSeriesColor(writer, series.dataPoints, serializationChartType);
            }
            if (serializationChartType === 'scatterChart') {
                var fillColor = series.dataPoints[0].fill.foreColor;
                writer.writeStartElement('c', 'marker', this.chartNamespace);
                writer.writeStartElement('c', 'symbol', this.chartNamespace);
                writer.writeAttributeString(undefined, 'val', undefined, 'circle');
                writer.writeEndElement(); // end of a: symbol
                writer.writeStartElement('c', 'size', this.chartNamespace);
                writer.writeAttributeString(undefined, 'val', undefined, '5');
                writer.writeEndElement(); // end of a: size
                this.serializeShapeProperties(writer, fillColor, false);
                writer.writeEndElement(); // end of a: marker
            }
            if (series.dataLabel) {
                this.parseChartDataLabels(writer, series.dataLabel);
            }
            if (series.trendLines) {
                this.parseChartTrendLines(writer, series);
            }
            if (series.errorBar) {
                this.serializeChartErrorBar(writer, series);
            }
            if (serializationChartType === 'scatterChart') {
                this.serializeDefaultShapeProperties(writer);
            }
            else if (serializationChartType === 'bubbleChart') {
                this.serializeShapeProperties(writer, series.dataPoints[i].fill.foreColor, false);
            }
            var categoryType = 'cat';
            var categoryRef = 'strRef';
            var cacheType = 'strCache';
            if (isScatterType) {
                categoryType = 'xVal';
                categoryRef = 'numRef';
                cacheType = 'numCache';
            }
            writer.writeStartElement('c', categoryType, this.chartNamespace);
            writer.writeStartElement('c', categoryRef, this.chartNamespace);
            this.serializeChartCategory(writer, chart, cacheType); // serialize chart yvalue
            writer.writeEndElement(); // end of categoryRef
            writer.writeEndElement(); // end of cat
            this.serializeChartValue(writer, valueSheet, serializationChartType);
            writer.writeEndElement(); // end of c:ser
        }
        writer.writeStartElement('c', 'dLbls', this.chartNamespace);
        if (isPieTypeSerialization) {
            writer.writeStartElement('c', 'dLblPos', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'bestFit');
            writer.writeEndElement(); // end of dLblPos
        }
        writer.writeStartElement('c', 'showLegendKey', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: showLegendKey
        writer.writeStartElement('c', 'showVal', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: showVal
        writer.writeStartElement('c', 'showCatName', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: showCatName
        writer.writeStartElement('c', 'showSerName', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: showSerName
        writer.writeStartElement('c', 'showPercent', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: showPercent
        writer.writeStartElement('c', 'showBubbleSize', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: showBubbleSize
        writer.writeStartElement('c', 'showLeaderLines', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '1');
        writer.writeEndElement(); // end of c: showLeaderLines
        writer.writeEndElement(); // end of c: dLbls
        if (isPieTypeSerialization) {
            var series = this.chart.chartSeries[0];
            var sliceAngle = 0;
            var holeSize = 0;
            if (series.hasOwnProperty('firstSliceAngle')) {
                sliceAngle = series.firstSliceAngle;
            }
            writer.writeStartElement('c', 'firstSliceAng', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, sliceAngle.toString());
            writer.writeEndElement(); // end of c: firstSliceAng
            if (chart.chartType === 'Doughnut') {
                holeSize = series.holeSize;
                writer.writeStartElement('c', 'holeSize', this.chartNamespace);
                writer.writeAttributeString(undefined, 'val', undefined, holeSize.toString());
                writer.writeEndElement(); // end of c: holeSize
            }
        }
        if (serializationChartType !== 'lineChart' && !isScatterType) {
            writer.writeStartElement('c', 'gapWidth', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, this.chart.gapWidth.toString());
            writer.writeEndElement(); // end of gapWidth
            writer.writeStartElement('c', 'overlap', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, this.chart.overlap.toString());
            writer.writeEndElement(); // end of overlap
        }
        else if (serializationChartType !== 'bubbleChart') {
            writer.writeStartElement('c', 'smooth', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '0');
            writer.writeEndElement(); // end of smooth
        }
        if (serializationChartType === 'bubbleChart') {
            writer.writeStartElement('c', 'sizeRepresents', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'area');
            writer.writeEndElement(); // end of smooth
        }
        var type = this.chart.chartType;
        if (!isPieTypeSerialization) {
            writer.writeStartElement('c', 'axId', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '335265000');
            writer.writeEndElement(); // end of axId
            writer.writeStartElement('c', 'axId', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '335263360');
            writer.writeEndElement(); // end of axId
        }
        writer.writeEndElement(); // end of chart type
        var isStackedPercentage = (type === 'Column_Stacked_100' || type === 'Area_Stacked_100' ||
            type === 'Bar_Stacked_100' || type === 'Line_Stacked_100' || type === 'Line_Markers_Stacked_100');
        var format = this.chart.chartPrimaryCategoryAxis.categoryType;
        if (!isPieTypeSerialization) {
            this.serializeCategoryAxis(writer, format, isStackedPercentage);
            this.serializeValueAxis(writer, format, isStackedPercentage);
        }
        if (this.chart.hasOwnProperty('chartDataTable')) {
            var dataTable = this.chart.chartDataTable;
            var showHorzBorder = 0;
            var showVertBorder = 0;
            var showOutline = 0;
            var showKeys = 0;
            if (dataTable.showSeriesKeys) {
                showKeys = 1;
            }
            if (dataTable.hasHorzBorder) {
                showHorzBorder = 1;
            }
            if (dataTable.hasVertBorder) {
                showVertBorder = 1;
            }
            if (dataTable.hasBorders) {
                showOutline = 1;
            }
            writer.writeStartElement('c', 'dTable', this.chartNamespace);
            writer.writeStartElement('c', 'showHorzBorder', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, showHorzBorder.toString());
            writer.writeEndElement(); // end of showHorzBorder
            writer.writeStartElement('c', 'showVertBorder', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, showVertBorder.toString());
            writer.writeEndElement(); // end of showVertBorder
            writer.writeStartElement('c', 'showOutline', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, showOutline.toString());
            writer.writeEndElement(); // end of showOutline
            writer.writeStartElement('c', 'showKeys', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, showKeys.toString());
            writer.writeEndElement(); // end of showKeys
            writer.writeEndElement(); // end of dTable
        }
        this.serializeDefaultShapeProperties(writer);
        writer.writeEndElement(); // end of plot area
        // legend
        if (!isNullOrUndefined(this.chart.chartLegend.position)) {
            this.serializeChartLegend(writer);
        }
        writer.writeStartElement('c', 'plotVisOnly', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '1');
        writer.writeEndElement(); // end of c: plotVisOnly
        writer.writeStartElement('c', 'dispBlanksAs', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, 'gap');
        writer.writeEndElement(); // end of c: dispBlanksAs
    };
    WordExport.prototype.serializeChartLegend = function (writer) {
        var legendPosition = this.chartLegendPosition(this.chart.chartLegend);
        var title = this.chart.chartLegend.chartTitleArea;
        var fill = title.dataFormat.fill.foreColor;
        writer.writeStartElement('c', 'legend', this.chartNamespace);
        writer.writeStartElement('c', 'legendPos', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, legendPosition);
        writer.writeEndElement();
        writer.writeStartElement('c', 'overlay', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement();
        this.serializeDefaultShapeProperties(writer);
        writer.writeStartElement('c', 'txPr', this.chartNamespace);
        writer.writeStartElement('a', 'bodyPr', this.aNamespace);
        writer.writeEndElement();
        writer.writeStartElement('a', 'lstStyle', this.aNamespace);
        writer.writeEndElement();
        writer.writeStartElement('a', 'p', this.aNamespace);
        this.serializeChartTitleFont(writer, title.fontSize, fill, title.fontName);
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
    };
    WordExport.prototype.serializeChartErrorBar = function (writer, series) {
        var errorBar = series.errorBar;
        var errorBarValueType = this.errorBarValueType(errorBar.type);
        var endStyle = 0;
        if (errorBar.endStyle !== 'Cap') {
            endStyle = 1;
        }
        writer.writeStartElement('c', 'errBars', this.chartNamespace);
        writer.writeStartElement('c', 'errBarType', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, errorBar.direction.toLowerCase());
        writer.writeEndElement(); // end of c: errBarType
        writer.writeStartElement('c', 'errValType', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, errorBarValueType);
        writer.writeEndElement(); // end of c: errValType
        writer.writeStartElement('c', 'noEndCap', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, endStyle.toString());
        writer.writeEndElement(); // end of c: noEndCap
        writer.writeStartElement('c', 'val', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, errorBar.numberValue.toString());
        writer.writeEndElement(); // end of c: val
        this.serializeShapeProperties(writer, '595959', true);
        writer.writeEndElement(); // end of c: errBars
    };
    WordExport.prototype.errorBarValueType = function (type) {
        var valueType = '';
        switch (type) {
            case 'StandardError':
                valueType = 'stdErr';
                break;
            case 'StandardDeviation':
                valueType = 'stdDev';
                break;
            case 'Percentage':
                valueType = 'percentage';
                break;
            case 'Fixed':
                valueType = 'fixedVal';
                break;
            default:
                valueType = 'stdErr';
                break;
        }
        return valueType;
    };
    WordExport.prototype.serializeCategoryAxis = function (writer, format, isStackedPercentage) {
        // serialize category axis
        var axisType = 'catAx';
        var formatCode = this.chart.chartPrimaryCategoryAxis.numberFormat;
        var type = this.chart.chartType;
        var isScatterType = (type === 'Scatter_Markers' || type === 'Bubble');
        if (format === 'Time') {
            axisType = 'dateAx';
        }
        if (isScatterType) {
            axisType = 'valAx';
        }
        writer.writeStartElement('c', axisType, this.chartNamespace);
        writer.writeStartElement('c', 'axId', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '335265000');
        writer.writeEndElement(); // end of axId
        this.serializeAxis(writer, '335263360', this.chart.chartPrimaryCategoryAxis, formatCode, isStackedPercentage);
        if (!isScatterType) {
            writer.writeStartElement('c', 'auto', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '1');
            writer.writeEndElement(); // end of auto
            writer.writeStartElement('c', 'lblAlgn', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'ctr');
            writer.writeEndElement(); // end of lblAlgn
            writer.writeStartElement('c', 'lblOffset', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '100');
            writer.writeEndElement(); // end of lblOffset
        }
        if (format === 'Time') {
            writer.writeStartElement('c', 'baseTimeUnit', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'days');
            writer.writeEndElement(); // end of baseTimeUnit
        }
        else if (this.chart.chartType !== 'Bubble') {
            writer.writeStartElement('c', 'noMultiLvlLbl', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '0');
            writer.writeEndElement(); // end of noMultiLvlLbl
        }
        writer.writeEndElement(); // end of catAx
    };
    WordExport.prototype.serializeValueAxis = function (writer, format, isStackedPercentage) {
        // serialize category axis
        var valueAxis = this.chart.chartPrimaryValueAxis;
        var crossBetween = 'between';
        if (format === 'Time') {
            crossBetween = 'midCat';
        }
        writer.writeStartElement('c', 'valAx', this.chartNamespace);
        writer.writeStartElement('c', 'axId', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '335263360');
        writer.writeEndElement(); // end of axId
        this.serializeAxis(writer, '335265000', valueAxis, 'General', isStackedPercentage);
        writer.writeStartElement('c', 'crossBetween', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, crossBetween);
        writer.writeEndElement(); // end of crossBetween
        if (valueAxis.majorUnit !== 0 && !isStackedPercentage) {
            writer.writeStartElement('c', 'majorUnit', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, valueAxis.majorUnit.toString());
            writer.writeEndElement(); // end of majorUnit
        }
        writer.writeEndElement(); // end of valAx
    };
    WordExport.prototype.serializeAxis = function (writer, axisID, axis, formatCode, isStackedPercentage) {
        var majorTickMark = 'none';
        var minorTickMark = 'none';
        var tickLabelPosition = 'nextTo';
        writer.writeStartElement('c', 'scaling', this.chartNamespace);
        writer.writeStartElement('c', 'orientation', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, 'minMax');
        writer.writeEndElement(); // end of orientation
        if (axis.maximumValue !== 0 && !isStackedPercentage) {
            writer.writeStartElement('c', 'max', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, axis.maximumValue.toString());
            writer.writeEndElement(); // end of max
            writer.writeStartElement('c', 'min', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, axis.minimumValue.toString());
            writer.writeEndElement(); // end of min
        }
        writer.writeEndElement(); // end of scaling
        writer.writeStartElement('c', 'delete', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of delete
        writer.writeStartElement('c', 'axPos', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, 'l');
        writer.writeEndElement(); // end of axPos
        if (axis.hasMajorGridLines) {
            writer.writeStartElement('c', 'majorGridlines', this.chartNamespace);
            this.serializeShapeProperties(writer, 'D9D9D9', true);
            writer.writeEndElement(); // end of majorGridlines
        }
        if (axis.hasMinorGridLines) {
            writer.writeStartElement('c', 'minorGridlines', this.chartNamespace);
            this.serializeShapeProperties(writer, 'F2F2F2', true);
            writer.writeEndElement(); // end of minorGridlines
        }
        if (axis.chartTitle) {
            writer.writeStartElement('c', 'title', this.chartNamespace);
            this.serializeTextProperties(writer, axis.chartTitleArea, axis.chartTitle);
            writer.writeEndElement(); // end tag of title
        }
        writer.writeStartElement('c', 'numFmt', this.chartNamespace);
        writer.writeAttributeString(undefined, 'formatCode', undefined, formatCode);
        writer.writeAttributeString(undefined, 'sourceLinked', undefined, '1');
        writer.writeEndElement(); // end of numFmt
        writer.writeStartElement('c', 'majorTickMark', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, majorTickMark);
        writer.writeEndElement(); // end of majorTickMark
        writer.writeStartElement('c', 'minorTickMark', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, minorTickMark);
        writer.writeEndElement(); // end of minorTickMark
        writer.writeStartElement('c', 'tickLblPos', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, tickLabelPosition);
        writer.writeEndElement(); // end of tickLblPos
        if (this.chart.chartType === 'Bubble') {
            this.serializeShapeProperties(writer, 'BFBFBF', true);
        }
        else {
            this.serializeDefaultShapeProperties(writer);
        }
        writer.writeStartElement('c', 'txPr', this.chartNamespace);
        writer.writeStartElement('a', 'bodyPr', this.aNamespace);
        writer.writeEndElement(); // end of bodyPr
        writer.writeStartElement('a', 'p', this.aNamespace);
        this.serializeChartTitleFont(writer, axis.fontSize, '595959', axis.fontName);
        writer.writeEndElement(); // end of a: p
        writer.writeEndElement(); // end of c: txPr
        writer.writeStartElement('c', 'crossAx', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, axisID);
        writer.writeEndElement(); // end of crossAx
        writer.writeStartElement('c', 'crosses', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, 'autoZero');
        writer.writeEndElement(); // end of crosses
    };
    WordExport.prototype.parseChartTrendLines = function (writer, series) {
        for (var i = 0; i < series.trendLines.length; i++) {
            var data = series.trendLines[i];
            var type = this.chartTrendLineType(data.type);
            var dispRSqr = 0;
            var dispEq = 0;
            if (data.isDisplayEquation) {
                dispEq = 1;
            }
            else if (data.isDisplayRSquared) {
                dispRSqr = 1;
            }
            var solidFill = series.dataPoints[i];
            writer.writeStartElement('c', 'trendline', this.chartNamespace);
            writer.writeStartElement('c', 'spPr', this.chartNamespace);
            writer.writeStartElement('a', 'ln', this.aNamespace);
            writer.writeAttributeString(undefined, 'w', undefined, '19050');
            this.serializeChartSolidFill(writer, solidFill.fill.foreColor, false);
            writer.writeStartElement('a', 'prstDash', this.aNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'sysDot');
            writer.writeEndElement(); // end of a: prstDash
            writer.writeStartElement('a', 'round', this.aNamespace);
            writer.writeEndElement(); // end of a: round
            writer.writeEndElement(); // end of a: ln
            writer.writeEndElement(); // end of c: spPr
            writer.writeStartElement('c', 'trendlineType', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, type);
            writer.writeEndElement(); // end of c: trendlineType
            writer.writeStartElement('c', 'forward', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, data.forward.toString());
            writer.writeEndElement(); // end of c: forward
            writer.writeStartElement('c', 'backward', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, data.backward.toString());
            writer.writeEndElement(); // end of c: backward
            if (data.intercept !== 'NaN') {
                writer.writeStartElement('c', 'intercept', this.chartNamespace);
                writer.writeAttributeString(undefined, 'val', undefined, data.intercept.toString());
                writer.writeEndElement(); // end of c: intercept
            }
            writer.writeStartElement('c', 'dispRSqr', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, dispRSqr.toString());
            writer.writeEndElement(); // end of c: dispRSqr
            writer.writeStartElement('c', 'dispEq', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, dispEq.toString());
            writer.writeEndElement(); // end of c: dispEq
            writer.writeEndElement(); // end of c: trendline
        }
    };
    WordExport.prototype.chartTrendLineType = function (type) {
        var trendlineType = '';
        switch (type) {
            case 'Linear':
                trendlineType = 'linear';
                break;
            case 'Exponential':
                trendlineType = 'exp';
                break;
        }
        return trendlineType;
    };
    WordExport.prototype.parseChartDataLabels = function (writer, dataLabels) {
        var position = '';
        var dataLabelPosition = dataLabels.position;
        var isLegendKey = 0;
        var isBubbleSize = 0;
        var isCategoryName = 0;
        var isSeriesName = 0;
        var isValue = 0;
        var isPercentage = 0;
        var isLeaderLines = 0;
        switch (dataLabelPosition) {
            case 'Center':
                position = 'ctr';
                break;
            case 'Left':
                position = 'l';
                break;
            case 'Right':
                position = 'r';
                break;
            case 'Outside':
                position = 'outEnd';
                break;
            case 'BestFit':
                position = 'bestFit';
                break;
            case 'Bottom':
            case 'OutsideBase':
                position = 'inBase';
                break;
            case 'Inside':
                position = 'inEnd';
                break;
            case 'Above':
                position = 't';
                break;
            case 'Below':
                position = 'b';
                break;
            default:
                position = 'Automatic';
                break;
        }
        writer.writeStartElement('c', 'dLbls', this.chartNamespace);
        this.serializeDefaultShapeProperties(writer);
        writer.writeStartElement('c', 'txPr', this.chartNamespace);
        writer.writeStartElement('a', 'bodyPr', this.aNamespace);
        writer.writeEndElement(); //end of a:bodyPr.
        writer.writeStartElement('a', 'lstStyle', this.aNamespace);
        writer.writeEndElement(); //end of a:lstStyle.
        writer.writeStartElement('a', 'p', this.aNamespace);
        this.serializeChartTitleFont(writer, dataLabels.fontSize, dataLabels.fontColor, dataLabels.fontName);
        writer.writeEndElement(); //end of a:p.
        writer.writeEndElement(); //end of c:txPr.
        if (dataLabels.isLegendKey) {
            isLegendKey = 1;
        }
        else if (dataLabels.isBubbleSize) {
            isBubbleSize = 1;
        }
        else if (dataLabels.isCategoryName) {
            isCategoryName = 1;
        }
        else if (dataLabels.isSeriesName) {
            isSeriesName = 1;
        }
        else if (dataLabels.isValue) {
            isValue = 1;
        }
        else if (dataLabels.isPercentage) {
            isPercentage = 1;
        }
        else if (dataLabels.isLeaderLines) {
            isLeaderLines = 1;
        }
        if (position !== 'Automatic') {
            writer.writeStartElement('c', 'dLblPos', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, position);
            writer.writeEndElement(); // end of dLblPos
        }
        writer.writeStartElement('c', 'showLegendKey', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, isLegendKey.toString());
        writer.writeEndElement(); // end of showLegendKey
        writer.writeStartElement('c', 'showVal', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, isValue.toString());
        writer.writeEndElement(); // end of showVal
        writer.writeStartElement('c', 'showCatName', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, isCategoryName.toString());
        writer.writeEndElement(); // end of showCatName
        writer.writeStartElement('c', 'showSerName', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, isSeriesName.toString());
        writer.writeEndElement(); // end of showSerName
        writer.writeStartElement('c', 'showPercent', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, isPercentage.toString());
        writer.writeEndElement(); // end of showPercent
        writer.writeStartElement('c', 'showBubbleSize', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, isBubbleSize.toString());
        writer.writeEndElement(); // end of showBubbleSize
        writer.writeStartElement('c', 'showLeaderLines', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, isLeaderLines.toString());
        writer.writeEndElement(); // end of showBubbleSize
        writer.writeEndElement(); // end of dLbls
    };
    WordExport.prototype.serializeShapeProperties = function (writer, color, isLine) {
        var chartType = this.chart.chartType;
        var isScatterType = (chartType === 'Scatter_Markers' || chartType === 'Bubble');
        // serialize shape
        writer.writeStartElement('c', 'spPr', this.chartNamespace);
        if (!isScatterType || isLine) {
            writer.writeStartElement('a', 'ln', this.aNamespace);
            writer.writeAttributeString(undefined, 'w', undefined, '9525');
            this.serializeChartSolidFill(writer, color, false);
            writer.writeStartElement('a', 'prstDash', this.aNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'solid');
            writer.writeEndElement(); // end of prstDash
            writer.writeStartElement('a', 'round', this.aNamespace);
            writer.writeEndElement(); // end tag of round
            writer.writeEndElement(); // end tag of ln
        }
        else if (chartType === 'Scatter_Markers') {
            this.serializeChartSolidFill(writer, color, false);
            this.serializeDefaultLineProperties(writer);
        }
        else if (chartType === 'Bubble') {
            this.serializeChartSolidFill(writer, color, true);
            this.serializeDefaultLineProperties(writer);
        }
        writer.writeStartElement('a', 'effectLst', this.aNamespace);
        writer.writeEndElement(); // end of a: effectLst
        writer.writeEndElement(); // end tag of spPr
    };
    WordExport.prototype.serializeDefaultShapeProperties = function (writer) {
        writer.writeStartElement('c', 'spPr', this.chartNamespace);
        writer.writeStartElement('a', 'noFill', this.aNamespace);
        writer.writeEndElement(); // end of a: noFill
        this.serializeDefaultLineProperties(writer);
        writer.writeStartElement('a', 'effectLst', this.aNamespace);
        writer.writeEndElement(); // end of a: effectLst
        writer.writeEndElement(); // end of c: spPr
    };
    WordExport.prototype.serializeDefaultLineProperties = function (writer) {
        writer.writeStartElement('a', 'ln', this.aNamespace);
        writer.writeStartElement('a', 'noFill', this.aNamespace);
        writer.writeEndElement(); // end of a: noFill
        writer.writeStartElement('a', 'round', this.aNamespace);
        writer.writeEndElement(); // end of a: round
        writer.writeEndElement(); // end of a: ln
    };
    WordExport.prototype.serializeTextProperties = function (writer, title, chartTitleName) {
        var fill = title.dataFormat.fill.foreColor;
        var fontSize = title.fontSize * 100;
        writer.writeStartElement('c', 'tx', this.chartNamespace);
        writer.writeStartElement('c', 'rich', this.chartNamespace);
        writer.writeStartElement('a', 'bodyPr', this.aNamespace);
        writer.writeAttributeString(undefined, 'rot', undefined, '0');
        writer.writeAttributeString(undefined, 'vert', undefined, 'horz');
        writer.writeEndElement(); // end of a: bodyPr
        writer.writeStartElement('a', 'lstStyle', this.aNamespace);
        writer.writeEndElement(); // end of a:lstStyle
        writer.writeStartElement('a', 'p', this.aNamespace);
        this.serializeChartTitleFont(writer, title.fontSize, fill, title.fontName);
        writer.writeStartElement('a', 'r', this.aNamespace);
        writer.writeStartElement('a', 'rPr', this.aNamespace);
        writer.writeAttributeString(undefined, 'lang', undefined, 'en-US');
        writer.writeAttributeString(undefined, 'b', undefined, '0');
        writer.writeAttributeString(undefined, 'sz', undefined, fontSize.toString());
        writer.writeAttributeString(undefined, 'baseline', undefined, '0');
        this.serializeChartSolidFill(writer, fill, false);
        this.serializeFont(writer, title.fontName);
        writer.writeEndElement(); // end of a: rPr
        writer.writeStartElement('a', 't', this.aNamespace);
        writer.writeString(chartTitleName);
        writer.writeEndElement(); // end of a:t
        writer.writeEndElement(); // end of a: r
        writer.writeEndElement(); // end of a: p
        writer.writeEndElement(); // end of c: rich
        writer.writeEndElement(); // end of c: tx
        writer.writeStartElement('c', 'layout', this.chartNamespace);
        // writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: layout
        writer.writeStartElement('c', 'overlay', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: overlay
        this.serializeDefaultShapeProperties(writer);
        writer.writeStartElement('c', 'txPr', this.chartNamespace);
        writer.writeStartElement('a', 'bodyPr', this.aNamespace);
        writer.writeEndElement(); // end of a: bodyPr
        writer.writeStartElement('a', 'lstStyle', this.aNamespace);
        writer.writeEndElement(); // end of a: lstStyle
        writer.writeStartElement('a', 'p', this.aNamespace);
        writer.writeEndElement(); // end of a: p
        this.serializeChartTitleFont(writer, title.fontSize, fill, title.fontName);
        writer.writeEndElement(); // end of c: txPr
    };
    WordExport.prototype.serializeChartTitleFont = function (writer, fontSize, fill, fontName) {
        var fontSizeCalc = fontSize * 100;
        writer.writeStartElement('a', 'pPr', this.aNamespace);
        writer.writeStartElement('a', 'defRPr', this.aNamespace);
        writer.writeAttributeString(undefined, 'lang', undefined, 'en-US');
        writer.writeAttributeString(undefined, 'b', undefined, '0');
        writer.writeAttributeString(undefined, 'sz', undefined, fontSizeCalc.toString());
        writer.writeAttributeString(undefined, 'baseline', undefined, '0');
        this.serializeChartSolidFill(writer, fill, false);
        this.serializeFont(writer, fontName);
        writer.writeEndElement(); // end of defRPr
        writer.writeEndElement(); // end of a: pPr
    };
    WordExport.prototype.serializeChartSolidFill = function (writer, fill, isSeriesFill) {
        writer.writeStartElement('a', 'solidFill', this.aNamespace);
        writer.writeStartElement('a', 'srgbClr', this.aNamespace);
        if (fill !== '000000') {
            writer.writeAttributeString(undefined, 'val', undefined, fill);
        }
        else {
            writer.writeAttributeString(undefined, 'val', undefined, '595959');
        }
        if (this.chart.chartType === 'Bubble' && isSeriesFill) {
            writer.writeStartElement('a', 'alpha', this.aNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '75000');
            writer.writeEndElement(); // end of alpha
        }
        writer.writeEndElement(); // end of srgbClr
        writer.writeEndElement(); // end of solidFill
    };
    WordExport.prototype.serializeFont = function (writer, fontName) {
        writer.writeStartElement('a', 'latin', this.aNamespace);
        writer.writeAttributeString(undefined, 'typeface', undefined, fontName);
        writer.writeEndElement(); // end of a:latin
        writer.writeStartElement('a', 'ea', this.aNamespace);
        writer.writeAttributeString(undefined, 'typeface', undefined, fontName);
        writer.writeEndElement(); // end of a:ea
        writer.writeStartElement('a', 'cs', this.aNamespace);
        writer.writeAttributeString(undefined, 'typeface', undefined, fontName);
        writer.writeEndElement(); // end of a:cs
    };
    WordExport.prototype.parseChartSeriesColor = function (writer, dataPoints, chartType) {
        for (var i = 0; i < dataPoints.length; i++) {
            var data = dataPoints[i];
            writer.writeStartElement('c', 'spPr', this.chartNamespace);
            if (chartType === 'lineChart') {
                writer.writeStartElement('a', 'ln', this.aNamespace);
                writer.writeAttributeString(undefined, 'w', undefined, '28575');
                writer.writeAttributeString(undefined, 'cap', undefined, 'rnd');
            }
            if (chartType !== 'lineChart') {
                this.serializeChartSolidFill(writer, data.fill.foreColor, true);
            }
            else {
                this.serializeChartSolidFill(writer, data.line.color, true);
            }
            if (chartType !== 'lineChart') {
                writer.writeStartElement('a', 'ln', this.aNamespace);
                writer.writeStartElement('a', 'noFill', this.aNamespace);
                writer.writeEndElement(); // end of a: noFill
            }
            writer.writeStartElement('a', 'round', this.aNamespace);
            writer.writeEndElement(); // end of a: round
            writer.writeEndElement(); // end of a: ln
            writer.writeStartElement('a', 'effectLst', this.aNamespace);
            writer.writeEndElement(); // end of a: effectLst
            writer.writeEndElement(); // end of c: spPr
            if (chartType === 'lineChart') {
                var symbolType = 'none';
                var size = 0;
                if (this.chart.chartSeries[i].hasOwnProperty('seriesFormat')) {
                    symbolType = this.chart.chartSeries[i].seriesFormat.markerStyle;
                    size = this.chart.chartSeries[i].seriesFormat.markerSize;
                }
                writer.writeStartElement('c', 'marker', this.chartNamespace);
                writer.writeStartElement('c', 'symbol', this.chartNamespace);
                writer.writeAttributeString(undefined, 'val', undefined, symbolType.toLowerCase());
                writer.writeEndElement(); // end of a: symbol
                if (this.chart.chartSeries[i].hasOwnProperty('seriesFormat')) {
                    writer.writeStartElement('c', 'size', this.chartNamespace);
                    writer.writeAttributeString(undefined, 'val', undefined, size.toString());
                    writer.writeEndElement(); // end of a: size
                }
                writer.writeEndElement(); // end of a: marker
            }
        }
    };
    WordExport.prototype.parseChartDataPoint = function (writer, series) {
        // data point
        var dataPoints = series.dataPoints;
        var points = [];
        for (var j = 0; j < dataPoints.length; j++) {
            points.push(dataPoints[j]);
            writer.writeStartElement('c', 'dPt', this.chartNamespace);
            writer.writeStartElement('c', 'idx', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, j.toString());
            writer.writeEndElement(); // end of c:idx
            writer.writeStartElement('c', 'bubble3D', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '0');
            writer.writeEndElement(); // end of c:bubble3D
            this.parseChartSeriesColor(writer, points, this.chart.chartType);
            writer.writeEndElement(); // end of c:dPt
            points = [];
        }
    };
    // chart data value
    WordExport.prototype.serializeChartCategory = function (writer, chart, cacheType) {
        var chartCategory = chart.chartCategory;
        var chartCategoryCount = chartCategory.length;
        writer.writeStartElement('c', 'f', this.chartNamespace);
        writer.writeString('Sheet1!$A$2:$A$' + (chartCategoryCount + 1).toString());
        writer.writeEndElement(); // end of f
        writer.writeStartElement('c', cacheType, this.chartNamespace);
        if (cacheType === 'numCache') {
            writer.writeStartElement('c', 'formatCode', this.chartNamespace);
            writer.writeString('General');
            writer.writeEndElement(); // end of formatCode
        }
        writer.writeStartElement('c', 'ptCount', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, chartCategoryCount.toString());
        writer.writeEndElement(); // end of ptCount
        for (var i = 0; i < chartCategory.length; i++) {
            var category = chartCategory[i];
            writer.writeStartElement('c', 'pt', this.chartNamespace);
            writer.writeAttributeString(undefined, 'idx', undefined, i.toString());
            writer.writeStartElement('c', 'v', this.chartNamespace);
            if (category.categoryXName !== '') {
                writer.writeString(category.categoryXName);
            }
            writer.writeEndElement(); // end of v
            writer.writeEndElement(); // end of pt
        }
        writer.writeEndElement(); // end of cacheType
    };
    // chart value
    WordExport.prototype.serializeChartValue = function (writer, valueSheet, chartType) {
        var isScatterType = (chartType === 'scatterChart' || chartType === 'bubbleChart');
        var valueType = 'val';
        if (isScatterType) {
            valueType = 'yVal';
        }
        this.serializeChartYValue(writer, valueType, valueSheet);
        if (chartType === 'bubbleChart') {
            valueType = 'bubbleSize';
            valueSheet = 'Sheet1!$C$2:$C$';
            this.serializeChartYValue(writer, valueType, valueSheet);
        }
        if (chartType === 'lineChart' || chartType === 'scatterChart') {
            writer.writeStartElement('c', 'smooth', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '0');
            writer.writeEndElement(); // end of smooth
        }
    };
    WordExport.prototype.serializeChartYValue = function (writer, valueType, valueSheet) {
        var chart = this.chart;
        var chartCategory = chart.chartCategory;
        var chartCategoryCount = chartCategory.length;
        writer.writeStartElement('c', valueType, this.chartNamespace);
        writer.writeStartElement('c', 'numRef', this.chartNamespace);
        writer.writeStartElement('c', 'f', this.chartNamespace);
        writer.writeString(valueSheet + (chartCategoryCount + 1).toString());
        writer.writeEndElement(); // end of f
        writer.writeStartElement('c', 'numCache', this.chartNamespace);
        writer.writeStartElement('c', 'formatCode', this.chartNamespace);
        writer.writeString('General');
        writer.writeEndElement(); // end of formatCode
        writer.writeStartElement('c', 'ptCount', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, chartCategoryCount.toString());
        writer.writeEndElement(); // end of ptCount
        for (var j = 0; j < chartCategoryCount; j++) {
            var category = chartCategory[j];
            for (var k = 0; k < category.chartData.length; k++) {
                if (k === this.seriesCount) {
                    var chartData = category.chartData[this.seriesCount];
                    writer.writeStartElement('c', 'pt', this.chartNamespace);
                    writer.writeAttributeString(undefined, 'idx', undefined, j.toString());
                    writer.writeStartElement('c', 'v', this.chartNamespace);
                    if (valueType !== 'bubbleSize') {
                        writer.writeString(chartData.yValue.toString());
                    }
                    else {
                        writer.writeString(chartData.size.toString());
                    }
                    writer.writeEndElement(); // end of v
                    writer.writeEndElement(); // end of pt
                }
            }
        }
        writer.writeEndElement(); // end of numCache
        writer.writeEndElement(); // end of numRef
        writer.writeEndElement(); // end of val
    };
    // chart type
    WordExport.prototype.chartType = function (chart) {
        var chartType = chart.chartType;
        switch (chartType) {
            case 'Pie':
                chartType = 'pieChart';
                break;
            case 'Doughnut':
                chartType = 'doughnutChart';
                break;
            case 'Scatter_Markers':
                chartType = 'scatterChart';
                break;
            case 'Bubble':
                chartType = 'bubbleChart';
                break;
        }
        if (chartType === 'Area' || chartType === 'Area_Stacked' || chartType === 'Area_Stacked_100') {
            chartType = 'areaChart';
        }
        if (chartType === 'Bar_Stacked_100' || chartType === 'Bar_Stacked' || chartType === 'Bar_Clustered' ||
            chartType === 'Column_Clustered' || chartType === 'Column_Stacked' || chartType === 'Column_Stacked_100') {
            chartType = 'barChart';
        }
        if (chartType === 'Line' || chartType === 'Line_Markers' || chartType === 'Line_Markers_Stacked' || chartType === 'Line_Stacked'
            || chartType === 'Line_Markers_Stacked_100' || chartType === 'Line_Stacked_100') {
            chartType = 'lineChart';
        }
        return chartType;
    };
    // chart group
    WordExport.prototype.chartGrouping = function (type) {
        var grouping = 'standard';
        if (type === 'Bar_Stacked' || type === 'Column_Stacked' || type === 'Area_Stacked'
            || type === 'Line_Stacked' || type === 'Line_Markers_Stacked') {
            grouping = 'stacked';
        }
        else if (type === 'Bar_Stacked_100' || type === 'Column_Stacked_100' ||
            type === 'Area_Stacked_100' || type === 'Line_Stacked_100' ||
            type === 'Line_Markers_Stacked_100') {
            grouping = 'percentStacked';
        }
        else if (type === 'Bar_Clustered' || type === 'Column_Clustered') {
            grouping = 'clustered';
        }
        return grouping;
    };
    // chart legend position
    WordExport.prototype.chartLegendPosition = function (chart) {
        var legendPosition = chart.position;
        switch (legendPosition) {
            case 'Top':
                legendPosition = 't';
                break;
            case 'Bottom':
                legendPosition = 'b';
                break;
            case 'Left':
                legendPosition = 'l';
                break;
            case 'Right':
                legendPosition = 'r';
                break;
            case 'Corner':
                legendPosition = 'tr';
                break;
            default:
                legendPosition = 'b';
                break;
        }
        return legendPosition;
    };
    // update the chard id
    WordExport.prototype.updatechartId = function (chart) {
        var id = '';
        if (id === '') {
            id = this.addChartRelation(this.documentCharts, chart);
        }
        return id;
    };
    // adds the chart relation.
    WordExport.prototype.addChartRelation = function (chartCollection, chart) {
        var relationId = '';
        relationId = this.getNextRelationShipID();
        chartCollection.add(relationId, chart);
        return relationId;
    };
    WordExport.prototype.startsWith = function (sourceString, startString) {
        return startString.length > 0 && sourceString.substring(0, startString.length) === startString;
    };
    // Serialize the graphics element for pictures.
    WordExport.prototype.serializeDrawingGraphics = function (writer, picture) {
        var id = '';
        id = this.updateShapeId(picture);
        // picture.ShapeId = this.getNextDocPrID();
        // Processing picture
        writer.writeStartElement('wp', 'docPr', this.wpNamespace);
        writer.writeAttributeString(undefined, 'id', undefined, (this.mDocPrID++).toString());
        // if (!isNullOrUndefined(picture.AlternativeText))
        //     m_writer.WriteAttributeString('descr', picture.AlternativeText);
        writer.writeAttributeString(undefined, 'name', undefined, '1'.toString());
        // if (!string.IsNullOrEmpty(picture.Title))
        //     m_writer.WriteAttributeString('title', picture.Title);
        // else
        writer.writeAttributeString(undefined, 'title', undefined, '');
        // if (!picture.Visible)
        //     m_writer.WriteAttributeString('hidden', '1');
        // SerializePictureHyperlink(picture);
        writer.writeEndElement();
        writer.writeStartElement('a', 'graphic', this.aNamespace);
        writer.writeStartElement('a', 'graphicData', this.aNamespace);
        writer.writeAttributeString(undefined, 'uri', undefined, this.pictureNamespace);
        writer.writeStartElement('pic', 'pic', this.pictureNamespace);
        writer.writeStartElement('pic', 'nvPicPr', this.pictureNamespace);
        writer.writeStartElement('pic', 'cNvPr', this.pictureNamespace);
        writer.writeAttributeString(undefined, 'id', undefined, '0');
        writer.writeAttributeString(undefined, 'name', undefined, '');
        writer.writeAttributeString(undefined, 'descr', undefined, '');
        writer.writeEndElement();
        writer.writeStartElement('pic', 'cNvPicPr', this.pictureNamespace);
        writer.writeStartElement('a', 'picLocks', this.aNamespace);
        writer.writeAttributeString(undefined, 'noChangeAspect', undefined, '1');
        writer.writeAttributeString(undefined, 'noChangeArrowheads', undefined, '1');
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeStartElement('pic', 'blipFill', this.pictureNamespace);
        writer.writeStartElement('a', 'blip', this.aNamespace);
        if (this.startsWith(picture.imageString, 'data:image')) {
            writer.writeAttributeString('r', 'embed', this.rNamespace, id);
        }
        else {
            if (this.documentImages.containsKey(id)) {
                //Remove the image document images collection for this particular key
                //If the picture image data has href means MS Word contains the image in media folder as well as 
                //it is having external relationship id
                // if (!this.startsWith(picture.imageString, 'data:image')) {
                this.documentImages.remove(id);
                this.externalImages.add(id, picture.imageString);
                writer.writeAttributeString(undefined, 'link', this.rNamespace, id);
            }
        }
        //End Element Blip
        writer.writeEndElement();
        writer.writeStartElement('a', 'srcRect', this.aNamespace);
        writer.writeEndElement();
        writer.writeStartElement('a', 'stretch', this.aNamespace);
        writer.writeStartElement('a', 'fillRect', this.aNamespace);
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeStartElement('pic', 'spPr', this.pictureNamespace);
        writer.writeAttributeString(undefined, 'bwMode', undefined, 'auto');
        writer.writeStartElement('a', 'xfrm', this.aNamespace);
        // if (picture.Rotation !== 0)
        //     m_writer.WriteAttributeString('rot', picture.Rotation.ToString());
        writer.writeStartElement('a', 'off', this.aNamespace);
        writer.writeAttributeString(undefined, 'x', undefined, '0');
        writer.writeAttributeString(undefined, 'y', undefined, '0');
        writer.writeEndElement();
        writer.writeStartElement('a', 'ext', this.aNamespace);
        var cx = Math.round((picture.width * this.emusPerPoint));
        writer.writeAttributeString(undefined, 'cx', undefined, cx.toString());
        var cy = Math.round((picture.height * this.emusPerPoint));
        writer.writeAttributeString(undefined, 'cy', undefined, cy.toString());
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeStartElement('a', 'prstGeom', this.aNamespace);
        writer.writeAttributeString(undefined, 'prst', undefined, 'rect');
        writer.writeStartElement('a', 'avLst', this.aNamespace);
        writer.writeEndElement();
        writer.writeEndElement();
        //When the picture border has been added next to effect list
        //if not, Picture border has not been preserved
        // if (picture.HasBorder)
        // {
        //     if (picture.TextWrappingStyle === TextWrappingStyle.Inline && picture.IsShape)
        //         SerializeInlineShapeLine(picture.PictureShape);
        //     else
        //         SerializeShapeLine(picture.PictureShape);
        // }
        // if (picture.DocxProps.length > 0)
        //     SerializeDocxProps(picture.DocxProps, 'effectLst');
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
    };
    /// Update the shape id.
    WordExport.prototype.updateShapeId = function (picture) {
        var id = '';
        var tOwner = this.paragraph;
        // Adding picture byte data to the corresponding picture collection 
        // depending on its owner subdocument
        if (this.headerFooter) {
            id = this.updateHFImageRels(this.headerFooter, picture);
        }
        else {
            if (id === '') {
                if (tOwner.hasOwnProperty('sectionFormat') || tOwner.hasOwnProperty('inlines')) {
                    id = this.addImageRelation(this.documentImages, picture);
                    // if (owner is WFootnote)
                    // {
                    //     if ((owner as WFootnote).FootnoteType === FootnoteType.Footnote)
                    //         id = AddImageRelation(FootnoteImages, picture.ImageRecord);
                    //     else
                    //         id = AddImageRelation(EndnoteImages, picture.ImageRecord);
                    // }
                    // if (owner is WComment)
                    //     id = AddImageRelation(CommentImages, picture.ImageRecord);
                }
            }
        }
        return id;
    };
    // Adds the image relation.
    WordExport.prototype.addImageRelation = function (imageCollection, image) {
        var relationId = '';
        // if (imageCollection.ContainsValue(imageRecord)) {
        //     foreach(string key in imageCollection.keys)
        //     {
        //         if (imageRecord === imageCollection[key]) {
        //             relationId = key;
        //             break;
        //         }
        //     }
        // }
        // else {
        relationId = this.getNextRelationShipID();
        imageCollection.add(relationId, image);
        // }
        return relationId;
    };
    // Update the HeaderFooter image relations.
    WordExport.prototype.updateHFImageRels = function (hf, image) {
        var id = '';
        // UpdateImages(image);
        var headerId = '';
        var types = this.headersFooters.keys;
        for (var i = 0; i < types.length; i++) {
            var hfColl = this.headersFooters.get(types[i]);
            var hfKeys = hfColl.keys;
            for (var j = 0; j < hfKeys.length; j++) {
                if (hfColl.get(hfKeys[j]) === hf) {
                    headerId = hfKeys[j];
                    var headerImages = void 0;
                    if (this.headerFooterImages.containsKey(headerId)) {
                        headerImages = this.headerFooterImages.get(headerId);
                        id = this.addImageRelation(headerImages, image);
                    }
                    else {
                        headerImages = new Dictionary();
                        id = this.addImageRelation(headerImages, image);
                        this.headerFooterImages.add(headerId, headerImages);
                    }
                }
            }
        }
        return id;
    };
    // Serialize the table
    WordExport.prototype.serializeTable = function (writer, table) {
        if (table.rows.length <= 0) {
            return;
        }
        var owner = this.table;
        this.table = table;
        writer.writeStartElement(undefined, 'tbl', this.wNamespace);
        var tableFormat = table.rows[0].rowFormat;
        this.serializeTableFormat(writer, tableFormat, table);
        this.serializeTableGrid(writer, table);
        this.serializeTableRows(writer, table.rows);
        writer.writeEndElement();
        this.table = owner;
    };
    // Serialize the table grid
    WordExport.prototype.serializeTableGrid = function (writer, table) {
        writer.writeStartElement(undefined, 'tblGrid', this.wNamespace);
        if (table.grid.length !== 0) {
            this.serializeGridColumns(writer, table.grid);
        }
        writer.writeEndElement();
    };
    // Serialize the table rows
    WordExport.prototype.serializeTableRows = function (writer, rows) {
        if (rows.length > 0) {
            for (var i = 0; i < rows.length; i++) {
                var row = rows[i];
                if (row.cells.length > 0) {
                    this.serializeRow(writer, row);
                }
            }
        }
    };
    // Serialize the table row
    WordExport.prototype.serializeRow = function (writer, row) {
        var owner = this.row;
        this.row = row;
        writer.writeStartElement(undefined, 'tr', this.wNamespace);
        this.serializeRowFormat(writer, row);
        this.serializeCells(writer, row.cells);
        writer.writeEndElement(); //end od table row 'tr'
        this.row = owner;
    };
    // Serialize the row format
    WordExport.prototype.serializeRowFormat = function (writer, row) {
        this.serializeRowMargins(writer, row.rowFormat);
        writer.writeStartElement(undefined, 'trPr', this.wNamespace);
        //Serialize Row Height
        if (row.rowFormat.height > 0) {
            writer.writeStartElement(undefined, 'trHeight', this.wNamespace);
            if (row.rowFormat.heightType === 'Exactly') {
                writer.writeAttributeString('w', 'hRule', this.wNamespace, 'exact');
            }
            else if (row.rowFormat.heightType === 'AtLeast') {
                writer.writeAttributeString('w', 'hRule', this.wNamespace, 'atLeast');
            }
            var height = this.roundToTwoDecimal(row.rowFormat.height * this.twentiethOfPoint).toString();
            writer.writeAttributeString('w', 'val', this.wNamespace, height);
            writer.writeEndElement();
        }
        var rowFormat = row.rowFormat;
        // //Serialize 'gridBefore' element
        var gridBefore = rowFormat.gridBefore;
        if (gridBefore > 0) {
            writer.writeStartElement(undefined, 'gridBefore', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, gridBefore.toString());
            writer.writeEndElement();
        }
        // //Serialize 'gridAfter' element
        var gridAfter = rowFormat.gridAfter;
        if (gridAfter > 0) {
            writer.writeStartElement(undefined, 'gridAfter', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, gridAfter.toString());
            writer.writeEndElement();
        }
        // //Serialize 'wBefore' element 
        if (gridBefore > 0) {
            writer.writeStartElement(undefined, 'wBefore', this.wNamespace);
            switch (rowFormat.gridBeforeWidthType) {
                case 'Percent':
                    var width = this.roundToTwoDecimal(rowFormat.gridBeforeWidth * this.percentageFactor).toString();
                    writer.writeAttributeString('w', 'val', this.wNamespace, width);
                    writer.writeAttributeString('w', 'type', this.wNamespace, 'pct');
                    break;
                case 'Point':
                    var pointWidth = this.roundToTwoDecimal(rowFormat.gridBeforeWidth * this.twipsInOnePoint).toString();
                    writer.writeAttributeString('w', 'val', this.wNamespace, pointWidth);
                    writer.writeAttributeString('w', 'type', this.wNamespace, 'dxa');
                    break;
            }
            writer.writeEndElement();
        }
        //Serialize 'wAfter' element
        if (gridAfter > 0) {
            writer.writeStartElement(undefined, 'wAfter', this.wNamespace);
            switch (rowFormat.gridAfterWidthType) {
                case 'Percent':
                    var width = this.roundToTwoDecimal(rowFormat.gridAfterWidth * this.percentageFactor).toString();
                    writer.writeAttributeString('w', 'val', this.wNamespace, width);
                    writer.writeAttributeString('w', 'type', this.wNamespace, 'pct');
                    break;
                case 'Point':
                    var pointWidth = this.roundToTwoDecimal(rowFormat.gridAfterWidth * this.twipsInOnePoint).toString();
                    writer.writeAttributeString('w', 'val', this.wNamespace, pointWidth);
                    writer.writeAttributeString('w', 'type', this.wNamespace, 'dxa');
                    break;
            }
            writer.writeEndElement();
        }
        //Serialize 'cantSplit' element 
        if (!rowFormat.allowBreakAcrossPages) {
            writer.writeStartElement(undefined, 'cantSplit', this.wNamespace);
            writer.writeEndElement();
        }
        // //Serialize 'tblHeader' element 
        if (rowFormat.isHeader) {
            writer.writeStartElement(undefined, 'tblHeader', this.wNamespace);
            writer.writeEndElement();
        }
        writer.writeEndElement();
    };
    // serialize the table cells
    WordExport.prototype.serializeCells = function (writer, cells) {
        for (var i = 0; i < cells.length; i++) {
            this.serializeCell(writer, cells[i]);
        }
    };
    // Serialize the table cell
    WordExport.prototype.serializeCell = function (writer, cell) {
        var owner = this.blockOwner;
        this.blockOwner = cell;
        writer.writeStartElement(undefined, 'tc', this.wNamespace);
        this.serializeCellFormat(writer, cell.cellFormat, true, true);
        if (cell.blocks.length > 0) {
            var itemIndex = 0;
            var item = undefined;
            while (itemIndex < cell.blocks.length) {
                item = cell.blocks[itemIndex];
                this.serializeBodyItem(writer, item, false);
                itemIndex += 1;
            }
        }
        else {
            writer.writeStartElement(undefined, 'p', this.wNamespace);
            writer.writeStartElement(undefined, 'pPr', this.wNamespace);
            writer.writeStartElement(undefined, 'pStyle', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, 'Normal');
            writer.writeEndElement(); //end of pStyle
            writer.writeEndElement(); //end of pPr
            writer.writeEndElement(); //end of P
        }
        writer.writeEndElement(); //end of table cell 'tc'        
        if (this.mVerticalMerge.containsKey((cell.columnIndex + cell.cellFormat.columnSpan - 1) + 1)
            && (((this.row.cells.indexOf(cell) === this.row.cells.length - 1) || this.row.cells.indexOf(cell) === cell.columnIndex))
            && cell.nextNode === undefined) {
            var collKey = (cell.columnIndex + cell.cellFormat.columnSpan - 1) + 1;
            writer.writeStartElement(undefined, 'tc', this.wNamespace);
            var endProperties = true;
            if (!isNullOrUndefined(this.spanCellFormat)) {
                endProperties = false;
                this.serializeCellFormat(writer, this.spanCellFormat, false, endProperties);
            }
            this.serializeColumnSpan(collKey, writer);
            writer.writeStartElement(undefined, 'vMerge', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, 'continue');
            writer.writeEndElement();
            if (!endProperties) {
                writer.writeEndElement();
            }
            this.checkMergeCell(collKey);
            writer.writeStartElement('w', 'p', this.wNamespace);
            writer.writeEndElement(); //end of P
            writer.writeEndElement(); //end of table cell 'tc'  
        }
        this.blockOwner = owner;
    };
    // Serialize the cell formatting
    WordExport.prototype.serializeCellFormat = function (writer, cellFormat, ensureMerge, endProperties) {
        var cell = this.blockOwner;
        //Get the table fomat
        var tf = this.table.tableFormat;
        //Get the row format
        var rf = this.row.rowFormat;
        writer.writeStartElement(undefined, 'tcPr', this.wNamespace);
        //w:cnfStyle -   Table Cell Conditional Formatting
        // SerializeCnfStyleElement(cell);
        //w:tcW -    Preferred Table Cell Width
        this.serializeCellWidth(writer, cell);
        // serialize cell margins
        this.serializeCellMargins(writer, cellFormat);
        if (ensureMerge) {
            //w:gridSpan -   Grid Columns Spanned by Current Table Cell
            this.serializeGridSpan(writer, cell);
            //w:hMerge -    Horizontally Merged Cell and w:vMerge -    Vertically Merged Cell
            this.serializeCellMerge(writer, cellFormat);
        }
        //w:tcBorders -    Table Cell Borders
        writer.writeStartElement(undefined, 'tcBorders', this.wNamespace);
        this.serializeBorders(writer, cellFormat.borders, 8);
        writer.writeEndElement();
        //w:shd -  Table Cell Shading
        this.serializeShading(writer, cell.cellFormat.shading);
        // //w:noWrap -   Don't Wrap Cell Content
        // if (cellFormat.HasValue(CellFormat.TextWrapKey)) {
        //     m_writer.WriteStartElement('noWrap', W_namespace);
        //     if (cellFormat.TextWrap)
        //         m_writer.WriteAttributeString('w', 'val', W_namespace, 'false');
        //     m_writer.WriteEndElement();
        // }
        // //w:tcMar -  Single Table Cell Margins
        // if (!cellFormat.SamePaddingsAsTable) {
        //     m_writer.WriteStartElement('tcMar', W_namespace);
        //     SerializePaddings(cellFormat.Paddings);
        //     m_writer.WriteEndElement();
        // }
        //w:textDirection -   Table Cell Text Flow Direction
        this.serializeTableCellDirection(writer, cellFormat);
        // //w:tcFitText -  Fit Text Within Cell
        // if (cellFormat.FitText) {
        //     m_writer.WriteStartElement('tcFitText', W_namespace);
        //     m_writer.WriteEndElement();
        // }
        // //w:hideMark 
        // if (cellFormat.HideMark) {
        //     m_writer.WriteStartElement('hideMark', W_namespace);
        //     m_writer.WriteEndElement();
        // }
        //w:vAlign -  Table Cell Vertical Alignment
        // if (cellFormat.HasValue(CellFormat.VrAlignmentKey))
        this.serializeCellVerticalAlign(writer, cellFormat.verticalAlignment);
        // //w:hideMark -   Ignore End Of Cell Marker In Row Height Calculation
        // SerializeDocxProps(tempDocxProps, 'hideMark');
        // //w:cellIns -    Table Cell Insertion
        // SerializeDocxProps(tempDocxProps, 'cellIns');
        // //w:cellDel -    Table Cell Deletion
        // SerializeDocxProps(tempDocxProps, 'cellDel');
        // //w:cellMerge -   Vertically Merged/Split Table Cells
        // SerializeDocxProps(tempDocxProps, 'cellMerge');
        // if (cellFormat.OldPropertiesHash.length > 0 && !m_isAlternativeCellFormat) {
        //     m_isAlternativeCellFormat = true;
        //     SerializeTrackChangeProps('tcPrChange', cellFormat.FormatChangeAuthorName, cellFormat.FormatChangeDateTime);
        //     Dictionary < int, object > oldPropertyHash = new Dictionary<int, object>(cellFormat.OldPropertiesHash);
        //     Dictionary < int, object > propertyHash = new Dictionary<int, object>(cellFormat.PropertiesHash);
        //     cellFormat.PropertiesHash.Clear();
        //     cellFormat.OldPropertiesHash.Clear();
        //     foreach(KeyValuePair < int, object > keyValue in oldPropertyHash)
        //     cellFormat.PropertiesHash[keyValue.Key] = keyValue.Value;
        //     SerializeCellFormat(cellFormat);
        //     cellFormat.PropertiesHash.Clear();
        //     foreach(KeyValuePair < int, object > keyValue in propertyHash)
        //     cellFormat.PropertiesHash[keyValue.Key] = keyValue.Value;
        //     foreach(KeyValuePair < int, object > keyValue in oldPropertyHash)
        //     cellFormat.OldPropertiesHash[keyValue.Key] = keyValue.Value;
        //     m_writer.WriteEndElement();
        //     m_isAlternativeCellFormat = false;
        // }
        if (endProperties) {
            writer.writeEndElement();
        }
    };
    // Serialize the cell width
    WordExport.prototype.serializeCellWidth = function (writer, cell) {
        var cf = cell.cellFormat;
        writer.writeStartElement(undefined, 'tcW', this.wNamespace);
        if (cf.preferredWidthType === 'Percent') {
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'pct');
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'w', this.wNamespace, this.roundToTwoDecimal(cf.preferredWidth * this.percentageFactor).toString());
        }
        else if (cf.preferredWidthType === 'Auto') {
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'auto');
            writer.writeAttributeString(undefined, 'w', this.wNamespace, '0');
        }
        else {
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'w', this.wNamespace, this.roundToTwoDecimal(cf.preferredWidth * this.twipsInOnePoint).toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
        }
        writer.writeEndElement();
    };
    // Serialize cell merge
    WordExport.prototype.serializeCellMerge = function (writer, cellFormat) {
        var cell = this.blockOwner;
        var isserialized = false;
        var collKey;
        var currentIndex = cell.columnIndex;
        var cellIndex = this.row.cells.indexOf(cell);
        var prevIndex = cellIndex > 0 ? this.row.cells[cellIndex - 1].columnIndex : cell.columnIndex;
        if (cell.columnIndex === cellIndex) {
            collKey = cell.columnIndex;
            isserialized = true;
        }
        else {
            isserialized = false;
        }
        if (!isserialized) {
            if (cellIndex === 0) {
                currentIndex = cell.columnIndex;
                prevIndex = -1;
            }
            for (var i = prevIndex; i < currentIndex; i++) {
                collKey = prevIndex + 1;
                prevIndex += 1;
                if (this.mVerticalMerge.containsKey(collKey)) {
                    this.createMerge(writer, collKey, cell);
                }
            }
        }
        if (cellFormat.rowSpan > 1) {
            writer.writeStartElement(undefined, 'vMerge', this.wNamespace);
            this.spanCellFormat = cellFormat;
            this.mVerticalMerge.add(collKey, cellFormat.rowSpan - 1);
            if (cellFormat.columnSpan > 1) {
                this.mGridSpans.add(collKey, cellFormat.columnSpan);
            }
            writer.writeAttributeString('w', 'val', this.wNamespace, 'restart');
            writer.writeEndElement();
        }
        else if (this.mVerticalMerge.containsKey(collKey) && isserialized) {
            this.createMerge(writer, collKey, cell);
        }
    };
    WordExport.prototype.createMerge = function (writer, collKey, cell) {
        this.serializeColumnSpan(collKey, writer);
        writer.writeStartElement(undefined, 'vMerge', this.wNamespace);
        writer.writeAttributeString('w', 'val', this.wNamespace, 'continue');
        writer.writeEndElement();
        writer.writeEndElement(); //end tcPr
        writer.writeStartElement('w', 'p', this.wNamespace);
        writer.writeEndElement();
        writer.writeEndElement(); //end tc
        writer.writeStartElement(undefined, 'tc', this.wNamespace);
        writer.writeStartElement(undefined, 'tcPr', this.wNamespace);
        this.serializeCellWidth(writer, cell);
        this.checkMergeCell(collKey);
    };
    WordExport.prototype.serializeColumnSpan = function (collKey, writer) {
        if (this.mGridSpans.keys.length > 0 && this.mGridSpans.containsKey(collKey)) {
            writer.writeStartElement(undefined, 'gridSpan', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, this.mGridSpans.get(collKey).toString());
            writer.writeEndElement();
        }
    };
    WordExport.prototype.checkMergeCell = function (collKey) {
        if ((this.mVerticalMerge.get(collKey) - 1) === 0) {
            this.mVerticalMerge.remove(collKey);
            this.spanCellFormat = undefined;
            if (this.mGridSpans.keys.length > 0 && this.mGridSpans.containsKey(collKey)) {
                this.mGridSpans.remove(collKey);
            }
        }
        else {
            this.mVerticalMerge.set(collKey, this.mVerticalMerge.get(collKey) - 1);
        }
    };
    // Serialize the grid span element of cell.
    WordExport.prototype.serializeGridSpan = function (writer, cell) {
        // int gridSpan = cell.cellFormat.GridSpan;
        if (cell.cellFormat.columnSpan > 1) {
            var num = cell.cellFormat.columnSpan;
            writer.writeStartElement(undefined, 'gridSpan', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, num.toString());
            writer.writeEndElement();
        }
    };
    // Serialize the table cell direction
    WordExport.prototype.serializeTableCellDirection = function (writer, cellFormat) {
        // if (cellFormat..textDirection !== TextDirection.Horizontal)
        // {
        //     m_writer.WriteStartElement('textDirection', W_namespace);
        //     switch (cellFormat.TextDirection)
        //     {
        //         case TextDirection.Horizontal:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'lrTb');
        //             break;
        //         case TextDirection.VerticalBottomToTop:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'btLr');
        //             break;
        //         case TextDirection.VerticalTopToBottom:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'tbRl');
        //             break;
        //         case TextDirection.HorizontalFarEast:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'lrTbV');
        //             break;
        //         case TextDirection.Vertical:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'tbLrV');
        //             break;
        //         case TextDirection.VerticalFarEast:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'tbRlV');
        //             break;
        //     }
        //     m_writer.WriteEndElement();
        // }
    };
    // Serialize the cell vertical alignment
    WordExport.prototype.serializeCellVerticalAlign = function (writer, alignment) {
        writer.writeStartElement(undefined, 'vAlign', this.wNamespace);
        switch (alignment) {
            case 'Center':
                writer.writeAttributeString('w', 'val', this.wNamespace, 'center');
                break;
            case 'Bottom':
                writer.writeAttributeString('w', 'val', this.wNamespace, 'bottom');
                break;
            default:
                writer.writeAttributeString('w', 'val', this.wNamespace, 'top');
                break;
        }
        writer.writeEndElement();
    };
    // Serialize the table grid columns.
    WordExport.prototype.serializeGridColumns = function (writer, grid) {
        for (var i = 0, count = grid.length; i < count; i++) {
            var gridValue = Math.round(grid[i] * 20);
            writer.writeStartElement(undefined, 'gridCol', this.wNamespace);
            writer.writeAttributeString(undefined, 'w', this.wNamespace, gridValue.toString());
            writer.writeEndElement();
        }
    };
    // Serialize the row formattings.
    // Table parameter is passed for serializing table format and undefined for serializing row format.
    WordExport.prototype.serializeTableFormat = function (writer, format, table) {
        // if (!isNullOrUndefined(table))
        // {
        //     List<Stream> tempDocxProps = new List<Stream>();
        //     for (int i = 0, cnt = table.DocxTableFormat.NodeArray.length; i < cnt; i++)
        //         tempDocxProps.Add(table.DocxTableFormat.NodeArray[i]);
        writer.writeStartElement(undefined, 'tblPr', this.wNamespace);
        //     SerializeTableStlye(format);
        //     if (format.WrapTextAround &&!((table.OwnerTextBody.Owner is WTextBox) || 
        //(table.OwnerTextBody.Owner is WComment) || (table.OwnerTextBody.Owner is WFootnote)))
        //     {
        //         SerializeTablePositioning(format.Positioning);
        //         if (!format.Positioning.AllowOverlap)
        //         {
        //             m_writer.WriteStartElement('tblOverlap', W_namespace);
        //             m_writer.WriteAttributeString('val', W_namespace, 'never');
        //             m_writer.WriteEndElement();
        //         }
        //     }
        //     SerializeDocxProps(tempDocxProps, 'tblStyleRowBandSize');
        //     SerializeDocxProps(tempDocxProps, 'tblStyleColBandSize');       
        this.serializeTableWidth(writer, table);
        this.serializeTableAlignment(writer, table.tableFormat);
        this.serializeCellSpacing(writer, table.tableFormat);
        this.serializeTableIndentation(writer, table.tableFormat);
        this.serializeTableMargins(writer, table.tableFormat);
        this.serializeTableBorders(writer, table.tableFormat);
        this.serializeShading(writer, table.tableFormat.shading);
        if (table.tableFormat.bidi) {
            writer.writeStartElement(undefined, 'bidiVisual', this.wNamespace);
            writer.writeEndElement();
        }
        this.serializeTblLayout(writer, table.tableFormat);
        // this.serializeTableCellMargin(writer, table.tableFormat);
        //     SerializeTableLook(table);
        //         if (!isNullOrUndefined(table.Title))
        //             SerializeTableTitle(table);
        //         if (!isNullOrUndefined(table.Description))
        //             SerializeTableDescription(table);
        // }
        // else
        // {
        //     SerializeCellSpacing(format);
        //     SerializeTableIndentation(format);
        //     SerializeTableBorders(format);
        //     SerializeTableShading(format);
        //     SerializeTblLayout(format);
        //     SerializeTableCellMargin(format);
        // }
        // if (!isNullOrUndefined(format.OwnerBase) && format.OwnerBase is WTable
        //   && format.OldPropertiesHash.length > 0 && !m_isAlternativeTableFormat)
        // {
        //     m_isAlternativeTableFormat = true;
        //     SerializeTrackChangeProps('tblPrChange', format.FormatChangeAuthorName, format.FormatChangeDateTime);
        //     SerializeTableTrackChanges(format, format.OwnerBase as WTable);
        //     m_writer.WriteEndElement();
        //     m_isAlternativeTableFormat = false;
        // }
        // if (!isNullOrUndefined(format.OwnerRow) && format.OldPropertiesHash.length > 0)
        // {
        //     SerializeTrackChangeProps('tblPrExChange', format.FormatChangeAuthorName, format.FormatChangeDateTime);
        //     SerializeTableTrackChanges(format, undefined);
        //     m_writer.WriteEndElement();
        // }
        // SerializeTblTrackChanges(format);
        if (!isNullOrUndefined(table)) {
            writer.writeEndElement(); //end of tblPr
        }
    };
    // serialize the table margin
    WordExport.prototype.serializeTableMargins = function (writer, format) {
        this.serializeMargins(writer, format, 'tblCellMar');
    };
    // serialize the row margin
    WordExport.prototype.serializeRowMargins = function (writer, format) {
        writer.writeStartElement(undefined, 'tblPrEx', this.wNamespace);
        this.serializeMargins(writer, format, 'tblCellMar');
        writer.writeEndElement();
    };
    // serialize the cell margins
    WordExport.prototype.serializeCellMargins = function (writer, format) {
        this.serializeMargins(writer, format, 'tcMar');
    };
    // serialize the table margins, row margins, cell margins
    WordExport.prototype.serializeMargins = function (writer, format, tag) {
        writer.writeStartElement(undefined, tag, this.wNamespace);
        if (!isNullOrUndefined(format.topMargin)) {
            var topMargin = Math.round(format.topMargin * 20);
            writer.writeStartElement(undefined, 'top', this.wNamespace);
            writer.writeAttributeString(undefined, 'w', this.wNamespace, topMargin.toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(format.leftMargin)) {
            var leftMargin = Math.round(format.leftMargin * 20);
            writer.writeStartElement(undefined, 'left', this.wNamespace);
            writer.writeAttributeString(undefined, 'w', this.wNamespace, leftMargin.toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(format.bottomMargin)) {
            var bottomMargin = Math.round(format.bottomMargin * 20);
            writer.writeStartElement(undefined, 'bottom', this.wNamespace);
            writer.writeAttributeString(undefined, 'w', this.wNamespace, bottomMargin.toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(format.rightMargin)) {
            var rightMargin = Math.round(format.rightMargin * 20);
            writer.writeStartElement(undefined, 'right', this.wNamespace);
            writer.writeAttributeString(undefined, 'w', this.wNamespace, rightMargin.toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
            writer.writeEndElement();
        }
        writer.writeEndElement();
    };
    // Serialize the table borders
    WordExport.prototype.serializeShading = function (writer, format) {
        // if (format.textureStyle !== 'TextureNone') {
        writer.writeStartElement(undefined, 'shd', this.wNamespace);
        if (format.backgroundColor) {
            writer.writeAttributeString(undefined, 'fill', this.wNamespace, this.getColor(format.backgroundColor));
        }
        if (format.foregroundColor === 'empty' || isNullOrUndefined(format.foregroundColor)) {
            writer.writeAttributeString(undefined, 'color', this.wNamespace, 'auto');
        }
        else {
            writer.writeAttributeString(undefined, 'color', this.wNamespace, this.getColor(format.foregroundColor));
        }
        if (!isNullOrUndefined(format.textureStyle)) {
            writer.writeAttributeString('w', 'val', this.wNamespace, this.getTextureStyle(format.textureStyle));
        }
        writer.writeEndElement();
        // }
    };
    WordExport.prototype.getTextureStyle = function (textureStyle) {
        switch (textureStyle) {
            case 'Texture5Percent':
            case 'Texture2Pt5Percent':
            case 'Texture7Pt5Percent':
                return 'pct5';
            case 'Texture10Percent':
                return 'pct10';
            case 'Texture12Pt5Percent':
                return 'pct12';
            case 'Texture15Percent':
            case 'Texture17Pt5Percent':
                return 'pct15';
            case 'Texture20Percent':
            case 'Texture22Pt5Percent':
                return 'pct20';
            case 'Texture25Percent':
            case 'Texture27Pt5Percent':
                return 'pct25';
            case 'Texture30Percent':
            case 'Texture32Pt5Percent':
                return 'pct30';
            case 'Texture35Percent':
                return 'pct35';
            case 'Texture37Pt5Percent':
                return 'pct37';
            case 'Texture40Percent':
            case 'Texture42Pt5Percent':
                return 'pct40';
            case 'Texture45Percent':
            case 'Texture47Pt5Percent':
                return 'pct45';
            case 'Texture50Percent':
            case 'Texture52Pt5Percent':
                return 'pct50';
            case 'Texture55Percent':
            case 'Texture57Pt5Percent':
                return 'pct55';
            case 'Texture60Percent':
                return 'pct60';
            case 'Texture62Pt5Percent':
                return 'pct62';
            case 'Texture65Percent':
            case 'Texture67Pt5Percent':
                return 'pct65';
            case 'Texture70Percent':
            case 'Texture72Pt5Percent':
                return 'pct70';
            case 'Texture75Percent':
            case 'Texture77Pt5Percent':
                return 'pct75';
            case 'Texture80Percent':
            case 'Texture82Pt5Percent':
                return 'pct80';
            case 'Texture85Percent':
                return 'pct85';
            case 'Texture87Pt5Percent':
                return 'pct87';
            case 'Texture90Percent':
            case 'Texture92Pt5Percent':
                return 'pct90';
            case 'Texture95Percent':
            case 'Texture97Pt5Percent':
                return 'pct95';
            case 'TextureCross':
                return 'thinHorzCross';
            case 'TextureDarkCross':
                return 'horzCross';
            case 'TextureDarkDiagonalCross':
                return 'diagCross';
            case 'TextureDarkDiagonalDown':
                return 'reverseDiagStripe';
            case 'TextureDarkDiagonalUp':
                return 'diagStripe';
            case 'TextureDarkHorizontal':
                return 'horzStripe';
            case 'TextureDarkVertical':
                return 'vertStripe';
            case 'TextureDiagonalCross':
                return 'thinDiagCross';
            case 'TextureDiagonalDown':
                return 'thinReverseDiagStripe';
            case 'TextureDiagonalUp':
                return 'thinDiagStripe';
            case 'TextureHorizontal':
                return 'thinHorzStripe';
            case 'TextureSolid':
                return 'solid';
            case 'TextureVertical':
                return 'thinVertStripe';
            default:
                return 'clear';
        }
    };
    // Serialize the table borders
    WordExport.prototype.serializeTableBorders = function (writer, format) {
        var borders = format.borders;
        // if (IsNoneBorder(borders))
        //     return;
        writer.writeStartElement(undefined, 'tblBorders', this.wNamespace);
        this.serializeBorders(writer, format.borders, 8);
        writer.writeEndElement();
    };
    // Serialize the borders.
    WordExport.prototype.serializeBorders = function (writer, borders, multipler) {
        this.serializeBorder(writer, borders.top, 'top', multipler);
        this.serializeBorder(writer, borders.left, 'left', multipler);
        this.serializeBorder(writer, borders.bottom, 'bottom', multipler);
        this.serializeBorder(writer, borders.right, 'right', multipler);
        this.serializeBorder(writer, borders.horizontal, 'insideH', multipler);
        this.serializeBorder(writer, borders.vertical, 'insideV', multipler);
        this.serializeBorder(writer, borders.diagonalDown, 'tl2br', multipler);
        this.serializeBorder(writer, borders.diagonalUp, 'tr2bl', multipler);
    };
    // Serialize the table layout element
    WordExport.prototype.serializeTblLayout = function (writer, format) {
        if (!format.allowAutoFit) {
            writer.writeStartElement(undefined, 'tblLayout', this.wNamespace);
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'fixed');
            writer.writeEndElement();
        }
    };
    // Serializes the Border
    WordExport.prototype.serializeBorder = function (writer, border, tagName, multiplier) {
        var borderStyle = border.lineStyle;
        var sz = ((border.lineWidth ? border.lineWidth : 0) * multiplier);
        var space = border.space ? border.space : 0;
        if (borderStyle === 'Cleared') {
            writer.writeStartElement(undefined, tagName, this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, 'nil');
            writer.writeEndElement();
            return;
        }
        else if (((borderStyle === 'None' || isNullOrUndefined(borderStyle)) && !border.hasNoneStyle) || sz <= 0) {
            return;
        }
        writer.writeStartElement(undefined, tagName, this.wNamespace);
        writer.writeAttributeString('w', 'val', this.wNamespace, this.getBorderStyle(borderStyle));
        // if (border.color === '#000000')
        // {
        //     writer.writeAttributeString(undefined, 'color', this.wNamespace, 'auto');
        // }
        // else
        // {
        if (border.color) {
            writer.writeAttributeString(undefined, 'color', this.wNamespace, this.getColor(border.color));
        }
        // }
        writer.writeAttributeString(undefined, 'sz', this.wNamespace, this.roundToTwoDecimal(sz).toString());
        writer.writeAttributeString(undefined, 'space', this.wNamespace, space.toString());
        if (border.shadow) {
            writer.writeAttributeString(undefined, 'shadow', this.wNamespace, 'on');
        }
        writer.writeEndElement();
    };
    // Get the border style as string
    WordExport.prototype.getBorderStyle = function (borderStyle) {
        switch (borderStyle) {
            case 'Cleared':
                return 'cleared';
            case 'DashSmallGap':
                return 'dashSmallGap';
            case 'Triple':
                return 'triple';
            case 'Dot':
                return 'dotted';
            case 'DashDot':
                return 'dotDash';
            case 'DashLargeGap':
                return 'dashed';
            case 'DashDotDot':
                return 'dotDotDash';
            case 'Double':
                return 'double';
            case 'ThinThickSmallGap':
                return 'thinThickSmallGap';
            case 'ThickThinSmallGap':
                return 'thickThinSmallGap';
            case 'ThinThickThinSmallGap':
                return 'thinThickThinSmallGap';
            case 'ThickThinMediumGap':
                return 'thickThinMediumGap';
            case 'ThinThickMediumGap':
                return 'thinThickMediumGap';
            case 'ThinThickThinMediumGap':
                return 'thinThickThinMediumGap';
            case 'ThickThinLargeGap':
                return 'thickThinLargeGap';
            case 'ThinThickLargeGap':
                return 'thinThickLargeGap';
            case 'ThinThickThinLargeGap':
                return 'thinThickThinLargeGap';
            case 'Thick':
                return 'thick';
            case 'SingleWavy':
                return 'wave';
            case 'DoubleWavy':
                return 'doubleWave';
            case 'DashDotStroked':
                return 'dashDotStroked';
            case 'Engrave3D':
                return 'threeDEngrave';
            case 'Emboss3D':
                return 'threeDEmboss';
            case 'Outset':
                return 'outset';
            case 'Inset':
                return 'inset';
            // case 'None':
            //     return 'none';
            default:
                return 'single';
        }
    };
    // Serialize the table indentation.
    WordExport.prototype.serializeTableIndentation = function (writer, format) {
        writer.writeStartElement(undefined, 'tblInd', this.wNamespace);
        var tableIndent = Math.round(format.leftIndent * this.twipsInOnePoint);
        writer.writeAttributeString(undefined, 'w', this.wNamespace, tableIndent.toString());
        writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
        writer.writeEndElement();
    };
    // Serialize the cell spacing.
    WordExport.prototype.serializeCellSpacing = function (writer, format) {
        if (!isNullOrUndefined(format.cellSpacing) && format.cellSpacing > 0) {
            writer.writeStartElement(undefined, 'tblCellSpacing', this.wNamespace);
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'w', this.wNamespace, this.roundToTwoDecimal(format.cellSpacing * this.twentiethOfPoint).toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
            writer.writeEndElement();
        }
    };
    // Serialize the table width
    WordExport.prototype.serializeTableWidth = function (writer, table) {
        writer.writeStartElement(undefined, 'tblW', this.wNamespace);
        if (table.tableFormat.preferredWidthType === 'Percent') {
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'w', this.wNamespace, (table.tableFormat.preferredWidth * this.percentageFactor).toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'pct');
        }
        else if (table.tableFormat.preferredWidthType === 'Point') {
            var tableWidth = Math.round(table.tableFormat.preferredWidth * this.twipsInOnePoint);
            writer.writeAttributeString(undefined, 'w', this.wNamespace, tableWidth.toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
        }
        else {
            writer.writeAttributeString(undefined, 'w', this.wNamespace, '0');
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'auto');
        }
        writer.writeEndElement();
    };
    // Serialize the table alignment
    WordExport.prototype.serializeTableAlignment = function (writer, format) {
        writer.writeStartElement(undefined, 'jc', this.wNamespace);
        switch (format.tableAlignment) {
            case 'Right':
                writer.writeAttributeString('w', 'val', this.wNamespace, 'right');
                break;
            case 'Center':
                writer.writeAttributeString('w', 'val', this.wNamespace, 'center');
                break;
            default:
                writer.writeAttributeString('w', 'val', this.wNamespace, 'left');
                break;
        }
        writer.writeEndElement();
    };
    // Serialize the field
    WordExport.prototype.serializeFieldCharacter = function (writer, field) {
        writer.writeStartElement(undefined, 'r', this.wNamespace);
        this.serializeCharacterFormat(writer, field.characterFormat);
        writer.writeStartElement(undefined, 'fldChar', this.wNamespace);
        var type = field.fieldType === 0 ? 'begin'
            : field.fieldType === 1 ? 'end' : 'separate';
        writer.writeAttributeString(undefined, 'fldCharType', this.wNamespace, type);
        writer.writeEndElement();
        writer.writeEndElement();
        if (field.fieldType === 0 && field.fieldCodeType === 'FieldFormTextInput') {
            writer.writeStartElement('w', 'r', this.wNamespace);
            writer.writeStartElement(undefined, 'instrText', this.wNamespace);
            writer.writeAttributeString('xml', 'space', this.xmlNamespace, 'preserve');
            writer.writeString('FORMTEXT');
            writer.writeEndElement();
            writer.writeEndElement();
        }
    };
    // Serialize the text range.
    WordExport.prototype.serializeTextRange = function (writer, span, previousNode) {
        writer.writeStartElement('w', 'r', this.wNamespace);
        if (!isNullOrUndefined(span.characterFormat)) {
            this.serializeCharacterFormat(writer, span.characterFormat);
        }
        if (span.text === '\t') {
            writer.writeElementString(undefined, 'tab', this.wNamespace, undefined);
        }
        else if (span.text === '\v') {
            writer.writeElementString(undefined, 'br', this.wNamespace, undefined);
        }
        else if (span.text === '\f') {
            writer.writeStartElement(undefined, 'br', this.wNamespace);
            writer.writeAttributeString('w', 'type', this.wNamespace, 'page');
            writer.writeEndElement();
        }
        else {
            var isField = !isNullOrUndefined(previousNode)
                && previousNode.hasOwnProperty('fieldType') && previousNode.fieldType !== 2;
            writer.writeStartElement(undefined, isField ? 'instrText' : 't', this.wNamespace);
            writer.writeAttributeString('xml', 'space', this.xmlNamespace, 'preserve');
            writer.writeString(span.text);
            writer.writeEndElement();
        }
        writer.writeEndElement();
    };
    // Serializes the paragraph format
    WordExport.prototype.serializeParagraphFormat = function (writer, paragraphFormat, paragraph) {
        if (!isNullOrUndefined(paragraphFormat.styleName)) {
            writer.writeStartElement(undefined, 'pStyle', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, paragraphFormat.styleName);
            writer.writeEndElement(); //end of pStyle
        }
        if (!isNullOrUndefined(paragraph)) {
            this.serializeListFormat(writer, paragraph.paragraphFormat.listFormat);
        }
        else {
            this.serializeListFormat(writer, paragraphFormat.listFormat);
        }
        if (paragraphFormat.bidi) {
            writer.writeStartElement(undefined, 'bidi', this.wNamespace);
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(paragraphFormat.contextualSpacing)) {
            writer.writeStartElement('w', 'contextualSpacing', this.wNamespace);
            if (!paragraphFormat.contextualSpacing) {
                writer.writeAttributeString('w', 'val', this.wNamespace, '0');
            }
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(paragraphFormat.outlineLevel)) {
            writer.writeStartElement(undefined, 'outlineLvl', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, this.getOutlineLevelValue(paragraphFormat.outlineLevel).toString());
            writer.writeEndElement();
        }
        this.serializeParagraphSpacing(writer, paragraphFormat);
        this.serializeIndentation(writer, paragraphFormat);
        this.serializeParagraphAlignment(writer, paragraphFormat.textAlignment, paragraphFormat.bidi);
        if (!isNullOrUndefined(paragraphFormat.tabs) && paragraphFormat.tabs.length > 0) {
            this.serializeTabs(writer, paragraphFormat.tabs);
        }
    };
    WordExport.prototype.getOutlineLevelValue = function (outlineLvl) {
        if (outlineLvl.indexOf('Level') !== -1) {
            var lvlNumber = parseInt(outlineLvl.substring(5), 10);
            if (lvlNumber > 0) {
                return lvlNumber - 1;
            }
        }
        return 9;
    };
    // Serialize Tabs
    WordExport.prototype.serializeTabs = function (writer, tabStops) {
        writer.writeStartElement('w', 'tabs', this.wNamespace);
        for (var i = 0; i < tabStops.length; i++) {
            this.serializeTab(writer, tabStops[i]);
        }
        writer.writeEndElement();
    };
    WordExport.prototype.serializeTab = function (writer, tabStop) {
        var position = 0;
        writer.writeStartElement('w', 'tab', this.wNamespace);
        if (tabStop.position === 0 && tabStop.deletePosition !== 0) {
            position = tabStop.deletePosition * this.twentiethOfPoint;
            writer.writeAttributeString('w', 'val', this.wNamespace, 'clear');
        }
        else {
            position = tabStop.position * this.twentiethOfPoint;
            writer.writeAttributeString('w', 'val', this.wNamespace, this.getTabJustification(tabStop.tabJustification));
        }
        if (!isNullOrUndefined(tabStop.tabLeader) && (tabStop.tabLeader !== 'None')) {
            writer.writeAttributeString('w', 'leader', this.wNamespace, this.getTabLeader(tabStop.tabLeader));
        }
        writer.writeAttributeString('w', 'pos', this.wNamespace, position.toString() + '');
        writer.writeEndElement();
    };
    WordExport.prototype.getTabLeader = function (tabLeader) {
        switch (tabLeader) {
            case 'Dot':
                return 'dot';
            case 'Hyphen':
                return 'hyphen';
            case 'Underscore':
                return 'underscore';
            default:
                return 'none';
        }
    };
    WordExport.prototype.getTabJustification = function (tabJustification) {
        switch (tabJustification) {
            case 'Bar':
                return 'bar';
            case 'Center':
                return 'center';
            case 'Decimal':
                return 'decimal';
            case 'Left':
                return 'left';
            case 'List':
                return 'num';
            case 'Right':
                return 'right';
            default:
                return 'clear';
        }
    };
    // // Seraializes the pargraph list format
    // private serializeListParagraph(writer: XmlWriter, paragraph: any): void {
    //     if (!isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
    //         this.serializeListFormat(writer, paragraph.paragraphFormat.listFormat);
    //     }
    // }
    // Serialize the list format
    WordExport.prototype.serializeListFormat = function (writer, lf) {
        // let pStyleName = undefined;
        // if (lf.CurrentListStyle.IsBuiltInStyle && !isNullOrUndefined(lf.OwnerParagraph))
        // {
        //     pStyleName = lf.OwnerParagraph.StyleName;
        // }
        // int listId = GetListId(lf);
        // if (!isNullOrUndefined(pStyleName) && string.IsNullOrEmpty(lf.LFOStyleName)) 
        // {
        //     WordDocument doc = lf.OwnerParagraph.Document;
        //     WParagraphStyle style = doc.Styles.FindByName(pStyleName, StyleType.ParagraphStyle) as WParagraphStyle;
        //     if (style.ListIndex === -1)
        //     {
        //         ListStyle lstStyle = lf.OwnerParagraph.Document.ListStyles.FindByName(lf.CustomStyleName);
        //         style.ListIndex = listId;
        //         if (lstStyle.Levels.length > 1)
        //         {
        //             style.ListLevel = lf.ListLevelNumber;
        //         }
        //         pStyleName = pStyleName.Replace(' ', '');
        //         lstStyle.Levels[lf.ListLevelNumber].ParaStyleName = pStyleName;
        //     }
        // }
        // else
        // {
        // if (!isNullOrUndefined(lf.listId) && !isNullOrUndefined(lf.listLevelNumber)) {
        //     this.serializeNumPr(writer, lf.listId, lf.listLevelNumber);
        // }
        // }
        if (!isNullOrUndefined(lf.listId) || !isNullOrUndefined(lf.listLevelNumber)) {
            writer.writeStartElement(undefined, 'numPr', this.wNamespace);
            if (!isNullOrUndefined(lf.listLevelNumber) && lf.listLevelNumber !== -1) {
                writer.writeStartElement(undefined, 'ilvl', this.wNamespace);
                writer.writeAttributeString('w', 'val', this.wNamespace, lf.listLevelNumber.toString());
                writer.writeEndElement();
            }
            if (!isNullOrUndefined(lf.listId)) {
                writer.writeStartElement(undefined, 'numId', this.wNamespace);
                writer.writeAttributeString('w', 'val', this.wNamespace, (lf.listId + 1).toString());
                writer.writeEndElement();
            }
            writer.writeEndElement();
        }
    };
    // // Serializes the numbering properties to the paragraph
    // private serializeNumPr(writer: XmlWriter, listId: number, listLevel: number): void {
    //     writer.writeStartElement(undefined, 'numPr', this.wNamespace);
    //     if (listLevel !== -1) {
    //         writer.writeStartElement(undefined, 'ilvl', this.wNamespace);
    //         writer.writeAttributeString('w', 'val', this.wNamespace, listLevel.toString());
    //         writer.writeEndElement();
    //     }
    //     if (listId !== -1) {
    //         writer.writeStartElement(undefined, 'numId', this.wNamespace);
    //         writer.writeAttributeString('w', 'val', this.wNamespace, listId.toString());
    //         writer.writeEndElement();
    //     }
    //     writer.writeEndElement();
    // }
    WordExport.prototype.serializeParagraphAlignment = function (writer, txtAlignment, isBidi) {
        if (isBidi) {
            if (txtAlignment === 'Right') {
                txtAlignment = 'Left';
            }
            else if (txtAlignment === 'Left') {
                txtAlignment = 'Right';
            }
        }
        if (!isNullOrUndefined(txtAlignment)) {
            writer.writeStartElement(undefined, 'jc', this.wNamespace);
            var alignment = void 0;
            switch (txtAlignment) {
                case 'Center':
                    alignment = 'center';
                    break;
                case 'Right':
                    alignment = 'right';
                    break;
                case 'Justify':
                    alignment = 'both';
                    break;
                default:
                    alignment = 'left';
                    break;
            }
            writer.writeAttributeString('w', 'val', this.wNamespace, alignment);
            writer.writeEndElement();
        }
    };
    // Serializes the paragraph spacings
    WordExport.prototype.serializeParagraphSpacing = function (writer, paragraphFormat) {
        writer.writeStartElement(undefined, 'spacing', this.wNamespace);
        // if (paragraphFormat.HasValue(WParagraphFormat.BeforeLinesKey))
        // {
        //     short beforeLines = (short)Math.Round(paragraphFormat.BeforeLines * DLSConstants.HundredthsUnit);
        //     writer.WriteAttributeString('beforeLines', this.wNamespace, ToString((float)beforeLines));               
        // }
        // if (paragraphFormat.HasValue(WParagraphFormat.AfterLinesKey))
        // {
        //     short afterLines = (short)Math.Round(paragraphFormat.AfterLines * DLSConstants.HundredthsUnit);
        //     writer.WriteAttributeString('afterLines', this.wNamespace, ToString((float)afterLines));                 
        // }
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(paragraphFormat.beforeSpacing)) {
            writer.writeAttributeString(undefined, 'before', this.wNamespace, this.roundToTwoDecimal(paragraphFormat.beforeSpacing * this.twentiethOfPoint).toString());
        }
        //TODO:ISSUEFIX(paragraphFormat.beforeSpacing * this.twentiethOfPoint).toString());
        // if (paragraphFormat.HasValue(WParagraphFormat.SpacingBeforeAutoKey))
        // {
        //     if (paragraphFormat.SpaceBeforeAuto)
        //     {
        //         writer.WriteAttributeString('beforeAutospacing', this.wNamespace, '1');
        //     }
        //     else
        //     {
        //         writer.WriteAttributeString('beforeAutospacing', this.wNamespace, '0');
        //     }
        // }
        if (!isNullOrUndefined(paragraphFormat.afterSpacing)) {
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'after', this.wNamespace, this.roundToTwoDecimal(paragraphFormat.afterSpacing * this.twentiethOfPoint).toString());
        }
        //TODO:ISSUEFIX(paragraphFormat.afterSpacing * this.twentiethOfPoint).toString());
        // if (paragraphFormat.HasValue(WParagraphFormat.SpacingAfterAutoKey))
        // {
        //     if (paragraphFormat.SpaceAfterAuto)
        //     {
        //         writer.WriteAttributeString('afterAutospacing', this.wNamespace, '1');
        //     }
        //     else
        //     {
        //         writer.WriteAttributeString('afterAutospacing', this.wNamespace, '0');
        //     }
        // }
        //TODO:ISSUEFIX((paragraphFormat.lineSpacing) * this.twentiethOfPoint).toString());
        if (!isNullOrUndefined(paragraphFormat.lineSpacing)) {
            // tslint:disable-next-line:max-line-length
            var lineSpacingValue = (paragraphFormat.lineSpacingType === 'AtLeast' || paragraphFormat.lineSpacingType === 'Exactly') ? this.roundToTwoDecimal(paragraphFormat.lineSpacing * this.twentiethOfPoint) : this.roundToTwoDecimal(paragraphFormat.lineSpacing * 240);
            writer.writeAttributeString(undefined, 'line', this.wNamespace, lineSpacingValue.toString());
        }
        if (!isNullOrUndefined(paragraphFormat.lineSpacingType)) {
            var lineSpacingType = 'auto';
            if (paragraphFormat.lineSpacingType === 'AtLeast') {
                lineSpacingType = 'atLeast';
            }
            else if (paragraphFormat.lineSpacingType === 'Exactly') {
                lineSpacingType = 'exact';
            }
            writer.writeAttributeString(undefined, 'lineRule', this.wNamespace, lineSpacingType);
        }
        writer.writeEndElement();
    };
    // Serializes the paragraph indentation
    WordExport.prototype.serializeIndentation = function (writer, paragraphFormat) {
        writer.writeStartElement(undefined, 'ind', this.wNamespace);
        if (!isNullOrUndefined(paragraphFormat.leftIndent)) {
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'left', this.wNamespace, this.roundToTwoDecimal(paragraphFormat.leftIndent * this.twipsInOnePoint).toString());
        }
        if (!isNullOrUndefined(paragraphFormat.rightIndent)) {
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'right', this.wNamespace, this.roundToTwoDecimal(paragraphFormat.rightIndent * this.twipsInOnePoint).toString());
        }
        if (!isNullOrUndefined(paragraphFormat.firstLineIndent)) {
            if (paragraphFormat.firstLineIndent < 0) {
                // tslint:disable-next-line:max-line-length
                writer.writeAttributeString(undefined, 'hanging', this.wNamespace, this.roundToTwoDecimal(-1 * paragraphFormat.firstLineIndent * this.twipsInOnePoint).toString());
            }
            else {
                // tslint:disable-next-line:max-line-length
                writer.writeAttributeString(undefined, 'firstLine', this.wNamespace, this.roundToTwoDecimal(paragraphFormat.firstLineIndent * this.twipsInOnePoint).toString());
            }
        }
        writer.writeEndElement();
    };
    // Serialize the styles (styles.xml)
    WordExport.prototype.serializeStyles = function () {
        var writer = new XmlWriter();
        writer.writeStartElement('w', 'styles', this.wNamespace);
        writer.writeAttributeString('xmlns', 'mc', undefined, this.veNamespace);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', 'w', undefined, this.wNamespace);
        writer.writeAttributeString('xmlns', 'w14', undefined, this.w14Namespace);
        writer.writeAttributeString('xmlns', 'w15', undefined, this.w15Namespace);
        writer.writeAttributeString('mc', 'Ignorable', undefined, 'w14 w15');
        //writes the document defaults, latent styles and default styles.
        this.serializeDefaultStyles(writer);
        //writes the document styles
        this.serializeDocumentStyles(writer);
        writer.writeEndElement(); //end of styles tag
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, this.stylePath);
        this.mArchive.addItem(zipArchiveItem); //this.stylePath, styleStream, false, FileAttributes.Archive);
    };
    // Serializes the default styles (document default paragraph and character format)
    WordExport.prototype.serializeDefaultStyles = function (writer) {
        writer.writeStartElement(undefined, 'docDefaults', this.wNamespace);
        //if (HasDefaultCharFormat())
        //{
        writer.writeStartElement(undefined, 'rPrDefault', this.wNamespace);
        // if (!isNullOrUndefined(this.mDocument.characterFormat)) {
        this.serializeCharacterFormat(writer, this.defCharacterFormat);
        writer.writeEndElement(); // end of rPrDefault
        // }
        // else {
        //     writer.writeStartElement(undefined, 'rPr', this.wNamespace);
        //     writer.writeStartElement(undefined, 'rFonts', this.wNamespace);
        //     if (!string.IsNullOrEmpty(m_document.StandardAsciiFont))
        //         writer.WriteAttributeString('ascii', this.wNamespace, m_document.StandardAsciiFont);
        //     if (!string.IsNullOrEmpty(m_document.StandardFarEastFont))
        //         writer.WriteAttributeString('eastAsia', this.wNamespace, m_document.StandardFarEastFont);
        //     if (!string.IsNullOrEmpty(m_document.StandardNonFarEastFont))
        //         writer.WriteAttributeString('hAnsi', this.wNamespace, m_document.StandardNonFarEastFont);
        //     if (!string.IsNullOrEmpty(m_document.StandardBidiFont))
        //         writer.WriteAttributeString('cs', this.wNamespace, m_document.StandardBidiFont);
        //     writer.WriteEndElement();
        //     float fontSize = GetDefFontSize(m_document, WCharacterFormat.FontSizeKey);
        //     if (fontSize !== 0f)
        //     {
        //         writer.WriteStartElement('sz', this.wNamespace);
        //         writer.WriteAttributeString('val', this.wNamespace, (fontSize * 2).ToString(CultureInfo.InvariantCulture));
        //         writer.WriteEndElement();
        //     }
        //     fontSize = GetDefFontSize(m_document, WCharacterFormat.FontSizeBidiKey);
        //     if (fontSize !== 0f)
        //     {
        //         writer.WriteStartElement('szCs', this.wNamespace);
        //         writer.WriteAttributeString('val', this.wNamespace, (fontSize * 2).ToString(CultureInfo.InvariantCulture));
        //         writer.WriteEndElement();
        //     }
        //     writer.WriteEndElement();
        // }
        // writer.WriteEndElement();
        // //}
        writer.writeStartElement(undefined, 'pPrDefault', this.wNamespace);
        if (!isNullOrUndefined(this.defParagraphFormat)) {
            writer.writeStartElement(undefined, 'pPr', this.wNamespace);
            this.serializeParagraphFormat(writer, this.defParagraphFormat, undefined);
            writer.writeEndElement(); //end of pPr
        }
        writer.writeEndElement(); //end of pPrDefault
        // writer.WriteEndElement();
        // SerializeLatentStyles();
        // //Default styles
        // if (m_document.Styles.length === 0 || isNullOrUndefined(m_document.Styles.FindByName('Normal')))
        // {
        //     SerializeDefaultParagraphStyle();
        // }
        // if (!IsDocumentContainsDefaultTableStyle())
        // {
        //     SerializeTableNormalStyle();
        // }
        // if (isNullOrUndefined(m_document.Styles.FindByName('No List')) && isNullOrUndefined(m_document.Styles.FindByName('NoList')))
        //     SerializeNoListStyle();
        // tslint:disable-next-line:max-line-length
        // if (isNullOrUndefined(m_document.Styles.FindByName('Table Grid')) && isNullOrUndefined(m_document.Styles.FindByName('TableGrid')))
        // {
        //     SerializeTableGridStyle();
        // }
        // }        
        writer.writeEndElement();
    };
    WordExport.prototype.serializeDocumentStyles = function (writer) {
        for (var i = 0; i < this.mStyles.length; i++) {
            var style = this.mStyles[i];
            writer.writeStartElement(undefined, 'style', this.wNamespace);
            var type = style.type === 'Paragraph' ? 'paragraph' : 'character';
            writer.writeAttributeString('w', 'type', this.wNamespace, type);
            writer.writeAttributeString('w', 'styleId', this.wNamespace, style.name);
            //name
            writer.writeStartElement(undefined, 'name', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, style.name);
            writer.writeEndElement();
            //basedOn
            if (!isNullOrUndefined(style.basedOn)) {
                writer.writeStartElement(undefined, 'basedOn', this.wNamespace);
                writer.writeAttributeString('w', 'val', this.wNamespace, style.basedOn);
                writer.writeEndElement();
            }
            //next
            if (!isNullOrUndefined(style.next)) {
                writer.writeStartElement(undefined, 'next', this.wNamespace);
                writer.writeAttributeString('w', 'val', this.wNamespace, style.next);
                writer.writeEndElement();
            }
            //link
            if (!isNullOrUndefined(style.link)) {
                writer.writeStartElement(undefined, 'link', this.wNamespace);
                writer.writeAttributeString('w', 'val', this.wNamespace, style.link);
                writer.writeEndElement();
            }
            if (style.type === 'Paragraph') {
                writer.writeStartElement(undefined, 'pPr', this.wNamespace);
                this.serializeParagraphFormat(writer, style.paragraphFormat, undefined);
                writer.writeEndElement();
            }
            // let value = (style.characterFormat as WCharacterFormat).newgetCharacterFormat();
            this.serializeCharacterFormat(writer, style.characterFormat);
            writer.writeEndElement(); //end of Style
        }
    };
    // Serializes the Character format
    WordExport.prototype.serializeCharacterFormat = function (writer, characterFormat) {
        writer.writeStartElement(undefined, 'rPr', this.wNamespace);
        if (!isNullOrUndefined(characterFormat.styleName)) {
            writer.writeStartElement(undefined, 'rStyle', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, characterFormat.styleName);
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.fontFamily)) {
            writer.writeStartElement(undefined, 'rFonts', this.wNamespace);
            writer.writeAttributeString(undefined, 'ascii', this.wNamespace, characterFormat.fontFamily);
            writer.writeAttributeString(undefined, 'hAnsi', this.wNamespace, characterFormat.fontFamily);
            writer.writeAttributeString(undefined, 'eastAsia', this.wNamespace, characterFormat.fontFamily);
            writer.writeAttributeString(undefined, 'cs', this.wNamespace, characterFormat.fontFamilyBidi);
            writer.writeEndElement(); //end         
        }
        if (!isNullOrUndefined(characterFormat.bold)) {
            this.serializeBoolProperty(writer, 'b', characterFormat.bold);
        }
        if (characterFormat.boldBidi) {
            this.serializeBoolProperty(writer, 'bCs', characterFormat.boldBidi);
        }
        if (!isNullOrUndefined(characterFormat.italic)) {
            this.serializeBoolProperty(writer, 'i', characterFormat.italic);
        }
        if (!isNullOrUndefined(characterFormat.italicBidi)) {
            this.serializeBoolProperty(writer, 'iCs', characterFormat.italicBidi);
        }
        if (characterFormat.bidi) {
            writer.writeStartElement(undefined, 'rtl', this.wNamespace);
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.strikethrough)) {
            switch (characterFormat.strikethrough) {
                case 'SingleStrike':
                    this.serializeBoolProperty(writer, 'strike', true);
                    break;
                case 'DoubleStrike':
                    this.serializeBoolProperty(writer, 'dstrike', true);
                    break;
                default:
                    this.serializeBoolProperty(writer, 'strike', false);
                    this.serializeBoolProperty(writer, 'dstrike', false);
                    break;
            }
        }
        if (!isNullOrUndefined(characterFormat.fontColor)) {
            writer.writeStartElement(undefined, 'color', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, this.getColor(characterFormat.fontColor));
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.fontSize)) {
            writer.writeStartElement(undefined, 'sz', this.wNamespace);
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString('w', 'val', this.wNamespace, this.roundToTwoDecimal(characterFormat.fontSize * 2).toString());
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.fontSizeBidi)) {
            writer.writeStartElement(undefined, 'szCs', this.wNamespace);
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString('w', 'val', this.wNamespace, this.roundToTwoDecimal(characterFormat.fontSizeBidi * 2).toString());
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.highlightColor) && characterFormat.highlightColor !== 'NoColor') {
            writer.writeStartElement(undefined, 'highlight', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, this.getHighlightColor(characterFormat.highlightColor));
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.underline) && characterFormat.underline !== 'None') {
            writer.writeStartElement(undefined, 'u', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, this.getUnderlineStyle(characterFormat.underline));
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.baselineAlignment)) {
            writer.writeStartElement(undefined, 'vertAlign', this.wNamespace);
            switch (characterFormat.baselineAlignment) {
                case 'Subscript':
                    writer.writeAttributeString('w', 'val', this.wNamespace, 'subscript');
                    break;
                case 'Superscript':
                    writer.writeAttributeString('w', 'val', this.wNamespace, 'superscript');
                    break;
                default:
                    writer.writeAttributeString('w', 'val', this.wNamespace, 'baseline');
                    break;
            }
            writer.writeEndElement();
        }
        writer.writeEndElement(); //end of rPrChange
    };
    WordExport.prototype.getColor = function (color) {
        if (color.length > 0) {
            if (color[0] === '#') {
                color = color.substr(1);
            }
            if (color.length > 6) {
                color = color.substr(0, 6);
            }
        }
        return color;
    };
    // Get the underline style as string
    WordExport.prototype.getUnderlineStyle = function (underlineStyle) {
        switch (underlineStyle) {
            case 'DotDotDashHeavy':
                return 'dashDotDotHeavy';
            case 'DotDashHeavy':
                return 'dashDotHeavy';
            case 'DashHeavy':
                return 'dashedHeavy';
            case 'DashLong':
                return 'dashLong';
            case 'DashLongHeavy':
                return 'dashLongHeavy';
            case 'DotDash':
                return 'dotDash';
            case 'DotDotDash':
                return 'dotDotDash';
            case 'Dotted':
                return 'dotted';
            case 'DottedHeavy':
                return 'dottedHeavy';
            case 'Double':
                return 'double';
            case 'Single':
                return 'single';
            case 'Thick':
                return 'thick';
            case 'Wavy':
                return 'wave';
            case 'WavyDouble':
                return 'wavyDouble';
            case 'WavyHeavy':
                return 'wavyHeavy';
            case 'Words':
                return 'words';
            default:
                return 'dash';
        }
    };
    WordExport.prototype.getHighlightColor = function (highlight) {
        switch (highlight) {
            // Highlights the content with bright green (#ff00ff00) color.
            case 'BrightGreen':
                return 'green';
            // Highlights the content with turquoise (#ff00ffff) color.
            case 'Turquoise':
                return 'cyan';
            // Highlights the content with pink (#ffff00ff) color.
            case 'Pink':
                return 'magenta';
            // Highlights the content with blue (#ff0000ff) color.
            case 'Blue':
                return 'blue';
            // Highlights the content with red (#ffff0000) color.
            case 'Red':
                return 'red';
            // Highlights the content with dark blue (#ff000080) color.
            case 'DarkBlue':
                return 'darkBlue';
            // Highlights the content with teal (#ff008080) color.
            case 'Teal':
                return 'darkCyan';
            // Highlights the content with green (#ff008000) color.
            case 'Green':
                return 'darkGreen';
            // Highlights the content with violet (#ff800080) color.
            case 'Violet':
                return 'darkMagenta';
            // Highlights the content with dark red (#ff800000) color.
            case 'DarkRed':
                return 'darkRed';
            // Highlights the content with dark yellow (#ff808000)  color.
            case 'DarkYellow':
                return 'darkYellow';
            // Highlights the content with gray 50 (#ff808080) color.
            case 'Gray50':
                return 'darkGray';
            // Highlights the content with gray 25 (#ffc0c0c0) color.
            case 'Gray25':
                return 'lightGray';
            // Highlights the content with black (#ff000000) color.
            case 'Black':
                return 'black';
            // Highlights the content with yellow (#ffffff00) color.
            default:
                return 'yellow';
        }
    };
    /*private toggleFirstCahar(text: string) {
        return text.charAt(0).toLowerCase() + text.slice(1);
    }*/
    // Serializes the bool character format property
    WordExport.prototype.serializeBoolProperty = function (writer, tag, value) {
        writer.writeStartElement(undefined, tag, this.wNamespace);
        if (!value) {
            writer.writeAttributeString(undefined, 'val', this.wNamespace, '0');
        }
        writer.writeEndElement();
    };
    // Serialize the list styles and numberings (numberings.xml)
    WordExport.prototype.serializeNumberings = function () {
        if (this.document.lists.length === 0) {
            return;
        }
        var writer = new XmlWriter();
        writer.writeStartElement('w', 'numbering', this.wNamespace);
        this.writeCommonAttributeStrings(writer);
        // this.serializePictureBullets(writer, this.mDocument.lists);
        this.serializeAbstractListStyles(writer, this.document.abstractLists);
        this.serializeListInstances(writer, this.document.lists);
        // SerializeListOverrides(writer, this.mDocument.ridesm_document.ListOverrides);
        writer.writeEndElement();
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, this.numberingPath);
        this.mArchive.addItem(zipArchiveItem);
    };
    // Serializes the abstract list styles
    WordExport.prototype.serializeAbstractListStyles = function (writer, listStyles) {
        for (var i = 0; i < listStyles.length; i++) {
            var abstractList = listStyles[i];
            writer.writeStartElement(undefined, 'abstractNum', this.wNamespace);
            writer.writeAttributeString(undefined, 'abstractNumId', this.wNamespace, abstractList.abstractListId.toString());
            writer.writeStartElement(undefined, 'nsid', this.wNamespace);
            writer.writeAttributeString(undefined, 'val', this.wNamespace, this.generateHex());
            writer.writeEndElement();
            for (var ilvl = 0, cnt = abstractList.levels.length; ilvl < cnt; ilvl++) {
                this.serializeListLevel(writer, abstractList.levels[ilvl], ilvl);
            }
            writer.writeEndElement(); //end of abstractNum
        }
    };
    // Serializes the list styles
    WordExport.prototype.serializeListInstances = function (writer, listStyles) {
        for (var i = 0; i < listStyles.length; i++) {
            var list = listStyles[i];
            writer.writeStartElement(undefined, 'num', this.wNamespace);
            writer.writeAttributeString(undefined, 'numId', this.wNamespace, (list.listId + 1).toString());
            writer.writeStartElement(undefined, 'abstractNumId', this.wNamespace);
            writer.writeAttributeString(undefined, 'val', this.wNamespace, list.abstractListId.toString());
            writer.writeEndElement();
            writer.writeEndElement();
        }
    };
    WordExport.prototype.generateHex = function () {
        return (Math.floor(Math.random() * (4000000000 - 270000000)) + 270000000).toString(16).toUpperCase();
    };
    WordExport.prototype.roundToTwoDecimal = function (num) {
        return Math.round(num); // * 100) / 100;
    };
    // Serialize the list level
    WordExport.prototype.serializeListLevel = function (writer, listLevel, levelIndex) {
        writer.writeStartElement(undefined, 'lvl', this.wNamespace);
        writer.writeAttributeString(undefined, 'ilvl', this.wNamespace, levelIndex.toString());
        writer.writeStartElement(undefined, 'start', this.wNamespace);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, listLevel.startAt.toString());
        writer.writeEndElement();
        writer.writeStartElement(undefined, 'numFmt', this.wNamespace);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, this.getLevelPattern(listLevel.listLevelPattern));
        writer.writeEndElement();
        // if (listLevel.restartLevel > 0) {
        //     writer.writeStartElement(undefined, 'lvlRestart', this.wNamespace);
        //     writer.writeAttributeString(undefined, 'val', this.wNamespace, '0');
        //     writer.writeEndElement();
        // }
        // if (!isNullOrUndefined(listLevel.paragraphFormat)) {
        //     string name = listLevel.ParaStyleName.Substring(0, 1).ToUpper() + listLevel.ParaStyleName.Remove(0, 1);
        //     writer.WriteStartElement('pStyle', this.wNamespace);
        //     writer.WriteAttributeString('val', this.wNamespace, name);
        //     writer.WriteEndElement();
        // }
        // if (listLevel.IsLegalStyleNumbering) {
        //     writer.WriteStartElement('isLgl', this.wNamespace);
        //     writer.WriteEndElement();
        // }
        this.serializeLevelFollow(writer, listLevel);
        this.serializeLevelText(writer, listLevel, levelIndex + 1);
        // SerializeLegacyProperties(listLevel);
        // if (listLevel.PicBulletId > 0) {
        //     writer.WriteStartElement('lvlPicBulletId', this.wNamespace);
        //     writer.WriteAttributeString('val', this.wNamespace, listLevel.PicBulletId.ToString());
        //     writer.WriteEndElement();
        // }
        // //lvlJc
        // if (listLevel.NumberAlignment !== ListNumberAlignment.Left) {
        //     writer.WriteStartElement('lvlJc', this.wNamespace);
        //     string alignment = string.Empty;
        //     if (listLevel.NumberAlignment === ListNumberAlignment.Right) {
        //         alignment = 'right';
        //     }
        //     else {
        //         alignment = 'center';
        //     }
        //     writer.WriteAttributeString('val', this.wNamespace, alignment);
        //     writer.WriteEndElement();
        // }
        writer.writeStartElement(undefined, 'pPr', this.wNamespace);
        this.serializeParagraphFormat(writer, listLevel.paragraphFormat, undefined);
        writer.writeEndElement(); //end of pPr
        this.serializeCharacterFormat(writer, listLevel.characterFormat);
        writer.writeEndElement();
    };
    WordExport.prototype.getLevelPattern = function (levelPattern) {
        var patternType;
        switch (levelPattern) {
            case 'Arabic':
                patternType = 'decimal';
                break;
            case 'UpRoman':
                patternType = 'upperRoman';
                break;
            case 'LowRoman':
                patternType = 'lowerRoman';
                break;
            case 'UpLetter':
                patternType = 'upperLetter';
                break;
            case 'LowLetter':
                patternType = 'lowerLetter';
                break;
            // case 'Ordinal':
            //     patternType = 'ordinal';
            //     break;
            // case 'Number':
            //     patternType = 'cardinalText';
            //     break;
            // case 'OrdinalText':
            //     patternType = 'ordinalText';
            //     break;
            // case 'LeadingZero':
            //     patternType = 'decimalZero';
            //     break;
            // case 'Bullet':
            default:
                patternType = 'bullet';
                break;
            // case 'FarEast':
            //     patternType = 'aiueoFullWidth';
            //     break;
            // case 'Special':
            //     patternType = 'russianLower';
            //     break;
            // case 'None':
            //     patternType = 'none';
            //     break;
        }
        return patternType;
    };
    // Serializes the level text
    WordExport.prototype.serializeLevelText = function (writer, listLevel, lvlIndex) {
        writer.writeStartElement(undefined, 'lvlText', this.wNamespace);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, (listLevel.numberFormat));
        writer.writeEndElement();
    };
    // Serialize the level follow character
    WordExport.prototype.serializeLevelFollow = function (writer, listLevel) {
        var fc;
        //TODO:Type issue returns number instead of string
        if (listLevel.followCharacter === 'Tab') {
            fc = 'tab';
        }
        else if (listLevel.followCharacter === 'Space') {
            fc = 'space';
        }
        else {
            fc = 'nothing';
        }
        writer.writeStartElement(undefined, 'suff', this.wNamespace);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, fc);
        writer.writeEndElement();
    };
    WordExport.prototype.serializeDocumentProtectionSettings = function (writer) {
        writer.writeStartElement('w', 'documentProtection', this.wNamespace);
        if (this.formatting) {
            writer.writeAttributeString('w', 'formatting', this.wNamespace, '1');
        }
        if (this.protectionType && this.protectionType === 'ReadOnly') {
            writer.writeAttributeString('w', 'edit', this.wNamespace, 'readOnly');
        }
        writer.writeAttributeString('w', 'cryptProviderType', this.wNamespace, 'rsaAES');
        writer.writeAttributeString('w', 'cryptAlgorithmClass', this.wNamespace, 'hash');
        writer.writeAttributeString('w', 'cryptAlgorithmType', this.wNamespace, 'typeAny');
        writer.writeAttributeString('w', 'cryptAlgorithmSid', this.wNamespace, '14');
        writer.writeAttributeString('w', 'cryptSpinCount', this.wNamespace, '100000');
        if (this.enforcement) {
            writer.writeAttributeString('w', 'enforcement', this.wNamespace, '1');
        }
        if (this.hashValue) {
            writer.writeAttributeString('w', 'hash', this.wNamespace, this.hashValue);
        }
        if (this.saltValue) {
            writer.writeAttributeString('w', 'salt', this.wNamespace, this.saltValue);
        }
        writer.writeEndElement();
    };
    WordExport.prototype.serializeSettings = function () {
        var writer = new XmlWriter();
        writer.writeStartElement('w', 'settings', this.wNamespace);
        this.writeCustom(writer);
        // writer.writeAttributeString('xmlns', 'mc', undefined, this.veNamespace);
        // writer.writeAttributeString('xmlns', 'o', undefined, this.oNamespace);
        // writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        // writer.writeAttributeString('xmlns', 'm', undefined, this.mNamespace);
        // writer.writeAttributeString('xmlns', 'v', undefined, this.vNamespace);
        writer.writeAttributeString('xmlns', 'w10', undefined, this.w10Namespace);
        writer.writeAttributeString('xmlns', 'w14', undefined, this.w14Namespace);
        writer.writeAttributeString('xmlns', 'w15', undefined, this.w15Namespace);
        writer.writeAttributeString('xmlns', 'sl', undefined, this.slNamespace);
        writer.writeAttributeString('mc', 'Ignorable', undefined, 'w14 w15');
        // //w:writeProtection - Write Protection
        this.serializeDocumentProtectionSettings(writer);
        //w:view - Document View Setting
        // if (this.mDocument.ViewSetup.DocumentViewType !== DocumentViewType.PrintLayout &&
        //   m_document.ViewSetup.DocumentViewType !== DocumentViewType.NormalLayout)
        // {
        //     writer.writeStartElement('view', this.wNamespace);
        //     string viewTypeStr = string.Empty;
        //     if (m_document.ViewSetup.DocumentViewType === DocumentViewType.OutlineLayout)
        //     {
        //         viewTypeStr = 'outline';
        //     }
        //     else if (m_document.ViewSetup.DocumentViewType === DocumentViewType.WebLayout)
        //     {
        //         viewTypeStr = 'web';
        //     }
        //     writer.writeAttributeString('val', this.wNamespace, viewTypeStr);
        //     writer.writeEndElement();
        // }
        //w:zoom - Magnification Setting
        writer.writeStartElement('w', 'zoom', this.wNamespace);
        // switch (m_document.ViewSetup.ZoomType)
        // {
        //     case ZoomType.FullPage:
        //         writer.writeAttributeString('w', 'val', this.wNamespace, 'fullPage');
        //         break;
        //     case ZoomType.PageWidth:
        //         writer.writeAttributeString('w', 'val', this.wNamespace, 'bestFit');
        //         break;
        //     case ZoomType.TextFit:
        //         writer.writeAttributeString('w', 'val', this.wNamespace, 'textFit');
        //         break;
        // default:
        writer.writeAttributeString('w', 'val', this.wNamespace, 'none');
        // break;
        // }
        writer.writeAttributeString('w', 'percent', this.wNamespace, '100');
        writer.writeEndElement();
        //w:displayBackgroundShape - Display Background Objects When Displaying Document
        // if (m_document.Background.Type !== BackgroundType.NoBackground)
        // {
        writer.writeStartElement(undefined, 'displayBackgroundShape', this.wNamespace);
        writer.writeEndElement();
        // }
        //w:defaultTabStop - Distance Between Automatic Tab Stops
        writer.writeStartElement(undefined, 'defaultTabStop', this.wNamespace);
        var tabWidth = Math.round(this.defaultTabWidthValue * this.twipsInOnePoint);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, tabWidth.toString());
        writer.writeEndElement();
        //w:evenAndOddHeaders - Different Even/Odd Page Headers and Footers        
        if (this.mDifferentFirstPage) {
            writer.writeStartElement(undefined, 'evenAndOddHeaders', this.wNamespace);
            writer.writeEndElement();
        }
        //w:footnotePr - Document-Wide Footnote Properties and w:endnotePr - Document-Wide Endnote Properties
        // SerializeFootnoteSettings();
        //w:compat - Compatibility Settings
        writer.writeStartElement(undefined, 'compat', this.wNamespace);
        writer.writeStartElement(undefined, 'compatSetting', this.wNamespace);
        writer.writeAttributeString(undefined, 'name', this.wNamespace, 'compatibilityMode');
        writer.writeAttributeString(undefined, 'uri', this.wNamespace, 'http://schemas.microsoft.com/office/word');
        writer.writeAttributeString(undefined, 'val', this.wNamespace, '15');
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, this.settingsPath);
        this.mArchive.addItem(zipArchiveItem);
    };
    WordExport.prototype.serializeCoreProperties = function () {
        //implementation
    };
    WordExport.prototype.serializeAppProperties = function () {
        //implementation
    };
    WordExport.prototype.serializeFontTable = function (contentType) {
        //implementation
    };
    WordExport.prototype.serializeSettingsRelation = function () {
        //implementation
    };
    WordExport.prototype.serializeHeaderFooters = function () {
        this.serializeHeaderFooter('EvenFooter');
        this.serializeHeaderFooter('EvenHeader');
        this.serializeHeaderFooter('FirstPageFooter');
        this.serializeHeaderFooter('FirstPageHeader');
        this.serializeHeaderFooter('OddFooter');
        this.serializeHeaderFooter('OddHeader');
    };
    // Serializes the Header/Footer
    WordExport.prototype.serializeHeaderFooter = function (hfType) {
        if (this.headersFooters.length === 0) {
            return;
        }
        var headerFooterPath;
        var headerFooterRelsPath;
        if (!this.headersFooters.containsKey(hfType)) {
            return;
        }
        var hfColl = this.headersFooters.get(hfType);
        var hf = undefined;
        for (var i = 0; i < hfColl.keys.length; i++) {
            var id = hfColl.keys[i];
            hf = hfColl.get(id);
            if (hfType === 'EvenHeader' || hfType === 'FirstPageHeader' ||
                hfType === 'OddHeader') {
                headerFooterPath = this.headerPath + id.replace('rId', '') + '.xml';
                headerFooterRelsPath = this.headerRelationPath + id.replace('rId', '') + '.xml.rels';
                this.serializeHeader(hf, id, headerFooterPath, headerFooterRelsPath);
            }
            else {
                headerFooterPath = this.footerPath + id.replace('rId', '') + '.xml';
                headerFooterRelsPath = this.footerRelationPath + id.replace('rId', '') + '.xml.rels';
                this.serializeFooter(hf, id, headerFooterPath, headerFooterRelsPath);
            }
        }
    };
    // Serialize the header part
    WordExport.prototype.serializeHeader = function (header, id, headerFooterPath, headerFooterRelsPath) {
        this.headerFooter = header;
        var writer = new XmlWriter();
        writer.writeStartElement('w', 'hdr', this.wNamespace);
        this.writeHFCommonAttributes(writer);
        var owner = this.blockOwner;
        this.blockOwner = header;
        this.serializeBodyItems(writer, header.blocks, true);
        this.blockOwner = owner;
        writer.writeEndElement();
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, headerFooterPath);
        this.mArchive.addItem(zipArchiveItem);
        this.serializeHFRelations(id, headerFooterRelsPath);
        this.headerFooter = undefined;
    };
    // Serializes the HeaderFooter relations
    WordExport.prototype.serializeHFRelations = function (hfId, headerFooterRelsPath) {
        var hasHFImage = this.headerFooterImages.containsKey(hfId);
        // let hasHFHyperlinks = HeaderFooterHyperlinks.ContainsKey(hfId);
        // let hasHFInclPics = HeaderFooterInclPicUrls.ContainsKey(hfId);
        // let hasHFAlternateChunks = HeaderFooterAlternateChunks.ContainsKey(hfId);
        if (hasHFImage) { // || hasHFHyperlinks ||hasHFAlternateChunks
            var writer = new XmlWriter();
            writer.writeStartElement(undefined, 'Relationships', this.rpNamespace);
            this.serializeImagesRelations(this.headerFooterImages.get(hfId), writer);
            // if (hasHFHyperlinks)
            //     SerializeHyperlinkRelations(stream, HeaderFooterHyperlinks[hfId]);
            // if (hasHFAlternateChunks)
            //     SerializeAltChunkRelations(stream, HeaderFooterAlternateChunks[hfId]);
            // if (hasHFInclPics)
            //     SerializeIncludePictureUrlRelations(stream, HeaderFooterInclPicUrls[hfId]);
            // if (HFOleContainers.ContainsKey(hfId))
            // {
            //     AddOLEToZip(HFOleContainers[hfId]);
            // }
            // if (HFRelations.ContainsKey(hfId))
            //     SerializeHFCommonRelations(stream, HFRelations[hfId]);
            writer.writeEndElement();
            var zipArchiveItem = new ZipArchiveItem(writer.buffer, headerFooterRelsPath);
            this.mArchive.addItem(zipArchiveItem);
        }
        else {
            return;
        }
    };
    WordExport.prototype.writeHFCommonAttributes = function (writer) {
        writer.writeAttributeString('xmlns', 'v', undefined, this.vNamespace);
        writer.writeAttributeString('xmlns', 'w10', undefined, this.w10Namespace);
        writer.writeAttributeString('xmlns', 'o', undefined, this.oNamespace);
        writer.writeAttributeString('xmlns', 've', undefined, this.veNamespace);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', 'm', undefined, this.mNamespace);
        writer.writeAttributeString('xmlns', 'wne', undefined, this.wneNamespace);
        writer.writeAttributeString('xmlns', 'a', undefined, this.aNamespace);
        writer.writeAttributeString('xmlns', 'pic', undefined, this.pictureNamespace);
        writer.writeAttributeString('xmlns', 'wp', undefined, this.wpNamespace);
        writer.writeAttributeString('xmlns', 'wpc', undefined, this.wpCanvasNamespace);
        writer.writeAttributeString('xmlns', 'wp14', undefined, this.wpDrawingNamespace);
        this.writeDup(writer);
        writer.writeAttributeString('xmlns', 'wps', undefined, this.wpShapeNamespace);
        writer.writeAttributeString('ve', 'Ignorable', undefined, 'w14 w15 wp14');
    };
    // Serailize the footer and its relations
    WordExport.prototype.serializeFooter = function (footer, id, headerFooterPath, headerFooterRelsPath) {
        this.headerFooter = footer;
        var writer = new XmlWriter();
        writer.writeStartElement('w', 'ftr', this.wNamespace);
        this.writeHFCommonAttributes(writer);
        this.serializeBodyItems(writer, footer.blocks, true);
        writer.writeEndElement();
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, headerFooterPath);
        this.mArchive.addItem(zipArchiveItem);
        this.serializeHFRelations(id, headerFooterRelsPath);
    };
    WordExport.prototype.serializeDocumentRelations = function () {
        var writer = new XmlWriter();
        writer.writeStartElement(undefined, 'Relationships', this.rpNamespace);
        this.serializeRelationShip(writer, this.getNextRelationShipID(), this.stylesRelType, 'styles.xml');
        this.serializeRelationShip(writer, this.getNextRelationShipID(), this.settingsRelType, 'settings.xml');
        if (this.mComments.length > 0) {
            this.serializeRelationShip(writer, this.getNextRelationShipID(), this.commentsRelType, 'comments.xml');
            this.serializeRelationShip(writer, this.getNextRelationShipID(), this.commentsExRelType, 'commentsExtended.xml');
        }
        // this.serializeRelationShip(writer, this.getNextRelationShipID(), this.ThemeRelType, 'theme/theme1.xml');
        if (this.document.lists.length > 0) {
            this.serializeRelationShip(writer, this.getNextRelationShipID(), this.numberingRelType, 'numbering.xml');
        }
        this.serializeHeaderFooterRelations(writer);
        // if (HasFontTable) {
        //     SerializeRelationShip(docRelstream, GetNextRelationShipID(), this.FontTableRelType, 'fontTable.xml');
        // }
        // SerializeIncludePictureUrlRelations(docRelstream, InclPicFieldUrl);
        // //// Creating relationships for every hyperlink and image containing in the document
        this.serializeImagesRelations(this.documentImages, writer);
        // serialize chart relations
        this.serializeChartDocumentRelations(this.documentCharts, writer);
        // SerializeSvgImageRelation();
        //this.serializeExternalLinkImages(writer);
        // if (HasHyperlink && HyperlinkTargets.length > 0) {
        //     SerializeHyperlinkRelations(docRelstream, HyperlinkTargets);
        // }
        // if (m_document.HasMacros
        //     && IsMacroEnabled)
        //     SerializeRelationShip(docRelstream, GetNextRelationShipID(), this.VbaProjectRelType, this.VbaProject);
        writer.writeEndElement();
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, this.wordRelationPath);
        this.mArchive.addItem(zipArchiveItem);
        this.headerFooter = undefined;
    };
    // serialize chart relations
    WordExport.prototype.serializeChartDocumentRelations = function (charts, writer) {
        if (charts.length > 0) {
            var keys = charts.keys;
            for (var i = 1; i <= keys.length; i++) {
                this.serializeRelationShip(writer, keys[i - 1], this.chartRelType, 'charts/chart' + i + '.xml');
            }
        }
    };
    WordExport.prototype.serializeChartRelations = function () {
        var writer = new XmlWriter();
        this.resetChartRelationShipId();
        writer.writeStartElement(undefined, 'Relationships', this.rpNamespace);
        var chartColorPath = 'colors' + this.chartCount + '.xml';
        var chartRelationPath = this.chartPath + '/_rels/chart' + this.chartCount + '.xml.rels';
        var chartExcelPath = '../embeddings/Microsoft_Excel_Worksheet' + this.chartCount + '.xlsx';
        // tslint:disable-next-line:max-line-length
        this.serializeRelationShip(writer, this.getNextChartRelationShipID(), this.packageRelType, chartExcelPath);
        this.serializeRelationShip(writer, this.getNextChartRelationShipID(), this.chartColorStyleRelType, chartColorPath);
        writer.writeEndElement(); // end of relationships
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, chartRelationPath);
        this.mArchive.addItem(zipArchiveItem);
    };
    // Serializes the image relations
    WordExport.prototype.serializeImagesRelations = function (images, writer) {
        if (images.length > 0) {
            var imagePath = '';
            var base64ImageString = void 0;
            var keys = images.keys;
            for (var i = 0; i < keys.length; i++) {
                var mImage = images.get(keys[i]);
                base64ImageString = mImage.imageString;
                if (isNullOrUndefined(base64ImageString)) {
                    imagePath = this.imagePath + '/0.jpeg';
                    this.serializeRelationShip(writer, keys[i], this.imageRelType, imagePath.replace('word/', ''));
                }
                else {
                    var imageInfo = HelperMethods.formatClippedString(base64ImageString);
                    var extension = imageInfo.extension;
                    var formatClippedString = imageInfo.formatClippedString;
                    imagePath = this.imagePath + keys[i] + extension;
                    this.serializeRelationShip(writer, keys[i], this.imageRelType, imagePath.replace('word/', ''));
                    //if (m_archive.Find(imagePath.Replace('\\', '/')) === -1)
                    // {
                    var imageBlob = new Blob([this.encodedString(formatClippedString)]);
                    var zipArchiveItem = new ZipArchiveItem(imageBlob, imagePath);
                    // let TestArchive = new ZipArchive();
                    this.mArchive.addItem(zipArchiveItem);
                    // TestArchive.save('image.zip').then(function (): void {
                    //     TestArchive.destroy();
                    // });
                    // }
                }
            }
        }
    };
    /**
     * @private
     */
    WordExport.prototype.encodedString = function (input) {
        var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        var chr1;
        var chr2;
        var chr3;
        var encode1;
        var encode2;
        var encode3;
        var encode4;
        var count = 0;
        var resultIndex = 0;
        /*let dataUrlPrefix: string = 'data:';*/
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
        var totalLength = input.length * 3 / 4;
        if (input.charAt(input.length - 1) === keyStr.charAt(64)) {
            totalLength--;
        }
        if (input.charAt(input.length - 2) === keyStr.charAt(64)) {
            totalLength--;
        }
        if (totalLength % 1 !== 0) {
            // totalLength is not an integer, the length does not match a valid
            // base64 content. That can happen if:
            // - the input is not a base64 content
            // - the input is *almost* a base64 content, with a extra chars at the
            // beginning or at the end
            // - the input uses a base64 variant (base64url for example)
            throw new Error('Invalid base64 input, bad content length.');
        }
        var output = new Uint8Array(totalLength | 0);
        while (count < input.length) {
            encode1 = keyStr.indexOf(input.charAt(count++));
            encode2 = keyStr.indexOf(input.charAt(count++));
            encode3 = keyStr.indexOf(input.charAt(count++));
            encode4 = keyStr.indexOf(input.charAt(count++));
            chr1 = (encode1 << 2) | (encode2 >> 4);
            chr2 = ((encode2 & 15) << 4) | (encode3 >> 2);
            chr3 = ((encode3 & 3) << 6) | encode4;
            output[resultIndex++] = chr1;
            if (encode3 !== 64) {
                output[resultIndex++] = chr2;
            }
            if (encode4 !== 64) {
                output[resultIndex++] = chr3;
            }
        }
        return output;
    };
    WordExport.prototype.serializeExternalLinkImages = function (writer) {
        var keys = this.externalImages.keys;
        for (var i = 0; i < this.externalImages.keys.length; i++) {
            this.serializeRelationShip(writer, keys[i], this.imageRelType, this.externalImages.get(keys[i]));
        }
    };
    // Serializes the HeaderFooters relations to the document relations stream
    WordExport.prototype.serializeHeaderFooterRelations = function (writer) {
        this.serializeHFRelation(writer, 'EvenFooter');
        this.serializeHFRelation(writer, 'EvenHeader');
        this.serializeHFRelation(writer, 'FirstPageFooter');
        this.serializeHFRelation(writer, 'FirstPageHeader');
        this.serializeHFRelation(writer, 'OddFooter');
        this.serializeHFRelation(writer, 'OddHeader');
    };
    // Serializes the headers footers relations.
    WordExport.prototype.serializeHFRelation = function (writer, hfType) {
        var headerFooterPath = '';
        var relType;
        if (!this.headersFooters.containsKey(hfType)) {
            return;
        }
        var hfColl = this.headersFooters.get(hfType);
        for (var i = 0; i < hfColl.keys.length; i++) {
            var id = hfColl.keys[i];
            if (hfType === 'EvenHeader' || hfType === 'FirstPageHeader' ||
                hfType === 'OddHeader') {
                headerFooterPath = 'header' + id.replace('rId', '') + '.xml';
                relType = this.headerRelType;
            }
            else {
                headerFooterPath = 'footer' + id.replace('rId', '') + '.xml';
                relType = this.footerRelType;
            }
            this.serializeRelationShip(writer, id, relType, headerFooterPath);
        }
    };
    // Serializes the relationship
    WordExport.prototype.serializeRelationShip = function (writer, relationshipID, relationshipType, targetPath) {
        writer.writeStartElement(undefined, 'Relationship', undefined);
        writer.writeAttributeString(undefined, 'Id', undefined, relationshipID);
        writer.writeAttributeString(undefined, 'Type', undefined, relationshipType);
        writer.writeAttributeString(undefined, 'Target', undefined, targetPath.replace('\\', '/').replace('\v', ''));
        // tslint:disable-next-line:max-line-length
        if (relationshipType === this.hyperlinkRelType || this.startsWith(targetPath, 'http://') || this.startsWith(targetPath, 'https://') || this.startsWith(targetPath, 'file:///')) {
            // Uri targetUri;
            // if ((!targetPath.StartsWith('file:///')) && Uri.TryCreate(targetPath, UriKind.Absolute, out targetUri))
            // {
            //     //Handled using Try catch to avoid exception if the Host name type is None because in 
            //Silverlight 'HostNameType' property is not available.
            //     try
            //     {
            //         m_writer.WriteAttributeString('Target', targetUri.AbsoluteUri);
            //     }
            //     catch
            //     {
            //         m_writer.WriteAttributeString('Target', targetPath.Replace('\\', '/').Replace(ControlChar.LineBreak, string.Empty));
            //     }
            // }
            // else
            // {
            //     m_writer.WriteAttributeString('Target', targetPath.Replace('\\', '/').Replace(ControlChar.LineBreak, string.Empty));
            // }
            writer.writeAttributeString(undefined, 'TargetMode', undefined, 'External');
        }
        writer.writeEndElement();
    };
    // Get the next relationship ID
    WordExport.prototype.getNextRelationShipID = function () {
        return 'rId' + (++this.mRelationShipID);
    };
    WordExport.prototype.serializeGeneralRelations = function () {
        var writer = new XmlWriter();
        this.resetRelationShipID();
        writer.writeStartElement(undefined, 'Relationships', this.rpNamespace);
        this.serializeRelationShip(writer, this.getNextRelationShipID(), this.documentRelType, this.documentPath);
        // this.serializeRelationShip(writer, this.getNextRelationShipID(), this.AppRelType, this.appPath);
        // this.serializeRelationShip(writer, this.getNextRelationShipID(), this.CoreRelType, this.corePath);
        //End of Relationships tag
        writer.writeEndElement();
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, this.generalRelationPath);
        this.mArchive.addItem(zipArchiveItem);
    };
    WordExport.prototype.serializeContentTypes = function (contentType) {
        var writer = new XmlWriter();
        writer.writeStartElement(undefined, 'Types', 'http://schemas.openxmlformats.org/package/2006/content-types');
        //if (m_hasOleObject)
        //{
        //    //<Default Extension='bin' ContentType='application/vnd.openxmlformats-officedocument.oleObject'/>
        //    SerializeDefaultContentType(contentStream, 'bin', 'application/vnd.openxmlformats-officedocument.oleObject');
        //}
        this.serializeDefaultContentType(writer, 'rels', this.relationContentType);
        this.serializeDefaultContentType(writer, 'xml', this.xmlContentType);
        // if (m_hasEmbedFonts && !string.IsNullOrEmpty(type))
        // {
        //     SerializeDefaultContentType(contentStream,type, this.fontContentType);
        // }
        if (this.documentImages.length > 0 || this.externalImages.length > 0 || this.headerFooterImages.length > 0) {
            this.serializeDefaultContentType(writer, 'png', 'image/png');
            this.serializeDefaultContentType(writer, 'bmp', 'image/bmp');
            this.serializeDefaultContentType(writer, 'emf', 'image/x-emf');
            this.serializeDefaultContentType(writer, 'wmf', 'image/x-wmf');
            this.serializeDefaultContentType(writer, 'gif', 'image/gif');
            this.serializeDefaultContentType(writer, 'ico', 'image/x-icon');
            this.serializeDefaultContentType(writer, 'tif', 'image/tiff');
            this.serializeDefaultContentType(writer, 'tiff', 'image/tiff');
            this.serializeDefaultContentType(writer, 'jpeg', 'image/jpeg');
            this.serializeDefaultContentType(writer, 'jpg', 'image/jpeg');
            this.serializeDefaultContentType(writer, 'svg', 'image/svg+xml');
        }
        // if (m_document.HasMacros
        //     && IsMacroEnabled && !m_isSkipBinExtension)
        // {
        //     SerializeDefaultContentType(contentStream, 'bin', this.VbaProjectContentType);
        //     m_isSkipBinExtension = true;
        // }
        // if (m_hasOleObject)
        // {
        //     SerializeOleContentType(contentStream);
        // }
        //document.xml
        this.serializeOverrideContentType(writer, this.documentPath, this.documentContentType);
        // tslint:disable-next-line:max-line-length
        //<Override PartName='/word/numbering.xml' ContentType='application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml'/>
        // if (HasNumbering) {
        this.serializeOverrideContentType(writer, this.numberingPath, this.numberingContentType);
        // }
        //Add the header/footer Alternate chunks
        // if (HeaderFooterAlternateChunks.length > 0) {
        //     foreach(Dictionary < string, string > item in m_headerFooterAlternateChunks.Values)
        //     AddAlternateChunkItem(item);
        // }
        //styles.xml
        this.serializeOverrideContentType(writer, this.stylePath, this.stylesContentType);
        //settings.xml
        this.serializeOverrideContentType(writer, this.settingsPath, this.settingsContentType);
        this.serializeOverrideContentType(writer, this.commentsPath, this.commentsContentType);
        //comments.xml
        this.serializeOverrideContentType(writer, this.commentsExtendedPath, this.commentsExContentType);
        //charts.xml
        if (this.chartCount > 0) {
            var count = 1;
            this.serializeDefaultContentType(writer, 'xlsx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
            while (count <= this.chartCount) {
                this.serializeOverrideContentType(writer, 'word/charts/chart' + count + '.xml', this.chartsContentType);
                this.serializeOverrideContentType(writer, 'word/charts/colors' + count + '.xml', this.chartColorStyleContentType);
                count++;
            }
        }
        //             //core.xml
        //             SerializeOverrideContentType(contentStream, this.corePath, this.CoreContentType);
        //             //app.xml
        //             SerializeOverrideContentType(contentStream, this.appPath, this.AppContentType);
        //             //custom.xml
        //             if (!isNullOrUndefined(m_document.CustomDocumentProperties) && m_document.CustomDocumentProperties.length > 0)
        //                 SerializeOverrideContentType(contentStream, this.CustomPath, this.CustomContentType);
        // #if Chart
        //             if (m_hasChart)
        //                 SerializeChartContentType(contentStream);
        // #endif
        this.serializeHFContentTypes(writer);
        // WriteXmlItemsContentTypes(contentStream);
        //End of Types tag
        writer.writeEndElement();
        var zipArchiveItem = new ZipArchiveItem(writer.buffer, this.contentTypesPath);
        this.mArchive.addItem(zipArchiveItem);
    };
    // Serializes the HeaderFooter content types
    WordExport.prototype.serializeHFContentTypes = function (writer) {
        this.serializeHeaderFootersContentType(writer, 'EvenFooter');
        this.serializeHeaderFootersContentType(writer, 'EvenHeader');
        this.serializeHeaderFootersContentType(writer, 'FirstPageFooter');
        this.serializeHeaderFootersContentType(writer, 'FirstPageHeader');
        this.serializeHeaderFootersContentType(writer, 'OddFooter');
        this.serializeHeaderFootersContentType(writer, 'OddHeader');
    };
    // Serializes the HeaderFooter content types.
    WordExport.prototype.serializeHeaderFootersContentType = function (writer, headerFooterType) {
        var contentType;
        var partName;
        if (!this.headersFooters.containsKey(headerFooterType)) {
            return;
        }
        var hfColl = this.headersFooters.get(headerFooterType);
        for (var i = 0; i < hfColl.keys.length; i++) {
            var id = hfColl.keys[i];
            if (headerFooterType === 'EvenHeader' || headerFooterType === 'FirstPageHeader' ||
                headerFooterType === 'OddHeader') {
                partName = this.headerPath + id.replace('rId', '') + '.xml';
                contentType = this.headerContentType;
            }
            else {
                partName = this.footerPath + id.replace('rId', '') + '.xml';
                contentType = this.footerContentType;
            }
            this.serializeOverrideContentType(writer, partName, contentType);
        }
    };
    // Serializes the Override content type.
    WordExport.prototype.serializeOverrideContentType = function (writer, partName, contentType) {
        writer.writeStartElement(undefined, 'Override', undefined);
        writer.writeAttributeString(undefined, 'PartName', undefined, '/' + partName.replace('\\', '/'));
        writer.writeAttributeString(undefined, 'ContentType', undefined, contentType);
        writer.writeEndElement();
    };
    // Serializes the default content type
    WordExport.prototype.serializeDefaultContentType = function (writer, extension, contentType) {
        writer.writeStartElement(undefined, 'Default', undefined);
        writer.writeAttributeString(undefined, 'Extension', undefined, extension);
        writer.writeAttributeString(undefined, 'ContentType', undefined, contentType);
        writer.writeEndElement();
    };
    // Reset the relationship id counter
    WordExport.prototype.resetRelationShipID = function () {
        this.mRelationShipID = 0;
    };
    WordExport.prototype.resetExcelRelationShipId = function () {
        this.eRelationShipId = 0;
    };
    WordExport.prototype.resetChartRelationShipId = function () {
        this.cRelationShipId = 0;
    };
    WordExport.prototype.close = function () {
        //Implement
    };
    return WordExport;
}());

/**
 * Exports the document to Text format.
 */
var TextExport = /** @__PURE__ @class */ (function () {
    function TextExport() {
        /**
         * @private
         */
        this.pageContent = '';
        this.curSectionIndex = 0;
        this.inField = false;
    }
    TextExport.prototype.getModuleName = function () {
        return 'TextExport';
    };
    /**
     * @private
     */
    TextExport.prototype.save = function (viewer, fileName) {
        this.serialize(viewer);
        var writer = new StreamWriter();
        this.writeInternal(writer);
        writer.save(fileName + '.txt');
    };
    /**
     * @private
     */
    TextExport.prototype.saveAsBlob = function (viewer) {
        this.serialize(viewer);
        var streamWriter = new StreamWriter();
        this.writeInternal(streamWriter);
        var blob = streamWriter.buffer;
        streamWriter.destroy();
        return new Promise(function (resolve, reject) {
            resolve(blob);
        });
    };
    TextExport.prototype.serialize = function (viewer) {
        var document = viewer.owner.sfdtExportModule.write();
        this.setDocument(document);
    };
    /**
     * @private
     * @param document
     */
    TextExport.prototype.setDocument = function (document) {
        this.document = document;
        this.mSections = document.sections;
    };
    /**
     * @private
     * @param streamWriter
     */
    TextExport.prototype.writeInternal = function (streamWriter) {
        var section = undefined;
        var sectionCount = this.document.sections.length - 1;
        var isLastSection = false;
        this.updateLastParagraph();
        for (var i = 0; i <= sectionCount; i++) {
            section = this.document.sections[i];
            isLastSection = (i === sectionCount) ? true : false;
            this.writeBody(streamWriter, section.blocks);
            this.writeNewLine(streamWriter);
            this.writeSectionEnd(section, isLastSection);
        }
        for (var j = 0; j <= sectionCount; j++) {
            section = this.document.sections[j];
            this.writeHeadersFooters(streamWriter, section);
        }
    };
    /// <summary>
    /// Writes the specified document content to the text file.
    /// </summary>
    TextExport.prototype.writeBody = function (streamWriter, body) {
        var bodyItemsCount = body.length - 1;
        var bodyItem = undefined;
        for (var i = 0; i <= bodyItemsCount; i++) {
            bodyItem = body[i];
            if (bodyItem.hasOwnProperty('inlines')) {
                var isLastPara = (bodyItem === this.lastPara) ? true : false;
                this.writeParagraph(streamWriter, bodyItem, isLastPara);
            }
            else {
                this.writeTable(streamWriter, bodyItem);
            }
        }
    };
    TextExport.prototype.writeParagraph = function (streamWriter, paragraph, isLastPara) {
        for (var i = 0; i < paragraph.inlines.length; i++) {
            var item = paragraph.inlines[i];
            if (item.hasOwnProperty('fieldType')) {
                this.inField = item.fieldType === 0;
            }
            else if (item.hasOwnProperty('text') && !this.inField) {
                this.writeText(streamWriter, item.text);
            }
        }
        if (!isLastPara) {
            this.writeNewLine(streamWriter);
        }
    };
    /// }
    /// <summary>
    /// Writes the specified table text content to the text file.
    /// </summary>
    TextExport.prototype.writeTable = function (streamWriter, table) {
        for (var i = 0; i < table.rows.length; i++) {
            var row = table.rows[i];
            for (var j = 0; j < row.cells.length; j++) {
                var cell = row.cells[j];
                this.writeBody(streamWriter, cell.blocks);
            }
        }
    };
    /// <summary>
    /// Writes the specified Header Footer text content to the text file.
    /// </summary>
    TextExport.prototype.writeHeadersFooters = function (streamWriter, section) {
        var headersFooters = section.headersFooters;
        if (isNullOrUndefined(headersFooters)) {
            return;
        }
        this.writeHeaderFooter(streamWriter, section.headersFooters.header);
        this.writeHeaderFooter(streamWriter, section.headersFooters.footer);
        this.writeHeaderFooter(streamWriter, section.headersFooters.evenFooter);
        this.writeHeaderFooter(streamWriter, section.headersFooters.evenHeader);
        this.writeHeaderFooter(streamWriter, section.headersFooters.firstPageHeader);
        this.writeHeaderFooter(streamWriter, section.headersFooters.firstPageFooter);
    };
    TextExport.prototype.writeHeaderFooter = function (streamWriter, headerFooter) {
        if (headerFooter && headerFooter.blocks) {
            this.writeBody(streamWriter, headerFooter.blocks);
        }
    };
    /// <summary>
    /// Writes the end of the section.
    /// </summary>
    TextExport.prototype.writeSectionEnd = function (section, lastSection) {
        this.curSectionIndex++;
    };
    TextExport.prototype.writeNewLine = function (writer) {
        if (!isNullOrUndefined(writer)) {
            writer.writeLine('');
        }
        else {
            this.pageContent = this.pageContent + ' ';
        }
    };
    TextExport.prototype.writeText = function (writer, text) {
        if (!isNullOrUndefined(writer)) {
            writer.write(text);
        }
        else {
            this.pageContent += text;
        }
    };
    TextExport.prototype.updateLastParagraph = function () {
        var cnt = this.document.sections.length;
        var sec;
        if (cnt > 0) {
            sec = this.document.sections[cnt - 1];
        }
        if (!isNullOrUndefined(sec)) {
            var paragraphs = [];
            for (var i = 0; i < sec.blocks.length; i++) {
                if (sec.blocks[i].hasOwnProperty('inlines')) {
                    paragraphs.push(sec.blocks[i]);
                }
            }
            var pCount = paragraphs.length;
            if (pCount > 0) {
                this.lastPara = paragraphs[pCount - 1];
            }
        }
    };
    /**
     * @private
     */
    TextExport.prototype.destroy = function () {
        this.document = undefined;
        this.lastPara = undefined;
        this.mSections = undefined;
        this.sections = undefined;
    };
    return TextExport;
}());

/**
 * Exports the document to Sfdt format.
 */
var SfdtExport = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function SfdtExport(owner) {
        /* tslint:disable:no-any */
        this.endLine = undefined;
        this.endOffset = undefined;
        this.endCell = undefined;
        this.startColumnIndex = undefined;
        this.endColumnIndex = undefined;
        this.lists = undefined;
        this.viewer = undefined;
        this.document = undefined;
        this.writeInlineStyles = undefined;
        this.editRangeId = -1;
        this.isExport = true;
        this.viewer = owner;
    }
    SfdtExport.prototype.getModuleName = function () {
        return 'SfdtExport';
    };
    SfdtExport.prototype.clear = function () {
        this.writeInlineStyles = undefined;
        this.endLine = undefined;
        this.lists = undefined;
        this.document = undefined;
        this.endCell = undefined;
    };
    /**
     * Serialize the data as Syncfusion document text.
     * @private
     */
    SfdtExport.prototype.serialize = function () {
        return JSON.stringify(this.write());
    };
    /**
     * @private
     */
    SfdtExport.prototype.saveAsBlob = function (viewer) {
        var streamWriter = new StreamWriter();
        streamWriter.write(this.serialize());
        var blob = streamWriter.buffer;
        streamWriter.destroy();
        return new Promise(function (resolve, reject) {
            resolve(blob);
        });
    };
    SfdtExport.prototype.updateEditRangeId = function () {
        var index = -1;
        for (var i = 0; i < this.viewer.editRanges.keys.length; i++) {
            var keys = this.viewer.editRanges.keys;
            for (var j = 0; j < keys[i].length; j++) {
                var editRangeStart = this.viewer.editRanges.get(keys[i]);
                for (var z = 0; z < editRangeStart.length; z++) {
                    index++;
                    editRangeStart[z].editRangeId = index;
                    editRangeStart[z].editRangeEnd.editRangeId = index;
                }
            }
        }
    };
    // tslint:disable-next-line:max-line-length
    /**
     * @private
     */
    SfdtExport.prototype.write = function (line, startOffset, endLine, endOffset, writeInlineStyles) {
        if (writeInlineStyles) {
            this.writeInlineStyles = true;
        }
        this.Initialize();
        this.updateEditRangeId();
        if (line instanceof LineWidget && endLine instanceof LineWidget) {
            this.isExport = false;
            // For selection
            var startPara = line.paragraph;
            var endPara = endLine.paragraph;
            var startCell = startPara.associatedCell;
            var endCell = endPara.associatedCell;
            // Creates section
            var bodyWidget = startPara.bodyWidget;
            var section = this.createSection(line.paragraph.bodyWidget);
            this.document.sections.push(section);
            if (startCell === endCell || isNullOrUndefined(endCell)) {
                this.endLine = endLine;
                this.endOffset = endOffset;
            }
            else {
                // Todo: Handle nested table cases
                if (startCell instanceof TableCellWidget) {
                    var startTable = startCell.getContainerTable();
                    var endTable = endCell.getContainerTable();
                    if (startTable.tableFormat === endTable.tableFormat) {
                        this.endCell = endCell;
                        if (this.endCell.ownerTable !== startCell.ownerTable && startCell.ownerTable.associatedCell
                            && startCell.ownerTable.associatedCell.ownerTable === this.endCell.ownerTable &&
                            (startCell.ownerTable.associatedCell.childWidgets.indexOf(startCell.ownerTable) === 0)) {
                            startCell = startCell.ownerTable.associatedCell;
                        }
                        this.endColumnIndex = this.endCell.columnIndex + this.endCell.cellFormat.columnSpan;
                        this.startColumnIndex = startCell.columnIndex;
                    }
                }
                else {
                    this.endCell = endCell;
                }
            }
            var nextBlock = void 0;
            if (startCell === endCell || isNullOrUndefined(startCell)) {
                var paragraph = this.createParagraph(line.paragraph);
                section.blocks.push(paragraph);
                nextBlock = this.writeParagraph(line.paragraph, paragraph, section.blocks, line.indexInOwner, startOffset);
                while (nextBlock) {
                    nextBlock = this.writeBlock(nextBlock, 0, section.blocks);
                }
                // Todo:continue in next section
            }
            else {
                // Specially handled for nested table cases
                // selection start inside table and end in paragraph outside table
                if (isNullOrUndefined(endCell) && startCell.ownerTable.associatedCell) {
                    var startTable = startCell.getContainerTable();
                    var lastRow = startTable.childWidgets[startTable.childWidgets.length - 1];
                    var endCell_1 = lastRow.childWidgets[lastRow.childWidgets.length - 1];
                    if (endCell_1.ownerTable !== startCell.ownerTable && startCell.ownerTable.associatedCell
                        && (startCell.ownerTable.associatedCell.childWidgets.indexOf(startCell.ownerTable) === 0)) {
                        while (startCell.ownerTable !== endCell_1.ownerTable) {
                            startCell = startCell.ownerTable.associatedCell;
                        }
                    }
                    this.endColumnIndex = endCell_1.columnIndex + endCell_1.cellFormat.columnSpan;
                    this.startColumnIndex = startCell.columnIndex;
                }
                var table = this.createTable(startCell.ownerTable);
                section.blocks.push(table);
                nextBlock = this.writeTable(startCell.ownerTable, table, startCell.ownerRow.indexInOwner, section.blocks);
                while (nextBlock) {
                    nextBlock = this.writeBlock(nextBlock, 0, section.blocks);
                }
            }
        }
        else {
            this.isExport = true;
            if (this.viewer.pages.length > 0) {
                var page = this.viewer.pages[0];
                this.writePage(page);
            }
        }
        this.writeStyles(this.viewer);
        this.writeLists(this.viewer);
        this.writeComments(this.viewer);
        var doc = this.document;
        this.clear();
        return doc;
    };
    /**
     * @private
     */
    SfdtExport.prototype.Initialize = function () {
        this.lists = [];
        this.document = {};
        this.document.sections = [];
        this.document.characterFormat = this.writeCharacterFormat(this.viewer.characterFormat);
        this.document.paragraphFormat = this.writeParagraphFormat(this.viewer.paragraphFormat);
        this.document.defaultTabWidth = this.viewer.defaultTabWidth;
        this.document.enforcement = this.viewer.isDocumentProtected;
        this.document.hashValue = this.viewer.hashValue;
        this.document.saltValue = this.viewer.saltValue;
        this.document.formatting = this.viewer.restrictFormatting;
        this.document.protectionType = this.viewer.protectionType;
    };
    /**
     * @private
     */
    SfdtExport.prototype.writePage = function (page) {
        if (page.bodyWidgets.length > 0) {
            var nextBlock = page.bodyWidgets[0];
            do {
                nextBlock = this.writeBodyWidget(nextBlock, 0);
            } while (!isNullOrUndefined(nextBlock));
        }
        return this.document;
    };
    SfdtExport.prototype.writeBodyWidget = function (bodyWidget, index) {
        if (!(bodyWidget instanceof BodyWidget)) {
            return undefined;
        }
        var section = this.createSection(bodyWidget);
        this.document.sections.push(section);
        this.writeHeaderFooters(this.viewer.headersFooters[bodyWidget.index], section);
        var firstBlock = bodyWidget.childWidgets[index];
        do {
            firstBlock = this.writeBlock(firstBlock, 0, section.blocks);
        } while (firstBlock);
        var next = bodyWidget;
        do {
            bodyWidget = next;
            next = next.nextRenderedWidget;
        } while (next instanceof BodyWidget && next.index === bodyWidget.index);
        return next;
    };
    SfdtExport.prototype.writeHeaderFooters = function (hfs, section) {
        if (isNullOrUndefined(hfs)) {
            return;
        }
        section.headersFooters.header = this.writeHeaderFooter(hfs[0]);
        section.headersFooters.footer = this.writeHeaderFooter(hfs[1]);
        section.headersFooters.evenHeader = this.writeHeaderFooter(hfs[2]);
        section.headersFooters.evenFooter = this.writeHeaderFooter(hfs[3]);
        section.headersFooters.firstPageHeader = this.writeHeaderFooter(hfs[4]);
        section.headersFooters.firstPageFooter = this.writeHeaderFooter(hfs[5]);
    };
    SfdtExport.prototype.writeHeaderFooter = function (widget) {
        if (isNullOrUndefined(widget) || widget.isEmpty) {
            return undefined;
        }
        var headerFooter = {};
        if (widget && widget.childWidgets && widget.childWidgets.length > 0) {
            headerFooter.blocks = [];
            var firstBlock = widget.firstChild;
            do {
                firstBlock = this.writeBlock(firstBlock, 0, headerFooter.blocks);
            } while (firstBlock);
        }
        return headerFooter;
    };
    SfdtExport.prototype.createSection = function (bodyWidget) {
        var section = {};
        section.sectionFormat = {};
        section.sectionFormat.pageWidth = bodyWidget.sectionFormat.pageWidth;
        section.sectionFormat.pageHeight = bodyWidget.sectionFormat.pageHeight;
        section.sectionFormat.leftMargin = bodyWidget.sectionFormat.leftMargin;
        section.sectionFormat.rightMargin = bodyWidget.sectionFormat.rightMargin;
        section.sectionFormat.topMargin = bodyWidget.sectionFormat.topMargin;
        section.sectionFormat.bottomMargin = bodyWidget.sectionFormat.bottomMargin;
        section.sectionFormat.differentFirstPage = bodyWidget.sectionFormat.differentFirstPage;
        section.sectionFormat.differentOddAndEvenPages = bodyWidget.sectionFormat.differentOddAndEvenPages;
        section.sectionFormat.headerDistance = bodyWidget.sectionFormat.headerDistance;
        section.sectionFormat.footerDistance = bodyWidget.sectionFormat.footerDistance;
        section.sectionFormat.bidi = bodyWidget.sectionFormat.bidi;
        section.blocks = [];
        section.headersFooters = {};
        return section;
    };
    SfdtExport.prototype.writeBlock = function (widget, index, blocks) {
        if (!(widget instanceof BlockWidget)) {
            return undefined;
        }
        if (widget instanceof ParagraphWidget) {
            var paragraph = this.createParagraph(widget);
            blocks.push(paragraph);
            return this.writeParagraph(widget, paragraph, blocks);
        }
        else {
            var tableWidget = widget;
            var table = this.createTable(tableWidget);
            blocks.push(table);
            return this.writeTable(tableWidget, table, 0, blocks);
        }
    };
    SfdtExport.prototype.writeParagraph = function (paragraphWidget, paragraph, blocks, lineIndex, start) {
        if (isNullOrUndefined(lineIndex)) {
            lineIndex = 0;
        }
        if (isNullOrUndefined(start)) {
            start = 0;
        }
        var next = paragraphWidget;
        while (next instanceof ParagraphWidget) {
            if (this.writeLines(next, lineIndex, start, paragraph.inlines)) {
                return undefined;
            }
            lineIndex = 0;
            start = 0;
            paragraphWidget = next;
            next = paragraphWidget.nextSplitWidget;
        }
        next = paragraphWidget.nextRenderedWidget;
        return (next instanceof BlockWidget && paragraphWidget.containerWidget.index === next.containerWidget.index) ? next : undefined;
    };
    SfdtExport.prototype.writeInlines = function (paragraph, line, inlines) {
        var lineWidget = line.clone();
        var bidi = paragraph.paragraphFormat.bidi;
        if (bidi || this.viewer.layout.isContainsRtl(lineWidget)) {
            this.viewer.layout.reArrangeElementsForRtl(lineWidget, bidi);
        }
        for (var i = 0; i < lineWidget.children.length; i++) {
            var element = lineWidget.children[i];
            if (element instanceof ListTextElementBox) {
                continue;
            }
            var inline = this.writeInline(element);
            if (!isNullOrUndefined(inline)) {
                inlines.push(inline);
            }
        }
    };
    SfdtExport.prototype.writeInline = function (element) {
        var inline = {};
        inline.characterFormat = this.writeCharacterFormat(element.characterFormat);
        if (element instanceof FieldElementBox) {
            inline.fieldType = element.fieldType;
            if (element.fieldType === 0) {
                inline.hasFieldEnd = true;
            }
            if (element.fieldCodeType && element.fieldCodeType !== '') {
                inline.fieldCodeType = element.fieldCodeType;
            }
        }
        else if (element instanceof ChartElementBox) {
            this.writeChart(element, inline);
        }
        else if (element instanceof ImageElementBox) {
            inline.imageString = element.imageString;
            inline.width = HelperMethods.convertPixelToPoint(element.width);
            inline.height = HelperMethods.convertPixelToPoint(element.height);
        }
        else if (element instanceof BookmarkElementBox) {
            inline.bookmarkType = element.bookmarkType;
            inline.name = element.name;
        }
        else if (element instanceof TextElementBox) {
            // replacing the no break hyphen character by '-'
            if (element.text.indexOf('\u001e') !== -1) {
                inline.text = element.text.replace('\u001e', '-');
            }
            else if (element.text.indexOf('\u001f') !== -1) {
                inline.text = element.text.replace('\u001f', '');
            }
            else {
                inline.text = element.text;
            }
        }
        else if (element instanceof EditRangeStartElementBox) {
            inline.user = element.user;
            inline.group = element.group;
            inline.columnFirst = element.columnFirst;
            inline.columnLast = element.columnLast;
            inline.editRangeId = element.editRangeId.toString();
        }
        else if (element instanceof EditRangeEndElementBox) {
            inline.editableRangeStart = {
                'user': element.editRangeStart.user,
                'group': element.editRangeStart.group,
                'columnFirst': element.editRangeStart.columnFirst,
                'columnLast': element.editRangeStart.columnLast
            };
            inline.editRangeId = element.editRangeId.toString();
        }
        else if (element instanceof CommentCharacterElementBox) {
            inline.commentCharacterType = element.commentType;
            inline.commentId = element.commentId;
        }
        else {
            inline = undefined;
        }
        return inline;
    };
    SfdtExport.prototype.writeChart = function (element, inline) {
        inline.chartLegend = {};
        inline.chartTitleArea = {};
        inline.chartArea = {};
        inline.plotArea = {};
        inline.chartCategory = [];
        inline.chartSeries = [];
        inline.chartPrimaryCategoryAxis = {};
        inline.chartPrimaryValueAxis = {};
        this.writeChartTitleArea(element.chartTitleArea, inline.chartTitleArea);
        this.writeChartArea(element.chartArea, inline.chartArea);
        this.writeChartArea(element.chartPlotArea, inline.plotArea);
        this.writeChartCategory(element, inline.chartCategory);
        this.createChartSeries(element, inline.chartSeries);
        this.writeChartLegend(element.chartLegend, inline.chartLegend);
        this.writeChartCategoryAxis(element.chartPrimaryCategoryAxis, inline.chartPrimaryCategoryAxis);
        this.writeChartCategoryAxis(element.chartPrimaryValueAxis, inline.chartPrimaryValueAxis);
        if (element.chartDataTable.showSeriesKeys !== undefined) {
            inline.chartDataTable = {};
            this.writeChartDataTable(element.chartDataTable, inline.chartDataTable);
        }
        inline.chartTitle = element.title;
        inline.chartType = element.type;
        inline.gapWidth = element.chartGapWidth;
        inline.overlap = element.chartOverlap;
        inline.height = HelperMethods.convertPixelToPoint(element.height);
        inline.width = HelperMethods.convertPixelToPoint(element.width);
    };
    SfdtExport.prototype.writeChartTitleArea = function (titleArea, chartTitleArea) {
        chartTitleArea.fontName = titleArea.chartfontName;
        chartTitleArea.fontSize = titleArea.chartFontSize;
        chartTitleArea.layout = {};
        chartTitleArea.dataFormat = this.writeChartDataFormat(titleArea.dataFormat);
        this.writeChartLayout(titleArea.layout, chartTitleArea.layout);
    };
    SfdtExport.prototype.writeChartDataFormat = function (format) {
        var chartDataFormat = {};
        chartDataFormat.fill = {};
        chartDataFormat.line = {};
        chartDataFormat.fill.foreColor = format.fill.color;
        chartDataFormat.fill.rgb = format.fill.rgb;
        chartDataFormat.line.color = format.line.color;
        chartDataFormat.line.rgb = format.line.rgb;
        return chartDataFormat;
    };
    SfdtExport.prototype.writeChartLayout = function (layout, chartLayout) {
        chartLayout.layoutX = layout.chartLayoutLeft;
        chartLayout.layoutY = layout.chartLayoutTop;
    };
    SfdtExport.prototype.writeChartArea = function (area, chartArea) {
        chartArea.foreColor = area.chartForeColor;
    };
    SfdtExport.prototype.writeChartLegend = function (legend, chartLegend) {
        chartLegend.position = legend.chartLegendPostion;
        chartLegend.chartTitleArea = {};
        this.writeChartTitleArea(legend.chartTitleArea, chartLegend.chartTitleArea);
    };
    SfdtExport.prototype.writeChartCategoryAxis = function (categoryAxis, primaryCategoryAxis) {
        primaryCategoryAxis.chartTitle = categoryAxis.categoryAxisTitle;
        primaryCategoryAxis.chartTitleArea = {};
        this.writeChartTitleArea(categoryAxis.chartTitleArea, primaryCategoryAxis.chartTitleArea);
        primaryCategoryAxis.categoryType = categoryAxis.categoryAxisType;
        primaryCategoryAxis.fontSize = categoryAxis.axisFontSize;
        primaryCategoryAxis.fontName = categoryAxis.axisFontName;
        primaryCategoryAxis.numberFormat = categoryAxis.categoryNumberFormat;
        primaryCategoryAxis.maximumValue = categoryAxis.max;
        primaryCategoryAxis.minimumValue = categoryAxis.min;
        primaryCategoryAxis.majorUnit = categoryAxis.interval;
        primaryCategoryAxis.hasMajorGridLines = categoryAxis.majorGridLines;
        primaryCategoryAxis.hasMinorGridLines = categoryAxis.minorGridLines;
        primaryCategoryAxis.majorTickMark = categoryAxis.majorTick;
        primaryCategoryAxis.minorTickMark = categoryAxis.minorTick;
        primaryCategoryAxis.tickLabelPosition = categoryAxis.tickPosition;
    };
    SfdtExport.prototype.writeChartDataTable = function (chartDataTable, dataTable) {
        dataTable.showSeriesKeys = chartDataTable.showSeriesKeys;
        dataTable.hasHorzBorder = chartDataTable.hasHorzBorder;
        dataTable.hasVertBorder = chartDataTable.hasVertBorder;
        dataTable.hasBorders = chartDataTable.hasBorders;
    };
    SfdtExport.prototype.writeChartCategory = function (element, chartCategory) {
        var data = element.chartCategory;
        chartCategory.chartData = [];
        for (var i = 0; i < data.length; i++) {
            var xData = data[i];
            var categories = this.createChartCategory(xData, element.chartType);
            chartCategory.push(categories);
        }
    };
    SfdtExport.prototype.createChartCategory = function (data, type) {
        var chartCategory = {};
        chartCategory.chartData = [];
        this.writeChartData(data, chartCategory.chartData, type);
        chartCategory.categoryXName = data.categoryXName;
        return chartCategory;
    };
    SfdtExport.prototype.writeChartData = function (element, chartData, type) {
        var data = element.chartData;
        for (var i = 0; i < data.length; i++) {
            var yData = data[i];
            var yCategory = this.createChartData(yData, type);
            chartData.push(yCategory);
        }
    };
    SfdtExport.prototype.createChartData = function (data, type) {
        var chartData = {};
        chartData.yValue = data.yValue;
        if (type === 'Bubble') {
            chartData.size = data.size;
        }
        return chartData;
    };
    SfdtExport.prototype.createChartSeries = function (element, chartSeries) {
        var data = element.chartSeries;
        var type = element.chartType;
        for (var i = 0; i < data.length; i++) {
            var yData = data[i];
            var series = this.writeChartSeries(yData, type);
            chartSeries.push(series);
        }
    };
    SfdtExport.prototype.writeChartSeries = function (series, type) {
        var isPieType = (type === 'Pie' || type === 'Doughnut');
        var chartSeries = {};
        var errorBar = {};
        var errorBarData = series.errorBar;
        chartSeries.dataPoints = [];
        chartSeries.seriesName = series.seriesName;
        if (isPieType) {
            if (!isNullOrUndefined(series.firstSliceAngle)) {
                chartSeries.firstSliceAngle = series.firstSliceAngle;
            }
            if (type === 'Doughnut') {
                chartSeries.holeSize = series.doughnutHoleSize;
            }
        }
        if (!isNullOrUndefined(series.dataLabels.labelPosition)) {
            var dataLabel = this.writeChartDataLabels(series.dataLabels);
            chartSeries.dataLabel = dataLabel;
        }
        if (!isNullOrUndefined(series.seriesFormat.markerStyle)) {
            var seriesFormat = {};
            var format = series.seriesFormat;
            seriesFormat.markerStyle = format.markerStyle;
            seriesFormat.markerSize = format.numberValue;
            seriesFormat.markerColor = format.markerColor;
            chartSeries.seriesFormat = seriesFormat;
        }
        if (!isNullOrUndefined(errorBarData.type)) {
            errorBar.type = errorBarData.type;
            errorBar.direction = errorBarData.direction;
            errorBar.endStyle = errorBarData.endStyle;
            errorBar.numberValue = errorBarData.numberValue;
            chartSeries.errorBar = errorBarData;
        }
        if (series.trendLines.length > 0) {
            chartSeries.trendLines = [];
            for (var i = 0; i < series.trendLines.length; i++) {
                var trendLine = this.writeChartTrendLines(series.trendLines[i]);
                chartSeries.trendLines.push(trendLine);
            }
        }
        for (var i = 0; i < series.chartDataFormat.length; i++) {
            var format = this.writeChartDataFormat(series.chartDataFormat[i]);
            chartSeries.dataPoints.push(format);
        }
        return chartSeries;
    };
    SfdtExport.prototype.writeChartDataLabels = function (dataLabels) {
        var dataLabel = {};
        dataLabel.position = dataLabels.position;
        dataLabel.fontName = dataLabels.fontName;
        dataLabel.fontColor = dataLabels.fontColor;
        dataLabel.fontSize = dataLabels.fontSize;
        dataLabel.isLegendKey = dataLabels.isLegendKey;
        dataLabel.isBubbleSize = dataLabels.isBubbleSize;
        dataLabel.isCategoryName = dataLabels.isCategoryName;
        dataLabel.isSeriesName = dataLabels.isSeriesName;
        dataLabel.isValue = dataLabels.isValue;
        dataLabel.isPercentage = dataLabels.isPercentage;
        dataLabel.isLeaderLines = dataLabels.isLeaderLines;
        return dataLabel;
    };
    SfdtExport.prototype.writeChartTrendLines = function (trendLines) {
        var trendLine = {};
        trendLine.name = trendLines.trendLineName;
        trendLine.type = trendLines.trendLineType;
        trendLine.forward = trendLines.forwardValue;
        trendLine.backward = trendLines.backwardValue;
        trendLine.intercept = trendLines.interceptValue;
        trendLine.isDisplayEquation = trendLines.isDisplayEquation;
        trendLine.isDisplayRSquared = trendLines.isDisplayRSquared;
        return trendLine;
    };
    SfdtExport.prototype.writeLines = function (paragraph, lineIndex, offset, inlines) {
        var startIndex = lineIndex;
        var endParagraph = this.endLine instanceof LineWidget && this.endLine.paragraph === paragraph;
        var endIndex = endParagraph ? this.endLine.indexInOwner : paragraph.childWidgets.length - 1;
        for (var i = startIndex; i <= endIndex; i++) {
            var child = paragraph.childWidgets[i];
            if (this.endLine === child || (lineIndex === i && offset !== 0)) {
                this.writeLine(child, offset, inlines);
            }
            else {
                this.writeInlines(paragraph, child, inlines);
            }
        }
        return endParagraph;
    };
    SfdtExport.prototype.writeLine = function (line, offset, inlines) {
        var isEnd = line === this.endLine;
        var lineWidget = line.clone();
        var bidi = line.paragraph.paragraphFormat.bidi;
        if (bidi || this.viewer.layout.isContainsRtl(lineWidget)) {
            this.viewer.layout.reArrangeElementsForRtl(lineWidget, bidi);
        }
        var started = false;
        var ended = false;
        var length = 0;
        for (var j = 0; j < lineWidget.children.length; j++) {
            var element = lineWidget.children[j];
            if (element instanceof ListTextElementBox) {
                continue;
            }
            var inline = undefined;
            length += element.length;
            started = length > offset;
            ended = isEnd && length >= this.endOffset;
            if (!started) {
                continue;
            }
            inline = this.writeInline(element);
            inlines[inlines.length] = inline;
            if (length > offset || ended) {
                if (inline.hasOwnProperty('text')) {
                    var startIndex = length - element.length;
                    var indexInInline = offset - startIndex;
                    var endIndex = ended ? this.endOffset - startIndex : element.length;
                    inline.text = inline.text.substring(indexInInline, endIndex);
                }
                offset = -1;
            }
            if (ended) {
                break;
            }
        }
    };
    SfdtExport.prototype.createParagraph = function (paragraphWidget) {
        var paragraph = {};
        var isParaSelected = false;
        if (this.viewer.selection && !this.viewer.selection.isEmpty && !this.isExport) {
            var endPos = this.viewer.selection.end;
            if (!this.viewer.selection.isForward) {
                endPos = this.viewer.selection.start;
            }
            var lastLine = endPos.paragraph.childWidgets[endPos.paragraph.childWidgets.length - 1];
            isParaSelected = this.viewer.selection.isParagraphLastLine(lastLine) && endPos.currentWidget === lastLine
                && endPos.offset === this.viewer.selection.getLineLength(lastLine) + 1;
        }
        else {
            isParaSelected = true;
        }
        // tslint:disable-next-line:max-line-length
        paragraph.paragraphFormat = this.writeParagraphFormat(isParaSelected ? paragraphWidget.paragraphFormat : new WParagraphFormat(paragraphWidget));
        paragraph.characterFormat = this.writeCharacterFormat(isParaSelected ? paragraphWidget.characterFormat : new WCharacterFormat(paragraphWidget));
        paragraph.inlines = [];
        return paragraph;
    };
    /**
     * @private
     */
    SfdtExport.prototype.writeCharacterFormat = function (format, isInline) {
        var characterFormat = {};
        HelperMethods.writeCharacterFormat(characterFormat, isInline, format);
        if (this.writeInlineStyles && !isInline) {
            characterFormat.inlineFormat = this.writeCharacterFormat(format, true);
        }
        return characterFormat;
    };
    SfdtExport.prototype.writeParagraphFormat = function (format, isInline) {
        var paragraphFormat = {};
        paragraphFormat.leftIndent = isInline ? format.leftIndent : format.getValue('leftIndent');
        paragraphFormat.rightIndent = isInline ? format.rightIndent : format.getValue('rightIndent');
        paragraphFormat.firstLineIndent = isInline ? format.firstLineIndent : format.getValue('firstLineIndent');
        paragraphFormat.textAlignment = isInline ? format.textAlignment : format.getValue('textAlignment');
        paragraphFormat.beforeSpacing = isInline ? format.beforeSpacing : format.getValue('beforeSpacing');
        paragraphFormat.afterSpacing = isInline ? format.afterSpacing : format.getValue('afterSpacing');
        paragraphFormat.lineSpacing = isInline ? format.lineSpacing : format.getValue('lineSpacing');
        paragraphFormat.lineSpacingType = isInline ? format.lineSpacingType : format.getValue('lineSpacingType');
        paragraphFormat.styleName = !isNullOrUndefined(format.baseStyle) ? format.baseStyle.name : undefined;
        paragraphFormat.outlineLevel = isInline ? format.outlineLevel : format.getValue('outlineLevel');
        paragraphFormat.listFormat = this.writeListFormat(format.listFormat, isInline);
        paragraphFormat.tabs = this.writeTabs(format.tabs);
        paragraphFormat.bidi = isInline ? format.bidi : format.getValue('bidi');
        paragraphFormat.contextualSpacing = isInline ? format.contextualSpacing : format.getValue('contextualSpacing');
        if (this.writeInlineStyles && !isInline) {
            paragraphFormat.inlineFormat = this.writeParagraphFormat(format, true);
        }
        return paragraphFormat;
    };
    SfdtExport.prototype.writeTabs = function (tabStops) {
        if (isNullOrUndefined(tabStops) || tabStops.length < 1) {
            return undefined;
        }
        var tabs = [];
        for (var i = 0; i < tabStops.length; i++) {
            var tabStop = tabStops[i];
            var tab = {};
            tab.position = tabStop.position;
            tab.deletePosition = tabStop.deletePosition;
            tab.tabJustification = tabStop.tabJustification;
            tab.tabLeader = tabStop.tabLeader;
            tabs.push(tab);
        }
        return tabs;
    };
    /**
     * @private
     */
    SfdtExport.prototype.writeListFormat = function (format, isInline) {
        var listFormat = {};
        var listIdValue = format.getValue('listId');
        if (!isNullOrUndefined(listIdValue)) {
            listFormat.listId = listIdValue;
            if (this.lists.indexOf(format.listId) < 0) {
                this.lists.push(format.listId);
            }
        }
        var listLevelNumber = format.getValue('listLevelNumber');
        if (!isNullOrUndefined(listLevelNumber)) {
            listFormat.listLevelNumber = listLevelNumber;
        }
        return listFormat;
    };
    SfdtExport.prototype.writeTable = function (tableWidget, table, index, blocks) {
        var widget = tableWidget.childWidgets[index];
        if (widget instanceof TableRowWidget) {
            if (this.writeRow(widget, table.rows)) {
                return undefined;
            }
        }
        var next = tableWidget;
        do {
            tableWidget = next;
            next = tableWidget.nextSplitWidget;
        } while (next instanceof BlockWidget);
        next = tableWidget.nextRenderedWidget;
        return (next instanceof BlockWidget && next.containerWidget.index === tableWidget.containerWidget.index) ? next : undefined;
    };
    SfdtExport.prototype.writeRow = function (rowWidget, rows) {
        if (!(rowWidget instanceof TableRowWidget)) {
            return false;
        }
        var row = this.createRow(rowWidget);
        rows.push(row);
        for (var i = 0; i < rowWidget.childWidgets.length; i++) {
            var widget = rowWidget.childWidgets[i];
            if (widget instanceof TableCellWidget) {
                if (rowWidget.index === widget.rowIndex
                    && (isNullOrUndefined(this.startColumnIndex) || widget.columnIndex >= this.startColumnIndex)
                    && (isNullOrUndefined(this.endColumnIndex) || widget.columnIndex < this.endColumnIndex)) {
                    if (this.writeCell(widget, row.cells)) {
                        return true;
                    }
                }
            }
        }
        var next = rowWidget;
        do {
            rowWidget = next;
            next = rowWidget.nextRenderedWidget;
            if (next && rowWidget.ownerTable.index !== next.ownerTable.index) {
                next = undefined;
            }
        } while (next instanceof TableRowWidget && next.index === rowWidget.index);
        return this.writeRow(next, rows);
    };
    SfdtExport.prototype.writeCell = function (cellWidget, cells) {
        var cell = this.createCell(cellWidget);
        cells.push(cell);
        var firstBlock = cellWidget.firstChild;
        do {
            firstBlock = this.writeBlock(firstBlock, 0, cell.blocks);
        } while (firstBlock);
        return this.endCell instanceof TableCellWidget ? this.endCell.cellFormat === cellWidget.cellFormat : false;
    };
    SfdtExport.prototype.createTable = function (tableWidget) {
        var table = {};
        table.rows = [];
        table.grid = [];
        for (var i = 0; i < tableWidget.tableHolder.columns.length; i++) {
            table.grid[i] = tableWidget.tableHolder.columns[i].preferredWidth;
        }
        table.tableFormat = this.writeTableFormat(tableWidget.tableFormat);
        table.description = tableWidget.description;
        table.title = tableWidget.title;
        table.columnCount = tableWidget.tableHolder.columns.length;
        return table;
    };
    SfdtExport.prototype.createRow = function (rowWidget) {
        var row = {};
        row.cells = [];
        row.rowFormat = this.writeRowFormat(rowWidget.rowFormat);
        return row;
    };
    SfdtExport.prototype.createCell = function (cellWidget) {
        var cell = {};
        cell.blocks = [];
        cell.cellFormat = this.writeCellFormat(cellWidget.cellFormat);
        cell.columnIndex = cellWidget.columnIndex;
        return cell;
    };
    SfdtExport.prototype.writeShading = function (wShading) {
        var shading = {};
        shading.backgroundColor = wShading.hasValue('backgroundColor') ? wShading.backgroundColor : undefined;
        shading.foregroundColor = wShading.hasValue('foregroundColor') ? wShading.foregroundColor : undefined;
        shading.textureStyle = wShading.hasValue('textureStyle') ? wShading.textureStyle : undefined;
        return shading;
    };
    SfdtExport.prototype.writeBorder = function (wBorder) {
        var border = {};
        border.color = wBorder.hasValue('color') ? wBorder.color : undefined;
        border.hasNoneStyle = wBorder.hasValue('hasNoneStyle') ? wBorder.hasNoneStyle : undefined;
        border.lineStyle = wBorder.hasValue('lineStyle') ? wBorder.lineStyle : undefined;
        border.lineWidth = wBorder.hasValue('lineWidth') ? wBorder.lineWidth : undefined;
        border.shadow = wBorder.hasValue('shadow') ? wBorder.shadow : undefined;
        border.space = wBorder.hasValue('space') ? wBorder.space : undefined;
        return border;
    };
    SfdtExport.prototype.writeBorders = function (wBorders) {
        var borders = {};
        borders.top = this.writeBorder(wBorders.top);
        borders.left = this.writeBorder(wBorders.left);
        borders.right = this.writeBorder(wBorders.right);
        borders.bottom = this.writeBorder(wBorders.bottom);
        borders.diagonalDown = this.writeBorder(wBorders.diagonalDown);
        borders.diagonalUp = this.writeBorder(wBorders.diagonalUp);
        borders.horizontal = this.writeBorder(wBorders.horizontal);
        borders.vertical = this.writeBorder(wBorders.vertical);
        return borders;
    };
    SfdtExport.prototype.writeCellFormat = function (wCellFormat) {
        var cellFormat = {};
        cellFormat.borders = this.writeBorders(wCellFormat.borders);
        cellFormat.shading = this.writeShading(wCellFormat.shading);
        cellFormat.topMargin = wCellFormat.hasValue('topMargin') ? wCellFormat.topMargin : undefined;
        cellFormat.rightMargin = wCellFormat.hasValue('rightMargin') ? wCellFormat.rightMargin : undefined;
        cellFormat.leftMargin = wCellFormat.hasValue('leftMargin') ? wCellFormat.leftMargin : undefined;
        cellFormat.bottomMargin = wCellFormat.hasValue('bottomMargin') ? wCellFormat.bottomMargin : undefined;
        cellFormat.preferredWidth = wCellFormat.hasValue('preferredWidth') ? wCellFormat.preferredWidth : undefined;
        cellFormat.preferredWidthType = wCellFormat.hasValue('preferredWidthType') ? wCellFormat.preferredWidthType : undefined;
        cellFormat.cellWidth = wCellFormat.hasValue('cellWidth') ? wCellFormat.cellWidth : undefined;
        cellFormat.columnSpan = wCellFormat.columnSpan;
        cellFormat.rowSpan = wCellFormat.rowSpan;
        cellFormat.verticalAlignment = wCellFormat.hasValue('verticalAlignment') ? wCellFormat.verticalAlignment : undefined;
        return cellFormat;
    };
    SfdtExport.prototype.writeRowFormat = function (wRowFormat) {
        var rowFormat = {};
        rowFormat.height = wRowFormat.hasValue('height') ? wRowFormat.height : undefined;
        rowFormat.allowBreakAcrossPages = wRowFormat.hasValue('allowBreakAcrossPages') ? wRowFormat.allowBreakAcrossPages : undefined;
        rowFormat.heightType = wRowFormat.hasValue('heightType') ? wRowFormat.heightType : undefined;
        rowFormat.isHeader = wRowFormat.hasValue('isHeader') ? wRowFormat.isHeader : undefined;
        rowFormat.borders = this.writeBorders(wRowFormat.borders);
        rowFormat.gridBefore = wRowFormat.gridBefore;
        rowFormat.gridBeforeWidth = wRowFormat.hasValue('gridBeforeWidth') ? wRowFormat.gridBeforeWidth : undefined;
        rowFormat.gridBeforeWidthType = wRowFormat.hasValue('gridBeforeWidthType') ? wRowFormat.gridBeforeWidthType : undefined;
        rowFormat.gridAfter = wRowFormat.gridAfter;
        rowFormat.gridAfterWidth = wRowFormat.hasValue('gridAfterWidth') ? wRowFormat.gridAfterWidth : undefined;
        rowFormat.gridAfterWidthType = wRowFormat.hasValue('gridAfterWidthType') ? wRowFormat.gridAfterWidthType : undefined;
        rowFormat.leftMargin = wRowFormat.hasValue('leftMargin') ? wRowFormat.leftMargin : undefined;
        rowFormat.topMargin = wRowFormat.hasValue('topMargin') ? wRowFormat.topMargin : undefined;
        rowFormat.rightMargin = wRowFormat.hasValue('rightMargin') ? wRowFormat.rightMargin : undefined;
        rowFormat.bottomMargin = wRowFormat.hasValue('bottomMargin') ? wRowFormat.bottomMargin : undefined;
        rowFormat.leftIndent = wRowFormat.hasValue('leftIndent') ? wRowFormat.leftIndent : undefined;
        return rowFormat;
    };
    SfdtExport.prototype.writeTableFormat = function (wTableFormat) {
        var tableFormat = {};
        tableFormat.borders = this.writeBorders(wTableFormat.borders);
        tableFormat.shading = this.writeShading(wTableFormat.shading);
        tableFormat.cellSpacing = wTableFormat.hasValue('cellSpacing') ? wTableFormat.cellSpacing : undefined;
        tableFormat.leftIndent = wTableFormat.hasValue('leftIndent') ? wTableFormat.leftIndent : undefined;
        tableFormat.tableAlignment = wTableFormat.hasValue('tableAlignment"') ? wTableFormat.tableAlignment : undefined;
        tableFormat.topMargin = wTableFormat.hasValue('topMargin') ? wTableFormat.topMargin : undefined;
        tableFormat.rightMargin = wTableFormat.hasValue('rightMargin') ? wTableFormat.rightMargin : undefined;
        tableFormat.leftMargin = wTableFormat.hasValue('leftMargin') ? wTableFormat.leftMargin : undefined;
        tableFormat.bottomMargin = wTableFormat.hasValue('bottomMargin') ? wTableFormat.bottomMargin : undefined;
        tableFormat.preferredWidth = wTableFormat.hasValue('preferredWidth') ? wTableFormat.preferredWidth : undefined;
        tableFormat.preferredWidthType = wTableFormat.hasValue('preferredWidthType') ? wTableFormat.preferredWidthType : undefined;
        tableFormat.bidi = wTableFormat.hasValue('bidi') ? wTableFormat.bidi : undefined;
        tableFormat.allowAutoFit = wTableFormat.hasValue('allowAutoFit') ? wTableFormat.allowAutoFit : undefined;
        return tableFormat;
    };
    SfdtExport.prototype.writeStyles = function (viewer) {
        this.document.styles = [];
        for (var i = 0; i < viewer.styles.length; i++) {
            this.document.styles.push(this.writeStyle(viewer.styles.getItem(i)));
        }
    };
    SfdtExport.prototype.writeStyle = function (style) {
        var wStyle = {};
        wStyle.name = style.name;
        if (style.type === 'Paragraph') {
            wStyle.type = 'Paragraph';
            wStyle.paragraphFormat = this.writeParagraphFormat(style.paragraphFormat);
            wStyle.characterFormat = this.writeCharacterFormat(style.characterFormat);
        }
        if (style.type === 'Character') {
            wStyle.type = 'Character';
            wStyle.characterFormat = this.writeCharacterFormat(style.characterFormat);
        }
        if (!isNullOrUndefined(style.basedOn)) {
            wStyle.basedOn = style.basedOn.name;
        }
        if (!isNullOrUndefined(style.link)) {
            wStyle.link = style.link.name;
        }
        if (!isNullOrUndefined(style.next)) {
            wStyle.next = style.next.name;
        }
        return wStyle;
    };
    SfdtExport.prototype.writeComments = function (viewer) {
        this.document.comments = [];
        for (var i = 0; i < viewer.comments.length; i++) {
            this.document.comments.push(this.writeComment(viewer.comments[i]));
        }
    };
    SfdtExport.prototype.writeComment = function (comments) {
        var comment = {};
        comment.commentId = comments.commentId;
        comment.author = comments.author;
        comment.date = comments.date;
        comment.blocks = [];
        comment.blocks.push(this.commentInlines(comments.text));
        comment.done = comments.isResolved;
        comment.replyComments = [];
        for (var i = 0; i < comments.replyComments.length; i++) {
            comment.replyComments.push(this.writeComment(comments.replyComments[i]));
        }
        return comment;
    };
    SfdtExport.prototype.commentInlines = function (ctext) {
        var blocks = {};
        blocks.inlines = [{ text: ctext }];
        return blocks;
    };
    SfdtExport.prototype.writeLists = function (viewer) {
        var abstractLists = [];
        this.document.lists = [];
        for (var i = 0; i < viewer.lists.length; i++) {
            var list = viewer.lists[i];
            if (this.lists.indexOf(list.listId) > -1) {
                this.document.lists.push(this.writeList(list));
                if (abstractLists.indexOf(list.abstractListId) < 0) {
                    abstractLists.push(list.abstractListId);
                }
            }
        }
        this.document.abstractLists = [];
        for (var i = 0; i < viewer.abstractLists.length; i++) {
            var abstractList = viewer.abstractLists[i];
            if (abstractLists.indexOf(abstractList.abstractListId) > -1) {
                this.document.abstractLists.push(this.writeAbstractList(abstractList));
            }
        }
    };
    SfdtExport.prototype.writeAbstractList = function (wAbstractList) {
        var abstractList = {};
        abstractList.abstractListId = wAbstractList.abstractListId;
        abstractList.levels = [];
        for (var i = 0; i < wAbstractList.levels.length; i++) {
            abstractList.levels[i] = this.writeListLevel(wAbstractList.levels[i]);
        }
        return abstractList;
    };
    SfdtExport.prototype.writeList = function (wList) {
        var list = {};
        list.abstractListId = wList.abstractListId;
        if (wList.levelOverrides.length > 0) {
            list.levelOverrides = wList.levelOverrides;
        }
        list.listId = wList.listId;
        return list;
    };
    SfdtExport.prototype.writeListLevel = function (wListLevel) {
        var listLevel = {};
        listLevel.characterFormat = this.writeCharacterFormat(wListLevel.characterFormat);
        listLevel.paragraphFormat = this.writeParagraphFormat(wListLevel.paragraphFormat);
        listLevel.followCharacter = wListLevel.followCharacter;
        listLevel.listLevelPattern = wListLevel.listLevelPattern;
        listLevel.numberFormat = wListLevel.numberFormat;
        listLevel.restartLevel = wListLevel.restartLevel;
        listLevel.startAt = wListLevel.startAt;
        return listLevel;
    };
    /**
     * @private
     */
    SfdtExport.prototype.destroy = function () {
        this.lists = undefined;
        this.endLine = undefined;
        this.endOffset = undefined;
        this.viewer = undefined;
    };
    return SfdtExport;
}());

/**
 * Export Export
 */

/**
 * The Hyperlink dialog is used to insert or edit hyperlink at selection.
 */
/* tslint:disable:max-line-length */
var HyperlinkDialog = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function HyperlinkDialog(viewer) {
        var _this = this;
        this.displayText = '';
        this.navigationUrl = undefined;
        this.bookmarkDropdown = undefined;
        this.bookmarkCheckbox = undefined;
        this.bookmarks = [];
        /**
         * @private
         */
        this.onKeyUpOnUrlBox = function (event) {
            if (event.keyCode === 13) {
                if (_this.displayTextBox.value !== '' && _this.urlTextBox.value !== '') {
                    _this.onInsertHyperlink();
                }
                return;
            }
            var selectedText = _this.owner.selection.text;
            var urlValue = _this.urlTextBox.value;
            if (urlValue.substring(0, 4).toLowerCase() === 'www.') {
                _this.urlTextBox.value = 'http://' + urlValue;
            }
            if (_this.displayText === '') {
                _this.displayTextBox.value = urlValue;
            }
            _this.enableOrDisableInsertButton();
        };
        /**
         * @private
         */
        this.onKeyUpOnDisplayBox = function () {
            _this.displayText = _this.displayTextBox.value;
            _this.enableOrDisableInsertButton();
        };
        /**
         * @private
         */
        this.onInsertButtonClick = function () {
            _this.onInsertHyperlink();
        };
        /**
         * @private
         */
        this.onCancelButtonClick = function () {
            _this.owner.dialog.hide();
            _this.clearValue();
        };
        /**
         * @private
         */
        this.loadHyperlinkDialog = function () {
            _this.owner.updateFocus();
            _this.bookmarks = [];
            for (var i = 0; i < _this.owner.bookmarks.keys.length; i++) {
                var bookmark = _this.owner.bookmarks.keys[i];
                if (bookmark.indexOf('_') !== 0) {
                    _this.bookmarks.push(bookmark);
                }
            }
            var fieldBegin = _this.owner.selection.getHyperlinkField();
            if (!isNullOrUndefined(fieldBegin)) {
                if (!isNullOrUndefined(fieldBegin.fieldSeparator)) {
                    var format = undefined;
                    // tslint:disable-next-line:max-line-length
                    var fieldObj = _this.owner.selection.getHyperlinkDisplayText(fieldBegin.fieldSeparator.line.paragraph, fieldBegin.fieldSeparator, fieldBegin.fieldEnd, false, format);
                    _this.displayText = fieldObj.displayText;
                    _this.displayTextBox.disabled = fieldObj.isNestedField;
                }
                _this.displayTextBox.value = _this.displayText;
                var link = _this.owner.selection.getLinkText(fieldBegin);
                _this.urlTextBox.value = _this.navigationUrl = link;
                _this.owner.dialog.header = _this.localObj.getConstant('Edit Hyperlink');
            }
            else {
                _this.displayText = _this.owner.selection.getText(true);
                if (_this.displayText !== '') {
                    if (_this.displayText.indexOf(String.fromCharCode(65532)) !== -1 ||
                        _this.displayText.indexOf('\r') !== -1 && (_this.displayText.lastIndexOf('\r') !== -1 &&
                            _this.displayText.slice(0, -1).indexOf('\r') !== -1)) {
                        _this.displayTextBox.value = '<<Selection in document>>';
                        _this.displayTextBox.disabled = true;
                    }
                    else {
                        _this.displayTextBox.value = _this.displayText;
                    }
                }
            }
            _this.bookmarkDiv.style.display = 'none';
            _this.addressText.style.display = 'block';
            _this.urlTextBox.style.display = 'block';
            _this.bookmarkCheckbox.checked = false;
            _this.bookmarkDropdown.dataSource = _this.owner.bookmarks.keys;
            _this.insertButton = document.getElementsByClassName('e-hyper-insert')[0];
            _this.enableOrDisableInsertButton();
            _this.urlTextBox.focus();
            if (_this.owner.selection.caret.style.display !== 'none') {
                _this.owner.selection.caret.style.display = 'none';
            }
        };
        /**
         * @private
         */
        this.closeHyperlinkDialog = function () {
            _this.clearValue();
            _this.owner.updateFocus();
        };
        /* tslint:disable:no-any */
        this.onUseBookmarkChange = function (args) {
            if (args.checked) {
                _this.bookmarkDiv.style.display = 'block';
                _this.bookmarkDropdown.dataSource = _this.bookmarks;
                _this.addressText.style.display = 'none';
                _this.urlTextBox.style.display = 'none';
            }
            else {
                _this.bookmarkDiv.style.display = 'none';
                _this.addressText.style.display = 'block';
                _this.urlTextBox.style.display = 'block';
            }
        };
        this.onBookmarkchange = function (args) {
            if (_this.bookmarkDropdown.value !== '') {
                _this.insertButton.disabled = false;
            }
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    HyperlinkDialog.prototype.getModuleName = function () {
        return 'HyperlinkDialog';
    };
    /**
     * @private
     */
    HyperlinkDialog.prototype.initHyperlinkDialog = function (localValue, isRtl) {
        var instance = this;
        var id = this.owner.owner.containerId + '_insert_hyperlink';
        this.target = createElement('div', { id: id, className: 'e-de-hyperlink' });
        var container = createElement('div');
        var displayText = createElement('div', { className: 'e-de-hyperlink-dlg-title', innerHTML: localValue.getConstant('Text to display') });
        this.displayTextBox = createElement('input', { id: this.owner.owner.containerId + '_display_text', className: 'e-input e-de-hyperlink-dlg-input' });
        this.displayTextBox.addEventListener('keyup', instance.onKeyUpOnDisplayBox);
        container.appendChild(displayText);
        container.appendChild(this.displayTextBox);
        this.addressText = createElement('div', { className: 'e-de-hyperlink-dlg-title', innerHTML: localValue.getConstant('Address') });
        this.urlTextBox = createElement('input', { id: this.owner.owner.containerId + '_url_text', className: 'e-input e-de-hyperlink-dlg-input', attrs: { autofocus: 'true' } });
        this.urlTextBox.addEventListener('input', instance.onKeyUpOnUrlBox);
        this.urlTextBox.addEventListener('keyup', instance.onKeyUpOnUrlBox);
        container.appendChild(this.addressText);
        container.appendChild(this.urlTextBox);
        this.bookmarkDiv = createElement('div', { styles: 'display:none;' });
        var bookmarkText = createElement('div', { className: 'e-de-hyperlink-dlg-title', innerHTML: localValue.getConstant('Bookmark') });
        var bookmarkTextElement = createElement('div', { className: 'e-de-hyperlink-dlg-bookmark' });
        // tslint:disable-next-line:max-line-length
        var bookmarkValue = createElement('input', { id: 'e-de-hyperlink-dlg-bookmark-value' });
        bookmarkTextElement.appendChild(bookmarkValue);
        // tslint:disable-next-line:max-line-length
        this.bookmarkDropdown = new DropDownList({ dataSource: [], change: this.onBookmarkchange, popupHeight: '230px', width: '230px', noRecordsTemplate: localValue.getConstant('No bookmarks found') });
        this.bookmarkDropdown.appendTo(bookmarkValue);
        this.bookmarkDiv.appendChild(bookmarkText);
        this.bookmarkDiv.appendChild(bookmarkTextElement);
        container.appendChild(this.bookmarkDiv);
        // tslint:disable-next-line:max-line-length
        var bookmarkCheckDiv = createElement('div', { className: 'e-de-hyperlink-bookmark-check e-de-hyperlink-dlg-title' });
        var bookmarkCheck = createElement('input', { attrs: { type: 'checkbox' }, id: this.target.id + '_bookmark', className: this.target.id + '_bookmarkcheck' });
        bookmarkCheckDiv.appendChild(bookmarkCheck);
        this.bookmarkCheckbox = new CheckBox({
            label: localValue.getConstant('Use bookmarks'),
            enableRtl: isRtl, change: this.onUseBookmarkChange
        });
        this.bookmarkCheckbox.appendTo(bookmarkCheck);
        container.appendChild(bookmarkCheckDiv);
        this.target.appendChild(container);
    };
    /**
     * @private
     */
    HyperlinkDialog.prototype.show = function () {
        this.localObj = new L10n('documenteditor', this.owner.owner.defaultLocale);
        this.localObj.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initHyperlinkDialog(this.localObj, this.owner.owner.enableRtl);
        }
        this.owner.dialog.header = this.localObj.getConstant('Insert Hyperlink');
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.buttons = [{
                click: this.onInsertButtonClick,
                buttonModel: { content: this.localObj.getConstant('Ok'), cssClass: 'e-flat e-hyper-insert', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: this.localObj.getConstant('Cancel'), cssClass: 'e-flat e-hyper-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.beforeOpen = this.loadHyperlinkDialog;
        this.owner.dialog.close = this.closeHyperlinkDialog;
        this.owner.dialog.show();
    };
    /**
     * @private
     */
    HyperlinkDialog.prototype.hide = function () {
        this.closeHyperlinkDialog();
    };
    HyperlinkDialog.prototype.enableOrDisableInsertButton = function () {
        if (!isNullOrUndefined(this.insertButton)) {
            // tslint:disable-next-line:max-line-length
            this.insertButton.disabled = (this.urlTextBox.value === '' || this.displayTextBox.value === '');
        }
    };
    /**
     * @private
     */
    HyperlinkDialog.prototype.onInsertHyperlink = function () {
        var displayText = this.displayTextBox.value.trim();
        var address = this.urlTextBox.value.trim();
        var isBookmark = false;
        if (!isNullOrUndefined(this.bookmarkDropdown.value) && this.bookmarkDropdown.value !== '') {
            address = this.bookmarkDropdown.value;
            isBookmark = true;
        }
        if (address === '') {
            this.owner.dialog.hide();
            return;
        }
        if (displayText === '' && address !== '') {
            displayText = address;
        }
        else {
            displayText = this.displayTextBox.value;
        }
        if (!isNullOrUndefined(this.navigationUrl)) {
            this.owner.owner.editorModule.editHyperlink(this.owner.selection, address, displayText, isBookmark);
        }
        else {
            var remove = this.owner.selection.text !== displayText && !this.displayTextBox.disabled;
            this.owner.owner.editorModule.insertHyperlinkInternal(address, displayText, remove, isBookmark);
        }
        this.owner.dialog.hide();
        this.navigationUrl = undefined;
    };
    /* tslint:enable:no-any */
    /**
     * @private
     */
    HyperlinkDialog.prototype.clearValue = function () {
        this.displayTextBox.value = '';
        this.urlTextBox.value = '';
        this.displayText = '';
        this.displayTextBox.disabled = false;
        this.bookmarks = [];
    };
    /**
     * @private
     */
    HyperlinkDialog.prototype.destroy = function () {
        if (this.displayTextBox) {
            this.displayTextBox.innerHTML = '';
            this.displayTextBox = undefined;
        }
        if (this.urlTextBox) {
            this.urlTextBox.parentElement.removeChild(this.urlTextBox);
            this.urlTextBox = undefined;
        }
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            this.target.innerHTML = '';
            this.target = undefined;
        }
    };
    return HyperlinkDialog;
}());

/**
 * The Table dialog is used to insert table at selection.
 */
var TableDialog = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function TableDialog(viewer) {
        var _this = this;
        /**
         * @private
         */
        this.keyUpInsertTable = function (event) {
            if (event.keyCode === 13) {
                if (_this.rowsCountBox.value !== '' && _this.columnsCountBox.value !== '') {
                    _this.onInsertTableClick();
                }
            }
        };
        /**
         * @private
         */
        this.onCancelButtonClick = function () {
            _this.owner.dialog.hide();
        };
        /**
         * @private
         */
        this.onInsertTableClick = function () {
            var rowCount = _this.rowValueTextBox.value;
            var columnCount = _this.columnValueTexBox.value;
            if (!(isNullOrUndefined(rowCount) && isNullOrUndefined(columnCount))) {
                _this.owner.owner.editor.insertTable(rowCount, columnCount);
            }
            _this.owner.dialog.hide();
        };
        this.owner = viewer;
    }
    TableDialog.prototype.getModuleName = function () {
        return 'TableDialog';
    };
    /**
     * @private
     */
    TableDialog.prototype.initTableDialog = function (localValue) {
        var instance = this;
        var id = this.owner.owner.containerId + '_insert_Table';
        this.target = createElement('div', { id: id, className: 'e-de-insert-table' });
        var parentDiv = createElement('div');
        var columnContainer = createElement('div', {
            className: 'e-de-insert-table-dlg-sub-header', innerHTML: localValue.getConstant('Number of columns')
        });
        var columnValue = createElement('div', { className: 'e-de-insert-table-dlg-input' });
        this.columnsCountBox = createElement('input', {
            attrs: { type: 'text' }, id: this.owner.owner.containerId + '_column'
        });
        columnValue.appendChild(this.columnsCountBox);
        var rowContainer = createElement('div', {
            className: 'e-de-insert-table-dlg-sub-header', innerHTML: localValue.getConstant('Number of rows')
        });
        var rowValue = createElement('div');
        this.rowsCountBox = createElement('input', {
            attrs: { type: 'text' }, id: this.owner.owner.containerId + 'row'
        });
        rowValue.appendChild(this.rowsCountBox);
        parentDiv.appendChild(columnContainer);
        parentDiv.appendChild(columnValue);
        parentDiv.appendChild(rowContainer);
        parentDiv.appendChild(rowValue);
        this.target.appendChild(parentDiv);
        this.columnsCountBox.addEventListener('keyup', instance.keyUpInsertTable);
        this.rowsCountBox.addEventListener('keyup', instance.keyUpInsertTable);
        this.rowValueTextBox = new NumericTextBox({
            format: '#',
            value: 2,
            min: 1,
            max: 32767,
            enablePersistence: false
        });
        this.rowValueTextBox.appendTo(this.rowsCountBox);
        this.columnValueTexBox = new NumericTextBox({
            format: '#',
            value: 2,
            min: 1,
            max: 63,
            enablePersistence: false
        });
        this.columnValueTexBox.appendTo(this.columnsCountBox);
    };
    /**
     * @private
     */
    TableDialog.prototype.show = function () {
        var localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localValue.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initTableDialog(localValue);
        }
        if (this.owner.selection.caret.style.display !== 'none') {
            this.owner.selection.caret.style.display = 'none';
        }
        this.owner.dialog.header = localValue.getConstant('Insert Table');
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.buttons = [{
                click: this.onInsertTableClick,
                buttonModel: { content: localValue.getConstant('Ok'), cssClass: 'e-flat e-table-ok', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: localValue.getConstant('Cancel'), cssClass: 'e-flat e-table-cancel' }
            }];
        this.rowValueTextBox.value = 2;
        this.columnValueTexBox.value = 2;
        this.owner.dialog.close = this.owner.updateFocus;
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    };
    /**
     * @private
     */
    TableDialog.prototype.destroy = function () {
        if (this.columnsCountBox) {
            if (this.columnsCountBox.parentElement) {
                this.columnsCountBox.parentElement.removeChild(this.columnsCountBox);
            }
            this.columnsCountBox = undefined;
        }
        if (this.rowsCountBox) {
            if (this.rowsCountBox.parentElement) {
                this.rowsCountBox.parentElement.removeChild(this.rowsCountBox);
            }
            this.rowsCountBox = undefined;
        }
        if (this.columnValueTexBox) {
            this.columnValueTexBox.destroy();
            this.columnValueTexBox = undefined;
        }
        if (this.rowValueTextBox) {
            this.rowValueTextBox.destroy();
            this.rowValueTextBox = undefined;
        }
        this.columnsCountBox = undefined;
        this.rowsCountBox = undefined;
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (var i = 0; i < this.target.childNodes.length; i++) {
                this.target.removeChild(this.target.childNodes[i]);
                i--;
            }
            this.target = undefined;
        }
    };
    return TableDialog;
}());

/**
 * The Bookmark dialog is used to add, navigate or delete bookmarks.
 */
var BookmarkDialog = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function BookmarkDialog(viewer) {
        var _this = this;
        /**
         * @private
         */
        this.onKeyUpOnTextBox = function (event) {
            _this.enableOrDisableButton();
        };
        this.addBookmark = function () {
            _this.owner.owner.editorModule.insertBookmark(_this.textBoxInput.value);
            _this.owner.dialog.hide();
        };
        /* tslint:disable:no-any */
        this.selectHandler = function (args) {
            _this.focusTextBox(args.text);
        };
        this.gotoBookmark = function () {
            _this.owner.selection.selectBookmark(_this.textBoxInput.value);
        };
        this.deleteBookmark = function () {
            _this.owner.owner.editorModule.deleteBookmark(_this.textBoxInput.value);
            _this.show();
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    BookmarkDialog.prototype.getModuleName = function () {
        return 'BookmarkDialog';
    };
    /**
     * @private
     */
    BookmarkDialog.prototype.initBookmarkDialog = function (localValue, bookmarks, isRtl) {
        var id = this.owner.owner.containerId + '_insert_bookmark';
        this.target = createElement('div', { id: id, className: 'e-de-bookmark' });
        var headerValue = localValue.getConstant('Bookmark name') + ':';
        var dlgFields = createElement('div', { innerHTML: headerValue, className: 'e-bookmark-dlgfields' });
        this.target.appendChild(dlgFields);
        var commonDiv = createElement('div', { className: 'e-bookmark-common' });
        this.target.appendChild(commonDiv);
        var searchDiv = createElement('div', { className: 'e-bookmark-list' });
        commonDiv.appendChild(searchDiv);
        if (isRtl) {
            searchDiv.classList.add('e-de-rtl');
        }
        var textBoxDiv = createElement('div', { className: 'e-bookmark-textboxdiv' });
        searchDiv.appendChild(textBoxDiv);
        // tslint:disable-next-line:max-line-length
        this.textBoxInput = createElement('input', { className: 'e-input e-bookmark-textbox-input', id: 'bookmark_text_box', attrs: { autofocus: 'true' } });
        this.textBoxInput.setAttribute('type', 'text');
        textBoxDiv.appendChild(this.textBoxInput);
        var listviewDiv = createElement('div', { className: 'e-bookmark-listViewDiv', id: 'bookmark_listview' });
        searchDiv.appendChild(listviewDiv);
        var arts = this.owner.bookmarks.keys;
        this.listviewInstance = new ListView({
            dataSource: bookmarks,
            cssClass: 'e-bookmark-listview',
        });
        var hasNoBookmark = (bookmarks === undefined || bookmarks.length === 0);
        this.listviewInstance.appendTo(listviewDiv);
        this.listviewInstance.addEventListener('select', this.selectHandler);
        var buttonDiv = createElement('div', { className: 'e-bookmark-button' });
        commonDiv.appendChild(buttonDiv);
        var addbuttonDiv = createElement('div', { className: 'e-bookmark-addbutton' });
        buttonDiv.appendChild(addbuttonDiv);
        var addButtonElement = createElement('button', {
            innerHTML: localValue.getConstant('Add'), id: 'add',
            attrs: { type: 'button' }
        });
        addbuttonDiv.appendChild(addButtonElement);
        this.addButton = new Button({ cssClass: 'e-button-custom' });
        this.addButton.disabled = true;
        this.addButton.appendTo(addButtonElement);
        this.textBoxInput.addEventListener('input', this.onKeyUpOnTextBox);
        this.textBoxInput.addEventListener('keyup', this.onKeyUpOnTextBox);
        addButtonElement.addEventListener('click', this.addBookmark);
        var deleteButtonDiv = createElement('div', { className: 'e-bookmark-deletebutton' });
        buttonDiv.appendChild(deleteButtonDiv);
        var deleteButtonElement = createElement('button', {
            innerHTML: localValue.getConstant('Delete'), id: 'delete',
            attrs: { type: 'button' }
        });
        deleteButtonDiv.appendChild(deleteButtonElement);
        this.deleteButton = new Button({ cssClass: 'e-button-custom' });
        this.deleteButton.disabled = hasNoBookmark;
        this.deleteButton.appendTo(deleteButtonElement);
        deleteButtonElement.addEventListener('click', this.deleteBookmark);
        var gotoButtonDiv = createElement('div', { className: 'e-bookmark-gotobutton' });
        buttonDiv.appendChild(gotoButtonDiv);
        var gotoButtonElement = createElement('button', {
            innerHTML: localValue.getConstant('Go To'), id: 'goto',
            attrs: { type: 'button' }
        });
        gotoButtonDiv.appendChild(gotoButtonElement);
        this.gotoButton = new Button({ cssClass: 'e-button-custom' });
        this.gotoButton.disabled = hasNoBookmark;
        this.gotoButton.appendTo(gotoButtonElement);
        gotoButtonElement.addEventListener('click', this.gotoBookmark);
    };
    /**
     * @private
     */
    BookmarkDialog.prototype.show = function () {
        var bookmarks = this.owner.getBookmarks();
        var localObj = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localObj.setLocale(this.owner.owner.locale);
        // if (!this.target) {
        this.initBookmarkDialog(localObj, bookmarks, this.owner.owner.enableRtl);
        //}
        this.owner.dialog.header = localObj.getConstant('Bookmark');
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.close = this.owner.updateFocus;
        this.owner.dialog.buttons = [{
                click: this.removeObjects.bind(this),
                buttonModel: { content: localObj.getConstant('Cancel'), cssClass: 'e-flat e-hyper-insert', isPrimary: true }
            }];
        this.owner.dialog.dataBind();
        var hasNoBookmark = (bookmarks === undefined || bookmarks.length === 0);
        if (!hasNoBookmark) {
            /* tslint:disable:no-any */
            var firstItem = bookmarks[0];
            this.listviewInstance.selectItem(firstItem);
        }
        this.owner.dialog.show();
    };
    BookmarkDialog.prototype.enableOrDisableButton = function () {
        if (!isNullOrUndefined(this.addButton)) {
            // tslint:disable-next-line:max-line-length
            this.addButton.disabled = (this.textBoxInput.value === '');
        }
    };
    /* tslint:disable:no-any */
    BookmarkDialog.prototype.focusTextBox = function (text) {
        this.textBoxInput.value = text;
        /* tslint:disable:no-any */
        var value = document.getElementById('bookmark_text_box');
        value.setSelectionRange(0, text.length);
        value.focus();
        this.enableOrDisableButton();
    };
    BookmarkDialog.prototype.removeObjects = function () {
        this.owner.dialog.hide();
    };
    /**
     * @private
     */
    BookmarkDialog.prototype.destroy = function () {
        if (this.textBoxInput) {
            this.textBoxInput.remove();
            this.textBoxInput = undefined;
        }
        if (this.listviewInstance) {
            this.listviewInstance.destroy();
            this.listviewInstance = undefined;
        }
    };
    return BookmarkDialog;
}());

/**
 * The Table of contents dialog is used to insert or edit table of contents at selection.
 */
var TableOfContentsDialog = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function TableOfContentsDialog(viewer) {
        var _this = this;
        this.styleLocaleValue = function (styleLocale, localValue) {
            var styleName = [];
            for (var index = 0; index < styleLocale.length; index++) {
                styleName.push(localValue.getConstant(styleLocale[index]));
            }
            return styleName;
        };
        /**
         * @private
         */
        this.loadTableofContentDialog = function () {
            _this.owner.updateFocus();
            _this.pageNumber.checked = true;
            _this.rightAlign.disabled = false;
            _this.rightAlign.checked = true;
            _this.tabLeader.enabled = true;
            _this.hyperlink.checked = true;
            _this.style.checked = true;
            _this.outline.checked = true;
            _this.outline.disabled = false;
            _this.showLevel.enabled = true;
        };
        /**
         * @private
         */
        this.closeTableOfContentDialog = function () {
            _this.unWireEventsAndBindings();
            _this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.onCancelButtonClick = function () {
            _this.owner.dialog.hide();
            _this.unWireEventsAndBindings();
        };
        /* tslint:disable:no-any */
        this.selectHandler = function (args) {
            _this.textBoxInput.value = args.text;
            /* tslint:disable:no-any */
            var value = document.getElementById('toclist');
            value.setSelectionRange(0, args.text.length);
            value.focus();
        };
        this.showStyleDialog = function () {
            if (!isNullOrUndefined(_this.owner.owner.styleDialogModule)) {
                _this.owner.owner.styleDialogModule.show(_this.textBoxInput.value);
            }
        };
        this.changeShowLevelValue = function (event) {
            var levels = event.value;
            var values = [];
            switch (levels) {
                case 1:
                    values = ['1', null, null, null, null, null, null, null, null];
                    _this.changeByValue(values);
                    break;
                case 2:
                    values = ['1', '2', null, null, null, null, null, null, null];
                    _this.changeByValue(values);
                    break;
                case 3:
                    values = ['1', '2', '3', null, null, null, null, null, null];
                    _this.changeByValue(values);
                    break;
                case 4:
                    values = ['1', '2', '3', '4', null, null, null, null, null];
                    _this.changeByValue(values);
                    break;
                case 5:
                    values = ['1', '2', '3', '4', '5', null, null, null, null];
                    _this.changeByValue(values);
                    break;
                case 6:
                    values = ['1', '2', '3', '4', '5', '6', null, null, null];
                    _this.changeByValue(values);
                    break;
                case 7:
                    values = ['1', '2', '3', '4', '5', '6', '7', null, null];
                    _this.changeByValue(values);
                    break;
                case 8:
                    values = ['1', '2', '3', '4', '5', '6', '7', '8', null];
                    _this.changeByValue(values);
                    break;
                case 9:
                    values = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
                    _this.changeByValue(values);
                    break;
            }
        };
        this.changeByValue = function (headings) {
            _this.heading1.value = headings[0];
            _this.heading2.value = headings[1];
            _this.heading3.value = headings[2];
            _this.heading4.value = headings[3];
            _this.heading5.value = headings[4];
            _this.heading6.value = headings[5];
            _this.heading7.value = headings[6];
            _this.heading8.value = headings[7];
            _this.heading9.value = headings[8];
        };
        this.reset = function () {
            _this.showLevel.enabled = true;
            _this.showLevel.value = 3;
            _this.outline.disabled = false;
            _this.outline.checked = true;
            var values = ['1', '2', '3', null, null, null, null, null, null];
            _this.changeByValue(values);
            _this.normal.value = null;
        };
        this.changeStyle = function (args) {
            var headingValue = args.srcElement.value;
            var value = _this.getElementValue(args.srcElement);
            if (headingValue !== value && headingValue !== '') {
                _this.showLevel.enabled = false;
            }
            else {
                _this.showLevel.enabled = true;
                _this.checkLevel();
            }
        };
        this.changeHeadingStyle = function (args) {
            var headingValue = args.srcElement.value;
            if (headingValue === '') {
                _this.showLevel.enabled = true;
            }
            else {
                _this.showLevel.enabled = false;
            }
            if (_this.normal === args.srcElement) {
                _this.outline.checked = false;
                _this.outline.disabled = true;
            }
        };
        /**
         * @private
         */
        this.changePageNumberValue = function (args) {
            if (args.checked) {
                _this.rightAlign.checked = true;
                _this.rightAlign.disabled = false;
                _this.tabLeader.enabled = true;
            }
            else {
                _this.rightAlign.disabled = true;
                _this.tabLeader.enabled = false;
            }
        };
        /**
         * @private
         */
        this.changeRightAlignValue = function (args) {
            if (args.checked) {
                _this.tabLeader.enabled = true;
            }
            else {
                _this.tabLeader.enabled = false;
            }
        };
        /**
         * @private
         */
        this.changeStyleValue = function (args) {
            if (args.checked) {
                _this.heading1.disabled = false;
                _this.heading2.disabled = false;
                _this.heading3.disabled = false;
                _this.heading4.disabled = false;
                _this.heading5.disabled = false;
                _this.heading6.disabled = false;
                _this.heading7.disabled = false;
                _this.heading8.disabled = false;
                _this.heading9.disabled = false;
                _this.normal.disabled = false;
            }
            else {
                _this.heading1.disabled = true;
                _this.heading2.disabled = true;
                _this.heading3.disabled = true;
                _this.heading4.disabled = true;
                _this.heading5.disabled = true;
                _this.heading6.disabled = true;
                _this.heading7.disabled = true;
                _this.heading8.disabled = true;
                _this.heading9.disabled = true;
                _this.normal.disabled = true;
            }
        };
        /**
         * @private
         */
        this.applyTableOfContentProperties = function () {
            var tocSettings = {
                startLevel: 1,
                endLevel: _this.showLevel.value,
                includeHyperlink: _this.hyperlink.checked,
                includePageNumber: _this.pageNumber.checked,
                rightAlign: _this.rightAlign.checked,
                tabLeader: _this.tabLeader.value,
                includeOutlineLevels: _this.outline.checked
            };
            _this.applyLevelSetting(tocSettings);
            _this.owner.owner.editorModule.insertTableOfContents(tocSettings);
            _this.owner.dialog.hide();
        };
        /**
         * @private
         */
        this.unWireEventsAndBindings = function () {
            _this.pageNumber.checked = false;
            _this.rightAlign.checked = false;
            _this.tabLeader.value = '';
            _this.hyperlink.checked = false;
            _this.style.checked = false;
            _this.outline.checked = false;
            _this.normal.value = '';
        };
        this.owner = viewer;
    }
    TableOfContentsDialog.prototype.getModuleName = function () {
        return 'TableOfContentsDialog';
    };
    /*tslint:disable max-func-body-length*/
    /**
     * @private
     */
    TableOfContentsDialog.prototype.initTableOfContentDialog = function (locale, isRtl) {
        var ownerId = this.owner.owner.containerId;
        var id = ownerId + '_toc_dialog';
        this.target = createElement('div', { id: id, className: 'e-de-toc-dlg-container' });
        // tslint:disable-next-line:max-line-length
        var generalDiv = createElement('div', { id: 'general_div', className: 'e-de-toc-dlg-sub-container' });
        this.target.appendChild(generalDiv);
        // tslint:disable-next-line:max-line-length
        var genLabel = createElement('div', { id: ownerId + '_genLabel', className: 'e-de-toc-dlg-main-heading', styles: 'margin-bottom: 13px;', innerHTML: locale.getConstant('General') });
        generalDiv.appendChild(genLabel);
        var leftGeneralDivStyles;
        var rightBottomGeneralDivStyles;
        if (isRtl) {
            leftGeneralDivStyles = 'float:right;';
            rightBottomGeneralDivStyles = 'float:left;position:relative;';
        }
        else {
            leftGeneralDivStyles = 'float:left;';
            rightBottomGeneralDivStyles = 'float:right;';
        }
        // tslint:disable-next-line:max-line-length
        var topContainer = createElement('div', { id: 'general_top_container', styles: 'display:inline-flex' });
        var leftGeneralDiv = createElement('div', { id: 'left_general', styles: leftGeneralDivStyles + 'position:relative;' });
        topContainer.appendChild(leftGeneralDiv);
        // tslint:disable-next-line:max-line-length
        var rightGeneralDiv = createElement('div', { className: 'e-de-toc-dlg-right-general-div' });
        topContainer.appendChild(rightGeneralDiv);
        generalDiv.appendChild(topContainer);
        // tslint:disable-next-line:max-line-length
        var bottomContainer = createElement('div', { id: 'general_bottom_container', styles: 'display:inline-flex' });
        var leftBottomGeneralDiv = createElement('div', { id: 'leftBottom_general', styles: 'float:left;' });
        bottomContainer.appendChild(leftBottomGeneralDiv);
        // tslint:disable-next-line:max-line-length
        var rightBottomGeneralDiv = createElement('div', { className: 'e-de-toc-dlg-right-sub-container', styles: rightBottomGeneralDivStyles });
        bottomContainer.appendChild(rightBottomGeneralDiv);
        generalDiv.appendChild(bottomContainer);
        // tslint:disable-next-line:max-line-length
        var pageNumberDiv = createElement('div', { id: 'pageNumber_div', className: 'e-de-toc-dlg-sub-container' });
        var pageNumber = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_pageNumber'
        });
        pageNumberDiv.appendChild(pageNumber);
        // tslint:disable-next-line:max-line-length
        var rightAlignDiv = createElement('div', { id: 'rightAlign_div', className: 'e-de-toc-dlg-sub-container' });
        var rightAlign = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_rightAlign'
        });
        rightAlignDiv.appendChild(rightAlign);
        // tslint:disable-next-line:max-line-length
        this.pageNumber = new CheckBox({ label: locale.getConstant('Show page numbers'), enableRtl: isRtl, checked: true, change: this.changePageNumberValue });
        // tslint:disable-next-line:max-line-length
        this.rightAlign = new CheckBox({ label: locale.getConstant('Right align page numbers'), enableRtl: isRtl, checked: true, change: this.changeRightAlignValue });
        this.pageNumber.appendTo(pageNumber);
        this.rightAlign.appendTo(rightAlign);
        var tabDiv = createElement('div', { id: 'tab_div', className: 'e-de-toc-dlg-tab-div' });
        // tslint:disable-next-line:max-line-length
        var tabLeaderLabelDiv = createElement('div', { id: 'tabLeaderLabel_div' });
        // tslint:disable-next-line:max-line-length
        var tabLeaderLabel = createElement('label', { id: ownerId + '_tabLeaderLabel', className: 'e-de-toc-dlg-heading', innerHTML: locale.getConstant('Tab leader') + ':' });
        tabLeaderLabelDiv.appendChild(tabLeaderLabel);
        var tabLeaderDiv = createElement('div', { id: 'tabLeader_div' });
        var tabLeader = createElement('select', {
            id: ownerId + '_tabLeader',
            innerHTML: '<option value="None">' + '(' + locale.getConstant('None').toLocaleLowerCase() + ')' +
                '</option><option value="Dot" selected>' + '....................' +
                '</option><option value="Hyphen">' + '-------------------' +
                '</option><option value="Underscore">' + '____________' + '</option>'
        });
        tabLeaderDiv.appendChild(tabLeader);
        tabDiv.appendChild(tabLeaderLabelDiv);
        tabDiv.appendChild(tabLeaderDiv);
        leftGeneralDiv.appendChild(pageNumberDiv);
        leftGeneralDiv.appendChild(rightAlignDiv);
        leftGeneralDiv.appendChild(tabDiv);
        this.tabLeader = new DropDownList({ width: 210, enableRtl: isRtl });
        this.tabLeader.appendTo(tabLeader);
        var hyperlink = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_hyperlink'
        });
        rightGeneralDiv.appendChild(hyperlink);
        //tslint:disable-next-line:max-line-length
        this.hyperlink = new CheckBox({ label: locale.getConstant('Use hyperlinks instead of page numbers'), cssClass: 'e-de-toc-label', enableRtl: isRtl, checked: true });
        this.hyperlink.appendTo(hyperlink);
        // tslint:disable-next-line:max-line-length
        var showDiv = createElement('div', { id: 'show_div', className: 'e-de-toc-dlg-style-label' });
        // tslint:disable-next-line:max-line-length
        var showLevelLabelDiv = createElement('div', { id: 'showLevelLabel_div', className: 'e-de-toc-dlg-show-level-div' });
        // tslint:disable-next-line:max-line-length
        var showLevelLabel = createElement('label', { id: ownerId + '_showLevelLabel', className: 'e-de-toc-dlg-heading', innerHTML: locale.getConstant('Show levels') + ':' });
        showLevelLabelDiv.appendChild(showLevelLabel);
        // tslint:disable-next-line:max-line-length
        var showLevelDiv = createElement('div', { id: 'showLevel_div', className: 'e-de-toc-dlg-showlevel-div' });
        // tslint:disable-next-line:max-line-length
        var showLevel = createElement('input', { id: ownerId + '_showLevel', attrs: { 'type': 'text' } });
        showLevelDiv.appendChild(showLevel);
        showDiv.appendChild(showLevelLabelDiv);
        showDiv.appendChild(showLevelDiv);
        rightGeneralDiv.appendChild(showDiv);
        this.showLevel = new NumericTextBox({ format: '#', value: 3, min: 1, max: 9, width: 210, change: this.changeShowLevelValue });
        this.showLevel.appendTo(showLevel);
        if (isRtl) {
            this.hyperlink.cssClass = 'e-de-toc-label-rtl';
            showLevelLabelDiv.classList.add('e-de-rtl');
            showLevelDiv.classList.add('e-de-rtl');
            rightBottomGeneralDiv.classList.add('e-de-rtl');
        }
        // tslint:disable-next-line:max-line-length
        var buildTableDiv = createElement('div', { id: 'buildTable_div', className: 'e-de-toc-dlg-sub-container' });
        // tslint:disable-next-line:max-line-length
        var buildTableLabel = createElement('div', { id: ownerId + '_buildTableLabel', className: 'e-de-toc-dlg-main-heading e-de-toc-dlg-build-table', styles: 'margin-bottom: 13px;', innerHTML: locale.getConstant('Build table of contents from') + ':' });
        leftBottomGeneralDiv.appendChild(buildTableDiv);
        leftBottomGeneralDiv.appendChild(buildTableLabel);
        var style = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_style',
        });
        leftBottomGeneralDiv.appendChild(style);
        this.style = new CheckBox({ label: locale.getConstant('Styles'), enableRtl: isRtl, checked: true, change: this.changeStyleValue });
        this.style.appendTo(style);
        var table = createElement('TABLE', { styles: 'margin-top:3px;' });
        var tr1 = createElement('tr');
        var td1 = createElement('td', { styles: 'width:120px;padding-left:10px;' });
        var availableLabel = createElement('label', {
            // tslint:disable-next-line:max-line-length
            innerHTML: locale.getConstant('Available styles'), className: 'e-de-toc-dlg-main-heading e-de-toc-dlg-sub-level-heading', id: this.target.id + '_availableLabel'
        });
        td1.appendChild(availableLabel);
        var td2 = createElement('td');
        var tocLabel = createElement('label', {
            innerHTML: locale.getConstant('TOC level') + ':', className: 'e-de-toc-dlg-main-heading e-de-toc-dlg-sub-level-heading',
            id: this.target.id + '_tocLabel'
        });
        td2.appendChild(tocLabel);
        tr1.appendChild(td1);
        tr1.appendChild(td2);
        table.appendChild(tr1);
        // tslint:disable-next-line:max-line-length
        var tableDiv = createElement('div', { id: 'table_div', className: 'e-de-toc-table-div' });
        var table1 = createElement('TABLE');
        var tr2 = createElement('tr');
        var td3 = createElement('td');
        var heading1Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 1',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading1Label'
        });
        td3.appendChild(heading1Label);
        var td4 = createElement('td');
        this.heading1 = createElement('input', { id: '_heading1', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading1.value = '1';
        this.heading1.addEventListener('keyup', this.changeStyle);
        td4.appendChild(this.heading1);
        tr2.appendChild(td3);
        tr2.appendChild(td4);
        var tr3 = createElement('tr');
        var td5 = createElement('td');
        var heading2Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 2',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading2Label'
        });
        td5.appendChild(heading2Label);
        var td6 = createElement('td');
        this.heading2 = createElement('input', { id: '_heading2', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading2.value = '2';
        this.heading2.addEventListener('keyup', this.changeStyle);
        td6.appendChild(this.heading2);
        tr3.appendChild(td5);
        tr3.appendChild(td6);
        var tr4 = createElement('tr');
        var td7 = createElement('td');
        var heading3Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 3',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading3Label'
        });
        td7.appendChild(heading3Label);
        var td8 = createElement('td');
        this.heading3 = createElement('input', { id: '_heading3', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading3.value = '3';
        this.heading3.addEventListener('keyup', this.changeStyle);
        td8.appendChild(this.heading3);
        tr4.appendChild(td7);
        tr4.appendChild(td8);
        var tr5 = createElement('tr');
        var td9 = createElement('td');
        var heading4Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 4',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading4Label'
        });
        td9.appendChild(heading4Label);
        var td10 = createElement('td');
        this.heading4 = createElement('input', { id: '_heading4', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading4.addEventListener('keyup', this.changeStyle);
        td10.appendChild(this.heading4);
        tr5.appendChild(td9);
        tr5.appendChild(td10);
        var tr6 = createElement('tr');
        var td11 = createElement('td');
        var heading5Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 5',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading5Label'
        });
        td11.appendChild(heading5Label);
        var td12 = createElement('td');
        this.heading5 = createElement('input', { id: '_heading5', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading5.addEventListener('keyup', this.changeStyle);
        td12.appendChild(this.heading5);
        tr6.appendChild(td11);
        tr6.appendChild(td12);
        var tr7 = createElement('tr');
        var td13 = createElement('td');
        var heading6Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 6',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading6Label'
        });
        td13.appendChild(heading6Label);
        var td14 = createElement('td');
        this.heading6 = createElement('input', { id: '_heading6', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading6.addEventListener('keyup', this.changeStyle);
        td14.appendChild(this.heading6);
        tr7.appendChild(td13);
        tr7.appendChild(td14);
        var tr8 = createElement('tr');
        var td15 = createElement('td');
        var heading7Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 7',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading7Label'
        });
        td15.appendChild(heading7Label);
        var td16 = createElement('td');
        this.heading7 = createElement('input', { id: '_heading7', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading7.addEventListener('keyup', this.changeStyle);
        td16.appendChild(this.heading7);
        tr8.appendChild(td15);
        tr8.appendChild(td16);
        var tr9 = createElement('tr');
        var td17 = createElement('td');
        var heading8Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 8',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading8Label'
        });
        td17.appendChild(heading8Label);
        var td18 = createElement('td');
        this.heading8 = createElement('input', { id: '_heading8', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading8.addEventListener('keyup', this.changeStyle);
        td18.appendChild(this.heading8);
        tr9.appendChild(td17);
        tr9.appendChild(td18);
        var tr10 = createElement('tr');
        var td19 = createElement('td');
        var heading9Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 9',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading9Label'
        });
        td19.appendChild(heading9Label);
        var td20 = createElement('td');
        this.heading9 = createElement('input', { id: '_heading9', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading9.addEventListener('keyup', this.changeStyle);
        td20.appendChild(this.heading9);
        tr10.appendChild(td19);
        tr10.appendChild(td20);
        var tr12 = createElement('tr');
        var td23 = createElement('td');
        var normalLabel = createElement('label', {
            innerHTML: locale.getConstant('Normal'),
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_normalLabel'
        });
        td23.appendChild(normalLabel);
        var td24 = createElement('td');
        this.normal = createElement('input', { id: '_normal', className: 'e-input e-de-toc-dlg-toc-level' });
        this.normal.addEventListener('keyup', this.changeHeadingStyle);
        td24.appendChild(this.normal);
        tr12.appendChild(td23);
        tr12.appendChild(td24);
        if (isRtl) {
            this.normal.classList.add('e-de-rtl');
            this.heading1.classList.add('e-de-rtl');
            this.heading2.classList.add('e-de-rtl');
            this.heading3.classList.add('e-de-rtl');
            this.heading4.classList.add('e-de-rtl');
            this.heading5.classList.add('e-de-rtl');
            this.heading6.classList.add('e-de-rtl');
            this.heading7.classList.add('e-de-rtl');
            this.heading8.classList.add('e-de-rtl');
            this.heading9.classList.add('e-de-rtl');
        }
        table1.appendChild(tr2);
        table1.appendChild(tr3);
        table1.appendChild(tr4);
        table1.appendChild(tr5);
        table1.appendChild(tr6);
        table1.appendChild(tr7);
        table1.appendChild(tr8);
        table1.appendChild(tr9);
        table1.appendChild(tr10);
        table1.appendChild(tr12);
        tableDiv.appendChild(table1);
        var stylesLevelDiv = createElement('div', { className: 'e-de-toc-styles-table-div' });
        stylesLevelDiv.appendChild(table);
        stylesLevelDiv.appendChild(tableDiv);
        leftBottomGeneralDiv.appendChild(stylesLevelDiv);
        //leftBottomGeneralDiv.appendChild(table); leftBottomGeneralDiv.appendChild(tableDiv);
        var fieldsDiv = createElement('div', { id: 'fields_div', styles: 'display: flex;' });
        leftBottomGeneralDiv.appendChild(fieldsDiv);
        var outDiv = createElement('div', { id: 'out_div' });
        // tslint:disable-next-line:max-line-length
        var outlineDiv = createElement('div', { id: 'outline_div', className: 'e-de-toc-dlg-sub-container e-de-toc-dlg-outline-levels' });
        var outline = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: '_outline'
        });
        outlineDiv.appendChild(outline);
        outDiv.appendChild(outlineDiv);
        fieldsDiv.appendChild(outDiv);
        this.outline = new CheckBox({
            label: locale.getConstant('Outline levels'),
            enableRtl: isRtl, checked: true, cssClass: 'e-de-outline-rtl'
        });
        this.outline.appendTo(outline);
        var resetButtonDiv = createElement('div', { className: 'e-de-toc-reset-button' });
        fieldsDiv.appendChild(resetButtonDiv);
        var resetElement = createElement('button', {
            innerHTML: locale.getConstant('Reset'), id: 'reset',
            attrs: { type: 'button' }
        });
        resetButtonDiv.appendChild(resetElement);
        var resetButton = new Button({ cssClass: 'e-btn e-flat' });
        resetButton.appendTo(resetElement);
        resetElement.addEventListener('click', this.reset);
        // tslint:disable-next-line:max-line-length
        var tocStylesDiv = createElement('div', { id: 'tocStyles_div', className: 'e-de-toc-dlg-sub-container' });
        // tslint:disable-next-line:max-line-length
        var tocStylesLabel = createElement('div', {
            id: ownerId + '_tocStylesLabel', className: 'e-de-toc-dlg-main-heading e-de-toc-dlg-styles',
            innerHTML: locale.getConstant('Styles') + ':'
        });
        rightBottomGeneralDiv.appendChild(tocStylesDiv);
        rightBottomGeneralDiv.appendChild(tocStylesLabel);
        var textBoxDiv = createElement('div', { className: 'e-de-toc-dlg-style-input' });
        rightBottomGeneralDiv.appendChild(textBoxDiv);
        this.textBoxInput = createElement('input', { className: 'e-input', id: 'toclist' });
        this.textBoxInput.setAttribute('type', 'text');
        textBoxDiv.appendChild(this.textBoxInput);
        var listViewDiv = createElement('div', { className: 'e-de-toc-list-view' });
        var styleLocale = ['TOC 1', 'TOC 2', 'TOC 3', 'TOC 4', 'TOC 5', 'TOC 6', 'TOC 7', 'TOC 8', 'TOC 9'];
        var styleValues = this.styleLocaleValue(styleLocale, locale);
        this.listViewInstance = new ListView({ dataSource: styleValues, cssClass: 'e-toc-list-view' });
        this.listViewInstance.appendTo(listViewDiv);
        this.listViewInstance.addEventListener('select', this.selectHandler);
        rightBottomGeneralDiv.appendChild(listViewDiv);
        var modifyButtonDiv = createElement('div', { className: 'e-de-toc-modify-button' });
        rightBottomGeneralDiv.appendChild(modifyButtonDiv);
        var modifyElement = createElement('button', {
            innerHTML: locale.getConstant('Modify'), id: 'modify',
            attrs: { type: 'button' }
        });
        modifyButtonDiv.appendChild(modifyElement);
        var modifyButton = new Button({ cssClass: 'e-btn e-flat' });
        modifyButton.appendTo(modifyElement);
        modifyElement.addEventListener('click', this.showStyleDialog);
        if (isRtl) {
            resetButtonDiv.classList.add('e-de-rtl');
            tocStylesLabel.classList.add('e-de-rtl');
            textBoxDiv.classList.add('e-de-rtl');
            listViewDiv.classList.add('e-de-rtl');
            modifyButtonDiv.classList.add('e-de-rtl');
        }
    };
    /**
     * @private
     */
    TableOfContentsDialog.prototype.show = function () {
        var localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localValue.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initTableOfContentDialog(localValue, this.owner.owner.enableRtl);
        }
        this.owner.dialog.header = localValue.getConstant('Table of Contents');
        this.owner.dialog.width = 'auto';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.loadTableofContentDialog;
        this.owner.dialog.close = this.closeTableOfContentDialog;
        this.owner.dialog.buttons = [{
                click: this.applyTableOfContentProperties,
                buttonModel: { content: localValue.getConstant('Ok'), cssClass: 'e-flat e-toc-okay', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: localValue.getConstant('Cancel'), cssClass: 'e-flat e-toc-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    };
    TableOfContentsDialog.prototype.checkLevel = function () {
        if (this.heading1.value !== '') {
            this.showLevel.value = 1;
        }
        if (this.heading2.value !== '') {
            this.showLevel.value = 2;
        }
        if (this.heading3.value !== '') {
            this.showLevel.value = 3;
        }
        if (this.heading4.value !== '') {
            this.showLevel.value = 4;
        }
        if (this.heading5.value !== '') {
            this.showLevel.value = 5;
        }
        if (this.heading6.value !== '') {
            this.showLevel.value = 6;
        }
        if (this.heading7.value !== '') {
            this.showLevel.value = 7;
        }
        if (this.heading8.value !== '') {
            this.showLevel.value = 8;
        }
        if (this.heading9.value !== '') {
            this.showLevel.value = 9;
        }
    };
    TableOfContentsDialog.prototype.getElementValue = function (element) {
        switch (element) {
            case this.heading1:
                return '1';
            case this.heading2:
                return '2';
            case this.heading3:
                return '3';
            case this.heading4:
                return '4';
            case this.heading5:
                return '5';
            case this.heading6:
                return '6';
            case this.heading7:
                return '7';
            case this.heading8:
                return '8';
            case this.heading9:
                return '9';
            default:
                return '1';
        }
    };
    TableOfContentsDialog.prototype.getHeadingLevel = function (index) {
        switch (index) {
            case 1:
                return parseInt(this.heading1.value);
            case 2:
                return parseInt(this.heading2.value);
            case 3:
                return parseInt(this.heading3.value);
            case 4:
                return parseInt(this.heading4.value);
            case 5:
                return parseInt(this.heading5.value);
            case 6:
                return parseInt(this.heading6.value);
            case 7:
                return parseInt(this.heading7.value);
            case 8:
                return parseInt(this.heading8.value);
            case 9:
                return parseInt(this.heading9.value);
            default:
                return 0;
        }
    };
    TableOfContentsDialog.prototype.applyLevelSetting = function (tocSettings) {
        tocSettings.levelSettings = {};
        var headingPrefix = 'Heading ';
        var newStartLevel = 0;
        var newEndLevel = 0;
        var isEndLevel = false;
        for (var i = 1; i <= tocSettings.endLevel; i++) {
            var outlineLevel = this.getHeadingLevel(i);
            if (i === outlineLevel) {
                if (newStartLevel === 0) {
                    newStartLevel = i;
                    isEndLevel = false;
                }
                if (!isEndLevel) {
                    newEndLevel = i;
                }
            }
            else {
                isEndLevel = true;
                if (outlineLevel !== 0) {
                    var headingStyle = headingPrefix + i.toString();
                    tocSettings.levelSettings[headingStyle] = outlineLevel;
                }
            }
        }
        tocSettings.startLevel = newStartLevel;
        tocSettings.endLevel = newEndLevel;
        if (this.normal.value !== '') {
            tocSettings.levelSettings['Normal'] = +this.normal.value;
        }
    };
    /**
     * @private
     */
    TableOfContentsDialog.prototype.destroy = function () {
        if (this.pageNumber) {
            this.pageNumber.destroy();
            this.pageNumber = undefined;
        }
        if (this.rightAlign) {
            this.rightAlign.destroy();
            this.rightAlign = undefined;
        }
        if (this.tabLeader) {
            this.tabLeader.destroy();
            this.tabLeader = undefined;
        }
        if (this.showLevel) {
            this.showLevel.destroy();
            this.showLevel = undefined;
        }
        if (this.hyperlink) {
            this.hyperlink.destroy();
            this.hyperlink = undefined;
        }
        if (this.style) {
            this.style.destroy();
            this.style = undefined;
        }
        if (this.outline) {
            this.outline.destroy();
            this.outline = undefined;
        }
        if (this.listViewInstance) {
            this.listViewInstance.destroy();
            this.listViewInstance = undefined;
        }
        this.heading1 = undefined;
        this.heading2 = undefined;
        this.heading3 = undefined;
        this.heading4 = undefined;
        this.heading5 = undefined;
        this.heading6 = undefined;
        this.heading7 = undefined;
        this.heading8 = undefined;
        this.heading9 = undefined;
        this.normal = undefined;
        this.textBoxInput = undefined;
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (var count = 0; count < this.target.childNodes.length; count++) {
                this.target.removeChild(this.target.childNodes[count]);
                count--;
            }
            this.target = undefined;
        }
    };
    return TableOfContentsDialog;
}());

/**
 * The Page setup dialog is used to modify formatting of selected sections.
 */
var PageSetupDialog = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function PageSetupDialog(viewer) {
        var _this = this;
        this.isPortrait = true;
        /**
         * @private
         */
        this.loadPageSetupDialog = function () {
            _this.owner.updateFocus();
            var sectionFormat = _this.owner.selection.sectionFormat;
            _this.topMarginBox.value = sectionFormat.topMargin;
            _this.leftMarginBox.value = sectionFormat.leftMargin;
            _this.bottomMarginBox.value = sectionFormat.bottomMargin;
            _this.rightMarginBox.value = sectionFormat.rightMargin;
            _this.widthBox.value = sectionFormat.pageWidth;
            _this.heightBox.value = sectionFormat.pageHeight;
            _this.checkBox1.checked = sectionFormat.differentOddAndEvenPages;
            _this.checkBox2.checked = sectionFormat.differentFirstPage;
            _this.headerBox.value = sectionFormat.headerDistance;
            _this.footerBox.value = sectionFormat.footerDistance;
            if (_this.widthBox.value > _this.heightBox.value) {
                _this.landscape.checked = true;
            }
            else {
                _this.portrait.checked = true;
            }
            _this.setPageSize(_this.portrait.checked, sectionFormat.pageWidth, sectionFormat.pageHeight);
        };
        /**
         * @private
         */
        this.closePageSetupDialog = function () {
            _this.unWireEventsAndBindings();
            _this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.onCancelButtonClick = function () {
            _this.owner.dialog.hide();
            _this.unWireEventsAndBindings();
        };
        /**
         * @private
         */
        this.keyUpInsertPageSettings = function (event) {
            if (event.keyCode === 13) {
                _this.applyPageSetupProperties();
            }
        };
        /**
         * @private
         */
        this.applyPageSetupProperties = function () {
            var sectionFormat = new WSectionFormat();
            sectionFormat.bottomMargin = _this.bottomMarginBox.value;
            sectionFormat.topMargin = _this.topMarginBox.value;
            sectionFormat.leftMargin = _this.leftMarginBox.value;
            sectionFormat.rightMargin = _this.rightMarginBox.value;
            sectionFormat.pageWidth = _this.widthBox.value;
            sectionFormat.pageHeight = _this.heightBox.value;
            sectionFormat.differentOddAndEvenPages = _this.checkBox1.checked;
            sectionFormat.differentFirstPage = _this.checkBox2.checked;
            sectionFormat.headerDistance = _this.headerBox.value;
            sectionFormat.footerDistance = _this.footerBox.value;
            _this.owner.owner.editorModule.onApplySectionFormat(undefined, sectionFormat);
            _this.owner.dialog.hide();
        };
        /**
         * @private
         */
        this.changeByPaperSize = function (event) {
            var value = event.value;
            var sectionFormat = _this.owner.selection.sectionFormat;
            var width = sectionFormat.pageWidth;
            var height = sectionFormat.pageHeight;
            if (_this.owner.selection.sectionFormat.pageWidth > _this.owner.selection.sectionFormat.pageHeight || _this.landscape.checked) {
                _this.isPortrait = false;
            }
            else {
                _this.isPortrait = true;
            }
            if (value === 'letter') {
                if (_this.isPortrait) {
                    _this.widthBox.value = 612;
                    _this.heightBox.value = 792;
                }
                else {
                    _this.widthBox.value = 792;
                    _this.heightBox.value = 612;
                }
            }
            else if (value === 'tabloid') {
                if (_this.isPortrait) {
                    _this.widthBox.value = 792;
                    _this.heightBox.value = 1224;
                }
                else {
                    _this.widthBox.value = 1224;
                    _this.heightBox.value = 792;
                }
            }
            else if (value === 'legal') {
                if (_this.isPortrait) {
                    _this.widthBox.value = 612;
                    _this.heightBox.value = 1008;
                }
                else {
                    _this.widthBox.value = 1008;
                    _this.heightBox.value = 612;
                }
            }
            else if (value === 'statement') {
                if (_this.isPortrait) {
                    _this.widthBox.value = 392;
                    _this.heightBox.value = 612;
                }
                else {
                    _this.widthBox.value = 612;
                    _this.heightBox.value = 392;
                }
            }
            else if (value === 'executive') {
                if (_this.isPortrait) {
                    _this.widthBox.value = 522;
                    _this.heightBox.value = 756;
                }
                else {
                    _this.widthBox.value = 756;
                    _this.heightBox.value = 522;
                }
            }
            else if (value === 'a3') {
                if (_this.isPortrait) {
                    _this.widthBox.value = 841.9;
                    _this.heightBox.value = 1190.55;
                }
                else {
                    _this.widthBox.value = 1190.55;
                    _this.heightBox.value = 841.9;
                }
            }
            else if (value === 'a4') {
                if (_this.isPortrait) {
                    _this.widthBox.value = 595.3;
                    _this.heightBox.value = 841.9;
                }
                else {
                    _this.widthBox.value = 841.9;
                    _this.heightBox.value = 595.3;
                }
            }
            else if (value === 'a5') {
                if (_this.isPortrait) {
                    _this.widthBox.value = 419.55;
                    _this.heightBox.value = 595.3;
                }
                else {
                    _this.widthBox.value = 595.3;
                    _this.heightBox.value = 419.55;
                }
            }
            else if (value === 'b4') {
                if (_this.isPortrait) {
                    _this.widthBox.value = 728.5;
                    _this.heightBox.value = 1031.8;
                }
                else {
                    _this.widthBox.value = 1031.8;
                    _this.heightBox.value = 728.5;
                }
            }
            else if (value === 'b5') {
                if (_this.isPortrait) {
                    _this.widthBox.value = 515.9;
                    _this.heightBox.value = 728.5;
                }
                else {
                    _this.widthBox.value = 728.5;
                    _this.heightBox.value = 515.9;
                }
            }
            else if (value === 'customsize') {
                if (_this.isPortrait) {
                    _this.widthBox.value = 515.9;
                    _this.heightBox.value = 728.5;
                }
                else {
                    _this.widthBox.value = 728.5;
                    _this.heightBox.value = 515.9;
                }
            }
        };
        /**
         * @private
         */
        this.onPortrait = function (event) {
            _this.landscape.checked = false;
            var width = _this.widthBox.value;
            var height = _this.heightBox.value;
            if (width > height) {
                _this.widthBox.value = height;
                _this.heightBox.value = width;
            }
        };
        /**
         * @private
         */
        this.onLandscape = function (event) {
            _this.portrait.checked = false;
            var width = _this.widthBox.value;
            var height = _this.heightBox.value;
            if (width < height) {
                _this.widthBox.value = height;
                _this.heightBox.value = width;
            }
        };
        /**
         * @private
         */
        this.unWireEventsAndBindings = function () {
            _this.paperSize.value = undefined;
            _this.topMarginBox.value = undefined;
            _this.bottomMarginBox.value = undefined;
            _this.leftMarginBox.value = undefined;
            _this.rightMarginBox.value = undefined;
            _this.headerBox.value = undefined;
            _this.footerBox.value = undefined;
            _this.widthBox.value = undefined;
            _this.heightBox.value = undefined;
            _this.checkBox1.checked = false;
            _this.checkBox2.checked = false;
            _this.portrait.checked = false;
            _this.landscape.checked = false;
        };
        this.owner = viewer;
    }
    PageSetupDialog.prototype.getModuleName = function () {
        return 'PageSetupDialog';
    };
    /**
     * @private
     */
    PageSetupDialog.prototype.initPageSetupDialog = function (locale, isRtl) {
        var id = this.owner.owner.containerId + '_pagesetup_dialog';
        this.target = createElement('div', { id: id, className: 'e-de-pagesetup-dlg-container' });
        var ejtabContainer = createElement('div', { id: this.target.id + '_MarginTabContainer' });
        this.target.appendChild(ejtabContainer);
        this.marginTab = createElement('div', {
            id: this.target.id + '_marginPropertyTab', styles: 'position: relative;'
        });
        this.paperTab = createElement('div', {
            id: this.target.id + '_paperSizePropertyTab', styles: 'position: relative;'
        });
        this.layoutTab = createElement('div', {
            id: this.target.id + '_CellPropertiesDialogTab', styles: 'position: relative;'
        });
        // tslint:disable-next-line:max-line-length
        var ejtab = createElement('div', { id: this.target.id + '_PageSetupDialogTab', className: 'e-de-page-setup-ppty-tab' });
        var headerContainer = createElement('div', { className: 'e-tab-header' });
        var marginHeader = createElement('div', {
            id: this.target.id + '_marginHeader', innerHTML: locale.getConstant('Margin')
        });
        var paperHeader = createElement('div', {
            id: this.target.id + '_paperHeader', innerHTML: locale.getConstant('Paper')
        });
        var layoutHeader = createElement('div', {
            id: this.target.id + '_layoutHeader', innerHTML: locale.getConstant('Layout')
        });
        headerContainer.appendChild(marginHeader);
        headerContainer.appendChild(paperHeader);
        headerContainer.appendChild(layoutHeader);
        var contentContainer = createElement('div', { className: 'e-content' });
        var marginContent = createElement('div', { id: this.target.id + '_marginContent' });
        var paperContent = createElement('div', { id: this.target.id + '_paperContent' });
        var layoutContent = createElement('div', { id: this.target.id + '_layoutContent' });
        marginContent.appendChild(this.marginTab);
        paperContent.appendChild(this.paperTab);
        layoutContent.appendChild(this.layoutTab);
        contentContainer.appendChild(marginContent);
        contentContainer.appendChild(paperContent);
        contentContainer.appendChild(layoutContent);
        ejtab.appendChild(headerContainer);
        ejtab.appendChild(contentContainer);
        ejtabContainer.appendChild(ejtab);
        this.initMarginProperties(this.marginTab, locale, isRtl);
        this.initPaperSizeProperties(this.paperTab, locale, isRtl);
        this.initLayoutProperties(this.layoutTab, locale, isRtl);
        var tabObj = new Tab({ enableRtl: isRtl }, ejtab);
        this.target.addEventListener('keyup', this.keyUpInsertPageSettings);
        // let marginTabHeader: HTMLElement = tabObj.element.getElementsByClassName('e-item e-toolbar-item')[0] as HTMLElement;
        // let marginTabHeaderItem: HTMLElement = marginTabHeader.getElementsByClassName('e-tab-wrap')[0] as HTMLElement;
        // marginTabHeaderItem.classList.add('e-de-page-setup-dlg-margin-tab-header');
        // if (isRtl) {
        //     marginTabHeaderItem.classList.add('e-de-rtl');
        // }
    };
    /**
     * @private
     */
    PageSetupDialog.prototype.initMarginProperties = function (element, locale, isRtl) {
        var marginDiv = createElement('div', {
            id: 'margin_div',
            className: 'e-de-page-setup-dlg-sub-container', styles: 'height:135px;'
        });
        // tslint:disable-next-line:max-line-length
        var leftMarginDiv = createElement('div', { id: 'left_margin', className: 'e-de-page-setup-dlg-left-sub-container' });
        marginDiv.appendChild(leftMarginDiv);
        // tslint:disable-next-line:max-line-length
        var rightMarginDiv = createElement('div', { className: 'e-de-page-setup-dlg-right-sub-container' });
        marginDiv.appendChild(rightMarginDiv);
        if (isRtl) {
            leftMarginDiv.classList.add('e-de-rtl');
            rightMarginDiv.classList.add('e-de-rtl');
        }
        var topLabel = createElement('label', {
            innerHTML: locale.getConstant('Top'), className: 'e-de-page-setup-dlg-sub-header',
            id: this.target.id + '_TopLabel', styles: 'padding-top:0px;'
        });
        var topTextBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_Top'
        });
        var bottomBoxLabel = createElement('label', {
            innerHTML: locale.getConstant('Bottom'),
            className: 'e-de-page-setup-dlg-sub-title-header', id: this.target.id + '_bottomLabel'
        });
        var bottomTextBox = createElement('input', {
            attrs: { 'type': 'text' },
            id: this.target.id + '_bottom'
        });
        leftMarginDiv.appendChild(topLabel);
        leftMarginDiv.appendChild(topTextBox);
        leftMarginDiv.appendChild(bottomBoxLabel);
        leftMarginDiv.appendChild(bottomTextBox);
        var leftBoxLabel = createElement('label', {
            innerHTML: locale.getConstant('Left'), className: 'e-de-page-setup-dlg-sub-header', styles: 'padding-top:0px;',
            id: this.target.id + '_leftLabel'
        });
        var leftTextBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_left'
        });
        var rightLabel = createElement('label', {
            innerHTML: locale.getConstant('Right'),
            id: this.target.id + '_rightLabel', className: 'e-de-page-setup-dlg-sub-title-header'
        });
        var rightTextBox = createElement('input', {
            attrs: { 'type': 'text' },
            id: this.target.id + '_right'
        });
        rightMarginDiv.appendChild(leftBoxLabel);
        rightMarginDiv.appendChild(leftTextBox);
        rightMarginDiv.appendChild(rightLabel);
        rightMarginDiv.appendChild(rightTextBox);
        element.appendChild(marginDiv);
        this.topMarginBox = new NumericTextBox({ value: 71, width: 170, decimals: 2 });
        this.topMarginBox.appendTo(topTextBox);
        this.leftMarginBox = new NumericTextBox({ value: 73, width: 170, decimals: 2 });
        this.leftMarginBox.appendTo(leftTextBox);
        this.bottomMarginBox = new NumericTextBox({ value: 72, width: 170, decimals: 2 });
        this.bottomMarginBox.appendTo(bottomTextBox);
        this.rightMarginBox = new NumericTextBox({ value: 74, width: 170, decimals: 2 });
        this.rightMarginBox.appendTo(rightTextBox);
        // tslint:disable-next-line:max-line-length
        var orientationDiv = createElement('div', { id: 'orientation_div', className: 'e-de-page-setup-dlg-sub-container-port' });
        // tslint:disable-next-line:max-line-length
        var orientationLabeldiv = createElement('div', { id: '_orientationLabelDiv', className: 'e-de-page-setup-dlg-sub-label', innerHTML: locale.getConstant('Orientation') });
        var orientationPropDiv = createElement('div', { id: '_orientationPropDiv', styles: 'display: flex;', className: 'e-de-page-setup-dlg-orientation-prop' });
        var portraitDivStyles;
        if (isRtl) {
            portraitDivStyles = 'padding-left: 30px;';
        }
        else {
            portraitDivStyles = 'padding-right: 30px;';
        }
        var portraitDiv = createElement('div', { id: '_portraitDiv', styles: portraitDivStyles });
        var portrait = createElement('input', {
            attrs: { 'type': 'radiobutton' }, id: this.target.id + '_portrait'
        });
        var landscapeDiv = createElement('div', { id: '_landscapeDiv' });
        var landscape = createElement('input', {
            attrs: { 'type': 'radiobutton' }, id: this.target.id + '_landscape'
        });
        portraitDiv.appendChild(portrait);
        landscapeDiv.appendChild(landscape);
        orientationPropDiv.appendChild(portraitDiv);
        orientationPropDiv.appendChild(landscapeDiv);
        orientationDiv.appendChild(orientationLabeldiv);
        orientationDiv.appendChild(orientationPropDiv);
        // tslint:disable-next-line:max-line-length
        this.portrait = new RadioButton({ label: locale.getConstant('Portrait'), checked: true, enableRtl: isRtl, change: this.onPortrait });
        this.landscape = new RadioButton({ label: locale.getConstant('Landscape'), enableRtl: isRtl, change: this.onLandscape });
        this.portrait.appendTo(portrait);
        this.landscape.appendTo(landscape);
        element.appendChild(orientationDiv);
    };
    /**
     * @private
     */
    PageSetupDialog.prototype.initPaperSizeProperties = function (element, locale, isRtl) {
        var sizeDiv = createElement('div', {
            id: 'size_div',
            className: 'e-de-page-setup-dlg-sub-size-container'
        });
        // tslint:disable-next-line:max-line-length
        var leftSizeDiv = createElement('div', { id: 'left_size', className: 'e-de-page-setup-dlg-left-sub-container' });
        sizeDiv.appendChild(leftSizeDiv);
        // tslint:disable-next-line:max-line-length
        var rightSizeDiv = createElement('div', { className: 'e-de-page-setup-dlg-right-sub-container' });
        sizeDiv.appendChild(rightSizeDiv);
        if (isRtl) {
            leftSizeDiv.classList.add('e-de-rtl');
            rightSizeDiv.classList.add('e-de-rtl');
        }
        var widthLabel = createElement('label', {
            innerHTML: locale.getConstant('Width'), className: 'e-de-page-setup-dlg-sub-header',
            id: this.target.id + '_widthLabel', styles: 'padding-top:0px;'
        });
        var widthTextBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_Width'
        });
        leftSizeDiv.appendChild(widthLabel);
        leftSizeDiv.appendChild(widthTextBox);
        var heightLabel = createElement('label', {
            innerHTML: locale.getConstant('Height'), className: 'e-de-page-setup-dlg-sub-header', styles: 'padding-top:0px;',
            id: this.target.id + '_heightLabel'
        });
        var heightTextBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_height'
        });
        rightSizeDiv.appendChild(heightLabel);
        rightSizeDiv.appendChild(heightTextBox);
        element.appendChild(sizeDiv);
        this.widthBox = new NumericTextBox({ value: 612, width: 170, decimals: 2 });
        this.widthBox.appendTo(widthTextBox);
        this.heightBox = new NumericTextBox({ value: 792, width: 170, decimals: 2 });
        this.heightBox.appendTo(heightTextBox);
        // tslint:disable-next-line:max-line-length
        var paperSizeDiv = createElement('div', { id: '_paperSizeDiv', styles: 'height:37px;', className: 'e-de-page-setup-dlg-sub-container' });
        var paperSize = createElement('select', {
            id: this.target.id + '_papersize', styles: 'width:170px;padding-bottom: 20px;',
            innerHTML: '<option value="letter">' + locale.getConstant('Letter') +
                '</option><option value="tabloid">' + locale.getConstant('Tabloid') +
                '</option><option value="legal">' + locale.getConstant('Legal') +
                '</option><option value="statement">' + locale.getConstant('Statement') +
                '</option><option value="executive">' + locale.getConstant('Executive') +
                '</option><option value="a3">' + locale.getConstant('A3') +
                '</option><option value="a4">' + locale.getConstant('A4') +
                '</option><option value="a5">' + locale.getConstant('A5') +
                '</option><option value="b4">' + locale.getConstant('B4') +
                '</option><option value="b5">' + locale.getConstant('B5') +
                '</option><option value="customsize">' + locale.getConstant('Custom Size') + '</option>'
        });
        paperSizeDiv.appendChild(paperSize);
        this.paperSize = new DropDownList({ change: this.changeByPaperSize, width: '170px', enableRtl: isRtl });
        this.paperSize.appendTo(paperSize);
        element.appendChild(paperSizeDiv);
    };
    /**
     * @private
     */
    PageSetupDialog.prototype.initLayoutProperties = function (element, locale, isRtl) {
        // tslint:disable-next-line:max-line-length
        var layoutDiv = createElement('div', { id: '_layoutDiv', className: 'e-de-page-setup-dlg-layout-sub-container', });
        // tslint:disable-next-line:max-line-length
        var firstPageDiv = createElement('div', { id: '_firstPageDiv', styles: 'height: 27px;', className: 'e-de-page-setup-dlg-first-page-prop' });
        var checkBox1 = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_oddoreven'
        });
        firstPageDiv.appendChild(checkBox1);
        // tslint:disable-next-line:max-line-length
        var oddOrEvenDiv = createElement('div', { id: '_oddOrEvenDiv', styles: 'height: 27px;', className: 'e-de-page-setup-dlg-odd-or-even-prop' });
        var checkBox2 = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_even'
        });
        oddOrEvenDiv.appendChild(checkBox2);
        layoutDiv.appendChild(firstPageDiv);
        layoutDiv.appendChild(oddOrEvenDiv);
        this.checkBox1 = new CheckBox({ label: locale.getConstant('Different odd and even'), enableRtl: isRtl });
        this.checkBox2 = new CheckBox({ label: locale.getConstant('Different first page'), enableRtl: isRtl });
        this.checkBox1.appendTo(checkBox1);
        this.checkBox2.appendTo(checkBox2);
        element.appendChild(layoutDiv);
        // tslint:disable-next-line:max-line-length
        var textLabelDiv = createElement('div', { id: '_textLabelDiv', className: 'e-de-page-setup-dlg-sub-label' });
        var textLabel = createElement('label', {
            innerHTML: locale.getConstant('From edge'), id: this.target.id + '_textLabel'
        });
        textLabelDiv.appendChild(textLabel);
        element.appendChild(textLabelDiv);
        // tslint:disable-next-line:max-line-length
        var propertyDiv = createElement('div', { id: '_headerFooeterPropDiv', className: 'e-de-page-setup-dlg-sub-container', styles: 'height: 65px;' });
        // tslint:disable-next-line:max-line-length
        var leftLayoutDiv = createElement('div', { id: '_leftLayoutDiv', className: 'e-de-page-setup-dlg-left-layout-container' });
        propertyDiv.appendChild(leftLayoutDiv);
        // tslint:disable-next-line:max-line-length
        var rightLayoutDiv = createElement('div', { className: 'e-de-page-setup-dlg-right-layout-container' });
        propertyDiv.appendChild(rightLayoutDiv);
        if (isRtl) {
            rightLayoutDiv.classList.add('e-de-rtl');
            leftLayoutDiv.classList.add('e-de-rtl');
        }
        var headerLabel = createElement('label', {
            innerHTML: locale.getConstant('Header'), className: 'e-de-page-setup-dlg-sub-header',
            id: this.target.id + '_headerLabel', styles: 'padding-top:0px;'
        });
        var headerBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_header'
        });
        leftLayoutDiv.appendChild(headerLabel);
        leftLayoutDiv.appendChild(headerBox);
        var footerLabel = createElement('label', {
            innerHTML: locale.getConstant('Footer'), className: 'e-de-page-setup-dlg-sub-header', styles: 'padding-top:0px;',
            id: this.target.id + '_footerLabel'
        });
        var footerBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_footer'
        });
        rightLayoutDiv.appendChild(footerLabel);
        rightLayoutDiv.appendChild(footerBox);
        element.appendChild(propertyDiv);
        this.headerBox = new NumericTextBox({ value: 612, width: 170, decimals: 2 });
        this.headerBox.appendTo(headerBox);
        this.footerBox = new NumericTextBox({ value: 792, width: 170, decimals: 2 });
        this.footerBox.appendTo(footerBox);
    };
    /**
     * @private
     */
    PageSetupDialog.prototype.show = function () {
        var localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localValue.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initPageSetupDialog(localValue, this.owner.owner.enableRtl);
        }
        this.owner.dialog.header = localValue.getConstant('Page Setup');
        this.owner.dialog.width = 'auto';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.loadPageSetupDialog;
        this.owner.dialog.close = this.closePageSetupDialog;
        this.owner.dialog.buttons = [{
                click: this.applyPageSetupProperties,
                buttonModel: { content: localValue.getConstant('Ok'), cssClass: 'e-flat e-layout-ppty-okay', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: localValue.getConstant('Cancel'), cssClass: 'e-flat e-layout-ppty-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    };
    PageSetupDialog.prototype.setPageSize = function (isPortrait, width, height) {
        if ((isPortrait && width === 612 && height === 792)
            || (!isPortrait && width === 792 && height === 612)) {
            this.paperSize.value = 'letter';
        }
        else if ((isPortrait && width === 792 && height === 1224)
            || (!isPortrait && width === 1224 && height === 792)) {
            this.paperSize.value = 'tabloid';
        }
        else if ((isPortrait && width === 612 && height === 1008)
            || (!isPortrait && width === 1008 && height === 612)) {
            this.paperSize.value = 'legal';
        }
        else if ((isPortrait && width === 392 && height === 612)
            || (!isPortrait && width === 392 && height === 612)) {
            this.paperSize.value = 'statement';
        }
        else if ((isPortrait && width === 522 && height === 756)
            || (!isPortrait && width === 756 && height === 522)) {
            this.paperSize.value = 'executive';
        }
        else if ((isPortrait && width === 841.9 && height === 1190.55)
            || (!isPortrait && width === 1190.5 && height === 841.9)) {
            this.paperSize.value = 'a3';
        }
        else if ((isPortrait && width === 595.3 && height === 841.9)
            || (!isPortrait && width === 841.9 && height === 595.3)) {
            this.paperSize.value = 'a4';
        }
        else if ((isPortrait && width === 419.55 && height === 595.3)
            || (!isPortrait && width === 595.3 && height === 419.55)) {
            this.paperSize.value = 'a5';
        }
        else if ((isPortrait && width === 728.5 && height === 1031.8)
            || (!isPortrait && width === 1031.8 && height === 728.5)) {
            this.paperSize.value = 'b4';
        }
        else if ((isPortrait && width === 515.9 && height === 728.5)
            || (!isPortrait && width === 728.5 && height === 515.9)) {
            this.paperSize.value = 'letter';
        }
        else {
            this.paperSize.value = 'customsize';
        }
    };
    /**
     * @private
     */
    PageSetupDialog.prototype.destroy = function () {
        if (this.topMarginBox) {
            this.topMarginBox.destroy();
            this.topMarginBox = undefined;
        }
        if (this.leftMarginBox) {
            this.leftMarginBox.destroy();
            this.leftMarginBox = undefined;
        }
        if (this.bottomMarginBox) {
            this.bottomMarginBox.destroy();
            this.bottomMarginBox = undefined;
        }
        if (this.rightMarginBox) {
            this.rightMarginBox.destroy();
            this.rightMarginBox = undefined;
        }
        if (this.headerBox) {
            this.headerBox.destroy();
            this.headerBox = undefined;
        }
        if (this.footerBox) {
            this.footerBox.destroy();
            this.footerBox = undefined;
        }
        if (this.widthBox) {
            this.widthBox.destroy();
            this.widthBox = undefined;
        }
        if (this.heightBox) {
            this.heightBox.destroy();
            this.heightBox = undefined;
        }
        if (this.paperSize) {
            this.paperSize.destroy();
            this.paperSize = undefined;
        }
        if (this.checkBox1) {
            this.checkBox1.destroy();
            this.checkBox1 = undefined;
        }
        if (this.checkBox2) {
            this.checkBox2.destroy();
            this.checkBox2 = undefined;
        }
        if (this.portrait) {
            this.portrait.destroy();
            this.portrait = undefined;
        }
        if (this.landscape) {
            this.landscape.destroy();
            this.landscape = undefined;
        }
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (var s = 0; s < this.target.childNodes.length; s++) {
                this.target.removeChild(this.target.childNodes[s]);
                s--;
            }
            this.target = undefined;
        }
    };
    return PageSetupDialog;
}());

/**
 * The Paragraph dialog is used to modify formatting of selected paragraphs.
 */
var ParagraphDialog = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function ParagraphDialog(viewer) {
        var _this = this;
        //paragraph Format properties
        this.leftIndent = undefined;
        this.rightIndent = undefined;
        this.beforeSpacing = undefined;
        this.afterSpacing = undefined;
        this.textAlignment = undefined;
        this.firstLineIndent = undefined;
        this.lineSpacingIn = undefined;
        this.lineSpacingType = undefined;
        this.paragraphFormat = undefined;
        this.bidi = undefined;
        this.contextualSpacing = undefined;
        this.isStyleDialog = false;
        this.directionDiv = undefined;
        /**
         * @private
         */
        this.keyUpParagraphSettings = function (event) {
            if (event.keyCode === 13) {
                _this.applyParagraphFormat();
            }
        };
        this.changeBeforeSpacing = function (event) {
            _this.beforeSpacing = event.value;
        };
        this.changeAfterSpacing = function (event) {
            _this.afterSpacing = event.value;
        };
        this.changeLeftIndent = function (event) {
            _this.leftIndent = event.value;
        };
        this.changeRightIndent = function (event) {
            _this.rightIndent = event.value;
        };
        this.changeLineSpacingValue = function (event) {
            _this.lineSpacingIn = event.value;
        };
        this.changeFirstLineIndent = function (event) {
            _this.firstLineIndent = event.value;
        };
        this.changeByTextAlignment = function (args) {
            _this.textAlignment = args.value;
        };
        this.changeBidirectional = function (event) {
            if (event.value === 'ltr') {
                _this.rtlButton.checked = !_this.ltrButton.checked;
                _this.bidi = false;
            }
            else {
                _this.ltrButton.checked = !_this.rtlButton.checked;
                _this.bidi = true;
            }
            _this.changeAlignmentByBidi();
        };
        this.changeContextualSpacing = function (args) {
            _this.contextualSpacing = args.checked;
        };
        /**
         * @private
         */
        this.changeByValue = function (event) {
            var paragraphFormat = _this.owner.selection.paragraphFormat;
            switch (_this.special.index) {
                case 0:
                    if (paragraphFormat.firstLineIndent !== 0) {
                        _this.byIn.value = 0;
                    }
                    break;
                case 1:
                    if (paragraphFormat.firstLineIndent === 0 || isNullOrUndefined(paragraphFormat.firstLineIndent)) {
                        _this.byIn.value = 0.1;
                    }
                    else if (paragraphFormat.firstLineIndent < 0) {
                        _this.byIn.value = -(paragraphFormat.firstLineIndent);
                    }
                    break;
                case 2:
                    if (paragraphFormat.firstLineIndent === 0 || isNullOrUndefined(paragraphFormat.firstLineIndent)) {
                        paragraphFormat.firstLineIndent = -0.1;
                    }
                    else if (paragraphFormat.firstLineIndent > 0) {
                        _this.byIn.value = -(paragraphFormat.firstLineIndent);
                    }
                    break;
            }
        };
        /**
         * @private
         */
        this.changeBySpacing = function (event) {
            if (isNullOrUndefined(_this.lineSpacing)) {
                return;
            }
            switch (_this.lineSpacing.index) {
                case 0:
                    _this.lineSpacingType = 'AtLeast';
                    _this.atIn.value = 12;
                    break;
                case 1:
                    _this.lineSpacingType = 'Exactly';
                    _this.atIn.value = 12;
                    break;
                case 2:
                    _this.lineSpacingType = 'Multiple';
                    _this.atIn.value = 1;
                    break;
            }
        };
        /* tslint:enable */
        /**
         * @private
         */
        this.loadParagraphDialog = function () {
            if (_this.isStyleDialog) {
                _this.directionDiv.classList.add('e-de-disabledbutton');
            }
            else {
                _this.directionDiv.classList.remove('e-de-disabledbutton');
            }
            var selectionFormat;
            if (_this.paragraphFormat) {
                selectionFormat = _this.paragraphFormat;
            }
            else {
                selectionFormat = _this.owner.selection.paragraphFormat;
            }
            var alignValue = _this.getAlignmentValue(selectionFormat.textAlignment);
            _this.alignment.index = alignValue;
            _this.beforeSpacingIn.value = selectionFormat.beforeSpacing;
            _this.afterSpacingIn.value = selectionFormat.afterSpacing;
            _this.leftIndentIn.value = selectionFormat.leftIndent;
            _this.rightIndentIn.value = selectionFormat.rightIndent;
            _this.byIn.value = selectionFormat.firstLineIndent;
            var lineSpaceValue = _this.lineSpacing.index;
            if (selectionFormat.lineSpacingType === 'AtLeast') {
                lineSpaceValue = 0;
            }
            else if (selectionFormat.lineSpacingType === 'Exactly') {
                lineSpaceValue = 1;
            }
            else {
                lineSpaceValue = 2;
            }
            _this.lineSpacing.index = lineSpaceValue;
            _this.atIn.value = selectionFormat.lineSpacing;
            if (_this.owner.selection.caret.style.display !== 'none') {
                _this.owner.selection.caret.style.display = 'none';
            }
            if (selectionFormat.bidi) {
                _this.rtlButton.checked = true;
                _this.ltrButton.checked = false;
            }
            else {
                _this.ltrButton.checked = true;
                _this.rtlButton.checked = false;
            }
            _this.contextSpacing.checked = selectionFormat.contextualSpacing;
        };
        /**
         * @private
         */
        this.applyParagraphFormat = function () {
            var paraFormat;
            var isApply;
            if (_this.paragraphFormat) {
                paraFormat = _this.paragraphFormat;
                isApply = false;
            }
            else {
                paraFormat = new WParagraphFormat();
                isApply = true;
            }
            if (!isNullOrUndefined(_this.beforeSpacing)) {
                paraFormat.beforeSpacing = _this.beforeSpacing;
            }
            if (!isNullOrUndefined(_this.afterSpacing)) {
                paraFormat.afterSpacing = _this.afterSpacing;
            }
            if (!isNullOrUndefined(_this.lineSpacingType)) {
                paraFormat.lineSpacingType = _this.lineSpacingType;
            }
            if (!isNullOrUndefined(_this.leftIndent)) {
                paraFormat.leftIndent = _this.leftIndent;
            }
            if (!isNullOrUndefined(_this.rightIndent)) {
                paraFormat.rightIndent = _this.rightIndent;
            }
            if (!isNullOrUndefined(_this.lineSpacingIn)) {
                paraFormat.lineSpacing = _this.lineSpacingIn;
            }
            if (!isNullOrUndefined(_this.firstLineIndent)) {
                paraFormat.firstLineIndent = _this.firstLineIndent;
            }
            if (!isNullOrUndefined(_this.bidi)) {
                paraFormat.bidi = _this.bidi;
            }
            if (!isNullOrUndefined(_this.textAlignment)) {
                paraFormat.textAlignment = _this.textAlignment;
            }
            if (!isNullOrUndefined(_this.contextualSpacing)) {
                paraFormat.contextualSpacing = _this.contextualSpacing;
            }
            if (isApply) {
                _this.onParagraphFormat(paraFormat);
            }
            else {
                _this.owner.owner.styleDialogModule.updateParagraphFormat();
            }
            _this.owner.dialog.hide();
        };
        /**
         * @private
         */
        this.closeParagraphDialog = function () {
            _this.leftIndent = undefined;
            _this.afterSpacing = undefined;
            _this.beforeSpacing = undefined;
            _this.firstLineIndent = undefined;
            _this.textAlignment = undefined;
            _this.rightIndent = undefined;
            _this.lineSpacingIn = undefined;
            _this.lineSpacingType = undefined;
            _this.paragraphFormat = undefined;
            _this.owner.dialog.hide();
            _this.owner.updateFocus();
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    ParagraphDialog.prototype.getModuleName = function () {
        return 'ParagraphDialog';
    };
    /*tslint:disable max-func-body-length*/
    /**
     * @private
     */
    ParagraphDialog.prototype.initParagraphDialog = function (locale) {
        var instance = this;
        var ownerId = this.owner.owner.containerId;
        var id = ownerId + '_paragraph_dialog';
        this.target = createElement('div', { id: id, className: 'e-de-para-dlg-container' });
        // tslint:disable-next-line:max-line-length
        var div = createElement('div', { id: 'property_div', styles: 'width:400px;' });
        var generalDiv = createElement('div', { id: 'genral_div', className: 'e-de-para-dlg-sub-container' });
        // tslint:disable-next-line:max-line-length
        var genLabel = createElement('div', { id: ownerId + '_genLabel', className: 'e-de-para-dlg-heading', innerHTML: locale.getConstant('General') });
        var alignLabel = createElement('div', { id: ownerId + '_AlignLabel', className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Alignment') });
        var alignment = createElement('select', {
            id: ownerId + '_Alignment',
            innerHTML: '<option value="Center">' + locale.getConstant('Center') +
                '</option><option value="Left">' + locale.getConstant('Left') +
                '</option><option value="Right">' + locale.getConstant('Right') +
                '</option><option value="Justify">' + locale.getConstant('Justify') + '</option>'
        });
        generalDiv.appendChild(genLabel);
        generalDiv.appendChild(alignLabel);
        generalDiv.appendChild(alignment);
        var dirLabel = createElement('div', {
            id: ownerId + '_DirLabel',
            className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Direction')
        });
        this.directionDiv = createElement('div', { id: ownerId + '_DirDiv', styles: 'display:flex' });
        var rtlDiv = createElement('div', { id: ownerId + '_DirDiv', className: 'e-de-rtl-btn-div' });
        var rtlInputELe = createElement('input', { id: ownerId + '_rtlEle' });
        rtlDiv.appendChild(rtlInputELe);
        this.directionDiv.appendChild(rtlDiv);
        var isRtl = this.owner.owner.enableRtl;
        if (isRtl) {
            rtlDiv.classList.add('e-de-rtl');
        }
        var ltrDiv = createElement('div', { id: ownerId + '_DirDiv', className: 'e-de-ltr-btn-div' });
        var ltrInputELe = createElement('input', { id: ownerId + '_ltrEle' });
        ltrDiv.appendChild(ltrInputELe);
        this.directionDiv.appendChild(ltrDiv);
        generalDiv.appendChild(dirLabel);
        generalDiv.appendChild(this.directionDiv);
        this.rtlButton = new RadioButton({
            label: locale.getConstant('Right-to-left'), enableRtl: isRtl,
            value: 'rtl', cssClass: 'e-small', change: this.changeBidirectional
        });
        this.rtlButton.appendTo(rtlInputELe);
        this.ltrButton = new RadioButton({
            label: locale.getConstant('Left-to-right'), enableRtl: isRtl,
            value: 'ltr', cssClass: 'e-small', change: this.changeBidirectional
        });
        this.ltrButton.appendTo(ltrInputELe);
        // tslint:disable-next-line:max-line-length
        var indentionDiv = createElement('div', { id: 'indention_div', styles: 'width: 400px;', className: 'e-de-para-dlg-sub-container e-para-dlg-sub-height' });
        var leftIndentionDiv = createElement('div', { id: 'left_indention', styles: 'float:left;position:relative;' });
        indentionDiv.appendChild(leftIndentionDiv);
        // tslint:disable-next-line:max-line-length
        var rightIndentionDiv = createElement('div', { className: 'e-de-para-dlg-right-sub-container', styles: 'float:right;position:relative;' });
        indentionDiv.appendChild(rightIndentionDiv);
        // tslint:disable-next-line:max-line-length
        var spacingDiv = createElement('div', { id: 'spacing_div' });
        var leftSpacingDiv = createElement('div', { id: 'left_spacing', styles: 'float:left;position:relative;' });
        spacingDiv.appendChild(leftSpacingDiv);
        var contextSpacingStyles = 'float:left';
        if (isRtl) {
            contextSpacingStyles = 'float:right;';
        }
        var contextSpacingDiv = createElement('div', { id: 'context_spacing', styles: contextSpacingStyles + 'position:relative;' });
        spacingDiv.appendChild(contextSpacingDiv);
        // tslint:disable-next-line:max-line-length
        var rightSpacingDiv = createElement('div', { styles: 'display:inline-flex;' });
        spacingDiv.appendChild(rightSpacingDiv);
        var contextInputEle = createElement('input', {
            attrs: { type: 'checkbox' },
            id: ownerId + '_contextSpacing'
        });
        contextSpacingDiv.appendChild(contextInputEle);
        // tslint:disable-next-line:max-line-length
        var indentLabel = createElement('div', {
            id: ownerId + '_indentLabel', className: 'e-de-para-dlg-heading', innerHTML: locale.getConstant('Indentation')
        });
        var beforeTextLabel = createElement('div', {
            id: ownerId + '_bfTextLabel',
            className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Before text')
        });
        // tslint:disable-next-line:max-line-length
        var leftIndent = createElement('input', { id: ownerId + '_leftIndent', attrs: { 'type': 'text' } });
        var specialLabel = createElement('div', { id: ownerId + '_specialLabel', className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Special') });
        var special = createElement('select', {
            id: ownerId + '_special',
            innerHTML: '<option value="None">' + locale.getConstant('None') +
                '</option><option value="First Line">' + locale.getConstant('First line') +
                '</option><option value="Hanging">' + locale.getConstant('Hanging') + '</option> '
        });
        leftIndentionDiv.appendChild(indentLabel);
        leftIndentionDiv.appendChild(beforeTextLabel);
        leftIndentionDiv.appendChild(leftIndent);
        leftIndentionDiv.appendChild(specialLabel);
        leftIndentionDiv.appendChild(special);
        // tslint:disable-next-line:max-line-length
        var afterTextLabel = createElement('div', { id: ownerId + '_afTextLabel', className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('After text') });
        var rightIndent = createElement('input', { id: ownerId + '_rightIndent', attrs: { 'type': 'text' } });
        // tslint:disable-next-line:max-line-length
        var byLabel = createElement('label', { id: ownerId + '_byLabel', className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('By') });
        var by = createElement('input', { id: ownerId + '_By', attrs: { 'type': 'text' } });
        rightIndentionDiv.appendChild(afterTextLabel);
        rightIndentionDiv.appendChild(rightIndent);
        rightIndentionDiv.appendChild(byLabel);
        rightIndentionDiv.appendChild(by);
        // tslint:disable-next-line:max-line-length
        var spaceLabel = createElement('div', { innerHTML: locale.getConstant('Spacing'), className: 'e-de-para-dlg-heading', id: ownerId + '_spaceLabel' });
        var spacingWholeDiv = createElement('div', { id: ownerId + '_spacingWholeDiv', styles: 'display:inline-flex;' });
        var beforeSpacingWholeDiv = createElement('div', { id: ownerId + '_beforeSpacingWholeDiv' });
        // tslint:disable-next-line:max-line-length
        var beforeLabel = createElement('div', { className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Before'), id: ownerId + '_beforeLabel' });
        // tslint:disable-next-line:max-line-length
        var beforeSpacing = createElement('input', { id: ownerId + '_beforeSpacing', attrs: { 'type': 'text' } });
        var afterSpacingWholeDiv = createElement('div', { id: ownerId + '_afterSpacingWholeDiv', className: 'e-de-para-dlg-spacing-div' });
        // tslint:disable-next-line:max-line-length
        var afterLabel = createElement('div', { innerHTML: locale.getConstant('After'), className: 'e-de-dlg-sub-header', id: ownerId + '_afterLabel' });
        var afterSpacing = createElement('input', { id: ownerId + '_afterSpacing', attrs: { 'type': 'text' } });
        leftSpacingDiv.appendChild(spaceLabel);
        leftSpacingDiv.appendChild(spacingWholeDiv);
        beforeSpacingWholeDiv.appendChild(beforeLabel);
        beforeSpacingWholeDiv.appendChild(beforeSpacing);
        spacingWholeDiv.appendChild(beforeSpacingWholeDiv);
        afterSpacingWholeDiv.appendChild(afterLabel);
        afterSpacingWholeDiv.appendChild(afterSpacing);
        spacingWholeDiv.appendChild(afterSpacingWholeDiv);
        var lineSpacingDiv = createElement('div', { id: ownerId + '_lineSpacingWholeDiv' });
        // tslint:disable-next-line:max-line-length
        var lineSpaceLabel = createElement('div', { id: ownerId + '_lineSpaceLabel', className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Line Spacing') });
        // tslint:disable-next-line:max-line-length
        var lineSpacing = createElement('select', {
            id: ownerId + '_lineSpacing', styles: 'width:180px;',
            innerHTML: '<option value="At least">' + locale.getConstant('At least') +
                '</option><option value="Exactly">' + locale.getConstant('Exactly') +
                '</option><option value="Multiple">' + locale.getConstant('Multiple') + '</option>'
        });
        // tslint:disable-next-line:max-line-length
        var lineTypeDiv = createElement('div', { id: ownerId + '_lineTypeWholeDiv', className: 'e-de-para-dlg-spacing-div' });
        // tslint:disable-next-line:max-line-length
        var atLabel = createElement('div', { innerHTML: locale.getConstant('At'), id: ownerId + '_atLabel', className: 'e-de-dlg-sub-header' });
        var lineSpacingAt = createElement('input', { id: ownerId + '_lineSpacingAt', attrs: { 'type': 'text' } });
        lineSpacingDiv.appendChild(lineSpaceLabel);
        lineSpacingDiv.appendChild(lineSpacing);
        rightSpacingDiv.appendChild(lineSpacingDiv);
        lineTypeDiv.appendChild(atLabel);
        lineTypeDiv.appendChild(lineSpacingAt);
        rightSpacingDiv.appendChild(lineTypeDiv);
        div.appendChild(generalDiv);
        div.appendChild(indentionDiv);
        div.appendChild(spacingDiv);
        this.target.appendChild(div);
        this.leftIndentIn = new NumericTextBox({
            format: 'n1', value: 0, min: -1584, max: 1584, width: 180, enablePersistence: false, change: this.changeLeftIndent
        });
        this.leftIndentIn.appendTo(leftIndent);
        this.rightIndentIn = new NumericTextBox({
            format: 'n1', value: 0, min: -1584, max: 1584, width: 180, enablePersistence: false, change: this.changeRightIndent
        });
        this.rightIndentIn.appendTo(rightIndent);
        this.byIn = new NumericTextBox({
            format: 'n1', value: 0, min: 0, max: 1584, width: 180, enablePersistence: false, change: this.changeFirstLineIndent
        });
        this.byIn.appendTo(by);
        this.beforeSpacingIn = new NumericTextBox({
            format: 'n1', value: 0, min: 0, max: 1584, width: 180, step: 6, enablePersistence: false,
            change: this.changeBeforeSpacing
        });
        this.beforeSpacingIn.appendTo(beforeSpacing);
        this.afterSpacingIn = new NumericTextBox({
            format: 'n1', value: 0, min: 0, max: 1584, width: 180, step: 6, enablePersistence: false,
            change: this.changeAfterSpacing
        });
        this.afterSpacingIn.appendTo(afterSpacing);
        this.atIn = new NumericTextBox({
            format: 'n1', value: 0, min: 1, max: 1584, width: 180, step: 0.5, enablePersistence: false, change: this.changeLineSpacingValue
        });
        this.special = new DropDownList({ change: this.changeByValue, width: 180, enableRtl: isRtl });
        this.special.appendTo(special);
        this.lineSpacing = new DropDownList({ change: this.changeBySpacing, width: '180px', enableRtl: isRtl });
        this.lineSpacing.appendTo(lineSpacing);
        this.alignment = new DropDownList({ width: 180, change: this.changeByTextAlignment, enableRtl: isRtl });
        this.alignment.appendTo(alignment);
        this.atIn.appendTo(lineSpacingAt);
        this.contextSpacing = new CheckBox({
            change: this.changeContextualSpacing,
            label: locale.getConstant("Contextual Spacing"),
            enableRtl: isRtl,
            cssClass: 'e-de-para-dlg-cs-check-box'
        });
        this.contextSpacing.appendTo(contextInputEle);
        this.target.addEventListener('keyup', instance.keyUpParagraphSettings);
        if (isRtl) {
            afterSpacingWholeDiv.classList.add('e-de-rtl');
            lineTypeDiv.classList.add('e-de-rtl');
        }
    };
    ParagraphDialog.prototype.changeAlignmentByBidi = function () {
        if (this.textAlignment === 'Left') {
            this.textAlignment = 'Right';
        }
        else if (this.textAlignment === 'Right') {
            this.textAlignment = 'Left';
        }
        if (!isNullOrUndefined(this.textAlignment)) {
            this.alignment.index = this.getAlignmentValue(this.textAlignment);
        }
        else {
            if (this.alignment.index === 0) {
                this.textAlignment = 'Center';
            }
            else {
                this.textAlignment = 'Justify';
            }
        }
    };
    ParagraphDialog.prototype.getAlignmentValue = function (textAlignment) {
        var alignValue;
        if (textAlignment === 'Center') {
            alignValue = 0;
        }
        else if (textAlignment === 'Left') {
            alignValue = 1;
        }
        else if (textAlignment === 'Right') {
            alignValue = 2;
        }
        else {
            alignValue = 3;
        }
        return alignValue;
    };
    /**
     * Applies Paragraph Format
     * @param  {WParagraphFormat} paragraphFormat
     * @private
     */
    ParagraphDialog.prototype.onParagraphFormat = function (paragraphFormat) {
        var selection = this.owner.selection;
        var isListBidi = paragraphFormat.bidi && selection.paragraphFormat.listId !== -1;
        if (!isListBidi) {
            this.owner.layout.isBidiReLayout = true;
        }
        this.owner.owner.editorModule.initHistory('ParagraphFormat');
        this.owner.owner.isShiftingEnabled = true;
        if (this.owner.selection.isEmpty) {
            this.owner.owner.editorModule.applyParaFormatProperty(selection.start.paragraph, undefined, paragraphFormat, false);
            this.owner.owner.editor.layoutItemBlock(selection.start.paragraph, false);
        }
        else {
            this.owner.owner.editorModule.updateSelectionParagraphFormatting('ParagraphFormat', paragraphFormat, false);
        }
        this.owner.owner.editorModule.reLayout(selection);
        if (!isListBidi) {
            this.owner.layout.isBidiReLayout = false;
        }
    };
    /**
     * @private
     */
    ParagraphDialog.prototype.show = function (paragraphFormat) {
        if (paragraphFormat) {
            this.isStyleDialog = true;
            this.paragraphFormat = paragraphFormat;
        }
        else {
            this.isStyleDialog = false;
        }
        var local = new L10n('documenteditor', this.owner.owner.defaultLocale);
        local.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initParagraphDialog(local);
        }
        this.loadParagraphDialog();
        this.owner.dialog.header = local.getConstant('Paragraph');
        this.owner.dialog.content = this.target;
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.buttons = [{
                click: this.applyParagraphFormat,
                buttonModel: { content: local.getConstant('Ok'), cssClass: 'e-flat e-para-okay', isPrimary: true }
            },
            {
                click: this.closeParagraphDialog,
                buttonModel: { content: local.getConstant('Cancel'), cssClass: 'e-flat e-para-cancel' }
            }];
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.close = this.owner.updateFocus;
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    };
    /**
     * @private
     */
    ParagraphDialog.prototype.destroy = function () {
        if (this.afterSpacingIn) {
            this.afterSpacingIn.destroy();
            this.afterSpacingIn = undefined;
        }
        if (this.beforeSpacingIn) {
            this.beforeSpacingIn.destroy();
            this.beforeSpacingIn = undefined;
        }
        if (this.leftIndentIn) {
            this.leftIndentIn.destroy();
            this.leftIndentIn = undefined;
        }
        if (this.rightIndentIn) {
            this.rightIndentIn.destroy();
            this.rightIndentIn = undefined;
        }
        if (this.byIn) {
            this.byIn.destroy();
            this.byIn = undefined;
        }
        if (this.atIn) {
            this.atIn.destroy();
            this.atIn = undefined;
        }
        if (this.alignment) {
            this.alignment.change = undefined;
            this.alignment.destroy();
        }
        this.alignment = undefined;
        if (this.lineSpacing) {
            this.lineSpacing.change = undefined;
            this.lineSpacing.destroy();
        }
        this.lineSpacing = undefined;
        if (this.special) {
            this.special.change = undefined;
            this.special.destroy();
        }
        this.special = undefined;
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (var q = 0; q < this.target.childNodes.length; q++) {
                this.target.removeChild(this.target.childNodes[q]);
                q--;
            }
            this.target = undefined;
        }
    };
    return ParagraphDialog;
}());

/**
 * List view model implementation
 * @private
 */
var ListViewModel = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function ListViewModel() {
        this.listIn = undefined;
        this.levelNumberIn = undefined;
        /**
         * @private
         */
        this.dialog = undefined;
        this.levelNumber = 0;
    }
    Object.defineProperty(ListViewModel.prototype, "levelNumber", {
        /**
         * @private
         */
        get: function () {
            return this.levelNumberIn;
        },
        /**
         * @private
         */
        set: function (value) {
            this.levelNumberIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListViewModel.prototype, "list", {
        /**
         * @private
         */
        get: function () {
            return this.listIn;
        },
        /**
         * @private
         */
        set: function (value) {
            if (isNullOrUndefined(value)) {
                this.createList();
            }
            else {
                this.listIn = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListViewModel.prototype, "listLevel", {
        /**
         * @private
         */
        get: function () {
            if (!isNullOrUndefined(this.list) && this.levelNumber >= 0 && this.levelNumber < 9) {
                if (!isNullOrUndefined(this.dialog.owner.getAbstractListById(this.list.abstractListId))) {
                    if (this.dialog.owner.getAbstractListById(this.list.abstractListId).levels.length <= this.levelNumber) {
                        this.addListLevels();
                    }
                    return this.dialog.owner.getAbstractListById(this.list.abstractListId).levels[this.levelNumber];
                }
                else {
                    this.dialog.owner.lists.push(this.list);
                    var abstractList = this.list.abstractList;
                    if (!this.list.abstractList) {
                        abstractList = new WAbstractList();
                        abstractList.abstractListId = this.list.abstractListId;
                    }
                    var listLevelAdv = new WListLevel(abstractList);
                    listLevelAdv.characterFormat = new WCharacterFormat(listLevelAdv);
                    listLevelAdv.paragraphFormat = new WParagraphFormat(listLevelAdv);
                    listLevelAdv.paragraphFormat.leftIndent = (1) * 48;
                    listLevelAdv.paragraphFormat.firstLineIndent = -24;
                    listLevelAdv.numberFormat = '%' + (1).toString() + '.';
                    listLevelAdv.listLevelPattern = 'UpRoman';
                    listLevelAdv.followCharacter = 'Tab';
                    listLevelAdv.startAt = 1;
                    listLevelAdv.restartLevel = 1;
                    this.dialog.owner.abstractLists.push(abstractList);
                    return this.dialog.owner.getAbstractListById(this.list.abstractListId).levels[0];
                    // return this.dialog.owner.getAbstractListById(this.list.abstractListId).levels.getItem(0);
                }
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListViewModel.prototype, "listLevelPattern", {
        /**
         * @private
         */
        get: function () {
            if (!isNullOrUndefined(this.listLevel)) {
                return this.listLevel.listLevelPattern;
            }
            return 'Arabic';
        },
        /**
         * @private
         */
        set: function (value) {
            if (!isNullOrUndefined(this.listLevel)) {
                this.listLevel.listLevelPattern = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListViewModel.prototype, "followCharacter", {
        /**
         * @private
         */
        get: function () {
            if (!isNullOrUndefined(this.listLevel)) {
                return this.listLevel.followCharacter;
            }
            return 'None';
        },
        /**
         * @private
         */
        set: function (value) {
            if (!isNullOrUndefined(this.listLevel)) {
                this.listLevel.followCharacter = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    ListViewModel.prototype.createList = function () {
        this.list = new WList();
        this.list.listId = this.dialog.owner.lists.length + 1;
        var abstractList = new WAbstractList();
        abstractList.abstractListId = this.dialog.owner.abstractLists.length + 1;
        this.list.abstractListId = abstractList.abstractListId;
        this.dialog.owner.lists.push(this.list);
        var listLevel = new WListLevel(abstractList);
        listLevel.paragraphFormat = new WParagraphFormat(listLevel);
        listLevel.paragraphFormat.leftIndent = 48;
        listLevel.paragraphFormat.firstLineIndent = -24;
        listLevel.characterFormat = new WCharacterFormat(listLevel);
        listLevel.numberFormat = '%1.';
        listLevel.startAt = 1;
        abstractList.levels.push(listLevel);
        this.dialog.owner.abstractLists.push(abstractList);
    };
    ListViewModel.prototype.addListLevels = function () {
        if (!isNullOrUndefined(this.list) && !isNullOrUndefined(this.list.abstractListId)) {
            for (var i = this.dialog.owner.getAbstractListById(this.list.abstractListId).levels.length; i < 9; i++) {
                var listLevelAdv = new WListLevel(this.dialog.owner.getAbstractListById(this.list.abstractListId));
                listLevelAdv.characterFormat = new WCharacterFormat(listLevelAdv);
                listLevelAdv.paragraphFormat = new WParagraphFormat(listLevelAdv);
                listLevelAdv.paragraphFormat.leftIndent = (i + 1) * 48;
                listLevelAdv.paragraphFormat.firstLineIndent = -24;
                listLevelAdv.numberFormat = '%' + (i + 1).toString() + '.';
                listLevelAdv.listLevelPattern = 'Arabic';
                listLevelAdv.followCharacter = 'Tab';
                listLevelAdv.startAt = 1;
                listLevelAdv.restartLevel = i;
                (this.dialog.owner).getAbstractListById(this.list.abstractListId).levels.push(listLevelAdv);
            }
        }
    };
    /**
     * @private
     */
    ListViewModel.prototype.destroy = function () {
        this.list = undefined;
        this.followCharacter = undefined;
        this.levelNumber = undefined;
        this.listLevelPattern = undefined;
    };
    return ListViewModel;
}());

// tslint:disable-next-line:max-line-length
/**
 * The List dialog is used to create or modify lists.
 */
/* tslint:disable:no-any */
var ListDialog = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function ListDialog(viewer) {
        var _this = this;
        /**
         * @private
         */
        this.dialog = undefined;
        this.target = undefined;
        /**
         * @private
         */
        this.owner = undefined;
        this.viewModel = undefined;
        this.startAt = undefined;
        this.textIndent = undefined;
        this.alignedAt = undefined;
        this.listLevelElement = undefined;
        this.followNumberWith = undefined;
        this.numberStyle = undefined;
        this.numberFormat = undefined;
        this.restartBy = undefined;
        /**
         * @private
         */
        this.isListCharacterFormat = false;
        this.onTextIndentChanged = function (args) {
            _this.viewModel.listLevel.paragraphFormat.leftIndent = args.value;
        };
        this.onStartValueChanged = function (args) {
            if (!isNullOrUndefined(_this.viewModel) && !isNullOrUndefined(_this.viewModel.listLevel)) {
                _this.viewModel.listLevel.startAt = args.value;
            }
        };
        this.onListLevelValueChanged = function (args) {
            _this.viewModel.levelNumber = parseInt(args.value.slice(args.value.length - 1), 10) - 1;
            if (isNullOrUndefined(_this.listLevel)) {
                return;
            }
            if (isNullOrUndefined(_this.listLevel.characterFormat)) {
                _this.listLevel.characterFormat = new WCharacterFormat(_this.viewModel.listLevel);
            }
            if (!isNullOrUndefined(_this.listLevel.paragraphFormat)) {
                _this.listLevel.paragraphFormat = new WParagraphFormat(_this.viewModel.listLevel);
            }
            _this.updateDialogValues();
            _this.updateRestartLevelBox();
        };
        this.onNumberFormatChanged = function (args) {
            _this.viewModel.listLevel.numberFormat = args.target.value;
        };
        this.onAlignedAtValueChanged = function (args) {
            _this.viewModel.listLevel.paragraphFormat.firstLineIndent = args.value;
        };
        this.onFollowCharacterValueChanged = function (args) {
            if (args.value) {
                _this.viewModel.followCharacter = args.value;
            }
        };
        this.onLevelPatternValueChanged = function (args) {
            _this.viewModel.listLevelPattern = args.value;
            var numberFormat = '%' + (_this.levelNumber + 1).toString();
            // tslint:disable-next-line:max-line-length
            var numberFormatTextBox = document.getElementById(_this.owner.owner.containerId + '_numberFormat');
            if (_this.listLevel.listLevelPattern === 'Bullet') {
                _this.listLevel.numberFormat = '\uf0b7';
                numberFormatTextBox.value = _this.listLevel.numberFormat;
                _this.listLevel.characterFormat.fontFamily = 'Wingdings';
            }
            else {
                if (_this.listLevel.listLevelPattern === 'None') {
                    _this.listLevel.numberFormat = '';
                }
                if (!_this.listLevel.numberFormat.match(numberFormat) && _this.listLevel.listLevelPattern !== 'None') {
                    _this.listLevel.numberFormat = numberFormat + '.';
                }
                numberFormatTextBox.value = _this.listLevel.numberFormat;
            }
        };
        this.loadListDialog = function () {
            _this.owner.updateFocus();
            if (isNullOrUndefined(_this.owner.owner)) {
                return;
            }
            _this.viewModel = new ListViewModel();
            _this.viewModel.dialog = _this;
            if (_this.owner.selection.paragraphFormat.listLevelNumber > 0) {
                _this.viewModel.levelNumber = _this.owner.selection.paragraphFormat.listLevelNumber;
            }
            _this.viewModel.list = _this.owner.selection.paragraphFormat.getList();
            if (isNullOrUndefined(_this.listLevel)) {
                return;
            }
            if (isNullOrUndefined(_this.listLevel.characterFormat)) {
                _this.listLevel.characterFormat = new WCharacterFormat(_this.viewModel.listLevel);
            }
            if (isNullOrUndefined(_this.listLevel.paragraphFormat)) {
                _this.listLevel.paragraphFormat = new WParagraphFormat(_this.viewModel.listLevel);
            }
            _this.updateDialogValues();
            if (_this.owner.selection.caret.style.display !== 'none') {
                _this.owner.selection.caret.style.display = 'none';
            }
        };
        this.showFontDialog = function () {
            _this.owner.owner.fontDialogModule.showFontDialog(_this.listLevel.characterFormat);
        };
        this.onApplyList = function () {
            if (!isNullOrUndefined(_this.owner)) {
                _this.owner.selection.paragraphFormat.setList(_this.list);
            }
            _this.owner.dialog2.hide();
            _this.owner.updateFocus();
        };
        this.onCancelButtonClick = function () {
            _this.disposeBindingForListUI();
            _this.owner.dialog2.hide();
            _this.owner.updateFocus();
            _this.isListCharacterFormat = false;
        };
        this.closeListDialog = function () {
            _this.disposeBindingForListUI();
            _this.owner.updateFocus();
            _this.isListCharacterFormat = false;
        };
        this.owner = viewer;
        this.viewModel = new ListViewModel();
    }
    Object.defineProperty(ListDialog.prototype, "listLevel", {
        /**
         * @private
         */
        get: function () {
            if (!isNullOrUndefined(this.viewModel)) {
                return this.viewModel.listLevel;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListDialog.prototype, "list", {
        /**
         * @private
         */
        get: function () {
            if (!isNullOrUndefined(this.viewModel)) {
                return this.viewModel.list;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListDialog.prototype, "levelNumber", {
        /**
         * @private
         */
        get: function () {
            if (this.listLevel.ownerBase instanceof WLevelOverride) {
                return this.listLevel.ownerBase.levelNumber;
                // tslint:disable-next-line:max-line-length
            }
            else if (this.listLevel.ownerBase instanceof WAbstractList && !isNullOrUndefined(this.listLevel.ownerBase.levels)) {
                return this.listLevel.ownerBase.levels.indexOf(this.listLevel);
            }
            else {
                return -1;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ListDialog.prototype.getModuleName = function () {
        return 'ListDialog';
    };
    /**
     * @private
     */
    ListDialog.prototype.showListDialog = function () {
        var locale = new L10n('documenteditor', this.owner.owner.defaultLocale);
        locale.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initListDialog(locale, this.owner.owner.enableRtl);
        }
        this.isListCharacterFormat = true;
        this.owner.dialog2.header = locale.getConstant('Define new Multilevel list');
        this.owner.dialog2.height = 'auto';
        this.owner.dialog2.width = 'auto';
        this.owner.dialog2.content = this.target;
        var buttonClass;
        var isRtl = this.owner.owner.enableRtl;
        if (isRtl) {
            buttonClass = 'e-flat e-list-dlg-font e-de-dlg-target.e-de-rtl e-font-rtl';
        }
        else {
            buttonClass = 'e-flat e-list-dlg-font e-font';
        }
        this.owner.dialog2.buttons = [{
                click: this.showFontDialog,
                buttonModel: { content: locale.getConstant('Font'), cssClass: buttonClass }
            }, {
                click: this.onApplyList,
                buttonModel: { content: locale.getConstant('Ok'), cssClass: 'e-flat e-list-dlg', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: locale.getConstant('Cancel'), cssClass: 'e-flat e-list-dlg' }
            }];
        this.owner.dialog2.dataBind();
        this.wireAndBindEvent(locale, isRtl);
        this.owner.dialog2.beforeOpen = this.loadListDialog;
        this.owner.dialog2.close = this.closeListDialog;
        this.owner.dialog2.position = { X: 'center', Y: 'top' };
        this.owner.dialog2.show();
    };
    /**
     * Shows the table properties dialog
     * @private
     */
    ListDialog.prototype.initListDialog = function (locale, isRtl) {
        var containerId = this.owner.owner.containerId;
        var id = containerId + '_insert_list';
        this.target = createElement('div', { id: id, className: 'e-de-list-dlg' });
        // tslint:disable-next-line:max-line-length
        var listLevelDiv = createElement('div', { innerHTML: '<label id="' + containerId + '_listLevellabel" style="display:block;" class=e-de-list-ddl-header-list-level>' + locale.getConstant('List level') + '</label><label id="' + containerId + '_modifyLabel" style="display:block;" class=e-de-list-ddl-subheader>' + locale.getConstant('Choose level to modify') + '</label><select style="height:20px;width:43%" id="' + containerId + '_listLevel"><option>' + locale.getConstant('Level') + ' 1' + '</option><option>' + locale.getConstant('Level') + ' 2' + '</option><option>' + locale.getConstant('Level') + ' 3' + '</option><option>' + locale.getConstant('Level') + ' 4' + '</option><option>' + locale.getConstant('Level') + ' 5' + '</option><option>' + locale.getConstant('Level') + ' 6' + '</option><option>' + locale.getConstant('Level') + ' 7' + '</option><option>' + locale.getConstant('Level') + ' 8' + '</option><option>' + locale.getConstant('Level') + ' 9' + '</option></select>' });
        this.target.appendChild(listLevelDiv);
        var div = createElement('div');
        var divStyle;
        if (isRtl) {
            divStyle = '<div style="float:right;display:block;width:241px;">';
        }
        else {
            divStyle = '<div style="float:left;display:block;">';
        }
        // tslint:disable-next-line:max-line-length
        var numberStyleDiv = createElement('div', { innerHTML: divStyle + '<label id="' + containerId + '_numberFormatLabel" style="display:block;" class=e-de-list-ddl-header>' + locale.getConstant('Number format') + '</label><label id="' + containerId + '_numberStyleLabel" style="display:block;" class=e-de-list-ddl-subheader>' + locale.getConstant('Number style for this level') + '</label><select style="height:20px;width:100%" id="' + containerId + '_numberStyle"><option>' + locale.getConstant('Arabic') + '</option><option>' + locale.getConstant('UpRoman') + '</option><option>' + locale.getConstant('LowRoman') + '</option><option>' + locale.getConstant('UpLetter') + '</option><option>' + locale.getConstant('LowLetter') + '</option><option>' + locale.getConstant('Number') + '</option><option>' + locale.getConstant('Leading zero') + '</option><option>' + locale.getConstant('Bullet') + '</option><option>' + locale.getConstant('Ordinal') + '</option><option>' + locale.getConstant('Ordinal Text') + '</option><option>' + locale.getConstant('Special') + '</option><option>' + locale.getConstant('For East') + '</option></select><label id="' + containerId + '_startAtLabel" style="display:block;" class=e-de-list-ddl-subheaderbottom>' + locale.getConstant('Start at') + '</label><input type="text" id="' + containerId + '_startAt">' });
        div.appendChild(numberStyleDiv);
        // tslint:disable-next-line:max-line-length
        this.numberFormatDiv = createElement('div', { className: 'e-de-list-dlg-subdiv', innerHTML: '<div><div><label id="' + containerId + '_formatLabel" style="display:inline-block;width:86%" class=e-de-list-ddl-subheader>' + locale.getConstant('Enter formatting for number') + '</label><button type="button" id="' + containerId + '_list_info" class="e-control e-btn e-primary e-de-list-format-info">i</button></div><input style=width:180px; type="text" id="' + containerId + '_numberFormat" class=e-input></div><label id="' + containerId + '_restartLabel" style="display:block;" class=e-de-list-ddl-subheaderbottom>' + locale.getConstant('Restart list after') + '</label><select style="height:20px;width:100%" id="' + containerId + '_restartBy"><option>' + locale.getConstant('No Restart') + '</option></select></div>' });
        div.appendChild(this.numberFormatDiv);
        this.target.appendChild(div);
        var indentsDivLabelStyle;
        if (isRtl) {
            indentsDivLabelStyle = 'display:block;position:relative; ';
        }
        else {
            indentsDivLabelStyle = 'display:block; ';
        }
        // tslint:disable-next-line:max-line-length
        var indentsDiv = createElement('div', { innerHTML: divStyle + '<label id="' + containerId + '_IndentsLabel" style=' + indentsDivLabelStyle + 'class=e-de-list-ddl-header>' + locale.getConstant('Position') + '</label><label id="' + containerId + '_textIndentLabel" style=' + indentsDivLabelStyle + 'class=e-de-list-ddl-subheader>' + locale.getConstant('Text indent at') + '</label><input type="text" id="' + containerId + '_textIndent"><label id="' + containerId + '_followCharacterLabel" style=' + indentsDivLabelStyle + 'class=e-de-list-ddl-subheaderbottom>' + locale.getConstant('Follow number with') + '</label><select style="height:20px;width:100%" id="' + containerId + '_followCharacter"><option>' + locale.getConstant('Tab character') + '</option><option>' + locale.getConstant('Space') + '</option><option>' + locale.getConstant('Nothing') + '</option></select></div><div id="e-de-list-dlg-div" class="e-de-list-dlg-div"><label id="' + containerId + '_alignedAtLabel" style="display:block;" class=e-de-list-ddl-subheader>' + locale.getConstant('Aligned at') + '</label><input type="text" id="' + containerId + '_alignedAt"></div>', });
        this.target.appendChild(indentsDiv);
    };
    ListDialog.prototype.wireAndBindEvent = function (locale, isRtl) {
        var instance = this;
        var containerId = this.owner.owner.containerId;
        if (isRtl) {
            document.getElementById('e-de-list-dlg-div').classList.add('e-de-rtl');
            this.numberFormatDiv.classList.add('e-de-rtl');
        }
        var startAtTextBox = document.getElementById(containerId + '_startAt');
        var textIndentAtTextBox = document.getElementById(containerId + '_textIndent');
        var alignedAtTextBox = document.getElementById(containerId + '_alignedAt');
        this.startAt = new NumericTextBox({
            format: '#',
            decimals: 0,
            min: 0,
            max: 50,
            width: '180px',
            enablePersistence: false,
        });
        this.startAt.addEventListener('change', instance.onStartValueChanged);
        this.startAt.appendTo(startAtTextBox);
        this.textIndent = new NumericTextBox({
            format: '#',
            decimals: 0,
            min: 0,
            max: 1584,
            width: '180px',
            step: 4,
            enablePersistence: false
        });
        this.textIndent.addEventListener('change', instance.onTextIndentChanged);
        this.textIndent.appendTo(textIndentAtTextBox);
        this.alignedAt = new NumericTextBox({
            format: '#',
            max: 1584,
            step: 6,
            width: '180px',
            enablePersistence: false
        });
        this.alignedAt.addEventListener('change', instance.onAlignedAtValueChanged);
        this.alignedAt.appendTo(alignedAtTextBox);
        var listLevel = document.getElementById(containerId + '_listLevel');
        // tslint:disable-next-line:max-line-length
        this.listLevelElement = new DropDownList({ popupHeight: '150px', width: '180px', enableRtl: isRtl, change: instance.onListLevelValueChanged });
        this.listLevelElement.appendTo(listLevel);
        var followCharacterElement = document.getElementById(containerId + '_followCharacter');
        // tslint:disable-next-line:max-line-length
        this.followNumberWith = new DropDownList({ popupHeight: '150px', width: '180px', enableRtl: isRtl, change: instance.onFollowCharacterValueChanged });
        this.followNumberWith.appendTo(followCharacterElement);
        var numberStyleEle = document.getElementById(containerId + '_numberStyle');
        // tslint:disable-next-line:max-line-length
        this.numberStyle = new DropDownList({ popupHeight: '150px', width: '180px', enableRtl: isRtl, change: instance.onLevelPatternValueChanged });
        this.numberStyle.appendTo(numberStyleEle);
        this.numberFormat = document.getElementById(containerId + '_numberFormat');
        this.numberFormat.addEventListener('change', instance.onNumberFormatChanged);
        var restartElement = document.getElementById(containerId + '_restartBy');
        this.restartBy = new DropDownList({ popupHeight: '150px', width: '180px', enableRtl: isRtl });
        this.restartBy.appendTo(restartElement);
        var button = document.getElementById(containerId + '_list_info');
        this.formatInfoToolTip = new Tooltip({ width: 200 });
        // tslint:disable-next-line:max-line-length
        this.formatInfoToolTip.content = locale.getConstant('Number format tooltip information');
        this.formatInfoToolTip.position = 'RightTop';
        this.formatInfoToolTip.appendTo(button);
    };
    ListDialog.prototype.updateRestartLevelBox = function () {
        var containerId = this.owner.owner.containerId;
        var listLevel = document.getElementById(containerId + '_listLevel');
        var restartBy = document.getElementById(containerId + '_restartBy');
        for (var i = 0; i < restartBy.options.length; i) {
            restartBy.options.remove(i);
        }
        if (listLevel.selectedIndex === 0) {
            var option = document.createElement('option');
            option.value = 'No Restart';
            option.innerHTML = 'No Restart';
            restartBy.appendChild(option);
        }
        else {
            for (var i = listLevel.selectedIndex; i > 0; i--) {
                var option_1 = document.createElement('option');
                option_1.value = 'Level ' + i;
                option_1.innerHTML = 'Level ' + i;
                restartBy.appendChild(option_1);
            }
            var option = document.createElement('option');
            option.value = 'No Restart';
            option.innerHTML = 'No Restart';
            restartBy.appendChild(option);
        }
        restartBy.selectedIndex = 0;
    };
    ListDialog.prototype.listPatternConverter = function (listLevelPattern) {
        switch (listLevelPattern) {
            case 'Arabic': return 0;
            case 'UpRoman': return 1;
            case 'LowRoman': return 2;
            case 'UpLetter': return 3;
            case 'LowLetter': return 4;
            case 'Number': return 5;
            case 'LeadingZero': return 6;
            case 'Bullet': return 7;
            case 'Ordinal': return 8;
            case 'OrdinalText': return 9;
            case 'Special': return 10;
            case 'FarEast': return 11;
            default: return 12;
        }
    };
    ListDialog.prototype.followCharacterConverter = function (followCharacter) {
        switch (followCharacter) {
            case 'Tab':
                return 0;
            case 'Space':
                return 1;
            default:
                return 2;
        }
    };
    ListDialog.prototype.updateDialogValues = function () {
        // tslint:disable-next-line:max-line-length
        var restartByTextBox = document.getElementById(this.owner.owner.containerId + '_restartBy');
        if (!isNullOrUndefined(this.viewModel) && !isNullOrUndefined(this.viewModel.listLevel)) {
            this.startAt.value = this.viewModel.listLevel.startAt;
            this.textIndent.value = this.viewModel.listLevel.paragraphFormat.leftIndent;
            this.alignedAt.value = this.viewModel.listLevel.paragraphFormat.firstLineIndent;
            this.followNumberWith.index = this.followCharacterConverter(this.viewModel.followCharacter);
            this.numberFormat.value = this.viewModel.listLevel.numberFormat;
            this.numberStyle.index = this.listPatternConverter(this.viewModel.listLevelPattern);
            this.listLevelElement.index = this.viewModel.levelNumber;
            this.viewModel.levelNumber = this.viewModel.levelNumber;
        }
    };
    ListDialog.prototype.disposeBindingForListUI = function () {
        this.followNumberWith.index = -1;
        this.numberFormat.value = ' ';
        this.numberStyle.index = -1;
        this.listLevelElement.index = -1;
        this.restartBy.index = -1;
        this.viewModel.destroy();
    };
    /**
     * @private
     */
    ListDialog.prototype.destroy = function () {
        if (this.alignedAt) {
            this.alignedAt.destroy();
        }
        this.alignedAt = undefined;
        this.dialog = undefined;
        if (this.followNumberWith) {
            this.followNumberWith.destroy();
        }
        this.followNumberWith = undefined;
        if (this.listLevelElement) {
            this.listLevelElement.destroy();
        }
        this.listLevelElement = undefined;
        if (this.textIndent) {
            this.textIndent.destroy();
        }
        this.textIndent = undefined;
        if (this.startAt) {
            this.startAt.destroy();
        }
        this.startAt = undefined;
        if (this.numberStyle) {
            this.numberStyle.destroy();
        }
        this.numberStyle = undefined;
        this.numberFormat = undefined;
        if (this.restartBy) {
            this.restartBy.destroy();
        }
        this.restartBy = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (var l = 0; l < this.target.childNodes.length; l++) {
                this.target.removeChild(this.target.childNodes[l]);
                l--;
            }
            this.target = undefined;
        }
        this.owner = undefined;
        this.viewModel = undefined;
    };
    return ListDialog;
}());

/* tslint:enable:no-any */

/**
 * The Style dialog is used to create or modify styles.
 */
var StyleDialog = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function StyleDialog(viewer) {
        var _this = this;
        this.target = undefined;
        this.styleType = undefined;
        this.styleBasedOn = undefined;
        this.styleParagraph = undefined;
        this.onlyThisDocument = undefined;
        this.template = undefined;
        this.fontFamily = undefined;
        this.fontSize = undefined;
        this.characterFormat = undefined;
        this.paragraphFormat = undefined;
        /* tslint:disable-next-line:no-any */
        this.openDialog = function (args) {
            switch (args.item.id) {
                case 'style_font':
                    _this.showFontDialog();
                    break;
                case 'style_paragraph':
                    _this.showParagraphDialog();
                    break;
                case 'style_numbering':
                    _this.showNumberingBulletDialog();
                    break;
            }
        };
        this.setBoldProperty = function () {
            _this.characterFormat.bold = !_this.characterFormat.bold;
            _this.fontButtonClicked(undefined);
        };
        this.setItalicProperty = function () {
            _this.characterFormat.italic = !_this.characterFormat.italic;
            _this.fontButtonClicked(undefined);
        };
        this.setUnderlineProperty = function () {
            _this.characterFormat.underline = _this.characterFormat.underline === 'None' ? 'Single' : 'None';
            _this.fontButtonClicked(undefined);
        };
        /* tslint:disable-next-line:no-any */
        this.fontButtonClicked = function (args) {
            if (_this.characterFormat.bold) {
                if (!_this.bold.classList.contains('e-active')) {
                    _this.bold.classList.add('e-active');
                }
            }
            else {
                if (_this.bold.classList.contains('e-active')) {
                    _this.bold.classList.remove('e-active');
                }
            }
            if (_this.characterFormat.italic) {
                if (!_this.italic.classList.contains('e-active')) {
                    _this.italic.classList.add('e-active');
                }
            }
            else {
                if (_this.italic.classList.contains('e-active')) {
                    _this.italic.classList.remove('e-active');
                }
            }
            if (_this.characterFormat.underline !== undefined && _this.characterFormat.underline !== 'None') {
                if (!_this.underline.classList.contains('e-active')) {
                    _this.underline.classList.add('e-active');
                    _this.characterFormat.underline = 'Single';
                }
            }
            else {
                if (_this.underline.classList.contains('e-active')) {
                    _this.underline.classList.remove('e-active');
                    _this.characterFormat.underline = 'None';
                }
            }
        };
        /* tslint:disable-next-line:no-any */
        this.fontSizeUpdate = function (args) {
            _this.characterFormat.fontSize = args.value;
        };
        /* tslint:disable-next-line:no-any */
        this.fontFamilyChanged = function (args) {
            _this.characterFormat.fontFamily = args.value;
        };
        /* tslint:disable-next-line:no-any */
        this.fontColorUpdate = function (args) {
            _this.characterFormat.fontColor = args.currentValue.hex;
        };
        this.setLeftAlignment = function () {
            if (_this.paragraphFormat.textAlignment === 'Left') {
                _this.paragraphFormat.textAlignment = 'Justify';
            }
            else {
                _this.paragraphFormat.textAlignment = 'Left';
            }
            _this.updateParagraphFormat();
        };
        this.setRightAlignment = function () {
            if (_this.paragraphFormat.textAlignment === 'Right') {
                _this.paragraphFormat.textAlignment = 'Left';
            }
            else {
                _this.paragraphFormat.textAlignment = 'Right';
            }
            _this.updateParagraphFormat();
        };
        this.setCenterAlignment = function () {
            if (_this.paragraphFormat.textAlignment === 'Center') {
                _this.paragraphFormat.textAlignment = 'Left';
            }
            else {
                _this.paragraphFormat.textAlignment = 'Center';
            }
            _this.updateParagraphFormat();
        };
        this.setJustifyAlignment = function () {
            if (_this.paragraphFormat.textAlignment === 'Justify') {
                _this.paragraphFormat.textAlignment = 'Left';
            }
            else {
                _this.paragraphFormat.textAlignment = 'Justify';
            }
            _this.updateParagraphFormat();
        };
        this.increaseBeforeAfterSpacing = function () {
            _this.paragraphFormat.beforeSpacing += 6;
            _this.paragraphFormat.afterSpacing += 6;
        };
        this.decreaseBeforeAfterSpacing = function () {
            if (_this.paragraphFormat.beforeSpacing >= 6) {
                _this.paragraphFormat.beforeSpacing -= 6;
            }
            else {
                _this.paragraphFormat.beforeSpacing = 0;
            }
            if (_this.paragraphFormat.afterSpacing >= 6) {
                _this.paragraphFormat.afterSpacing -= 6;
            }
            else {
                _this.paragraphFormat.afterSpacing = 0;
            }
        };
        /**
         * @private
         */
        this.updateNextStyle = function (args) {
            var typedName = args.srcElement.value;
            // tslint:disable-next-line:max-line-length
            if (_this.getTypeValue() === _this.localObj.getConstant('Paragraph') && !isNullOrUndefined(typedName) && typedName !== '' && !_this.isUserNextParaUpdated) {
                var styles = _this.owner.owner.viewer.styles.getStyleNames(_this.getTypeValue());
                if (_this.isEdit) {
                    styles = styles.filter(function (e) { return e !== _this.editStyleName; });
                }
                styles.push(typedName);
                _this.styleParagraph.dataSource = styles;
                _this.styleParagraph.index = null;
                _this.styleParagraph.index = styles.indexOf(typedName);
                _this.styleParagraph.dataBind();
            }
        };
        /**
         * @private
         */
        this.updateOkButton = function () {
            var styleName = _this.target.getElementsByClassName('e-input e-de-style-dlg-name-input').item(0).value;
            _this.enableOrDisableOkButton();
        };
        /**
         * @private
         */
        /* tslint:disable-next-line:no-any */
        this.styleTypeChange = function (args) {
            if (args.isInteracted) {
                var type = void 0;
                if (args.value === _this.localObj.getConstant('Character')) {
                    _this.style = new WCharacterStyle();
                    type = 'Character';
                }
                // tslint:disable-next-line:max-line-length
                if (args.value === _this.localObj.getConstant('Paragraph') || args.value === _this.localObj.getConstant('Linked Style')) {
                    _this.style = new WParagraphStyle();
                    type = 'Paragraph';
                }
                _this.toggleDisable();
                _this.updateStyleNames(type);
            }
        };
        /* tslint:disable-next-line:no-any */
        this.styleBasedOnChange = function (args) {
            //Based on change
        };
        /**
         * @private
         */
        /* tslint:disable-next-line:no-any */
        this.styleParagraphChange = function (args) {
            if (args.isInteracted) {
                _this.isUserNextParaUpdated = true;
            }
            //Next change
        };
        /**
         * @private
         */
        this.showFontDialog = function () {
            if (!isNullOrUndefined(_this.owner.owner.fontDialogModule)) {
                _this.owner.owner.showFontDialog(_this.characterFormat);
            }
            _this.updateCharacterFormat();
        };
        /**
         * @private
         */
        this.showParagraphDialog = function () {
            if (!isNullOrUndefined(_this.owner.owner.paragraphDialogModule)) {
                _this.owner.owner.showParagraphDialog(_this.paragraphFormat);
            }
        };
        /**
         * @private
         */
        this.showNumberingBulletDialog = function () {
            _this.numberingBulletDialog = new BulletsAndNumberingDialog(_this.owner.owner.viewer);
            if (_this.style instanceof WParagraphStyle && (!isNullOrUndefined(_this.style.paragraphFormat))) {
                // tslint:disable-next-line:max-line-length
                _this.numberingBulletDialog.showNumberBulletDialog(_this.style.paragraphFormat.listFormat, _this.abstractList);
            }
        };
        /**
         * @private
         */
        this.onOkButtonClick = function () {
            var styleName = _this.styleNameElement.value;
            if (styleName.length > 0) {
                var style = _this.owner.owner.viewer.styles.findByName(styleName);
                var name_1;
                if (!isNullOrUndefined(style)) {
                    _this.style.type = _this.getTypeValue();
                    _this.style.basedOn = _this.owner.owner.viewer.styles.findByName(_this.styleBasedOn.value);
                    // tslint:disable-next-line:max-line-length
                    if (_this.styleType.value === _this.localObj.getConstant('Paragraph') || _this.styleType.value === _this.localObj.getConstant('Linked Style')) {
                        _this.style.next = _this.owner.owner.viewer.styles.findByName(_this.styleParagraph.value);
                        _this.style.characterFormat.mergeFormat(style.characterFormat);
                        _this.style.paragraphFormat.mergeFormat(style.paragraphFormat, true);
                        _this.updateList();
                        // tslint:disable-next-line:max-line-length
                        _this.style.link = (_this.styleType.value === _this.localObj.getConstant('Linked Style')) ? _this.createLinkStyle(styleName, _this.isEdit) : undefined;
                    }
                    //Updating existing style implementation
                    _this.style.name = style.name;
                    name_1 = style.name;
                    style = _this.style;
                    _this.owner.owner.isShiftingEnabled = true;
                    _this.owner.owner.editorModule.layoutWholeDocument();
                    _this.owner.owner.isShiftingEnabled = false;
                }
                else {
                    /* tslint:disable-next-line:no-any */
                    var tmpStyle = _this.getTypeValue() === 'Paragraph' ? new WParagraphStyle() : new WCharacterStyle;
                    tmpStyle.copyStyle(_this.style);
                    /* tslint:disable-next-line:no-any */
                    var basedOn = _this.owner.owner.viewer.styles.findByName(_this.styleBasedOn.value);
                    // tslint:disable-next-line:max-line-length
                    if (_this.styleType.value === _this.localObj.getConstant('Paragraph') || _this.styleType.value === _this.localObj.getConstant('Linked Style')) {
                        if (styleName === _this.styleParagraph.value) {
                            tmpStyle.next = tmpStyle;
                        }
                        else {
                            tmpStyle.next = _this.owner.owner.viewer.styles.findByName(_this.styleParagraph.value);
                        }
                        _this.updateList();
                    }
                    // tslint:disable-next-line:max-line-length
                    tmpStyle.link = (_this.styleType.value === _this.localObj.getConstant('Linked Style')) ? _this.createLinkStyle(styleName) : undefined;
                    tmpStyle.type = _this.getTypeValue();
                    tmpStyle.name = styleName;
                    tmpStyle.basedOn = basedOn;
                    /* tslint:disable-next-line:no-any */
                    _this.owner.owner.viewer.styles.push(tmpStyle);
                    name_1 = styleName;
                    _this.owner.owner.editorModule.applyStyle(name_1);
                }
                _this.owner.owner.viewer.dialog2.hide();
            }
            else {
                throw new Error('Enter valid Style name');
            }
            if (_this.style) {
                //this.style.destroy();
            }
        };
        /* tslint:disable-next-line:no-any */
        this.loadStyleDialog = function (args) {
            _this.owner.owner.viewer.updateFocus();
            _this.isUserNextParaUpdated = false;
            /*tslint:disable-next-line:max-line-length */
            _this.styleNameElement = _this.target.getElementsByClassName('e-input e-de-style-dlg-name-input').item(0);
            _this.styleNameElement.value = null;
            if (!_this.isEdit) {
                _this.styleType.index = 0; //Set to paragraph            
            }
            var name;
            if (_this.isEdit) {
                _this.styleNameElement.value = _this.editStyleName;
                name = _this.editStyleName;
            }
            /*tslint:disable-next-line:max-line-length */
            _this.okButton = _this.owner.dialog2.element.getElementsByClassName('e-flat e-style-okay').item(0);
            _this.enableOrDisableOkButton();
            _this.updateStyleNames(_this.getTypeValue(), name);
            _this.updateCharacterFormat(_this.style.characterFormat);
            _this.updateParagraphFormat(_this.style.paragraphFormat);
        };
        /**
         * @private
         */
        this.onCancelButtonClick = function () {
            if (!_this.isEdit && _this.style) {
                _this.style.destroy();
            }
            _this.owner.owner.viewer.dialog2.hide();
        };
        /**
         * @private
         */
        this.closeStyleDialog = function () {
            _this.owner.owner.viewer.updateFocus();
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    StyleDialog.prototype.getModuleName = function () {
        return 'StyleDialog';
    };
    /**
     * @private
     */
    //tslint:disable: max-func-body-length
    StyleDialog.prototype.initStyleDialog = function (localValue, isRtl) {
        this.localObj = localValue;
        var id = this.owner.owner.containerId + '_style';
        this.target = createElement('div', { id: id, className: 'e-de-style-dialog' });
        var container = createElement('div');
        // tslint:disable-next-line:max-line-length
        var properties = createElement('div', { className: 'e-de-style-properties', innerHTML: localValue.getConstant('Properties') });
        container.appendChild(properties);
        var styleNameTypeDiv = createElement('div', { styles: 'display:flex', className: 'e-de-style-nametype-div' });
        container.appendChild(styleNameTypeDiv);
        var nameWholeDiv = createElement('div', { className: 'e-de-style-left-div' });
        styleNameTypeDiv.appendChild(nameWholeDiv);
        var name = createElement('div', { className: 'e-de-style-name', innerHTML: localValue.getConstant('Name') + ':' });
        nameWholeDiv.appendChild(name);
        // tslint:disable-next-line:max-line-length
        var nameValue = createElement('input', { id: this.owner.owner.containerId + '_style_name', styles: 'width:210px;', className: 'e-input e-de-style-dlg-name-input' });
        nameValue.addEventListener('keyup', this.updateOkButton);
        nameValue.addEventListener('input', this.updateOkButton);
        nameValue.addEventListener('blur', this.updateNextStyle);
        nameWholeDiv.appendChild(nameValue);
        var styleTypeWholeDiv = createElement('div');
        styleNameTypeDiv.appendChild(styleTypeWholeDiv);
        // tslint:disable-next-line:max-line-length
        var styleType = createElement('div', { className: 'e-de-style-styletype', innerHTML: localValue.getConstant('Style type') + ':' });
        styleTypeWholeDiv.appendChild(styleType);
        var styleTypeDivElement = createElement('div', { className: 'e-de-style-style-type-div' });
        var styleTypeValue = createElement('select', { id: 'e-de-style-style-type' });
        // tslint:disable-next-line:max-line-length
        styleTypeValue.innerHTML = '<option>' + localValue.getConstant('Paragraph') + '</option><option>' + localValue.getConstant('Character') + '</option><option>' + localValue.getConstant('Linked Style') + '</option>'; //<option>Linked(Paragraph and Character)</option><option>Table</option><option>List</option>';
        styleTypeDivElement.appendChild(styleTypeValue);
        this.styleType = new DropDownList({ change: this.styleTypeChange, popupHeight: '253px', width: '210px', enableRtl: isRtl });
        this.styleType.appendTo(styleTypeValue);
        styleTypeWholeDiv.appendChild(styleTypeDivElement);
        // tslint:disable-next-line:max-line-length
        var styleBasedParaDiv = createElement('div', { styles: 'display:flex', className: 'e-de-style-based-para-div' });
        container.appendChild(styleBasedParaDiv);
        var styleBasedOnWholeDiv = createElement('div', { className: 'e-de-style-left-div' });
        styleBasedParaDiv.appendChild(styleBasedOnWholeDiv);
        // tslint:disable-next-line:max-line-length
        var styleBasedOn = createElement('div', { className: 'e-de-style-style-based-on', innerHTML: localValue.getConstant('Style based on') + ':' });
        styleBasedOnWholeDiv.appendChild(styleBasedOn);
        var styleBasedOnDivElement = createElement('div', { className: 'e-de-style-style-based-on-div' });
        // tslint:disable-next-line:max-line-length
        var styleBasedOnValue = createElement('input', { id: 'e-de-style-style-based-on-value' });
        //styleBasedOnValue.innerHTML = '<option>Normal</option><option>Heading 1</option><option>Heading 2</option><option>Heading 3</option><option>Heading 4</option><option>Heading 5</option><option>Heading 6</option>';
        styleBasedOnDivElement.appendChild(styleBasedOnValue);
        // tslint:disable-next-line:max-line-length
        this.styleBasedOn = new DropDownList({ dataSource: [], select: this.styleBasedOnChange, popupHeight: '253px', width: '210px', enableRtl: isRtl });
        this.styleBasedOn.appendTo(styleBasedOnValue);
        styleBasedOnWholeDiv.appendChild(styleBasedOnDivElement);
        var styleParagraphWholeDiv = createElement('div');
        styleBasedParaDiv.appendChild(styleParagraphWholeDiv);
        if (isRtl) {
            nameWholeDiv.classList.add('e-de-rtl');
            styleBasedOnWholeDiv.classList.add('e-de-rtl');
            styleParagraphWholeDiv.classList.add('e-de-rtl');
        }
        // tslint:disable-next-line:max-line-length
        var styleParagraph = createElement('div', { className: 'e-de-style-style-paragraph', innerHTML: localValue.getConstant('Style for following paragraph') + ':' });
        styleParagraphWholeDiv.appendChild(styleParagraph);
        var styleParagraphDivElement = createElement('div', { className: 'e-de-style-style-paragraph-div' });
        // tslint:disable-next-line:max-line-length
        var styleParagraphValue = createElement('input', { id: 'e-de-style-style-paragraph-value' });
        // tslint:disable-next-line:max-line-length
        //styleParagraphValue.innerHTML = '<option>Normal</option><option>Heading 1</option><option>Heading 2</option><option>Heading 3</option><option>Heading 4</option><option>Heading 5</option><option>Heading 6</option>';
        styleParagraphDivElement.appendChild(styleParagraphValue);
        // tslint:disable-next-line:max-line-length
        this.styleParagraph = new DropDownList({ dataSource: [], select: this.styleParagraphChange, popupHeight: '253px', width: '210px', enableRtl: isRtl });
        this.styleParagraph.appendTo(styleParagraphValue);
        styleParagraphWholeDiv.appendChild(styleParagraphDivElement);
        // tslint:disable-next-line:max-line-length
        var formatting = createElement('div', { className: 'e-de-style-formatting', innerHTML: localValue.getConstant('Formatting') });
        container.appendChild(formatting);
        var optionsDiv = createElement('div', { className: 'e-de-style-options-div' });
        container.appendChild(optionsDiv);
        var fontOptionsDiv = createElement('div', { styles: 'display:flex;margin-bottom: 14px;' });
        optionsDiv.appendChild(fontOptionsDiv);
        this.createFontOptions(fontOptionsDiv, isRtl);
        var paragraphOptionsDiv = createElement('div', { styles: 'display:flex', className: 'e-style-paragraph' });
        optionsDiv.appendChild(paragraphOptionsDiv);
        this.createParagraphOptions(paragraphOptionsDiv);
        // let radioOptionsDiv: HTMLElement = createElement('div', { styles: 'display:flex' });
        // container.appendChild(radioOptionsDiv);
        // let onlyThisDocumentDiv: HTMLElement = createElement('div', { className: 'e-de-style-radio-button' });
        // tslint:disable-next-line:max-line-length
        // let onlyThisDocument: HTMLInputElement = createElement('input', { className: 'e-de-style-only-this-doc', attrs: { type: 'radio' } }) as HTMLInputElement;
        // onlyThisDocumentDiv.appendChild(onlyThisDocument);
        // tslint:disable-next-line:max-line-length
        // this.onlyThisDocument = new RadioButton({ label: 'Only in this document', value: 'only in this document', checked: true, name: 'styles' });
        // this.onlyThisDocument.appendTo(onlyThisDocument);
        // radioOptionsDiv.appendChild(onlyThisDocumentDiv);
        // let templateDiv: HTMLElement = createElement('div', { className: 'e-de-style-radio-button' });
        // tslint:disable-next-line:max-line-length
        // let template: HTMLInputElement = createElement('input', { className: 'e-de-style-temp', attrs: { type: 'radio' } }) as HTMLInputElement;
        // templateDiv.appendChild(template);
        // this.template = new RadioButton({ label: 'Template', value: 'template', name: 'styles' });
        // this.template.appendTo(template);
        // radioOptionsDiv.appendChild(templateDiv);
        this.createFormatDropdown(container, localValue, isRtl);
        this.target.appendChild(container);
    };
    StyleDialog.prototype.createFormatDropdown = function (parentDiv, localValue, isRtl) {
        var _this = this;
        var formatBtn = createElement('button', {
            id: 'style_format_dropdown', innerHTML: localValue.getConstant('Format'),
            attrs: { type: 'button' }
        });
        formatBtn.style.height = '31px';
        parentDiv.appendChild(formatBtn);
        var items = [{ text: localValue.getConstant('Font') + '..', id: 'style_font' },
            { text: localValue.getConstant('Paragraph') + '..', id: 'style_paragraph' },
            { text: localValue.getConstant('Numbering') + '..', id: 'style_numbering' }];
        this.styleDropdwn = new DropDownButton({
            items: items, cssClass: 'e-de-style-format-dropdwn', enableRtl: isRtl,
            beforeItemRender: function (args) {
                if (_this.styleType.value === localValue.getConstant('Character')) {
                    if (args.item.text === localValue.getConstant('Paragraph')) {
                        args.element.classList.add('e-disabled');
                    }
                    if (args.item.text === 'Numbering') {
                        args.element.classList.add('e-disabled');
                    }
                }
                else {
                    if (args.item.text === localValue.getConstant('Paragraph')) {
                        args.element.classList.remove('e-disabled');
                    }
                    if (args.item.text === 'Numbering') {
                        args.element.classList.remove('e-disabled');
                    }
                }
            }
        });
        this.styleDropdwn.appendTo(formatBtn);
        this.styleDropdwn.addEventListener('select', this.openDialog);
    };
    StyleDialog.prototype.createFontOptions = function (parentDiv, isRtl) {
        var fontFamilyElement = createElement('select', { id: this.target.id + '_fontName' });
        fontFamilyElement.innerHTML = '<option>Arial</option><option>Calibri</option><option>Candara</option>' +
            '<option>Comic Sans MS</option><option>Consolas</option><option>Constantia</option><option>Corbel</option>' +
            '<option>Courier New</option><option>Ebrima</option><option>Franklin Gothic</option>' +
            '<option>Gabriola</option><option>Gadugi</option><option>Georgia</option><option>Impact</option>' +
            '<option>Javanese Text</option><option>Microsoft Sans Serif</option><option>MS Gothic</option><option>MS UI Gothic</option>' +
            '<option>Segoe Print</option><option>Times New Roman</option><option>Verdana</option><option>Segoe UI</option>' +
            '<option>Algerian</option><option>Cambria</option><option>Georgia</option><option>Consolas</option>';
        parentDiv.appendChild(fontFamilyElement);
        this.fontFamily = new ComboBox({
            width: '123px', popupWidth: '123px',
            cssClass: 'e-style-font-fmaily-right', enableRtl: isRtl, change: this.fontFamilyChanged
        });
        this.fontFamily.showClearButton = false;
        this.fontFamily.appendTo(fontFamilyElement);
        var fontSizeElement = createElement('input');
        parentDiv.appendChild(fontSizeElement);
        var sizeDataSource = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];
        this.fontSize = new ComboBox({
            dataSource: sizeDataSource, width: '73px', cssClass: 'e-style-font-fmaily-right',
            enableRtl: isRtl, change: this.fontSizeUpdate
        });
        this.fontSize.showClearButton = false;
        this.fontSize.appendTo(fontSizeElement);
        var fontGroupButton = createElement('div', { className: 'e-de-style-font-group-button' });
        parentDiv.appendChild(fontGroupButton);
        // tslint:disable-next-line:max-line-length
        this.bold = this.createButtonElement(fontGroupButton, 'e-de-bold', 'e-de-style-bold-button-size', this.owner.owner.containerId + '_style_bold');
        this.bold.addEventListener('click', this.setBoldProperty);
        // tslint:disable-next-line:max-line-length
        this.italic = this.createButtonElement(fontGroupButton, 'e-de-italic', 'e-de-style-icon-button-size', this.owner.owner.containerId + '_style_italic');
        this.italic.addEventListener('click', this.setItalicProperty);
        // tslint:disable-next-line:max-line-length
        this.underline = this.createButtonElement(fontGroupButton, 'e-de-underline', 'e-de-style-icon-button-size', this.owner.owner.containerId + '_style_underline');
        this.underline.addEventListener('click', this.setUnderlineProperty);
        var fontColorElement = createElement('input', { attrs: { type: 'color' }, className: 'e-de-style-icon-button-size' });
        parentDiv.appendChild(fontColorElement);
        // tslint:disable-next-line:max-line-length
        this.fontColor = new ColorPicker({ cssClass: 'e-de-style-font-color-picker', enableRtl: isRtl, change: this.fontColorUpdate, locale: this.owner.owner.locale });
        this.fontColor.appendTo(fontColorElement);
    };
    StyleDialog.prototype.createParagraphOptions = function (parentDiv) {
        var _this = this;
        var alignmentDiv = createElement('div', { className: 'e-de-style-paragraph-group-button' });
        parentDiv.appendChild(alignmentDiv);
        this.leftAlign = this.createButtonElement(alignmentDiv, 'e-de-align-left', 'e-de-style-icon-button-size');
        this.leftAlign.addEventListener('click', this.setLeftAlignment);
        this.centerAlign = this.createButtonElement(alignmentDiv, 'e-de-align-center', 'e-de-style-icon-button-size');
        this.centerAlign.addEventListener('click', this.setCenterAlignment);
        this.rightAlign = this.createButtonElement(alignmentDiv, 'e-de-align-right', 'e-de-style-icon-button-size');
        this.rightAlign.addEventListener('click', this.setRightAlignment);
        this.justify = this.createButtonElement(alignmentDiv, 'e-de-justify', 'e-de-style-icon-button-last-size');
        this.justify.addEventListener('click', this.setJustifyAlignment);
        var lineSpacingDiv = createElement('div', { className: 'e-de-style-paragraph-group-button' });
        parentDiv.appendChild(lineSpacingDiv);
        this.singleLineSpacing = this.createButtonElement(lineSpacingDiv, 'e-de-single-spacing', 'e-de-style-icon-button-first-size');
        this.singleLineSpacing.addEventListener('click', function () {
            _this.paragraphFormat.lineSpacing = 1;
            _this.updateParagraphFormat();
        });
        // tslint:disable-next-line:max-line-length
        this.onePointFiveLineSpacing = this.createButtonElement(lineSpacingDiv, 'e-de-one-point-five-spacing', 'e-de-style-icon-button-size');
        this.onePointFiveLineSpacing.addEventListener('click', function () {
            _this.paragraphFormat.lineSpacing = 1.5;
            _this.updateParagraphFormat();
        });
        this.doubleLineSpacing = this.createButtonElement(lineSpacingDiv, 'e-de-double-spacing', 'e-de-style-icon-button-last-size');
        this.doubleLineSpacing.addEventListener('click', function () {
            _this.paragraphFormat.lineSpacing = 2;
            _this.updateParagraphFormat();
        });
        var spacingDiv = createElement('div', { className: 'e-de-style-paragraph-group-button' });
        parentDiv.appendChild(spacingDiv);
        var beforeSpacing = this.createButtonElement(spacingDiv, 'e-de-before-spacing', 'e-de-style-icon-button-first-size');
        var afterSpacing = this.createButtonElement(spacingDiv, 'e-de-after-spacing', 'e-de-style-icon-button-last-size');
        beforeSpacing.addEventListener('click', this.increaseBeforeAfterSpacing);
        afterSpacing.addEventListener('click', this.decreaseBeforeAfterSpacing);
        var indentingDiv = createElement('div', { className: 'e-de-style-paragraph-indent-group-button' });
        parentDiv.appendChild(indentingDiv);
        var decreaseIndent = this.createButtonElement(indentingDiv, 'e-de-indent', 'e-de-style-icon-button-first-size');
        decreaseIndent.addEventListener('click', function () {
            if (_this.paragraphFormat.leftIndent >= 36) {
                _this.paragraphFormat.leftIndent -= 36;
            }
            else {
                _this.paragraphFormat.leftIndent = 0;
            }
        });
        var increaseindent = this.createButtonElement(indentingDiv, 'e-de-outdent', 'e-de-style-icon-button-size');
        increaseindent.addEventListener('click', function () {
            _this.paragraphFormat.leftIndent += 36;
        });
    };
    StyleDialog.prototype.createButtonElement = function (parentDiv, iconCss, className, id) {
        var buttonElement = createElement('button', { attrs: { type: 'button' } });
        if (!isNullOrUndefined(id)) {
            buttonElement.id = id;
        }
        parentDiv.appendChild(buttonElement);
        var button = new Button({ iconCss: iconCss, cssClass: className });
        button.appendTo(buttonElement);
        return buttonElement;
    };
    StyleDialog.prototype.toggleDisable = function () {
        if (this.styleType.value === this.localObj.getConstant('Character')) {
            this.styleParagraph.enabled = false;
            // tslint:disable-next-line:max-line-length
            this.target.getElementsByClassName('e-style-paragraph').item(0).setAttribute('style', 'display:flex;pointer-events:none;opacity:0.5');
        }
        else {
            this.styleParagraph.enabled = true;
            this.target.getElementsByClassName('e-style-paragraph').item(0).removeAttribute('style');
            this.target.getElementsByClassName('e-style-paragraph').item(0).setAttribute('style', 'display:flex');
        }
        this.styleBasedOn.enabled = true;
    };
    /**
     * @private
     */
    StyleDialog.prototype.show = function (styleName, header) {
        var localObj = new L10n('documenteditor', this.owner.owner.defaultLocale);
        this.isEdit = (!isNullOrUndefined(styleName) && styleName.length > 0) ? true : false;
        this.editStyleName = styleName;
        this.abstractList = new WAbstractList();
        // tslint:disable-next-line:max-line-length
        var style = this.owner.owner.viewer.styles.findByName(styleName);
        this.style = !this.isEdit ? new WParagraphStyle() : style ? style : this.getStyle(styleName);
        localObj.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initStyleDialog(localObj, this.owner.owner.enableRtl);
        }
        if (isNullOrUndefined(header)) {
            header = localObj.getConstant('Create New Style');
        }
        this.owner.owner.viewer.dialog2.header = header;
        this.owner.owner.viewer.dialog2.height = 'auto';
        this.owner.owner.viewer.dialog2.width = 'auto';
        this.owner.owner.viewer.dialog2.content = this.target;
        this.owner.owner.viewer.dialog2.buttons = [{
                click: this.onOkButtonClick,
                buttonModel: { content: localObj.getConstant('Ok'), cssClass: 'e-flat e-style-okay', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: localObj.getConstant('Cancel'), cssClass: 'e-flat e-style-cancel' }
            }];
        this.toggleDisable();
        this.owner.owner.viewer.dialog2.dataBind();
        this.owner.owner.viewer.dialog2.beforeOpen = this.loadStyleDialog;
        this.owner.owner.viewer.dialog2.close = this.closeStyleDialog;
        this.owner.owner.viewer.dialog2.position = { X: 'center', Y: 'center' };
        this.owner.owner.viewer.dialog2.show();
    };
    StyleDialog.prototype.updateList = function () {
        var listId = this.style.paragraphFormat.listFormat.listId;
        if (listId > -1) {
            if (this.owner.owner.viewer.lists.filter(function (a) { return (a.listId === listId); }).length === 0) {
                this.owner.owner.viewer.lists.push(this.style.paragraphFormat.listFormat.list);
            }
            else {
                this.owner.owner.viewer.lists = this.owner.owner.viewer.lists.filter(function (a) { return (a.listId !== listId); });
                this.owner.owner.viewer.lists.push(this.style.paragraphFormat.listFormat.list);
            }
        }
        if (this.abstractList.abstractListId !== -1) {
            this.owner.owner.viewer.abstractLists.push(this.abstractList);
        }
    };
    StyleDialog.prototype.createLinkStyle = function (name, isEdit) {
        var charStyle;
        if (isEdit) {
            charStyle = this.owner.owner.viewer.styles.findByName((name + ' Char'), 'Character');
        }
        else {
            charStyle = new WCharacterStyle();
        }
        charStyle.type = 'Character';
        charStyle.name = name + ' Char';
        charStyle.characterFormat = this.style.characterFormat.cloneFormat();
        charStyle.basedOn = this.style.basedOn;
        if (!isEdit) {
            this.owner.owner.viewer.styles.push(charStyle);
        }
        return this.owner.owner.viewer.styles.findByName(charStyle.name, 'Character');
    };
    /**
     * @private
     */
    StyleDialog.prototype.updateCharacterFormat = function (characterFormat) {
        if (!isNullOrUndefined(characterFormat)) {
            this.characterFormat = characterFormat;
        }
        this.fontFamily.value = this.characterFormat.fontFamily;
        this.fontSize.value = this.characterFormat.fontSize;
        this.fontColor.value = this.characterFormat.fontColor;
        this.fontButtonClicked(undefined);
    };
    /**
     * @private
     */
    StyleDialog.prototype.updateParagraphFormat = function (paragraphFOrmat) {
        if (!isNullOrUndefined(paragraphFOrmat)) {
            this.paragraphFormat = paragraphFOrmat;
        }
        if (this.paragraphFormat.textAlignment === 'Left') {
            if (!this.leftAlign.classList.contains('e-active')) {
                this.leftAlign.classList.add('e-active');
            }
            if (this.rightAlign.classList.contains('e-active')) {
                this.rightAlign.classList.remove('e-active');
            }
            if (this.centerAlign.classList.contains('e-active')) {
                this.centerAlign.classList.remove('e-active');
            }
            if (this.justify.classList.contains('e-active')) {
                this.justify.classList.remove('e-active');
            }
        }
        else if (this.paragraphFormat.textAlignment === 'Right') {
            if (this.leftAlign.classList.contains('e-active')) {
                this.leftAlign.classList.remove('e-active');
            }
            if (!this.rightAlign.classList.contains('e-active')) {
                this.rightAlign.classList.add('e-active');
            }
            if (this.centerAlign.classList.contains('e-active')) {
                this.centerAlign.classList.remove('e-active');
            }
            if (this.justify.classList.contains('e-active')) {
                this.justify.classList.remove('e-active');
            }
        }
        else if (this.paragraphFormat.textAlignment === 'Center') {
            if (this.leftAlign.classList.contains('e-active')) {
                this.leftAlign.classList.remove('e-active');
            }
            if (this.rightAlign.classList.contains('e-active')) {
                this.rightAlign.classList.remove('e-active');
            }
            if (!this.centerAlign.classList.contains('e-active')) {
                this.centerAlign.classList.add('e-active');
            }
            if (this.justify.classList.contains('e-active')) {
                this.justify.classList.remove('e-active');
            }
        }
        else if (this.paragraphFormat.textAlignment === 'Justify') {
            if (this.leftAlign.classList.contains('e-active')) {
                this.leftAlign.classList.remove('e-active');
            }
            if (this.rightAlign.classList.contains('e-active')) {
                this.rightAlign.classList.remove('e-active');
            }
            if (this.centerAlign.classList.contains('e-active')) {
                this.centerAlign.classList.remove('e-active');
            }
            if (!this.justify.classList.contains('e-active')) {
                this.justify.classList.add('e-active');
            }
        }
        if (this.paragraphFormat.lineSpacing === 1) {
            this.singleLineSpacing.classList.add('e-active');
            this.onePointFiveLineSpacing.classList.remove('e-active');
            this.doubleLineSpacing.classList.remove('e-active');
        }
        else if (this.paragraphFormat.lineSpacing === 1.5) {
            this.singleLineSpacing.classList.remove('e-active');
            this.onePointFiveLineSpacing.classList.add('e-active');
            this.doubleLineSpacing.classList.remove('e-active');
        }
        else if (this.paragraphFormat.lineSpacing === 2) {
            this.singleLineSpacing.classList.remove('e-active');
            this.onePointFiveLineSpacing.classList.remove('e-active');
            this.doubleLineSpacing.classList.add('e-active');
        }
        else {
            this.singleLineSpacing.classList.remove('e-active');
            this.onePointFiveLineSpacing.classList.remove('e-active');
            this.doubleLineSpacing.classList.remove('e-active');
        }
    };
    StyleDialog.prototype.enableOrDisableOkButton = function () {
        if (!isNullOrUndefined(this.okButton)) {
            this.okButton.disabled = (this.styleNameElement.value === '');
        }
    };
    StyleDialog.prototype.getTypeValue = function () {
        if (this.styleType.value === this.localObj.getConstant('Linked Style') || this.styleType.value === this.localObj.getConstant('Paragraph')) {
            return 'Paragraph';
        }
        else {
            return 'Character';
        }
    };
    StyleDialog.prototype.updateStyleNames = function (type, name) {
        var styles = this.owner.owner.viewer.styles.getStyleNames(type);
        this.styleParagraph.dataSource = styles;
        this.styleParagraph.index = null;
        if (name) {
            this.styleBasedOn.dataSource = styles.filter(function (e) { return e !== name; });
            this.styleBasedOn.index = null;
            var style = this.getStyle(name);
            if (style.basedOn instanceof String || isNullOrUndefined(style.basedOn)) {
                this.styleBasedOn.enabled = false;
            }
            else {
                /*tslint:disable-next-line:max-line-length */
                this.styleBasedOn.index = styles.indexOf(style.basedOn.name) > -1 ? styles.indexOf(style.basedOn.name) : 0;
            }
            if (style.type === 'Paragraph') {
                if (!isNullOrUndefined(style.link)) {
                    this.styleType.index = 2;
                }
                else {
                    this.styleType.index = 0;
                }
            }
            else {
                this.styleType.index = 1;
            }
            if (!isNullOrUndefined(style.next)) {
                var nxtName = style.next.name;
                var index = 0;
                if (styles.indexOf(nxtName) > -1) {
                    index = styles.indexOf(nxtName);
                }
                this.styleParagraph.index = index;
                this.isUserNextParaUpdated = (nxtName === name) ? false : true;
            }
        }
        else {
            this.styleBasedOn.dataSource = styles;
            this.styleBasedOn.index = null;
            var basedOnIndex = 0;
            if (this.owner.owner.selectionModule) {
                var styleName = void 0;
                if (type === 'Character') {
                    styleName = this.owner.owner.selection.characterFormat.styleName;
                }
                else {
                    styleName = this.owner.owner.selection.paragraphFormat.styleName;
                }
                basedOnIndex = styles.indexOf(styleName);
            }
            this.styleBasedOn.index = basedOnIndex;
            this.styleParagraph.index = 0;
        }
        if (this.isEdit) {
            this.styleType.enabled = false;
        }
        else {
            this.styleType.enabled = true;
        }
        this.styleBasedOn.dataBind();
        this.styleParagraph.dataBind();
    };
    StyleDialog.prototype.getStyle = function (styleName) {
        /* tslint:disable-next-line:max-line-length */
        if (isNullOrUndefined(this.owner.owner.viewer.styles.findByName(styleName))) {
            /* tslint:disable-next-line:max-line-length */
            this.owner.owner.editor.createStyle(this.owner.owner.viewer.preDefinedStyles.get(styleName));
        }
        return this.owner.owner.viewer.styles.findByName(styleName);
    };
    /**
     * @private
     */
    StyleDialog.prototype.destroy = function () {
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (var n = 0; n < this.target.childNodes.length; n++) {
                this.target.removeChild(this.target.childNodes[n]);
                n--;
            }
            this.target = undefined;
        }
        if (this.fontColor) {
            this.fontColor.destroy();
            this.fontColor = undefined;
        }
        if (this.fontSize) {
            this.fontSize.destroy();
            this.fontSize = undefined;
        }
        if (this.fontFamily) {
            this.fontFamily.destroy();
            this.fontFamily = undefined;
        }
        if (this.styleType) {
            this.styleType.destroy();
            this.styleType = undefined;
        }
        if (this.styleBasedOn) {
            this.styleBasedOn.destroy();
            this.styleBasedOn = undefined;
        }
        if (this.styleParagraph) {
            this.styleParagraph.destroy();
            this.styleParagraph = undefined;
        }
        if (this.onlyThisDocument) {
            this.onlyThisDocument.destroy();
        }
        this.onlyThisDocument = undefined;
        if (this.template) {
            this.template.destroy();
            this.template = undefined;
        }
        if (this.style) {
            this.style = undefined;
        }
        if (this.abstractList) {
            this.abstractList = undefined;
        }
        if (this.numberingBulletDialog) {
            this.numberingBulletDialog.destroy();
            this.numberingBulletDialog = undefined;
        }
        if (this.styleDropdwn) {
            this.styleDropdwn.destroy();
            this.styleDropdwn = undefined;
        }
    };
    return StyleDialog;
}());

/**
 * The Bullets and Numbering dialog is used to apply list format for a paragraph style.
 */
/* tslint:disable:no-any */
var BulletsAndNumberingDialog = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function BulletsAndNumberingDialog(layoutViewer) {
        var _this = this;
        this.isBullet = false;
        /**
         * @private
         */
        this.numberListClick = function (args) {
            _this.isBullet = false;
            _this.setActiveElement(args);
            if (args.currentTarget.classList.contains('e-de-list-numbered-none')) {
                _this.numberFormat = undefined;
                _this.listLevelPattern = undefined;
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-number-dot')) {
                _this.numberFormat = '%1.';
                _this.listLevelPattern = 'Arabic';
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-number-brace')) {
                _this.numberFormat = '%1)';
                _this.listLevelPattern = 'Arabic';
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-up-roman')) {
                _this.numberFormat = '%1.';
                _this.listLevelPattern = 'UpRoman';
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-up-letter')) {
                _this.numberFormat = '%1.';
                _this.listLevelPattern = 'UpLetter';
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-low-letter-brace')) {
                _this.numberFormat = '%1)';
                _this.listLevelPattern = 'LowLetter';
            }
            else if (args.currentTarget.classList.contains('e-de-numbered-low-letter-dot')) {
                _this.numberFormat = '%1.';
                _this.listLevelPattern = 'LowLetter';
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-low-roman')) {
                _this.numberFormat = '%1.';
                _this.listLevelPattern = 'LowRoman';
            }
        };
        /**
         * @private
         */
        this.bulletListClick = function (args) {
            _this.isBullet = true;
            _this.setActiveElement(args);
            if (args.currentTarget.classList.contains('e-bullet-none')) {
                _this.symbol = undefined;
                _this.fontFamily = undefined;
            }
            else if (args.currentTarget.classList.contains('e-bullet-dot')) {
                _this.symbol = '\uf0b7';
                _this.fontFamily = 'Symbol';
            }
            else if (args.currentTarget.classList.contains('e-bullet-circle')) {
                _this.symbol = '\uf06f' + '\u0020';
                _this.fontFamily = 'Symbol';
            }
            else if (args.currentTarget.classList.contains('e-bullet-square')) {
                _this.symbol = '\uf0a7';
                _this.fontFamily = 'Wingdings';
            }
            else if (args.currentTarget.classList.contains('e-bullet-flower')) {
                _this.symbol = '\uf076';
                _this.fontFamily = 'Wingdings';
            }
            else if (args.currentTarget.classList.contains('e-bullet-arrow')) {
                _this.symbol = '\uf0d8';
                _this.fontFamily = 'Wingdings';
            }
            else if (args.currentTarget.classList.contains('e-bullet-tick')) {
                _this.symbol = '\uf0fc';
                _this.fontFamily = 'Wingdings';
            }
        };
        /**
         * @private
         */
        this.loadNumberingBulletDialog = function () {
            //Load 
            _this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.closeNumberingBulletDialog = function () {
            _this.unWireEventsAndBindings();
            _this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.onCancelButtonClick = function () {
            _this.isBullet = false;
            _this.listLevelPattern = undefined;
            _this.numberFormat = undefined;
            _this.symbol = undefined;
            _this.fontFamily = undefined;
            _this.owner.dialog.hide();
            _this.unWireEventsAndBindings();
        };
        /**
         * @private
         */
        this.onOkButtonClick = function () {
            if (_this.owner.owner.viewer.lists.length > 0) {
                _this.listFormat.list.listId = _this.owner.owner.viewer.lists[_this.owner.owner.viewer.lists.length - 1].listId + 1;
                _this.listFormat.listId = _this.listFormat.list.listId;
            }
            else {
                _this.listFormat.list.listId = 0;
                _this.listFormat.listId = 0;
            }
            if (_this.owner.owner.viewer.abstractLists.length > 0) {
                /*tslint:disable-next-line:max-line-length */
                _this.abstractList.abstractListId = _this.owner.owner.viewer.abstractLists[_this.owner.owner.viewer.abstractLists.length - 1].abstractListId + 1;
            }
            else {
                _this.abstractList.abstractListId = 0;
            }
            _this.listFormat.list.abstractListId = _this.abstractList.abstractListId;
            var listLevel = new WListLevel(_this.abstractList);
            listLevel.listLevelPattern = !isNullOrUndefined(_this.listLevelPattern) ? _this.listLevelPattern : 'Bullet';
            listLevel.numberFormat = _this.isBullet ? _this.symbol : _this.numberFormat;
            if (listLevel.listLevelPattern !== 'Bullet') {
                listLevel.startAt = 1;
            }
            listLevel.characterFormat.fontFamily = !isNullOrUndefined(_this.fontFamily) ? _this.fontFamily : 'Verdana';
            listLevel.paragraphFormat.leftIndent = 36;
            listLevel.paragraphFormat.firstLineIndent = -18;
            _this.abstractList.levels.push(listLevel);
            _this.listFormat.listLevelNumber = 0;
            _this.listFormat.list.abstractList = _this.abstractList;
            _this.owner.dialog.hide();
        };
        this.owner = layoutViewer;
    }
    /**
     * @private
     */
    BulletsAndNumberingDialog.prototype.getModuleName = function () {
        return 'BulletsAndNumberingDialog';
    };
    /**
     * @private
     */
    BulletsAndNumberingDialog.prototype.initNumberingBulletDialog = function (locale) {
        var id = this.owner.owner.containerId;
        this.target = createElement('div', { id: id + '_insertNumberBulletDialog', className: 'e-de-number-bullet-dlg' });
        var tabTarget = createElement('div', { id: id + '_tabNumberBulletDialog', className: 'e-de-tab-number-bullet-dlg' });
        this.target.appendChild(tabTarget);
        this.createNumberList(id);
        this.createBulletList(id);
        //Initialize Tab component
        this.tabObj = new Tab({
            items: [
                {
                    header: { 'text': createElement('div', { innerHTML: locale.getConstant('Numbering') }) },
                    content: this.numberListDiv,
                },
                {
                    header: { 'text': createElement('div', { innerHTML: locale.getConstant('Bullets') }) },
                    content: this.bulletListDiv,
                }
            ],
            heightAdjustMode: 'None',
            width: 272,
            selecting: this.onTabSelect.bind(this)
        });
        //Render initialized Tab component
        this.tabObj.appendTo(tabTarget);
    };
    BulletsAndNumberingDialog.prototype.onTabSelect = function (args) {
        if (args.selectingIndex === 1) {
            this.bulletListDiv.style.display = 'block';
        }
    };
    BulletsAndNumberingDialog.prototype.createNumberList = function (id) {
        this.numberListDiv = createElement('div', { className: 'e-de-style-numbered-list', id: id + '_Number' });
        var numberListDiv = this.numberListDiv;
        numberListDiv.style.height = '270px';
        var ulTag = createElement('ul', {
            styles: 'display: block; outline: 0px;',
            id: 'listMenu',
            className: 'e-de-ui-wfloating-menu e-de-ui-bullets-menu e-de-list-container e-de-list-thumbnail'
        });
        numberListDiv.appendChild(ulTag);
        var numberedNone = this.createNumberNoneListTag(ulTag);
        var numberedNumberDot = this.createNumberListTag(ulTag, '1.', '2.', '3.', 'e-de-list-numbered-number-dot');
        var numberedNumberBrace = this.createNumberListTag(ulTag, '1)', '2)', '3)', 'e-de-list-numbered-number-brace');
        var numberedUpRoman = this.createNumberListTag(ulTag, 'I.', 'II.', 'III.', 'e-de-list-numbered-up-roman');
        var numberedUpLettter = this.createNumberListTag(ulTag, 'A.', 'B.', 'C.', 'e-de-list-numbered-up-letter');
        var numberedLowLetterDot = this.createNumberListTag(ulTag, 'a.', 'b.', 'c.', 'e-de-numbered-low-letter-dot');
        var numberedLowLetterBrace = this.createNumberListTag(ulTag, 'a)', 'b)', 'c)', 'e-de-list-numbered-low-letter-brace');
        var numberedLowRoman = this.createNumberListTag(ulTag, 'i.', 'ii.', 'iii.', 'e-de-list-numbered-low-roman');
        numberedNone.addEventListener('click', this.numberListClick);
        numberedNumberDot.addEventListener('click', this.numberListClick);
        numberedNumberBrace.addEventListener('click', this.numberListClick);
        numberedUpRoman.addEventListener('click', this.numberListClick);
        numberedUpLettter.addEventListener('click', this.numberListClick);
        numberedLowLetterBrace.addEventListener('click', this.numberListClick);
        numberedLowLetterDot.addEventListener('click', this.numberListClick);
        numberedLowRoman.addEventListener('click', this.numberListClick);
        this.target.appendChild(numberListDiv);
    };
    BulletsAndNumberingDialog.prototype.createNumberListTag = function (ulTag, text1, text2, text3, className) {
        var liTag = createElement('li', {
            styles: 'display:block',
            className: 'e-de-ui-wfloating-menuitem e-de-ui-wfloating-menuitem-md e-de-list-items  e-de-list-item-size ' + className
        });
        ulTag.appendChild(liTag);
        /*tslint:disable-next-line:max-line-length */
        var innerHTML = '<div>' + text1 + '<span class="e-de-ui-list-line"></span></div><div>' + text2 + '<span class="e-de-ui-list-line">';
        innerHTML += '</span></div><div>' + text3 + '<span class="e-de-ui-list-line"> </span></div >';
        var liInnerDiv = createElement('div', {
            className: 'e-de-ui-list-header-presetmenu',
            id: 'e-de-ui-zlist0', innerHTML: innerHTML
        });
        liTag.style.cssFloat = 'left';
        liTag.appendChild(liInnerDiv);
        return liTag;
    };
    BulletsAndNumberingDialog.prototype.createNumberNoneListTag = function (ulTag) {
        var liTag = createElement('li', {
            styles: 'display:block',
            /*tslint:disable-next-line:max-line-length */
            className: 'e-de-ui-wfloating-menuitem e-de-ui-wfloating-menuitem-md e-de-list-items  e-de-list-item-size e-de-list-numbered-none'
        });
        ulTag.appendChild(liTag);
        var innerHTML = '<div class="e-de-ui-bullets e-de-bullet-icons">None</div>';
        var liInnerDiv = createElement('div', {
            className: 'e-de-ui-list-header-presetmenu',
            id: 'e-de-ui-zlist0', innerHTML: innerHTML
        });
        liTag.style.cssFloat = 'left';
        liTag.appendChild(liInnerDiv);
        return liTag;
    };
    BulletsAndNumberingDialog.prototype.createBulletListTag = function (ulTag, iconCss, className) {
        var liTag = createElement('li', {
            styles: 'display:block;',
            className: 'e-de-ui-wfloating-menuitem e-de-ui-wfloating-bullet-menuitem-md e-de-list-items  e-de-list-item-size ' + className
        });
        ulTag.appendChild(liTag);
        /*tslint:disable-next-line:max-line-length */
        var liInnerDiv = createElement('div', { className: 'e-de-ui-bullet-list-header-presetmenu e-de-bullet-icon-size', id: 'e-de-ui-zlist0' });
        var liNextDiv = createElement('div', { className: iconCss });
        liInnerDiv.appendChild(liNextDiv);
        liTag.appendChild(liInnerDiv);
        return liTag;
    };
    BulletsAndNumberingDialog.prototype.createBulletList = function (id) {
        this.bulletListDiv = createElement('div', { className: 'e-de-ui-bullet-list-header-presetmenu', id: id + '_Bullet' });
        var bulletListDiv = this.bulletListDiv;
        bulletListDiv.style.height = '270px';
        bulletListDiv.style.display = 'none';
        var ulTag = createElement('ul', {
            styles: 'display: block; outline: 0px;', id: 'listMenu',
            className: 'e-de-ui-wfloating-menu e-de-ui-bullets-menu e-de-list-container e-de-list-thumbnail'
        });
        bulletListDiv.appendChild(ulTag);
        var bulletNone = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-none e-de-bullet-icons', 'e-bullet-none');
        var bulletDot = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-dot e-de-bullet-icons', 'e-bullet-dot');
        /*tslint:disable-next-line:max-line-length */
        var bulletCircle = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-circle e-de-bullet-icons', 'e-bullet-circle');
        var bulletSquare = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-square e-de-bullet-icons', 'e-bullet-square');
        /*tslint:disable-next-line:max-line-length */
        var bulletFlower = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-flower e-de-bullet-icons', 'e-bullet-flower');
        var bulletArrow = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-arrow e-de-bullet-icons', 'e-bullet-arrow');
        var bulletTick = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-tick e-de-bullet-icons', 'e-bullet-tick');
        bulletNone.addEventListener('click', this.bulletListClick);
        bulletDot.addEventListener('click', this.bulletListClick);
        bulletCircle.addEventListener('click', this.bulletListClick);
        bulletSquare.addEventListener('click', this.bulletListClick);
        bulletFlower.addEventListener('click', this.bulletListClick);
        bulletArrow.addEventListener('click', this.bulletListClick);
        bulletTick.addEventListener('click', this.bulletListClick);
        this.target.appendChild(bulletListDiv);
    };
    /**
     * @private
     */
    BulletsAndNumberingDialog.prototype.showNumberBulletDialog = function (listFormat, abstractList) {
        if (!isNullOrUndefined(listFormat)) {
            this.listFormat = listFormat;
        }
        else {
            this.listFormat = new WListFormat();
        }
        if (isNullOrUndefined(this.listFormat.list)) {
            this.listFormat.list = new WList();
        }
        if (!isNullOrUndefined(abstractList)) {
            this.abstractList = abstractList;
        }
        else {
            this.abstractList = new WAbstractList();
        }
        var locale = new L10n('documenteditor', this.owner.owner.defaultLocale);
        locale.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initNumberingBulletDialog(locale);
        }
        this.owner.dialog.header = locale.getConstant('Numbering and Bullets');
        this.owner.dialog.width = 'auto';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.loadNumberingBulletDialog;
        this.owner.dialog.close = this.closeNumberingBulletDialog;
        this.owner.dialog.position = { X: 'center', Y: 'center' };
        this.owner.dialog.buttons = [{
                click: this.onOkButtonClick,
                buttonModel: { content: locale.getConstant('Ok'), cssClass: 'e-flat e-numbering-bullet-okay', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: locale.getConstant('Cancel'), cssClass: 'e-flat e-numbering-bullet-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
        this.tabObj.refresh();
    };
    BulletsAndNumberingDialog.prototype.setActiveElement = function (args) {
        var html = args.currentTarget.parentElement;
        for (var i = 0; i < html.childElementCount; i++) {
            if (html.childNodes[i].classList.contains('e-de-list-active')) {
                html.childNodes[i].classList.remove('e-de-list-active');
            }
        }
        args.currentTarget.classList.add('e-de-list-active');
    };
    /**
     * @private
     */
    BulletsAndNumberingDialog.prototype.unWireEventsAndBindings = function () {
        //Unwire events
    };
    /**
     * @private
     */
    BulletsAndNumberingDialog.prototype.destroy = function () {
        this.owner = undefined;
        if (this.listFormat) {
            this.listFormat.destroy();
            this.listFormat = undefined;
        }
        if (this.tabObj) {
            this.tabObj.destroy();
            this.tabObj = undefined;
        }
        if (this.abstractList) {
            this.abstractList.destroy();
            this.abstractList = undefined;
        }
        if (this.target && this.target.parentElement) {
            this.target.parentElement.removeChild(this.target);
            for (var m = 0; m < this.target.childNodes.length; m++) {
                this.target.removeChild(this.target.childNodes[m]);
                m--;
            }
            this.target = undefined;
        }
        this.bulletListDiv = undefined;
        this.numberListDiv = undefined;
    };
    return BulletsAndNumberingDialog;
}());

/* tslint:enable:no-any */

/**
 * The Font dialog is used to modify formatting of selected text.
 */
/* tslint:disable:no-any */
var FontDialog = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function FontDialog(layoutViewer) {
        var _this = this;
        this.fontStyleInternal = undefined;
        this.fontNameList = undefined;
        this.fontStyleText = undefined;
        this.fontSizeText = undefined;
        this.colorPicker = undefined;
        this.underlineDrop = undefined;
        this.strikethroughBox = undefined;
        this.doublestrikethrough = undefined;
        this.superscript = undefined;
        this.subscript = undefined;
        //Character Format Property
        this.bold = undefined;
        this.italic = undefined;
        this.underline = undefined;
        this.strikethrough = undefined;
        this.baselineAlignment = undefined;
        this.fontSize = undefined;
        this.fontFamily = undefined;
        this.fontColor = undefined;
        /**
         * @private
         */
        this.characterFormat = undefined;
        /**
         * @private
         */
        this.loadFontDialog = function () {
            _this.owner.updateFocus();
            var characterFormat;
            if (_this.characterFormat) {
                characterFormat = _this.characterFormat;
            }
            else {
                characterFormat = _this.owner.owner.selection.characterFormat;
            }
            _this.fontNameList.value = characterFormat.fontFamily;
            _this.fontNameList.dataBind();
            if (!characterFormat.bold && !characterFormat.italic) {
                _this.fontStyleText.value = _this.fontSizeText.value;
                _this.fontStyleText.index = 0;
            }
            else if (characterFormat.bold && !characterFormat.italic) {
                _this.fontStyleText.value = _this.fontSizeText.value;
                _this.fontStyleText.index = 1;
            }
            else if (!characterFormat.bold && characterFormat.italic) {
                _this.fontStyleText.value = _this.fontSizeText.value;
                _this.fontStyleText.index = 2;
            }
            else if (characterFormat.bold && characterFormat.italic) {
                _this.fontStyleText.value = _this.fontSizeText.value;
                _this.fontStyleText.index = 3;
            }
            if (!isNullOrUndefined(characterFormat.fontSize)) {
                for (var i = 0; i <= 15; i++) {
                    var items = _this.fontSizeText.getItems();
                    if (characterFormat.fontSize.toString() === items[i].innerHTML) {
                        _this.fontSizeText.value = characterFormat.fontSize;
                        _this.fontSizeText.index = i;
                        break;
                    }
                }
            }
            if (!isNullOrUndefined(characterFormat.fontColor)) {
                _this.colorPicker.value = characterFormat.fontColor;
            }
            else {
                _this.colorPicker.value = '#000000';
            }
            if (characterFormat.underline === 'None') {
                _this.underlineDrop.index = 0;
            }
            else if (characterFormat.underline === 'Single') {
                _this.underlineDrop.index = 1;
            }
            if (characterFormat.strikethrough === 'SingleStrike') {
                _this.strikethroughBox.checked = true;
            }
            else if (characterFormat.strikethrough === 'DoubleStrike') {
                _this.doublestrikethrough.checked = true;
            }
            else {
                _this.strikethroughBox.checked = false;
                _this.doublestrikethrough.checked = false;
            }
            if (characterFormat.baselineAlignment === 'Superscript') {
                _this.superscript.checked = true;
            }
            else if (characterFormat.baselineAlignment === 'Subscript') {
                _this.subscript.checked = true;
            }
            else {
                _this.superscript.checked = false;
                _this.subscript.checked = false;
            }
            if (_this.owner.selection.caret.style.display !== 'none') {
                _this.owner.selection.caret.style.display = 'none';
            }
        };
        /**
         * @private
         */
        this.closeFontDialog = function () {
            _this.unWireEventsAndBindings();
            _this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.onCancelButtonClick = function () {
            _this.owner.dialog.hide();
            _this.unWireEventsAndBindings();
        };
        /**
         * @private
         */
        this.onInsertFontFormat = function () {
            var format;
            if (_this.characterFormat) {
                format = _this.characterFormat;
            }
            else {
                format = new WCharacterFormat(undefined);
            }
            if (!isNullOrUndefined(_this.bold)) {
                format.bold = _this.bold;
            }
            if (!isNullOrUndefined(_this.italic)) {
                format.italic = _this.italic;
            }
            if (!isNullOrUndefined(_this.fontSize) && _this.fontSize > 0) {
                format.fontSize = _this.fontSize;
            }
            if (!isNullOrUndefined(_this.fontColor)) {
                format.fontColor = _this.fontColor;
            }
            if (!isNullOrUndefined(_this.baselineAlignment)) {
                format.baselineAlignment = _this.baselineAlignment;
            }
            if (!isNullOrUndefined(_this.strikethrough)) {
                format.strikethrough = _this.strikethrough;
            }
            if (!isNullOrUndefined(_this.underline)) {
                format.underline = _this.underline;
            }
            if (!isNullOrUndefined(_this.fontFamily)) {
                format.fontFamily = _this.fontFamily;
            }
            if (!_this.characterFormat) {
                _this.onCharacterFormat(_this.owner.selection, format);
            }
            else {
                _this.owner.owner.styleDialogModule.updateCharacterFormat();
            }
            _this.owner.dialog.hide();
        };
        this.fontSizeUpdate = function (args) {
            _this.fontSize = args.value;
        };
        this.fontStyleUpdate = function (args) {
            _this.fontStyle = args.value;
        };
        this.fontFamilyUpdate = function (args) {
            _this.fontFamily = args.value;
        };
        this.underlineUpdate = function (args) {
            _this.underline = args.value;
        };
        this.fontColorUpdate = function (args) {
            if (!isNullOrUndefined(args.currentValue)) {
                _this.fontColor = args.currentValue.hex;
            }
        };
        this.singleStrikeUpdate = function (args) {
            _this.enableCheckBoxProperty(args);
            if (args.checked) {
                _this.strikethrough = 'SingleStrike';
            }
            else {
                _this.strikethrough = 'None';
            }
        };
        this.doubleStrikeUpdate = function (args) {
            _this.enableCheckBoxProperty(args);
            if (args.checked) {
                _this.strikethrough = 'DoubleStrike';
            }
            else {
                _this.strikethrough = 'None';
            }
        };
        this.superscriptUpdate = function (args) {
            _this.enableCheckBoxProperty(args);
            if (args.checked) {
                _this.baselineAlignment = 'Superscript';
            }
            else {
                _this.baselineAlignment = 'Normal';
            }
        };
        this.subscriptUpdate = function (args) {
            _this.enableCheckBoxProperty(args);
            if (args.checked) {
                _this.baselineAlignment = 'Subscript';
            }
            else {
                _this.baselineAlignment = 'Normal';
            }
        };
        this.owner = layoutViewer;
    }
    Object.defineProperty(FontDialog.prototype, "fontStyle", {
        /**
         * @private
         */
        get: function () {
            return this.fontStyleInternal;
        },
        /**
         * @private
         */
        set: function (value) {
            this.fontStyleInternal = value;
            switch (this.fontStyle) {
                case 'Bold':
                    this.bold = true;
                    this.italic = false;
                    break;
                case 'Italic':
                    this.bold = false;
                    this.italic = true;
                    break;
                case 'BoldItalic':
                    this.bold = true;
                    this.italic = true;
                    break;
                case 'Regular':
                    this.bold = false;
                    this.italic = false;
                    break;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    FontDialog.prototype.getModuleName = function () {
        return 'FontDialog';
    };
    FontDialog.prototype.createInputElement = function (type, id, className) {
        var element = createElement('input', {
            attrs: { type: type },
            id: id,
            className: className
        });
        return element;
    };
    /**
     * @private
     */
    FontDialog.prototype.initFontDialog = function (locale, isRtl) {
        var effectLabel;
        var strikeThroughElement;
        var superScriptElement;
        var subScriptElement;
        var doubleStrikeThroughElement;
        var id = this.owner.owner.containerId;
        this.target = createElement('div', { id: id + '_insertFontDialog', className: 'e-de-font-dlg' });
        var fontDiv = this.getFontDiv(locale, isRtl);
        this.target.appendChild(fontDiv);
        var sizeDiv = this.getFontSizeDiv(locale, isRtl);
        this.target.appendChild(sizeDiv);
        var colorDiv = createElement('div', { id: id + '_fontColor', styles: 'margin-top:14px;' });
        this.fontColorDiv = createElement('div', { id: id + '_fontColorDiv', className: 'e-de-font-dlg-display' });
        var fontColorLabel = createElement('label', {
            className: 'e-de-font-dlg-header-font-color e-de-font-color-margin',
            innerHTML: locale.getConstant('Font color'), styles: 'width:63px'
        });
        if (isRtl) {
            fontColorLabel.classList.add('e-de-rtl');
        }
        this.fontColorDiv.appendChild(fontColorLabel);
        var fontColorElement = this.createInputElement('color', this.target.id + '_ColorDiv', 'e-de-font-dlg-color');
        this.fontColorDiv.appendChild(fontColorElement);
        colorDiv.appendChild(this.fontColorDiv);
        this.target.appendChild(colorDiv);
        var fontEffectsDiv = createElement('div', { id: id + '_fontEffectsDiv' });
        var fontEffectSubDiv1 = createElement('div', {
            className: 'e-de-font-color-label e-de-font-dlg-display',
            id: this.target.id + '_fontEffectsSubDiv1'
        });
        effectLabel = createElement('label', {
            className: 'e-de-font-dlg-header-effects',
            innerHTML: locale.getConstant('Effects'), styles: 'width:58px'
        });
        fontEffectSubDiv1.appendChild(effectLabel);
        strikeThroughElement = this.createInputElement('checkbox', this.target.id + '_strikeThrough', '');
        fontEffectSubDiv1.appendChild(strikeThroughElement);
        superScriptElement = this.createInputElement('checkbox', this.target.id + '_superScript', '');
        fontEffectSubDiv1.appendChild(superScriptElement);
        fontEffectsDiv.appendChild(fontEffectSubDiv1);
        var fontEffectSubDiv2 = createElement('div', { className: 'e-de-font-checkbox', id: id + '_fontEffectsSubDiv2' });
        subScriptElement = this.createInputElement('checkbox', this.target.id + '_subScript', '');
        fontEffectSubDiv2.appendChild(subScriptElement);
        doubleStrikeThroughElement = this.createInputElement('checkbox', this.target.id + '_doubleStrikeThrough', '');
        fontEffectSubDiv2.appendChild(doubleStrikeThroughElement);
        fontEffectsDiv.appendChild(fontEffectSubDiv2);
        this.target.appendChild(fontEffectsDiv);
        this.colorPicker = new ColorPicker({
            change: this.fontColorUpdate, value: '#000000', enableRtl: isRtl, locale: this.owner.owner.locale
        });
        this.colorPicker.appendTo(fontColorElement);
        this.strikethroughBox = new CheckBox({
            change: this.singleStrikeUpdate,
            cssClass: 'e-de-font-content-label',
            label: locale.getConstant('Strikethrough'),
            enableRtl: isRtl
        });
        this.strikethroughBox.appendTo(strikeThroughElement);
        this.doublestrikethrough = new CheckBox({
            change: this.doubleStrikeUpdate,
            cssClass: 'e-de-font-content-checkbox-label',
            label: locale.getConstant('Double strikethrough'),
            enableRtl: isRtl
        });
        this.doublestrikethrough.appendTo(doubleStrikeThroughElement);
        this.subscript = new CheckBox({
            label: locale.getConstant('Subscript'),
            cssClass: 'e-de-font-content-label-width',
            change: this.subscriptUpdate,
            enableRtl: isRtl
        });
        this.subscript.appendTo(subScriptElement);
        this.superscript = new CheckBox({
            label: locale.getConstant('Superscript'),
            cssClass: 'e-de-font-content-label', change: this.superscriptUpdate,
            enableRtl: isRtl
        });
        this.superscript.appendTo(superScriptElement);
        if (isRtl) {
            fontEffectSubDiv2.classList.add('e-de-rtl');
            this.doublestrikethrough.cssClass = 'e-de-font-content-checkbox-label-rtl';
        }
    };
    FontDialog.prototype.getFontSizeDiv = function (locale, isRtl) {
        var fontSize;
        var sizeDiv;
        var id = this.owner.owner.containerId;
        sizeDiv = createElement('div', { id: id + '_fontSizeAndUnderlineDiv', className: 'e-de-font-dlg-padding e-de-font-dlg-display' });
        var sizeSubDiv1 = createElement('div', { id: id + '_fontSizeAndUnderlineSubDiv1' });
        var sizeLabel = createElement('label', { className: 'e-de-font-dlg-header', innerHTML: locale.getConstant('Size') });
        var styles = 'font-family:Roboto;font-size:14px;opacity:0.8;';
        fontSize = createElement('select', { id: this.target.id + '_fontSize', styles: styles });
        fontSize.innerHTML = '<option>8</option><option>9</option><option>10</option><option>11</option><option>12</option>' +
            '<option>14</option><option>16</option><option>18</option><option>20</option><option>24</option><option>26</option>' +
            '<option>28</option><option>36</option><option>48</option><option>72</option><option>96</option>';
        sizeSubDiv1.appendChild(sizeLabel);
        sizeSubDiv1.appendChild(fontSize);
        sizeDiv.appendChild(sizeSubDiv1);
        var sizeSubDiv2 = createElement('div', {
            className: 'e-de-font-dlg-cb-right',
            id: id + '_fontSizeAndUnderlineSubDiv2'
        });
        if (isRtl) {
            sizeSubDiv2.classList.add('e-de-rtl');
        }
        var html = locale.getConstant('Underline style');
        var underlineLabel = createElement('label', { className: 'e-de-font-dlg-header', innerHTML: html });
        var underlineElement;
        underlineElement = createElement('select', { id: this.target.id + '_underLine', styles: styles });
        underlineElement.innerHTML = '<option>' + locale.getConstant('None') + '</option><option>________</option>';
        sizeSubDiv2.appendChild(underlineLabel);
        sizeSubDiv2.appendChild(underlineElement);
        sizeDiv.appendChild(sizeSubDiv2);
        this.fontSizeText = new ComboBox({ change: this.fontSizeUpdate, popupHeight: '170px', width: '170px', enableRtl: isRtl });
        this.fontSizeText.showClearButton = false;
        this.fontSizeText.appendTo(fontSize);
        this.underlineDrop = new DropDownList({ change: this.underlineUpdate, popupHeight: '100px', width: '170px', enableRtl: isRtl });
        this.underlineDrop.appendTo(underlineElement);
        return sizeDiv;
    };
    FontDialog.prototype.getFontDiv = function (locale, isRtl) {
        var id = this.owner.owner.containerId;
        var fontDiv = createElement('div', { id: id + '_fontDiv', className: 'e-de-font-dlg-display' });
        var fontSubDiv1 = createElement('div', { id: id + '_fontSubDiv1' });
        var fontNameLabel = createElement('label', {
            className: 'e-de-font-dlg-header',
            innerHTML: locale.getConstant('Font')
        });
        var fontNameValues = createElement('select', { id: this.target.id + '_fontName' });
        fontNameValues.innerHTML = '<option>Arial</option><option>Calibri</option><option>Candara</option><option>Comic Sans MS</option>' +
            '<option>Consolas</option><option>Constantia</option><option>Corbel</option>' +
            '<option>Courier New</option><option>Ebrima</option><option>Franklin Gothic</option>' +
            '<option>Gabriola</option><option>Gadugi</option><option>Georgia</option><option>Impact</option>' +
            '<option>Javanese Text</option><option>Microsoft Sans Serif</option><option>MS Gothic</option><option>MS UI Gothic</option>' +
            '<option>Segoe Print</option><option>Times New Roman</option><option>Verdana</option><option>Segoe UI</option>' +
            '<option>Algerian</option><option>Cambria</option><option>Georgia</option><option>Consolas</option>';
        fontSubDiv1.appendChild(fontNameLabel);
        fontSubDiv1.appendChild(fontNameValues);
        fontDiv.appendChild(fontSubDiv1);
        var fontSubDiv2;
        var fontStyleLabel;
        var fontStyleValues;
        fontSubDiv2 = createElement('div', { className: 'e-de-font-dlg-cb-right', id: id + '_fontSubDiv2', styles: 'float:right;' });
        if (isRtl) {
            fontSubDiv2.classList.add('e-de-rtl');
        }
        fontStyleLabel = createElement('label', { className: 'e-de-font-dlg-header', innerHTML: locale.getConstant('Font style') });
        var fontStyle = 'font-family:Roboto;font-size:14px;opacity:0.8;';
        fontStyleValues = createElement('select', { id: this.target.id + '_fontStyle', styles: fontStyle });
        fontStyleValues.innerHTML = '<option>' +
            locale.getConstant('Regular') + '</option><option>' + locale.getConstant('Bold') + '</option><option>' +
            locale.getConstant('Italic') + '</option><option>' + locale.getConstant('Bold') + locale.getConstant('Italic') + '</option>';
        fontSubDiv2.appendChild(fontStyleLabel);
        fontSubDiv2.appendChild(fontStyleValues);
        fontDiv.appendChild(fontSubDiv2);
        this.fontNameList = new ComboBox({ change: this.fontFamilyUpdate, popupHeight: '200px', width: '170px', enableRtl: isRtl });
        this.fontNameList.showClearButton = false;
        this.fontNameList.appendTo(fontNameValues);
        this.fontStyleText = new DropDownList({ change: this.fontStyleUpdate, popupHeight: '170px', width: '170px', enableRtl: isRtl });
        this.fontStyleText.appendTo(fontStyleValues);
        return fontDiv;
    };
    /**
     * @private
     */
    FontDialog.prototype.showFontDialog = function (characterFormat) {
        if (characterFormat) {
            this.characterFormat = characterFormat;
        }
        var locale = new L10n('documenteditor', this.owner.owner.defaultLocale);
        locale.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initFontDialog(locale, this.owner.owner.enableRtl);
        }
        this.owner.dialog.header = locale.getConstant('Font');
        this.owner.dialog.width = 'auto';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.loadFontDialog;
        this.owner.dialog.close = this.closeFontDialog;
        this.owner.dialog.buttons = [{
                click: this.onInsertFontFormat,
                buttonModel: { content: locale.getConstant('Ok'), cssClass: 'e-flat e-font-okay', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: locale.getConstant('Cancel'), cssClass: 'e-flat e-font-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    };
    /**
     * Applies character format
     * @param  {Selection} selection
     * @param  {WCharacterFormat} format
     * @private
     */
    FontDialog.prototype.onCharacterFormat = function (selection, format) {
        this.owner.owner.editorModule.initHistory('CharacterFormat');
        if (selection.isEmpty) {
            if (selection.start.offset === selection.getParagraphLength(selection.start.paragraph)) {
                // tslint:disable-next-line:max-line-length
                this.owner.owner.editorModule.applyCharFormatValueInternal(selection, selection.start.paragraph.characterFormat, undefined, format);
                this.owner.owner.editorModule.reLayout(selection);
            }
            this.owner.updateFocus();
            return;
        }
        else {
            //Iterate and update formating.
            this.owner.owner.editorModule.setOffsetValue(this.owner.selection);
            this.owner.owner.editorModule.updateSelectionCharacterFormatting('CharacterFormat', format, false);
        }
    };
    /**
     * @private
     */
    FontDialog.prototype.enableCheckBoxProperty = function (args) {
        if (this.strikethroughBox.checked && this.doublestrikethrough.checked) {
            this.strikethroughBox.checked = false;
            this.doublestrikethrough.checked = false;
            if (args.event.currentTarget.id === this.target.id + '_doubleStrikeThrough') {
                this.doublestrikethrough.checked = true;
            }
            else {
                this.strikethroughBox.checked = true;
            }
        }
        if (this.superscript.checked && this.subscript.checked) {
            this.subscript.checked = false;
            this.superscript.checked = false;
            if (args.event.currentTarget.id === this.target.id + '_subScript') {
                this.subscript.checked = true;
            }
            else {
                this.superscript.checked = true;
            }
        }
    };
    /**
     * @private
     */
    FontDialog.prototype.unWireEventsAndBindings = function () {
        this.fontNameList.value = '';
        this.fontSizeText.value = '';
        this.fontStyleText.value = '';
        this.strikethroughBox.checked = false;
        this.doublestrikethrough.checked = false;
        this.superscript.checked = false;
        this.subscript.checked = false;
        this.bold = undefined;
        this.italic = undefined;
        this.underline = undefined;
        this.strikethrough = undefined;
        this.baselineAlignment = undefined;
        this.fontColor = undefined;
        this.fontSize = undefined;
        this.fontFamily = undefined;
    };
    /**
     * @private
     */
    FontDialog.prototype.destroy = function () {
        this.owner = undefined;
        if (this.characterFormat) {
            this.characterFormat.destroy();
            this.characterFormat = undefined;
        }
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (var m = 0; m < this.target.childNodes.length; m++) {
                this.target.removeChild(this.target.childNodes[m]);
                m--;
            }
            this.target = undefined;
        }
        if (this.fontNameList) {
            this.fontNameList.destroy();
        }
        this.fontNameList = undefined;
        if (this.fontStyleText) {
            this.fontStyleText.destroy();
        }
        this.fontStyleText = undefined;
        if (this.fontSizeText) {
            this.fontSizeText.destroy();
        }
        this.fontSizeText = undefined;
        if (this.colorPicker) {
            this.colorPicker.destroy();
        }
        this.colorPicker = undefined;
        if (this.underlineDrop) {
            this.underlineDrop.destroy();
        }
        this.underlineDrop = undefined;
        if (this.strikethroughBox) {
            this.strikethroughBox.destroy();
        }
        this.strikethroughBox = undefined;
        if (this.doublestrikethrough) {
            this.doublestrikethrough.destroy();
        }
        this.doublestrikethrough = undefined;
        if (this.superscript) {
            this.superscript.destroy();
        }
        this.superscript = undefined;
        if (this.subscript) {
            this.subscript.destroy();
        }
        this.subscript = undefined;
    };
    return FontDialog;
}());

/* tslint:enable:no-any */

/**
 * The Table properties dialog is used to modify properties of selected table.
 */
var TablePropertiesDialog = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function TablePropertiesDialog(viewer) {
        var _this = this;
        this.hasTableWidth = false;
        this.hasCellWidth = false;
        this.bidi = false;
        /**
         * @private
         */
        this.isTableBordersAndShadingUpdated = false;
        /**
         * @private
         */
        this.isCellBordersAndShadingUpdated = false;
        this.tabObj = undefined;
        this.localValue = undefined;
        /**
         * @private
         */
        this.isCellOptionsUpdated = false;
        /**
         * @private
         */
        this.isTableOptionsUpdated = false;
        this.onBeforeOpen = function () {
            _this.owner.updateFocus();
            _this.loadTableProperties();
        };
        /**
         * @private
         */
        this.onCloseTablePropertyDialog = function () {
            _this.unWireEvent.bind(_this);
            _this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.applyTableProperties = function () {
            var selection = _this.owner.selection;
            if (!_this.preferCheckBox.checked && !_this.preferCheckBox.indeterminate) {
                if (isNullOrUndefined(selection.tableFormat.preferredWidth) || selection.tableFormat.preferredWidth !== 0) {
                    _this.tableFormat.preferredWidth = 0;
                    _this.tableFormat.preferredWidthType = 'Point';
                }
            }
            if (_this.tableFormat.hasValue('tableAlignment') && _this.tableFormat.tableAlignment !== 'Left') {
                if (isNullOrUndefined(selection.tableFormat.leftIndent) || selection.tableFormat.leftIndent !== 0) {
                    _this.tableFormat.leftIndent = 0;
                }
            }
            if (!_this.rowHeightCheckBox.checked && !_this.rowHeightCheckBox.indeterminate) {
                if (isNullOrUndefined(selection.rowFormat.height) || selection.rowFormat.height !== 0) {
                    _this.rowFormat.heightType = 'AtLeast';
                    _this.rowFormat.height = 0;
                }
            }
            if (!_this.preferredCellWidthCheckBox.checked && !_this.preferredCellWidthCheckBox.indeterminate) {
                if (isNullOrUndefined(selection.cellFormat.preferredWidth) || selection.cellFormat.preferredWidth === 0) {
                    _this.cellFormat.preferredWidthType = 'Point';
                    _this.cellFormat.preferredWidth = 0;
                }
            }
            else {
                if (_this.cellFormat.preferredWidthType === 'Percent') {
                    if (!_this.tableFormat.hasValue('preferredWidth') && !_this.tableFormat.hasValue('preferredWidthType')
                        && _this.owner.selection.start.paragraph.associatedCell.ownerTable.tableFormat.preferredWidth === 0) {
                        // tslint:disable-next-line:max-line-length
                        var containerWidth = _this.owner.selection.start.paragraph.associatedCell.ownerTable.getOwnerWidth(true);
                        var tableWidth = _this.owner.selection.start.paragraph.associatedCell.ownerTable.getTableClientWidth(containerWidth);
                        _this.tableFormat.preferredWidthType = 'Percent';
                        _this.tableFormat.preferredWidth = tableWidth / HelperMethods.convertPixelToPoint(_this.owner.clientArea.width) * 100;
                    }
                }
            }
            if (_this.rowHeightValue) {
                _this.rowFormat.height = _this.rowHeightValue;
            }
            _this.owner.owner.editorModule.initComplexHistory('TableProperties');
            _this.owner.owner.editorModule.onTableFormat(_this.tableFormat);
            _this.owner.owner.editorModule.onRowFormat(_this.rowFormat);
            _this.owner.owner.editorModule.onCellFormat(_this.cellFormat);
            _this.owner.owner.editorHistory.updateComplexHistory();
            _this.closeTablePropertiesDialog();
            _this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.applyTableSubProperties = function () {
            if (_this.isCellOptionsUpdated) {
                var cellFormat = _this.owner.owner.cellOptionsDialogModule.cellFormat;
                _this.owner.owner.cellOptionsDialogModule.applySubCellOptions(cellFormat);
            }
            if (_this.isTableOptionsUpdated) {
                var tableFormat = _this.owner.owner.tableOptionsDialogModule.tableFormat;
                _this.owner.owner.tableOptionsDialogModule.applySubTableOptions(tableFormat);
            }
            _this.isCellOptionsUpdated = false;
            _this.isTableOptionsUpdated = false;
        };
        /**
         * @private
         */
        this.unWireEvent = function () {
            //Table Format
            _this.preferCheckBox.change = undefined;
            _this.tableWidthBox.change = undefined;
            _this.tableWidthType.change = undefined;
            _this.leftIndentBox.change = undefined;
            //Row Format
            _this.rowHeightCheckBox.change = undefined;
            _this.rowHeightBox.change = undefined;
            _this.rowHeightType.change = undefined;
            _this.repeatHeader.change = undefined;
            _this.allowRowBreak.change = undefined;
            //Cell Format
            _this.preferredCellWidthCheckBox.change = undefined;
            _this.cellWidthBox.change = undefined;
            _this.cellWidthType.change = undefined;
            _this.cellFormat.destroy();
            _this.rowFormat.destroy();
            _this.tableFormat.destroy();
            _this.rowHeightValue = undefined;
            _this.owner.dialog2.open = _this.owner.selection.hideCaret.bind(_this.owner);
        };
        /**
         * @private
         */
        this.closeTablePropertiesDialog = function () {
            _this.owner.dialog2.hide();
            _this.owner.updateFocus();
        };
        this.changeBidirectional = function (event) {
            if (event.value === 'ltr') {
                _this.rtlButton.checked = !_this.ltrButton.checked;
                _this.tableFormat.bidi = false;
            }
            else {
                _this.ltrButton.checked = !_this.rtlButton.checked;
                _this.tableFormat.bidi = true;
            }
            if (_this.tableFormat.bidi && _this.tableFormat.tableAlignment === 'Left') {
                _this.tableFormat.tableAlignment = 'Right';
            }
            else if (!_this.tableFormat.bidi && _this.tableFormat.tableAlignment === 'Right') {
                _this.tableFormat.tableAlignment = 'Left';
            }
            _this.activeTableAlignment(_this.tableFormat, true);
        };
        /**
         * @private
         */
        this.changeTableCheckBox = function () {
            var enable = (_this.preferCheckBox.checked || _this.preferCheckBox.indeterminate);
            _this.tableWidthBox.enabled = enable;
            _this.tableWidthType.enabled = enable;
            if (enable) {
                _this.tableFormat.preferredWidthType = (_this.tableWidthType.value === 'Points') ?
                    'Point' : _this.tableWidthType.value;
            }
            else {
                _this.tableFormat.preferredWidthType = _this.owner.selection.tableFormat.preferredWidthType;
            }
        };
        /**
         * @private
         */
        this.changeTableAlignment = function (event) {
            _this.updateClassForAlignmentProperties(_this.tableTab);
            var element = event.target;
            classList(element, ['e-de-table-alignment-active'], ['e-de-table-properties-alignment']);
            var bidi = _this.tableFormat.bidi || _this.rtlButton.checked;
            if ((element.classList.contains('e-de-table-left-alignment') && !bidi) ||
                (element.classList.contains('e-de-table-right-alignment') && bidi)) {
                _this.leftIndentBox.enabled = true;
            }
            else {
                _this.leftIndentBox.enabled = false;
            }
            _this.tableFormat.tableAlignment = _this.getTableAlignment();
        };
        /**
         * @private
         */
        this.changeTableRowCheckBox = function () {
            _this.rowHeightType.enabled = _this.rowHeightCheckBox.checked;
            _this.rowHeightBox.enabled = _this.rowHeightCheckBox.checked;
            if (_this.rowHeightType.enabled) {
                _this.rowFormat.heightType = _this.rowHeightType.value;
            }
            else {
                _this.rowFormat.heightType = _this.owner.selection.rowFormat.heightType;
            }
        };
        /**
         * @private
         */
        this.changeTableCellCheckBox = function () {
            _this.cellWidthType.enabled = _this.preferredCellWidthCheckBox.checked;
            _this.cellWidthBox.enabled = _this.preferredCellWidthCheckBox.checked;
        };
        /**
         * @private
         */
        this.changeCellAlignment = function (event) {
            _this.updateClassForCellAlignment(_this.cellTab);
            var element = event.target;
            classList(element, ['e-de-table-alignment-active'], ['e-de-tablecell-alignment']);
            _this.cellFormat.verticalAlignment = _this.getCellAlignment();
        };
        //#endregion
        /**
         * @private
         */
        this.showTableOptionsDialog = function () {
            _this.owner.owner.tableOptionsDialogModule.show();
            _this.owner.dialog2.element.style.pointerEvents = 'none';
        };
        /**
         * @private
         */
        this.showBordersShadingsPropertiesDialog = function () {
            _this.owner.owner.bordersAndShadingDialogModule.show();
            _this.owner.dialog2.element.style.pointerEvents = 'none';
        };
        /**
         * @private
         */
        this.showCellOptionsDialog = function () {
            _this.owner.owner.cellOptionsDialogModule.show();
            _this.owner.dialog2.element.style.pointerEvents = 'none';
        };
        this.owner = viewer;
    }
    Object.defineProperty(TablePropertiesDialog.prototype, "cellFormat", {
        /**
         * @private
         */
        get: function () {
            if (isNullOrUndefined(this.cellFormatIn)) {
                return this.cellFormatIn = new WCellFormat();
            }
            return this.cellFormatIn;
        },
        /**
         * @private
         */
        set: function (value) {
            this.cellFormatIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TablePropertiesDialog.prototype, "tableFormat", {
        /**
         * @private
         */
        get: function () {
            if (isNullOrUndefined(this.tableFormatIn)) {
                this.tableFormatIn = new WTableFormat();
                return this.tableFormatIn;
            }
            return this.tableFormatIn;
        },
        /**
         * @private
         */
        set: function (value) {
            this.tableFormatIn = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TablePropertiesDialog.prototype, "rowFormat", {
        /**
         * @private
         */
        get: function () {
            if (isNullOrUndefined(this.rowFormatInternal)) {
                this.rowFormatInternal = new WRowFormat();
                return this.rowFormatInternal;
            }
            return this.rowFormatInternal;
        },
        enumerable: true,
        configurable: true
    });
    TablePropertiesDialog.prototype.getModuleName = function () {
        return 'TablePropertiesDialog';
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.initTablePropertyDialog = function (localValue, isRtl) {
        this.localValue = localValue;
        var id = this.owner.owner.containerId + '_TablePropertiesDialog';
        this.target = createElement('div', { id: id, className: 'e-de-table-properties-dlg' });
        var ejtabContainer = createElement('div', { id: this.target.id + '_TabContainer' });
        this.target.appendChild(ejtabContainer);
        this.tableTab = createElement('div', {
            id: this.target.id + '_TablePropertiesContentDialogTab', className: 'e-de-table-ppty-dlg-tabs'
        });
        this.rowTab = createElement('div', {
            id: this.target.id + '_RowPropertiesDialogTab', className: 'e-de-table-ppty-dlg-tabs'
        });
        this.cellTab = createElement('div', {
            id: this.target.id + '_CellPropertiesDialogTab', className: 'e-de-table-ppty-dlg-tabs'
        });
        var separatorLine = createElement('div', { className: 'e-de-table-dialog-separator-line' });
        // tslint:disable-next-line:max-line-length
        var ejtab = createElement('div', { id: this.target.id + '_TablePropertiesDialogTab', className: 'e-de-table-ppty-tab' });
        var headerContainer = createElement('div', { className: 'e-tab-header' });
        var tableHeader = createElement('div', {
            id: this.target.id + '_tableHeader', innerHTML: localValue.getConstant('Table')
        });
        var rowHeader = createElement('div', {
            id: this.target.id + '_rowHeader', innerHTML: localValue.getConstant('Row')
        });
        var cellHeader = createElement('div', {
            id: this.target.id + '_cellHeader', innerHTML: localValue.getConstant('Cell')
        });
        headerContainer.appendChild(tableHeader);
        headerContainer.appendChild(rowHeader);
        headerContainer.appendChild(cellHeader);
        var contentContainer = createElement('div', { className: 'e-content' });
        var tableContent = createElement('div', { id: this.target.id + '_tableContent' });
        var rowContent = createElement('div', { id: this.target.id + '_rowContent' });
        var cellContent = createElement('div', { id: this.target.id + '_cellContent' });
        tableContent.appendChild(this.tableTab);
        rowContent.appendChild(this.rowTab);
        cellContent.appendChild(this.cellTab);
        contentContainer.appendChild(tableContent);
        contentContainer.appendChild(rowContent);
        contentContainer.appendChild(cellContent);
        ejtab.appendChild(headerContainer);
        ejtab.appendChild(contentContainer);
        ejtabContainer.appendChild(ejtab);
        this.initTableProperties(this.tableTab, localValue, this.owner.owner.enableRtl);
        this.initTableRowProperties(this.rowTab, localValue, this.owner.owner.enableRtl);
        this.initTableCellProperties(this.cellTab, localValue, this.owner.owner.enableRtl);
        this.tabObj = new Tab({ enableRtl: isRtl }, ejtab);
        this.target.appendChild(separatorLine);
        var alignMentButtons = this.tableTab.getElementsByClassName(this.tableTab.id + 'e-de-table-alignment');
        for (var i = 0; i < alignMentButtons.length; i++) {
            alignMentButtons[i].addEventListener('click', this.changeTableAlignment);
        }
        var cellAlignment = this.cellTab.getElementsByClassName(this.cellTab.id + 'e-de-table-cell-alignment');
        for (var i = 0; i < cellAlignment.length; i++) {
            cellAlignment[i].addEventListener('click', this.changeCellAlignment);
        }
        // let tableTabHeader: HTMLElement = this.tabObj.element.getElementsByClassName('e-item e-toolbar-item')[0] as HTMLElement;
        // let tableTabHeaderItem: HTMLElement = tableTabHeader.getElementsByClassName('e-tab-wrap')[0] as HTMLElement;
        // let rowTabHeader: HTMLElement = this.tabObj.element.getElementsByClassName('e-item e-toolbar-item')[1] as HTMLElement;
        // let rowTabHeaderItem: HTMLElement = rowTabHeader.getElementsByClassName('e-tab-wrap')[0] as HTMLElement;
        // rowTabHeaderItem.classList.add('e-de-table-ppty-dlg-row-header');
        // let cellTabHeader: HTMLElement = this.tabObj.element.getElementsByClassName('e-item e-toolbar-item')[2] as HTMLElement;
        // let cellTabHeaderItem: HTMLElement = cellTabHeader.getElementsByClassName('e-tab-wrap')[0] as HTMLElement;
        // cellTabHeaderItem.classList.add('e-de-table-ppty-dlg-cell-header');
        // if (isRtl) {
        //     tableTabHeaderItem.classList.add('e-de-rtl');
        //     (this.tabObj.element.getElementsByClassName('e-indicator')[0] as HTMLElement).style.left = '155px';
        // } else {
        //     (this.tabObj.element.getElementsByClassName('e-indicator')[0] as HTMLElement).style.right = '155px';
        // }
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.show = function () {
        var localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localValue.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initTablePropertyDialog(localValue, this.owner.owner.enableRtl);
        }
        if (this.owner.selection.caret.style.display !== 'none') {
            this.owner.selection.caret.style.display = 'none';
        }
        this.owner.dialog2.header = localValue.getConstant('Table Properties');
        this.owner.dialog2.position = { X: 'center', Y: 'center' };
        this.owner.dialog2.width = 'auto';
        this.owner.dialog2.height = 'auto';
        this.owner.dialog2.content = this.target;
        this.owner.dialog2.beforeOpen = this.onBeforeOpen;
        this.owner.dialog2.close = this.onCloseTablePropertyDialog;
        this.owner.dialog2.open = this.wireEvent.bind(this);
        this.owner.dialog2.buttons = [{
                click: this.applyTableProperties,
                buttonModel: { content: localValue.getConstant('Ok'), cssClass: 'e-flat e-table-ppty-okay', isPrimary: true }
            },
            {
                click: this.closeTablePropertiesDialog,
                buttonModel: { content: localValue.getConstant('Cancel'), cssClass: 'e-flat e-table-ppty-cancel' }
            }];
        //this.tabObj.select(0);
        this.owner.dialog2.dataBind();
        this.owner.dialog2.show();
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.calculateGridValue = function (table) {
        table.calculateGrid();
        table.isGridUpdated = false;
        table.buildTableColumns();
        table.isGridUpdated = true;
        this.owner.selection.owner.isLayoutEnabled = true;
        this.owner.layout.reLayoutTable(table);
        this.owner.owner.editorModule.reLayout(this.owner.selection);
        this.owner.owner.editorModule.updateSelectionTextPosition(true);
        var history = this.owner.owner.editorHistory;
        if (history && history.currentBaseHistoryInfo) {
            if (history.currentBaseHistoryInfo.modifiedProperties.length > 0) {
                history.currentBaseHistoryInfo.updateSelection();
            }
            history.updateHistory();
        }
        this.owner.owner.editorModule.fireContentChange();
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.loadTableProperties = function () {
        this.setTableProperties();
        this.setTableRowProperties();
        this.setTableCellProperties();
        if (!this.owner.owner.bordersAndShadingDialogModule) {
            this.bordersAndShadingButton.disabled = true;
        }
        else {
            this.bordersAndShadingButton.disabled = false;
        }
        // if (!this.owner.owner.tableOptionsDialogModule) {
        //     this.tableOptionButton.disabled = true;
        // } else {
        this.tableOptionButton.disabled = false;
        // }
        // if (!this.owner.owner.cellOptionsDialogModule) {
        //     this.cellOptionButton.disabled = true;
        // } else {
        this.cellOptionButton.disabled = false;
        // }
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.wireEvent = function () {
        this.owner.selection.hideCaret();
        //Table Format
        this.preferCheckBox.change = this.changeTableCheckBox.bind(this);
        this.tableWidthBox.change = this.onTableWidthChange.bind(this);
        this.tableWidthType.change = this.onTableWidthTypeChange.bind(this);
        this.leftIndentBox.change = this.onLeftIndentChange.bind(this);
        //Row Format
        this.rowHeightCheckBox.change = this.changeTableRowCheckBox.bind(this);
        this.rowHeightBox.change = this.onRowHeightChange.bind(this);
        this.rowHeightType.change = this.onRowHeightTypeChange.bind(this);
        this.allowRowBreak.change = this.onAllowBreakAcrossPage.bind(this);
        this.repeatHeader.change = this.onRepeatHeader.bind(this);
        //Cell Format
        this.preferredCellWidthCheckBox.change = this.changeTableCellCheckBox.bind(this);
        this.cellWidthBox.change = this.onCellWidthChange.bind(this);
        this.cellWidthType.change = this.onCellWidthTypeChange.bind(this);
    };
    //#region Table Format
    /**
     * @private
     */
    // tslint:disable-next-line:max-func-body-length
    TablePropertiesDialog.prototype.initTableProperties = function (element, localValue, isRtl) {
        var container = createElement('div', { id: element.id + '_table_TabContainer' });
        var sizeHeader = createElement('div', {
            id: container.id + '_sizeLabel', innerHTML: localValue.getConstant('Size'),
            styles: 'width:100%;margin:0px;', className: 'e-de-table-dialog-options-label'
        });
        var parentContainer = createElement('div', { styles: 'display: inline-flex;' });
        var childContainer1 = createElement('div', {
            styles: 'float: left;',
            className: 'e-de-table-container-div'
        });
        var childContainer2 = createElement('div', {
            className: 'e-de-table-ppty-dlg-preferred-width-div'
        });
        var child1 = createElement('div', {
            styles: 'display: inline;',
            className: 'e-de-table-ppty-dlg-measure-div'
        });
        var child2 = createElement('div', {
            styles: 'display: inline;position: absolute;',
            className: 'e-de-table-ppty-dlg-measure-drop-down-div'
        });
        var childContainer3 = createElement('div');
        var preferCheckBox = createElement('input', {
            id: element.id + '_Prefer_Width_CheckBox', attrs: { 'type': 'checkbox' }
        });
        this.preferredWidth = createElement('input', { id: element.id + 'preferred_Width' });
        var controlDiv = createElement('div');
        var tableWidthType = createElement('select', {
            innerHTML: '<option>' + localValue.getConstant('Points') +
                '</option><option>' + localValue.getConstant('Percent') + '</option>', id: element.id + '_width_dropdown'
        });
        var labeltext = createElement('label', {
            innerHTML: localValue.getConstant('Measure in'), styles: 'width: 60px;font-size: 11px; font-weight: normal;'
        });
        var alignmentHeader = createElement('div', {
            innerHTML: localValue.getConstant('Alignment'), className: 'e-de-table-dialog-options-label',
            styles: 'width: 100%;margin: 0px;'
        });
        var alignmentContainer = createElement('div', { styles: 'height:85px;display:inline-flex' });
        var classDivName = element.id + 'e-de-table-alignment';
        var leftAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        this.left = createElement('div', {
            className: 'e-icons e-de-table-properties-alignment e-de-table-left-alignment ' + classDivName,
            id: element.id + '_left_alignment', styles: 'width:54px;height:54px;margin:2px'
        });
        leftAlignDiv.appendChild(this.left);
        var centerAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        this.center = createElement('div', {
            className: 'e-icons e-de-table-properties-alignment  e-de-table-center-alignment ' + classDivName,
            id: element.id + '_center_alignment', styles: 'width:54px;height:54px;margin:2px'
        });
        centerAlignDiv.appendChild(this.center);
        this.right = createElement('div', {
            styles: 'width:54px;height:54px;margin:2px', id: element.id + '_right_alignment',
            className: 'e-icons e-de-table-properties-alignment  e-de-table-right-alignment ' + classDivName
        });
        var rightAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        rightAlignDiv.appendChild(this.right);
        var leftlabel = createElement('label', {
            innerHTML: localValue.getConstant('Left'), className: 'e-de-table-dia-align-label'
        });
        var centerlabel = createElement('label', {
            innerHTML: localValue.getConstant('Center'), className: 'e-de-table-dia-align-label'
        });
        var rightlabel = createElement('label', {
            innerHTML: localValue.getConstant('Right'), className: 'e-de-table-dia-align-label'
        });
        var leftIndenetContainer = createElement('div', {
            className: 'e-de-table-ppty-dlg-left-indent-container'
        });
        var leftIndentLabelMargin;
        var leftIndentBoxMargin;
        if (isRtl) {
            leftIndentLabelMargin = 'left: 45px;';
            leftIndentBoxMargin = 'left: 45px;';
        }
        else {
            leftIndentLabelMargin = 'right: 45px;';
            leftIndentBoxMargin = 'right: 45px;';
        }
        this.indentingLabel = createElement('label', {
            innerHTML: localValue.getConstant('Indent from left'),
            // tslint:disable-next-line:max-line-length
            styles: 'font-weight: normal;font-size: 11px;position:relative;display:block;margin-bottom:18px;top:10px;' + leftIndentLabelMargin
        });
        var leftIndentBox = createElement('div', {
            styles: 'margin-top: 15px;position: relative;' + leftIndentBoxMargin
        });
        this.leftIndent = createElement('input', { id: element.id + '_left_indent' });
        var tableDirHeader = createElement('div', {
            innerHTML: localValue.getConstant('Table direction'), className: 'e-de-table-dialog-options-label',
            styles: 'width: 100%;margin: 0px;padding-top:14px;'
        });
        var tableDirContainer = createElement('div', { styles: 'display:flex' });
        var rtlDiv = createElement('div', { id: element.id + '_TableDirDiv', className: 'e-de-tbl-rtl-btn-div' });
        var rtlInputELe = createElement('input', { id: element.id + '_rtlEle' });
        rtlDiv.appendChild(rtlInputELe);
        tableDirContainer.appendChild(rtlDiv);
        var ltrDiv = createElement('div', { id: element.id + '_DirDiv', className: 'e-de-tbl-ltr-btn-div' });
        var ltrInputELe = createElement('input', { id: element.id + '_ltrEle' });
        ltrDiv.appendChild(ltrInputELe);
        tableDirContainer.appendChild(ltrDiv);
        this.rtlButton = new RadioButton({
            label: localValue.getConstant('Right-to-left'),
            value: 'rtl', cssClass: 'e-small', change: this.changeBidirectional,
            enableRtl: isRtl
        });
        this.rtlButton.appendTo(rtlInputELe);
        this.ltrButton = new RadioButton({
            label: localValue.getConstant('Left-to-right'),
            value: 'ltr', cssClass: 'e-small', change: this.changeBidirectional,
            enableRtl: isRtl
        });
        this.ltrButton.appendTo(ltrInputELe);
        var tableOptionContiner = createElement('div', {
            className: 'e-de-tbl-dlg-border-btn'
        });
        if (isRtl) {
            tableOptionContiner.style.cssFloat = 'left';
        }
        this.bordersAndShadingButton = createElement('button', {
            innerHTML: localValue.getConstant('Borders and Shading'),
            id: element.id + '_borders_and_shadings', className: 'e-control e-btn e-flat e-de-ok-button',
            attrs: { type: 'button' }
        });
        this.tableOptionButton = createElement('button', {
            className: 'e-control e-btn e-flat', innerHTML: localValue.getConstant('Options'),
            id: element.id + '_table_cellmargin', attrs: { type: 'button' }
        });
        this.tableOptionButton.addEventListener('click', this.showTableOptionsDialog);
        this.bordersAndShadingButton.addEventListener('click', this.showBordersShadingsPropertiesDialog);
        tableOptionContiner.appendChild(this.bordersAndShadingButton);
        tableOptionContiner.appendChild(this.tableOptionButton);
        leftIndenetContainer.appendChild(this.indentingLabel);
        leftIndentBox.appendChild(this.leftIndent);
        leftIndenetContainer.appendChild(leftIndentBox);
        alignmentContainer.appendChild(leftAlignDiv);
        alignmentContainer.appendChild(centerAlignDiv);
        alignmentContainer.appendChild(rightAlignDiv);
        leftAlignDiv.appendChild(leftlabel);
        centerAlignDiv.appendChild(centerlabel);
        rightAlignDiv.appendChild(rightlabel);
        alignmentContainer.appendChild(leftIndenetContainer);
        container.appendChild(sizeHeader);
        element.appendChild(container);
        childContainer1.appendChild(preferCheckBox);
        parentContainer.appendChild(childContainer1);
        childContainer2.appendChild(this.preferredWidth);
        parentContainer.appendChild(childContainer2);
        controlDiv.appendChild(tableWidthType);
        child1.appendChild(labeltext);
        child2.appendChild(controlDiv);
        childContainer3.appendChild(child1);
        childContainer3.appendChild(child2);
        parentContainer.appendChild(childContainer3);
        element.appendChild(parentContainer);
        element.appendChild(alignmentHeader);
        element.appendChild(alignmentContainer);
        element.appendChild(tableDirHeader);
        element.appendChild(tableDirContainer);
        element.appendChild(tableOptionContiner);
        this.tableWidthBox = new NumericTextBox({
            value: 0, decimals: 2, min: 0, max: 1584, width: 120, enablePersistence: false
        });
        this.tableWidthBox.appendTo(this.preferredWidth);
        this.leftIndentBox = new NumericTextBox({
            value: 0, decimals: 2, min: -1584, max: 1584, width: 140, enablePersistence: false
        });
        this.leftIndentBox.appendTo(this.leftIndent);
        this.preferCheckBox = new CheckBox({
            label: localValue.getConstant('Preferred Width'), enableRtl: isRtl
        });
        this.preferCheckBox.appendTo(preferCheckBox);
        this.tableWidthType = new DropDownList({ width: '120px', enableRtl: isRtl });
        this.tableWidthType.appendTo(tableWidthType);
        if (isRtl) {
            rtlDiv.classList.add('e-de-rtl');
            childContainer2.classList.add('e-de-rtl');
            child1.classList.add('e-de-rtl');
            child2.classList.add('e-de-rtl');
            leftIndenetContainer.classList.add('e-de-rtl');
            tableOptionContiner.classList.add('e-de-rtl');
            this.bordersAndShadingButton.classList.add('e-de-rtl');
            leftAlignDiv.classList.add('e-de-rtl');
            centerAlignDiv.classList.add('e-de-rtl');
            rightAlignDiv.classList.add('e-de-rtl');
        }
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.onTableWidthChange = function () {
        this.tableFormat.preferredWidth = this.tableWidthBox.value;
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.onTableWidthTypeChange = function () {
        var value;
        var table = this.owner.selection.start.paragraph.associatedCell.ownerTable;
        var width = HelperMethods.convertPixelToPoint(this.owner.clientArea.width);
        if (this.tableWidthType.text === 'Percent' && this.owner.selection.tableFormat.preferredWidthType !== 'Percent') {
            value = this.tableWidthBox.value / width * 100;
            this.formatNumericTextBox(this.tableWidthBox, 'Percent', value);
        }
        else if (this.tableWidthType.text === 'Points' && this.owner.selection.tableFormat.preferredWidthType !== 'Point') {
            value = width / 100 * this.tableWidthBox.value;
            this.formatNumericTextBox(this.tableWidthBox, 'Point', value);
        }
        else {
            if (this.tableWidthBox.format === '#\'\%\'') {
                if (this.tableWidthType.text === 'Points') {
                    value = width / 100 * this.tableWidthBox.value;
                }
                else {
                    value = this.tableWidthBox.value;
                }
            }
            else {
                if (this.tableWidthType.text === 'Percent') {
                    value = this.tableWidthBox.value / width * 100;
                }
                else {
                    value = this.tableWidthBox.value;
                }
            }
            // tslint:disable-next-line:max-line-length
            this.formatNumericTextBox(this.tableWidthBox, (this.tableWidthType.text === 'Points') ? 'Point' : this.tableWidthType.text, value);
        }
        this.tableFormat.preferredWidthType = (this.tableWidthType.text === 'Points') ? 'Point' : this.tableWidthType.text;
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.onLeftIndentChange = function () {
        this.tableFormat.leftIndent = this.leftIndentBox.value;
    };
    TablePropertiesDialog.prototype.setTableProperties = function () {
        //instance of Table Property values
        var tableFormat = this.owner.selection.tableFormat;
        var tableHasWidth = tableFormat.preferredWidth > 0;
        var preferredWidth = tableFormat.preferredWidth;
        if (isNullOrUndefined(tableFormat.preferredWidth)) {
            this.preferCheckBox.indeterminate = true;
            var startTable = this.owner.selection.start.paragraph.associatedCell.ownerTable;
            var table = startTable.combineWidget(this.owner);
            preferredWidth = table.tableFormat.preferredWidth;
        }
        else {
            this.preferCheckBox.checked = tableHasWidth;
        }
        this.tableWidthBox.enabled = tableHasWidth;
        this.tableWidthType.enabled = tableHasWidth;
        this.formatNumericTextBox(this.tableWidthBox, tableFormat.preferredWidthType, preferredWidth);
        if (tableFormat.preferredWidthType === 'Auto' || tableFormat.preferredWidthType === 'Point') {
            this.tableWidthType.index = 0;
        }
        else {
            this.tableWidthType.index = 1;
        }
        this.activeTableAlignment(tableFormat, false);
        if (tableFormat.bidi) {
            this.rtlButton.checked = true;
            this.ltrButton.checked = false;
        }
        else {
            this.ltrButton.checked = true;
            this.rtlButton.checked = false;
        }
    };
    TablePropertiesDialog.prototype.activeTableAlignment = function (tableFormat, isChanged) {
        var tableAlignment = isChanged ? this.tableFormat.tableAlignment : undefined;
        // Consider the TableAlignment based on the Bidirectional property.
        if (isNullOrUndefined(tableAlignment)) {
            if (tableFormat.bidi) {
                if (tableFormat.tableAlignment === 'Left') {
                    tableAlignment = 'Right';
                }
                else if (tableFormat.tableAlignment === 'Right') {
                    tableAlignment = 'Left';
                }
            }
            else {
                tableAlignment = tableFormat.tableAlignment;
            }
        }
        if (tableFormat.bidi) {
            this.leftIndentBox.enabled = tableAlignment === 'Right';
            this.indentingLabel.innerHTML = this.localValue.getConstant('Indent from right');
        }
        else {
            this.leftIndentBox.enabled = tableAlignment === 'Left';
            this.indentingLabel.innerHTML = this.localValue.getConstant('Indent from left');
        }
        this.leftIndentBox.value = tableFormat.leftIndent;
        classList(this.left, [], ['e-de-table-alignment-active']);
        classList(this.right, [], ['e-de-table-alignment-active']);
        classList(this.center, [], ['e-de-table-alignment-active']);
        if (tableAlignment === 'Left') {
            this.left.classList.add('e-de-table-alignment-active');
        }
        else if (tableAlignment === 'Center') {
            this.center.classList.add('e-de-table-alignment-active');
        }
        else if (tableAlignment === 'Right') {
            this.right.classList.add('e-de-table-alignment-active');
        }
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.getTableAlignment = function () {
        var id = this.tableTab.id;
        var groupButtons = this.tableTab.getElementsByClassName(id + 'e-de-table-alignment');
        for (var j = 0; j < groupButtons.length; j++) {
            var groupButton = groupButtons[j];
            if (groupButton.classList.contains('e-de-table-alignment-active')) {
                if (j === 0) {
                    return this.ltrButton.checked ? 'Left' : 'Right';
                }
                else if (j === 1) {
                    return 'Center';
                }
                else {
                    return this.ltrButton.checked ? 'Right' : 'Left';
                }
            }
        }
        return undefined;
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.updateClassForAlignmentProperties = function (element) {
        var id = element.id;
        var groupButtons = element.getElementsByClassName(id + 'e-de-table-alignment');
        for (var j = 0; j < groupButtons.length; j++) {
            var groupButton = groupButtons[j];
            if (groupButton.classList.contains('e-de-table-alignment-active')) {
                classList(groupButton, ['e-de-table-properties-alignment'], ['e-de-table-alignment-active']);
            }
        }
    };
    //#endregion
    //#region Row Format
    /**
     * @private
     */
    TablePropertiesDialog.prototype.initTableRowProperties = function (element, localValue, isRtl) {
        var rowDiv = createElement('div', { styles: 'width: 100%;' });
        var sizeLabeldiv = createElement('div', {
            innerHTML: localValue.getConstant('Size'),
            styles: 'width: 100%;',
            className: 'e-de-table-dialog-options-label'
        });
        var parentDiv = createElement('div', { styles: 'display: inline-flex;width: 100%;' });
        var childDiv1 = createElement('div', {
            className: 'e-de-table-header-div', styles: 'margin-top:6px'
        });
        var rowHeightCheckBox = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: element.id + '_height_CheckBox'
        });
        var childdiv2 = createElement('div', {
            className: 'e-de-row-ht-top'
        });
        this.rowHeight = createElement('input', {
            attrs: { 'type': 'text' }, 'id': element.id + '_table_row_height'
        });
        var child2 = createElement('div', { className: 'e-de-ht-wdth-type' });
        var child3 = createElement('div');
        var child4 = createElement('div');
        var controlDiv = createElement('div');
        var rowHeightType = createElement('select', {
            innerHTML: '<option>' + localValue.getConstant('At least')
                + '</option><option>' + localValue.getConstant('Exactly') + '</option>',
            id: element.id + '_height_type'
        });
        // tslint:disable-next-line:max-line-length
        var labeltext = createElement('label', {
            innerHTML: localValue.getConstant('Row height is'), styles: 'font-size: 11px;font-weight: normal;width: 75px;display:block;margin-bottom:8px'
        });
        rowDiv.appendChild(sizeLabeldiv);
        element.appendChild(rowDiv);
        childDiv1.appendChild(rowHeightCheckBox);
        parentDiv.appendChild(childDiv1);
        childdiv2.appendChild(this.rowHeight);
        parentDiv.appendChild(childdiv2);
        controlDiv.appendChild(rowHeightType);
        child3.appendChild(labeltext);
        child4.appendChild(controlDiv);
        child2.appendChild(child3);
        child2.appendChild(child4);
        parentDiv.appendChild(child2);
        element.appendChild(parentDiv);
        var alignmentDiv = createElement('div', {
            innerHTML: localValue.getConstant('Options'), styles: 'width: 100%;',
            className: 'e-de-table-dialog-options-label'
        });
        // tslint:disable-next-line:max-line-length
        var allowRowContainer = createElement('div', { className: 'e-de-table-ppty-options-break' });
        var repeatHeaderContaniner = createElement('div', { className: 'e-de-table-ppty-options-header-row' });
        var allowRowBreak = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: element.id + '_allow_row_break'
        });
        var repeatHeader = createElement('input', {
            attrs: { 'type': 'checkbox' }, 'id': element.id + '_repeat_header'
        });
        allowRowContainer.appendChild(allowRowBreak);
        repeatHeaderContaniner.appendChild(repeatHeader);
        element.appendChild(alignmentDiv);
        element.appendChild(allowRowContainer);
        element.appendChild(repeatHeaderContaniner);
        this.rowHeightBox = new NumericTextBox({
            value: 0, decimals: 2, min: 0, max: 1584, width: 120, enablePersistence: false
        });
        this.rowHeightBox.appendTo(this.rowHeight);
        this.rowHeightCheckBox = new CheckBox({
            label: localValue.getConstant('Specify height'),
            enableRtl: isRtl
        });
        this.rowHeightCheckBox.appendTo(rowHeightCheckBox);
        this.rowHeightType = new DropDownList({ width: '120px', enableRtl: isRtl });
        this.rowHeightType.appendTo(rowHeightType);
        this.allowRowBreak = new CheckBox({
            label: localValue.getConstant('Allow row to break across pages'),
            enableRtl: isRtl
        });
        this.allowRowBreak.appendTo(allowRowBreak);
        this.repeatHeader = new CheckBox({
            label: localValue.getConstant('Repeat as header row at the top of each page'),
            enableRtl: isRtl
        });
        this.repeatHeader.appendTo(repeatHeader);
        if (isRtl) {
            child3.classList.add('e-de-rtl');
            child4.classList.add('e-de-rtl');
            childdiv2.classList.add('e-de-rtl');
        }
    };
    TablePropertiesDialog.prototype.setTableRowProperties = function () {
        var rowFormat = this.owner.selection.rowFormat;
        var enableRowHeight = (rowFormat.height > 0 || rowFormat.heightType === 'Exactly');
        //instance of table row values
        if (enableRowHeight) {
            this.rowHeightCheckBox.checked = true;
        }
        else {
            if (rowFormat.heightType === undefined) {
                this.rowHeightCheckBox.indeterminate = true;
                enableRowHeight = true;
            }
            else {
                this.rowHeightCheckBox.checked = false;
            }
        }
        this.rowHeightBox.enabled = enableRowHeight;
        this.rowHeightType.enabled = enableRowHeight;
        var enabledHeader = this.enableRepeatHeader() ? false : true;
        if (isNullOrUndefined(this.owner.selection.rowFormat.isHeader)) {
            this.repeatHeader.indeterminate = true;
            this.repeatHeader.disabled = true;
        }
        else if (this.owner.selection.rowFormat.isHeader) {
            this.repeatHeader.checked = !enabledHeader;
            this.repeatHeader.indeterminate = enabledHeader;
            this.repeatHeader.disabled = enabledHeader;
        }
        else {
            this.repeatHeader.checked = false;
            this.repeatHeader.indeterminate = false;
            this.repeatHeader.disabled = enabledHeader;
        }
        if (isNullOrUndefined(rowFormat.allowBreakAcrossPages)) {
            this.allowRowBreak.indeterminate = true;
        }
        else {
            this.allowRowBreak.checked = rowFormat.allowBreakAcrossPages;
        }
        this.rowHeightBox.value = rowFormat.height;
        if (rowFormat.heightType === 'Auto' || rowFormat.heightType === 'AtLeast') {
            this.rowHeightType.index = 0;
        }
        else {
            this.rowHeightType.index = 1;
        }
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.onRowHeightChange = function () {
        this.rowHeightValue = this.rowHeightBox.value;
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.onRowHeightTypeChange = function () {
        this.rowFormat.heightType = this.rowHeightType.text;
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.onAllowBreakAcrossPage = function () {
        this.rowFormat.allowBreakAcrossPages = this.allowRowBreak.checked;
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.onRepeatHeader = function () {
        this.rowFormat.isHeader = this.repeatHeader.checked;
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.enableRepeatHeader = function () {
        var selection = this.owner.selection;
        var start = selection.start;
        var end = selection.end;
        if (!selection.isForward) {
            start = selection.end;
            end = selection.start;
        }
        var startCell = start.paragraph.associatedCell;
        var endCell = end.paragraph.associatedCell;
        return startCell.ownerRow.index === 0 && endCell.ownerTable.equals(startCell.ownerTable);
    };
    //#endregion
    //#region Cell Format
    /**
     * @private
     */
    // tslint:disable-next-line:max-func-body-length
    TablePropertiesDialog.prototype.initTableCellProperties = function (element, localValue, isRtl) {
        var sizeDiv = createElement('div', { styles: 'width: 100%;' });
        var div = createElement('div', {
            innerHTML: localValue.getConstant('Size'), className: 'e-de-table-dialog-options-label',
            styles: 'width: 100%;',
        });
        var parentdiv = createElement('div', { styles: 'width: 100%;display: inline-flex;' });
        var childdiv1 = createElement('div', {
            className: 'e-de-table-cell-header-div', styles: 'margin-top:9px'
        });
        var preferredCellWidthCheckBox = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: element.id + '_Prefer_Width_CheckBox_cell'
        });
        var childdiv2 = createElement('div', {
            styles: 'padding:0px 20px',
        });
        this.preferredCellWidth = createElement('input', {
            id: element.id + 'tablecell_Width_textBox', attrs: { 'type': 'text' }
        });
        var child2 = createElement('div', {
            className: 'e-de-ht-wdth-type'
        });
        var child3 = createElement('div');
        var child4 = createElement('div');
        var controlDiv = createElement('div');
        var cellWidthType = createElement('select', {
            innerHTML: '<option>' + localValue.getConstant('Points') + '</option><option>' +
                localValue.getConstant('Percent') + '</option>', 'id': element.id + '_measure_type_cell'
        });
        var labeltext = createElement('label', {
            innerHTML: localValue.getConstant('Measure in'),
            styles: 'font-size: 11px;font-weight: normal;display:block;margin-bottom:8px'
        });
        sizeDiv.appendChild(div);
        element.appendChild(sizeDiv);
        childdiv1.appendChild(preferredCellWidthCheckBox);
        parentdiv.appendChild(childdiv1);
        childdiv2.appendChild(this.preferredCellWidth);
        parentdiv.appendChild(childdiv2);
        controlDiv.appendChild(cellWidthType);
        child3.appendChild(labeltext);
        child4.appendChild(controlDiv);
        child2.appendChild(child3);
        child2.appendChild(child4);
        parentdiv.appendChild(child2);
        element.appendChild(parentdiv);
        var alignmentDiv = createElement('div', {
            innerHTML: localValue.getConstant('Vertical alignment'),
            styles: 'width: 100%;margin: 0px;',
            className: 'e-de-table-dialog-options-label'
        });
        var classDivName = element.id + 'e-de-table-cell-alignment';
        var divAlignment = createElement('div', {
            styles: 'width: 100%;height: 100px;'
        });
        var divStyle = 'width:54px;height:54px;margin:2px;border-style:solid;border-width:1px';
        var topAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        this.cellTopAlign = createElement('div', {
            styles: divStyle, id: element.id + '_cell_top-alignment',
            className: 'e-icons e-de-tablecell-alignment  e-de-tablecell-top-alignment ' + classDivName
        });
        topAlignDiv.appendChild(this.cellTopAlign);
        var centerAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        this.cellCenterAlign = createElement('div', {
            styles: divStyle, id: element.id + '_cell_center-alignment',
            className: 'e-icons e-de-tablecell-alignment  e-de-tablecell-center-alignment ' + classDivName
        });
        centerAlignDiv.appendChild(this.cellCenterAlign);
        var bottomAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        this.cellBottomAlign = createElement('div', {
            styles: divStyle, id: element.id + '_cell_bottom-alignment',
            className: 'e-icons e-de-tablecell-alignment e-de-tablecell-bottom-alignment  ' + classDivName
        });
        bottomAlignDiv.appendChild(this.cellBottomAlign);
        var topLabel = createElement('label', {
            innerHTML: localValue.getConstant('Top'), className: 'e-de-table-dia-align-label'
        });
        var centerLabel = createElement('label', {
            innerHTML: localValue.getConstant('Center'), className: 'e-de-table-dia-align-label'
        });
        var bottomLabel = createElement('label', {
            innerHTML: localValue.getConstant('Bottom'), className: 'e-de-table-dia-align-label'
        });
        this.cellOptionButton = createElement('button', {
            innerHTML: localValue.getConstant('Options'), id: element.id + '_table_cellmargin',
            className: 'e-control e-btn e-flat', attrs: { type: 'button' }
        });
        this.cellOptionButton.style.cssFloat = isRtl ? 'left' : 'right';
        divAlignment.appendChild(topAlignDiv);
        divAlignment.appendChild(centerAlignDiv);
        divAlignment.appendChild(bottomAlignDiv);
        topAlignDiv.appendChild(topLabel);
        centerAlignDiv.appendChild(centerLabel);
        bottomAlignDiv.appendChild(bottomLabel);
        element.appendChild(alignmentDiv);
        element.appendChild(divAlignment);
        element.appendChild(this.cellOptionButton);
        this.cellOptionButton.addEventListener('click', this.showCellOptionsDialog);
        this.cellWidthBox = new NumericTextBox({
            value: 0, decimals: 2, min: 0, max: 1584, width: 120, enablePersistence: false
        });
        this.cellWidthBox.appendTo(this.preferredCellWidth);
        this.preferredCellWidthCheckBox = new CheckBox({ label: localValue.getConstant('Preferred Width'), enableRtl: isRtl });
        this.preferredCellWidthCheckBox.appendTo(preferredCellWidthCheckBox);
        this.cellWidthType = new DropDownList({ width: '120px', enableRtl: isRtl });
        this.cellWidthType.appendTo(cellWidthType);
        if (isRtl) {
            childdiv2.classList.add('e-de-rtl');
            child3.classList.add('e-de-rtl');
            child4.classList.add('e-de-rtl');
            this.cellOptionButton.classList.add('e-de-rtl');
            topAlignDiv.classList.add('e-de-rtl');
            centerAlignDiv.classList.add('e-de-rtl');
            bottomAlignDiv.classList.add('e-de-rtl');
        }
    };
    TablePropertiesDialog.prototype.setTableCellProperties = function () {
        var cellFormat = this.owner.selection.cellFormat;
        //instance of table cell Values
        this.hasCellWidth = cellFormat.preferredWidth > 0;
        var preferredWidth = cellFormat.preferredWidth;
        if (isNullOrUndefined(cellFormat.preferredWidth)) {
            this.preferredCellWidthCheckBox.indeterminate = true;
            preferredWidth = this.owner.selection.start.paragraph.associatedCell.cellFormat.preferredWidth;
        }
        else {
            this.preferredCellWidthCheckBox.checked = this.hasCellWidth;
        }
        this.cellWidthBox.enabled = this.hasCellWidth;
        this.cellWidthType.enabled = this.hasCellWidth;
        if (cellFormat.preferredWidthType === 'Auto' || cellFormat.preferredWidthType === 'Point') {
            this.cellWidthType.index = 0;
        }
        else {
            this.cellWidthType.index = 1;
        }
        this.formatNumericTextBox(this.cellWidthBox, cellFormat.preferredWidthType, preferredWidth);
        classList(this.cellTopAlign, ['e-de-tablecell-alignment'], ['e-de-table-alignment-active']);
        classList(this.cellCenterAlign, ['e-de-tablecell-alignment'], ['e-de-table-alignment-active']);
        classList(this.cellBottomAlign, ['e-de-tablecell-alignment'], ['e-de-table-alignment-active']);
        if (cellFormat.verticalAlignment === 'Top') {
            this.cellTopAlign.classList.add('e-de-table-alignment-active');
        }
        else if (cellFormat.verticalAlignment === 'Center') {
            this.cellCenterAlign.classList.add('e-de-table-alignment-active');
        }
        else if (cellFormat.verticalAlignment === 'Bottom') {
            this.cellBottomAlign.classList.add('e-de-table-alignment-active');
        }
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.updateClassForCellAlignment = function (element) {
        var cellAlignments = element.getElementsByClassName(element.id + 'e-de-table-cell-alignment');
        for (var j = 0; j < cellAlignments.length; j++) {
            var cellAlignment = cellAlignments[j];
            if (cellAlignment.classList.contains('e-de-table-alignment-active')) {
                classList(cellAlignment, ['e-de-tablecell-alignment'], ['e-de-table-alignment-active']);
            }
        }
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.formatNumericTextBox = function (textBox, format, value) {
        if (format === 'Auto' || format === 'Point') {
            textBox.format = 'n2';
        }
        else {
            textBox.format = '#\'\%\'';
        }
        textBox.step = 1;
        textBox.decimals = 2;
        textBox.value = value;
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.getCellAlignment = function () {
        var id = this.cellTab.id;
        var groupButtons = this.cellTab.getElementsByClassName(id + 'e-de-table-cell-alignment');
        for (var j = 0; j < groupButtons.length; j++) {
            var groupButton = groupButtons[j];
            if (groupButton.classList.contains('e-de-table-alignment-active')) {
                if (j === 0) {
                    return 'Top';
                }
                else if (j === 1) {
                    return 'Center';
                }
                else {
                    return 'Bottom';
                }
            }
        }
        return this.owner.selection.cellFormat.verticalAlignment;
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.onCellWidthChange = function () {
        this.cellFormat.preferredWidth = this.cellWidthBox.value;
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.onCellWidthTypeChange = function () {
        var value;
        var table = this.owner.selection.start.paragraph.associatedCell.ownerTable;
        var containerWidth = table.getOwnerWidth(true);
        var tableWidth = table.getTableClientWidth(containerWidth);
        if (this.cellWidthType.text === 'Percent' && this.owner.selection.cellFormat.preferredWidthType !== 'Percent') {
            value = this.cellWidthBox.value / tableWidth * 100;
            this.formatNumericTextBox(this.cellWidthBox, 'Percent', value);
        }
        else if (this.cellWidthType.text === 'Points' && this.owner.selection.cellFormat.preferredWidthType !== 'Point') {
            value = tableWidth / 100 * this.cellWidthBox.value;
            this.formatNumericTextBox(this.cellWidthBox, 'Point', value);
        }
        else {
            if (this.cellWidthBox.format === '#\'\%\'') {
                if (this.cellWidthType.text === 'Points') {
                    value = tableWidth / 100 * this.cellWidthBox.value;
                }
                else {
                    value = this.cellWidthBox.value;
                }
            }
            else {
                if (this.cellWidthType.text === 'Percent') {
                    value = this.cellWidthBox.value / tableWidth * 100;
                }
                else {
                    value = this.cellWidthBox.value;
                }
            }
            // tslint:disable-next-line:max-line-length
            this.formatNumericTextBox(this.cellWidthBox, (this.cellWidthType.text === 'Points') ? 'Point' : this.cellWidthType.text, value);
        }
        this.cellFormat.preferredWidthType = (this.cellWidthType.text === 'Points') ? 'Point' : this.cellWidthType.text;
    };
    /**
     * @private
     */
    TablePropertiesDialog.prototype.destroy = function () {
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (var s = 0; s < this.target.childNodes.length; s++) {
                this.target.removeChild(this.target.childNodes[s]);
                s--;
            }
            this.target = undefined;
        }
        this.dialog = undefined;
        this.target = undefined;
        this.cellAlignment = undefined;
        this.tableAlignment = undefined;
        this.owner = undefined;
        this.preferCheckBox = undefined;
        this.tableWidthType = undefined;
        this.preferredWidth = undefined;
        this.rowHeightType = undefined;
        this.rowHeightCheckBox = undefined;
        this.rowHeight = undefined;
        this.cellWidthType = undefined;
        this.preferredCellWidthCheckBox = undefined;
        this.preferredCellWidth = undefined;
        this.tableTab = undefined;
        this.rowTab = undefined;
        this.cellTab = undefined;
        this.left = undefined;
        this.center = undefined;
        this.right = undefined;
        this.leftIndent = undefined;
        this.allowRowBreak = undefined;
        this.repeatHeader = undefined;
        this.cellTopAlign = undefined;
        this.cellCenterAlign = undefined;
        this.cellBottomAlign = undefined;
        this.tableFormat.destroy();
        this.cellFormat.destroy();
        this.tableFormat = undefined;
        this.cellFormat = undefined;
    };
    return TablePropertiesDialog;
}());

/**
 * The Borders and Shading dialog is used to modify borders and shading options for selected table or cells.
 */
var BordersAndShadingDialog = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function BordersAndShadingDialog(viewer) {
        var _this = this;
        this.cellFormat = new WCellFormat();
        this.tableFormat = new WTableFormat();
        this.isShadingChanged = false;
        this.applyBordersShadingsProperties = function () {
            var tablePropertiesDialog = _this.owner.owner.tablePropertiesDialogModule;
            var selectedCell = _this.owner.selection.start.paragraph.associatedCell;
            //Need to bind the properties with current cell and current table formats.
            var borders = undefined;
            if (_this.checkClassName(_this.previewDivTopTop) || _this.checkClassName(_this.previewDivTopBottom)
                || _this.checkClassName(_this.previewDivTopCenter) || _this.checkClassName(_this.previewDivBottomcenter)
                || _this.checkClassName(_this.previewDivBottomLeft) || _this.checkClassName(_this.previewDivBottomRight)
                || _this.checkClassName(_this.previewDivDiagonalRight) || _this.checkClassName(_this.previewDivLeftDiagonal)) {
                borders = new WBorders();
                if (_this.checkClassName(_this.previewDivTopTop)) {
                    borders.top = _this.getBorder();
                }
                if (_this.checkClassName(_this.previewDivTopBottom)) {
                    borders.bottom = _this.getBorder();
                }
                if (_this.checkClassName(_this.previewDivBottomLeft)) {
                    borders.left = _this.getBorder();
                }
                if (_this.checkClassName(_this.previewDivBottomRight)) {
                    borders.right = _this.getBorder();
                }
                if (_this.checkClassName(_this.previewDivTopCenter)) {
                    borders.horizontal = _this.getBorder();
                }
                if (_this.checkClassName(_this.previewDivBottomcenter)) {
                    borders.vertical = _this.getBorder();
                }
                if (_this.checkClassName(_this.previewDivLeftDiagonal)) {
                    borders.diagonalDown = _this.getBorder();
                }
                if (_this.checkClassName(_this.previewDivDiagonalRight)) {
                    borders.diagonalUp = _this.getBorder();
                }
            }
            var shading = new WShading();
            var editorModule = _this.owner.owner.editorModule;
            shading.backgroundColor = _this.shadingColorPicker.value;
            if (_this.ulelementShading.index === 0) {
                _this.applyTo = 0;
                if (tablePropertiesDialog) {
                    tablePropertiesDialog.isCellBordersAndShadingUpdated = true;
                }
                _this.cellFormat.borders = new WBorders();
                if (!isNullOrUndefined(borders)) {
                    editorModule.applyBordersInternal(_this.cellFormat.borders, borders);
                }
                else if (_this.noneDiv.classList.contains('e-de-table-border-inside-setting-click')) {
                    editorModule.applyBordersInternal(_this.cellFormat.borders, new WBorders());
                }
                // Once option has been added for texture and foreground, need to handle this similar to Shading Fill.
                if (!isNullOrUndefined(selectedCell.cellFormat.shading)) {
                    shading.foregroundColor = selectedCell.cellFormat.shading.foregroundColor;
                    shading.textureStyle = selectedCell.cellFormat.shading.textureStyle;
                }
                _this.cellFormat.shading = new WShading();
                editorModule.applyShading(_this.cellFormat.shading, shading);
            }
            else {
                if (tablePropertiesDialog) {
                    tablePropertiesDialog.isTableBordersAndShadingUpdated = true;
                }
                _this.applyTo = 1;
                var currentTableFormat = _this.owner.owner.selection.tableFormat.table.tableFormat;
                _this.tableFormat.copyFormat(currentTableFormat);
                _this.tableFormat.borders = new WBorders();
                if (!isNullOrUndefined(borders)) {
                    editorModule.applyBordersInternal(_this.tableFormat.borders, borders);
                }
                else if (_this.noneDiv.classList.contains('e-de-table-border-inside-setting-click')) {
                    editorModule.applyBordersInternal(_this.tableFormat.borders, new WBorders());
                }
                // Once option has been added for texture and foreground, need to handle this similar to Shading Fill.
                if (!isNullOrUndefined(currentTableFormat.shading)) {
                    shading.foregroundColor = currentTableFormat.shading.foregroundColor;
                    shading.textureStyle = currentTableFormat.shading.textureStyle;
                }
                _this.tableFormat.shading = new WShading();
                _this.isShadingChanged = currentTableFormat.shading.backgroundColor !== shading.backgroundColor;
                editorModule.applyShading(_this.tableFormat.shading, shading);
            }
            _this.applyFormat();
            _this.closeDialog();
        };
        /**
         * @private
         */
        this.closeDialog = function () {
            _this.owner.dialog.hide();
            _this.closeBordersShadingsDialog();
        };
        this.closeBordersShadingsDialog = function () {
            _this.owner.dialog2.element.style.pointerEvents = '';
            _this.owner.updateFocus();
        };
        this.handleSettingCheckBoxAction = function (event) {
            var targetId = event.target.id;
            var tableBorderDialogId = _this.target.id;
            if (targetId === tableBorderDialogId + '_None_Div' || targetId === tableBorderDialogId + '_None_Div_Container'
                || targetId === tableBorderDialogId + '_None_Div_Transparent') {
                _this.updateClassForSettingDivElements();
                _this.noneDiv.classList.add('e-de-table-border-inside-setting-click');
                _this.setSettingPreviewDivElement('none');
            }
            else if (targetId === tableBorderDialogId + '_Box_Div' || targetId === tableBorderDialogId + '_Box_Div_Container'
                || targetId === tableBorderDialogId + '_Box_Div_Transparent') {
                _this.updateClassForSettingDivElements();
                _this.boxDiv.classList.add('e-de-table-border-inside-setting-click');
                _this.setSettingPreviewDivElement('box');
            }
            else if (targetId === tableBorderDialogId + '_All_Div' || targetId === tableBorderDialogId + '_All_Div_Container'
                || targetId === tableBorderDialogId + '_All_Div_Transparent') {
                _this.updateClassForSettingDivElements();
                _this.allDiv.classList.add('e-de-table-border-inside-setting-click');
                _this.setSettingPreviewDivElement('all');
            }
            else {
                _this.updateClassForSettingDivElements();
                _this.customDiv.classList.add('e-de-table-border-inside-setting-click');
                _this.setSettingPreviewDivElement('customDiv');
            }
        };
        this.handlePreviewCheckBoxAction = function (event) {
            var target = event.target;
            var targetId = target.id;
            var tableBorderDialog = _this.target;
            var tableBorderDialogId = _this.target.id;
            var compareClass = 'e-de-table-border-inside-preview-click';
            _this.customDiv.click();
            if (targetId === tableBorderDialogId + '_Preview_Div_TopTop_Container' || targetId === tableBorderDialogId + '_Preview_Div_TopTop'
                || targetId === tableBorderDialogId + '_previewDivTopTopTransParent') {
                _this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, _this.previewDivTopTop);
                _this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div', '_Preview_Div_TopTop', 'TopTop');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_TopCenter_Container'
                || targetId === tableBorderDialogId + '_Preview_Div_TopCenter'
                || targetId === tableBorderDialogId + '_previewDivTopCenterTransParent') {
                _this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, _this.previewDivTopCenter);
                // tslint:disable-next-line:max-line-length
                _this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div_Horizontal', '_Preview_Div_TopCenter', 'TopCenter');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_TopBottom_Container' || targetId === tableBorderDialogId + '_Preview_Div_TopBottom'
                || targetId === tableBorderDialogId + '_previewDivTopBottomTransParent') {
                _this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, _this.previewDivTopBottom);
                _this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div', '_Preview_Div_TopBottom', 'TopBottom');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_LeftDiagonal_Container'
                || targetId === tableBorderDialogId + '_Preview_Div_LeftDiagonal'
                || targetId === tableBorderDialogId + '_previewDivLeftDiagonalTransParent') {
                _this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, _this.previewDivLeftDiagonal);
                // tslint:disable-next-line:max-line-length
                _this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div_Left_Diagonal', '_Preview_Div_LeftDiagonal', 'LeftDiagonal');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_BottomLeft_Container' || targetId === tableBorderDialogId + '_Preview_Div_BottomLeft'
                || targetId === tableBorderDialogId + '_previewDivBottomLeftTransparent') {
                _this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, _this.previewDivBottomLeft);
                _this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div', '_Preview_Div_BottomLeft', 'BottomLeft');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_BottomCenter_Container'
                || targetId === tableBorderDialogId + '_Preview_Div_BottomCenter'
                || targetId === tableBorderDialogId + '_previewDivBottomcenterTransparent') {
                _this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, _this.previewDivBottomcenter);
                // tslint:disable-next-line:max-line-length
                _this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div_Vertical', '_Preview_Div_BottomCenter', 'BottomCenter');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_BottomRight_Container' || targetId === tableBorderDialogId + '_Preview_Div_BottomRight'
                || targetId === tableBorderDialogId + '_previewDivBottomRightTransparent') {
                _this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, _this.previewDivBottomRight);
                _this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div', '_Preview_Div_BottomRight', 'BottomRight');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_RightDiagonal_Container'
                || targetId === tableBorderDialogId + '_Preview_Div_RightDiagonal'
                || targetId === tableBorderDialogId + '_previewDivDiagonalRightTransparent') {
                _this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, _this.previewDivDiagonalRight);
                // tslint:disable-next-line:max-line-length
                _this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div_Right_Diagonal', '_Preview_Div_RightDiagonal', 'RightDiagonal');
            }
        };
        this.applyTableCellPreviewBoxes = function () {
            _this.customDiv.click();
            if (!isNullOrUndefined(_this.ulelementShading)) {
                if (_this.ulelementShading.index === 0) {
                    _this.previewDivBottomcenterContainer.style.display = 'none';
                    _this.previewDivTopCenterContainer.style.display = 'none';
                    _this.previewVerticalDiv.style.display = 'none';
                    _this.previewHorizontalDiv.style.display = 'none';
                    _this.previewDivLeftDiagonal.style.display = '';
                    _this.previewDivDiagonalRight.style.display = '';
                    _this.previewDivBottomRightContainer.style.left = '80px';
                }
                else {
                    _this.previewDivLeftDiagonal.style.display = 'none';
                    _this.previewDivDiagonalRight.style.display = 'none';
                    _this.previewDivBottomcenterContainer.style.display = '';
                    _this.previewDivTopCenterContainer.style.display = '';
                    _this.previewVerticalDiv.style.display = '';
                    _this.previewHorizontalDiv.style.display = '';
                    _this.previewDivBottomRightContainer.style.left = '110px';
                }
            }
        };
        this.applyPreviewTableBackgroundColor = function (args) {
            if (!isNullOrUndefined(args.currentValue)) {
                var color = args.currentValue.hex;
                _this.previewDiv.style.backgroundColor = color;
            }
        };
        this.applyPreviewTableBorderColor = function (args) {
            if (!isNullOrUndefined(args.currentValue)) {
                var color = args.currentValue.hex;
                _this.previewDiv.style.borderColor = color;
                _this.previewRightDiagonalDiv.style.backgroundColor = color;
                _this.previewLeftDiagonalDiv.style.backgroundColor = color;
                _this.previewVerticalDiv.style.backgroundColor = color;
                _this.previewHorizontalDiv.style.backgroundColor = color;
            }
        };
        this.owner = viewer;
    }
    BordersAndShadingDialog.prototype.getModuleName = function () {
        return 'BordersAndShadingDialog';
    };
    /**
     * @private
     */
    // tslint:disable-next-line:max-func-body-length
    BordersAndShadingDialog.prototype.initBordersAndShadingsDialog = function (localeValue, isRtl) {
        var instance = this;
        this.target = createElement('div', {
            id: instance.owner.owner.containerId + '_table_border_shadings',
            className: 'e-de-table-border-shading-dlg'
        });
        var displayText = createElement('div', {
            innerHTML: localeValue.getConstant('Borders'), styles: 'position: absolute;top: 65px;',
            id: this.target.id + '_border_label', className: 'e-de-table-border-heading'
        });
        var settingsContiner = createElement('div', {
            styles: 'display: inline-block;position: absolute;top: 105px;width: 100px;height: 235px;border-style: none;',
            id: this.target.id + '_border_settings'
        });
        var styleContainerPosition;
        if (isRtl) {
            styleContainerPosition = 'left: 148px;';
        }
        else {
            styleContainerPosition = 'left: 125px;';
        }
        var styleContainer = createElement('div', {
            // tslint:disable-next-line:max-line-length
            styles: 'display: inline-block;position: absolute;' + styleContainerPosition + 'top: 125px;width: 150px;height: 235px;padding-left: 40px;border-style: none;padding-right: 40px;',
            id: this.target.id + '_border_style'
        });
        var previewContinerPosition;
        if (isRtl) {
            previewContinerPosition = 'right: 342px;';
        }
        else {
            previewContinerPosition = 'left: 339px;';
        }
        var previewContiner = createElement('div', {
            // tslint:disable-next-line:max-line-length
            styles: 'display: inline-block;position: absolute;' + previewContinerPosition + 'top: 87px;width: 180px;height: 235px;padding: 0px;border-style: none;',
            id: this.target.id + '_border_preview'
        });
        var styleText = createElement('div', {
            innerHTML: localeValue.getConstant('Style'), styles: 'width: 100%;padding-bottom: 10px;',
            className: 'e-de-table-element-subheading'
        });
        var dropDownList = createElement('select', {
            id: this.target.id + '_border_style_dropDown'
        });
        dropDownList.innerHTML = '<option>' + 'None' + '</option><option>'
            + 'Single' + '</option><option>' + 'Dot' + '</option><option>'
            + 'DashSmallGap' + '</option><option>' + 'DashLargeGap' + '</option><option>'
            + 'DashDot' + '</option><option>' + 'DashDotDot' + '</option><option>'
            + 'Double' + '</option><option>' + 'Triple' + '</option><option>'
            + 'ThinThickSmallGap' + '</option><option>'
            + 'ThickThinSmallGap' + '</option><option>' + 'ThinThickThinSmallGap'
            + '</option><option>' + 'ThinThickMediumGap' + '</option><option>'
            + 'ThickThinMediumGap' + '</option><option>' + 'ThinThickThinMediumGap'
            + '</option><option>' + 'ThinThickLargeGap' + '</option><option>'
            + 'ThickThinLargeGap' + '</option><option>' + 'ThinThickThinLargeGap'
            + '</option><option>' + 'SingleWavy' + '</option><option>'
            + 'DoubleWavy' + '</option><option>' + 'DashDotStroked'
            + '</option><option>' + 'Emboss3D' + '</option><option>' + 'Engrave3D'
            + '</option><option>' + 'Outset' + '</option><option>'
            + 'Inset' + '</option><option>' + 'Thick' + '</option>';
        var widthText = createElement('div', {
            innerHTML: localeValue.getConstant('Width'), styles: 'width:100%;padding-top: 20px;padding-bottom: 10px;',
            className: 'e-de-table-element-subheading'
        });
        var widthNumeric = createElement('input', {
            id: this.target.id + '_width'
        });
        var colorText = createElement('div', {
            innerHTML: localeValue.getConstant('Color'), styles: 'padding-top: 25px;',
            className: 'e-de-table-setting-heading'
        });
        var borderColorPickerElement = createElement('input', {
            attrs: { 'type': 'color' },
            id: this.target.id + '_border_color',
            styles: 'width: 30px;position: absolute;left: 90px;',
            className: 'e-dlg-clr-pkr-top'
        });
        var settingText = createElement('div', {
            innerHTML: localeValue.getConstant('Setting'), styles: 'width: 100%;position: absolute;',
            className: 'e-de-table-setting-heading'
        });
        var noneDivContainer = createElement('div', {
            id: this.target.id + '_None_Div_Container', className: 'e-de-table-border-none'
        });
        var divLabelPadding;
        if (isRtl) {
            divLabelPadding = 'padding-right:10px;';
        }
        else {
            divLabelPadding = 'padding-left:10px;';
        }
        this.noneDiv = createElement('div', {
            id: this.target.id + '_None_Div',
            className: 'e-de-table-border-inside-setting e-de-table-border-setting-genral'
        });
        var noneDivLabel = createElement('label', {
            innerHTML: localeValue.getConstant('None'), className: 'e-de-table-setting-labels-heading',
            styles: divLabelPadding + 'top: 20px;position: absolute;',
            id: this.target.id + '_None_Div_Label'
        });
        var boxDivContainer = createElement('div', {
            id: this.target.id + '_Box_Div_Container', className: 'e-de-table-border-box'
        });
        this.boxDiv = createElement('div', {
            id: this.target.id + '_Box_Div',
            className: 'e-de-table-border-inside-setting e-de-table-border-setting-genral'
        });
        var boxDivLabel = createElement('label', {
            innerHTML: localeValue.getConstant('Box'), className: 'e-de-table-setting-labels-heading',
            styles: divLabelPadding + 'top: 20px;position: absolute;',
            id: this.target.id + '_Box_Div_Label'
        });
        var allDivContainer = createElement('div', {
            id: this.target.id + '_All_Div_Container', className: 'e-de-table-border-all'
        });
        this.allDiv = createElement('div', {
            id: this.target.id + '_All_Div',
            className: 'e-de-table-border-inside-setting e-de-table-border-setting-genral'
        });
        var allDivLabel = createElement('label', {
            innerHTML: localeValue.getConstant('All'), className: 'e-de-table-setting-labels-heading',
            styles: divLabelPadding + 'top: 25px;position: absolute;',
            id: this.target.id + '_All_Div_Label'
        });
        var customDivContainer = createElement('div', {
            id: this.target.id + '_Custom_Div_Container', className: 'e-de-table-border-custom'
        });
        this.customDiv = createElement('div', {
            id: this.target.id + '_Custom_Div',
            className: 'e-de-table-border-inside-setting e-de-table-border-setting-genral'
        });
        var customDivLabel = createElement('label', {
            innerHTML: localeValue.getConstant('Custom'), className: 'e-de-table-setting-labels-heading',
            styles: divLabelPadding + 'top: 25px;position: absolute;',
            id: this.target.id + '_Custom_Div_Label'
        });
        this.noneDivTransparent = createElement('div', {
            id: this.target.id + '_None_Div_Transparent', className: 'e-icons e-de-table-border-setting e-de-table-border-none-setting'
        });
        this.boxDivTransparent = createElement('div', {
            id: this.target.id + '_Box_Div_Transparent', className: 'e-icons e-de-table-border-setting e-de-table-border-box-setting'
        });
        this.allDivTransparent = createElement('div', {
            id: this.target.id + '_All_Div_Transparent', className: 'e-icons e-de-table-border-setting e-de-table-border-all-setting'
        });
        this.customDivTransparent = createElement('div', {
            id: this.target.id + '_Custom_Div_Transparent', className: 'e-icons e-de-table-border-setting e-de-table-border-custom-setting'
        });
        if (isRtl) {
            this.noneDivTransparent.classList.add('e-de-rtl');
            this.boxDivTransparent.classList.add('e-de-rtl');
            this.allDivTransparent.classList.add('e-de-rtl');
            this.customDivTransparent.classList.add('e-de-rtl');
        }
        var previewTextPosition;
        if (isRtl) {
            previewTextPosition = 'margin-right: 10px;';
        }
        else {
            previewTextPosition = 'margin-left: 10px;';
        }
        var previewText = createElement('div', {
            innerHTML: localeValue.getConstant('Preview'), className: 'e-de-table-setting-heading',
            styles: 'position: absolute;top: 20px;' + previewTextPosition
        });
        this.previewDiv = createElement('div', {
            styles: 'width: 80px;height: 80px;position: absolute; left: 50px;top: 50px;',
            id: this.target.id + '_Preview_Div', className: 'e-de-border-dlg-preview-div'
        });
        this.previewRightDiagonalDiv = createElement('div', {
            styles: 'position: absolute;width:1px;height:113px;left: 90px;top: 34px;transform: rotate(135deg);',
            id: this.target.id + '_Preview_Div_Right_Diagonal',
            className: 'e-de-border-dlg-preview-inside-divs'
        });
        this.previewLeftDiagonalDiv = createElement('div', {
            styles: 'position: absolute;width: 1px;height: 113px;left: 90px;top: 34px;transform:rotate(45deg);',
            id: this.target.id + '_Preview_Div_Left_Diagonal',
            className: 'e-de-border-dlg-preview-inside-divs'
        });
        this.previewVerticalDiv = createElement('div', {
            styles: 'width: 1px;height: 81px;position: absolute;left: 90px;top: 50px;',
            id: this.target.id + '_Preview_Div_Vertical',
            className: 'e-de-border-dlg-preview-inside-divs'
        });
        this.previewHorizontalDiv = createElement('div', {
            styles: 'width: 81px;height: 1px;position: absolute;left: 50px;top: 90px;',
            id: this.target.id + '_Preview_Div_Horizontal',
            className: 'e-de-border-dlg-preview-inside-divs'
        });
        var previewDivTopPosition;
        if (isRtl) {
            previewDivTopPosition = 'right: 10px;';
        }
        else {
            previewDivTopPosition = 'left: 10px;';
        }
        this.previewDivTopTopContainer = createElement('div', {
            styles: 'top: 50px;position: absolute;' + previewDivTopPosition, id: this.target.id + '_Preview_Div_TopTop_Container'
        });
        this.previewDivTopTop = createElement('div', {
            id: this.target.id + '_Preview_Div_TopTop',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivTopCenterContainer = createElement('div', {
            styles: 'top: 80px;position: absolute;' + previewDivTopPosition, id: this.target.id + '_Preview_Div_TopCenter_Container'
        });
        this.previewDivTopCenter = createElement('div', {
            id: this.target.id + '_Preview_Div_TopCenter',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivTopBottomContainer = createElement('div', {
            styles: 'top: 110px;position: absolute;' + previewDivTopPosition, id: this.target.id + '_Preview_Div_TopBottom_Container'
        });
        this.previewDivTopBottom = createElement('div', {
            id: this.target.id + '_Preview_Div_TopBottom',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivLeftDiagonalContainer = createElement('div', {
            styles: 'top: 145px;position: absolute;left: 10px;', id: this.target.id + '_Preview_Div_LeftDiagonal_Container'
        });
        this.previewDivLeftDiagonal = createElement('div', {
            id: this.target.id + '_Preview_Div_LeftDiagonal',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        var previewDivBottomLeftPosition;
        var previewDivBottomCenterPosition;
        var previewDivBottomRightPosition;
        if (isRtl) {
            previewDivBottomLeftPosition = 'left: 104px';
            previewDivBottomCenterPosition = 'left: 74px';
            previewDivBottomRightPosition = 'left: 44px';
        }
        else {
            previewDivBottomLeftPosition = 'left: 50px;';
            previewDivBottomCenterPosition = 'left : 80px;';
            previewDivBottomRightPosition = 'left : 110px';
        }
        this.previewDivBottomLeftContainer = createElement('div', {
            styles: 'top: 145px;position: absolute;' + previewDivBottomLeftPosition,
            id: this.target.id + '_Preview_Div_BottomLeft_Container'
        });
        this.previewDivBottomLeft = createElement('div', {
            id: this.target.id + '_Preview_Div_BottomLeft',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivBottomcenterContainer = createElement('div', {
            styles: 'top: 145px;position: absolute;' + previewDivBottomCenterPosition,
            id: this.target.id + '_Preview_Div_BottomCenter_Container'
        });
        this.previewDivBottomcenter = createElement('div', {
            id: this.target.id + '_Preview_Div_BottomCenter',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivBottomRightContainer = createElement('div', {
            styles: 'top: 145px;position: absolute;' + previewDivBottomRightPosition,
            id: this.target.id + '_Preview_Div_BottomRight_Container'
        });
        this.previewDivBottomRight = createElement('div', {
            id: this.target.id + '_Preview_Div_BottomRight',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivDiagonalRightContainer = createElement('div', {
            styles: 'top: 145px; position: absolute; left: 110px;', id: this.target.id + '_Preview_Div_RightDiagonal_Container'
        });
        this.previewDivDiagonalRight = createElement('div', {
            id: this.target.id + '_Preview_Div_RightDiagonal',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivTopTopTransParent = createElement('div', {
            id: this.target.id + '_previewDivTopTopTransParent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-toptop-alignment'
        });
        this.previewDivTopCenterTransParent = createElement('div', {
            id: this.target.id + '_previewDivTopCenterTransParent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-topcenter-alignment'
        });
        this.previewDivTopBottomTransParent = createElement('div', {
            id: this.target.id + '_previewDivTopBottomTransParent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-topbottom-alignment'
        });
        this.previewDivLeftDiagonalTransParent = createElement('div', {
            id: this.target.id + '_previewDivLeftDiagonalTransParent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-diagionalup-alignment'
        });
        this.previewDivBottomLeftTransparent = createElement('div', {
            id: this.target.id + '_previewDivBottomLeftTransparent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-bottomleft-alignment'
        });
        this.previewDivBottomcenterTransparent = createElement('div', {
            id: this.target.id + '_previewDivBottomcenterTransparent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-bottomcenter-alignment'
        });
        this.previewDivBottomRightTransparent = createElement('div', {
            id: this.target.id + '_previewDivBottomRightTransparent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-bottomright-alignment'
        });
        this.previewDivDiagonalRightTransparent = createElement('div', {
            id: this.target.id + '_previewDivDiagonalRightTransparent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-diagionaldown-alignment'
        });
        var shadingContainerPosition;
        if (isRtl) {
            shadingContainerPosition = 'left:60px;';
        }
        else {
            shadingContainerPosition = 'left:17px;';
        }
        this.shadingContiner = createElement('div', {
            /* tslint:disable:max-line-length */
            styles: 'display:inline-block;position:absolute;' + shadingContainerPosition + ';width:400px;height:100px;padding:0px;border-style: none;margin-left:10px;',
            id: this.target.id + '_shading_preview', className: 'e-de-table-shading-preview'
        });
        var shadingText = createElement('div', {
            innerHTML: localeValue.getConstant('Shading'), className: 'e-de-table-border-heading',
            styles: 'padding-top: 30px;left: 5px;'
        });
        var shadings = createElement('div', { styles: 'display:flex;' });
        var label = createElement('div', {
            innerHTML: localeValue.getConstant('Fill'), className: 'e-de-table-setting-heading e-de-table-border-fill',
            styles: 'top: 50px;left: 10px;'
        });
        var shadingColorPickerElement = createElement('input', {
            attrs: { 'type': 'color' },
            id: this.target.id + '_shading_color', styles: 'position: absolute;top: 75px;left: 40px;width: 30px;'
        });
        var shdApplyPosition;
        if (isRtl) {
            shdApplyPosition = 'left: 75px;';
        }
        else {
            shdApplyPosition = 'left: 150px;';
        }
        var shdApply = createElement('div', {
            styles: 'position:absolute;top:44px;' + shdApplyPosition + 'width:180px;'
        });
        var div = createElement('div', {
            styles: 'width:100px;padding-bottom: 10px;', innerHTML: localeValue.getConstant('Apply To'),
            className: 'e-de-table-element-subheading'
        });
        var divsion = createElement('div', { styles: 'width:100px;position:absolute;' });
        var ulelementShading = createElement('select', {
            innerHTML: '<option>' + localeValue.getConstant('Cell') + '</option>'
                + '<option>' + localeValue.getConstant('Table') + '</option>',
            id: this.target.id + '_shading'
        });
        divsion.appendChild(ulelementShading);
        this.noneDiv.appendChild(this.noneDivTransparent);
        this.boxDiv.appendChild(this.boxDivTransparent);
        this.allDiv.appendChild(this.allDivTransparent);
        this.customDiv.appendChild(this.customDivTransparent);
        noneDivContainer.appendChild(this.noneDiv);
        noneDivContainer.appendChild(noneDivLabel);
        boxDivContainer.appendChild(this.boxDiv);
        boxDivContainer.appendChild(boxDivLabel);
        allDivContainer.appendChild(this.allDiv);
        allDivContainer.appendChild(allDivLabel);
        customDivContainer.appendChild(this.customDiv);
        customDivContainer.appendChild(customDivLabel);
        settingsContiner.appendChild(settingText);
        settingsContiner.appendChild(noneDivContainer);
        settingsContiner.appendChild(boxDivContainer);
        settingsContiner.appendChild(allDivContainer);
        settingsContiner.appendChild(customDivContainer);
        this.previewDivBottomcenter.appendChild(this.previewDivBottomcenterTransparent);
        this.previewDivBottomRight.appendChild(this.previewDivBottomRightTransparent);
        this.previewDivBottomLeft.appendChild(this.previewDivBottomLeftTransparent);
        this.previewDivTopTop.appendChild(this.previewDivTopTopTransParent);
        this.previewDivTopCenter.appendChild(this.previewDivTopCenterTransParent);
        this.previewDivTopBottom.appendChild(this.previewDivTopBottomTransParent);
        this.previewDivDiagonalRight.appendChild(this.previewDivDiagonalRightTransparent);
        this.previewDivLeftDiagonal.appendChild(this.previewDivLeftDiagonalTransParent);
        this.previewDivBottomcenterContainer.appendChild(this.previewDivBottomcenter);
        this.previewDivBottomLeftContainer.appendChild(this.previewDivBottomLeft);
        this.previewDivBottomRightContainer.appendChild(this.previewDivBottomRight);
        this.previewDivDiagonalRightContainer.appendChild(this.previewDivDiagonalRight);
        this.previewDivLeftDiagonalContainer.appendChild(this.previewDivLeftDiagonal);
        this.previewDivTopBottomContainer.appendChild(this.previewDivTopBottom);
        this.previewDivTopCenterContainer.appendChild(this.previewDivTopCenter);
        this.previewDivTopTopContainer.appendChild(this.previewDivTopTop);
        previewContiner.appendChild(previewText);
        previewContiner.appendChild(this.previewDiv);
        previewContiner.appendChild(this.previewRightDiagonalDiv);
        previewContiner.appendChild(this.previewHorizontalDiv);
        previewContiner.appendChild(this.previewLeftDiagonalDiv);
        previewContiner.appendChild(this.previewVerticalDiv);
        previewContiner.appendChild(this.previewDivBottomcenterContainer);
        previewContiner.appendChild(this.previewDivBottomLeftContainer);
        previewContiner.appendChild(this.previewDivBottomRightContainer);
        previewContiner.appendChild(this.previewDivDiagonalRightContainer);
        previewContiner.appendChild(this.previewDivLeftDiagonalContainer);
        previewContiner.appendChild(this.previewDivTopBottomContainer);
        previewContiner.appendChild(this.previewDivTopCenterContainer);
        previewContiner.appendChild(this.previewDivTopTopContainer);
        shdApply.appendChild(div);
        shdApply.appendChild(divsion);
        shadings.appendChild(label);
        shadings.appendChild(shadingColorPickerElement);
        shadings.appendChild(shdApply);
        this.shadingContiner.appendChild(shadingText);
        this.shadingContiner.appendChild(shadings);
        styleContainer.appendChild(styleText);
        styleContainer.appendChild(dropDownList);
        styleContainer.appendChild(widthText);
        styleContainer.appendChild(widthNumeric);
        styleContainer.appendChild(colorText);
        styleContainer.appendChild(borderColorPickerElement);
        this.target.appendChild(displayText);
        this.target.appendChild(settingsContiner);
        this.target.appendChild(styleContainer);
        this.target.appendChild(previewContiner);
        this.target.appendChild(this.shadingContiner);
        // Handling Setting Container
        noneDivContainer.addEventListener('click', this.handleSettingCheckBoxAction);
        boxDivContainer.addEventListener('click', this.handleSettingCheckBoxAction);
        allDivContainer.addEventListener('click', this.handleSettingCheckBoxAction);
        customDivContainer.addEventListener('click', this.handleSettingCheckBoxAction);
        // Handling Preview Div Container
        this.previewDivBottomcenterContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivBottomLeftContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivBottomRightContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivTopTopContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivTopBottomContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivTopCenterContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivDiagonalRightContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivLeftDiagonalContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        // handling dropdown change
        this.borderWidth = new NumericTextBox({
            value: 0, min: 0, max: 6, decimals: 2,
            width: 150, enablePersistence: false
        });
        this.borderWidth.appendTo(widthNumeric);
        this.borderStyle = new DropDownList({
            width: '150px', popupHeight: '150px', index: 1,
            enableRtl: isRtl
        });
        this.borderStyle.appendTo(dropDownList);
        this.ulelementShading = new DropDownList({
            width: '150px', change: this.applyTableCellPreviewBoxes, index: 1,
            enableRtl: isRtl
        });
        this.ulelementShading.appendTo(ulelementShading);
        this.borderColorPicker = new ColorPicker({
            value: '#000000', change: this.applyPreviewTableBorderColor,
            enableRtl: isRtl, locale: this.owner.owner.locale, cssClass: 'e-de-dlg-clr-picker'
        });
        this.borderColorPicker.appendTo(borderColorPickerElement);
        this.shadingColorPicker = new ColorPicker({
            value: '#000000', change: this.applyPreviewTableBackgroundColor,
            enableRtl: isRtl, locale: this.owner.owner.locale, cssClass: 'e-de-dlg-clr-picker'
        });
        this.shadingColorPicker.appendTo(shadingColorPickerElement);
        if (isRtl) {
            label.classList.add('e-de-rtl');
        }
    };
    BordersAndShadingDialog.prototype.applyFormat = function () {
        var selection = this.owner.selection;
        var editorModule = this.owner.owner.editorModule;
        editorModule.initComplexHistory('BordersAndShading');
        editorModule.isBordersAndShadingDialog = true;
        if (this.applyTo === 0) {
            editorModule.onCellFormat(this.cellFormat);
        }
        else {
            editorModule.onTableFormat(this.tableFormat, this.isShadingChanged);
        }
        if (!isNullOrUndefined(this.owner.owner.editorHistory.currentHistoryInfo)) {
            this.owner.owner.editorHistory.updateComplexHistory();
        }
        editorModule.isBordersAndShadingDialog = false;
    };
    BordersAndShadingDialog.prototype.getBorder = function () {
        var border = new WBorder();
        border.color = this.borderColorPicker.value;
        border.lineStyle = this.borderStyle.text;
        border.lineWidth = this.borderWidth.value;
        return border;
    };
    BordersAndShadingDialog.prototype.checkClassName = function (element) {
        return element.classList.contains('e-de-table-border-inside-preview-click');
    };
    /**
     * @private
     */
    BordersAndShadingDialog.prototype.show = function () {
        var localeValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localeValue.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initBordersAndShadingsDialog(localeValue, this.owner.owner.enableRtl);
        }
        this.loadBordersShadingsPropertiesDialog();
        this.owner.dialog.content = this.target;
        this.owner.dialog.header = localeValue.getConstant('Borders and Shading');
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.close = this.closeBordersShadingsDialog;
        this.owner.dialog.position = { X: 'center', Y: 'center' };
        this.owner.dialog.width = 'auto';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.buttons = [{
                click: this.applyBordersShadingsProperties,
                buttonModel: { content: localeValue.getConstant('Ok'), cssClass: 'e-flat e-table-border-shading-okay', isPrimary: true }
            },
            {
                click: this.closeDialog,
                buttonModel: { content: localeValue.getConstant('Cancel'), cssClass: 'e-flat e-table-border-shading-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    };
    BordersAndShadingDialog.prototype.updateClassForSettingDivElements = function () {
        var settingDivs = this.target.getElementsByClassName('e-de-table-border-inside-setting');
        for (var j = 0; j < settingDivs.length; j++) {
            if (settingDivs[j].className.indexOf('e-de-table-border-inside-setting-click') !== -1) {
                var tempClassName = settingDivs[j].className;
                tempClassName = tempClassName.replace('e-de-table-border-inside-setting-click', '');
                settingDivs[j].className = tempClassName;
            }
        }
    };
    BordersAndShadingDialog.prototype.setSettingPreviewDivElement = function (position) {
        switch (position) {
            case 'none':
                this.previewDivTopTop.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivTopCenter.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivTopBottom.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivLeftDiagonal.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivDiagonalRight.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivBottomRight.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivBottomLeft.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivBottomcenter.classList.remove('e-de-table-border-inside-preview-click');
                this.isShowHidePreviewTableElements('none');
                break;
            case 'box':
                this.previewDivTopCenter.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivLeftDiagonal.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivDiagonalRight.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivBottomcenter.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivTopTop.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivTopBottom.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivBottomRight.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivBottomLeft.classList.add('e-de-table-border-inside-preview-click');
                this.isShowHidePreviewTableElements('box');
                break;
            case 'all':
                this.previewDivLeftDiagonal.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivDiagonalRight.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivBottomcenter.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivTopTop.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivTopBottom.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivBottomRight.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivBottomLeft.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivTopCenter.classList.add('e-de-table-border-inside-preview-click');
                this.isShowHidePreviewTableElements('all');
                break;
        }
    };
    BordersAndShadingDialog.prototype.isShowHidePreviewTableElements = function (settingDiv) {
        switch (settingDiv) {
            case 'none':
                this.previewDiv.style.border = 'none';
                this.previewRightDiagonalDiv.style.display = 'none';
                this.previewLeftDiagonalDiv.style.display = 'none';
                this.previewHorizontalDiv.style.display = 'none';
                this.previewVerticalDiv.style.display = 'none';
                break;
            case 'box':
                this.previewDiv.style.border = '1px solid rgba(0, 0, 0, .54)';
                this.previewRightDiagonalDiv.style.display = 'none';
                this.previewLeftDiagonalDiv.style.display = 'none';
                this.previewHorizontalDiv.style.display = 'none';
                this.previewVerticalDiv.style.display = 'none';
                break;
            case 'all':
                this.previewDiv.style.border = '1px solid rgba(0, 0, 0, .54)';
                this.previewRightDiagonalDiv.style.display = 'none';
                this.previewLeftDiagonalDiv.style.display = 'none';
                this.previewHorizontalDiv.style.display = 'block';
                this.previewVerticalDiv.style.display = 'block';
                break;
        }
    };
    BordersAndShadingDialog.prototype.handlePreviewCheckBoxShowHide = function (tableBorderDialogId, compareClass, element) {
        if (element.classList.contains(compareClass)) {
            element.classList.remove(compareClass);
        }
        else {
            element.classList.add(compareClass);
        }
    };
    // tslint:disable-next-line:max-line-length
    BordersAndShadingDialog.prototype.showHidePreviewDivElements = function (tableBorderDialogId, compareClass, elementClass, compareElementClass, position) {
        var setElement = document.getElementById(tableBorderDialogId + elementClass);
        var compareElement = document.getElementById(tableBorderDialogId + compareElementClass);
        if (position === 'TopTop') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'border-top');
        }
        else if (position === 'TopCenter') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'display');
        }
        else if (position === 'TopBottom') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'border-bottom');
        }
        else if (position === 'LeftDiagonal') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'display');
        }
        else if (position === 'BottomLeft') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'border-left');
        }
        else if (position === 'BottomCenter') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'display');
        }
        else if (position === 'BottomRight') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'border-right');
        }
        else if (position === 'RightDiagonal') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'display');
        }
    };
    BordersAndShadingDialog.prototype.setPropertyPreviewDivElement = function (ele, compareElement, compareClass, property) {
        if (compareElement.classList.contains(compareClass) && property.split('-')[0] === 'border') {
            /* tslint:disable:no-any */
            ele.style[property] = '1px solid rgba(0, 0, 0, .54)';
        }
        else if (compareElement.classList.contains(compareClass) && property === 'display') {
            ele.style[property] = 'block';
        }
        else {
            ele.style[property] = 'none';
            /* tslint:enable:no-any */
        }
    };
    BordersAndShadingDialog.prototype.loadBordersShadingsPropertiesDialog = function () {
        var tableFormat = this.owner.selection.tableFormat.table.tableFormat;
        var lineStyle;
        var borderColor;
        var fillColor;
        var borderWidth;
        if (!isNullOrUndefined(tableFormat) && !isNullOrUndefined(tableFormat.borders)) {
            this.cloneBorders(tableFormat.borders);
            if (isNullOrUndefined(tableFormat.borders) || isNullOrUndefined(tableFormat.borders.top)) {
                lineStyle = 1;
                borderColor = '#000000';
                borderWidth = 0;
                fillColor = '#000000';
            }
            else {
                lineStyle = this.getLineStyle(tableFormat.borders.top.lineStyle);
                borderColor = tableFormat.borders.top.color;
                borderWidth = tableFormat.borders.top.getLineWidth();
                fillColor = tableFormat.shading.backgroundColor;
            }
        }
        this.borderColorPicker.value = borderColor;
        this.shadingColorPicker.value = fillColor;
        /* tslint:disable:no-any */
        var colorPickerEvent = {
            target: this.borderColorPicker, ctrlKey: false,
            shiftKey: false, which: 0
        };
        var fillColorEvent = {
            target: this.shadingColorPicker, ctrlKey: false,
            shiftKey: false, which: 0
        };
        /* tslint:enable:no-any */
        this.applyPreviewTableBackgroundColor(fillColorEvent);
        this.applyPreviewTableBorderColor(colorPickerEvent);
        this.ulelementShading.index = 1;
        this.previewDivLeftDiagonal.style.display = 'none';
        this.previewDivDiagonalRight.style.display = 'none';
        this.borderWidth.value = borderWidth;
        this.borderStyle.index = lineStyle;
    };
    // tslint:disable:max-func-body-length
    BordersAndShadingDialog.prototype.cloneBorders = function (borders) {
        var topBorder = false;
        var bottomBorder = false;
        var leftBorder = false;
        var rightBorder = false;
        var horizontalBorder = false;
        var verticalBorder = false;
        var diagonalDownBorder = false;
        var customBorder = false;
        var diagonalUpBorder = false;
        if (borders !== null) {
            if (borders.top && (borders.top.hasNoneStyle || borders.top.lineStyle !== 'None')) {
                topBorder = true;
            }
            if (borders.bottom && (borders.bottom.hasNoneStyle || borders.bottom.lineStyle !== 'None')) {
                bottomBorder = true;
            }
            if (borders.left && (borders.left.hasNoneStyle || borders.left.lineStyle !== 'None')) {
                leftBorder = true;
            }
            if (borders.right && (borders.right.hasNoneStyle || borders.right.lineStyle !== 'None')) {
                rightBorder = true;
            }
            if (borders.horizontal && (borders.horizontal.hasNoneStyle || borders.horizontal.lineStyle !== 'None')) {
                horizontalBorder = true;
            }
            if (borders.vertical && (borders.vertical.hasNoneStyle || borders.vertical.lineStyle !== 'None')) {
                verticalBorder = true;
            }
            if (borders.diagonalDown && (borders.diagonalDown.hasNoneStyle || borders.diagonalDown.lineStyle !== 'None')) {
                diagonalDownBorder = true;
            }
            if (borders.diagonalUp && (borders.diagonalUp.hasNoneStyle || borders.diagonalUp.lineStyle !== 'None')) {
                diagonalUpBorder = true;
            }
            if (!(!topBorder || !bottomBorder || !leftBorder || !rightBorder)) {
                if (!(!topBorder || !bottomBorder || !leftBorder || !rightBorder || !horizontalBorder
                    || !verticalBorder || diagonalUpBorder || diagonalDownBorder)) {
                    if ((topBorder && bottomBorder && leftBorder && rightBorder && horizontalBorder && verticalBorder
                        && !diagonalUpBorder && !diagonalDownBorder)) {
                        if (borders.top.hasNoneStyle && borders.bottom.hasNoneStyle && borders.left.hasNoneStyle
                            && borders.right.hasNoneStyle && borders.horizontal.hasNoneStyle && borders.vertical.hasNoneStyle) {
                            this.setSettingPreviewDivElement('none');
                            this.customDiv.classList.remove('e-de-table-border-inside-setting-click');
                            this.noneDiv.classList.add('e-de-table-border-inside-setting-click');
                            this.boxDiv.classList.remove('e-de-table-border-inside-setting-click');
                            this.allDiv.classList.remove('e-de-table-border-inside-setting-click');
                        }
                        else {
                            this.setSettingPreviewDivElement('all');
                            this.allDiv.classList.add('e-de-table-border-inside-setting-click');
                            this.customDiv.classList.remove('e-de-table-border-inside-setting-click');
                            this.noneDiv.classList.remove('e-de-table-border-inside-setting-click');
                            this.boxDiv.classList.remove('e-de-table-border-inside-setting-click');
                        }
                    }
                }
                else if ((leftBorder && bottomBorder && topBorder && rightBorder && !horizontalBorder && !verticalBorder)) {
                    if (borders.top.hasNoneStyle && borders.bottom.hasNoneStyle && borders.left.hasNoneStyle
                        && borders.right.hasNoneStyle && borders.horizontal.hasNoneStyle && borders.vertical.hasNoneStyle) {
                        this.setSettingPreviewDivElement('none');
                        this.boxDiv.classList.remove('e-de-table-border-inside-setting-click');
                        this.allDiv.classList.remove('e-de-table-border-inside-setting-click');
                        this.customDiv.classList.remove('e-de-table-border-inside-setting-click');
                        this.noneDiv.classList.add('e-de-table-border-inside-setting-click');
                    }
                    else {
                        this.setSettingPreviewDivElement('box');
                        this.customDiv.classList.remove('e-de-table-border-inside-setting-click');
                        this.noneDiv.classList.remove('e-de-table-border-inside-setting-click');
                        this.boxDiv.classList.add('e-de-table-border-inside-setting-click');
                        this.allDiv.classList.remove('e-de-table-border-inside-setting-click');
                    }
                }
                else {
                    customBorder = true;
                }
            }
            else {
                customBorder = true;
            }
            this.previewDivLeftDiagonal.classList.remove('e-de-table-border-inside-preview-click');
            this.previewDivDiagonalRight.classList.remove('e-de-table-border-inside-preview-click');
            if (customBorder) {
                this.customDiv.classList.add('e-de-table-border-inside-setting-click');
                this.noneDiv.classList.remove('e-de-table-border-inside-setting-click');
                this.boxDiv.classList.remove('e-de-table-border-inside-setting-click');
                this.allDiv.classList.remove('e-de-table-border-inside-setting-click');
                if (topBorder) {
                    this.previewDivTopTop.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivTopTop.classList.remove('e-de-table-border-inside-preview-click');
                }
                if (bottomBorder) {
                    this.previewDivTopBottom.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivTopBottom.classList.remove('e-de-table-border-inside-preview-click');
                }
                if (leftBorder) {
                    this.previewDivBottomLeft.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivBottomLeft.classList.remove('e-de-table-border-inside-preview-click');
                }
                if (rightBorder) {
                    this.previewDivBottomRight.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivBottomRight.classList.remove('e-de-table-border-inside-preview-click');
                }
                if (verticalBorder) {
                    this.previewDivBottomcenter.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivBottomcenter.classList.remove('e-de-table-border-inside-preview-click');
                }
                if (horizontalBorder) {
                    this.previewDivTopCenter.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivTopCenter.classList.remove('e-de-table-border-inside-preview-click');
                }
            }
        }
    };
    BordersAndShadingDialog.prototype.getLineStyle = function (lineStyle) {
        switch (lineStyle) {
            case 'Single': return 1;
            case 'Dot': return 2;
            case 'DashSmallGap': return 3;
            case 'DashLargeGap': return 4;
            case 'DashDot': return 5;
            case 'DashDotDot': return 6;
            case 'Double': return 7;
            case 'Triple': return 8;
            case 'ThinThickSmallGap': return 9;
            case 'ThickThinSmallGap': return 10;
            case 'ThinThickThinSmallGap': return 11;
            case 'ThinThickMediumGap': return 12;
            case 'ThickThinMediumGap': return 13;
            case 'ThinThickThinMediumGap': return 14;
            case 'ThinThickLargeGap': return 15;
            case 'ThickThinLargeGap': return 16;
            case 'ThinThickThinLargeGap': return 17;
            case 'SingleWavy': return 18;
            case 'DoubleWavy': return 19;
            case 'DashDotStroked': return 20;
            case 'Emboss3D': return 21;
            case 'Engrave3D': return 22;
            case 'Outset': return 23;
            case 'Inset': return 24;
            case 'Thick': return 25;
        }
        return 0;
    };
    /**
     * @private
     */
    BordersAndShadingDialog.prototype.destroy = function () {
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (var k = 0; k < this.target.childNodes.length; k++) {
                this.target.removeChild(this.target.childNodes[k]);
                k--;
            }
            this.target = undefined;
        }
        if (this.cellFormat) {
            this.cellFormat.destroy();
            this.cellFormat = undefined;
        }
        if (this.tableFormat) {
            this.tableFormat.destroy();
            this.tableFormat = undefined;
        }
        this.dialog = undefined;
        this.target = undefined;
        if (!isNullOrUndefined(this.borderStyle)) {
            this.borderStyle.destroy();
        }
        this.borderStyle = undefined;
        if (!isNullOrUndefined(this.borderColorPicker)) {
            this.borderColorPicker.destroy();
        }
        this.borderColorPicker = undefined;
        if (!isNullOrUndefined(this.shadingColorPicker)) {
            this.shadingColorPicker.destroy();
        }
        this.shadingColorPicker = undefined;
        if (!isNullOrUndefined(this.ulelementShading)) {
            this.ulelementShading.destroy();
        }
        this.ulelementShading = undefined;
        this.noneDivTransparent = undefined;
        this.boxDivTransparent = undefined;
        this.allDivTransparent = undefined;
        this.customDivTransparent = undefined;
        this.previewDiv = undefined;
        this.previewRightDiagonalDiv = undefined;
        this.previewLeftDiagonalDiv = undefined;
        this.previewVerticalDiv = undefined;
        this.previewHorizontalDiv = undefined;
        this.previewDivTopTopContainer = undefined;
        this.previewDivTopTop = undefined;
        this.previewDivTopCenterContainer = undefined;
        this.previewDivTopCenter = undefined;
        this.previewDivTopBottomContainer = undefined;
        this.previewDivTopBottom = undefined;
        this.previewDivLeftDiagonalContainer = undefined;
        this.previewDivLeftDiagonal = undefined;
        this.previewDivBottomLeftContainer = undefined;
        this.previewDivBottomLeft = undefined;
        this.previewDivBottomcenterContainer = undefined;
        this.previewDivBottomcenter = undefined;
        this.previewDivBottomRightContainer = undefined;
        this.previewDivBottomRight = undefined;
        this.previewDivDiagonalRightContainer = undefined;
        this.previewDivDiagonalRight = undefined;
        this.previewDivTopTopTransParent = undefined;
        this.previewDivTopCenterTransParent = undefined;
        this.previewDivTopBottomTransParent = undefined;
        this.previewDivLeftDiagonalTransParent = undefined;
        this.previewDivBottomLeftTransparent = undefined;
        this.previewDivBottomcenterTransparent = undefined;
        this.previewDivBottomRightTransparent = undefined;
        this.previewDivDiagonalRightTransparent = undefined;
        this.shadingContiner = undefined;
        this.noneDiv = undefined;
        this.customDiv = undefined;
        this.allDiv = undefined;
        this.boxDiv = undefined;
    };
    return BordersAndShadingDialog;
}());

/**
 * The Table options dialog is used to modify default cell margins and cell spacing of selected table.
 */
var TableOptionsDialog = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function TableOptionsDialog(viewer) {
        var _this = this;
        /**
         * @private
         */
        this.applyTableCellProperties = function () {
            var tableFormat = _this.owner.selection.tableFormat;
            if (!isNullOrUndefined(_this.bottomMarginBox.value || _this.leftMarginBox.value
                || _this.rightMarginBox.value || _this.topMarginBox.value || _this.cellSpaceTextBox.value)
                && (tableFormat.bottomMargin !== _this.bottomMarginBox.value
                    || tableFormat.leftMargin !== _this.leftMarginBox.value
                    || tableFormat.rightMargin !== _this.rightMarginBox.value
                    || tableFormat.topMargin !== _this.topMarginBox.value
                    || tableFormat.cellSpacing !== _this.cellSpaceTextBox.value)) {
                _this.owner.owner.tablePropertiesDialogModule.isTableOptionsUpdated = true;
                _this.applyTableOptions(_this.tableFormat);
                _this.owner.owner.tablePropertiesDialogModule.applyTableSubProperties();
            }
            _this.closeCellMarginsDialog();
        };
        /**
         * @private
         */
        this.closeCellMarginsDialog = function () {
            _this.owner.dialog.hide();
            _this.owner.dialog.element.style.pointerEvents = '';
            _this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.changeAllowSpaceCheckBox = function () {
            if (_this.allowSpaceCheckBox.checked) {
                _this.cellSpaceTextBox.enabled = true;
            }
            else {
                _this.cellSpaceTextBox.enabled = false;
            }
        };
        /**
         * @private
         */
        this.removeEvents = function () {
            _this.owner.dialog2.element.style.pointerEvents = '';
            _this.owner.updateFocus();
        };
        this.owner = viewer;
    }
    Object.defineProperty(TableOptionsDialog.prototype, "tableFormat", {
        /**
         * @private
         */
        get: function () {
            if (isNullOrUndefined(this.tableFormatIn)) {
                return this.tableFormatIn = new WTableFormat();
            }
            return this.tableFormatIn;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    TableOptionsDialog.prototype.getModuleName = function () {
        return 'TableOptionsDialog';
    };
    /**
     * @private
     */
    TableOptionsDialog.prototype.initTableOptionsDialog = function (localValue, isRtl) {
        var instance = this.owner;
        this.target = createElement('div', {
            id: this.owner.owner.containerId + '_insertCellMarginsDialog', className: 'e-de-table-options-dlg'
        });
        var innerDiv = createElement('div', {
            styles: 'width: 504px;position: relative;height: auto;margin-bottom: 14px'
        });
        var innerDivLabel = createElement('Label', {
            id: this.target.id + '_innerDivLabel', className: 'e-de-cell-dia-options-label',
            innerHTML: localValue.getConstant('Default cell margins')
        });
        innerDiv.appendChild(innerDivLabel);
        CellOptionsDialog.getCellMarginDialogElements(this, innerDiv, localValue);
        var div = createElement('div', { styles: 'width: 475px; position: relative;' });
        var cellSpaceLabel = createElement('Label', {
            className: 'e-de-cell-dia-options-label',
            id: this.target.id + '_cellSpaceLabel'
        });
        cellSpaceLabel.innerHTML = localValue.getConstant('Default cell spacing');
        div.appendChild(cellSpaceLabel);
        var table2 = createElement('TABLE', {
            styles: 'height: 30px;'
        });
        var tr3 = createElement('tr');
        var td5 = createElement('td');
        var allowSpaceCheckBox = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_cellcheck'
        });
        var td6Padding;
        if (isRtl) {
            td6Padding = 'padding-right:15px;';
        }
        else {
            td6Padding = 'padding-left:14px;';
        }
        var td6 = createElement('td', { styles: td6Padding, });
        this.cellspacingTextBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_cellspacing'
        });
        td5.appendChild(allowSpaceCheckBox);
        td6.appendChild(this.cellspacingTextBox);
        tr3.appendChild(td5);
        tr3.appendChild(td6);
        table2.appendChild(tr3);
        div.appendChild(table2);
        var divBtn = document.createElement('div');
        this.target.appendChild(div);
        this.target.appendChild(divBtn);
        this.cellSpaceTextBox = new NumericTextBox({
            value: 0, min: 0, max: 264.5, width: 163,
            decimals: 2, enablePersistence: false
        });
        this.cellSpaceTextBox.appendTo(this.cellspacingTextBox);
        this.allowSpaceCheckBox = new CheckBox({
            label: localValue.getConstant('Allow spacing between cells'),
            change: this.changeAllowSpaceCheckBox,
            enableRtl: isRtl,
            cssClass: 'e-de-tbl-margin-sub-header',
        });
        this.allowSpaceCheckBox.appendTo(allowSpaceCheckBox);
    };
    /**
     * @private
     */
    TableOptionsDialog.prototype.loadCellMarginsDialog = function () {
        var tableFormat = this.owner.selection.tableFormat;
        this.cellSpaceTextBox.value = tableFormat.cellSpacing;
        this.bottomMarginBox.value = tableFormat.bottomMargin;
        this.topMarginBox.value = tableFormat.topMargin;
        this.rightMarginBox.value = tableFormat.rightMargin;
        this.leftMarginBox.value = tableFormat.leftMargin;
        if (tableFormat.cellSpacing > 0) {
            this.allowSpaceCheckBox.checked = true;
            this.cellSpaceTextBox.enabled = true;
        }
        else {
            this.allowSpaceCheckBox.checked = false;
            this.cellSpaceTextBox.enabled = false;
        }
    };
    /**
     * @private
     */
    TableOptionsDialog.prototype.applySubTableOptions = function (tableFormat) {
        this.owner.owner.editorHistory.initComplexHistory(this.owner.selection, 'TableMarginsSelection');
        this.applyTableOptionsHistory(tableFormat);
        if (!isNullOrUndefined(this.owner.owner.editorHistory.currentHistoryInfo)) {
            this.owner.owner.editorHistory.updateComplexHistory();
        }
    };
    /**
     * @private
     */
    TableOptionsDialog.prototype.applyTableOptionsHelper = function (tableFormat) {
        this.applySubTableOptionsHelper(tableFormat);
    };
    /**
     * @private
     */
    TableOptionsDialog.prototype.applyTableOptionsHistory = function (tableFormat) {
        this.owner.owner.editorModule.initHistory('TableOptions');
        this.applySubTableOptionsHelper(tableFormat);
    };
    /**
     * @private
     */
    TableOptionsDialog.prototype.applySubTableOptionsHelper = function (tableFormat) {
        var ownerTable = this.owner.selection.start.currentWidget.paragraph.associatedCell.ownerTable;
        ownerTable = ownerTable.combineWidget(this.owner);
        var currentTableFormat = ownerTable.tableFormat;
        if (!isNullOrUndefined(this.owner.owner.editorHistory.currentBaseHistoryInfo)) {
            this.owner.owner.editorHistory.currentBaseHistoryInfo.addModifiedTableOptions(currentTableFormat);
        }
        currentTableFormat.cellSpacing = tableFormat.cellSpacing;
        currentTableFormat.leftMargin = tableFormat.leftMargin;
        currentTableFormat.topMargin = tableFormat.topMargin;
        currentTableFormat.rightMargin = tableFormat.rightMargin;
        currentTableFormat.bottomMargin = tableFormat.bottomMargin;
        this.owner.owner.tablePropertiesDialogModule.calculateGridValue(ownerTable);
    };
    /**
     * @private
     */
    TableOptionsDialog.prototype.applyTableOptions = function (tableFormat) {
        tableFormat.leftMargin = this.leftMarginBox.value;
        tableFormat.topMargin = this.topMarginBox.value;
        tableFormat.bottomMargin = this.bottomMarginBox.value;
        tableFormat.rightMargin = this.rightMarginBox.value;
        if (this.allowSpaceCheckBox.checked) {
            tableFormat.cellSpacing = this.cellSpaceTextBox.value;
        }
    };
    /**
     * @private
     */
    TableOptionsDialog.prototype.show = function () {
        var documentLocale = new L10n('documenteditor', this.owner.owner.defaultLocale);
        documentLocale.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initTableOptionsDialog(documentLocale, this.owner.owner.enableRtl);
        }
        this.loadCellMarginsDialog();
        this.owner.dialog.header = documentLocale.getConstant('Table Options');
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = undefined;
        this.owner.dialog.position = { X: 'center', Y: 'center' };
        //  this.owner.dialog.cssClass = 'e-de-table-margin-size';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.open = undefined;
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.close = this.removeEvents;
        this.owner.dialog.buttons = [{
                click: this.applyTableCellProperties,
                buttonModel: { content: documentLocale.getConstant('Ok'), cssClass: 'e-flat e-table-cell-okay', isPrimary: true }
            },
            {
                click: this.closeCellMarginsDialog,
                buttonModel: { content: documentLocale.getConstant('Cancel'), cssClass: 'e-flat e-table-cell-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    };
    /**
     * @private
     */
    TableOptionsDialog.prototype.destroy = function () {
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (var p = 0; p < this.target.childNodes.length; p++) {
                this.target.removeChild(this.target.childNodes[p]);
                p--;
            }
            this.target = undefined;
        }
        this.dialog = undefined;
        this.target = undefined;
        this.owner = undefined;
        this.cellspacingTextBox = undefined;
        this.allowSpaceCheckBox = undefined;
    };
    return TableOptionsDialog;
}());

/**
 * The Cell options dialog is used to modify margins of selected cells.
 */
var CellOptionsDialog = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function CellOptionsDialog(viewer) {
        var _this = this;
        /**
         * @private
         */
        this.removeEvents = function () {
            _this.owner.dialog2.element.style.pointerEvents = '';
            _this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.changeSameAsTable = function () {
            if (_this.sameAsTableCheckBox.checked) {
                _this.leftMarginBox.enabled = false;
                _this.rightMarginBox.enabled = false;
                _this.bottomMarginBox.enabled = false;
                _this.topMarginBox.enabled = false;
            }
            else {
                _this.leftMarginBox.enabled = true;
                _this.rightMarginBox.enabled = true;
                _this.bottomMarginBox.enabled = true;
                _this.topMarginBox.enabled = true;
            }
        };
        /**
         * @private
         */
        this.applyTableCellProperties = function () {
            var cellFormat = _this.owner.selection.cellFormat;
            if (!isNullOrUndefined(_this.bottomMarginBox.value || _this.leftMarginBox.value
                || _this.rightMarginBox.value || _this.topMarginBox.value) &&
                (cellFormat.bottomMargin !== _this.bottomMarginBox.value || cellFormat.leftMargin !== _this.leftMarginBox.value
                    || cellFormat.rightMargin !== _this.rightMarginBox.value || cellFormat.topMargin !== _this.topMarginBox.value)) {
                _this.owner.owner.tablePropertiesDialogModule.isCellOptionsUpdated = true;
                _this.applyTableOptions(_this.cellFormat);
                _this.owner.owner.tablePropertiesDialogModule.applyTableSubProperties();
            }
            _this.closeCellMarginsDialog();
        };
        /**
         * @private
         */
        this.closeCellMarginsDialog = function () {
            _this.owner.dialog.hide();
            _this.owner.dialog.element.style.pointerEvents = '';
        };
        this.owner = viewer;
    }
    Object.defineProperty(CellOptionsDialog.prototype, "cellFormat", {
        /**
         * @private
         */
        get: function () {
            if (isNullOrUndefined(this.cellFormatIn)) {
                return this.cellFormatIn = new WCellFormat();
            }
            return this.cellFormatIn;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    CellOptionsDialog.prototype.getModuleName = function () {
        return 'CellOptionsDialog';
    };
    /**
     * @private
     */
    CellOptionsDialog.prototype.initCellMarginsDialog = function (localValue, isRtl) {
        var instance = this.owner;
        this.target = createElement('div', {
            id: this.owner.owner.containerId + '_tableCellMarginsDialog', className: 'e-de-table-cell-margin-dlg'
        });
        var innerDiv = createElement('div', { styles: 'width: 504px;position: relative;height: auto;' });
        var innerDivLabel = createElement('Label', {
            className: 'e-de-cell-dia-options-label', id: this.target.id + '_innerDivLabel'
        });
        innerDivLabel.innerHTML = localValue.getConstant('Cell margins');
        innerDiv.appendChild(innerDivLabel);
        var table = createElement('TABLE', {
            styles: 'padding-bottom: 8px;padding-top: 8px;', className: 'e-de-cell-margin-top'
        });
        var tr = createElement('tr');
        var td = createElement('td', { className: 'e-de-tbl-btn-seperator' });
        var sameAsTableCheckBox = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_sameAsCheckBox'
        });
        td.appendChild(sameAsTableCheckBox);
        tr.appendChild(td);
        table.appendChild(tr);
        innerDiv.appendChild(table);
        CellOptionsDialog.getCellMarginDialogElements(this, innerDiv, localValue);
        var divBtn = document.createElement('div');
        this.target.appendChild(divBtn);
        this.sameAsTableCheckBox = new CheckBox({
            label: localValue.getConstant('Same as the whole table'),
            change: this.changeSameAsTable,
            enableRtl: isRtl
        });
        this.sameAsTableCheckBox.appendTo(sameAsTableCheckBox);
        this.sameAsTableCheckBox.addEventListener('change', this.changeSameAsTable);
    };
    /**
     * @private
     */
    CellOptionsDialog.prototype.show = function () {
        var localizeValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localizeValue.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initCellMarginsDialog(localizeValue, this.owner.owner.enableRtl);
        }
        this.loadCellMarginsDialog();
        this.owner.dialog.header = localizeValue.getConstant('Cell Options');
        this.owner.dialog.position = { X: 'center', Y: 'top' };
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = undefined;
        this.owner.dialog.open = undefined;
        this.owner.dialog.close = this.removeEvents;
        this.owner.dialog.buttons = [{
                click: this.applyTableCellProperties,
                buttonModel: { content: localizeValue.getConstant('Ok'), cssClass: 'e-flat e-table-cell-margin-okay', isPrimary: true }
            },
            {
                click: this.closeCellMarginsDialog,
                buttonModel: { content: localizeValue.getConstant('Cancel'), cssClass: 'e-flat e-table-cell-margin-cancel' }
            }];
        this.owner.dialog.show();
    };
    /**
     * @private
     */
    CellOptionsDialog.prototype.loadCellMarginsDialog = function () {
        var cellFormat = this.owner.selection.cellFormat;
        this.sameAsTable = isNullOrUndefined(cellFormat.leftMargin || cellFormat.topMargin
            || cellFormat.rightMargin || cellFormat.bottomMargin);
        if (this.sameAsTable) {
            var tableFormat = this.owner.selection.tableFormat;
            this.loadCellProperties(tableFormat, false, true);
        }
        else {
            this.loadCellProperties(cellFormat, true, false);
        }
    };
    CellOptionsDialog.prototype.loadCellProperties = function (format, enableTextBox, enableCheckBox) {
        this.leftMarginBox.value = format.leftMargin;
        this.rightMarginBox.value = format.rightMargin;
        this.topMarginBox.value = format.topMargin;
        this.bottomMarginBox.value = format.bottomMargin;
        this.leftMarginBox.enabled = enableTextBox;
        this.rightMarginBox.enabled = enableTextBox;
        this.topMarginBox.enabled = enableTextBox;
        this.bottomMarginBox.enabled = enableTextBox;
        this.sameAsTableCheckBox.checked = enableCheckBox;
    };
    /**
     * @private
     */
    CellOptionsDialog.prototype.applySubCellOptions = function (cellFormat) {
        this.owner.owner.editorHistory.initComplexHistory(this.owner.selection, 'CellMarginsSelection');
        this.owner.owner.editorModule.initHistory('CellOptions');
        /* tslint:disable:max-line-length */
        var startTable = this.owner.selection.start.paragraph.associatedCell.ownerTable;
        startTable = startTable.combineWidget(this.owner);
        this.applyCellmarginsValue(this.owner.selection.start.paragraph.associatedCell.ownerRow.combineWidget(this.owner), this.owner.selection.start, this.owner.selection.end, cellFormat);
        this.owner.owner.editorModule.reLayout(this.owner.selection, false);
        if (!isNullOrUndefined(this.owner.owner.editorHistory.currentHistoryInfo)) {
            this.owner.owner.editorHistory.updateComplexHistory();
        }
    };
    /**
     * @private
     */
    CellOptionsDialog.prototype.applyCellmarginsValue = function (row, start, end, cellFormat) {
        this.applyCellMarginsInternal(row, cellFormat);
        if (end.paragraph.associatedCell.ownerRow === row) {
            return;
        }
        var newRow = row.nextWidget;
        if (!isNullOrUndefined(newRow)) {
            this.applyCellmarginsValue(newRow, start, end, cellFormat);
        }
    };
    CellOptionsDialog.prototype.applyCellMarginsInternal = function (row, cellFormat) {
        if (!isNullOrUndefined(this.owner.owner.editorHistory.currentBaseHistoryInfo)) {
            var currentFormat = row.childWidgets[0].cellFormat;
            /* tslint:disable:max-line-length */
            cellFormat = this.owner.owner.editorHistory.currentBaseHistoryInfo.addModifiedCellOptions(currentFormat, cellFormat, row.ownerTable);
        }
        if (!isNullOrUndefined(cellFormat)) {
            this.applyCellMarginsForCells(row, cellFormat);
        }
    };
    /**
     * @private
     */
    CellOptionsDialog.prototype.applyCellMarginsForCells = function (row, cellFormat) {
        var rowCells = row.childWidgets;
        this.iterateCells(rowCells, cellFormat);
    };
    /**
     * @private
     */
    CellOptionsDialog.prototype.iterateCells = function (cells, cellFormat) {
        for (var i = 0; i < cells.length; i++) {
            this.applySubCellMargins(cells[i].cellFormat, cellFormat);
        }
        this.owner.owner.tablePropertiesDialogModule.calculateGridValue(cells[0].ownerTable);
    };
    /**
     * @private
     */
    CellOptionsDialog.prototype.applySubCellMargins = function (sourceFormat, cellFormat) {
        sourceFormat.leftMargin = cellFormat.leftMargin;
        sourceFormat.topMargin = cellFormat.topMargin;
        sourceFormat.rightMargin = cellFormat.rightMargin;
        sourceFormat.bottomMargin = cellFormat.bottomMargin;
    };
    /**
     * @private
     */
    CellOptionsDialog.prototype.applyTableOptions = function (cellFormat) {
        if (!this.sameAsTableCheckBox.checked) {
            cellFormat.leftMargin = this.leftMarginBox.value;
            cellFormat.topMargin = this.topMarginBox.value;
            cellFormat.bottomMargin = this.bottomMarginBox.value;
            cellFormat.rightMargin = this.rightMarginBox.value;
        }
    };
    /**
     * @private
     */
    CellOptionsDialog.prototype.destroy = function () {
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (var y = 0; y < this.target.childNodes.length; y++) {
                this.target.removeChild(this.target.childNodes[y]);
                y--;
            }
            this.target = undefined;
        }
        this.dialog = undefined;
        this.target = undefined;
        this.owner = undefined;
        this.sameAsTableCheckBox = undefined;
    };
    /**
     * @private
     */
    CellOptionsDialog.getCellMarginDialogElements = function (dialog, div, locale) {
        if (!isNullOrUndefined(dialog)) {
            var table = createElement('TABLE', { className: 'e-de-cell-margin-top' });
            var tr1 = createElement('tr', { styles: 'height: 50px;' });
            var td1 = createElement('td');
            var topLabel = createElement('label', {
                innerHTML: locale.getConstant('Top'), className: 'e-de-cell-dia-label-common',
                id: dialog.target.id + '_TopLabel'
            });
            var topTextBox = createElement('input', {
                attrs: { 'type': 'text' }, styles: 'width:100%', id: dialog.target.id + '_Top'
            });
            td1.appendChild(topLabel);
            td1.appendChild(topTextBox);
            var td2 = createElement('td', { className: 'e-de-tbl-btn-seperator' });
            var leftLabel = createElement('label', {
                innerHTML: locale.getConstant('Left'), className: 'e-de-cell-dia-label-common',
                id: dialog.target.id + '_leftLabel'
            });
            var leftTextBox = createElement('input', {
                attrs: { 'type': 'text' },
                styles: 'width:100%', id: dialog.target.id + '_left'
            });
            td2.appendChild(leftLabel);
            td2.appendChild(leftTextBox);
            tr1.appendChild(td1);
            tr1.appendChild(td2);
            var tr2 = createElement('tr', { styles: 'height: 50px;' });
            var td3 = createElement('td', { styles: 'width:40%;' });
            var bottomLabel = createElement('label', {
                innerHTML: locale.getConstant('Bottom'),
                className: 'e-de-cell-dia-label-common', id: dialog.target.id + '_bottomLabel'
            });
            var bottomTextBox = createElement('input', {
                attrs: { 'type': 'text' },
                styles: 'width:100%', id: dialog.target.id + '_bottom'
            });
            td3.appendChild(bottomLabel);
            td3.appendChild(bottomTextBox);
            var td4 = createElement('td', { styles: 'width:40%;' });
            var rightLabel = createElement('label', {
                innerHTML: locale.getConstant('Right'), id: dialog.target.id + '_rightLabel',
                className: 'e-de-cell-dia-label-common'
            });
            var rightTextBox = createElement('input', {
                attrs: { 'type': 'text' },
                styles: 'width:100%', id: dialog.target.id + '_right'
            });
            td4.appendChild(rightLabel);
            td4.appendChild(rightTextBox);
            tr2.appendChild(td3);
            tr2.appendChild(td4);
            table.appendChild(tr1);
            table.appendChild(tr2);
            div.appendChild(table);
            dialog.target.appendChild(div);
            dialog.topMarginBox = new NumericTextBox({
                value: 0, min: 0, max: 1584, width: 175, decimals: 2,
                enablePersistence: false
            });
            dialog.topMarginBox.appendTo(topTextBox);
            dialog.leftMarginBox = new NumericTextBox({
                value: 0, min: 0, max: 1584, width: 175,
                decimals: 2, enablePersistence: false
            });
            dialog.leftMarginBox.appendTo(leftTextBox);
            dialog.bottomMarginBox = new NumericTextBox({
                value: 0, min: 0, max: 1584, width: 175, decimals: 2,
                enablePersistence: false
            });
            dialog.bottomMarginBox.appendTo(bottomTextBox);
            dialog.rightMarginBox = new NumericTextBox({
                value: 0, min: 0, max: 1584, width: 175,
                decimals: 2, enablePersistence: false
            });
            dialog.rightMarginBox.appendTo(rightTextBox);
        }
    };
    return CellOptionsDialog;
}());

/**
 * The Styles dialog is used to create or modify styles.
 */
var StylesDialog = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function StylesDialog(viewer) {
        var _this = this;
        this.updateStyleNames = function (localValue) {
            var collection = _this.owner.owner.viewer.styles.getStyleNames('Paragraph');
            var styleNames = ['Normal', 'Heading 1', 'Heading 2', 'Heading 3', 'Heading 4', 'Heading 5', 'Heading 6'];
            var defaultStyleNames = _this.defaultStyleName(styleNames, localValue);
            var finalList = collection.concat(defaultStyleNames).filter(function (v, i, a) { return a.indexOf(v) === i; });
            return finalList;
        };
        this.defaultStyleName = function (styleNames, localValue) {
            var styleName = [];
            for (var index = 0; index < styleNames.length; index++) {
                styleName.push(localValue.getConstant(styleNames[index]));
            }
            return styleName;
        };
        this.modifyStyles = function () {
            _this.owner.dialog.hide();
            _this.owner.owner.styleDialogModule.show(_this.styleName, _this.localValue.getConstant('Modify Style'));
        };
        /* tslint:disable:no-any */
        this.selectHandler = function (args) {
            _this.styleName = args.text;
        };
        this.addNewStyles = function () {
            _this.owner.dialog.hide();
            _this.owner.owner.styleDialogModule.show();
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    StylesDialog.prototype.getModuleName = function () {
        return 'StylesDialog';
    };
    /**
     * @private
     */
    StylesDialog.prototype.initStylesDialog = function (localValue, styles, isRtl) {
        var id = this.owner.owner.containerId + '_insert_styles';
        this.target = createElement('div', { id: id, className: 'e-de-styles' });
        var headerValue = localValue.getConstant('Styles');
        var dlgFields = createElement('div', { innerHTML: headerValue, className: 'e-styles-dlgfields' });
        this.target.appendChild(dlgFields);
        var commonDiv = createElement('div', { className: 'e-styles-common' });
        this.target.appendChild(commonDiv);
        var searchDiv = createElement('div', { className: 'e-styles-list' });
        commonDiv.appendChild(searchDiv);
        if (isRtl) {
            searchDiv.classList.add('e-de-rtl');
        }
        var listviewDiv = createElement('div', { className: 'e-styles-listViewDiv', id: 'styles_listview' });
        searchDiv.appendChild(listviewDiv);
        this.listviewInstance = new ListView({
            dataSource: styles,
            cssClass: 'e-styles-listview',
        });
        this.listviewInstance.appendTo(listviewDiv);
        this.listviewInstance.addEventListener('select', this.selectHandler);
        var buttonDiv = createElement('div', { className: 'e-styles-button' });
        commonDiv.appendChild(buttonDiv);
        var newButtonDiv = createElement('div', { className: 'e-styles-addbutton' });
        buttonDiv.appendChild(newButtonDiv);
        var newButtonElement = createElement('button', {
            innerHTML: localValue.getConstant('New'), id: 'new',
            attrs: { type: 'button' }
        });
        newButtonDiv.appendChild(newButtonElement);
        var newbutton = new Button({ cssClass: 'e-button-custom' });
        newbutton.appendTo(newButtonElement);
        newButtonElement.addEventListener('click', this.addNewStyles);
        var modifybuttonDiv = createElement('div', { className: 'e-styles-addbutton' });
        buttonDiv.appendChild(modifybuttonDiv);
        var modifyButtonElement = createElement('button', {
            innerHTML: localValue.getConstant('Modify'), id: 'modify',
            attrs: { type: 'button' }
        });
        modifybuttonDiv.appendChild(modifyButtonElement);
        var addbutton = new Button({ cssClass: 'e-button-custom' });
        addbutton.appendTo(modifyButtonElement);
        modifyButtonElement.addEventListener('click', this.modifyStyles);
    };
    /**
     * @private
     */
    StylesDialog.prototype.show = function () {
        var localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localValue.setLocale(this.owner.owner.locale);
        var styles = this.updateStyleNames(localValue);
        this.localValue = localValue;
        this.initStylesDialog(localValue, styles, this.owner.owner.enableRtl);
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.close = this.owner.updateFocus;
        this.owner.dialog.header = localValue.getConstant('Styles');
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.buttons = [{
                click: this.hideObjects.bind(this),
                buttonModel: { content: localValue.getConstant('Cancel'), cssClass: 'e-flat e-hyper-insert', isPrimary: true }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    };
    StylesDialog.prototype.hideObjects = function () {
        this.owner.dialog.hide();
    };
    /**
     * @private
     */
    StylesDialog.prototype.destroy = function () {
        if (this.listviewInstance) {
            this.listviewInstance.destroy();
            this.listviewInstance = undefined;
        }
    };
    return StylesDialog;
}());

/**
 * Export dialogs
 */

/**
 * Spell checker export
 */

/**
 * Restrict editing
 */

/**
 * @private
 */
var CommentReviewPane = /** @__PURE__ @class */ (function () {
    function CommentReviewPane(owner) {
        this.isNewComment = false;
        this.owner = owner;
        var localObj = new L10n('documenteditor', this.owner.defaultLocale);
        localObj.setLocale(this.owner.locale);
        this.initReviewPane(localObj);
        this.reviewPane.style.display = 'none';
    }
    Object.defineProperty(CommentReviewPane.prototype, "previousSelectedComment", {
        get: function () {
            return this.previousSelectedCommentInt;
        },
        set: function (value) {
            if (!isNullOrUndefined(value) && value !== this.previousSelectedCommentInt) {
                if (this.commentPane.comments.containsKey(value)) {
                    var commentStart = this.commentPane.getCommentStart(value);
                    var commentMark = commentStart.commentMark;
                    if (commentMark) {
                        classList(commentMark, [], ['e-de-cmt-mark-selected']);
                        this.commentPane.removeSelectionMark('e-de-cmt-selection');
                        this.commentPane.removeSelectionMark('e-de-cmt-mark-selected');
                    }
                    var commentView = this.commentPane.comments.get(value);
                    commentView.hideDrawer();
                    for (var i = 0; i < value.replyComments.length; i++) {
                        commentView = this.commentPane.comments.get(value.replyComments[i]);
                        if (commentView) {
                            commentView.hideDrawer();
                            commentView.hideMenuItems();
                        }
                    }
                }
            }
            this.previousSelectedCommentInt = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    CommentReviewPane.prototype.showHidePane = function (show) {
        if (this.reviewPane) {
            this.reviewPane.style.display = show ? 'block' : 'none';
        }
        if (show) {
            this.commentPane.updateHeight();
        }
        if (this.owner) {
            this.owner.resize();
        }
    };
    CommentReviewPane.prototype.initReviewPane = function (localValue) {
        var reviewContainer = this.owner.viewer.optionsPaneContainer;
        reviewContainer.style.display = 'inline-flex';
        reviewContainer.appendChild(this.initPaneHeader(localValue));
        this.initCommentPane();
    };
    CommentReviewPane.prototype.initPaneHeader = function (localValue) {
        this.headerContainer = createElement('div');
        this.reviewPane = createElement('div', { className: 'e-de-cmt-pane', styles: 'display:none' });
        if (this.owner.enableRtl) {
            classList(this.reviewPane, ['e-rtl'], []);
        }
        var headerWholeDiv = createElement('div', { className: 'e-de-cp-whole-header' });
        var headerDiv1 = createElement('div', {
            innerHTML: localValue.getConstant('Comments'), className: 'e-de-cp-header'
        });
        this.closeButton = createElement('button', {
            className: 'e-de-cp-close e-btn e-flat e-icon-btn', id: 'close',
            attrs: { type: 'button' }
        });
        this.closeButton.title = localValue.getConstant('Close');
        headerWholeDiv.appendChild(this.closeButton);
        headerWholeDiv.appendChild(headerDiv1);
        var closeSpan = createElement('span', { className: 'e-de-op-close-icon e-btn-icon e-icons' });
        this.closeButton.appendChild(closeSpan);
        this.headerContainer.appendChild(headerWholeDiv);
        this.headerContainer.appendChild(this.initToolbar(localValue));
        this.reviewPane.appendChild(this.headerContainer);
        this.closeButton.addEventListener('click', this.closePane.bind(this));
        return this.reviewPane;
    };
    CommentReviewPane.prototype.closePane = function () {
        if (this.commentPane && this.commentPane.isEditMode) {
            if (!isNullOrUndefined(this.commentPane.currentEditingComment)
                && this.commentPane.isInsertingReply && this.commentPane.currentEditingComment.replyViewTextBox.value === '') {
                this.owner.viewer.currentSelectedComment = undefined;
                this.commentPane.currentEditingComment.cancelReply();
                this.owner.showComments = false;
            }
            else if (this.isNewComment || !isNullOrUndefined(this.commentPane.currentEditingComment)
                && this.commentPane.isInsertingReply && this.commentPane.currentEditingComment.replyViewTextBox.value !== '' ||
                !isNullOrUndefined(this.commentPane.currentEditingComment) && !this.commentPane.isInsertingReply &&
                    this.commentPane.currentEditingComment.textArea.value !== this.commentPane.currentEditingComment.comment.text) {
                var localObj = new L10n('documenteditor', this.owner.defaultLocale);
                localObj.setLocale(this.owner.locale);
                this.confirmDialog = DialogUtility.confirm({
                    title: localObj.getConstant('Un-posted comments'),
                    content: localObj.getConstant('Discard Comment'),
                    okButton: {
                        text: 'Discard', click: this.discardButtonClick.bind(this)
                    },
                    cancelButton: {
                        text: 'Cancel', click: this.closeDialogUtils.bind(this)
                    },
                    showCloseIcon: true,
                    closeOnEscape: true,
                    animationSettings: { effect: 'Zoom' },
                    position: { X: 'Center', Y: 'Center' }
                });
            }
            else {
                this.owner.viewer.currentSelectedComment = undefined;
                this.commentPane.currentEditingComment.cancelEditing();
                this.owner.showComments = false;
            }
        }
        else {
            this.owner.viewer.currentSelectedComment = undefined;
            this.owner.showComments = false;
        }
    };
    CommentReviewPane.prototype.discardButtonClick = function () {
        if (this.commentPane.currentEditingComment) {
            var isNewComment = this.isNewComment;
            if (this.commentPane.currentEditingComment && this.commentPane.isInsertingReply) {
                this.commentPane.currentEditingComment.cancelReply();
            }
            else {
                this.commentPane.currentEditingComment.cancelEditing();
                if (isNewComment) {
                    this.discardComment(this.commentPane.currentEditingComment.comment);
                }
            }
            this.owner.viewer.currentSelectedComment = undefined;
            this.closeDialogUtils();
            this.owner.showComments = false;
        }
    };
    CommentReviewPane.prototype.closeDialogUtils = function () {
        this.confirmDialog.close();
        this.confirmDialog = undefined;
    };
    CommentReviewPane.prototype.initToolbar = function (localValue) {
        this.toolbarElement = createElement('div');
        this.toolbar = new Toolbar({
            items: [
                {
                    prefixIcon: 'e-de-new-cmt e-de-cmt-tbr', tooltipText: localValue.getConstant('New Comment'),
                    text: localValue.getConstant('New Comment'), click: this.insertComment.bind(this)
                },
                {
                    prefixIcon: 'e-de-nav-left-arrow e-de-cmt-tbr', align: 'Right',
                    tooltipText: localValue.getConstant('Previous Comment'), click: this.navigatePreviousComment.bind(this)
                },
                {
                    prefixIcon: 'e-de-nav-right-arrow e-de-cmt-tbr', align: 'Right',
                    tooltipText: localValue.getConstant('Next Comment'), click: this.navigateNextComment.bind(this)
                }
            ],
            enableRtl: this.owner.enableRtl
        });
        this.toolbar.appendTo(this.toolbarElement);
        return this.toolbarElement;
    };
    CommentReviewPane.prototype.insertComment = function () {
        if (this.owner && this.owner.editorModule) {
            this.owner.editorModule.insertComment('');
        }
    };
    CommentReviewPane.prototype.addComment = function (comment, isNewComment) {
        this.isNewComment = isNewComment;
        this.owner.viewer.currentSelectedComment = comment;
        this.commentPane.insertComment(comment);
        if (!isNewComment) {
            var commentView = this.commentPane.comments.get(comment);
            commentView.cancelEditing();
            this.enableDisableToolbarItem();
        }
        this.selectComment(comment);
    };
    CommentReviewPane.prototype.deleteComment = function (comment) {
        if (this.commentPane) {
            this.commentPane.deleteComment(comment);
        }
    };
    CommentReviewPane.prototype.selectComment = function (comment) {
        if (this.commentPane.isEditMode) {
            return;
        }
        if (comment.isReply) {
            comment = comment.ownerComment;
        }
        if (this.owner && this.owner.viewer && this.owner.viewer.currentSelectedComment !== comment) {
            this.owner.viewer.currentSelectedComment = comment;
        }
        this.commentPane.selectComment(comment);
    };
    CommentReviewPane.prototype.resolveComment = function (comment) {
        this.commentPane.resolveComment(comment);
    };
    CommentReviewPane.prototype.reopenComment = function (comment) {
        this.commentPane.reopenComment(comment);
    };
    CommentReviewPane.prototype.addReply = function (comment, newComment) {
        this.isNewComment = newComment;
        this.commentPane.insertReply(comment);
        if (!newComment) {
            var commentView = this.commentPane.comments.get(comment);
            commentView.cancelEditing();
            this.enableDisableToolbarItem();
        }
        this.selectComment(comment.ownerComment);
    };
    CommentReviewPane.prototype.navigatePreviousComment = function () {
        if (this.owner && this.owner.editorModule) {
            this.owner.selection.navigatePreviousComment();
        }
    };
    CommentReviewPane.prototype.navigateNextComment = function () {
        if (this.owner && this.owner.editorModule) {
            this.owner.selection.navigateNextComment();
        }
    };
    CommentReviewPane.prototype.enableDisableToolbarItem = function () {
        if (this.toolbar) {
            var enable = true;
            if (this.commentPane.isEditMode) {
                enable = !this.commentPane.isEditMode;
            }
            var elements = this.toolbar.element.querySelectorAll('.' + 'e-de-cmt-tbr');
            this.toolbar.enableItems(elements[0].parentElement.parentElement, enable);
            if (enable && this.owner && this.owner.viewer) {
                enable = !(this.owner.viewer.comments.length === 0);
            }
            this.toolbar.enableItems(elements[1].parentElement.parentElement, enable);
            this.toolbar.enableItems(elements[2].parentElement.parentElement, enable);
        }
    };
    CommentReviewPane.prototype.initCommentPane = function () {
        this.commentPane = new CommentPane(this.owner, this);
        this.commentPane.initCommentPane();
    };
    CommentReviewPane.prototype.layoutComments = function () {
        for (var i = 0; i < this.owner.viewer.comments.length; i++) {
            this.commentPane.addComment(this.owner.viewer.comments[i]);
        }
    };
    CommentReviewPane.prototype.clear = function () {
        this.previousSelectedCommentInt = undefined;
        this.commentPane.clear();
    };
    CommentReviewPane.prototype.discardComment = function (comment) {
        if (comment) {
            if (this.owner.editorHistory) {
                this.owner.editorHistory.undo();
                this.owner.editorHistory.redoStack.pop();
            }
            else if (this.owner.editor) {
                this.owner.editor.deleteCommentInternal(comment);
            }
        }
    };
    CommentReviewPane.prototype.destroy = function () {
        if (this.commentPane) {
            this.commentPane.destroy();
        }
        this.commentPane = undefined;
        if (this.closeButton && this.closeButton.parentElement) {
            this.closeButton.parentElement.removeChild(this.closeButton);
        }
        this.closeButton = undefined;
        if (this.toolbar) {
            this.toolbar.destroy();
        }
        this.toolbar = undefined;
        if (this.toolbarElement && this.toolbarElement.parentElement) {
            this.toolbarElement.parentElement.removeChild(this.toolbarElement);
        }
        this.toolbarElement = undefined;
        if (this.headerContainer && this.headerContainer.parentElement) {
            this.headerContainer.parentElement.removeChild(this.headerContainer);
        }
        this.headerContainer = undefined;
        this.previousSelectedCommentInt = undefined;
        if (this.reviewPane && this.reviewPane.parentElement) {
            this.reviewPane.parentElement.removeChild(this.reviewPane);
        }
        this.reviewPane.innerHTML = '';
        this.reviewPane = undefined;
        this.owner = undefined;
    };
    return CommentReviewPane;
}());
/**
 * @private
 */
var CommentPane = /** @__PURE__ @class */ (function () {
    function CommentPane(owner, pane) {
        this.isEditModeInternal = false;
        this.isInsertingReply = false;
        this.owner = owner;
        this.parentPane = pane;
        this.parent = pane.reviewPane;
        this.comments = new Dictionary();
    }
    Object.defineProperty(CommentPane.prototype, "isEditMode", {
        /**
         * @private
         */
        get: function () {
            return this.isEditModeInternal;
        },
        /**
         * @private
         */
        set: function (value) {
            this.isEditModeInternal = value;
            var keys = this.comments.keys;
            for (var i = 0; i < keys.length; i++) {
                var commentView = this.comments.get(keys[i]);
                if (value) {
                    commentView.menuBar.style.display = 'none';
                }
                else if (!commentView.comment.isReply) {
                    commentView.menuBar.style.display = 'block';
                }
            }
            if (this.parentPane) {
                this.parentPane.enableDisableToolbarItem();
            }
            if (this.owner) {
                if (this.isEditModeInternal) {
                    this.owner.trigger('commentBegin');
                }
                else {
                    this.owner.trigger('commentEnd');
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    CommentPane.prototype.initCommentPane = function () {
        this.commentPane = createElement('div', { className: 'e-de-cmt-container' });
        var localObj = new L10n('documenteditor', this.owner.defaultLocale);
        localObj.setLocale(this.owner.locale);
        this.noCommentIndicator = createElement('div', {
            className: 'e-de-cmt-no-cmt',
            innerHTML: localObj.getConstant('No comments in this document')
        });
        this.commentPane.appendChild(this.noCommentIndicator);
        this.parent.appendChild(this.commentPane);
    };
    CommentPane.prototype.addComment = function (comment) {
        var commentView = new CommentView(this.owner, this, comment);
        var commentParent = commentView.layoutComment(false);
        this.comments.add(comment, commentView);
        this.commentPane.appendChild(commentParent);
        for (var i = 0; i < comment.replyComments.length; i++) {
            var replyView = new CommentView(this.owner, this, comment.replyComments[i]);
            this.comments.add(comment.replyComments[i], replyView);
            commentParent.insertBefore(replyView.layoutComment(true), commentView.replyViewContainer);
        }
        this.updateCommentStatus();
        commentView.hideDrawer();
    };
    CommentPane.prototype.updateHeight = function () {
        this.commentPane.style.height = this.parent.clientHeight - this.parentPane.headerContainer.clientHeight + 'px';
    };
    CommentPane.prototype.insertReply = function (replyComment) {
        var parentComment = replyComment.ownerComment;
        var parentView = this.comments.get(parentComment);
        var replyView = new CommentView(this.owner, this, replyComment);
        this.comments.add(replyComment, replyView);
        var replyElement = replyView.layoutComment(true);
        var replyIndex = parentComment.replyComments.indexOf(replyComment);
        if (replyIndex === parentComment.replyComments.length - 1) {
            parentView.parentElement.insertBefore(replyElement, parentView.replyViewContainer);
        }
        else {
            var nextReply = parentComment.replyComments[replyIndex + 1];
            parentView.parentElement.insertBefore(replyElement, this.comments.get(nextReply).parentElement);
        }
        replyView.editComment();
    };
    CommentPane.prototype.insertComment = function (comment) {
        var commentView = new CommentView(this.owner, this, comment);
        var commentParent = commentView.layoutComment(false);
        this.comments.add(comment, commentView);
        if (this.owner.viewer.comments.indexOf(comment) === this.owner.viewer.comments.length - 1) {
            this.commentPane.appendChild(commentParent);
        }
        else {
            var index = this.owner.viewer.comments.indexOf(comment);
            var element = this.comments.get(this.owner.viewer.comments[index + 1]).parentElement;
            this.commentPane.insertBefore(commentParent, element);
            commentParent.focus();
        }
        this.updateCommentStatus();
        commentView.editComment();
    };
    CommentPane.prototype.removeSelectionMark = function (className) {
        if (this.parent) {
            var elements = this.parent.getElementsByClassName(className);
            for (var i = 0; i < elements.length; i++) {
                classList(elements[i], [], [className]);
            }
        }
    };
    CommentPane.prototype.selectComment = function (comment) {
        this.removeSelectionMark('e-de-cmt-selection');
        if (comment.isReply) {
            comment = comment.ownerComment;
        }
        if (comment) {
            var commentView = this.comments.get(comment);
            var selectedElement = commentView.parentElement;
            if (selectedElement) {
                classList(selectedElement, ['e-de-cmt-selection'], []);
                selectedElement.focus();
            }
            var commentStart = this.getCommentStart(comment);
            if (!commentStart.commentMark) {
                commentStart.renderCommentMark();
            }
            classList(commentStart.commentMark, ['e-de-cmt-mark-selected'], []);
            commentView.showDrawer();
        }
    };
    CommentPane.prototype.getCommentStart = function (comment) {
        var commentStart = undefined;
        if (comment && comment.commentStart) {
            commentStart = comment.commentStart;
        }
        return this.getFirstCommentInLine(commentStart);
    };
    CommentPane.prototype.getFirstCommentInLine = function (commentStart) {
        for (var i = 0; i < commentStart.line.children.length; i++) {
            var startComment = commentStart.line.children[i];
            if (startComment instanceof CommentCharacterElementBox && startComment.commentType === 0) {
                return startComment;
            }
        }
        return commentStart;
    };
    CommentPane.prototype.deleteComment = function (comment) {
        var commentView = this.comments.get(comment);
        if (commentView.parentElement && commentView.parentElement.parentElement) {
            commentView.parentElement.parentElement.removeChild(commentView.parentElement);
        }
        //this.commentPane.removeChild();
        this.comments.remove(comment);
        commentView.destroy();
        this.updateCommentStatus();
    };
    CommentPane.prototype.resolveComment = function (comment) {
        var commentView = this.comments.get(comment);
        if (commentView) {
            commentView.resolveComment();
        }
    };
    CommentPane.prototype.reopenComment = function (comment) {
        var commentView = this.comments.get(comment);
        if (commentView) {
            commentView.reopenComment();
        }
    };
    CommentPane.prototype.updateCommentStatus = function () {
        if (this.owner.viewer.comments.length === 0) {
            if (!this.noCommentIndicator.parentElement) {
                this.commentPane.appendChild(this.noCommentIndicator);
            }
            this.noCommentIndicator.style.display = 'block';
        }
        else {
            this.noCommentIndicator.style.display = 'none';
        }
        if (this.parentPane) {
            this.parentPane.enableDisableToolbarItem();
        }
    };
    CommentPane.prototype.clear = function () {
        this.isEditMode = false;
        this.currentEditingComment = undefined;
        this.isInsertingReply = false;
        this.removeChildElements();
        this.commentPane.innerHTML = '';
        this.updateCommentStatus();
    };
    CommentPane.prototype.removeChildElements = function () {
        var comments = this.comments.keys;
        for (var i = 0; i < comments.length; i++) {
            this.comments.get(comments[i]).destroy();
        }
        this.comments.clear();
    };
    CommentPane.prototype.destroy = function () {
        this.removeChildElements();
        if (this.noCommentIndicator && this.noCommentIndicator) {
            this.noCommentIndicator.parentElement.removeChild(this.noCommentIndicator);
        }
        this.noCommentIndicator = undefined;
        if (this.commentPane && this.commentPane.parentElement) {
            this.commentPane.parentElement.removeChild(this.commentPane);
        }
        this.commentPane.innerHTML = '';
        this.parentPane = undefined;
        this.owner = undefined;
    };
    return CommentPane;
}());
/**
 * @private
 */
var CommentView = /** @__PURE__ @class */ (function () {
    function CommentView(owner, commentPane, comment) {
        this.isReply = false;
        this.isDrawerExpand = false;
        this.owner = owner;
        this.comment = comment;
        this.commentPane = commentPane;
    }
    CommentView.prototype.layoutComment = function (isReply) {
        this.isReply = isReply;
        var classList$$1 = 'e-de-cmt-sub-container';
        if (isReply) {
            classList$$1 += ' e-de-cmt-reply';
        }
        var localObj = new L10n('documenteditor', this.owner.defaultLocale);
        localObj.setLocale(this.owner.locale);
        this.parentElement = createElement('div', { className: classList$$1 });
        this.initCommentHeader(localObj);
        this.initCommentView(localObj);
        this.initDateView();
        if (!this.comment.isReply) {
            this.parentElement.tabIndex = 0;
            this.initReplyView(localObj);
            this.initResolveOption(localObj);
            this.initDrawer();
            if (this.comment.isResolved) {
                this.resolveComment();
            }
        }
        else {
            this.menuBar.style.display = 'none';
        }
        this.commentView.addEventListener('mouseenter', this.showMenuItems.bind(this));
        this.commentView.addEventListener('mouseleave', this.hideMenuItemOnMouseLeave.bind(this));
        return this.parentElement;
    };
    CommentView.prototype.initCommentHeader = function (localObj) {
        var commentDiv = createElement('div', { className: 'e-de-cmt-view' });
        var commentUserInfo = createElement('div', { className: 'e-de-cmt-author' });
        var userName = createElement('div', { className: 'e-de-cmt-author-name' });
        userName.textContent = this.comment.author;
        //if (this.comment.author === this.owner.currentUser) {
        this.menuBar = createElement('button', { className: 'e-de-cp-option' });
        var userOption = [{ text: localObj.getConstant('Edit') },
            { text: localObj.getConstant('Delete') },
            { text: localObj.getConstant('Reply') },
            { text: localObj.getConstant('Resolve') }];
        var menuItem = new DropDownButton({
            items: this.isReply ? userOption.splice(0, 2) : userOption,
            select: this.userOptionSelectEvent.bind(this),
            iconCss: 'e-de-menu-icon',
            cssClass: 'e-caret-hide',
            enableRtl: this.owner.enableRtl
        });
        menuItem.appendTo(this.menuBar);
        commentUserInfo.appendChild(this.menuBar);
        this.dropDownButton = menuItem;
        //}
        commentUserInfo.appendChild(userName);
        commentDiv.appendChild(commentUserInfo);
        this.commentView = commentDiv;
        this.parentElement.appendChild(commentDiv);
        commentDiv.addEventListener('click', this.selectComment.bind(this));
    };
    CommentView.prototype.selectComment = function (event) {
        if (this.commentPane) {
            if (!this.commentPane.isEditMode) {
                this.owner.selection.selectComment(this.comment);
            }
            else if (this.commentPane.isEditMode && this.commentPane.isInsertingReply
                && this.commentPane.currentEditingComment && this.commentPane.currentEditingComment.replyViewTextBox.value === '') {
                var comment = this.comment;
                if (comment && comment.isReply) {
                    comment = this.comment.ownerComment;
                }
                if (comment && this.owner.viewer.currentSelectedComment === comment) {
                    return;
                }
                this.commentPane.currentEditingComment.cancelReply();
                this.owner.selection.selectComment(this.comment);
            }
        }
    };
    CommentView.prototype.initCommentView = function (localObj) {
        this.commentText = createElement('div', { className: 'e-de-cmt-readonly' });
        this.commentText.innerText = this.comment.text;
        this.commentView.appendChild(this.commentText);
        this.initEditView(localObj);
    };
    CommentView.prototype.initEditView = function (localObj) {
        this.textAreaContainer = createElement('div', { styles: 'display:none' });
        this.textArea = createElement('textarea', { className: 'e-de-cmt-textarea e-input' });
        this.textArea.placeholder = localObj.getConstant('Type your comment here');
        this.textArea.rows = 1;
        this.textArea.value = this.comment.text.trim();
        this.textArea.addEventListener('keydown', this.updateTextAreaHeight.bind(this));
        this.textArea.addEventListener('keyup', this.enableDisablePostButton.bind(this));
        var editRegionFooter = createElement('div', { className: 'e-de-cmt-action-button' });
        var postButton = createElement('button', { className: 'e-de-cmt-post-btn e-btn e-flat' });
        //tslint:disable-next-line:max-line-length
        this.postButton = new Button({ cssClass: 'e-btn e-flat e-primary', iconCss: 'e-de-cmt-post', disabled: true }, postButton);
        postButton.addEventListener('click', this.postComment.bind(this));
        var cancelButton = createElement('button', {
            className: 'e-de-cmt-cancel-btn e-btn e-flat'
        });
        this.cancelButton = new Button({ cssClass: 'e-btn e-flat', iconCss: 'e-de-cmt-cancel' }, cancelButton);
        cancelButton.addEventListener('click', this.cancelEditing.bind(this));
        editRegionFooter.appendChild(postButton);
        editRegionFooter.appendChild(cancelButton);
        this.textAreaContainer.appendChild(this.textArea);
        this.textAreaContainer.appendChild(editRegionFooter);
        this.commentView.appendChild(this.textAreaContainer);
    };
    CommentView.prototype.initDateView = function () {
        this.commentDate = createElement('div', { className: 'e-de-cmt-date' });
        var modifiedDate = new Date(this.comment.date);
        var date = modifiedDate.toString().split(' ').splice(1, 2).join(' ');
        var time = modifiedDate.toLocaleTimeString().split(' ')[0].split(':').splice(0, 2).join(':')
            + modifiedDate.toLocaleTimeString().split(' ')[1];
        this.commentDate.innerText = date + ', ' + modifiedDate.getFullYear() + ', ' + time;
        this.commentView.appendChild(this.commentDate);
    };
    CommentView.prototype.initDrawer = function () {
        this.drawerElement = createElement('div', { styles: 'display:none;', className: 'e-de-cmt-drawer-cnt' });
        var leftPane = createElement('div', { className: 'e-de-cmt-drawer' });
        var spanElement = createElement('span');
        leftPane.appendChild(spanElement);
        this.drawerElement.appendChild(leftPane);
        this.drawerSpanElement = spanElement;
        this.drawerAction = leftPane;
        this.drawerAction.addEventListener('click', this.showOrHideDrawer.bind(this));
        this.parentElement.appendChild(this.drawerElement);
    };
    CommentView.prototype.initReplyView = function (localObj) {
        this.replyViewContainer = createElement('div', { className: 'e-de-cmt-rply-view' });
        if (this.commentPane.parentPane.isNewComment) {
            this.replyViewContainer.style.display = 'none';
        }
        this.replyViewTextBox = createElement('textarea', { className: 'e-de-cmt-textarea e-input' });
        this.replyViewTextBox.placeholder = localObj.getConstant('Reply');
        this.replyViewTextBox.rows = 1;
        this.replyViewTextBox.value = '';
        this.replyViewTextBox.readOnly = true;
        this.replyViewTextBox.addEventListener('click', this.enableReplyView.bind(this));
        this.replyViewTextBox.addEventListener('keydown', this.updateReplyTextAreaHeight.bind(this));
        this.replyViewTextBox.addEventListener('keyup', this.enableDisableReplyPostButton.bind(this));
        var editRegionFooter = createElement('div', { styles: 'display:none', className: 'e-de-cmt-action-button' });
        var postButton = createElement('button', { className: 'e-de-cmt-post-btn e-btn e-flat' });
        //tslint:disable-next-line:max-line-length
        this.replyPostButton = new Button({ cssClass: 'e-btn e-flat e-primary', iconCss: 'e-de-cmt-post', disabled: true }, postButton);
        postButton.addEventListener('click', this.postReply.bind(this));
        var cancelButton = createElement('button', {
            className: 'e-de-cmt-cancel-btn e-btn e-flat'
        });
        this.replyCancelButton = new Button({ cssClass: 'e-btn e-flat', iconCss: 'e-de-cmt-cancel' }, cancelButton);
        cancelButton.addEventListener('click', this.cancelReply.bind(this));
        editRegionFooter.appendChild(postButton);
        editRegionFooter.appendChild(cancelButton);
        this.replyFooter = editRegionFooter;
        this.replyViewContainer.appendChild(this.replyViewTextBox);
        this.replyViewContainer.appendChild(editRegionFooter);
        this.parentElement.appendChild(this.replyViewContainer);
    };
    CommentView.prototype.initResolveOption = function (localObj) {
        var editRegionFooter = createElement('div', { className: 'e-de-cmt-resolve-btn' });
        var postButton = createElement('button', { className: 'e-de-cmt-post-btn e-btn e-flat' });
        //tslint:disable-next-line:max-line-length
        this.reopenButton = new Button({ cssClass: 'e-btn e-flat', iconCss: 'e-de-cmt-reopen' }, postButton);
        postButton.title = localObj.getConstant('Reopen');
        postButton.addEventListener('click', this.reopenButtonClick.bind(this));
        var cancelButton = createElement('button', {
            className: 'e-de-cmt-cancel-btn e-btn e-flat'
        });
        cancelButton.title = localObj.getConstant('Delete');
        this.deleteButton = new Button({ cssClass: 'e-btn e-flat', iconCss: 'e-de-cmt-delete' }, cancelButton);
        cancelButton.addEventListener('click', this.deleteButtonClick.bind(this));
        editRegionFooter.appendChild(postButton);
        editRegionFooter.appendChild(cancelButton);
        this.parentElement.appendChild(editRegionFooter);
    };
    CommentView.prototype.reopenButtonClick = function () {
        this.owner.editor.reopenComment(this.comment);
    };
    CommentView.prototype.deleteButtonClick = function () {
        this.owner.editorModule.deleteCommentInternal(this.comment);
    };
    CommentView.prototype.updateReplyTextAreaHeight = function () {
        var _this = this;
        setTimeout(function () {
            _this.replyViewTextBox.style.height = 'auto';
            var scrollHeight = _this.replyViewTextBox.scrollHeight;
            _this.replyViewTextBox.style.height = scrollHeight + 'px';
        });
    };
    CommentView.prototype.enableDisableReplyPostButton = function () {
        this.replyPostButton.disabled = this.replyViewTextBox.value === '';
    };
    CommentView.prototype.enableReplyView = function () {
        var _this = this;
        if (this.commentPane.isEditMode) {
            return;
        }
        this.commentPane.currentEditingComment = this;
        this.commentPane.isInsertingReply = true;
        if (this.owner.viewer.currentSelectedComment !== this.comment) {
            this.owner.selection.selectComment(this.comment);
        }
        this.commentPane.isEditMode = true;
        this.replyViewTextBox.readOnly = false;
        this.replyFooter.style.display = 'block';
        setTimeout(function () {
            _this.replyViewTextBox.focus();
        });
    };
    CommentView.prototype.postReply = function () {
        var replyText = this.replyViewTextBox.value;
        this.cancelReply();
        this.updateReplyTextAreaHeight();
        this.owner.editorModule.replyComment(this.comment, replyText);
    };
    CommentView.prototype.cancelReply = function () {
        this.commentPane.currentEditingComment = undefined;
        this.commentPane.isInsertingReply = true;
        this.commentPane.isEditMode = false;
        this.replyPostButton.disabled = true;
        this.replyViewTextBox.value = '';
        this.replyViewTextBox.readOnly = true;
        this.replyFooter.style.display = 'none';
    };
    CommentView.prototype.updateTextAreaHeight = function () {
        var _this = this;
        setTimeout(function () {
            _this.textArea.style.height = 'auto';
            var scrollHeight = _this.textArea.scrollHeight;
            _this.textArea.style.height = scrollHeight + 'px';
        });
    };
    CommentView.prototype.showMenuItems = function () {
        if (this.comment.isReply) {
            if (!this.commentPane.isEditMode && (!isNullOrUndefined(this.comment) && !this.comment.isResolved)) {
                this.menuBar.style.display = 'block';
            }
        }
        var commentStart = this.commentPane.getCommentStart(this.comment);
        if (!isNullOrUndefined(commentStart) && !isNullOrUndefined(commentStart.commentMark)) {
            commentStart.commentMark.classList.add('e-de-cmt-mark-hover');
        }
    };
    CommentView.prototype.hideMenuItemOnMouseLeave = function () {
        if (this.comment.isReply) {
            if (this.owner.viewer.currentSelectedComment !== this.comment.ownerComment) {
                this.hideMenuItems();
            }
        }
        if (this.commentPane) {
            var commentStart = this.commentPane.getCommentStart(this.comment);
            if (!isNullOrUndefined(commentStart) && !isNullOrUndefined(commentStart.commentMark)) {
                commentStart.commentMark.classList.remove('e-de-cmt-mark-hover');
            }
        }
    };
    CommentView.prototype.hideMenuItems = function () {
        this.menuBar.style.display = 'none';
    };
    CommentView.prototype.enableDisablePostButton = function () {
        this.postButton.disabled = this.textArea.value === '';
    };
    CommentView.prototype.editComment = function () {
        var _this = this;
        this.commentPane.currentEditingComment = this;
        this.commentPane.isInsertingReply = false;
        this.commentPane.isEditMode = true;
        this.commentText.style.display = 'none';
        this.textAreaContainer.style.display = 'block';
        this.commentDate.style.display = 'none';
        this.menuBar.style.display = 'none';
        this.updateTextAreaHeight();
        setTimeout(function () {
            _this.textArea.focus();
        });
    };
    CommentView.prototype.resolveComment = function () {
        classList(this.parentElement, ['e-de-cmt-resolved'], []);
        var localObj = new L10n('documenteditor', this.owner.defaultLocale);
        localObj.setLocale(this.owner.locale);
        this.dropDownButton.items = [{ text: localObj.getConstant('Reopen') }, { text: localObj.getConstant('Delete') }];
    };
    CommentView.prototype.reopenComment = function () {
        classList(this.parentElement, [], ['e-de-cmt-resolved']);
        var localObj = new L10n('documenteditor', this.owner.defaultLocale);
        localObj.setLocale(this.owner.locale);
        this.dropDownButton.items = [{ text: localObj.getConstant('Edit') },
            { text: localObj.getConstant('Delete') },
            { text: localObj.getConstant('Reply') },
            { text: localObj.getConstant('Resolve') }];
        this.showDrawer();
    };
    CommentView.prototype.postComment = function () {
        var updatedText = this.textArea.value;
        this.commentText.innerText = updatedText;
        this.comment.text = updatedText;
        this.showCommentView();
        if (this.commentPane && this.commentPane.parentPane) {
            this.commentPane.parentPane.isNewComment = false;
        }
        if (!isNullOrUndefined(this.replyViewContainer)) {
            this.replyViewContainer.style.display = '';
        }
    };
    CommentView.prototype.showCommentView = function () {
        this.commentPane.isEditMode = false;
        this.textAreaContainer.style.display = 'none';
        this.commentText.style.display = 'block';
        this.commentDate.style.display = 'block';
        this.menuBar.style.display = 'block';
    };
    CommentView.prototype.cancelEditing = function () {
        this.showCommentView();
        this.textArea.value = this.comment.text.trim();
        if (this.commentPane.parentPane.isNewComment) {
            if (this.commentPane && this.commentPane.parentPane) {
                this.commentPane.parentPane.isNewComment = false;
            }
            this.commentPane.parentPane.discardComment(this.comment);
        }
    };
    CommentView.prototype.showOrHideDrawer = function () {
        if (this.isDrawerExpand) {
            this.hideDrawer();
        }
        else {
            this.showDrawer();
        }
    };
    CommentView.prototype.hideDrawer = function () {
        if (this.parentElement) {
            var localObj = new L10n('documenteditor', this.owner.defaultLocale);
            localObj.setLocale(this.owner.locale);
            var elements = this.parentElement.getElementsByClassName('e-de-cmt-sub-container');
            if (elements.length > 1) {
                for (var i = 1; i < elements.length; i++) {
                    elements[i].style.display = 'none';
                }
                this.drawerElement.style.display = 'block';
                classList(this.drawerSpanElement, [], ['e-de-nav-up']);
                this.drawerSpanElement.innerText = '+' + (elements.length - 1) + ' ' + localObj.getConstant('more') + '...';
            }
            this.isDrawerExpand = false;
        }
    };
    CommentView.prototype.showDrawer = function () {
        if (this.parentElement) {
            var elements = this.parentElement.getElementsByClassName('e-de-cmt-sub-container');
            if (elements.length > 1) {
                for (var i = 0; i < elements.length; i++) {
                    elements[i].style.display = 'block';
                }
                this.drawerElement.style.display = 'block';
                this.drawerSpanElement.innerText = '';
                classList(this.drawerSpanElement, ['e-de-nav-up'], []);
            }
            this.isDrawerExpand = true;
        }
    };
    CommentView.prototype.userOptionSelectEvent = function (event) {
        var selectedItem = event.item.text;
        var localObj = new L10n('documenteditor', this.owner.defaultLocale);
        localObj.setLocale(this.owner.locale);
        switch (selectedItem) {
            case localObj.getConstant('Edit'):
                this.editComment();
                break;
            case localObj.getConstant('Reply'):
                this.enableReplyView();
                break;
            case localObj.getConstant('Delete'):
                this.owner.editorModule.deleteCommentInternal(this.comment);
                break;
            case localObj.getConstant('Resolve'):
                this.owner.editor.resolveComment(this.comment);
                break;
            case localObj.getConstant('Reopen'):
                this.owner.editor.reopenComment(this.comment);
        }
    };
    CommentView.prototype.unwireEvent = function () {
        if (this.drawerAction) {
            this.drawerAction.removeEventListener('click', this.showOrHideDrawer.bind(this));
        }
        if (this.textArea) {
            this.textArea.removeEventListener('keydown', this.updateTextAreaHeight.bind(this));
            this.textArea.removeEventListener('keyup', this.enableDisablePostButton.bind(this));
        }
        if (this.postButton) {
            this.postButton.removeEventListener('click', this.postComment.bind(this));
        }
        if (this.cancelButton) {
            this.cancelButton.removeEventListener('click', this.cancelEditing.bind(this));
        }
        if (this.commentView) {
            this.commentView.removeEventListener('click', this.selectComment.bind(this));
            this.commentView.removeEventListener('mouseenter', this.showMenuItems.bind(this));
            this.commentView.removeEventListener('mouseleave', this.hideMenuItemOnMouseLeave.bind(this));
        }
    };
    CommentView.prototype.destroy = function () {
        this.unwireEvent();
        if (this.comment) {
            this.comment = undefined;
        }
        if (this.dropDownButton) {
            this.dropDownButton.destroy();
        }
        this.dropDownButton = undefined;
        if (this.postButton) {
            this.postButton.destroy();
        }
        this.postButton = undefined;
        if (this.cancelButton) {
            this.cancelButton.destroy();
        }
        if (this.replyPostButton) {
            this.replyPostButton.destroy();
            this.replyPostButton = undefined;
        }
        if (this.replyCancelButton) {
            this.replyCancelButton.destroy();
            this.replyCancelButton = undefined;
        }
        if (this.reopenButton) {
            this.reopenButton.destroy();
            this.reopenButton = undefined;
        }
        if (this.deleteButton) {
            this.deleteButton.destroy();
            this.deleteButton = undefined;
        }
        this.replyViewContainer = undefined;
        this.replyViewTextBox = undefined;
        this.replyFooter = undefined;
        if (this.parentElement && this.parentElement.parentElement) {
            this.parentElement.parentElement.removeChild(this.parentElement);
        }
        this.commentPane = undefined;
        this.parentElement.innerHTML = '';
        this.cancelButton = undefined;
        this.owner = undefined;
        this.menuBar = undefined;
        this.commentView = undefined;
        this.drawerAction = undefined;
        this.commentText = undefined;
        this.commentDate = undefined;
        this.textAreaContainer = undefined;
        this.textArea = undefined;
        this.drawerElement = undefined;
        this.drawerSpanElement = undefined;
        this.parentElement = null;
    };
    return CommentView;
}());

/**
 * Comments
 */

/**
 * Document Editor implementation
 */

/**
 * export document editor
 */

var TOOLBAR_ID = '_toolbar';
var NEW_ID = '_new';
var OPEN_ID = '_open';
var UNDO_ID = '_undo';
var REDO_ID = '_redo';
var INSERT_IMAGE_ID = '_image';
var INSERT_IMAGE_LOCAL_ID = '_image_local';
var INSERT_IMAGE_ONLINE_ID = '_image_url';
var INSERT_TABLE_ID = '_table';
var INSERT_LINK_ID = '_link';
var BOOKMARK_ID = '_bookmark';
var COMMENT_ID = '_comment';
var TABLE_OF_CONTENT_ID = '_toc';
var HEADER_ID = '_header';
var FOOTER_ID = '_footer';
var PAGE_SET_UP_ID = '_page_setup';
var PAGE_NUMBER_ID = '_page_number';
var BREAK_ID = '_break';
var FIND_ID = '_find';
var CLIPBOARD_ID = '_use_local_clipboard';
var RESTRICT_EDITING_ID = '_restrict_edit';
var PAGE_BREAK = '_page_break';
var SECTION_BREAK = '_section_break';
var READ_ONLY = '_read_only';
var PROTECTIONS = '_protections';
/**
 * Toolbar Module
 */
var Toolbar$1 = /** @__PURE__ @class */ (function () {
    /**
     * @private
     */
    function Toolbar$$1(container) {
        /**
         * @private
         */
        this.isCommentEditing = false;
        this.container = container;
        this.importHandler = new XmlHttpRequestHandler();
    }
    Object.defineProperty(Toolbar$$1.prototype, "documentEditor", {
        /**
         * @private
         */
        get: function () {
            return this.container.documentEditor;
        },
        enumerable: true,
        configurable: true
    });
    Toolbar$$1.prototype.getModuleName = function () {
        return 'toolbar';
    };
    /**
     * @private
     */
    Toolbar$$1.prototype.initToolBar = function () {
        this.renderToolBar();
        this.wireEvent();
    };
    // tslint:disable-next-line:max-func-body-length
    Toolbar$$1.prototype.renderToolBar = function () {
        if (isNullOrUndefined(this.container)) {
            return;
        }
        var toolbarContainer = this.container.toolbarContainer;
        var toolbarWrapper = createElement('div', { className: 'e-de-tlbr-wrapper' });
        var toolbarTarget = createElement('div', { className: 'e-de-toolbar', styles: 'height:100%' });
        this.initToolbarItems();
        toolbarWrapper.appendChild(toolbarTarget);
        toolbarContainer.appendChild(toolbarWrapper);
        // Show hide pane button initialization 
        var propertiesPaneDiv = createElement('div', { className: 'e-de-ctnr-properties-pane-btn' });
        var buttonElement = createElement('button', { attrs: { type: 'button' } });
        propertiesPaneDiv.appendChild(buttonElement);
        var cssClassName = 'e-tbar-btn e-tbtn-txt e-control e-btn e-de-showhide-btn';
        var iconCss = 'e-icons e-de-ctnr-showhide';
        if (this.container.enableRtl) {
            cssClassName += '-rtl';
            iconCss = 'e-icons e-de-ctnr-showhide e-de-flip';
        }
        this.propertiesPaneButton = new Button({
            cssClass: cssClassName,
            iconCss: iconCss
        });
        this.propertiesPaneButton.appendTo(buttonElement);
        EventHandler.add(buttonElement, 'click', this.showHidePropertiesPane, this);
        toolbarContainer.appendChild(propertiesPaneDiv);
        this.toolbar.appendTo(toolbarTarget);
        var locale = this.container.localObj;
        var id = this.container.element.id + TOOLBAR_ID;
        var imageButton = toolbarTarget.getElementsByClassName('e-de-image-splitbutton')[0].firstChild;
        var items = {
            items: [
                {
                    text: locale.getConstant('Upload from computer'), iconCss: 'e-icons e-de-ctnr-upload',
                    id: id + INSERT_IMAGE_LOCAL_ID
                }
            ],
            //,{ text: locale.getConstant('By URL'), iconCss: 'e-icons e-de-ctnr-link', id: id + INSERT_IMAGE_ONLINE_ID }],
            cssClass: 'e-de-toolbar-btn-first e-caret-hide',
            iconCss: 'e-icons e-de-ctnr-image',
            select: this.onDropDownButtonSelect.bind(this),
        };
        this.imgDropDwn = new DropDownButton(items, imageButton);
        var breakButton = toolbarTarget.getElementsByClassName('e-de-break-splitbutton')[0].firstChild;
        items = {
            items: [
                { text: locale.getConstant('Page Break'), iconCss: 'e-icons e-de-ctnr-page-break', id: id + PAGE_BREAK },
                { text: locale.getConstant('Section Break'), iconCss: 'e-icons e-de-ctnr-section-break', id: id + SECTION_BREAK }
            ],
            cssClass: 'e-caret-hide',
            iconCss: 'e-icons e-de-ctnr-break',
            select: this.onDropDownButtonSelect.bind(this),
        };
        this.breakDropDwn = new DropDownButton(items, breakButton);
        this.filePicker = createElement('input', {
            attrs: { type: 'file', accept: '.doc,.docx,.rtf,.txt,.htm,.html,.sfdt' }, className: 'e-de-ctnr-file-picker'
        });
        this.imagePicker = createElement('input', {
            attrs: { type: 'file', accept: '.jpg,.jpeg,.png,.bmp' }, className: 'e-de-ctnr-file-picker'
        });
        this.toggleButton(id + CLIPBOARD_ID, this.container.enableLocalPaste);
        this.toggleButton(id + RESTRICT_EDITING_ID, this.container.restrictEditing);
        var restrictEditing = toolbarTarget.getElementsByClassName('e-de-lock-dropdownbutton')[0].firstChild;
        var lockItems = {
            items: [
                { text: locale.getConstant('Read only'), id: id + READ_ONLY },
                { text: locale.getConstant('Protections'), id: id + PROTECTIONS }
            ],
            cssClass: 'e-de-toolbar-btn-first e-caret-hide',
            select: this.onDropDownButtonSelect.bind(this)
        };
        this.restrictDropDwn = new DropDownButton(lockItems, restrictEditing);
    };
    Toolbar$$1.prototype.showHidePropertiesPane = function () {
        if (this.container.propertiesPaneContainer.style.display === 'none') {
            this.container.showPropertiesPane = true;
            this.container.trigger('beforePaneSwitch', { type: 'PropertiesPane' });
        }
        else {
            this.container.showPropertiesPane = false;
        }
        this.enableDisablePropertyPaneButton(this.container.showPropertiesPane);
        this.container.showPropertiesPaneOnSelection();
        this.documentEditor.focusIn();
    };
    Toolbar$$1.prototype.onWrapText = function (text) {
        var content = '';
        var index = text.lastIndexOf(' ');
        content = text.slice(0, index);
        text.slice(index);
        content += '<div class="e-de-text-wrap">' + text.slice(index) + '</div>';
        return content;
    };
    Toolbar$$1.prototype.wireEvent = function () {
        this.propertiesPaneButton.on('click', this.togglePropertiesPane.bind(this));
        EventHandler.add(this.filePicker, 'change', this.onFileChange, this);
        EventHandler.add(this.imagePicker, 'change', this.onImageChange, this);
    };
    // tslint:disable-next-line:max-func-body-length
    Toolbar$$1.prototype.initToolbarItems = function () {
        var id = this.container.element.id + TOOLBAR_ID;
        var locale = this.container.localObj;
        this.toolbar = new Toolbar({
            enableRtl: this.container.enableRtl,
            clicked: this.clickHandler.bind(this),
            items: [
                {
                    prefixIcon: 'e-de-ctnr-new', tooltipText: locale.getConstant('Create a new document'),
                    id: id + NEW_ID, text: locale.getConstant('New'), cssClass: 'e-de-toolbar-btn-start'
                },
                {
                    prefixIcon: 'e-de-ctnr-open', tooltipText: locale.getConstant('Open a document'), id: id + OPEN_ID,
                    text: locale.getConstant('Open'), cssClass: 'e-de-toolbar-btn-last'
                },
                {
                    type: 'Separator', cssClass: 'e-de-separator'
                },
                {
                    prefixIcon: 'e-de-ctnr-undo', tooltipText: locale.getConstant('Undo Tooltip'),
                    id: id + UNDO_ID, text: locale.getConstant('Undo'), cssClass: 'e-de-toolbar-btn-first'
                },
                {
                    prefixIcon: 'e-de-ctnr-redo', tooltipText: locale.getConstant('Redo Tooltip'),
                    id: id + REDO_ID, text: locale.getConstant('Redo'), cssClass: 'e-de-toolbar-btn-last'
                },
                {
                    type: 'Separator', cssClass: 'e-de-separator'
                },
                {
                    tooltipText: locale.getConstant('Insert inline picture from a file'), id: id + INSERT_IMAGE_ID,
                    text: locale.getConstant('Image'), cssClass: 'e-de-toolbar-btn-first e-de-image-splitbutton e-de-image-focus'
                },
                {
                    prefixIcon: 'e-de-ctnr-table', tooltipText: locale.getConstant('Insert a table into the document'),
                    id: id + INSERT_TABLE_ID, text: locale.getConstant('Table'), cssClass: 'e-de-toolbar-btn-middle'
                },
                {
                    prefixIcon: 'e-de-ctnr-link',
                    tooltipText: locale.getConstant('Create Hyperlink'),
                    id: id + INSERT_LINK_ID, text: locale.getConstant('Link'), cssClass: 'e-de-toolbar-btn-middle'
                },
                {
                    prefixIcon: 'e-de-ctnr-bookmark',
                    tooltipText: locale.getConstant('Insert a bookmark in a specific place in this document'),
                    id: id + BOOKMARK_ID, text: locale.getConstant('Bookmark'), cssClass: 'e-de-toolbar-btn-middle'
                },
                {
                    prefixIcon: 'e-de-cnt-cmt-add',
                    tooltipText: locale.getConstant('New comment'),
                    id: id + COMMENT_ID, text: locale.getConstant('Comments'), cssClass: 'e-de-toolbar-btn-middle'
                },
                {
                    prefixIcon: 'e-de-ctnr-tableofcontent',
                    tooltipText: locale.getConstant('Provide an overview of your document by adding a table of contents'),
                    id: id + TABLE_OF_CONTENT_ID, text: this.onWrapText(locale.getConstant('Table of Contents')),
                    cssClass: 'e-de-toolbar-btn-last'
                },
                {
                    type: 'Separator', cssClass: 'e-de-separator'
                },
                {
                    prefixIcon: 'e-de-ctnr-header', tooltipText: locale.getConstant('Add or edit the header'),
                    id: id + HEADER_ID, text: locale.getConstant('Header'), cssClass: 'e-de-toolbar-btn-first'
                },
                {
                    prefixIcon: 'e-de-ctnr-footer', tooltipText: locale.getConstant('Add or edit the footer'),
                    id: id + FOOTER_ID, text: locale.getConstant('Footer'), cssClass: 'e-de-toolbar-btn-middle'
                },
                {
                    prefixIcon: 'e-de-ctnr-pagesetup', tooltipText: locale.getConstant('Open the page setup dialog'),
                    id: id + PAGE_SET_UP_ID, text: this.onWrapText(locale.getConstant('Page Setup')),
                    cssClass: 'e-de-toolbar-btn-middle'
                },
                {
                    prefixIcon: 'e-de-ctnr-pagenumber', tooltipText: locale.getConstant('Add page numbers'),
                    id: id + PAGE_NUMBER_ID, text: this.onWrapText(locale.getConstant('Page Number')),
                    cssClass: 'e-de-toolbar-btn-middle'
                },
                {
                    tooltipText: locale.getConstant('Break'), text: locale.getConstant('Break'), id: BREAK_ID,
                    cssClass: 'e-de-toolbar-btn-last e-de-break-splitbutton'
                },
                {
                    type: 'Separator', cssClass: 'e-de-separator'
                },
                {
                    prefixIcon: 'e-de-ctnr-find', tooltipText: locale.getConstant('Find Text'),
                    id: id + FIND_ID, text: locale.getConstant('Find'), cssClass: 'e-de-toolbar-btn'
                },
                {
                    type: 'Separator', cssClass: 'e-de-separator'
                },
                {
                    prefixIcon: 'e-de-ctnr-paste',
                    tooltipText: locale.getConstant('Toggle between the internal clipboard and system clipboard'),
                    id: id + CLIPBOARD_ID, text: this.onWrapText(locale.getConstant('Local Clipboard')),
                    cssClass: 'e-de-toolbar-btn-first'
                },
                {
                    prefixIcon: 'e-de-ctnr-lock', tooltipText: locale.getConstant('Restrict Editing'), id: id + RESTRICT_EDITING_ID,
                    text: this.onWrapText(locale.getConstant('Restrict Editing')), cssClass: 'e-de-toolbar-btn-end e-de-lock-dropdownbutton'
                }
            ]
        });
    };
    Toolbar$$1.prototype.clickHandler = function (args) {
        var id = this.container.element.id + TOOLBAR_ID;
        switch (args.item.id) {
            case id + NEW_ID:
                this.container.documentEditor.openBlank();
                break;
            case id + OPEN_ID:
                this.filePicker.value = '';
                this.filePicker.click();
                break;
            case id + UNDO_ID:
                this.container.documentEditor.editorHistory.undo();
                break;
            case id + REDO_ID:
                this.container.documentEditor.editorHistory.redo();
                break;
            case id + INSERT_TABLE_ID:
                this.container.documentEditor.showDialog('Table');
                break;
            case id + INSERT_LINK_ID:
                this.container.documentEditor.showDialog('Hyperlink');
                break;
            case id + BOOKMARK_ID:
                this.container.documentEditor.showDialog('Bookmark');
                break;
            case id + COMMENT_ID:
                this.documentEditor.editor.insertComment('');
                break;
            case id + HEADER_ID:
                this.container.documentEditor.selection.goToHeader();
                break;
            case id + TABLE_OF_CONTENT_ID:
                this.onToc();
                break;
            case id + FOOTER_ID:
                this.container.documentEditor.selection.goToFooter();
                break;
            case id + PAGE_SET_UP_ID:
                this.container.documentEditor.showDialog('PageSetup');
                break;
            case id + PAGE_NUMBER_ID:
                this.container.documentEditor.editor.insertPageNumber();
                break;
            case id + FIND_ID:
                this.container.documentEditor.showOptionsPane();
                break;
            case id + CLIPBOARD_ID:
                this.toggleLocalPaste(args.item.id);
                break;
        }
        if (args.item.id !== id + FIND_ID && args.item.id !== id + INSERT_IMAGE_ID) {
            this.container.documentEditor.focusIn();
        }
    };
    Toolbar$$1.prototype.toggleLocalPaste = function (id) {
        this.container.enableLocalPaste = !this.container.enableLocalPaste;
        this.toggleButton(id, this.container.enableLocalPaste);
    };
    Toolbar$$1.prototype.toggleEditing = function (id) {
        this.container.restrictEditing = !this.container.restrictEditing;
        this.container.showPropertiesPane = !this.container.restrictEditing;
        // this.toggleButton(id, this.container.restrictEditing);
    };
    Toolbar$$1.prototype.toggleButton = function (id, toggle) {
        var element = document.getElementById(id);
        if (toggle) {
            classList(element, ['e-btn-toggle'], []);
        }
        else {
            classList(element, [], ['e-btn-toggle']);
        }
    };
    Toolbar$$1.prototype.togglePropertiesPane = function () {
        this.container.showPropertiesPane = !this.container.showPropertiesPane;
    };
    Toolbar$$1.prototype.onDropDownButtonSelect = function (args) {
        var _this = this;
        var parentId = this.container.element.id + TOOLBAR_ID;
        var id = args.item.id;
        if (id === parentId + PAGE_BREAK) {
            this.container.documentEditor.editorModule.insertPageBreak();
        }
        else if (id === parentId + SECTION_BREAK) {
            this.container.documentEditor.editorModule.insertSectionBreak();
        }
        else if (id === parentId + INSERT_IMAGE_LOCAL_ID) {
            this.imagePicker.value = '';
            this.imagePicker.click();
        }
        else if (id === parentId + INSERT_IMAGE_ONLINE_ID) {
            // Need to implement image dialog;
        }
        else if (id === parentId + READ_ONLY) {
            this.container.restrictEditing = !this.container.restrictEditing;
            this.container.showPropertiesPane = !this.container.restrictEditing;
        }
        else if (id === parentId + PROTECTIONS) {
            this.documentEditor.viewer.restrictEditingPane.showHideRestrictPane(true);
        }
        setTimeout(function () { _this.documentEditor.focusIn(); }, 30);
    };
    Toolbar$$1.prototype.onFileChange = function () {
        var _this = this;
        var file = this.filePicker.files[0];
        if (file) {
            if (file.name.substr(file.name.lastIndexOf('.')) === '.sfdt') {
                var fileReader_1 = new FileReader();
                fileReader_1.onload = function () {
                    _this.container.documentEditor.open(fileReader_1.result);
                };
                fileReader_1.readAsText(file);
            }
            else {
                this.convertToSfdt(file);
            }
            this.container.documentEditor.documentName = file.name.substr(0, file.name.lastIndexOf('.'));
        }
    };
    Toolbar$$1.prototype.convertToSfdt = function (file) {
        showSpinner(this.container.containerTarget);
        this.importHandler.url = this.container.serviceUrl + this.container.serverActionSettings.import;
        this.importHandler.onSuccess = this.successHandler.bind(this);
        this.importHandler.onFailure = this.failureHandler.bind(this);
        this.importHandler.onError = this.failureHandler.bind(this);
        this.importHandler.customHeaders = this.container.headers;
        var formData = new FormData();
        formData.append('files', file);
        this.importHandler.send(formData);
    };
    /* tslint:disable:no-any */
    Toolbar$$1.prototype.failureHandler = function (args) {
        if (args.name === 'onError') {
            // tslint:disable-next-line:max-line-length
            DialogUtility.alert({ content: this.container.localObj.getConstant('Error in establishing connection with web server'), closeOnEscape: true, showCloseIcon: true, position: { X: 'Center', Y: 'Center' } });
        }
        else {
            alert('Failed to load the file');
        }
        hideSpinner(this.container.containerTarget);
    };
    Toolbar$$1.prototype.successHandler = function (result) {
        this.container.documentEditor.open(result.data);
        hideSpinner(this.container.containerTarget);
    };
    /* tslint:enable:no-any */
    Toolbar$$1.prototype.onImageChange = function () {
        var _this = this;
        var file = this.imagePicker.files[0];
        var fileReader = new FileReader();
        fileReader.onload = function () {
            _this.insertImage(fileReader.result);
        };
        fileReader.readAsDataURL(file);
    };
    Toolbar$$1.prototype.insertImage = function (data) {
        var image = document.createElement('img');
        var container = this.container;
        image.addEventListener('load', function () {
            container.documentEditor.editor.insertImage(data, this.width, this.height);
        });
        image.src = data;
    };
    /**
     * @private
     */
    Toolbar$$1.prototype.enableDisableInsertComment = function (enable) {
        this.isCommentEditing = !enable;
        var id = this.container.element.id + TOOLBAR_ID;
        var commentId = id + COMMENT_ID;
        var element = document.getElementById(commentId);
        if (!this.container.enableComment && element) {
            this.toolbar.removeItems(element.parentElement);
        }
        else if (element) {
            this.toolbar.enableItems(element.parentElement, enable);
        }
    };
    /**
     * @private
     */
    Toolbar$$1.prototype.enableDisableToolBarItem = function (enable, isProtectedContent) {
        var id = this.container.element.id + TOOLBAR_ID;
        for (var _i = 0, _a = this.toolbar.items; _i < _a.length; _i++) {
            var item = _a[_i];
            var itemId = item.id;
            if (itemId !== id + NEW_ID && itemId !== id + OPEN_ID && itemId !== id + FIND_ID &&
                itemId !== id + CLIPBOARD_ID && itemId !== id + RESTRICT_EDITING_ID && item.type !== 'Separator') {
                if (enable && this.isCommentEditing && itemId === id + COMMENT_ID) {
                    continue;
                }
                var element = document.getElementById(item.id);
                this.toolbar.enableItems(element.parentElement, enable);
            }
        }
        if (!isProtectedContent) {
            classList(this.propertiesPaneButton.element.parentElement, !enable ? ['e-de-overlay'] : [], !enable ? [] : ['e-de-overlay']);
        }
        if (enable) {
            this.enableDisableUndoRedo();
        }
    };
    /**
     * @private
     */
    Toolbar$$1.prototype.enableDisableUndoRedo = function () {
        var id = this.container.element.id + TOOLBAR_ID;
        // tslint:disable-next-line:max-line-length
        this.toolbar.enableItems(document.getElementById(id + UNDO_ID).parentElement, this.container.documentEditor.editorHistory.canUndo());
        this.toolbar.enableItems(document.getElementById(id + REDO_ID).parentElement, this.container.documentEditor.editorHistory.canRedo());
    };
    Toolbar$$1.prototype.onToc = function () {
        if (this.container.previousContext === 'TableOfContents' && this.container.propertiesPaneContainer.style.display === 'none') {
            this.container.showPropertiesPane = false;
            this.documentEditor.focusIn();
            return;
        }
        if (this.container.headerFooterProperties.element.style.display === 'block') {
            this.documentEditor.selection.closeHeaderFooter();
        }
        this.enableDisablePropertyPaneButton(false);
        this.container.showProperties('toc');
    };
    /**
     * @private
     */
    Toolbar$$1.prototype.enableDisablePropertyPaneButton = function (isShow) {
        if (isShow) {
            classList(this.propertiesPaneButton.element.firstChild, ['e-pane-enabled'], ['e-pane-disabled']);
        }
        else {
            classList(this.propertiesPaneButton.element.firstChild, ['e-pane-disabled'], ['e-pane-enabled']);
        }
    };
    /**
     * @private
     */
    Toolbar$$1.prototype.destroy = function () {
        if (this.restrictDropDwn) {
            this.restrictDropDwn.destroy();
            this.restrictDropDwn = undefined;
        }
        if (this.imgDropDwn) {
            this.imgDropDwn.destroy();
            this.imgDropDwn = undefined;
        }
        if (this.breakDropDwn) {
            this.breakDropDwn.destroy();
            this.breakDropDwn = undefined;
        }
        if (this.toolbar) {
            var toolbarElement = this.toolbar.element;
            this.toolbar.destroy();
            this.toolbar = undefined;
            toolbarElement.parentElement.removeChild(toolbarElement);
        }
        this.container = undefined;
    };
    return Toolbar$$1;
}());

/**
 * Export toolbar module
 */

/**
 * Text Properties
 * @private
 */
var Text = /** @__PURE__ @class */ (function () {
    function Text(container, isRtl) {
        var _this = this;
        this.isRetrieving = false;
        this.appliedHighlightColor = 'rgb(255, 255, 0)';
        this.createHighlightColorSplitButton = function (id, width, divElement, toolTipText) {
            var buttonElement = createElement('button', { id: id, attrs: { type: 'button' } });
            // buttonElement.style.width = width + 'px';
            // buttonElement.style.padding = '1px';
            // buttonElement.style.height = 30 + 'px';
            divElement.appendChild(buttonElement);
            var hgltSplitObj = new SplitButton({
                cssClass: 'e-de-btn-hghlclr',
                iconCss: 'e-de-ctnr-hglt-color',
                target: _this.highlightColorElement, close: _this.closePopup, beforeOpen: _this.openPopup, enableRtl: _this.isRtl
            });
            hgltSplitObj.appendTo(buttonElement);
            hgltSplitObj.click = function () {
                _this.applyHighlightColor(_this.highlightColorInputElement.style.backgroundColor);
            };
            hgltSplitObj.element.firstChild.style.backgroundColor = 'rgb(255, 255, 0)';
            hgltSplitObj.element.parentElement.setAttribute('title', toolTipText);
            return hgltSplitObj;
        };
        this.openPopup = function () {
            _this.highlightColorElement.style.display = 'block';
        };
        this.closePopup = function () {
            _this.highlightColorElement.style.display = 'none';
        };
        /* tslint:disable:no-any */
        this.onHighLightColor = function (event) {
            if (_this.documentEditor.selection) {
                _this.applyHighlightColor(event.currentTarget.style.backgroundColor);
                _this.highlightColor.toggle();
            }
        };
        this.applyHighlightColorAsBackground = function (color) {
            _this.removeSelectedColorDiv();
            if (color === 'NoColor') {
                _this.highlightColorElement.querySelector('#noColorDiv').classList.add('e-color-selected');
            }
            else if (color === 'Yellow') {
                _this.highlightColorElement.querySelector('#yellowDiv').classList.add('e-color-selected');
            }
            else if (color === 'BrightGreen') {
                _this.highlightColorElement.querySelector('#brightGreenDiv').classList.add('e-color-selected');
            }
            else if (color === 'Turquoise') {
                _this.highlightColorElement.querySelector('#turquoiseDiv').classList.add('e-color-selected');
            }
            else if (color === 'Pink') {
                _this.highlightColorElement.querySelector('#hotPinkDiv').classList.add('e-color-selected');
            }
            else if (color === 'Red') {
                _this.highlightColorElement.querySelector('#redDiv').classList.add('e-color-selected');
            }
            else if (color === 'DarkBlue') {
                _this.highlightColorElement.querySelector('#darkBlueDiv').classList.add('e-color-selected');
            }
            else if (color === 'Teal') {
                _this.highlightColorElement.querySelector('#tealDiv').classList.add('e-color-selected');
            }
            else if (color === 'Green') {
                _this.highlightColorElement.querySelector('#greenDiv').classList.add('e-color-selected');
            }
            else if (color === 'Violet') {
                _this.highlightColorElement.querySelector('#violetDiv').classList.add('e-color-selected');
            }
            else if (color === 'DarkRed') {
                _this.highlightColorElement.querySelector('#darkRedDiv').classList.add('e-color-selected');
            }
            else if (color === 'DarkYellow') {
                _this.highlightColorElement.querySelector('#darkYellowDiv').classList.add('e-color-selected');
            }
            else if (color === 'Gray50') {
                _this.highlightColorElement.querySelector('#gray50Div').classList.add('e-color-selected');
            }
            else if (color === 'Gray25') {
                _this.highlightColorElement.querySelector('#gray25Div').classList.add('e-color-selected');
            }
            else if (color === 'Black') {
                _this.highlightColorElement.querySelector('#blackDiv').classList.add('e-color-selected');
            }
            else if (color === 'Blue') {
                _this.highlightColorElement.querySelector('#blueDiv').classList.add('e-color-selected');
            }
        };
        this.removeSelectedColorDiv = function () {
            _this.highlightColorElement.querySelector('#noColorDiv').classList.remove('e-color-selected');
            _this.highlightColorElement.querySelector('#yellowDiv').classList.remove('e-color-selected');
            _this.highlightColorElement.querySelector('#brightGreenDiv').classList.remove('e-color-selected');
            _this.highlightColorElement.querySelector('#turquoiseDiv').classList.remove('e-color-selected');
            _this.highlightColorElement.querySelector('#hotPinkDiv').classList.remove('e-color-selected');
            _this.highlightColorElement.querySelector('#redDiv').classList.remove('e-color-selected');
            _this.highlightColorElement.querySelector('#darkBlueDiv').classList.remove('e-color-selected');
            _this.highlightColorElement.querySelector('#tealDiv').classList.remove('e-color-selected');
            _this.highlightColorElement.querySelector('#greenDiv').classList.remove('e-color-selected');
            _this.highlightColorElement.querySelector('#violetDiv').classList.remove('e-color-selected');
            _this.highlightColorElement.querySelector('#darkRedDiv').classList.remove('e-color-selected');
            _this.highlightColorElement.querySelector('#darkYellowDiv').classList.remove('e-color-selected');
            _this.highlightColorElement.querySelector('#gray50Div').classList.remove('e-color-selected');
            _this.highlightColorElement.querySelector('#gray25Div').classList.remove('e-color-selected');
            _this.highlightColorElement.querySelector('#blackDiv').classList.remove('e-color-selected');
        };
        this.applyHighlightColor = function (color) {
            _this.appliedHighlightColor = color;
            var hgltColor = _this.getHighLightColor(color);
            _this.documentEditor.selection.characterFormat.highlightColor = hgltColor;
        };
        this.getHighLightColor = function (color) {
            switch (color) {
                case 'rgb(255, 255, 0)':
                    return 'Yellow';
                case 'rgb(0, 255, 0)':
                    return 'BrightGreen';
                case 'rgb(0, 255, 255)':
                    return 'Turquoise';
                case 'rgb(255, 0, 255)':
                    return 'Pink';
                case 'rgb(0, 0, 255)':
                    return 'Blue';
                case 'rgb(255, 0, 0)':
                    return 'Red';
                case 'rgb(0, 0, 128)':
                    return 'DarkBlue';
                case 'rgb(0, 128, 128)':
                    return 'Teal';
                case 'rgb(0, 128, 0)':
                    return 'Green';
                case 'rgb(128, 0, 128)':
                    return 'Violet';
                case 'rgb(128, 0, 0)':
                    return 'DarkRed';
                case 'rgb(128, 128, 0)':
                    return 'DarkYellow';
                case 'rgb(128, 128, 128)':
                    return 'Gray50';
                case 'rgb(192, 192, 192)':
                    return 'Gray25';
                case 'rgb(0, 0, 0)':
                    return 'Black';
                default:
                    return 'NoColor';
            }
        };
        this.createFontColorPicker = function (id, width, divElement, toolTipText) {
            var inputElement = createElement('input', { id: id, attrs: { 'type': 'color' } });
            inputElement.style.width = width + 'px';
            divElement.appendChild(inputElement);
            // tslint:disable-next-line:max-line-length
            _this.fontColorInputElement = new ColorPicker({ value: '#000000', showButtons: true, enableRtl: _this.isRtl, locale: _this.container.locale }, inputElement);
            _this.fontColorInputElement.element.parentElement.setAttribute('title', toolTipText);
            return inputElement;
        };
        this.boldAction = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.editor) {
                _this.documentEditor.editor.toggleBold();
            }
        };
        this.italicAction = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.editor) {
                _this.documentEditor.editor.toggleItalic();
            }
        };
        this.underlineAction = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.editor) {
                _this.documentEditor.editor.toggleUnderline('Single');
            }
        };
        this.strikethroughAction = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.editor) {
                _this.documentEditor.editor.toggleStrikethrough();
            }
        };
        this.clearFormatAction = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.editor) {
                _this.documentEditor.editor.clearFormatting();
            }
        };
        this.subscriptAction = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.editor) {
                _this.documentEditor.editor.toggleSubscript();
            }
        };
        this.superscriptAction = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.editor) {
                _this.documentEditor.editor.toggleSuperscript();
            }
        };
        this.changeFontColor = function (arg) {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.selection) {
                _this.documentEditor.selection.characterFormat.fontColor = arg.currentValue.hex;
                setTimeout(function () { _this.documentEditor.focusIn(); }, 30);
            }
        };
        this.changeFontFamily = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.selection && _this.fontFamily.value !== '') {
                setTimeout(function () { _this.documentEditor.selection.characterFormat.fontFamily = _this.fontFamily.value; }, 10);
            }
        };
        this.changeFontSize = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.selection && _this.fontSize.value !== '') {
                setTimeout(function () { _this.documentEditor.selection.characterFormat.fontSize = _this.fontSize.value; }, 10);
            }
        };
        this.container = container;
        this.isRtl = isRtl;
    }
    Object.defineProperty(Text.prototype, "documentEditor", {
        get: function () {
            return this.container.documentEditor;
        },
        enumerable: true,
        configurable: true
    });
    Text.prototype.initializeTextPropertiesDiv = function (wholeDiv, isRtl) {
        this.localObj = new L10n('documenteditorcontainer', this.container.defaultLocale, this.container.locale);
        this.textProperties = wholeDiv;
        var element = 'font_properties';
        var textDiv = this.createDiv(element + '_text', wholeDiv);
        classList(textDiv, ['e-de-cntr-pane-padding', 'e-de-prop-separator-line'], []);
        var label = createElement('label', { className: 'e-de-ctnr-prop-label' });
        label.innerHTML = this.localObj.getConstant('Text');
        textDiv.appendChild(label);
        var fontDiv = this.createDiv(element + '_sizeStyle', textDiv, 'display:inline-flex;');
        classList(fontDiv, ['e-de-ctnr-segment'], []);
        if (isRtl) {
            classList(fontDiv, ['e-de-ctnr-segment-rtl'], []);
        }
        var fontFamilyDiv = this.createDiv(element + '_fontFamilyDiv', fontDiv);
        var fontFamily = createElement('input', {
            id: element + '_fontFamily',
            className: 'e-prop-font-style'
        });
        fontFamilyDiv.appendChild(fontFamily);
        classList(fontFamilyDiv, ['e-de-panel-left-width'], []);
        this.createDropDownListForFamily(fontFamily);
        var fontSizeDiv = this.createDiv(element + '_fontSizeDiv', fontDiv);
        var divClassName = 'e-de-ctnr-group-btn e-de-char-fmt-btn-left e-btn-group';
        if (isRtl) {
            divClassName = 'e-rtl ' + divClassName;
        }
        var fontSize = createElement('input', {
            id: element + '_fontSize',
            innerHTML: 'type:number',
            className: 'e-prop-font-style',
        });
        fontSizeDiv.appendChild(fontSize);
        classList(fontSizeDiv, ['e-de-panel-right-width'], []);
        this.createDropDownListForSize(fontSize);
        var propertiesDiv = createElement('div', {
            id: element + '_properties',
            styles: 'display:inline-flex;',
            className: 'e-de-ctnr-segment'
        });
        if (isRtl) {
            classList(propertiesDiv, ['e-de-ctnr-segment-rtl'], []);
        }
        textDiv.appendChild(propertiesDiv);
        var leftDiv = createElement('div', {
            id: element + '_leftDiv',
            className: divClassName, styles: 'display:inline-flex;'
        });
        propertiesDiv.appendChild(leftDiv);
        // tslint:disable-next-line:max-line-length
        this.bold = this.createButtonTemplate(element + '_bold', 'e-de-ctnr-bold e-icons', leftDiv, 'e-de-prop-font-button', '40.5', this.localObj.getConstant('Bold Tooltip'));
        // tslint:disable-next-line:max-line-length
        this.italic = this.createButtonTemplate(element + '_italic', 'e-de-ctnr-italic e-icons', leftDiv, 'e-de-prop-font-button', '40.5', this.localObj.getConstant('Italic Tooltip'));
        // tslint:disable-next-line:max-line-length
        this.underline = this.createButtonTemplate(element + '_underline', 'e-de-ctnr-underline e-icons', leftDiv, 'e-de-prop-font-button', '40.5', this.localObj.getConstant('Underline Tooltip'));
        // tslint:disable-next-line:max-line-length
        this.strikethrough = this.createButtonTemplate(element + '_strikethrough', 'e-de-ctnr-strikethrough e-icons', leftDiv, 'e-de-prop-font-last-button', '40.5', this.localObj.getConstant('Strikethrough'));
        divClassName = 'e-de-ctnr-group-btn e-de-char-fmt-btn-right e-btn-group';
        if (isRtl) {
            divClassName = 'e-rtl ' + divClassName;
        }
        // tslint:disable-next-line:max-line-length
        var rightDiv = createElement('div', { id: element + '_rightDiv', className: divClassName, styles: 'display:inline-flex;' });
        propertiesDiv.appendChild(rightDiv);
        // tslint:disable-next-line:max-line-length
        this.superscript = this.createButtonTemplate(element + '_superscript', 'e-de-ctnr-superscript e-icons', rightDiv, 'e-de-prop-font-button', '38.5', this.localObj.getConstant('Superscript Tooltip'));
        // tslint:disable-next-line:max-line-length
        this.subscript = this.createButtonTemplate(element + '_subscript', 'e-de-ctnr-subscript e-icons', rightDiv, 'e-de-prop-font-last-button', '38.5', this.localObj.getConstant('Subscript Tooltip'));
        // tslint:disable-next-line:max-line-length
        var leftDiv2 = createElement('div', { id: element + '_color', className: 'e-de-font-clr-picker e-de-ctnr-group-btn', styles: 'display:inline-flex;' });
        if (isRtl) {
            classList(leftDiv2, ['e-rtl'], []);
        }
        textDiv.appendChild(leftDiv2);
        // tslint:disable-next-line:max-line-length
        this.fontColor = this.createFontColorPicker(element + '_textColor', 40.5, leftDiv2, this.localObj.getConstant('Font color'));
        classList(leftDiv2.firstElementChild.lastElementChild.lastElementChild.firstChild, ['e-de-ctnr-fontcolor', 'e-icons'], ['e-caret']);
        this.initializeHighlightColorElement();
        // tslint:disable-next-line:max-line-length
        this.highlightColor = this.createHighlightColorSplitButton(element + '_highlightColor', 34.5, leftDiv2, this.localObj.getConstant('Text highlight color'));
        classList(this.highlightColor.element.nextElementSibling.firstElementChild, ['e-de-ctnr-highlight', 'e-icons'], ['e-caret']);
        this.highlightColorInputElement = this.highlightColor.element.firstChild;
        // tslint:disable-next-line:max-line-length
        this.clearFormat = this.createButtonTemplate(element + '_clearFormat', 'e-de-ctnr-clearall e-icons', leftDiv2, 'e-de-prop-font-last-button', '40.5', this.localObj.getConstant('Clear all formatting'));
    };
    Text.prototype.initializeHighlightColorElement = function () {
        this.highlightColorElement = createElement('div', {
            id: 'highlight_color_ppty',
            styles: 'display:none;width:157px',
            className: 'e-de-cntr-highlight-pane'
        });
        var yellowDiv = this.createHightlighColorPickerDiv('#ffff00', 'yellowDiv');
        var brightGreenDiv = this.createHightlighColorPickerDiv('#00ff00', 'brightGreenDiv');
        var turquoiseDiv = this.createHightlighColorPickerDiv('#00ffff', 'turquoiseDiv');
        var hotPinkDiv = this.createHightlighColorPickerDiv('#ff00ff', 'hotPinkDiv');
        var blueDiv = this.createHightlighColorPickerDiv('#0000ff', 'blueDiv');
        var redDiv = this.createHightlighColorPickerDiv('#ff0000', 'redDiv');
        var darkBlueDiv = this.createHightlighColorPickerDiv('#000080', 'darkBlueDiv');
        var tealDiv = this.createHightlighColorPickerDiv('#008080', 'tealDiv');
        var greenDiv = this.createHightlighColorPickerDiv('#008000', 'greenDiv');
        var violetDiv = this.createHightlighColorPickerDiv('#800080', 'violetDiv');
        var darkRedDiv = this.createHightlighColorPickerDiv('#800000', 'darkRedDiv');
        var darkYellowDiv = this.createHightlighColorPickerDiv('#808000', 'darkYellowDiv');
        var gray50Div = this.createHightlighColorPickerDiv('#808080', 'gray50Div');
        var gray25Div = this.createHightlighColorPickerDiv('#c0c0c0', 'gray25Div');
        var blackDiv = this.createHightlighColorPickerDiv('#000000', 'blackDiv');
        var nocolor = createElement('div', { className: 'e-hglt-no-color' });
        this.highlightColorElement.appendChild(nocolor);
        // tslint:disable-next-line:max-line-length
        var nocolorDiv = createElement('div', { styles: 'width:24px;height:24px;background-color:#ffffff;margin:3px;', id: 'noColorDiv' });
        nocolor.appendChild(nocolorDiv);
        var nocolorDivValue = createElement('div', { innerHTML: 'No color', className: 'e-de-ctnr-hglt-no-color' });
        nocolorDiv.appendChild(nocolorDivValue);
        yellowDiv.addEventListener('click', this.onHighLightColor);
        brightGreenDiv.addEventListener('click', this.onHighLightColor);
        turquoiseDiv.addEventListener('click', this.onHighLightColor);
        hotPinkDiv.addEventListener('click', this.onHighLightColor);
        blueDiv.addEventListener('click', this.onHighLightColor);
        redDiv.addEventListener('click', this.onHighLightColor);
        darkBlueDiv.addEventListener('click', this.onHighLightColor);
        tealDiv.addEventListener('click', this.onHighLightColor);
        greenDiv.addEventListener('click', this.onHighLightColor);
        violetDiv.addEventListener('click', this.onHighLightColor);
        darkRedDiv.addEventListener('click', this.onHighLightColor);
        darkYellowDiv.addEventListener('click', this.onHighLightColor);
        gray50Div.addEventListener('click', this.onHighLightColor);
        gray25Div.addEventListener('click', this.onHighLightColor);
        blackDiv.addEventListener('click', this.onHighLightColor);
        nocolor.addEventListener('click', this.onHighLightColor);
    };
    Text.prototype.createHightlighColorPickerDiv = function (backgroundColor, id) {
        var colorDiv = createElement('div', { className: 'e-de-ctnr-hglt-btn', id: id });
        colorDiv.style.backgroundColor = backgroundColor;
        this.highlightColorElement.appendChild(colorDiv);
        return colorDiv;
    };
    Text.prototype.createDiv = function (id, parentDiv, style) {
        var div;
        if (style) {
            div = createElement('div', { id: id, styles: style });
        }
        else {
            div = createElement('div', { id: id });
        }
        parentDiv.appendChild(div);
        return div;
    };
    // tslint:disable-next-line:max-line-length
    Text.prototype.createButtonTemplate = function (id, iconcss, div, buttonClass, width, toolTipText) {
        var button = createElement('Button', { id: id, attrs: { type: 'button' } });
        // button.style.width = width + 'px';
        // buttonElement.style.height = 32 + 'px';
        div.appendChild(button);
        var btn = new Button({
            cssClass: buttonClass, iconCss: iconcss, enableRtl: this.isRtl
        });
        btn.appendTo(button);
        button.setAttribute('title', toolTipText);
        return button;
    };
    /**
     * Adds file colot elements to parent div.
     */
    Text.prototype.createColorTypeInput = function (elemId) {
        var colorType = createElement('input', {
            id: elemId,
            attrs: { 'type': 'color' }, styles: 'position:fixed; left:-100em'
        });
        this.documentEditor.getDocumentEditorElement().parentElement.appendChild(colorType);
        return colorType;
    };
    Text.prototype.createDropDownListForSize = function (fontSelectElement) {
        var _this = this;
        var fontSize = ['8', '9', '10', '11', '12', '14', '16', '18', '20', '22', '24', '26', '28', '36', '48', '72', '96'];
        this.fontSize = new ComboBox({
            dataSource: fontSize, popupHeight: '180px',
            cssClass: 'e-de-prop-dropdown',
            allowCustom: true,
            showClearButton: false,
            enableRtl: this.isRtl
        });
        this.fontSize.focus = function () { _this.isRetrieving = false; _this.fontSize.element.select(); };
        this.fontSize.value = this.documentEditor.selection.characterFormat.fontSize.toString();
        this.fontSize.appendTo(fontSelectElement);
        this.fontSize.element.parentElement.setAttribute('title', this.localObj.getConstant('Font Size'));
    };
    Text.prototype.createDropDownListForFamily = function (fontSelectElement) {
        var _this = this;
        var fontStyle = [{ FontName: 'Algerian' }, { FontName: 'Arial' },
            { FontName: 'Calibri' }, { FontName: 'Cambria' }, { FontName: 'Cambria Math' }, { FontName: 'Candara' },
            { FontName: 'Courier New' }, { FontName: 'Georgia' }, { FontName: 'Impact' }, { FontName: 'Segoe Print' },
            { FontName: 'Segoe Script' }, { FontName: 'Segoe UI' }, { FontName: 'Symbol' },
            { FontName: 'Times New Roman' }, { FontName: 'Verdana' }, { FontName: 'Windings' }
        ];
        this.fontFamily = new ComboBox({
            dataSource: fontStyle,
            query: new Query().select(['FontName']),
            fields: { text: 'FontName', value: 'FontName' },
            popupHeight: '150px',
            cssClass: 'e-de-prop-dropdown',
            allowCustom: true,
            showClearButton: false,
            enableRtl: this.isRtl
        });
        if (!this.container.enableCsp) {
            this.fontFamily.itemTemplate = '<span style="font-family: ${FontName};">${FontName}</span>';
            this.fontFamily.isStringTemplate = true;
        }
        this.fontFamily.focus = function () { _this.isRetrieving = false; _this.fontFamily.element.select(); };
        this.fontFamily.appendTo(fontSelectElement);
        this.fontFamily.element.parentElement.setAttribute('title', this.localObj.getConstant('Font'));
    };
    Text.prototype.wireEvent = function () {
        var _this = this;
        this.fontFamily.addEventListener('change', function () { _this.changeFontFamily(); });
        this.fontSize.addEventListener('change', function () { _this.changeFontSize(); });
        this.bold.addEventListener('click', function () { _this.isRetrieving = false; _this.boldAction(); });
        this.italic.addEventListener('click', function () { _this.isRetrieving = false; _this.italicAction(); });
        this.underline.addEventListener('click', function () { _this.isRetrieving = false; _this.underlineAction(); });
        this.strikethrough.addEventListener('click', function () { _this.isRetrieving = false; _this.strikethroughAction(); });
        this.superscript.addEventListener('click', function () { _this.isRetrieving = false; _this.superscriptAction(); });
        this.subscript.addEventListener('click', function () { _this.isRetrieving = false; _this.subscriptAction(); });
        /* tslint:disable-next-line:max-line-length */
        this.fontColorInputElement.addEventListener('change', function (args) { _this.isRetrieving = false; _this.changeFontColor(args); });
        this.clearFormat.addEventListener('click', function () { _this.isRetrieving = false; _this.clearFormatAction(); });
    };
    Text.prototype.unwireEvents = function () {
        this.fontFamily.change = undefined;
        this.fontSize.change = undefined;
        this.bold.click = undefined;
        this.italic.click = undefined;
        this.underline.click = undefined;
        this.strikethrough.click = undefined;
        this.superscript.click = undefined;
        this.subscript.click = undefined;
        this.fontColorInputElement.change = undefined;
        this.highlightColorElement.click = undefined;
        this.highlightColor.click = undefined;
        this.clearFormat.click = undefined;
    };
    Text.prototype.onSelectionChange = function () {
        this.isRetrieving = true;
        if (this.documentEditor.selection) {
            //#region character format
            if (this.documentEditor.selection.characterFormat.fontFamily) {
                this.fontFamily.value = this.documentEditor.selection.characterFormat.fontFamily;
                this.fontFamily.dataBind();
            }
            else {
                this.fontFamily.value = '';
            }
            if (this.documentEditor.selection.characterFormat.fontSize) {
                this.fontSize.value = this.documentEditor.selection.characterFormat.fontSize.toString();
                this.fontSize.dataBind();
            }
            else {
                this.fontSize.value = '';
            }
            if (this.documentEditor.selection.characterFormat.bold) {
                if (!this.bold.classList.contains('e-btn-toggle')) {
                    this.bold.classList.add('e-btn-toggle');
                }
            }
            else {
                if (this.bold.classList.contains('e-btn-toggle')) {
                    this.bold.classList.remove('e-btn-toggle');
                }
            }
            if (this.documentEditor.selection.characterFormat.italic) {
                if (!this.italic.classList.contains('e-btn-toggle')) {
                    this.italic.classList.add('e-btn-toggle');
                }
            }
            else {
                if (this.italic.classList.contains('e-btn-toggle')) {
                    this.italic.classList.remove('e-btn-toggle');
                }
            }
            if (this.documentEditor.selection.characterFormat.underline
                && this.documentEditor.selection.characterFormat.underline !== 'None') {
                if (!this.underline.classList.contains('e-btn-toggle')) {
                    this.underline.classList.add('e-btn-toggle');
                }
            }
            else {
                if (this.underline.classList.contains('e-btn-toggle')) {
                    this.underline.classList.remove('e-btn-toggle');
                }
            }
            if (this.documentEditor.selection.characterFormat.strikethrough
                && this.documentEditor.selection.characterFormat.strikethrough !== 'None') {
                if (!this.strikethrough.classList.contains('e-btn-toggle')) {
                    this.strikethrough.classList.add('e-btn-toggle');
                }
            }
            else {
                if (this.strikethrough.classList.contains('e-btn-toggle')) {
                    this.strikethrough.classList.remove('e-btn-toggle');
                }
            }
            if (this.documentEditor.selection.characterFormat.baselineAlignment
                && this.documentEditor.selection.characterFormat.baselineAlignment === 'Subscript') {
                if (!this.subscript.classList.contains('e-btn-toggle')) {
                    this.subscript.classList.add('e-btn-toggle');
                }
            }
            else {
                if (this.subscript.classList.contains('e-btn-toggle')) {
                    this.subscript.classList.remove('e-btn-toggle');
                }
            }
            if (this.documentEditor.selection.characterFormat.baselineAlignment
                && this.documentEditor.selection.characterFormat.baselineAlignment === 'Superscript') {
                if (!this.superscript.classList.contains('e-btn-toggle')) {
                    this.superscript.classList.add('e-btn-toggle');
                }
            }
            else {
                if (this.superscript.classList.contains('e-btn-toggle')) {
                    this.superscript.classList.remove('e-btn-toggle');
                }
            }
            if (this.documentEditor.selection.characterFormat.fontColor) {
                this.fontColorInputElement.value = this.documentEditor.selection.characterFormat.fontColor;
            }
            if (this.documentEditor.selection.characterFormat.highlightColor) {
                this.highlightColorInputElement.style.backgroundColor = this.appliedHighlightColor;
                this.applyHighlightColorAsBackground(this.documentEditor.selection.characterFormat.highlightColor);
            }
            //#endregion
        }
    };
    Text.prototype.destroy = function () {
        this.container = undefined;
        if (this.highlightColor) {
            this.highlightColor.destroy();
            this.highlightColor = undefined;
        }
        if (this.fontColorInputElement) {
            this.fontColorInputElement.destroy();
            this.fontColorInputElement = undefined;
        }
        if (this.fontSize) {
            this.fontSize.destroy();
            this.fontSize = undefined;
        }
        if (this.fontFamily) {
            this.fontFamily.destroy();
            this.fontFamily = undefined;
        }
    };
    return Text;
}());

/**
 * Paragraph Properties
 * @private
 */
var Paragraph = /** @__PURE__ @class */ (function () {
    function Paragraph(container) {
        var _this = this;
        this.isRetrieving = false;
        this.appliedBulletStyle = 'dot';
        this.appliedNumberingStyle = 'arabic';
        this.appliedLineSpacing = '';
        this.splitButtonClass = 'e-de-prop-splitbutton';
        this.updateSelectedBulletListType = function (listText) {
            switch (listText) {
                case '\uf0b7':
                    _this.dotBullet.classList.add('de-list-item-selected');
                    break;
                case '\uf06f' + '\u0020':
                    _this.circleBullet.classList.add('de-list-item-selected');
                    break;
                case '\uf0a7':
                    _this.squareBullet.classList.add('de-list-item-selected');
                    break;
                case '\uf076':
                    _this.flowerBullet.classList.add('de-list-item-selected');
                    break;
                case '\uf0d8':
                    _this.arrowBullet.classList.add('de-list-item-selected');
                    break;
                case '\uf0fc':
                    _this.tickBullet.classList.add('de-list-item-selected');
                    break;
                default:
                    _this.noneBulletTag.classList.add('de-list-item-selected');
                    break;
            }
        };
        this.updateSelectedNumberedListType = function (listText) {
            switch (listText) {
                case '1.':
                    _this.numberList.classList.add('de-list-item-selected');
                    break;
                case 'I.':
                    _this.upRoman.classList.add('de-list-item-selected');
                    break;
                case 'A.':
                    _this.upLetter.classList.add('de-list-item-selected');
                    break;
                case 'a.':
                    _this.lowLetter.classList.add('de-list-item-selected');
                    break;
                case 'i.':
                    _this.lowRoman.classList.add('de-list-item-selected');
                    break;
                default:
                    _this.noneNumberTag.classList.add('de-list-item-selected');
                    break;
            }
        };
        this.removeSelectedList = function () {
            var className = 'de-list-item-selected';
            _this.noneNumberTag.classList.remove(className);
            _this.numberList.classList.remove(className);
            _this.lowLetter.classList.remove(className);
            _this.upLetter.classList.remove(className);
            _this.lowRoman.classList.remove(className);
            _this.upRoman.classList.remove(className);
            _this.noneBulletTag.classList.remove(className);
            _this.dotBullet.classList.remove(className);
            _this.circleBullet.classList.remove(className);
            _this.squareBullet.classList.remove(className);
            _this.flowerBullet.classList.remove(className);
            _this.arrowBullet.classList.remove(className);
            _this.tickBullet.classList.remove(className);
        };
        this.applyLastAppliedNumbering = function () {
            switch (_this.appliedNumberingStyle) {
                case 'arabic':
                    _this.numberedNumberDotClick();
                    break;
                case 'lowletter':
                    _this.numberedLowLetterClick();
                    break;
                case 'upletter':
                    _this.numberedUpLetterClick();
                    break;
                case 'lowroman':
                    _this.numberedLowRomanClick();
                    break;
                case 'uproman':
                    _this.numberedUpRomanClick();
                    break;
            }
        };
        this.applyLastAppliedBullet = function () {
            switch (_this.appliedBulletStyle) {
                case 'dot':
                    _this.bulletDotClick();
                    break;
                case 'circle':
                    _this.bulletCircleClick();
                    break;
                case 'square':
                    _this.bulletSquareClick();
                    break;
                case 'arrow':
                    _this.bulletArrowClick();
                    break;
                case 'tick':
                    _this.bulletTickClick();
                    break;
                case 'flower':
                    _this.bulletFlowerClick();
                    break;
            }
        };
        /* tslint:disable:no-any */
        this.updateOptions = function (args) {
            _this.updateStyleNames();
            args.popup.element.getElementsByClassName('e-de-ctnr-dropdown-ftr')[0].addEventListener('click', _this.createStyle);
        };
        this.createStyle = function () {
            _this.style.hidePopup();
            if (!_this.documentEditor.isReadOnly) {
                _this.documentEditor.showDialog('Styles');
            }
        };
        this.leftAlignmentAction = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.editor) {
                _this.documentEditor.editor.toggleTextAlignment('Left');
            }
        };
        this.lineSpacingAction = function (args) {
            if (_this.isRetrieving) {
                return;
            }
            var text = args.item.text;
            switch (text) {
                case _this.localObj.getConstant('Single'):
                    _this.documentEditor.selection.paragraphFormat.lineSpacing = 1;
                    break;
                case '1.15':
                    _this.documentEditor.selection.paragraphFormat.lineSpacing = 1.15;
                    break;
                case '1.5':
                    _this.documentEditor.selection.paragraphFormat.lineSpacing = 1.5;
                    break;
                case _this.localObj.getConstant('Double'):
                    _this.documentEditor.selection.paragraphFormat.lineSpacing = 2;
                    break;
            }
            setTimeout(function () { _this.documentEditor.focusIn(); }, 30);
        };
        this.selectStyleValue = function (args) {
            if (_this.isRetrieving || !args.isInteracted) {
                return;
            }
            setTimeout(function () { _this.applyStyleValue(args); }, 10);
        };
        /* tslint:enable:no-any */
        this.rightAlignmentAction = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.editor) {
                _this.documentEditor.editor.toggleTextAlignment('Right');
            }
        };
        this.centerAlignmentAction = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.editor) {
                _this.documentEditor.editor.toggleTextAlignment('Center');
            }
        };
        this.justifyAction = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.editor) {
                _this.documentEditor.editor.toggleTextAlignment('Justify');
            }
        };
        this.increaseIndentAction = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.editor) {
                _this.documentEditor.editor.increaseIndent();
            }
        };
        this.decreaseIndentAction = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (!_this.documentEditor.isReadOnly && _this.documentEditor.editor) {
                _this.documentEditor.editor.decreaseIndent();
            }
        };
        this.numberedNoneClick = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (_this.documentEditor.editor) {
                _this.documentEditor.editor.clearList();
                setTimeout(function () { _this.documentEditor.focusIn(); }, 30);
            }
        };
        this.numberedNumberDotClick = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (_this.documentEditor.editor) {
                _this.appliedNumberingStyle = 'arabic';
                _this.documentEditor.editor.applyNumbering('%1.', 'Arabic');
                setTimeout(function () { _this.documentEditor.focusIn(); }, 30);
            }
        };
        this.numberedUpRomanClick = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (_this.documentEditor.editor) {
                _this.appliedNumberingStyle = 'uproman';
                _this.documentEditor.editor.applyNumbering('%1.', 'UpRoman');
                setTimeout(function () { _this.documentEditor.focusIn(); }, 30);
            }
        };
        this.numberedUpLetterClick = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (_this.documentEditor.editor) {
                _this.appliedNumberingStyle = 'upletter';
                _this.documentEditor.editor.applyNumbering('%1.', 'UpLetter');
                setTimeout(function () { _this.documentEditor.focusIn(); }, 30);
            }
        };
        this.numberedLowLetterClick = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (_this.documentEditor.editor) {
                _this.appliedNumberingStyle = 'lowletter';
                _this.documentEditor.editor.applyNumbering('%1.', 'LowLetter');
                setTimeout(function () { _this.documentEditor.focusIn(); }, 30);
            }
        };
        this.numberedLowRomanClick = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (_this.documentEditor.editor) {
                _this.appliedNumberingStyle = 'lowroman';
                _this.documentEditor.editor.applyNumbering('%1.', 'LowRoman');
                setTimeout(function () { _this.documentEditor.focusIn(); }, 30);
            }
        };
        this.bulletDotClick = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (_this.documentEditor.editor) {
                _this.appliedBulletStyle = 'dot';
                _this.documentEditor.editor.applyBullet('\uf0b7', 'Symbol');
                setTimeout(function () { _this.documentEditor.focusIn(); }, 30);
            }
        };
        this.bulletCircleClick = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (_this.documentEditor.editor) {
                _this.appliedBulletStyle = 'circle';
                _this.documentEditor.editor.applyBullet('\uf06f' + '\u0020', 'Symbol');
                setTimeout(function () { _this.documentEditor.focusIn(); }, 30);
            }
        };
        this.bulletSquareClick = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (_this.documentEditor.editor) {
                _this.appliedBulletStyle = 'square';
                _this.documentEditor.editor.applyBullet('\uf0a7', 'Wingdings');
                setTimeout(function () { _this.documentEditor.focusIn(); }, 30);
            }
        };
        this.bulletFlowerClick = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (_this.documentEditor.editor) {
                _this.appliedBulletStyle = 'flower';
                _this.documentEditor.editor.applyBullet('\uf076', 'Wingdings');
                setTimeout(function () { _this.documentEditor.focusIn(); }, 30);
            }
        };
        this.bulletArrowClick = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (_this.documentEditor.editor) {
                _this.appliedBulletStyle = 'arrow';
                _this.documentEditor.editor.applyBullet('\uf0d8', 'Wingdings');
                setTimeout(function () { _this.documentEditor.focusIn(); }, 30);
            }
        };
        this.bulletTickClick = function () {
            if (_this.isRetrieving) {
                return;
            }
            if (_this.documentEditor.editor) {
                _this.appliedBulletStyle = 'tick';
                _this.documentEditor.editor.applyBullet('\uf0fc', 'Wingdings');
                setTimeout(function () { _this.documentEditor.focusIn(); }, 30);
            }
        };
        this.container = container;
    }
    Object.defineProperty(Paragraph.prototype, "documentEditor", {
        get: function () {
            return this.container.documentEditor;
        },
        enumerable: true,
        configurable: true
    });
    Paragraph.prototype.initializeParagraphPropertiesDiv = function (wholeDiv, isRtl) {
        this.localObj = new L10n('documenteditorcontainer', this.container.defaultLocale, this.container.locale);
        this.isRtl = isRtl;
        if (this.isRtl) {
            this.splitButtonClass = 'e-rtl ' + this.splitButtonClass;
        }
        this.textProperties = wholeDiv;
        var element = 'font_properties';
        var paragraphDiv = this.createDivElement(element + '_paragraph', wholeDiv, '');
        classList(paragraphDiv, ['e-de-cntr-pane-padding'], []);
        var label = createElement('label', { styles: 'width:26px;', className: 'e-de-ctnr-prop-label' });
        label.innerHTML = this.localObj.getConstant('Paragraph');
        paragraphDiv.appendChild(label);
        var styleDiv = this.createDivElement(element + '_styleDiv', paragraphDiv);
        styleDiv.classList.add('e-de-ctnr-segment', 'e-de-ctnr-style-div');
        // tslint:disable-next-line:max-line-length
        var styleSelect = createElement('input', { id: element + '_style', styles: 'width:248px;font-size: 12px;letter-spacing: 0.05px;' });
        styleDiv.appendChild(styleSelect);
        this.createStyleDropDownList(styleSelect);
        var indentWholeDiv = this.createDivElement(element + '_indentWholeDiv', paragraphDiv);
        indentWholeDiv.style.display = 'flex';
        indentWholeDiv.classList.add('e-de-ctnr-segment');
        if (isRtl) {
            classList(indentWholeDiv, ['e-de-ctnr-segment-rtl'], []);
        }
        // tslint:disable-next-line:max-line-length
        var indentDiv = this.createDivElement(element + '_indentDiv', indentWholeDiv, 'display:flex;');
        var indentClassName = 'e-de-ctnr-group-btn e-de-char-fmt-btn-left e-btn-group';
        if (isRtl) {
            indentClassName = 'e-rtl ' + indentClassName;
        }
        indentDiv.className = indentClassName;
        // tslint:disable-next-line:max-line-length
        this.leftAlignment = this.createButtonTemplate(element + '_leftIndent', 'e-de-ctnr-alignleft e-icons', indentDiv, 'e-de-prop-indent-button', '40.5', this.localObj.getConstant('Align left Tooltip'));
        // tslint:disable-next-line:max-line-length
        this.centerAlignment = this.createButtonTemplate(element + '_centerIndent', 'e-de-ctnr-aligncenter e-icons', indentDiv, 'e-de-prop-indent-button', '40.5', this.localObj.getConstant('Center Tooltip'));
        // tslint:disable-next-line:max-line-length
        this.rightAlignment = this.createButtonTemplate(element + '_rightIndent', 'e-de-ctnr-alignright e-icons', indentDiv, 'e-de-prop-indent-button', '40.5', this.localObj.getConstant('Align right Tooltip'));
        // tslint:disable-next-line:max-line-length
        this.justify = this.createButtonTemplate(element + '_justify', 'e-de-ctnr-justify e-icons', indentDiv, 'e-de-prop-indent-last-button', '40.5', this.localObj.getConstant('Justify Tooltip'));
        var increaseIndentIconCss = 'e-de-ctnr-increaseindent e-icons';
        var decreaseIndentIconCss = 'e-de-ctnr-decreaseindent e-icons';
        var incDecIndentDiv = this.createDivElement(element + '_indentDiv', indentWholeDiv, 'display:flex;');
        indentClassName = 'e-de-ctnr-group-btn e-de-char-fmt-btn-right e-btn-group';
        if (isRtl) {
            indentClassName = 'e-rtl ' + indentClassName;
            increaseIndentIconCss += ' e-de-flip';
            decreaseIndentIconCss += ' e-de-flip';
        }
        incDecIndentDiv.className = indentClassName;
        // tslint:disable-next-line:max-line-length
        this.decreaseIndent = this.createButtonTemplate(element + '_decreaseIndent', decreaseIndentIconCss, incDecIndentDiv, 'e-de-prop-indent-button', '37', this.localObj.getConstant('Decrease indent'));
        // tslint:disable-next-line:max-line-length
        this.increaseIndent = this.createButtonTemplate(element + '_increaseIndent', increaseIndentIconCss, incDecIndentDiv, 'e-de-prop-indent-last-button', '37', this.localObj.getConstant('Increase indent'));
        var listDiv = this.createDivElement(element + '_listDiv', paragraphDiv, 'display:flex;');
        classList(listDiv, ['e-de-ctnr-segment', 'e-de-ctnr-group-btn'], []);
        if (isRtl) {
            classList(listDiv, ['e-de-ctnr-segment-rtl', 'e-de-ctnr-group-btn'], []);
        }
        var lineHeight = createElement('button', { id: element + '_lineHeight', attrs: { type: 'button' } });
        listDiv.appendChild(lineHeight);
        this.lineSpacing = this.createLineSpacingDropdown(lineHeight);
        var listDropDown = this.createDivElement(element + '_listDropDiv', listDiv);
        listDropDown.className = 'de-split-button';
        var bulletButton = createElement('button', { id: element + '_bullet', attrs: { type: 'button' } });
        listDropDown.appendChild(bulletButton);
        var numberingList = createElement('button', { id: element + '_numberingList', attrs: { type: 'button' } });
        listDropDown.appendChild(numberingList);
        var bulletIconCss = 'e-de-ctnr-bullets e-icons';
        var numberIconCss = 'e-de-ctnr-numbering e-icons';
        if (isRtl) {
            bulletIconCss += ' e-de-flip';
            numberIconCss += ' e-de-flip';
        }
        this.createBulletListDropButton(bulletIconCss, bulletButton);
        this.createNumberListDropButton(numberIconCss, numberingList);
    };
    Paragraph.prototype.createSeperator = function (parentDiv) {
        var seperator = createElement('div', { className: 'e-de-prop-vline' });
        parentDiv.appendChild(seperator);
    };
    Paragraph.prototype.createDivElement = function (id, parentDiv, style) {
        var element;
        if (style) {
            element = createElement('div', { id: id, styles: style });
        }
        else {
            element = createElement('div', { id: id });
        }
        parentDiv.appendChild(element);
        return element;
    };
    // tslint:disable-next-line:max-line-length
    Paragraph.prototype.createButtonTemplate = function (id, iconcss, div, buttonClass, width, toolTipText) {
        var buttonElement = createElement('Button', { id: id, attrs: { type: 'button' } });
        // buttonElement.style.width = width + 'px';
        // buttonElement.style.height = 32 + 'px';
        div.appendChild(buttonElement);
        var btn = new Button({
            cssClass: buttonClass, iconCss: iconcss
        });
        btn.appendTo(buttonElement);
        buttonElement.setAttribute('title', toolTipText);
        return buttonElement;
    };
    Paragraph.prototype.createLineSpacingDropdown = function (button) {
        var _this = this;
        var items = [{
                text: this.localObj.getConstant('Single')
            }, {
                text: '1.15'
            }, {
                text: '1.5'
            }, {
                text: this.localObj.getConstant('Double')
            }];
        var dropdown = new DropDownButton({
            items: items,
            iconCss: 'e-de-ctnr-linespacing e-icons',
            enableRtl: this.isRtl,
            select: this.lineSpacingAction,
            cssClass: this.splitButtonClass,
            beforeItemRender: function (args) {
                args.element.innerHTML = '<span></span>' + args.item.text;
                var span = args.element.children[0];
                if (args.item.text === _this.appliedLineSpacing) {
                    span.style.marginRight = '10px';
                    span.setAttribute('class', 'e-de-selected-item e-icons');
                }
                else {
                    args.element.children[0].style.marginRight = '25px';
                    args.element.children[0].classList.remove('e-de-selected-item');
                }
            }
        });
        dropdown.appendTo(button);
        button.setAttribute('title', this.localObj.getConstant('Line spacing'));
        return dropdown;
    };
    Paragraph.prototype.createNumberListDropButton = function (iconcss, button) {
        var _this = this;
        // tslint:disable-next-line:max-line-length
        var div = createElement('div', { id: 'target', styles: 'width: 211px;height: auto;display:none' });
        var ulTag = createElement('ul', {
            styles: 'display: block; outline: 0px;',
            id: 'listMenu',
            className: 'e-de-floating-menu e-de-bullets-menu e-de-list-container e-de-list-thumbnail'
        });
        div.appendChild(ulTag);
        this.noneNumberTag = this.createNumberNoneListTag(ulTag);
        this.noneNumberTag.addEventListener('click', this.numberedNoneClick);
        this.numberList = this.createNumberListTag(ulTag, '1.', '2.', '3.');
        this.numberList.addEventListener('click', this.numberedNumberDotClick);
        this.lowLetter = this.createNumberListTag(ulTag, 'a.', 'b.', 'c.');
        this.lowLetter.addEventListener('click', this.numberedLowLetterClick);
        this.upLetter = this.createNumberListTag(ulTag, 'A.', 'B.', 'C.');
        this.upLetter.addEventListener('click', this.numberedUpLetterClick);
        this.lowRoman = this.createNumberListTag(ulTag, 'i.', 'ii.', 'iii.');
        this.lowRoman.addEventListener('click', this.numberedLowRomanClick);
        this.upRoman = this.createNumberListTag(ulTag, 'I.', 'II.', 'III.');
        this.upRoman.addEventListener('click', this.numberedUpRomanClick);
        var menuOptions = {
            target: div,
            iconCss: iconcss,
            cssClass: this.splitButtonClass,
            beforeOpen: function () {
                div.style.display = 'block';
                _this.updateSelectedNumberedListType(_this.documentEditor.selection.paragraphFormat.listText);
            },
            beforeClose: function () {
                div.style.display = 'none';
                _this.removeSelectedList();
            }
        };
        this.numberedListBtn = new SplitButton(menuOptions);
        this.numberedListBtn.click = function () {
            _this.applyLastAppliedNumbering();
        };
        this.numberedListBtn.appendTo(button);
        button.parentElement.setAttribute('title', this.localObj.getConstant('Numbering'));
    };
    Paragraph.prototype.createBulletListDropButton = function (iconcss, button) {
        var _this = this;
        // tslint:disable-next-line:max-line-length
        var div = createElement('div', { id: 'bullet_list', styles: 'width: 196px;height: auto;display:none' });
        var ulTag = createElement('ul', {
            styles: 'display: block; outline: 0px;', id: 'listMenu',
            className: 'e-de-floating-menu e-de-bullets-menu e-de-list-container e-de-list-thumbnail'
        });
        div.appendChild(ulTag);
        this.noneBulletTag = this.createBulletListTag(ulTag, 'e-de-ctnr-bullet-none e-icons e-de-ctnr-list');
        this.noneBulletTag.addEventListener('click', this.numberedNoneClick);
        this.dotBullet = this.createBulletListTag(ulTag, 'e-de-ctnr-bullet-dot e-icons e-de-ctnr-list');
        this.dotBullet.addEventListener('click', this.bulletDotClick);
        this.circleBullet = this.createBulletListTag(ulTag, 'e-de-ctnr-bullet-circle e-icons e-de-ctnr-list');
        this.circleBullet.addEventListener('click', this.bulletCircleClick);
        this.squareBullet = this.createBulletListTag(ulTag, 'e-de-ctnr-bullet-square e-icons e-de-ctnr-list');
        this.squareBullet.addEventListener('click', this.bulletSquareClick);
        this.flowerBullet = this.createBulletListTag(ulTag, 'e-de-ctnr-bullet-flower e-icons e-de-ctnr-list');
        this.flowerBullet.addEventListener('click', this.bulletFlowerClick);
        this.arrowBullet = this.createBulletListTag(ulTag, 'e-de-ctnr-bullet-arrow e-icons e-de-ctnr-list');
        this.arrowBullet.addEventListener('click', this.bulletArrowClick);
        this.tickBullet = this.createBulletListTag(ulTag, 'e-de-ctnr-bullet-tick e-icons e-de-ctnr-list');
        this.tickBullet.addEventListener('click', this.bulletTickClick);
        var menuOptions = {
            target: div,
            iconCss: iconcss,
            cssClass: this.splitButtonClass,
            beforeOpen: function () {
                div.style.display = 'block';
                _this.updateSelectedBulletListType(_this.documentEditor.selection.paragraphFormat.listText);
            },
            beforeClose: function () {
                div.style.display = 'none';
                _this.removeSelectedList();
            }
        };
        this.bulletListBtn = new SplitButton(menuOptions);
        this.bulletListBtn.click = function () {
            _this.applyLastAppliedBullet();
        };
        this.bulletListBtn.appendTo(button);
        button.parentElement.setAttribute('title', this.localObj.getConstant('Bullets'));
    };
    Paragraph.prototype.createNumberListTag = function (ulTag, text1, text2, text3) {
        var liTag = createElement('li', {
            styles: 'display:block',
            className: 'e-de-floating-menuitem e-de-floating-menuitem-md e-de-list-items  e-de-list-item-size'
        });
        ulTag.appendChild(liTag);
        // tslint:disable-next-line:max-line-length
        var innerHTML = '<div>' + text1 + '<span class="e-de-list-line"></span></div><div>' + text2 + '<span class="e-de-list-line">';
        innerHTML += '</span></div><div>' + text3 + '<span class="e-de-list-line"> </span></div >';
        var liInnerDiv = createElement('div', {
            className: 'e-de-list-header-presetmenu',
            id: 'ui-zlist0', innerHTML: innerHTML
        });
        liTag.appendChild(liInnerDiv);
        return liTag;
    };
    Paragraph.prototype.createNumberNoneListTag = function (ulTag) {
        var liTag = createElement('li', {
            styles: 'display:block;',
            className: 'e-de-floating-menuitem e-de-floating-menuitem-md e-de-list-items  e-de-list-item-size'
        });
        ulTag.appendChild(liTag);
        var innerHTML = '<div><span class="e-de-bullets">None</span></div>';
        var liInnerDiv = createElement('div', {
            className: 'e-de-list-header-presetmenu', styles: 'position:relative;left:11px;top:13px',
            id: 'ui-zlist0', innerHTML: innerHTML
        });
        liTag.appendChild(liInnerDiv);
        return liTag;
    };
    Paragraph.prototype.createBulletListTag = function (ulTag, iconCss) {
        var liTag = createElement('li', {
            styles: 'display:block;',
            className: 'e-de-floating-menuitem e-de-floating-bullet-menuitem-md e-de-list-items  e-de-list-item-size'
        });
        ulTag.appendChild(liTag);
        var liInnerDiv = createElement('div', { className: 'e-de-bullet-list-header-presetmenu', id: 'ui-zlist0' });
        var spanDiv = createElement('div');
        liInnerDiv.appendChild(spanDiv);
        var span = createElement('span', { className: iconCss });
        spanDiv.appendChild(span);
        liTag.appendChild(liInnerDiv);
        return liTag;
    };
    Paragraph.prototype.createStyleDropDownList = function (selectElement) {
        this.style = new DropDownList({
            dataSource: [{ StyleName: 'Normal', Class: 'e-icons e-edit-font' }],
            cssClass: 'e-de-prop-dropdown',
            popupHeight: '240px',
            enableRtl: this.isRtl,
            query: new Query().select(['StyleName', 'Style']),
            fields: { text: 'StyleName', value: 'StyleName' },
            change: this.selectStyleValue
        });
        if (!this.container.enableCsp) {
            this.style.open = this.updateOptions;
            this.style.itemTemplate = '<span style="${Style}">${StyleName}</span>';
            this.style.footerTemplate = '<span class="e-de-ctnr-dropdown-ftr">' + this.localObj.getConstant('Manage Styles') + '</span>';
            this.style.isStringTemplate = true;
        }
        this.style.appendTo(selectElement);
        selectElement.parentElement.setAttribute('title', this.localObj.getConstant('Styles'));
    };
    Paragraph.prototype.updateStyleNames = function () {
        this.styleName = !isNullOrUndefined(this.style.itemData) ? this.style.itemData.StyleName : undefined;
        this.style.dataSource = this.constructStyleDropItems(this.documentEditor.getStyles('Paragraph'));
        this.style.dataBind();
        this.onSelectionChange();
    };
    Paragraph.prototype.constructStyleDropItems = function (styles) {
        var collection = [];
        for (var _i = 0, styles_1 = styles; _i < styles_1.length; _i++) {
            var styleObj = styles_1[_i];
            var obj = {};
            obj.StyleName = styleObj.name;
            obj.Style = this.parseStyle(styleObj.style);
            collection.push(obj);
        }
        return collection;
    };
    Paragraph.prototype.parseStyle = function (style) {
        var domStyle = '';
        var styleObj = JSON.parse(style);
        var textDecoration = '';
        if (!isNullOrUndefined(styleObj.characterFormat.baselineAlignment) && styleObj.characterFormat.baselineAlignment !== 'Normal') {
            var vAlign = '';
            switch (styleObj.characterFormat.baselineAlignment) {
                case 'Superscript':
                    vAlign = 'super';
                    break;
                case 'Subscript':
                    vAlign = 'sub';
                    break;
            }
            if (vAlign.length > 1) {
                domStyle += 'vertical-align:' + vAlign + ';';
            }
        }
        if (!isNullOrUndefined(styleObj.characterFormat.underline) && styleObj.characterFormat.underline !== 'None') {
            textDecoration += 'underline ';
        }
        if (!isNullOrUndefined(styleObj.characterFormat.strikethrough) && styleObj.characterFormat.strikethrough !== 'None') {
            textDecoration += 'line-through ';
        }
        if (!isNullOrUndefined(styleObj.characterFormat.fontSize)) {
            domStyle += 'font-size:' + styleObj.characterFormat.fontSize + 'px;';
        }
        if (!isNullOrUndefined(styleObj.characterFormat.fontFamily)) {
            domStyle += 'font-family:' + styleObj.characterFormat.fontFamily + ';';
        }
        if (!isNullOrUndefined(styleObj.characterFormat.bold) && styleObj.characterFormat.bold) {
            domStyle += 'font-weight:bold;';
        }
        if (!isNullOrUndefined(styleObj.characterFormat.italic) && styleObj.characterFormat.italic) {
            domStyle += 'font-style:italic;';
        }
        // if (!isNullOrUndefined(styleObj.characterFormat.fontColor)) {
        //     domStyle += 'color: ' + styleObj.characterFormat.fontColor + ';';
        // }
        if (textDecoration.length > 1) {
            domStyle += 'text-decoration:' + textDecoration + ';';
        }
        return domStyle;
    };
    Paragraph.prototype.wireEvent = function () {
        var _this = this;
        this.leftAlignment.addEventListener('click', function () { _this.leftAlignmentAction(); });
        this.rightAlignment.addEventListener('click', function () { _this.rightAlignmentAction(); });
        this.centerAlignment.addEventListener('click', function () { _this.centerAlignmentAction(); });
        this.justify.addEventListener('click', function () { _this.justifyAction(); });
        this.increaseIndent.addEventListener('click', function () { _this.increaseIndentAction(); });
        this.decreaseIndent.addEventListener('click', function () { _this.decreaseIndentAction(); });
        /* tslint:disable-next-line:max-line-length */
        this.lineSpacing.addEventListener('select', function (args) { _this.lineSpacingAction(args); });
    };
    Paragraph.prototype.unwireEvents = function () {
        this.leftAlignment.click = undefined;
        this.rightAlignment.click = undefined;
        this.centerAlignment.click = undefined;
        this.justify.click = undefined;
        this.increaseIndent.click = undefined;
        this.decreaseIndent.click = undefined;
        this.lineSpacing.select = undefined;
        this.style.select = undefined;
    };
    Paragraph.prototype.setLineSpacing = function () {
        var lineSpacing = this.documentEditor.selection.paragraphFormat.lineSpacing;
        if (lineSpacing === 1) {
            this.appliedLineSpacing = this.localObj.getConstant('Single');
        }
        else if (lineSpacing === 1.15) {
            this.appliedLineSpacing = '1.15';
        }
        else if (lineSpacing === 1.5) {
            this.appliedLineSpacing = '1.5';
        }
        else if (lineSpacing === 2) {
            this.appliedLineSpacing = this.localObj.getConstant('Double');
        }
        else {
            this.appliedLineSpacing = '';
        }
    };
    Paragraph.prototype.applyStyleValue = function (args) {
        if (!this.documentEditor.isReadOnly && this.documentEditor.editor) {
            this.documentEditor.editor.applyStyle(args.itemData.StyleName);
        }
    };
    Paragraph.prototype.onSelectionChange = function () {
        this.isRetrieving = true;
        if (this.documentEditor.editor) {
            //#region paragraph format
            var style = this.documentEditor.selection.paragraphFormat.styleName;
            if (style) {
                this.style.value = style;
                this.style.dataBind();
            }
            else {
                this.style.value = '';
            }
            classList(this.leftAlignment, [], ['e-btn-toggle']);
            classList(this.rightAlignment, [], ['e-btn-toggle']);
            classList(this.centerAlignment, [], ['e-btn-toggle']);
            classList(this.justify, [], ['e-btn-toggle']);
            if (this.documentEditor.selection.paragraphFormat.textAlignment === 'Left') {
                classList(this.leftAlignment, ['e-btn-toggle'], []);
            }
            else if (this.documentEditor.selection.paragraphFormat.textAlignment === 'Right') {
                classList(this.rightAlignment, ['e-btn-toggle'], []);
            }
            else if (this.documentEditor.selection.paragraphFormat.textAlignment === 'Center') {
                classList(this.centerAlignment, ['e-btn-toggle'], []);
            }
            else if (this.documentEditor.selection.paragraphFormat.textAlignment === 'Justify') {
                classList(this.justify, ['e-btn-toggle'], []);
            }
            //#endregion
        }
        this.setLineSpacing();
        this.isRetrieving = false;
    };
    Paragraph.prototype.destroy = function () {
        this.container = undefined;
        if (this.lineSpacing) {
            this.lineSpacing.destroy();
            this.lineSpacing = undefined;
        }
        if (this.style) {
            this.style.destroy();
            this.style = undefined;
        }
        if (this.bulletListBtn) {
            this.bulletListBtn.destroy();
            this.bulletListBtn = undefined;
        }
        if (this.numberedListBtn) {
            this.numberedListBtn.destroy();
            this.numberedListBtn = undefined;
        }
    };
    return Paragraph;
}());

/**
 * Text Properties pane
 * @private
 */
var TextProperties = /** @__PURE__ @class */ (function () {
    function TextProperties(container, id, isTableProperties, isRtl) {
        var _this = this;
        this.isInitial = true;
        this.showTextProperties = function (isShow) {
            if (isShow) {
                _this.onSelectionChange();
            }
            if (!isShow && _this.element.style.display === 'none' || (isShow && _this.element.style.display === 'block')) {
                return;
            }
            _this.element.style.display = isShow ? 'block' : 'none';
            _this.documentEditor.resize();
        };
        this.generateUniqueID = function () {
            return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        };
        this.container = container;
        this.text = new Text(container, isRtl);
        this.paragraph = new Paragraph(container);
        this.initializeTextProperties(id, isTableProperties, isRtl);
        this.wireEvents();
    }
    Object.defineProperty(TextProperties.prototype, "documentEditor", {
        get: function () {
            return this.container.documentEditor;
        },
        enumerable: true,
        configurable: true
    });
    TextProperties.prototype.enableDisableElements = function (enable) {
        if (enable) {
            classList(this.element, [], ['e-de-overlay']);
        }
        else {
            classList(this.element, ['e-de-overlay'], []);
        }
    };
    TextProperties.prototype.updateStyles = function () {
        this.paragraph.updateStyleNames();
    };
    Object.defineProperty(TextProperties.prototype, "appliedHighlightColor", {
        get: function () {
            return this.text.appliedHighlightColor;
        },
        set: function (value) {
            this.text.appliedHighlightColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextProperties.prototype, "appliedBulletStyle", {
        get: function () {
            return this.paragraph.appliedBulletStyle;
        },
        set: function (value) {
            this.paragraph.appliedBulletStyle = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextProperties.prototype, "appliedNumberingStyle", {
        get: function () {
            return this.paragraph.appliedNumberingStyle;
        },
        set: function (value) {
            this.paragraph.appliedNumberingStyle = value;
        },
        enumerable: true,
        configurable: true
    });
    TextProperties.prototype.initializeTextProperties = function (id, isTableProperties, isRtl) {
        /* tslint:disable-next-line:max-line-length */
        this.element = createElement('div', { id: id + 'id_' + this.generateUniqueID(), className: 'e-de-prop-pane' });
        this.text.initializeTextPropertiesDiv(this.element, isRtl);
        this.paragraph.initializeParagraphPropertiesDiv(this.element, isRtl);
        this.paragraph.updateStyleNames();
        if (!isTableProperties) {
            this.container.propertiesPaneContainer.appendChild(this.element);
        }
    };
    TextProperties.prototype.wireEvents = function () {
        this.text.wireEvent();
        this.paragraph.wireEvent();
    };
    TextProperties.prototype.onSelectionChange = function () {
        this.text.onSelectionChange();
        this.paragraph.onSelectionChange();
    };
    TextProperties.prototype.destroy = function () {
        if (this.text) {
            this.text.destroy();
            this.text = undefined;
        }
        if (this.paragraph) {
            this.paragraph.destroy();
            this.paragraph = undefined;
        }
    };
    return TextProperties;
}());

/**
 * Represents document editor header and footer.
 */
/**
 * @private
 */
var HeaderFooterProperties = /** @__PURE__ @class */ (function () {
    function HeaderFooterProperties(container, isRtl) {
        var _this = this;
        this.isHeaderTopApply = false;
        this.isFooterTopApply = false;
        this.wireEvents = function () {
            _this.headerFromTop.element.addEventListener('click', function () { _this.isHeaderTopApply = true; });
            _this.footerFromTop.element.addEventListener('click', function () { _this.isFooterTopApply = true; });
            _this.headerFromTop.element.addEventListener('keydown', _this.onHeaderValue);
            _this.footerFromTop.element.addEventListener('keydown', _this.onFooterValue);
            _this.headerFromTop.element.addEventListener('blur', function () { _this.changeHeaderValue(); _this.isHeaderTopApply = false; });
            _this.footerFromTop.element.addEventListener('blur', function () { _this.changeFooterValue(); _this.isFooterTopApply = false; });
        };
        this.onClose = function () {
            _this.documentEditor.selection.closeHeaderFooter();
        };
        this.changeFirstPageOptions = function () {
            if (!_this.documentEditor.isReadOnly) {
                _this.documentEditor.selection.sectionFormat.differentFirstPage = _this.firstPage.checked;
                setTimeout(function () { _this.documentEditor.focusIn(); }, 10);
            }
        };
        this.changeoddOrEvenOptions = function () {
            if (!_this.documentEditor.isReadOnly) {
                _this.documentEditor.selection.sectionFormat.differentOddAndEvenPages = _this.oddOrEven.checked;
                setTimeout(function () { _this.documentEditor.focusIn(); }, 10);
            }
        };
        this.changeHeaderValue = function () {
            if (!_this.isHeaderTopApply) {
                return;
            }
            if (!_this.documentEditor.isReadOnly) {
                var headerTop = _this.headerFromTop.value;
                if (headerTop > _this.headerFromTop.max) {
                    headerTop = _this.headerFromTop.max;
                }
                _this.documentEditor.selection.sectionFormat.headerDistance = headerTop;
            }
        };
        this.onHeaderValue = function (e) {
            if (e.keyCode === 13) {
                setTimeout(function () { _this.changeHeaderValue(); _this.isHeaderTopApply = false; }, 30);
            }
        };
        this.onFooterValue = function (e) {
            if (e.keyCode === 13) {
                setTimeout(function () { _this.changeFooterValue(); _this.isFooterTopApply = false; }, 30);
            }
        };
        this.changeFooterValue = function () {
            if (!_this.isFooterTopApply) {
                return;
            }
            if (!_this.documentEditor.isReadOnly) {
                var footerTop = _this.footerFromTop.value;
                if (footerTop > _this.footerFromTop.max) {
                    footerTop = _this.footerFromTop.max;
                }
                _this.documentEditor.selection.sectionFormat.footerDistance = footerTop;
            }
        };
        this.container = container;
        this.isRtl = isRtl;
        this.initHeaderFooterPane();
        this.wireEvents();
    }
    Object.defineProperty(HeaderFooterProperties.prototype, "documentEditor", {
        /**
         * @private
         */
        get: function () {
            return this.container.documentEditor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HeaderFooterProperties.prototype, "toolbar", {
        get: function () {
            return this.container.toolbarModule;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    HeaderFooterProperties.prototype.enableDisableElements = function (enable) {
        if (enable) {
            classList(this.element, [], ['e-de-overlay']);
        }
        else {
            classList(this.element, ['e-de-overlay'], []);
        }
    };
    HeaderFooterProperties.prototype.initHeaderFooterPane = function () {
        this.initializeHeaderFooter();
        this.element.style.display = 'none';
        this.container.propertiesPaneContainer.appendChild(this.element);
    };
    HeaderFooterProperties.prototype.showHeaderFooterPane = function (isShow) {
        if (isShow) {
            if (this.toolbar) {
                this.toolbar.enableDisablePropertyPaneButton(false);
            }
            this.onSelectionChange();
        }
        if (!isShow && this.element.style.display === 'none' || (isShow && this.element.style.display === 'block')) {
            return;
        }
        this.element.style.display = isShow ? 'block' : 'none';
        this.documentEditor.resize();
    };
    // tslint:disable-next-line:max-func-body-length
    HeaderFooterProperties.prototype.initializeHeaderFooter = function () {
        var _this = this;
        var localObj = new L10n('documenteditorcontainer', this.container.defaultLocale, this.container.locale);
        var elementId = 'header_footer_properties';
        // tslint:disable-next-line:max-line-length
        this.element = createElement('div', { id: this.documentEditor.element.id + elementId, className: 'e-de-prop-pane' });
        var headerDiv = this.createDivTemplate('_header_footer', this.element, 'padding-bottom:0');
        classList(headerDiv, ['e-de-cntr-pane-padding'], []);
        var headerLabel = createElement('label', { className: 'e-de-prop-header-label' });
        headerLabel.innerHTML = localObj.getConstant('Header And Footer');
        var closeButtonFloat;
        if (!this.isRtl) {
            closeButtonFloat = 'float:right;';
            
        }
        else {
            closeButtonFloat = 'float:left;';
            
        }
        var closeIcon = createElement('span', {
            id: '_header_footer_close',
            className: 'e-de-ctnr-close e-icons',
            styles: 'display:inline-block;cursor:pointer;color: #4A4A4A;' + closeButtonFloat
        });
        closeIcon.addEventListener('click', function () { _this.onClose(); });
        headerDiv.appendChild(headerLabel);
        headerDiv.appendChild(closeIcon);
        var optionsLabelDiv = this.createDivTemplate(elementId + '_options', this.element);
        classList(optionsLabelDiv, ['e-de-cntr-pane-padding', 'e-de-prop-separator-line'], []);
        var optionsLabel = createElement('label', { className: 'e-de-ctnr-prop-label', styles: 'height:20px;' });
        optionsLabel.innerHTML = localObj.getConstant('Options');
        optionsLabelDiv.appendChild(optionsLabel);
        var optionsDiv = this.createDivTemplate(elementId + '_optionsDiv', optionsLabelDiv);
        var firstPageDiv = this.createDivTemplate(elementId + '_firstPageDiv', optionsDiv, 'margin-bottom:10px;');
        var firstPage = createElement('input', { id: 'firstPage', className: 'e-de-prop-sub-label' });
        firstPageDiv.appendChild(firstPage);
        // tslint:disable-next-line:max-line-length
        this.firstPage = new CheckBox({ label: localObj.getConstant('Different First Page'), change: this.changeFirstPageOptions, cssClass: 'e-de-prop-sub-label', enableRtl: this.isRtl });
        this.firstPage.appendTo(firstPage);
        // tslint:disable-next-line:max-line-length
        firstPageDiv.children[0].setAttribute('title', localObj.getConstant('Different header and footer for first page'));
        var oddOrEvenDiv = this.createDivTemplate(elementId + '_oddOrEvenDiv', optionsDiv);
        var oddOrEven = createElement('input', { id: 'oddOrEven', className: 'e-de-sub-prop-label' });
        oddOrEvenDiv.appendChild(oddOrEven);
        // tslint:disable-next-line:max-line-length
        this.oddOrEven = new CheckBox({ label: localObj.getConstant('Different Odd And Even Pages'), change: this.changeoddOrEvenOptions, cssClass: 'e-de-prop-sub-label', enableRtl: this.isRtl });
        this.oddOrEven.appendTo(oddOrEven);
        // tslint:disable-next-line:max-line-length
        oddOrEvenDiv.children[0].setAttribute('title', localObj.getConstant('Different header and footer for odd and even pages'));
        // tslint:disable-next-line:max-line-length
        // let autoFieldLabelDiv: HTMLElement = this.createDivTemplate(element + '_autoFieldLabelDiv', div, 'padding-top:10px;padding-left: 10px;');
        // let autoFieldLabel: HTMLElement = createElement('label', { className: 'e-de-header-prop-label', styles: 'height:20px;' });
        // autoFieldLabel.innerHTML = 'Insert Autofield';
        // autoFieldLabelDiv.appendChild(autoFieldLabel);
        // let autofieldDiv: HTMLElement = this.createDivTemplate(element + '_autofieldDiv', autoFieldLabelDiv, 'display:inline-flex;');
        // let pageNumberDiv: HTMLElement = this.createDivTemplate(element + '_pageNumberDiv', autofieldDiv, 'margin-right:8px;');
        // let pageNumber: HTMLInputElement = createElement('input', { id: 'pageNumber' }) as HTMLInputElement;
        // pageNumberDiv.appendChild(pageNumber);
        // this.pageNumber = new CheckBox({ label: 'Page Number', change: this.changePageNumber });
        // this.pageNumber.appendTo(pageNumber);
        // let pageCountDiv: HTMLElement = this.createDivTemplate(element + '_pageCountDiv', autofieldDiv);
        // let pageCount: HTMLInputElement = createElement('input', { id: 'pageCount' }) as HTMLInputElement;
        // pageCountDiv.appendChild(pageCount);
        // this.pageCount = new CheckBox({ label: 'Page Count', change: this.changePageCount });
        // this.pageCount.appendTo(pageCount);
        // let autoFieldLine: HTMLElement = createElement('div', { className: 'e-de-prop-separator-line', styles: 'margin-top:7px;' });
        // autoFieldLabelDiv.appendChild(autoFieldLine);
        // tslint:disable-next-line:max-line-length
        var positionLabelDiv = this.createDivTemplate(elementId + '_positionLabelDiv', this.element);
        classList(positionLabelDiv, ['e-de-cntr-pane-padding', 'e-de-prop-separator-line'], []);
        var positionLabel = createElement('label', { className: 'e-de-ctnr-prop-label', styles: 'height:20px;' });
        positionLabel.innerHTML = localObj.getConstant('Position');
        positionLabelDiv.appendChild(positionLabel);
        var positionDiv = this.createDivTemplate(elementId + '_positionDiv', positionLabelDiv);
        if (!this.isRtl) {
            
        }
        else {
            
        }
        // tslint:disable-next-line:max-line-length
        var headerTopDiv = this.createDivTemplate(elementId + '_headerTopDiv', positionDiv, 'margin-bottom:14px;');
        // tslint:disable-next-line:max-line-length
        var headerTopLabel = createElement('label', { className: 'e-de-prop-sub-label', styles: 'display:block' });
        headerTopLabel.innerHTML = localObj.getConstant('Header from Top');
        headerTopDiv.appendChild(headerTopLabel);
        // tslint:disable-next-line:max-line-length
        var headerFromTop = createElement('input', { id: 'headerFromTop', className: 'e-de-prop-sub-label' });
        headerTopDiv.appendChild(headerFromTop);
        // tslint:disable-next-line:max-line-length
        this.headerFromTop = new NumericTextBox({
            value: 36, cssClass: 'e-de-prop-header-numeric',
            showSpinButton: false, format: 'n0', decimals: 2, max: 1584, min: 0, enableRtl: this.isRtl
        });
        this.headerFromTop.appendTo(headerFromTop);
        // tslint:disable-next-line:max-line-length
        this.headerFromTop.element.parentElement.setAttribute('title', localObj.getConstant('Distance from top of the page to top of the header'));
        // tslint:disable-next-line:max-line-length
        var footerBottomDiv = this.createDivTemplate(elementId + '_footerBottomDiv', positionDiv);
        // tslint:disable-next-line:max-line-length
        var footerBottomLabel = createElement('label', { className: 'e-de-prop-sub-label', styles: 'display:block' });
        footerBottomLabel.innerHTML = localObj.getConstant('Footer from Bottom');
        footerBottomDiv.appendChild(footerBottomLabel);
        // tslint:disable-next-line:max-line-length
        var footerFromTop = createElement('input', { id: 'footerFromTop', className: 'e-de-prop-sub-label' });
        footerBottomDiv.appendChild(footerFromTop);
        // tslint:disable-next-line:max-line-length
        this.footerFromTop = new NumericTextBox({
            value: 36, cssClass: 'e-de-prop-header-numeric',
            showSpinButton: false, format: 'n0', decimals: 2, max: 1584, min: 0, enableRtl: this.isRtl
        });
        this.footerFromTop.appendTo(footerFromTop);
        // tslint:disable-next-line:max-line-length
        this.footerFromTop.element.parentElement.setAttribute('title', localObj.getConstant('Distance from bottom of the page to bottom of the footer'));
    };
    HeaderFooterProperties.prototype.createDivTemplate = function (id, parentDiv, style) {
        var divElement;
        if (style) {
            divElement = createElement('div', { id: id, styles: style });
        }
        else {
            divElement = createElement('div', { id: id });
        }
        parentDiv.appendChild(divElement);
        return divElement;
    };
    HeaderFooterProperties.prototype.onSelectionChange = function () {
        this.headerFromTop.value = this.documentEditor.selection.sectionFormat.headerDistance;
        this.footerFromTop.value = this.documentEditor.selection.sectionFormat.footerDistance;
        if (this.documentEditor.selection.sectionFormat.differentFirstPage) {
            this.firstPage.checked = true;
        }
        else {
            this.firstPage.checked = false;
        }
        if (this.documentEditor.selection.sectionFormat.differentOddAndEvenPages) {
            this.oddOrEven.checked = true;
        }
        else {
            this.oddOrEven.checked = false;
        }
    };
    HeaderFooterProperties.prototype.destroy = function () {
        if (this.headerFromTop) {
            this.headerFromTop.destroy();
            this.headerFromTop = undefined;
        }
        if (this.footerFromTop) {
            this.footerFromTop.destroy();
            this.footerFromTop = undefined;
        }
    };
    return HeaderFooterProperties;
}());

/**
 * Image Property pane
 * @private
 */
var ImageProperties = /** @__PURE__ @class */ (function () {
    function ImageProperties(container, isRtl) {
        var _this = this;
        this.isWidthApply = false;
        this.isHeightApply = false;
        this.initializeImageProperties = function () {
            // tslint:disable-next-line:max-line-length
            _this.element = createElement('div', { id: _this.elementId + '_imageProperties', className: 'e-de-prop-pane' });
            _this.element.style.display = 'none';
            _this.container.propertiesPaneContainer.appendChild(_this.element);
            _this.initImageProp();
            _this.wireEvents();
        };
        this.initImageProp = function () {
            var localObj = new L10n('documenteditorcontainer', _this.container.defaultLocale, _this.container.locale);
            // tslint:disable-next-line:max-line-length
            var imageDiv = createElement('div', { id: _this.elementId + '_imageDiv', className: 'e-de-cntr-pane-padding', styles: 'border:0px' });
            _this.element.appendChild(imageDiv);
            var label = createElement('label', { className: 'e-de-ctnr-prop-label' });
            label.textContent = localObj.getConstant('Image');
            imageDiv.appendChild(label);
            var outerDiv = createElement('div');
            imageDiv.appendChild(outerDiv);
            // tslint:disable-next-line:max-line-length
            _this.widthElement = _this.createImagePropertiesDiv('_widthDiv', outerDiv, '_widthInput', localObj.getConstant('W'), localObj.getConstant('Width'));
            // tslint:disable-next-line:max-line-length
            _this.widthNumericBox = new NumericTextBox({ min: 0, max: 23500, cssClass: 'e-de-image-property', showSpinButton: false, format: 'n0', decimals: 2 });
            _this.widthNumericBox.appendTo(_this.widthElement);
            // tslint:disable-next-line:max-line-length
            _this.heightElement = _this.createImagePropertiesDiv('_heightDiv', outerDiv, '_heightInput', localObj.getConstant('H'), localObj.getConstant('Height'));
            // tslint:disable-next-line:max-line-length
            _this.heightNumericBox = new NumericTextBox({ min: 0, max: 23500, cssClass: 'e-de-image-property', showSpinButton: false, format: 'n0', decimals: 2 });
            _this.heightNumericBox.appendTo(_this.heightElement);
            // tslint:disable-next-line:max-line-length        
            var aspectRatioDiv = createElement('div', { id: _this.elementId + '_aspectRatioDiv' });
            aspectRatioDiv.setAttribute('title', localObj.getConstant('Aspect ratio'));
            outerDiv.appendChild(aspectRatioDiv);
            // tslint:disable-next-line:max-line-length
            var aspectRatio = createElement('input', { id: _this.elementId + '_aspectRatio', className: 'e-de-ctnr-prop-label' });
            aspectRatioDiv.appendChild(aspectRatio);
            _this.aspectRatioBtn = new CheckBox({ label: localObj.getConstant('Aspect ratio'), enableRtl: _this.isRtl }, aspectRatio);
        };
        // tslint:disable-next-line:max-line-length
        this.createImagePropertiesDiv = function (id, outerDiv, inputId, spanContent, tooltip) {
            // tslint:disable-next-line:max-line-length
            var divElement = createElement('div', { id: _this.elementId + id, styles: 'position: relative;width: 100%;', className: 'e-de-ctnr-segment' });
            divElement.setAttribute('title', tooltip);
            outerDiv.appendChild(divElement);
            // tslint:disable-next-line:max-line-length
            var inputElement = createElement('input', { id: _this.elementId + inputId, className: 'e-textbox', styles: 'width:100%;' });
            divElement.appendChild(inputElement);
            var spanElement = createElement('span', { className: 'e-de-img-prty-span' });
            spanElement.textContent = spanContent;
            divElement.appendChild(spanElement);
            return inputElement;
        };
        this.wireEvents = function () {
            _this.aspectRatioBtn.element.addEventListener('change', _this.onAspectRatioBtnClick);
            _this.widthNumericBox.element.addEventListener('click', function () { _this.isWidthApply = true; });
            _this.heightNumericBox.element.addEventListener('click', function () { _this.isHeightApply = true; });
            _this.widthNumericBox.element.addEventListener('keydown', _this.onImageWidth);
            _this.heightNumericBox.element.addEventListener('keydown', _this.onImageHeight);
            _this.widthNumericBox.element.addEventListener('blur', function () { _this.applyImageWidth(); _this.isWidthApply = false; });
            _this.heightNumericBox.element.addEventListener('blur', function () { _this.applyImageHeight(); _this.isHeightApply = false; });
        };
        this.onImageWidth = function (e) {
            if (e.keyCode === 13) {
                setTimeout(function () { _this.applyImageWidth(); _this.isWidthApply = false; }, 30);
            }
        };
        this.onImageHeight = function (e) {
            if (e.keyCode === 13) {
                setTimeout(function () { _this.applyImageHeight(); _this.isHeightApply = false; }, 30);
            }
        };
        this.applyImageWidth = function () {
            if (!_this.isMaintainAspectRatio) {
                // tslint:disable-next-line:max-line-length
                var width = _this.widthNumericBox.value;
                var height = _this.heightNumericBox.value;
                if (width > _this.widthNumericBox.max) {
                    width = _this.widthNumericBox.max;
                }
                if (height > _this.heightNumericBox.max) {
                    height = _this.heightNumericBox.max;
                }
                if (!(width === null || height === null)) {
                    _this.documentEditor.selection.imageFormat.resize(width, height);
                }
            }
            else if (_this.isMaintainAspectRatio) {
                // tslint:disable-next-line:max-line-length
                var width = _this.widthNumericBox.value;
                if (width > _this.widthNumericBox.max) {
                    width = _this.widthNumericBox.max;
                }
                var ratio = width / _this.documentEditor.selection.imageFormat.width;
                var height = _this.heightNumericBox.value * ratio;
                _this.heightNumericBox.value = height;
                if (!(width === null || height === null)) {
                    _this.documentEditor.selection.imageFormat.resize(width, height);
                }
            }
        };
        this.applyImageHeight = function () {
            if (!_this.isMaintainAspectRatio) {
                // tslint:disable-next-line:max-line-length
                var width = _this.widthNumericBox.value;
                var height = _this.heightNumericBox.value;
                if (!(width === null || height === null)) {
                    _this.documentEditor.selection.imageFormat.resize(width, height);
                }
            }
            else if (_this.isMaintainAspectRatio) {
                // tslint:disable-next-line:max-line-length
                var height = _this.heightNumericBox.value;
                var ratio = height / _this.documentEditor.selection.imageFormat.height;
                var width = _this.widthNumericBox.value * ratio;
                _this.widthNumericBox.value = width;
                if (!(width === null || height === null)) {
                    _this.documentEditor.selection.imageFormat.resize(width, height);
                }
            }
        };
        this.onAspectRatioBtnClick = function () {
            if (_this.isMaintainAspectRatio) {
                _this.isMaintainAspectRatio = false;
            }
            else {
                _this.isMaintainAspectRatio = true;
            }
        };
        this.container = container;
        this.elementId = this.documentEditor.element.id;
        this.isMaintainAspectRatio = false;
        this.isRtl = isRtl;
        this.initializeImageProperties();
    }
    Object.defineProperty(ImageProperties.prototype, "documentEditor", {
        get: function () {
            return this.container.documentEditor;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ImageProperties.prototype.enableDisableElements = function (enable) {
        if (enable) {
            classList(this.element, [], ['e-de-overlay']);
        }
        else {
            classList(this.element, ['e-de-overlay'], []);
        }
    };
    ImageProperties.prototype.showImageProperties = function (isShow) {
        if (this.element.style.display === 'block') {
            this.updateImageProperties();
        }
        if (!isShow && this.element.style.display === 'none' || (isShow && this.element.style.display === 'block')) {
            return;
        }
        this.element.style.display = isShow ? 'block' : 'none';
        this.documentEditor.resize();
    };
    ImageProperties.prototype.updateImageProperties = function () {
        this.widthNumericBox.value = this.documentEditor.selection.imageFormat.width;
        this.heightNumericBox.value = this.documentEditor.selection.imageFormat.height;
    };
    ImageProperties.prototype.destroy = function () {
        this.container = undefined;
        if (this.widthNumericBox) {
            this.widthNumericBox.destroy();
            this.widthNumericBox = undefined;
        }
        if (this.heightNumericBox) {
            this.heightNumericBox.destroy();
            this.heightNumericBox = undefined;
        }
    };
    return ImageProperties;
}());

/**
 * TOC Properties pane
 * @private
 */
var TocProperties = /** @__PURE__ @class */ (function () {
    function TocProperties(container, isRtl) {
        var _this = this;
        this.initializeTocPane = function () {
            _this.localObj = new L10n('documenteditorcontainer', _this.container.defaultLocale, _this.container.locale);
            // tslint:disable-next-line:max-line-length
            _this.element = createElement('div', { id: _this.elementId + '_tocProperties', className: 'e-de-prop-pane' });
            var container = createElement('div', { className: 'e-de-cntr-pane-padding e-de-prop-separator-line' });
            _this.tocHeaderDiv(container);
            _this.initTemplates(container);
            container = createElement('div', { className: 'e-de-cntr-pane-padding' });
            _this.tocOptionsDiv(container);
            _this.contentStylesDropdown(container);
            _this.checkboxContent(container);
            _this.buttonDiv(container);
            _this.wireEvents();
            _this.updateTocProperties();
            _this.container.propertiesPaneContainer.appendChild(_this.element);
        };
        this.updateTocProperties = function () {
            _this.rightalignPageNumber.checked = true;
            _this.showPageNumber.checked = true;
            _this.hyperlink.checked = true;
        };
        this.wireEvents = function () {
            _this.cancelBtn.element.addEventListener('click', function () { _this.onClose(); });
            _this.updateBtn.element.addEventListener('click', _this.onInsertToc);
            _this.closeButton.addEventListener('click', function () { _this.onClose(); });
        };
        this.onClose = function () {
            if (_this.container.showPropertiesPane
                && _this.container.previousContext !== 'TableOfContents') {
                _this.container.showPropertiesPaneOnSelection();
            }
            else {
                _this.showTocPane(false);
                if (_this.toolbar) {
                    _this.toolbar.enableDisablePropertyPaneButton(false);
                }
                _this.container.showPropertiesPane = false;
            }
        };
        this.tocHeaderDiv = function (container) {
            var closeButtonFloat;
            var closeButtonMargin;
            if (!_this.isRtl) {
                closeButtonFloat = 'float:right;';
                closeButtonMargin = 'margin-right:7px;';
            }
            else {
                closeButtonFloat = 'float:left;';
                closeButtonMargin = 'margin-left:7px;';
            }
            var headerDiv = createElement('div', {
                id: _this.elementId + 'toc_id',
                styles: 'display: block;'
            });
            container.appendChild(headerDiv);
            _this.element.appendChild(container);
            var title = createElement('label', {
                className: 'e-de-ctnr-prop-label'
            });
            title.textContent = _this.localObj.getConstant('Table of Contents');
            headerDiv.appendChild(title);
            _this.closeButton = createElement('span', {
                className: 'e-de-ctnr-close e-icons',
                styles: 'cursor: pointer;display:inline-block;color: #4A4A4A;' + closeButtonFloat + closeButtonMargin
            });
            headerDiv.appendChild(_this.closeButton);
        };
        this.initTemplates = function (container) {
            _this.template1(container);
            // tslint:disable-next-line:max-line-length
            // let div: HTMLElement = createElement('div', { styles: 'display:block;border-top: 1px solid #E0E0E0;' }); this.element.appendChild(div);
        };
        this.template1 = function (container) {
            _this.template1Div = createElement('div', {
                className: 'e-de-toc-template1'
            });
            if (_this.isRtl) {
                _this.template1Div.classList.add('e-de-rtl');
            }
            container.appendChild(_this.template1Div);
            var templateContent1 = createElement('div', {
                className: 'e-de-toc-template1-content1'
            });
            templateContent1.textContent = _this.localObj.getConstant('HEADING - - - - 1');
            _this.template1Div.appendChild(templateContent1);
            var templateContent2 = createElement('div', {
                className: 'e-de-toc-template1-content2'
            });
            templateContent2.textContent = _this.localObj.getConstant('HEADING - - - - 2');
            _this.template1Div.appendChild(templateContent2);
            var templateContent3 = createElement('div', {
                className: 'e-de-toc-template1-content3'
            });
            templateContent3.textContent = _this.localObj.getConstant('HEADING - - - - 3');
            _this.template1Div.appendChild(templateContent3);
        };
        this.tocOptionsDiv = function (container) {
            var optionsDiv = createElement('div');
            container.appendChild(optionsDiv);
            _this.element.appendChild(container);
            if (_this.isRtl) {
                optionsDiv.classList.add('e-de-rtl');
            }
            var label = createElement('label', { className: 'e-de-ctnr-prop-label' });
            label.textContent = _this.localObj.getConstant('Options');
            optionsDiv.appendChild(label);
        };
        /* tslint:disable */
        this.contentStylesDropdown = function (container) {
            if (!_this.isRtl) {
                
            }
            else {
                
            }
            var contentStyleElement = createElement('div', { id: 'contentstyle_div' });
            // tslint:disable-next-line:max-line-length
            contentStyleElement.setAttribute('title', _this.localObj.getConstant('Number of heading or outline levels to be shown in table of contents'));
            container.appendChild(contentStyleElement);
            // let items: ItemModel[] = [{ text: '___________', id: 'solid' }];
            // this.borderStyle = this.createDropDownButton(
            //     this.elementId + '_borderStyleDiv',
            //     'width:120px;height:28px;margin-top:8px', contentStyleElement, 'e-de-icon-stroke-size', 'Solid', items
            // );
            if (!_this.isRtl) {
                
            }
            else {
                
            }
            var label = createElement('label', { className: 'e-de-prop-sub-label', styles: 'display:block' });
            label.textContent = _this.localObj.getConstant('Levels');
            contentStyleElement.appendChild(label);
            container.appendChild(contentStyleElement);
            var dataSource = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
            _this.borderLevelStyle = _this.createDropDownButton(_this.elementId + '_borderLevelDiv', contentStyleElement, '', dataSource, 2);
            _this.borderLevelStyle.change = function (args) {
                _this.borderLevelStyle.value = args.item.value;
            };
            container.appendChild(contentStyleElement);
        };
        this.checkboxContent = function (container) {
            if (!_this.isRtl) {
                
            }
            else {
                
            }
            // tslint:disable-next-line:max-line-length
            var checkboxElement = createElement('div', { id: 'toc_checkboxDiv', styles: 'margin-bottom:36px;' });
            container.appendChild(checkboxElement);
            var showPageNumberDiv = createElement('div', { className: 'e-de-toc-checkbox1' });
            showPageNumberDiv.setAttribute('title', _this.localObj.getConstant('Show page numbers in table of contents'));
            checkboxElement.appendChild(showPageNumberDiv);
            // tslint:disable-next-line:max-line-length
            var showpagenumberCheckboxElement = createElement('input', { id: 'showpagenumber', styles: 'width:12px;height:12px;margin-bottom:8px', className: 'e-de-prop-sub-label' });
            showPageNumberDiv.appendChild(showpagenumberCheckboxElement);
            _this.showPageNumber = new CheckBox({
                label: _this.localObj.getConstant('Show page numbers'),
                enableRtl: _this.isRtl
            });
            _this.showPageNumber.appendTo(showpagenumberCheckboxElement);
            var rightAlignDiv = createElement('div', { className: 'e-de-toc-checkbox2' });
            rightAlignDiv.setAttribute('title', _this.localObj.getConstant('Right align page numbers in table of contents'));
            checkboxElement.appendChild(rightAlignDiv);
            // tslint:disable-next-line:max-line-length
            var rightalignpagenumberCheckboxElement = createElement('input', { id: 'rightalignpagenumber', styles: 'width:12px;height:12px', className: 'e-de-prop-sub-label' });
            rightAlignDiv.appendChild(rightalignpagenumberCheckboxElement);
            _this.rightalignPageNumber = new CheckBox({
                label: _this.localObj.getConstant('Right align page numbers'),
                enableRtl: _this.isRtl
            });
            _this.rightalignPageNumber.appendTo(rightalignpagenumberCheckboxElement);
            var hyperlinkDiv = createElement('div', { className: 'e-de-toc-checkbox3' });
            hyperlinkDiv.setAttribute('title', _this.localObj.getConstant('Use hyperlinks instead of page numbers'));
            checkboxElement.appendChild(hyperlinkDiv);
            // tslint:disable-next-line:max-line-length
            var hyperlinkCheckboxElement = createElement('input', { id: 'hyperlinkdiv', styles: 'width:12px;height:12px', className: 'e-de-prop-sub-label' });
            hyperlinkDiv.appendChild(hyperlinkCheckboxElement);
            _this.hyperlink = new CheckBox({
                label: _this.localObj.getConstant('Use hyperlinks'),
                enableRtl: _this.isRtl
            });
            _this.hyperlink.appendTo(hyperlinkCheckboxElement);
        };
        this.buttonDiv = function (container) {
            var footerElementFloat;
            if (!_this.isRtl) {
                footerElementFloat = 'float:right';
            }
            else {
                footerElementFloat = 'float:left';
            }
            var footerElement = createElement('div', { id: 'footerDiv', styles: footerElementFloat });
            container.appendChild(footerElement);
            var updatebuttoncontentStyleElement = createElement('button', {
                id: 'footerupdatebuttonDiv',
                attrs: { type: 'button' }
            });
            footerElement.appendChild(updatebuttoncontentStyleElement);
            _this.updateBtn = new Button({
                content: _this.localObj.getConstant('Update'), cssClass: 'btn-update', isPrimary: true
            });
            _this.updateBtn.appendTo(updatebuttoncontentStyleElement);
            var cancelbuttoncontentStyleElement = createElement('button', {
                id: 'footercancelbuttonDiv',
                attrs: { type: 'button' }
            });
            footerElement.appendChild(cancelbuttoncontentStyleElement);
            _this.cancelBtn = new Button({
                content: _this.localObj.getConstant('Cancel'), cssClass: _this.isRtl ? 'e-de-btn-cancel-rtl' : 'e-de-btn-cancel'
            });
            _this.cancelBtn.appendTo(cancelbuttoncontentStyleElement);
        };
        this.showTocPane = function (isShow, previousContextType) {
            if (!isShow && _this.element.style.display === 'none' || (isShow && _this.element.style.display === 'block')) {
                return;
            }
            _this.element.style.display = isShow ? 'block' : 'none';
            // tslint:disable-next-line:max-line-length
            _this.updateBtn.content = _this.documentEditor.selection.contextType === 'TableOfContents' ? _this.localObj.getConstant('Update') : _this.localObj.getConstant('Insert');
            _this.prevContext = _this.documentEditor.selection.contextType;
            _this.documentEditor.resize();
            if (isShow) {
                _this.updateBtn.element.focus();
            }
        };
        this.onInsertToc = function () {
            var tocSettings = {
                startLevel: 1,
                endLevel: parseInt(_this.borderLevelStyle.value, 0),
                includeHyperlink: _this.hyperlink.checked,
                includePageNumber: _this.showPageNumber.checked,
                rightAlign: _this.rightalignPageNumber.checked
            };
            if (tocSettings.rightAlign) {
                tocSettings.tabLeader = 'Dot';
            }
            _this.documentEditor.editor.insertTableOfContents(tocSettings);
        };
        this.container = container;
        this.elementId = this.documentEditor.element.id;
        this.isRtl = isRtl;
        this.initializeTocPane();
    }
    Object.defineProperty(TocProperties.prototype, "documentEditor", {
        /**
         * @private
         */
        get: function () {
            return this.container.documentEditor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TocProperties.prototype, "toolbar", {
        /**
         * @private
         */
        get: function () {
            return this.container.toolbarModule;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    TocProperties.prototype.enableDisableElements = function (enable) {
        if (enable) {
            classList(this.element, [], ['e-de-overlay']);
        }
        else {
            classList(this.element, ['e-de-overlay'], []);
        }
    };
    /* tslint:disable */
    TocProperties.prototype.createDropdownOption = function (ulTag, text) {
        var liTag = createElement('li', {
            styles: 'display:block',
            className: 'e-de-floating-menuitem e-de-floating-menuitem-md de-list-items  de-list-item-size'
        });
        ulTag.appendChild(liTag);
        var innerHTML;
        if (text === 'None') {
            innerHTML = '<div>' + text + '</div>';
        }
        else if (text === '1.5px') {
            // tslint:disable-next-line:max-line-length
            innerHTML = '<div>' + text + '<span class="e-de-list-line" style="margin-left:10px;border-bottom-width:' + text + '"></span></div>';
        }
        else {
            // tslint:disable-next-line:max-line-length
            innerHTML = '<div>' + text + '<span class="e-de-list-line" style="margin-left:20px;border-bottom-width:' + text + '"></span></div>';
        }
        var liInnerDiv = createElement('div', {
            className: 'e-de-list-header-presetmenu',
            innerHTML: innerHTML
        });
        liTag.appendChild(liInnerDiv);
        return liTag;
    };
    // tslint:disable-next-line:max-line-length
    TocProperties.prototype.createDropDownButton = function (id, parentDiv, iconCss, content, selectedIndex) {
        var buttonElement = createElement('input', { id: id });
        parentDiv.appendChild(buttonElement);
        // tslint:disable-next-line:max-line-length  
        var dropDownBtn = new DropDownList({ index: selectedIndex, dataSource: content, popupHeight: '150px', cssClass: 'e-de-prop-font-button' }, buttonElement);
        return dropDownBtn;
    };
    TocProperties.prototype.destroy = function () {
        this.container = undefined;
        if (this.showPageNumber) {
            this.showPageNumber.destroy();
            this.showPageNumber = undefined;
        }
        if (this.rightalignPageNumber) {
            this.rightalignPageNumber.destroy();
            this.rightalignPageNumber = undefined;
        }
        if (this.borderBtn) {
            this.borderBtn.destroy();
            this.borderBtn = undefined;
        }
        if (this.borderLevelStyle) {
            this.borderLevelStyle.destroy();
            this.borderLevelStyle = undefined;
        }
    };
    return TocProperties;
}());

/**
 * Represents table properties
 * @private
 */
var TableProperties = /** @__PURE__ @class */ (function () {
    function TableProperties(container, imageProperty, textProperties, isRtl) {
        var _this = this;
        this.isTopMarginApply = false;
        this.isRightMarginApply = false;
        this.isBottomMarginApply = false;
        this.isLeftMarginApply = false;
        this.borderColor = '#000000';
        this.groupButtonClass = 'e-de-ctnr-group-btn e-btn-group';
        this.initializeTablePropPane = function () {
            _this.localObj = new L10n('documenteditorcontainer', _this.container.defaultLocale, _this.container.locale);
            _this.tableProperties = createElement('div', { id: _this.elementId + '_tableProperties' });
            _this.initFillColorDiv();
            _this.initBorderStylesDiv();
            _this.initCellDiv();
            _this.initInsertOrDelCell();
            _this.initCellMargin();
            _this.initAlignText();
            _this.addTablePropertyTab();
            // wire fnt property
            _this.wireEvent();
        };
        this.addTablePropertyTab = function () {
            var tableHeader = createElement('div', { innerHTML: _this.localObj.getConstant('Table') });
            var textHeader = createElement('div', { innerHTML: _this.localObj.getConstant('Text') });
            // tslint:disable-next-line:max-line-length
            _this.parentElement = createElement('div', { styles: 'height:100%;overflow:auto;display:none', className: 'e-de-prop-pane' });
            _this.element = createElement('div', { id: _this.elementId + '_propertyTabDiv', className: 'e-de-property-tab' });
            // tslint:disable-next-line:max-line-length
            var items = [{ header: { text: tableHeader }, content: _this.tableProperties }, { header: { text: textHeader }, content: _this.tableTextProperties.element }];
            _this.propertiesTab = new Tab({ items: items, animation: { previous: { effect: 'None' }, next: { effect: 'None' } }, selected: _this.onTabSelection });
            _this.propertiesTab.isStringTemplate = true;
            _this.propertiesTab.appendTo(_this.element);
            _this.parentElement.appendChild(_this.element);
            _this.container.propertiesPaneContainer.appendChild(_this.parentElement);
        };
        this.onTabSelection = function () {
            _this.documentEditor.resize();
        };
        this.wireEvent = function () {
            _this.shadingBtn.addEventListener('change', _this.changeBackgroundColor);
            // tslint:disable-next-line:max-line-length
            _this.borderBtn.addEventListener('change', function (args) { setTimeout(function () { _this.borderColor = args.currentValue.hex; _this.tableOutlineBorder.element.focus(); }, 10); });
            _this.tableOutlineBorder.element.addEventListener('click', _this.onOutlineBorder);
            _this.tableAllBorder.element.addEventListener('click', _this.onAllBorder);
            _this.tableCenterBorder.element.addEventListener('click', _this.onInsideBorder);
            _this.tableLeftBorder.element.addEventListener('click', _this.onLeftBorder);
            _this.tableCenterVerticalBorder.element.addEventListener('click', _this.onVerticalBorder);
            _this.tableRightBorder.element.addEventListener('click', _this.onRightBorder);
            _this.tableTopBorder.element.addEventListener('click', _this.onTopBorder);
            _this.tableCenterHorizontalBorder.element.addEventListener('click', _this.onHorizontalBorder);
            _this.tableBottomBorder.element.addEventListener('click', _this.onBottomBorder);
            _this.insertRowAbove.element.addEventListener('click', _this.onInsertRowAbove);
            _this.insertRowBelow.element.addEventListener('click', _this.onInsertRowBelow);
            _this.insertColumnLeft.element.addEventListener('click', _this.onInsertColumnLeft);
            _this.insertColumnRight.element.addEventListener('click', _this.onInsertColumnRight);
            _this.deleteRow.element.addEventListener('click', _this.onDeleteRow);
            _this.deleteColumn.element.addEventListener('click', _this.onDeleteColumn);
            _this.horizontalMerge.element.addEventListener('click', _this.onMergeCell);
            _this.alignTop.element.addEventListener('click', _this.applyAlignTop);
            _this.alignBottom.element.addEventListener('click', _this.applyAlignBottom);
            _this.alignCenterHorizontal.element.addEventListener('click', _this.applyAlignCenterHorizontal);
            _this.topMargin.element.addEventListener('click', function () { _this.isTopMarginApply = true; });
            _this.rightMargin.element.addEventListener('click', function () { _this.isRightMarginApply = true; });
            _this.leftMargin.element.addEventListener('click', function () { _this.isLeftMarginApply = true; });
            _this.bottomMargin.element.addEventListener('click', function () { _this.isBottomMarginApply = true; });
            _this.topMargin.element.addEventListener('keydown', _this.onTopMargin);
            _this.rightMargin.element.addEventListener('keydown', _this.onRightMargin);
            _this.leftMargin.element.addEventListener('keydown', _this.onLeftMargin);
            _this.bottomMargin.element.addEventListener('keydown', _this.onBottomMargin);
            _this.topMargin.element.addEventListener('blur', function () { _this.applyTopMargin(); _this.isTopMarginApply = false; });
            _this.rightMargin.element.addEventListener('blur', function () { _this.applyRightMargin(); _this.isRightMarginApply = false; });
            _this.leftMargin.element.addEventListener('blur', function () { _this.applyLeftMargin(); _this.isLeftMarginApply = false; });
            _this.bottomMargin.element.addEventListener('blur', function () { _this.applyBottomMargin(); _this.isBottomMarginApply = false; });
        };
        this.getBorder = function (border) {
            var lineWidth = (_this.borderSize.content.indexOf('No Border') >= 0) ? 0 : parseInt(_this.borderSize.content, 0);
            var linestyle = (lineWidth === 0) ? 'Cleared' : 'Single';
            var borderSettings = {
                type: border,
                borderColor: _this.borderColor,
                lineWidth: lineWidth,
                borderStyle: linestyle
            };
            return borderSettings;
        };
        this.onOutlineBorder = function () {
            _this.documentEditor.editor.applyBorders(_this.getBorder('OutsideBorders'));
        };
        this.onAllBorder = function () {
            _this.documentEditor.editor.applyBorders(_this.getBorder('AllBorders'));
        };
        this.onInsideBorder = function () {
            _this.documentEditor.editor.applyBorders(_this.getBorder('InsideBorders'));
        };
        this.onLeftBorder = function () {
            _this.documentEditor.editor.applyBorders(_this.getBorder('LeftBorder'));
        };
        this.onVerticalBorder = function () {
            _this.documentEditor.editor.applyBorders(_this.getBorder('InsideVerticalBorder'));
        };
        this.onRightBorder = function () {
            _this.documentEditor.editor.applyBorders(_this.getBorder('RightBorder'));
        };
        this.onTopBorder = function () {
            _this.documentEditor.editor.applyBorders(_this.getBorder('TopBorder'));
        };
        this.onHorizontalBorder = function () {
            _this.documentEditor.editor.applyBorders(_this.getBorder('InsideHorizontalBorder'));
        };
        this.onBottomBorder = function () {
            _this.documentEditor.editor.applyBorders(_this.getBorder('BottomBorder'));
        };
        this.onTopMargin = function (e) {
            if (e.keyCode === 13) {
                setTimeout(function () { _this.applyTopMargin(); _this.isTopMarginApply = false; }, 30);
            }
        };
        this.onBottomMargin = function (e) {
            if (e.keyCode === 13) {
                setTimeout(function () { _this.applyBottomMargin(); _this.isBottomMarginApply = false; }, 30);
            }
        };
        this.onLeftMargin = function (e) {
            if (e.keyCode === 13) {
                setTimeout(function () { _this.applyLeftMargin(); _this.isLeftMarginApply = false; }, 30);
            }
        };
        this.onRightMargin = function (e) {
            if (e.keyCode === 13) {
                setTimeout(function () { _this.applyRightMargin(); _this.isRightMarginApply = false; }, 30);
            }
        };
        this.applyTopMargin = function () {
            if (!_this.isTopMarginApply) {
                return;
            }
            _this.documentEditor.selection.cellFormat.topMargin = (_this.topMargin.value > _this.topMargin.max)
                ? _this.topMargin.max : _this.topMargin.value;
        };
        this.applyBottomMargin = function () {
            if (!_this.isBottomMarginApply) {
                return;
            }
            _this.documentEditor.selection.cellFormat.bottomMargin = (_this.bottomMargin.value > _this.bottomMargin.max)
                ? _this.bottomMargin.max : _this.bottomMargin.value;
        };
        this.applyLeftMargin = function () {
            if (!_this.isLeftMarginApply) {
                return;
            }
            _this.documentEditor.selection.cellFormat.leftMargin = (_this.leftMargin.value > _this.leftMargin.max)
                ? _this.leftMargin.max : _this.leftMargin.value;
        };
        this.applyRightMargin = function () {
            if (!_this.isRightMarginApply) {
                return;
            }
            _this.documentEditor.selection.cellFormat.rightMargin = (_this.rightMargin.value > _this.rightMargin.max)
                ? _this.rightMargin.max : _this.rightMargin.value;
        };
        this.applyAlignTop = function () {
            _this.documentEditor.selection.cellFormat.verticalAlignment = 'Top';
        };
        this.applyAlignBottom = function () {
            _this.documentEditor.selection.cellFormat.verticalAlignment = 'Bottom';
        };
        this.applyAlignCenterHorizontal = function () {
            _this.documentEditor.selection.cellFormat.verticalAlignment = 'Center';
        };
        this.onMergeCell = function () {
            _this.documentEditor.editor.mergeCells();
        };
        this.onInsertRowAbove = function () {
            _this.documentEditor.editor.insertRow(true);
        };
        this.onInsertRowBelow = function () {
            _this.documentEditor.editor.insertRow(false);
        };
        this.onInsertColumnLeft = function () {
            _this.documentEditor.editor.insertColumn(true);
        };
        this.onInsertColumnRight = function () {
            _this.documentEditor.editor.insertColumn(false);
        };
        this.onDeleteRow = function () {
            _this.documentEditor.editor.deleteRow();
        };
        this.onDeleteColumn = function () {
            _this.documentEditor.editor.deleteColumn();
        };
        this.onSelectionChange = function () {
            if (_this.documentEditor.selection) {
                if (_this.documentEditor.editor && _this.documentEditor.editor.canMergeCells()) {
                    _this.horizontalMerge.disabled = false;
                }
                else {
                    _this.horizontalMerge.disabled = true;
                }
                if (_this.documentEditor.selection.contextType === 'TableText' || _this.documentEditor.selection.contextType === 'TableImage') {
                    _this.shadingBtn.value = _this.documentEditor.selection.cellFormat.background;
                }
                // tslint:disable-next-line:max-line-length
                _this.topMargin.value = _this.documentEditor.selection.cellFormat.topMargin ? _this.documentEditor.selection.cellFormat.topMargin : 0;
                // tslint:disable-next-line:max-line-length
                _this.bottomMargin.value = _this.documentEditor.selection.cellFormat.bottomMargin ? _this.documentEditor.selection.cellFormat.bottomMargin : 0;
                // tslint:disable-next-line:max-line-length
                _this.rightMargin.value = _this.documentEditor.selection.cellFormat.rightMargin ? _this.documentEditor.selection.cellFormat.rightMargin : 0;
                // tslint:disable-next-line:max-line-length
                _this.leftMargin.value = _this.documentEditor.selection.cellFormat.leftMargin ? _this.documentEditor.selection.cellFormat.leftMargin : 0;
            }
        };
        this.changeBackgroundColor = function (args) {
            if (!_this.documentEditor.isReadOnly) {
                //Handle API for shading.
                _this.documentEditor.selection.cellFormat.background = args.currentValue.hex;
                setTimeout(function () { _this.documentEditor.focusIn(); }, 10);
            }
        };
        this.initFillColorDiv = function () {
            // tslint:disable-next-line:max-line-length
            var fillDiv = createElement('div', { id: _this.elementId + '_fillColorDiv', className: 'e-de-property-div-padding de-tbl-fill-clr' });
            _this.tableProperties.appendChild(fillDiv);
            var label = createElement('label', { className: 'e-de-prop-sub-label' });
            label.classList.add('e-de-prop-fill-label');
            if (_this.isRtl) {
                label.classList.add('e-de-rtl');
            }
            label.textContent = _this.localObj.getConstant('Fill');
            fillDiv.appendChild(label);
            _this.shadingBtn = _this.createColorPickerTemplate(_this.elementId + '_tableShading', fillDiv, _this.localObj.getConstant('Fill color'), false);
            // tslint:disable-next-line:max-line-length
            classList(fillDiv.lastElementChild.lastElementChild.lastElementChild.firstChild, ['e-de-ctnr-cellbg-clr-picker'], ['e-caret']);
        };
        this.initBorderStylesDiv = function () {
            var borderStyleDiv = createElement('div', { className: 'e-de-property-div-padding' });
            _this.tableProperties.appendChild(borderStyleDiv);
            var label = createElement('label', { className: 'e-de-ctnr-prop-label' });
            label.classList.add('e-de-table-prop-label');
            label.textContent = _this.localObj.getConstant('Border Style');
            borderStyleDiv.appendChild(label);
            // tslint:disable-next-line:max-line-length
            var parentDiv = createElement('div', { id: _this.elementId + '_borderStyleDiv', className: 'e-de-border-style-div', styles: 'display:inline-flex;' });
            var styleDiv = createElement('div', { styles: 'width:126px;height:126px', className: 'e-de-grp-btn-ctnr' });
            var div1 = createElement('div', { className: _this.groupButtonClass + ' e-de-ctnr-group-btn-top' });
            styleDiv.appendChild(div1);
            var div2 = createElement('div', { className: _this.groupButtonClass + ' e-de-ctnr-group-btn-middle' });
            styleDiv.appendChild(div2);
            var div3 = createElement('div', { className: _this.groupButtonClass + ' e-de-ctnr-group-btn-bottom' });
            styleDiv.appendChild(div3);
            if (_this.isRtl) {
                div1.classList.add('e-de-rtl');
                div3.classList.add('e-de-rtl');
                parentDiv.classList.add('e-de-rtl');
                label.classList.add('e-de-rtl');
            }
            var btnStyle = '';
            // tslint:disable-next-line:max-line-length
            _this.tableOutlineBorder = _this.createButtonTemplate(_this.elementId + '_tableOutlineBorder', 'e-de-ctnr-outsideborder e-icons', div1, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Outside borders'));
            _this.tableAllBorder = _this.createButtonTemplate(_this.elementId + '_tableAllBorder', 'e-de-ctnr-allborders e-icons', div1, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('All borders'));
            // tslint:disable-next-line:max-line-length
            _this.tableCenterBorder = _this.createButtonTemplate(_this.elementId + '_tableCenterBorder', 'e-de-ctnr-insideborders e-icons', div1, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Inside borders'));
            _this.tableLeftBorder = _this.createButtonTemplate(_this.elementId + '_tableLeftBorder', 'e-de-ctnr-leftborders e-icons', div2, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Left border'));
            // tslint:disable-next-line:max-line-length
            _this.tableCenterVerticalBorder = _this.createButtonTemplate(_this.elementId + '_tableCenterVBorder', 'e-de-ctnr-insideverticalborder e-icons', div2, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Inside vertical border'));
            _this.tableRightBorder = _this.createButtonTemplate(_this.elementId + '_tableRightBorder', 'e-de-ctnr-rightborder e-icons', div2, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Right border'));
            // tslint:disable-next-line:max-line-length
            _this.tableTopBorder = _this.createButtonTemplate(_this.elementId + '_tableTopBorder', 'e-de-ctnr-topborder e-icons', div3, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Top border'));
            _this.tableCenterHorizontalBorder = _this.createButtonTemplate(_this.elementId + '_tableCenterHBorder', 'e-de-ctnr-insidehorizondalborder e-icons', div3, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Inside horizontal border'));
            // tslint:disable-next-line:max-line-length
            _this.tableBottomBorder = _this.createButtonTemplate(_this.elementId + '_tableBottomBorder', 'e-de-ctnr-bottomborder e-icons', div3, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Bottom border'));
            parentDiv.appendChild(styleDiv);
            // tslint:disable-next-line:max-line-length
            var styleTypeDiv = createElement('div', { className: 'de-tbl-fill-clr' });
            if (!_this.isRtl) {
                styleTypeDiv.classList.add('e-de-stylediv');
            }
            else {
                styleTypeDiv.classList.add('e-de-stylediv-rtl');
            }
            // tslint:disable-next-line:max-line-length
            _this.borderBtn = _this.createColorPickerTemplate(_this.elementId + '_tableBorderColor', styleTypeDiv, _this.localObj.getConstant('Border color'), true);
            _this.borderBtn.value = '#000000';
            styleTypeDiv.firstElementChild.lastElementChild.lastElementChild.style.width = '30px';
            styleTypeDiv.firstElementChild.lastElementChild.firstElementChild.firstElementChild.style.width = '100%';
            // tslint:disable-next-line:max-line-length
            classList(styleTypeDiv.lastElementChild.lastElementChild.lastElementChild.firstChild, ['e-de-ctnr-highlightcolor'], ['e-caret']);
            var borderSizeButton = createElement('button', { id: _this.elementId + '_tableBorderSize', className: 'e-de-border-size-button', styles: 'font-size:10px;padding:0px;', attrs: { type: 'button' } });
            styleTypeDiv.appendChild(borderSizeButton);
            _this.borderSize = _this.createBorderSizeDropDown('e-de-ctnr-strokesize e-icons', borderSizeButton);
            parentDiv.appendChild(styleTypeDiv);
            _this.borderSizeColorElement = document.getElementsByClassName('e-de-border-width');
            borderStyleDiv.appendChild(parentDiv);
        };
        this.initCellDiv = function () {
            var cellDiv = createElement('div', { className: 'e-de-property-div-padding' });
            _this.tableProperties.appendChild(cellDiv);
            var label = createElement('label', { className: 'e-de-ctnr-prop-label' });
            label.classList.add('e-de-table-prop-label');
            label.textContent = _this.localObj.getConstant('Cell');
            cellDiv.appendChild(label);
            var parentDiv = createElement('div', { className: 'e-de-ctnr-group-btn' });
            parentDiv.classList.add('e-de-cell-div');
            if (_this.isRtl) {
                parentDiv.classList.add('e-de-rtl');
                label.classList.add('e-de-rtl');
            }
            var btnStyle = 'width:' + 38 + 'px;';
            // tslint:disable-next-line:max-line-length
            _this.horizontalMerge = _this.createButtonTemplate(_this.elementId + '_tableOutlineBorder', 'e-de-ctnr-mergecell e-icons', parentDiv, 'e-de-prop-font-button', btnStyle, 'Merge cells');
            //this.verticalMerge = this.createButtonTemplate(this.elementId + '_tableAllBorder', 'e-de-icon-merge-column e-icons', parentDiv, 'e-de-prop-font-button', btnStyle, 'Vertical Merge');
            cellDiv.appendChild(parentDiv);
        };
        this.initInsertOrDelCell = function () {
            var tableOperationDiv = createElement('div', { className: 'e-de-property-div-padding' });
            _this.tableProperties.appendChild(tableOperationDiv);
            var label = createElement('label', { className: 'e-de-ctnr-prop-label' });
            label.classList.add('e-de-table-prop-label');
            label.textContent = _this.localObj.getConstant('Insert Or Delete');
            tableOperationDiv.appendChild(label);
            var parentDiv = createElement('div', { className: 'e-de-insert-del-cell', styles: 'display:inline-flex' });
            var div1 = createElement('div', { className: _this.groupButtonClass });
            parentDiv.appendChild(div1);
            var div2 = createElement('div', { className: _this.groupButtonClass });
            if (!_this.isRtl) {
                div2.style.marginLeft = '12px';
            }
            else {
                div2.style.marginRight = '12px';
                parentDiv.classList.add('e-de-rtl');
                label.classList.add('e-de-rtl');
            }
            parentDiv.appendChild(div2);
            var btnStyle = 'width:' + 38 + 'px;';
            // tslint:disable-next-line:max-line-length
            _this.insertColumnLeft = _this.createButtonTemplate(_this.elementId + '_insertColumnLeft', 'e-de-ctnr-insertleft e-icons', div1, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Insert columns to the left'));
            _this.insertColumnRight = _this.createButtonTemplate(_this.elementId + '_insertColumnRight', 'e-de-ctnr-insertright e-icons', div1, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Insert columns to the right'));
            // tslint:disable-next-line:max-line-length
            _this.insertRowAbove = _this.createButtonTemplate(_this.elementId + '_insertRowAbove', 'e-de-ctnr-insertabove e-icons', div1, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Insert rows above'));
            _this.insertRowBelow = _this.createButtonTemplate(_this.elementId + '_insertRowBelow', 'e-de-ctnr-insertbelow e-icons', div1, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Insert rows below'));
            // tslint:disable-next-line:max-line-length
            _this.deleteRow = _this.createButtonTemplate(_this.elementId + '_deleteRow', 'e-de-ctnr-deleterows e-icons', div2, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Delete rows'));
            _this.deleteColumn = _this.createButtonTemplate(_this.elementId + '_deleteColumn', 'e-de-ctnr-deletecolumns e-icons', div2, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Delete columns'));
            tableOperationDiv.appendChild(parentDiv);
        };
        this.initCellMargin = function () {
            var cellMarginDiv = createElement('div', { className: 'e-de-property-div-padding e-de-cellmargin-text' });
            _this.tableProperties.appendChild(cellMarginDiv);
            var label = createElement('label', { className: 'e-de-ctnr-prop-label' });
            label.classList.add('e-de-table-prop-label');
            label.textContent = _this.localObj.getConstant('Cell Margin');
            cellMarginDiv.appendChild(label);
            var parentDiv = createElement('div', { className: 'e-de-cell-margin', styles: 'height: 60px;display:inline-flex' });
            if (_this.isRtl) {
                label.classList.add('e-de-rtl');
            }
            var textboxDivStyle = 'width:' + 48 + 'px';
            var textboxParentDivStyle = 'width:' + 50 + 'px;float:left;';
            // tslint:disable-next-line:max-line-length
            _this.topMargin = _this.createCellMarginTextBox(_this.localObj.getConstant('Top'), _this.elementId + '_topMargin', parentDiv, textboxDivStyle, textboxParentDivStyle, 500, 'Top margin');
            // tslint:disable-next-line:max-line-length
            _this.bottomMargin = _this.createCellMarginTextBox(_this.localObj.getConstant('Bottom'), _this.elementId + '_bottomMargin', parentDiv, textboxDivStyle, textboxParentDivStyle, 500, 'Bottom margin');
            // tslint:disable-next-line:max-line-length
            _this.leftMargin = _this.createCellMarginTextBox(_this.localObj.getConstant('Left'), _this.elementId + '_leftMargin', parentDiv, textboxDivStyle, textboxParentDivStyle, 500, 'Left margin');
            // tslint:disable-next-line:max-line-length
            _this.rightMargin = _this.createCellMarginTextBox(_this.localObj.getConstant('Right'), _this.elementId + '_rightMargin', parentDiv, textboxDivStyle, textboxParentDivStyle, 500, 'Right margin');
            cellMarginDiv.appendChild(parentDiv);
        };
        this.initAlignText = function () {
            var alignmentDiv = createElement('div', { className: 'e-de-property-div-padding', styles: 'border-bottom-width:0px' });
            _this.tableProperties.appendChild(alignmentDiv);
            var label = createElement('label', { className: 'e-de-ctnr-prop-label' });
            label.classList.add('e-de-table-prop-label');
            label.textContent = _this.localObj.getConstant('Align Text');
            alignmentDiv.appendChild(label);
            var parentDiv = createElement('div', { className: 'e-de-align-text', styles: 'margin-bottom: 10px;' });
            if (_this.isRtl) {
                parentDiv.classList.add('e-de-rtl');
                label.classList.add('e-de-rtl');
            }
            var div = createElement('div', { className: _this.groupButtonClass });
            parentDiv.appendChild(div);
            var btnStyle = 'width:' + 38 + 'px;';
            // tslint:disable-next-line:max-line-length
            _this.alignTop = _this.createButtonTemplate(_this.elementId + '_alignTop', 'e-de-ctnr-aligntop e-icons', div, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Align top'));
            // tslint:disable-next-line:max-line-length
            // this.alignCenterVertical = this.createButtonTemplate(this.elementId + '_alignCenterVertical', 'e-de-icon-merge-column e-icons', parentDiv, 'e-de-prop-font-button', btnStyle, 'Align Center Vertical');
            // tslint:disable-next-line:max-line-length
            // this.alignRight = this.createButtonTemplate(this.elementId + '_alignRight', 'e-de-icon-merge-column e-icons', parentDiv, 'e-de-prop-font-button', btnStyle, 'Align Right');
            _this.alignBottom = _this.createButtonTemplate(_this.elementId + '_alignBottom', 'e-de-ctnr-alignbottom e-icons', div, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Align bottom'));
            // tslint:disable-next-line:max-line-length
            // this.alignCenterHorizontal = this.createButtonTemplate(this.elementId + '_alignCenterHorizontal', 'e-de-icon-merge-column e-icons', parentDiv, 'e-de-prop-font-button', btnStyle, 'Align Center Horizontal');
            _this.alignCenterHorizontal = _this.createButtonTemplate(_this.elementId + '_alignCenterHorizontal', 'e-de-ctnr-aligncenter-table e-icons', div, 'e-de-prop-font-button', btnStyle, _this.localObj.getConstant('Align center'));
            _this.alignCenterHorizontal.addEventListener('click', _this.applyAlignCenterHorizontal);
            alignmentDiv.appendChild(parentDiv);
        };
        // tslint:disable-next-line:max-line-length
        this.createCellMarginTextBox = function (textboxLabel, textboxId, parentDiv, styles, parentStyle, maxValue, toolTipText) {
            var cellMarginParentDiv = createElement('div', { styles: parentStyle });
            cellMarginParentDiv.classList.add('e-de-cell-text-box');
            var cellMarginLabel = createElement('label', { className: 'e-de-prop-sub-label' });
            cellMarginLabel.textContent = textboxLabel;
            cellMarginParentDiv.appendChild(cellMarginLabel);
            // tslint:disable-next-line:max-line-length
            var cellMarginTextbox = createElement('input', { className: 'e-textbox', id: textboxId, styles: styles });
            cellMarginParentDiv.appendChild(cellMarginTextbox);
            // tslint:disable-next-line:max-line-length
            var cellMarginNumericText = new NumericTextBox({ showSpinButton: false, min: 0, format: 'n0', max: maxValue, enableRtl: _this.isRtl }, cellMarginTextbox);
            parentDiv.appendChild(cellMarginParentDiv);
            cellMarginTextbox.setAttribute('title', toolTipText);
            return cellMarginNumericText;
        };
        this.createBorderSizeDropDown = function (iconcss, button) {
            var div = createElement('div', { id: 'borderSizeTarget', styles: 'display:none' });
            var ulTag = createElement('ul', {
                styles: 'display: block; outline: 0px; width: 126px; height: auto;',
                id: 'borderSizeListMenu'
            });
            div.appendChild(ulTag);
            var noneOption = _this.createDropdownOption(ulTag, _this.localObj.getConstant('No Border'));
            noneOption.addEventListener('click', function () { _this.onBorderSizeChange('No Border'); });
            var oneOption = _this.createDropdownOption(ulTag, '1px');
            oneOption.addEventListener('click', function () { _this.onBorderSizeChange('1px'); });
            var oneHalfOption = _this.createDropdownOption(ulTag, '1.5px');
            oneHalfOption.addEventListener('click', function () { _this.onBorderSizeChange('1.5px'); });
            var twoOption = _this.createDropdownOption(ulTag, '2px');
            twoOption.addEventListener('click', function () { _this.onBorderSizeChange('2px'); });
            var threeOption = _this.createDropdownOption(ulTag, '3px');
            threeOption.addEventListener('click', function () { _this.onBorderSizeChange('3px'); });
            var fourOption = _this.createDropdownOption(ulTag, '4px');
            fourOption.addEventListener('click', function () { _this.onBorderSizeChange('4px'); });
            var fiveOption = _this.createDropdownOption(ulTag, '5px');
            fiveOption.addEventListener('click', function () { _this.onBorderSizeChange('5px'); });
            var menuOptions = {
                target: div,
                iconCss: iconcss,
                cssClass: 'e-de-prop-bordersize',
                enableRtl: _this.isRtl,
                content: '1.5px',
            };
            var dropdown = new DropDownButton(menuOptions);
            dropdown.beforeOpen = function () {
                div.style.display = 'block';
                for (var i = 0; i < _this.borderSizeColorElement.length; i++) {
                    // tslint:disable-next-line:max-line-length
                    _this.borderSizeColorElement[i].style.borderBottomColor = _this.borderColor;
                }
            };
            dropdown.beforeClose = function () { div.style.display = 'none'; };
            dropdown.appendTo(button);
            dropdown.element.setAttribute('title', _this.localObj.getConstant('Border width'));
            return dropdown;
        };
        this.onBorderSizeChange = function (value) {
            _this.borderSize.content = value;
            setTimeout(function () { _this.tableOutlineBorder.element.focus(); }, 10);
        };
        this.createDropdownOption = function (ulTag, text) {
            var liTag = createElement('li', {
                styles: 'display:block',
                className: 'e-de-floating-menuitem e-de-floating-menuitem-md e-de-list-items  e-de-list-item-size'
            });
            ulTag.appendChild(liTag);
            var innerHTML;
            if (text === 'No Border') {
                innerHTML = '<div>' + text + '</div>';
            }
            else if (text === '1.5px') {
                // tslint:disable-next-line:max-line-length
                innerHTML = '<div>' + text + '<span class="e-de-list-line e-de-border-width"  style="margin-left:10px;border-bottom-width:' + text + ';' + '"' + '></span></div>';
            }
            else {
                // tslint:disable-next-line:max-line-length
                innerHTML = '<div>' + text + '<span class="e-de-list-line e-de-border-width" style="margin-left:20px;border-bottom-width:' + text + ';' + '"' + '></span></div>';
            }
            var liInnerDiv = createElement('div', {
                className: 'e-de-list-header-presetmenu',
                innerHTML: innerHTML
            });
            liTag.appendChild(liInnerDiv);
            return liTag;
        };
        //tslint:disable-next-line:max-line-length
        this.createDropDownButton = function (id, styles, parentDiv, iconCss, content, items, target) {
            var buttonElement = createElement('button', { id: id, styles: styles, attrs: { type: 'button' } });
            parentDiv.appendChild(buttonElement);
            var splitButtonClass = 'e-de-prop-splitbutton';
            if (_this.isRtl) {
                splitButtonClass = 'e-rtl ' + splitButtonClass;
            }
            // tslint:disable-next-line:max-line-length
            var dropDownBtn = new DropDownButton({ iconCss: iconCss, content: content, enableRtl: _this.isRtl, cssClass: splitButtonClass }, buttonElement);
            if (items) {
                dropDownBtn.items = items;
            }
            if (target) {
                dropDownBtn.target = target;
            }
            return dropDownBtn;
        };
        this.createColorPickerTemplate = function (id, divElement, toolTipText, isBorderWidth) {
            var inputElement = createElement('input', { id: id });
            divElement.appendChild(inputElement);
            var cssClass = 'e-de-prop-font-button e-de-prop-font-colorpicker';
            if (isBorderWidth) {
                cssClass = cssClass + ' e-de-border-clr-picker';
            }
            // tslint:disable-next-line:max-line-length
            var colorPicker = new ColorPicker({ showButtons: true, cssClass: cssClass, enableRtl: _this.isRtl, locale: _this.container.locale }, inputElement);
            inputElement.parentElement.setAttribute('title', toolTipText);
            return colorPicker;
        };
        this.showTableProperties = function (isShow) {
            if (isShow) {
                if (_this.prevContext !== _this.documentEditor.selection.contextType) {
                    _this.propertiesTab.selectedItem = 0;
                    _this.tableTextProperties.appliedHighlightColor = _this.textProperties.appliedHighlightColor;
                    _this.tableTextProperties.appliedBulletStyle = _this.textProperties.appliedBulletStyle;
                    _this.tableTextProperties.appliedNumberingStyle = _this.textProperties.appliedNumberingStyle;
                }
                _this.onSelectionChange();
                _this.tableTextProperties.onSelectionChange();
                _this.textProperties.appliedHighlightColor = _this.tableTextProperties.appliedHighlightColor;
                _this.textProperties.appliedBulletStyle = _this.tableTextProperties.appliedBulletStyle;
                _this.textProperties.appliedNumberingStyle = _this.tableTextProperties.appliedNumberingStyle;
            }
            if (!isShow && _this.parentElement.style.display === 'none' || (isShow && _this.parentElement.style.display === 'block')) {
                return;
            }
            _this.parentElement.style.display = isShow ? 'block' : 'none';
            _this.documentEditor.resize();
            _this.prevContext = _this.documentEditor.selection.contextType;
        };
        this.container = container;
        this.isRtl = isRtl;
        if (this.isRtl) {
            this.groupButtonClass = 'e-rtl ' + this.groupButtonClass;
        }
        this.tableTextProperties = new TextProperties(container, 'textProperties', true, this.isRtl);
        this.imageProperty = imageProperty;
        this.elementId = this.documentEditor.element.id;
        this.initializeTablePropPane();
        this.prevContext = this.documentEditor.selection.contextType;
        this.textProperties = textProperties;
    }
    Object.defineProperty(TableProperties.prototype, "documentEditor", {
        get: function () {
            return this.container.documentEditor;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    TableProperties.prototype.enableDisableElements = function (enable) {
        this.textProperties.enableDisableElements(enable);
        if (enable) {
            classList(this.element, [], ['e-de-overlay']);
        }
        else {
            classList(this.element, ['e-de-overlay'], []);
        }
    };
    // tslint:disable-next-line:max-line-length
    TableProperties.prototype.createButtonTemplate = function (id, iconcss, div, buttonClass, styles, toolTipText, content, iconPos) {
        var buttonElement = createElement('Button', { id: id, styles: styles, attrs: { type: 'button' } });
        div.appendChild(buttonElement);
        var btn = new Button({
            cssClass: buttonClass, iconCss: iconcss, enableRtl: this.isRtl, iconPosition: (iconPos ? iconPos : 'Left'),
            content: content ? content : ''
        });
        btn.appendTo(buttonElement);
        buttonElement.setAttribute('title', toolTipText);
        return btn;
    };
    TableProperties.prototype.destroy = function () {
        this.container = undefined;
        if (this.shadingBtn) {
            this.shadingBtn.destroy();
            this.shadingBtn = undefined;
        }
        if (this.borderBtn) {
            this.borderBtn.destroy();
            this.borderBtn = undefined;
        }
        if (this.borderSize) {
            this.borderSize.destroy();
            this.borderSize = undefined;
        }
        if (this.topMargin) {
            this.topMargin.destroy();
            this.topMargin = undefined;
        }
        if (this.bottomMargin) {
            this.bottomMargin.destroy();
            this.bottomMargin = undefined;
        }
        if (this.leftMargin) {
            this.leftMargin.destroy();
            this.leftMargin = undefined;
        }
        if (this.rightMargin) {
            this.rightMargin.destroy();
            this.rightMargin = undefined;
        }
        if (this.tableTextProperties) {
            this.tableTextProperties.destroy();
            this.tableTextProperties = undefined;
        }
        if (this.propertiesTab) {
            this.propertiesTab.destroy();
            this.propertiesTab = undefined;
        }
    };
    return TableProperties;
}());

/**
 * Represents document editor status bar.
 * @private
 */
var StatusBar = /** @__PURE__ @class */ (function () {
    function StatusBar(parentElement, docEditor) {
        var _this = this;
        this.startPage = 1;
        this.initializeStatusBar = function () {
            var isRtl = _this.container.enableRtl;
            _this.documentEditor.enableSpellCheck = (_this.container.enableSpellCheck) ? true : false;
            // tslint:disable-next-line:max-line-length
            _this.localObj = new L10n('documenteditorcontainer', _this.container.defaultLocale, _this.container.locale);
            // tslint:disable-next-line:max-line-length
            var styles = 'padding-top:8px;';
            styles += isRtl ? 'padding-right:16px' : 'padding-left:16px';
            // tslint:disable-next-line:max-line-length
            var div = createElement('div', { className: (_this.container.enableSpellCheck) ? 'e-de-ctnr-pg-no' : 'e-de-ctnr-pg-no-spellout', styles: styles });
            _this.statusBarDiv.appendChild(div);
            var label = createElement('label');
            label.textContent = _this.localObj.getConstant('Page') + ' ';
            div.appendChild(label);
            // tslint:disable-next-line:max-line-length
            _this.pageNumberLabel = createElement('label', { styles: 'text-transform:capitalize;white-space:pre;overflow:hidden;user-select:none;cursor:text;height:17px;max-width:150px' });
            _this.editablePageNumber = createElement('div', { styles: 'display: inline-flex;height: 17px;padding: 0px 4px;', className: 'e-input e-de-pagenumber-text' });
            _this.editablePageNumber.appendChild(_this.pageNumberLabel);
            if (isRtl) {
                label.style.marginLeft = '6px';
                _this.editablePageNumber.style.marginLeft = '6px';
            }
            else {
                label.style.marginRight = '6px';
                _this.editablePageNumber.style.marginRight = '6px';
            }
            _this.updatePageNumber();
            div.appendChild(_this.editablePageNumber);
            // tslint:disable-next-line:max-line-length
            _this.editablePageNumber.setAttribute('title', _this.localObj.getConstant('Current Page Number'));
            var label1 = createElement('label', { styles: 'width:16px' });
            label1.textContent = ' ' + _this.localObj.getConstant('of') + ' ';
            div.appendChild(label1);
            _this.pageCount = createElement('label');
            div.appendChild(_this.pageCount);
            _this.updatePageCount();
            if (_this.documentEditor.enableSpellCheck) {
                var verticalLine = createElement('div', { className: 'e-de-statusbar-seperator' });
                _this.statusBarDiv.appendChild(verticalLine);
                var spellCheckBtn = _this.addSpellCheckElement();
                _this.spellCheckButton.appendTo(spellCheckBtn);
            }
            var zoomBtn = createElement('button', {
                // tslint:disable-next-line:max-line-length
                className: (_this.container.enableSpellCheck) ? 'e-de-statusbar-zoom-spell' : 'e-de-statusbar-zoom', attrs: { type: 'button' }
            });
            _this.statusBarDiv.appendChild(zoomBtn);
            zoomBtn.setAttribute('title', 'Zoom level. Click or tap to open the Zoom options.');
            var items = [
                {
                    text: '200%',
                },
                {
                    text: '175%',
                },
                {
                    text: '150%',
                },
                {
                    text: '125%',
                },
                {
                    text: '100%',
                },
                {
                    text: '75%',
                },
                {
                    text: '50%',
                },
                {
                    text: '25%',
                },
                {
                    separator: true
                },
                {
                    text: _this.localObj.getConstant('Fit one page')
                },
                {
                    text: _this.localObj.getConstant('Fit page width'),
                },
            ];
            // tslint:disable-next-line:max-line-length
            _this.zoom = new DropDownButton({ content: '100%', items: items, enableRtl: _this.container.enableRtl, select: _this.onZoom }, zoomBtn);
        };
        this.onZoom = function (args) {
            _this.setZoomValue(args.item.text);
            _this.updateZoomContent();
        };
        this.onSpellCheck = function (args) {
            _this.setSpellCheckValue(args.item.text, args.element);
        };
        this.updateZoomContent = function () {
            _this.zoom.content = Math.round(_this.documentEditor.zoomFactor * 100) + '%';
        };
        this.setSpellCheckValue = function (text, element) {
            _this.spellCheckButton.content = 'Spelling';
            if (text.match(_this.localObj.getConstant('Spell Check'))) {
                _this.documentEditor.enableSpellCheck = (_this.documentEditor.enableSpellCheck) ? false : true;
                setTimeout(function () {
                    if (_this.documentEditor.enableSpellCheck) {
                        _this.documentEditor.spellChecker.languageID = _this.currentLanguage;
                        _this.documentEditor.spellChecker.allowSpellCheckAndSuggestion = _this.allowSuggestion;
                        _this.documentEditor.viewer.triggerElementsOnLoading = true;
                        _this.documentEditor.viewer.triggerSpellCheck = true;
                    }
                    _this.documentEditor.editor.reLayout(_this.documentEditor.viewer.selection);
                    /* tslint:disable */
                }, 50);
                /* tslint:enable */
                _this.documentEditor.viewer.triggerSpellCheck = false;
                _this.documentEditor.viewer.triggerElementsOnLoading = false;
                // tslint:disable-next-line:max-line-length
            }
            else if (text.match(_this.localObj.getConstant('Underline errors'))) {
                if (_this.documentEditor.enableSpellCheck) {
                    // tslint:disable-next-line:max-line-length
                    _this.documentEditor.spellChecker.removeUnderline = (_this.documentEditor.spellChecker.removeUnderline) ? false : true;
                    _this.documentEditor.editor.reLayout(_this.documentEditor.viewer.selection);
                }
            }
        };
        this.setZoomValue = function (text) {
            if (text.match(_this.localObj.getConstant('Fit one page'))) {
                _this.documentEditor.fitPage('FitOnePage');
            }
            else if (text.match(_this.localObj.getConstant('Fit page width'))) {
                _this.documentEditor.fitPage('FitPageWidth');
            }
            else {
                _this.documentEditor.zoomFactor = parseInt(text, 0) / 100;
            }
        };
        /**
         * Updates page count.
         */
        this.updatePageCount = function () {
            _this.pageCount.textContent = _this.editorPageCount.toString();
        };
        /**
         * Updates page number.
         */
        this.updatePageNumber = function () {
            _this.pageNumberLabel.textContent = _this.startPage.toString();
        };
        this.updatePageNumberOnViewChange = function (args) {
            if (_this.documentEditor.selection
                && _this.documentEditor.selection.startPage >= args.startPage && _this.documentEditor.selection.startPage <= args.endPage) {
                _this.startPage = _this.documentEditor.selection.startPage;
            }
            else {
                _this.startPage = args.startPage;
            }
            _this.updatePageNumber();
        };
        this.wireEvents = function () {
            _this.editablePageNumber.addEventListener('keydown', function (e) {
                if (e.which === 13) {
                    e.preventDefault();
                    var pageNumber = parseInt(_this.editablePageNumber.textContent, 0);
                    if (pageNumber > _this.editorPageCount) {
                        _this.updatePageNumber();
                    }
                    else {
                        if (_this.documentEditor.selection) {
                            _this.documentEditor.selection.goToPage(parseInt(_this.editablePageNumber.textContent, 0));
                        }
                        else {
                            _this.documentEditor.scrollToPage(parseInt(_this.editablePageNumber.textContent, 0));
                        }
                    }
                    _this.editablePageNumber.contentEditable = 'false';
                    if (_this.editablePageNumber.textContent === '') {
                        _this.updatePageNumber();
                    }
                }
                if (e.which > 64) {
                    e.preventDefault();
                }
            });
            _this.editablePageNumber.addEventListener('blur', function () {
                if (_this.editablePageNumber.textContent === '' || parseInt(_this.editablePageNumber.textContent, 0) > _this.editorPageCount) {
                    _this.updatePageNumber();
                }
                _this.editablePageNumber.contentEditable = 'false';
                _this.editablePageNumber.style.border = 'none';
            });
            _this.editablePageNumber.addEventListener('focus', function () {
                _this.editablePageNumber.style.border = '1px solid #F1F1F1';
            });
            _this.editablePageNumber.addEventListener('click', function () {
                _this.updateDocumentEditorPageNumber();
            });
        };
        this.updateDocumentEditorPageNumber = function () {
            _this.editablePageNumber.contentEditable = 'true';
            _this.editablePageNumber.focus();
            window.getSelection().selectAllChildren(_this.editablePageNumber);
        };
        this.statusBarDiv = parentElement;
        this.container = docEditor;
        this.initializeStatusBar();
        this.wireEvents();
    }
    Object.defineProperty(StatusBar.prototype, "documentEditor", {
        get: function () {
            return this.container ? this.container.documentEditor : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StatusBar.prototype, "editorPageCount", {
        get: function () {
            return this.documentEditor ? this.documentEditor.pageCount : 1;
        },
        enumerable: true,
        configurable: true
    });
    StatusBar.prototype.addSpellCheckElement = function () {
        var _this = this;
        var spellCheckBtn = createElement('button', {
            className: 'e-de-statusbar-spellcheck'
        });
        this.statusBarDiv.appendChild(spellCheckBtn);
        spellCheckBtn.setAttribute('title', 'Spell Checker options');
        var spellCheckItems = [
            {
                text: 'Spell Check',
            },
            {
                text: 'Underline errors',
            },
        ];
        // tslint:disable-next-line:max-line-length
        this.spellCheckButton = new DropDownButton({
            content: 'Spelling', items: spellCheckItems, enableRtl: this.container.enableRtl, select: this.onSpellCheck,
            beforeItemRender: function (args) {
                args.element.innerHTML = '<span></span>' + args.item.text;
                if (isNullOrUndefined(_this.currentLanguage)) {
                    _this.currentLanguage = _this.documentEditor.spellChecker.languageID;
                }
                if (isNullOrUndefined(_this.allowSuggestion)) {
                    _this.allowSuggestion = _this.documentEditor.spellChecker.allowSpellCheckAndSuggestion;
                }
                var span = args.element.children[0];
                if (args.item.text === 'Spell Check' && _this.documentEditor.enableSpellCheck) {
                    span.style.marginRight = '10px';
                    span.setAttribute('class', 'e-de-selected-spellcheck-item');
                    // tslint:disable-next-line:max-line-length
                }
                else if (args.item.text === 'Underline errors' && _this.documentEditor.enableSpellCheck && !_this.documentEditor.spellChecker.removeUnderline) {
                    span.style.marginRight = '10px';
                    span.setAttribute('class', 'e-de-selected-underline-item');
                }
                else {
                    span.style.marginRight = '25px';
                    args.element.children[0].classList.remove('e-de-selected-spellcheck-item');
                    args.element.children[0].classList.remove('e-de-selected-underline-item');
                }
            }
        });
        return spellCheckBtn;
    };
    /**
     * @private
     */
    StatusBar.prototype.destroy = function () {
        this.container = undefined;
        if (this.zoom) {
            this.zoom.destroy();
            this.zoom = undefined;
        }
        if (this.spellCheckButton) {
            this.spellCheckButton.destroy();
            this.spellCheckButton = undefined;
        }
    };
    return StatusBar;
}());

var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
// tslint:disable-next-line:max-line-length
/**
 * Document Editor container component.
 */
var DocumentEditorContainer = /** @__PURE__ @class */ (function (_super) {
    __extends$5(DocumentEditorContainer, _super);
    /**
     * Initialize the constructor of DocumentEditorContainer
     */
    function DocumentEditorContainer(options, element) {
        var _this = _super.call(this, options, element) || this;
        /**
         * @private
         */
        _this.previousContext = '';
        /**
         * default locale
         * @private
         */
        _this.defaultLocale = {
            'New': 'New',
            'Open': 'Open',
            'Undo': 'Undo',
            'Redo': 'Redo',
            'Image': 'Image',
            'Table': 'Table',
            'Link': 'Link',
            'Bookmark': 'Bookmark',
            'Table of Contents': 'Table of Contents',
            'HEADING - - - - 1': 'HEADING - - - - 1',
            'HEADING - - - - 2': 'HEADING - - - - 2',
            'HEADING - - - - 3': 'HEADING - - - - 3',
            'Header': 'Header',
            'Footer': 'Footer',
            'Page Setup': 'Page Setup',
            'Page Number': 'Page Number',
            'Break': 'Break',
            'Find': 'Find',
            'Local Clipboard': 'Local Clipboard',
            'Restrict Editing': 'Restrict Editing',
            'Upload from computer': 'Upload from computer',
            'By URL': 'By URL',
            'Page Break': 'Page Break',
            'Section Break': 'Section Break',
            'Header And Footer': 'Header & Footer',
            'Options': 'Options',
            'Levels': 'Levels',
            'Different First Page': 'Different First Page',
            'Different header and footer for odd and even pages': 'Different header and footer for odd and even pages.',
            'Different Odd And Even Pages': 'Different Odd & Even Pages',
            'Different header and footer for first page': 'Different header and footer for first page.',
            'Position': 'Position',
            'Header from Top': 'Header from Top',
            'Footer from Bottom': 'Footer from Bottom',
            'Distance from top of the page to top of the header': 'Distance from top of the page to top of the header.',
            'Distance from bottom of the page to bottom of the footer': 'Distance from bottom of the page to bottom of the footer.',
            'Aspect ratio': 'Aspect ratio',
            'W': 'W',
            'H': 'H',
            'Width': 'Width',
            'Height': 'Height',
            'Text': 'Text',
            'Paragraph': 'Paragraph',
            'Fill': 'Fill',
            'Fill color': 'Fill color',
            'Border Style': 'Border Style',
            'Outside borders': 'Outside borders',
            'All borders': 'All borders',
            'Inside borders': 'Inside borders',
            'Left border': 'Left border',
            'Inside vertical border': 'Inside vertical border',
            'Right border': 'Right border',
            'Top border': 'Top border',
            'Inside horizontal border': 'Inside horizontal border',
            'Bottom border': 'Bottom border',
            'Border color': 'Border color',
            'Border width': 'Border width',
            'Cell': 'Cell',
            'Merge cells': 'Merge cells',
            'Insert Or Delete': 'Insert / Delete',
            'Insert columns to the left': 'Insert columns to the left',
            'Insert columns to the right': 'Insert columns to the right',
            'Insert rows above': 'Insert rows above',
            'Insert rows below': 'Insert rows below',
            'Delete rows': 'Delete rows',
            'Delete columns': 'Delete columns',
            'Cell Margin': 'Cell Margin',
            'Top': 'Top',
            'Bottom': 'Bottom',
            'Left': 'Left',
            'Right': 'Right',
            'Align Text': 'Align Text',
            'Align top': 'Align top',
            'Align bottom': 'Align bottom',
            'Align center': 'Align center',
            // tslint:disable-next-line:max-line-length
            'Number of heading or outline levels to be shown in table of contents': 'Number of heading or outline levels to be shown in table of contents.',
            'Show page numbers': 'Show page numbers',
            'Show page numbers in table of contents': 'Show page numbers in table of contents.',
            'Right align page numbers': 'Right align page numbers',
            'Right align page numbers in table of contents': 'Right align page numbers in table of contents.',
            'Use hyperlinks': 'Use hyperlinks',
            'Use hyperlinks instead of page numbers': 'Use hyperlinks instead of page numbers.',
            'Font': 'Font',
            'Font Size': 'Font Size',
            'Font color': 'Font color',
            'Text highlight color': 'Text highlight color',
            'Clear all formatting': 'Clear all formatting',
            'Bold Tooltip': 'Bold (Ctrl+B)',
            'Italic Tooltip': 'Italic (Ctrl+I)',
            'Underline Tooltip': 'Underline (Ctrl+U)',
            'Strikethrough': 'Strikethrough',
            'Superscript Tooltip': 'Superscript (Ctrl+Shift++)',
            'Subscript Tooltip': 'Subscript (Ctrl+=)',
            'Align left Tooltip': 'Align left (Ctrl+L)',
            'Center Tooltip': 'Center (Ctrl+E)',
            'Align right Tooltip': 'Align right (Ctrl+R)',
            'Justify Tooltip': 'Justify (Ctrl+J)',
            'Decrease indent': 'Decrease indent',
            'Increase indent': 'Increase indent',
            'Line spacing': 'Line spacing',
            'Bullets': 'Bullets',
            'Numbering': 'Numbering',
            'Styles': 'Styles',
            'Manage Styles': 'Manage Styles',
            'Page': 'Page',
            'of': 'of',
            'Fit one page': 'Fit one page',
            'Spell Check': 'Spell Check',
            'Underline errors': 'Underline errors',
            'Fit page width': 'Fit page width',
            'Update': 'Update',
            'Cancel': 'Cancel',
            'Insert': 'Insert',
            'No Border': 'No Border',
            'Create a new document': 'Create a new document.',
            'Open a document': 'Open a document.',
            'Undo Tooltip': 'Undo the last operation (Ctrl+Z).',
            'Redo Tooltip': 'Redo the last operation (Ctrl+Y).',
            'Insert inline picture from a file': 'Insert inline picture from a file.',
            'Insert a table into the document': 'Insert a table into the document',
            // tslint:disable-next-line:max-line-length
            'Create Hyperlink': 'Create a link in your document for quick access to web pages and files (Ctrl+K).',
            'Insert a bookmark in a specific place in this document': 'Insert a bookmark in a specific place in this document.',
            // tslint:disable-next-line:max-line-length
            'Provide an overview of your document by adding a table of contents': 'Provide an overview of your document by adding a table of contents.',
            'Add or edit the header': 'Add or edit the header.',
            'Add or edit the footer': 'Add or edit the footer.',
            'Open the page setup dialog': 'Open the page setup dialog.',
            'Add page numbers': 'Add page numbers.',
            'Find Text': 'Find text in the document (Ctrl+F).',
            'Toggle between the internal clipboard and system clipboard': 'Toggle between the internal clipboard and system clipboard.</br>' +
                'Access to system clipboard through script is denied due to browsers security policy. Instead, </br>' +
                ' 1. You can enable internal clipboard to cut, copy and paste within the component.</br>' +
                ' 2. You can use the keyboard shortcuts (Ctrl+X, Ctrl+C and Ctrl+V) to cut, copy and paste with system clipboard.',
            // tslint:disable-next-line:max-line-length
            'Current Page Number': 'The current page number in the document. Click or tap to navigate specific page.',
            'Read only': 'Read only',
            'Protections': 'Protections',
            'Error in establishing connection with web server': 'Error in establishing connection with web server',
            'Single': 'Single',
            'Double': 'Double',
            'New comment': 'New comment',
            'Comments': 'Comments'
        };
        return _this;
    }
    Object.defineProperty(DocumentEditorContainer.prototype, "documentEditor", {
        /**
         * Gets DocumentEditor instance.
         * @aspType DocumentEditor
         * @blazorType DocumentEditor
         */
        get: function () {
            return this.documentEditorInternal;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    DocumentEditorContainer.prototype.getModuleName = function () {
        return 'DocumentEditorContainer';
    };
    /**
     * @private
     */
    DocumentEditorContainer.prototype.onPropertyChanged = function (newModel, oldModel) {
        for (var _i = 0, _a = Object.keys(newModel); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'restrictEditing':
                    if (this.toolbarModule) {
                        this.toolbarModule.enableDisableToolBarItem(!newModel.restrictEditing, false);
                    }
                    this.documentEditor.isReadOnly = newModel.restrictEditing;
                    break;
                case 'showPropertiesPane':
                    this.showHidePropertiesPane(newModel.showPropertiesPane);
                    break;
                case 'enableLocalPaste':
                    if (this.documentEditor) {
                        this.documentEditor.enableLocalPaste = newModel.enableLocalPaste;
                    }
                    break;
                case 'serviceUrl':
                    if (this.documentEditor) {
                        this.documentEditor.serviceUrl = newModel.serviceUrl;
                    }
                    break;
                case 'serverActionSettings':
                    if (this.documentEditor) {
                        this.setserverActionSettings();
                    }
                    break;
                case 'zIndex':
                    if (this.documentEditor) {
                        this.documentEditor.zIndex = newModel.zIndex;
                    }
                    break;
                case 'headers':
                    if (this.documentEditor) {
                        this.documentEditor.headers = newModel.headers;
                    }
                    break;
                case 'locale':
                case 'enableRtl':
                    this.refresh();
                    break;
                case 'enableComment':
                    if (this.documentEditor) {
                        this.documentEditor.enableComment = newModel.enableComment;
                    }
                    if (this.toolbarModule) {
                        this.toolbarModule.enableDisableInsertComment(newModel.enableComment);
                    }
                    break;
            }
        }
    };
    /**
     * @private
     */
    DocumentEditorContainer.prototype.preRender = function () {
        this.localObj = new L10n('documenteditorcontainer', this.defaultLocale, this.locale);
        this.initContainerElement();
        //Prototype
    };
    /**
     * @private
     */
    DocumentEditorContainer.prototype.render = function () {
        if (this.toolbarModule) {
            this.toolbarModule.initToolBar();
            this.toolbarModule.enableDisableInsertComment(this.enableComment);
        }
        if (this.element.getBoundingClientRect().height < 320) {
            this.element.style.height = '320px';
        }
        this.element.style.minHeight = '320px';
        this.initializeDocumentEditor();
        this.textProperties = new TextProperties(this, this.element.id, false, this.enableRtl);
        this.headerFooterProperties = new HeaderFooterProperties(this, this.enableRtl);
        this.imageProperties = new ImageProperties(this, this.enableRtl);
        this.tocProperties = new TocProperties(this, this.enableRtl);
        this.tableProperties = new TableProperties(this, this.imageProperties, this.textProperties, this.enableRtl);
        this.statusBar = new StatusBar(this.statusBarElement, this);
        // Waiting popup
        createSpinner({ target: this.containerTarget, cssClass: 'e-spin-overlay' });
        this.setserverActionSettings();
        this.renderComplete();
    };
    DocumentEditorContainer.prototype.setFormat = function () {
        if (this.characterFormat) {
            this.documentEditor.setDefaultCharacterFormat(this.characterFormat);
        }
        if (this.paragraphFormat) {
            this.documentEditor.setDefaultParagraphFormat(this.paragraphFormat);
        }
        if (this.sectionFormat) {
            this.documentEditor.setDefaultSectionFormat(this.sectionFormat);
        }
    };
    DocumentEditorContainer.prototype.setserverActionSettings = function () {
        if (this.serviceUrl) {
            this.documentEditor.serviceUrl = this.serviceUrl;
        }
        if (this.serverActionSettings.spellCheck) {
            this.documentEditor.serverActionSettings.spellCheck = this.serverActionSettings.spellCheck;
        }
        if (this.serverActionSettings.restrictEditing) {
            this.documentEditor.serverActionSettings.restrictEditing = this.serverActionSettings.restrictEditing;
        }
        if (this.serverActionSettings.systemClipboard) {
            this.documentEditor.serverActionSettings.systemClipboard = this.serverActionSettings.systemClipboard;
        }
        if (this.headers) {
            this.documentEditor.headers = this.headers;
        }
    };
    /**
     * @private
     */
    DocumentEditorContainer.prototype.getPersistData = function () {
        return 'documenteditor-container';
    };
    //tslint:disable: max-func-body-length
    DocumentEditorContainer.prototype.requiredModules = function () {
        var modules = [];
        if (this.enableToolbar) {
            modules.push({
                member: 'toolbar', args: [this]
            });
        }
        return modules;
    };
    DocumentEditorContainer.prototype.initContainerElement = function () {
        // Toolbar container
        var isRtl = this.enableRtl;
        this.containerTarget = this.createElement('div', { className: 'e-de-ctn' });
        if (this.enableToolbar) {
            this.toolbarContainer = this.createElement('div', { className: 'e-de-ctnr-toolbar' + (isRtl ? ' e-de-ctnr-rtl' : '') });
            this.containerTarget.appendChild(this.toolbarContainer);
            // tslint:disable-next-line:max-line-length
            this.editorContainer = this.createElement('div', { className: 'e-de-tool-ctnr-properties-pane' + (isRtl ? ' e-de-ctnr-rtl' : '') });
        }
        else {
            this.editorContainer = this.createElement('div', { className: 'e-de-ctnr-properties-pane' + (isRtl ? ' e-de-ctnr-rtl' : '') });
        }
        var propertiesPaneContainerBorder;
        if (!isRtl) {
            propertiesPaneContainerBorder = 'e-de-pane';
        }
        else {
            propertiesPaneContainerBorder = 'e-de-pane-rtl';
        }
        this.propertiesPaneContainer = this.createElement('div', { className: propertiesPaneContainerBorder, styles: 'display:none' });
        this.editorContainer.appendChild(this.propertiesPaneContainer);
        this.containerTarget.appendChild(this.editorContainer);
        this.statusBarElement = this.createElement('div', { className: 'e-de-status-bar' });
        if (isRtl) {
            this.statusBarElement.style.direction = 'rtl';
        }
        this.containerTarget.appendChild(this.statusBarElement);
        this.element.appendChild(this.containerTarget);
    };
    DocumentEditorContainer.prototype.initializeDocumentEditor = function () {
        var id = this.element.id + '_editor';
        var documentEditorTarget = this.createElement('div', { id: id, styles: 'width:100%;height:100%' });
        this.documentEditorInternal = new DocumentEditor({
            isReadOnly: false, enableRtl: this.enableRtl,
            selectionChange: this.onSelectionChange.bind(this),
            contentChange: this.onContentChange.bind(this),
            documentChange: this.onDocumentChange.bind(this),
            zoomFactorChange: this.onZoomFactorChange.bind(this),
            requestNavigate: this.onRequestNavigate.bind(this),
            viewChange: this.onViewChange.bind(this),
            customContextMenuSelect: this.onCustomContextMenuSelect.bind(this),
            customContextMenuBeforeOpen: this.onCustomContextMenuBeforeOpen.bind(this),
            beforePaneSwitch: this.onBeforePaneSwitch.bind(this),
            commentBegin: this.onCommentBegin.bind(this),
            commentEnd: this.onCommentEnd.bind(this),
            locale: this.locale,
            acceptTab: true,
            zIndex: this.zIndex,
            enableLocalPaste: this.enableLocalPaste,
            enableComment: this.enableComment,
            pageOutline: '#E0E0E0'
        });
        this.documentEditor.enableAllModules();
        this.editorContainer.insertBefore(documentEditorTarget, this.editorContainer.firstChild);
        this.setFormat();
        this.documentEditor.appendTo(documentEditorTarget);
        this.documentEditor.resize();
    };
    DocumentEditorContainer.prototype.onCommentBegin = function () {
        if (this.toolbarModule) {
            this.toolbarModule.enableDisableInsertComment(false);
        }
    };
    DocumentEditorContainer.prototype.onCommentEnd = function () {
        if (this.toolbarModule) {
            this.toolbarModule.enableDisableInsertComment(true && this.enableComment);
        }
    };
    DocumentEditorContainer.prototype.onBeforePaneSwitch = function (args) {
        this.trigger('beforePaneSwitch', args);
    };
    /**
     * @private
     */
    DocumentEditorContainer.prototype.showHidePropertiesPane = function (show) {
        if (this.showPropertiesPane) {
            this.showPropertiesPaneOnSelection();
        }
        this.propertiesPaneContainer.style.display = show ? 'block' : 'none';
        if (this.toolbarModule) {
            this.toolbarModule.propertiesPaneButton.element.style.opacity = show ? '1' : '0.5';
        }
        this.documentEditor.resize();
    };
    /**
     * @private
     */
    DocumentEditorContainer.prototype.onContentChange = function () {
        if (this.toolbarModule) {
            this.toolbarModule.enableDisableUndoRedo();
        }
        if (this.statusBar) {
            this.statusBar.updatePageCount();
        }
        var eventArgs = { source: isBlazor() ? null : this };
        this.trigger('contentChange', eventArgs);
    };
    /**
     * @private
     */
    DocumentEditorContainer.prototype.onDocumentChange = function () {
        if (this.toolbarModule) {
            this.toolbarModule.isCommentEditing = false;
            this.toolbarModule.enableDisableInsertComment(true);
            this.toolbarModule.enableDisableUndoRedo();
        }
        if (this.textProperties) {
            this.textProperties.updateStyles();
        }
        if (this.statusBar) {
            this.statusBar.updatePageCount();
        }
        var eventArgs = { source: isBlazor() ? null : this };
        this.trigger('documentChange', eventArgs);
    };
    /**
     * @private
     */
    DocumentEditorContainer.prototype.onSelectionChange = function () {
        var _this = this;
        setTimeout(function () {
            _this.showPropertiesPaneOnSelection();
            var eventArgs = { source: isBlazor() ? null : _this };
            _this.trigger('selectionChange', eventArgs);
        });
    };
    /**
     * @private
     */
    DocumentEditorContainer.prototype.onZoomFactorChange = function () {
        if (this.statusBar) {
            this.statusBar.updateZoomContent();
        }
    };
    /**
     * @private
     */
    DocumentEditorContainer.prototype.onRequestNavigate = function (args) {
        if (args.linkType !== 'Bookmark') {
            var link = args.navigationLink;
            if (args.localReference.length > 0) {
                link += '#' + args.localReference;
            }
            window.open(link);
            args.isHandled = true;
        }
    };
    /**
     * @private
     */
    DocumentEditorContainer.prototype.onViewChange = function (args) {
        if (this.statusBar) {
            this.statusBar.updatePageNumberOnViewChange(args);
        }
    };
    /**
     * @private
     */
    DocumentEditorContainer.prototype.onCustomContextMenuSelect = function (args) {
        this.trigger('customContextMenuSelect', args);
    };
    /**
     * @private
     */
    DocumentEditorContainer.prototype.onCustomContextMenuBeforeOpen = function (args) {
        this.trigger('customContextMenuBeforeOpen', args);
    };
    /**
     * @private
     */
    DocumentEditorContainer.prototype.showPropertiesPaneOnSelection = function () {
        if (this.restrictEditing || this.textProperties === undefined) {
            return;
        }
        var isProtectedDocument = this.documentEditor.viewer.protectionType === 'ReadOnly';
        var allowFormatting = isProtectedDocument && this.documentEditor.viewer.restrictFormatting;
        var isSelectionInProtectecRegion = this.documentEditor.editor.restrictEditing;
        if (isProtectedDocument) {
            if (this.toolbarModule) {
                this.toolbarModule.enableDisableToolBarItem(!isSelectionInProtectecRegion, true);
            }
            this.textProperties.enableDisableElements(!allowFormatting && !isSelectionInProtectecRegion);
            this.tableProperties.enableDisableElements(!allowFormatting && !isSelectionInProtectecRegion);
            this.tocProperties.enableDisableElements(!isSelectionInProtectecRegion);
            this.headerFooterProperties.enableDisableElements(!isSelectionInProtectecRegion);
            this.imageProperties.enableDisableElements(!isSelectionInProtectecRegion);
        }
        else {
            var isReadOnly = !this.documentEditor.isReadOnly;
            if (this.toolbarModule) {
                this.toolbarModule.enableDisableToolBarItem(isReadOnly, true);
            }
            this.textProperties.enableDisableElements(isReadOnly);
            this.tableProperties.enableDisableElements(true);
            this.tocProperties.enableDisableElements(true);
            this.headerFooterProperties.enableDisableElements(true);
            this.imageProperties.enableDisableElements(true);
        }
        var currentContext = this.documentEditor.selection.contextType;
        var isInHeaderFooter = currentContext.indexOf('Header') >= 0
            || currentContext.indexOf('Footer') >= 0;
        if (!this.showPropertiesPane) {
            this.showHidePropertiesPane(false);
            this.propertiesPaneContainer.style.display = 'none';
        }
        else {
            this.propertiesPaneContainer.style.display = 'block';
            if (isInHeaderFooter) {
                this.showProperties('headerfooter');
            }
            else if (currentContext.indexOf('Text') >= 0
                && currentContext.indexOf('Table') < 0) {
                this.showProperties('text');
            }
            else if (currentContext.indexOf('Image') >= 0) {
                this.showProperties('image');
            }
            else if (currentContext.indexOf('TableOfContents') >= 0) {
                this.showProperties('toc');
            }
            else if (currentContext.indexOf('Table') >= 0) {
                this.showProperties('table');
            }
        }
        this.previousContext = this.documentEditor.selection.contextType;
        if (this.toolbarModule.toolbar) {
            this.toolbarModule.enableDisableInsertComment(!this.documentEditor.enableHeaderAndFooter && this.enableComment);
        }
    };
    /**
     * @private
     * @param property
     */
    DocumentEditorContainer.prototype.showProperties = function (property) {
        if (this.toolbarModule && property !== 'headerfooter' && property !== 'toc') {
            this.toolbarModule.enableDisablePropertyPaneButton(true);
        }
        this.textProperties.showTextProperties(property === 'text');
        this.tableProperties.showTableProperties(property === 'table');
        this.imageProperties.showImageProperties(property === 'image');
        this.headerFooterProperties.showHeaderFooterPane(property === 'headerfooter');
        this.tocProperties.showTocPane(property === 'toc');
    };
    /**
     * Set the default character format for document editor container
     * @param characterFormat
     */
    DocumentEditorContainer.prototype.setDefaultCharacterFormat = function (characterFormat) {
        this.characterFormat = characterFormat;
    };
    /**
     * Set the default paragraph format for document editor container
     * @param paragraphFormat
     */
    DocumentEditorContainer.prototype.setDefaultParagraphFormat = function (paragraphFormat) {
        this.paragraphFormat = paragraphFormat;
    };
    /**
     * Set the default section format for document editor container
     * @param sectionFormat
     */
    DocumentEditorContainer.prototype.setDefaultSectionFormat = function (sectionFormat) {
        this.sectionFormat = sectionFormat;
    };
    /**
     * Destroys all managed resources used by this object.
     */
    DocumentEditorContainer.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (this.element) {
            this.element.classList.remove('e-documenteditorcontainer');
            this.element.innerHTML = '';
        }
        if (!this.refreshing) {
            this.element = undefined;
        }
        if (this.toolbarContainer && this.toolbarContainer.parentElement) {
            this.toolbarContainer.innerHTML = '';
            this.toolbarContainer.parentElement.removeChild(this.toolbarContainer);
        }
        this.toolbarContainer = undefined;
        if (this.documentEditorInternal) {
            this.documentEditorInternal.destroy();
        }
        this.documentEditorInternal = undefined;
        if (this.textProperties) {
            this.textProperties.destroy();
        }
        this.textProperties = undefined;
        if (this.headerFooterProperties) {
            this.headerFooterProperties.destroy();
        }
        this.headerFooterProperties = undefined;
        if (this.imageProperties) {
            this.imageProperties.destroy();
        }
        this.imageProperties = undefined;
        if (this.tocProperties) {
            this.tocProperties.destroy();
        }
        this.tocProperties = undefined;
        if (this.tableProperties) {
            this.tableProperties.destroy();
        }
        this.tableProperties = undefined;
        if (this.statusBar) {
            this.statusBar.destroy();
        }
        if (this.propertiesPaneContainer && this.editorContainer.parentElement) {
            this.propertiesPaneContainer.innerHTML = '';
            this.propertiesPaneContainer.parentElement.removeChild(this.propertiesPaneContainer);
        }
        this.propertiesPaneContainer = undefined;
        if (this.editorContainer && this.editorContainer.parentElement) {
            this.editorContainer.innerHTML = '';
            this.editorContainer.parentElement.removeChild(this.editorContainer);
        }
        if (this.statusBarElement && this.statusBarElement.parentElement) {
            this.statusBarElement.innerHTML = '';
            this.statusBarElement.parentElement.removeChild(this.statusBarElement);
        }
        if (this.containerTarget && this.containerTarget.parentElement) {
            this.containerTarget.innerHTML = '';
            this.containerTarget.parentElement.removeChild(this.containerTarget);
        }
        this.containerTarget = undefined;
        this.statusBarElement = undefined;
        this.editorContainer = undefined;
    };
    __decorate$1([
        Property(true)
    ], DocumentEditorContainer.prototype, "showPropertiesPane", void 0);
    __decorate$1([
        Property(true)
    ], DocumentEditorContainer.prototype, "enableToolbar", void 0);
    __decorate$1([
        Property(false)
    ], DocumentEditorContainer.prototype, "restrictEditing", void 0);
    __decorate$1([
        Property(false)
    ], DocumentEditorContainer.prototype, "enableSpellCheck", void 0);
    __decorate$1([
        Property(false)
    ], DocumentEditorContainer.prototype, "enableLocalPaste", void 0);
    __decorate$1([
        Property()
    ], DocumentEditorContainer.prototype, "serviceUrl", void 0);
    __decorate$1([
        Property(2000)
    ], DocumentEditorContainer.prototype, "zIndex", void 0);
    __decorate$1([
        Property(false)
    ], DocumentEditorContainer.prototype, "enableCsp", void 0);
    __decorate$1([
        Property(false)
    ], DocumentEditorContainer.prototype, "enableComment", void 0);
    __decorate$1([
        Event()
    ], DocumentEditorContainer.prototype, "created", void 0);
    __decorate$1([
        Event()
    ], DocumentEditorContainer.prototype, "destroyed", void 0);
    __decorate$1([
        Event()
    ], DocumentEditorContainer.prototype, "contentChange", void 0);
    __decorate$1([
        Event()
    ], DocumentEditorContainer.prototype, "selectionChange", void 0);
    __decorate$1([
        Event()
    ], DocumentEditorContainer.prototype, "documentChange", void 0);
    __decorate$1([
        Event()
    ], DocumentEditorContainer.prototype, "customContextMenuSelect", void 0);
    __decorate$1([
        Event()
    ], DocumentEditorContainer.prototype, "customContextMenuBeforeOpen", void 0);
    __decorate$1([
        Event()
    ], DocumentEditorContainer.prototype, "beforePaneSwitch", void 0);
    __decorate$1([
        Property({ import: 'Import', systemClipboard: 'SystemClipboard', spellCheck: 'SpellCheck', restrictEditing: 'RestrictEditing' })
    ], DocumentEditorContainer.prototype, "serverActionSettings", void 0);
    __decorate$1([
        Property([])
    ], DocumentEditorContainer.prototype, "headers", void 0);
    DocumentEditorContainer = __decorate$1([
        NotifyPropertyChanges
    ], DocumentEditorContainer);
    return DocumentEditorContainer;
}(Component));

/**
 * export document editor container
 */

/**
 * export document editor modules
 */

export { Dictionary, WUniqueFormat, WUniqueFormats, XmlHttpRequestHandler, DocumentEditor, ServerActionSettings, ContainerServerActionSettings, Print, ContextMenu$1 as ContextMenu, WSectionFormat, WStyle, WParagraphStyle, WCharacterStyle, WStyles, WCharacterFormat, WListFormat, WTabStop, WParagraphFormat, WTableFormat, WRowFormat, WCellFormat, WBorder, WBorders, WShading, WList, WAbstractList, WListLevel, WLevelOverride, LayoutViewer, PageLayoutViewer, Layout, Rect, Margin, Widget, BlockContainer, BodyWidget, HeaderFooterWidget, BlockWidget, ParagraphWidget, TableWidget, TableRowWidget, TableCellWidget, LineWidget, ElementBox, FieldElementBox, TextElementBox, ErrorTextElementBox, FieldTextElementBox, TabElementBox, BookmarkElementBox, ImageElementBox, ListTextElementBox, EditRangeEndElementBox, EditRangeStartElementBox, ChartElementBox, ChartArea, ChartCategory, ChartData, ChartLegend, ChartSeries, ChartErrorBar, ChartSeriesFormat, ChartDataLabels, ChartTrendLines, ChartTitleArea, ChartDataFormat, ChartFill, ChartLayout, ChartCategoryAxis, ChartDataTable, CommentCharacterElementBox, CommentElementBox, Page, WTableHolder, WColumn, ColumnSizeInfo, Renderer, SfdtReader, TextHelper, Zoom, Selection, SelectionCharacterFormat, SelectionParagraphFormat, SelectionSectionFormat, SelectionTableFormat, SelectionCellFormat, SelectionRowFormat, SelectionImageFormat, TextPosition, SelectionWidgetInfo, Hyperlink, ImageFormat, Search, OptionsPane, TextSearch, SearchWidgetInfo, TextSearchResult, TextSearchResults, Editor, ImageResizer, ImageResizingPoints, SelectedImageInfo, TableResizer, HelperMethods, Point, Base64, EditorHistory, BaseHistoryInfo, HistoryInfo, ModifiedLevel, ModifiedParagraphFormat, RowHistoryFormat, TableHistoryInfo, TableFormatHistoryInfo, RowFormatHistoryInfo, CellFormatHistoryInfo, CellHistoryFormat, WordExport, TextExport, SfdtExport, HtmlExport, HyperlinkDialog, TableDialog, BookmarkDialog, TableOfContentsDialog, PageSetupDialog, ParagraphDialog, ListDialog, StyleDialog, BulletsAndNumberingDialog, FontDialog, TablePropertiesDialog, BordersAndShadingDialog, TableOptionsDialog, CellOptionsDialog, StylesDialog, SpellCheckDialog, SpellChecker, AddUserDialog, EnforceProtectionDialog, UnProtectDocumentDialog, RestrictEditing, CommentReviewPane, CommentPane, CommentView, Toolbar$1 as Toolbar, DocumentEditorContainer };
//# sourceMappingURL=ej2-documenteditor.es5.js.map
