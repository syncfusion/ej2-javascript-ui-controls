/* eslint-disable */
import { LayoutViewer, SelectionSectionFormat } from '../index';
import { Selection } from '../index';
import { TextPosition, ImageSizeInfo } from '../selection/selection-helper';
import {
    IWidget, ParagraphWidget, LineWidget, ElementBox, TextElementBox, Margin, Page, ImageElementBox,
    BlockWidget, BlockContainer, BodyWidget, TableWidget, TableCellWidget, TableRowWidget, Widget, ListTextElementBox,
    BookmarkElementBox, HeaderFooterWidget, FieldTextElementBox, TabElementBox, EditRangeStartElementBox, EditRangeEndElementBox,
    CommentElementBox, CommentCharacterElementBox, CheckBoxFormField, DropDownFormField, TextFormField, FormField, ShapeElementBox,
    TextFrame, ContentControl, FootnoteElementBox, FootNoteWidget, ShapeBase, HeaderFooters, TabStopListInfo, FootnoteEndnoteMarkerElementBox,
    ContentControlProperties, CheckBoxState, ContentControlListItems, XmlMapping, FillFormat, LineFormat,
    GroupShapeElementBox} from '../viewer/page';
import { WCharacterFormat } from '../format/character-format';
import {
    ElementInfo, HelperMethods, CellInfo, HyperlinkTextInfo,
    ParagraphInfo, LineInfo, IndexInfo, BlockInfo, CellCountInfo, PositionInfo, Base64,
    TextFormFieldInfo, CheckBoxFormFieldInfo, DropDownFormFieldInfo, RevisionMatchedInfo, FootNoteWidgetsInfo, SelectedCommentInfo, FieldInfo, ListSearchResultInfo, AbsolutePositionInfo
} from './editor-helper';
import { isNullOrUndefined, Browser, classList, L10n, isVisible } from '@syncfusion/ej2-base';
import {
    WParagraphFormat, WSectionFormat, WListFormat,
    WTableFormat, WRowFormat, WCellFormat, WStyle,
    WBorder, WBorders, WShading, WTabStop, WColumnFormat
} from '../index';
import { WList } from '../list/list';
import { WAbstractList } from '../list/abstract-list';
import { WListLevel } from '../list/list-level';
import { WLevelOverride } from '../list/level-override';
import { FieldElementBox } from '../viewer/page';
import {
    HighlightColor, BaselineAlignment, Strikethrough, Underline,
    LineSpacingType, TextAlignment, ListLevelPattern, RowPlacement, ColumnPlacement,
    FollowCharacterType, HeaderFooterType, TrackChangeEventArgs, protectionTypeChangeEvent, imagesProperty, abstractListIdProperty,
    ContentControlInfo,
    CommentProperties, Comment, breakCodeProperty,
    nsidProperty,
    customXmlProperty,
    BeforePasteEventArgs,
    beforePaste
} from '../../base/index';
import { SelectionCharacterFormat, SelectionParagraphFormat } from '../index';
import { Action } from '../../index';
import { PageLayoutViewer, SfdtReader } from '../index';
import { WCharacterStyle, WStyles } from '../format/style';
import { EditorHistory, HistoryInfo } from '../editor-history/index';
import { BaseHistoryInfo, MarkerInfo, ImageInfo, ListInfo} from '../editor-history/base-history-info';
import { TableResizer } from './table-resizer';
import { Dictionary } from '../../base/dictionary';
import { WParagraphStyle } from '../format/style';
import {
    TableAlignment, WidthType, HeightType, CellVerticalAlignment, BorderType, LineStyle,
    TabLeader, OutlineLevel, AutoFitType, ProtectionType, PasteOptions, TablePasteOptions, FormFieldType, TextFormFieldType, RevisionType,
    FootEndNoteNumberFormat, FootnoteRestartIndex, CONTROL_CHARACTERS, TabJustification , ContentControlType, AutoShapeType,
    TextWrappingStyle,
    TextWrappingType,
    LineFormatType,
    LineDashing,
    VerticalOrigin,
    VerticalAlignment,
    HorizontalOrigin,
    HorizontalAlignment,
    ContentControlWidgetType,
    PasteType
} from '../../base/types';
import { DocumentEditor } from '../../document-editor';
import { showSpinner, hideSpinner, Dialog } from '@syncfusion/ej2-popups';
import { DialogUtility } from '@syncfusion/ej2-popups';
import { DocumentHelper, Layout } from '../viewer';
import { Revision } from '../track-changes/track-changes';
import { XmlHttpRequestHandler } from '../../base/ajax-helper';
import { CommentActionEventArgs, beforeCommentActionEvent, trackChangeEvent, XmlHttpRequestEventArgs, beforeXmlHttpRequestSend, internalStyleCollectionChange } from '../../base/index';
import { CommentView } from '../comments';
import { SectionBreakType } from '../../base/types';
import { sectionsProperty, commentsProperty, bidiProperty, revisionsProperty, lastParagraphMarkCopiedProperty, sectionFormatProperty, revisionIdProperty, contextualSpacingProperty, keepWithNextProperty, keepLinesTogetherProperty, widowControlProperty, outlineLevelProperty, numberFormatProperty, startAtProperty, paragraphFormatProperty, listsProperty, abstractListsProperty, listIdProperty, listLevelNumberProperty, leftIndentProperty, rightIndentProperty, firstLineIndentProperty, textAlignmentProperty, afterSpacingProperty, beforeSpacingProperty, lineSpacingProperty, lineSpacingTypeProperty, listFormatProperty, cellsProperty, rowsProperty, blocksProperty, listLevelPatternProperty, levelsProperty, stylesProperty, nameProperty, numberOfColumnsProperty } from '../../index';
import { SanitizeHtmlHelper } from '@syncfusion/ej2-base';
import { ChangesSingleView } from '../track-changes/track-changes-pane';
import { FieldSettingsModel } from '@syncfusion/ej2-dropdowns';

// Check box character is rendered smaller when compared to MS Word
// So, mutiplied the font side by below factor to render check box character large.
const CHECK_BOX_FACTOR: number = 1.35;

/**
 * Editor module
 */
export class Editor {
    /**
     * @private
     */
    public documentHelper: DocumentHelper;
    private nodes: IWidget[] = [];
    private editHyperlinkInternal: boolean = false;
    private startOffset: number;
    /**
     * @private
     */
    public startParagraph: ParagraphWidget = undefined;
    private endOffset: number;
    private pasteRequestHandler: XmlHttpRequestHandler;
    /**
     * @private
     */
    public endParagraph: ParagraphWidget = undefined;
    private currentProtectionType: ProtectionType;
    private alertDialog: Dialog;
    private formFieldCounter: number = 1;
    private skipFieldDeleteTracking: boolean = false;
    private skipFootNoteDeleteTracking: boolean = false;
    private isForHyperlinkFormat: boolean = false;
    private isTrackingFormField: boolean = false;
    private previousBlockToLayout: BlockWidget;
    private isInsertText: boolean = false;
    private casingIndex: number = -1;
    private checkLastLetterSpace: string = '';
    private checkLastLetterSpaceDot: string = '';
    private pasteFootNoteType: string = '';
    private isInsertingText: boolean = false;
    private isInternalPaste: boolean = false;
    private guid: string;
    private type: string = null;
    /**
     * @private
     */
    public keywordIndex: number = 0;
    /**
     * @private
     */
    public dateValue: string;
    /**
     * @private
     */
    public xmlTitle: string;
    /**
     * @private
     */
    public dictionaryObjcetIDIncreament: number = 1;
    /**
     * @private
     */
    public dictionaryObjectIndexIncrement: number = 0;
    /**
     * @private
     */
    public XMLFilesCount: number = 1;
    /**
     * @private
     */
    public XMLFilesNameSpaceCount: number = 1;
    /**
     * @private
     */
    public xmlData: { [key: string]: Object }[] = [];
    /**
     * @private
     */
    public dictionaryObject:{ ID:string , Data:any }[] = [];
    private footnoteRevision: Revision;
    /**
    * @private
    */
    public isFootnoteElementRemoved: boolean = false;
    /**
    * @private
    */
    public isEndnoteElementRemoved: boolean = false;
    /**
    * @private
    */
    public handledEnter: boolean = false;
    /**
     * @private
     */
    public handledTextInput: boolean = false;
    /**
     * @private
     */
    public isDeleteOrBackSpace: boolean = false;
    /**
     * @private
     */
    public isRemoveRevision: boolean = false;
    /**
     * @private
     */
    public isFootNoteInsert: boolean = false;
    /**
     * @private
     */
    public isTableInsert: boolean = false;
    /**
     * @private
     */
    public isFootNote: boolean = false;
    /**
     * @private
     */
    public isHandledComplex: boolean = false;
    /**
     * @private
     */
    public isUserInsert: boolean = false;
    /**
     * @private
     */
    public tableResize: TableResizer = undefined;
    /**
     * @private
     */
    public tocStyles: TocLevelSettings = {};
    /**
     * @private
     */
    public triggerPageSpellCheck: boolean = true;
    /**
     * @private
     */
    public chartType: boolean = false;
    /**
     * @private
     */
    public isSkipGrouping: boolean = false;
    /**
     * @private
     */
    public removedBookmarkElements: BookmarkElementBox[] = [];
    /**
     * @private
     */
    public removedEditRangeStartElements: EditRangeStartElementBox[] = [];
    /**
     * @private
     */
    public removedEditRangeEndElements: EditRangeEndElementBox[] = [];
    /**
     * @private
     */
    public removedContentControlElements: ContentControl[] = [];
    /**
     * @private
     */
    public tocBookmarkId: number = 0;
    /**
     * @private
     */
    public copiedData: string = undefined;
    /**
     * @private
     */
    public collabTrackAction: boolean = false;
    /**
    * @private
    */
    public isPasteContentCheck: boolean = false;
    /**
     * @private
     */
    public isDeleteTrackedContent: boolean = false;
    /**
     * @private
     */
    public isSelectionBasedonEndRevision: boolean = false;

    private animationTimer: number;
    private pageRefFields: PageRefFields = {};
    private delBlockContinue: boolean = false;
    private delBlock: Widget = undefined;
    private delSection: BodyWidget = undefined;
    /**
     * @private
     */
    public isInsertingTOC: boolean = false;
    /**
     * @private
     */
    public isMeasureParaWidth: boolean = false;
    private editStartRangeCollection: EditRangeStartElementBox[] = [];
    private skipReplace: boolean = false;
    private skipTableElements: boolean = false;
    private isPasteOverWriteCells: boolean = false;
    private removedTextNodes: IWidget[];
    private editRangeID: number[] = [];
    /**
     * @private
     */
    public isImageInsert: boolean = false;
    /**
     * @private
     */
    public isSkipOperationsBuild: boolean = false;
    /**
     * @private
     */
    public isCellFormatApplied: boolean = false;
    /**
     * @private
     */
    public revisionData: MarkerInfo[] = undefined;
    /**
     * @private
     */
    public splittedRevisions: MarkerInfo[] = [];
    /**
     * @private
     */
    public isSkipComments: boolean = false;
    private currentHashValue: string;
    /**
     * @private
     */
    public isRemoteAction: boolean = false;
    /**
     * @private
     */
    public isIncrementalSave: boolean = false;
    /**
     * @private
     */
    public listFormatInfo: ListInfo = undefined;
    /**
     * @private
     */
    public listLevelNumber: number = 0;
     /**
     * @private
     */
     public xmlStringValue: string;
    /**
     * @private
     */
    public isXmlMapped: boolean = false;
    /**
     * @private
     */
    public restrictLayout: boolean = false;
    private isAutoList: boolean = false;
    /**
     * @private
     */
    public isLastParaMarkCopied: boolean = false;
    private combineLastBlock: boolean = false;
    /**
     * @private
     */
    public remotePasteRevision: Revision[] = [];
    /**
     * @private
     */
    public isFieldOperation: boolean = false;
    /**
     * @private
     */
    public decreasedIndent: boolean = false;
    /**
     * @private
     */
    public increasedIndent: boolean = false;
    /**
     * @private
     * @returns {boolean} - Returns the restrict formatting
     */
    public get restrictFormatting(): boolean {
        return this.documentHelper.isDocumentProtected && (this.documentHelper.restrictFormatting
            || (!this.documentHelper.restrictFormatting && !this.selection.isSelectionInEditRegion()))
            && this.documentHelper.protectionType !== 'RevisionsOnly';
    }

    /**
     * @private
     * @returns {boolean} - Returns the restrict editing
     */
    public get restrictEditing(): boolean {
        return this.documentHelper.isDocumentProtected && ((this.documentHelper.protectionType === 'ReadOnly' || this.documentHelper.isCommentOnlyMode)
            && !this.selection.isSelectionInEditRegion() || this.documentHelper.protectionType === 'FormFieldsOnly');
    }
    /**
     * @private
     * @returns {boolean} - Returns the can edit content control.
     */
    public get canEditContentControl(): boolean {
        let currentContentControl : ContentControl = this.selection.currentContentControl;
        if(!isNullOrUndefined(currentContentControl)){
            if (currentContentControl.contentControlProperties.lockContents || currentContentControl.contentControlProperties.type === 'DropDownList') {
                return false;
            }
        }
        else if(this.selection.checkContentControlLocked()){
            return false;
        }
        if (this.owner.isReadOnly) {
            return false;
        }
        return true;
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    /**
     * @private
     */
    public copiedContent: any = '';
    /**
     * @private
     */
    public copiedTextContent: string = '';
    /**
     * @private
     */
    public previousParaFormat: WParagraphFormat = undefined;
    private previousCharFormat: WCharacterFormat = undefined;
    private previousSectionFormat: WSectionFormat = undefined;
    private currentPasteOptions: PasteOptions | TablePasteOptions;
    private pasteTextPosition: PositionInfo = undefined;
    //public isSkipHistory: boolean = false;
    /**
     * @private
     */
    public isPaste: boolean = false;
    /**
     * @private
     */
    public isPasteListUpdated: boolean = false;
    /**
     * @private
     */
    public isHtmlPaste: boolean = false;
    /**
     * @private
     */
    public base64: Base64;
    /**
     * @private
     */
    public isInsertField: boolean = false;

    /**
     * Initialize the editor module
     *
     * @param {DocumentHelper} documentHelper - Document helper
     * @private
     */
    public constructor(documentHelper: DocumentHelper) {
        this.documentHelper = documentHelper;
        if (!isNullOrUndefined(this.documentHelper)) {
            this.tableResize = new TableResizer(this.documentHelper.owner);
        }
        this.base64 = new Base64();
    }
    private get viewer(): LayoutViewer {
        if (!isNullOrUndefined(this.owner)) {
            return this.owner.viewer;
        }
        return undefined;
    }
    private get editorHistory(): EditorHistory {
        return this.documentHelper.owner.editorHistoryModule;
    }
    /**
     * @private
     */
    public isBordersAndShadingDialog: boolean = false;
    /**
     * @private
    */
    public pasteImageIndex: Dictionary<string, string> = undefined;
    private get selection(): Selection {
        if (this.documentHelper) {
            return this.documentHelper.selection;
        }
        return undefined;
    }

    private get owner(): DocumentEditor {
        if (this.documentHelper) {
            return this.documentHelper.owner;
        }
        return undefined;
    }
    private getModuleName(): string {
        return 'Editor';
    }
    /**
     * Initiates a batch update mode where multiple editing operations can be grouped together. This prevents intermediate re-layout during the execution of grouped operations, improving performance for bulk updates.
     *
     * @returns {void}
     */
    public beginBatchEdit(): void {
        this.restrictLayout = true;
    }
    /**
     * Ends the batch update mode and triggers a single re-relayout or change notification to reflect all the modifications made during the batch update. 
     *
     * @returns {void}
     */
    public endBatchEdit(): void {
        this.restrictLayout = false;
        this.documentHelper.layout.layoutWholeDocument();
    }
    /** 
     * Sets the field information for the selected field. 
     * 
     * @param { FieldInfo } fieldInfo – Specifies the field information.  
     * @returns {void} 
     * > Nested field gets replaced completely with the specified field information. 
     */
    public setFieldInfo(fieldInfo: FieldInfo): void {
        const field: FieldElementBox = this.selection.getHyperlinkField(true);
        if (!isNullOrUndefined(field)) {
            this.selection.selectField();
            this.insertField(fieldInfo.code, fieldInfo.result);
        }
    }
    /**
     * Inserts the specified field at cursor position.
     *
     * @param {string} code Specify the field code.
     * @param {string} result Specify the field result.
     * @returns {void}
     */
    public insertField(code: string, result?: string): void {
        this.isInsertField = true;
        let fieldCode: string = code;
        fieldCode = HelperMethods.trimStart(fieldCode);
        if (fieldCode.substring(0, 8) === 'NUMPAGES') {
            this.insertPageCount(result);
        } else
            if (fieldCode.substring(0, 4) === 'PAGE') {
                this.insertPageNumber(result);
            }
            else {
                if (isNullOrUndefined(result)) {
                    if (fieldCode.substring(0, 10) === 'MERGEFIELD') {
                        fieldCode = fieldCode.substring(10).trim();
                        const index: number = fieldCode.indexOf('\\*');
                        result = '«' + fieldCode.substring(0, index).trim() + '»';
                    }
                }

                const paragraph: ParagraphWidget = new ParagraphWidget();
                let insertFormat: WCharacterFormat = new WCharacterFormat();
                let startParagraph: ParagraphWidget = this.selection.start.paragraph;
                if (!this.selection.isForward) {
                    startParagraph = this.selection.end.paragraph;
                }
                const currentInline: ElementInfo = this.selection.start.currentWidget.getInline(this.selection.start.offset, 0);
                if (startParagraph.isEmpty()) {
                    insertFormat = startParagraph.characterFormat;
                } else if (!isNullOrUndefined(currentInline.element)) {
                    insertFormat = currentInline.element.characterFormat;
                } else {
                    insertFormat = this.copyInsertFormat(insertFormat, false);
                }
                const line: LineWidget = new LineWidget(paragraph);
                const fieldBegin: FieldElementBox = new FieldElementBox(0);
                fieldBegin.characterFormat.assignFormat(insertFormat);
                line.children.push(fieldBegin);
                const fieldCodeSpan: TextElementBox = new TextElementBox();
                fieldCodeSpan.characterFormat.assignFormat(insertFormat);
                fieldCodeSpan.text = code;
                line.children.push(fieldCodeSpan);
                const fieldSeparator: FieldElementBox = new FieldElementBox(2);
                fieldSeparator.characterFormat.assignFormat(insertFormat);
                fieldSeparator.fieldBegin = fieldBegin;
                fieldBegin.fieldSeparator = fieldSeparator;
                line.children.push(fieldSeparator);
                const fieldResultSpan: TextElementBox = new TextElementBox();
                fieldResultSpan.text = result;
                fieldResultSpan.characterFormat.assignFormat(insertFormat);
                if (!this.documentHelper.textHelper.isRTLText(result) && fieldResultSpan.characterFormat.bidi) {
                    fieldResultSpan.characterFormat.bidi = false;
                }
                line.children.push(fieldResultSpan);
                const fieldEnd: FieldElementBox = new FieldElementBox(1);
                fieldEnd.characterFormat.assignFormat(insertFormat);
                fieldEnd.fieldSeparator = fieldSeparator;
                fieldEnd.fieldBegin = fieldBegin;
                fieldBegin.fieldEnd = fieldEnd;
                fieldSeparator.fieldEnd = fieldEnd;
                line.children.push(fieldEnd);
                fieldBegin.line = line;
                paragraph.childWidgets.push(line);
                this.documentHelper.fields.push(fieldBegin);
                const section: BodyWidget = new BodyWidget();
                section.sectionFormat = new WSectionFormat(section);
                section.childWidgets.push(paragraph);
                this.pasteContentsInternal([section], false, startParagraph.paragraphFormat);
            }
        this.isInsertField = false;
    }
    /**
     * @private
     */
    public isLinkedStyle(styleName: string): boolean {
        const styleObj: Object = this.documentHelper.styles.findByName(styleName);
        return !isNullOrUndefined((styleObj as WParagraphStyle).link);
    }
    /**
     * Applies the specified style for paragraph.
     *
     * @param {string} style Specify the style name to apply.
     * @param {boolean} clearDirectFormatting - Removes manual formatting (formatting not applied using a style)
     * from the selected text, to match the formatting of the applied style. Default value is false.
     * @returns {void}
     */
    public applyStyle(style: string, clearDirectFormatting?: boolean): void {
        clearDirectFormatting = isNullOrUndefined(clearDirectFormatting) ? false : clearDirectFormatting;
        let startPosition: number = undefined;
        let endPosition: number = undefined;
        const styleObj: Object = this.documentHelper.styles.findByName(style);
        if (clearDirectFormatting) {
            this.initComplexHistory('ApplyStyle');
            this.setOffsetValue(this.selection);
            startPosition = this.startOffset;
            endPosition = this.endOffset;
            const isSelectionEmpty: boolean = this.selection.isEmpty;
            this.isSkipOperationsBuild = this.owner.enableCollaborativeEditing;
            if (!isNullOrUndefined(styleObj) && (styleObj instanceof WCharacterStyle && styleObj.type === 'Character')) {
                this.clearFormattingInternal(false, true);
            }
            else {
                this.clearFormattingInternal(true, true);
            }
            this.isSkipOperationsBuild = false;
            if (isSelectionEmpty && !this.selection.isEmpty) {
                this.selection.end.setPositionInternal(this.selection.start);
            }
        }
        if (styleObj !== undefined) {
            if (styleObj instanceof WCharacterStyle && styleObj.type === 'Character') {
                if (this.selection.isEmpty) {
                    let offset: number = this.selection.start.offset;
                    let preservedStartPosition: TextPosition = this.selection.start.clone();
                    let preservedEndPosition: TextPosition = this.selection.end.clone();
                    this.selection.selectCurrentWord();
                    if (offset === this.selection.start.offset || offset === this.selection.end.offset - 1) {
                        this.selection.start = preservedStartPosition;
                        this.selection.end = preservedEndPosition;
                        this.selection.characterFormat.copyFormat(styleObj.characterFormat);
                    } else {
                        this.onApplyCharacterFormat('styleName', styleObj, false, true);
                    }
                } else {
                    this.onApplyCharacterFormat('styleName', styleObj, false, true);
                }
            } else {
                this.onApplyParagraphFormat('styleName', styleObj, false, true);
            }
        } else {
            /* eslint-disable-next-line max-len */
            this.documentHelper.owner.parser.parseStyle(JSON.parse(this.getCompleteStyles()), JSON.parse(this.documentHelper.preDefinedStyles.get(style)), this.documentHelper.styles);
            this.applyStyle(style);
        }
        if (this.editorHistory && this.editorHistory.currentHistoryInfo && this.editorHistory.currentHistoryInfo.action === 'ApplyStyle') {
            this.startOffset = startPosition;
            this.endOffset = endPosition;
            this.editorHistory.updateComplexHistory();
        }
        this.startParagraph = undefined;
        this.endParagraph = undefined;
    }
    // Public Implementation Starts
    /**
     * Moves the selected content in the document editor control to clipboard.
     *
     * @returns {void}
     */
    public cut(): void {
        if (this.owner.isReadOnlyMode || this.selection.isEmpty || !this.canEditContentControl) {
            return;
        }
        // As per MSWord behaviour, when we select the bookmark whole content except bookmark start & end and cut those content, then bookmark should be removed.
        let startPosition: TextPosition = this.selection.start;
        let endPosition: TextPosition = this.selection.end;
        let previousElementInfo: ElementInfo = (startPosition.offset === 0) ? this.selection.getElementInfo(startPosition.currentWidget, startPosition.offset - 1) : this.selection.getElementInfo(startPosition.currentWidget, this.selection.isForward ? startPosition.offset : startPosition.offset + 1);
        let nextElementInfo: ElementInfo = (endPosition.offset === 0) ? this.selection.getElementInfo(endPosition.currentWidget, endPosition.offset - 1) : this.selection.getElementInfo(endPosition.currentWidget, this.selection.isForward ? endPosition.offset + 1 : endPosition.offset);
        if (!isNullOrUndefined(previousElementInfo) && !isNullOrUndefined(nextElementInfo) && previousElementInfo.element && nextElementInfo.element
            && previousElementInfo.index !== -1 && nextElementInfo.index !== -1 && previousElementInfo.element instanceof BookmarkElementBox && nextElementInfo.element instanceof BookmarkElementBox
            && previousElementInfo.element.name === nextElementInfo.element.name &&
            !(!isNullOrUndefined(previousElementInfo.element.nextElement) && !isNullOrUndefined(nextElementInfo.element.previousElement) && previousElementInfo.element.nextElement instanceof FieldElementBox && nextElementInfo.element.previousElement instanceof FieldElementBox)) {
            if (this.selection.isForward) {
                this.selection.start.setPositionParagraph(previousElementInfo.element.line, previousElementInfo.element.line.getOffset(previousElementInfo.element, 0));
                this.selection.end.setPositionParagraph(nextElementInfo.element.line, nextElementInfo.element.line.getOffset(nextElementInfo.element, 1));
            } else {
                this.selection.start.setPositionParagraph(previousElementInfo.element.line, previousElementInfo.element.line.getOffset(previousElementInfo.element, 1));
                this.selection.end.setPositionParagraph(nextElementInfo.element.line, nextElementInfo.element.line.getOffset(nextElementInfo.element, 0));
            }
        }
        this.selection.copySelectedContent(true);
        this.documentHelper.owner.parser.isCutPerformed = true;
    }
    /**
     * Inserts the editing region where everyone can edit.
     *
     * @returns {void}
     */
    public insertEditingRegion(): void;
    /**
     * Inserts the editing region where mentioned user can edit.
     *
     * @returns {void}
     */
    public insertEditingRegion(user: string): void
    /**
     * Inserts the editing region in the current selection range for the specified user.
     *
     * @param {string} user Specifies the native rendering
     * @returns {void}
     */
    public insertEditingRegion(user?: string): void {
        this.insertEditRangeElement(user && user !== '' ? user : 'Everyone');
    }
    /**
     * Enforces the document protection by protection type.
     *
     * @param {string} credential Specify the credential to protect the document.
     * 
     * @param {ProtectionType} protectionType Specify the document protection type.
     * 
     * @returns {void}
     */
    public enforceProtection(credential: string, protectionType: ProtectionType): void;
    /**
     * Enforces the document protection with the specified credential.
     * 
     * @param {string} credential Specify the credential to protect the document.
     * 
     * @param {boolean} limitToFormatting True if to limit the document formatting; Otherwise, false.
     * 
     * @param {boolean} isReadOnly  True if to allow read-only access to the document; Otherwise, false.
     * 
     * @returns {void}
     */
    public enforceProtection(credential: string, limitToFormatting: boolean, isReadOnly: boolean): void;

    public enforceProtection(credential: string, restrictFormatType: boolean | ProtectionType, isReadOnly?: boolean): void {
        let typeOfProtection: ProtectionType;
        let limitToFormatting: boolean;
        if (typeof (restrictFormatType) === 'boolean') {
            typeOfProtection = isReadOnly ? 'ReadOnly' : this.documentHelper.protectionType;
            limitToFormatting = restrictFormatType;
        } else {
            typeOfProtection = restrictFormatType;
        }
        if (!isNullOrUndefined(limitToFormatting)) {
            this.documentHelper.restrictFormatting = limitToFormatting;
        }
        this.documentHelper.protectionType = typeOfProtection;
        this.selection.isHighlightEditRegion = true;
        this.addProtection(credential, this.documentHelper.protectionType, false);
    }

    /**
     * Enforces the document protection with the specified protection type.
     *
     * @param {string} credential Specify the credential to protect the document.
     * 
     * @param {ProtectionType} protectionType Specify the document protection type.
     * 
     * @returns {Promise} Returns a Promise which is resolved when protection is enforced, or rejected if for any reason protection cannot be enforced.
     */
    public async enforceProtectionAsync(credential: string, protectionType: ProtectionType): Promise<void>;
    /**
     * Enforces the document protection with the specified credential.
     * 
     * @param {string} credential Specify the credential to protect the document.
     * 
     * @param {boolean} limitToFormatting True if to limit the document formatting; Otherwise, false.
     * 
     * @param {boolean} isReadOnly  True if to allow read-only access to the document; Otherwise, false.
     * 
     * @returns {Promise} Returns a Promise which is resolved when protection is enforced, or rejected if for any reason protection cannot be enforced.
     */
    public async enforceProtectionAsync(credential: string, limitToFormatting: boolean, isReadOnly: boolean): Promise<void>;

    public async enforceProtectionAsync(credential: string, restrictFormatType: boolean | ProtectionType, isReadOnly?: boolean): Promise<void> {
        let typeOfProtection: ProtectionType;
        let limitToFormatting: boolean;
        if (typeof (restrictFormatType) === 'boolean') {
            typeOfProtection = isReadOnly ? 'ReadOnly' : this.documentHelper.protectionType;
            limitToFormatting = restrictFormatType;
        } else {
            limitToFormatting = true;
            typeOfProtection = restrictFormatType;
        }
        this.documentHelper.restrictFormatting = limitToFormatting;
        this.documentHelper.protectionType = typeOfProtection;
        this.selection.isHighlightEditRegion = true;
        await this.addProtection(credential, this.documentHelper.protectionType, true);
    }

    private getCommentHierarchicalIndex(comment: CommentElementBox): string {
        let index: string = '';
        while (comment.ownerComment) {
            if (!isNullOrUndefined(comment.ownerComment)) {
                index = comment.ownerComment.replyComments.indexOf(comment) + ';' + index;
                comment = comment.ownerComment;
            } else {
                index = comment.replyComments.indexOf(comment) + ';' + index;
                comment = comment;
            }
        }
        index = 'C;' + this.documentHelper.comments.indexOf(comment) + ';' + index;
        return index;
    }

    private alertBox(): void {
        const localObj: L10n = new L10n('documenteditor', this.owner.defaultLocale);
        localObj.setLocale(this.owner.locale);
        DialogUtility.alert({
            title: localObj.getConstant('Information'),
            content: localObj.getConstant('Multiple Comment')
        });
    }
    /**
     * Inserts a reply to a comment.
     *
     * @param {string} id - The unique identifier of the comment to reply to.
     * @param {string} text - The text of the reply.
     * @param {CommentProperties} commentProperties - The properties of the reply (author, isResolved, dateTime).
     * @returns {Comment} Returns the inserted reply comment.
     */
    public insertReplyComment(id: string, text: string, commentProperties: CommentProperties): Comment {
        let markerData: MarkerInfo = {};
        const result = this.getCommentInfo(text);
        markerData = {
            author: commentProperties.author ? commentProperties.author : 'Guest user',
            initial: this.constructCommentInitial(commentProperties.author ? commentProperties.author : 'Guest user'),
            text: isNullOrUndefined(result.innerText) ? SanitizeHtmlHelper.sanitize(text) : SanitizeHtmlHelper.sanitize(result.innerText),
            commentId: Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15),
            done: false,
            date: commentProperties.dateTime ? HelperMethods.getUtcDate(commentProperties.dateTime) : HelperMethods.getUtcDate(),
        }
        let parentComment: CommentElementBox;
        if (this.documentHelper.comments.length > 0) {
            for (let i: number = 0; i < this.documentHelper.comments.length; i++) {
                if (this.documentHelper.comments[i].commentId === id) {
                    parentComment = this.documentHelper.comments[i];
                    break;
                }
            }
        }
        this.replyComment(parentComment, isNullOrUndefined(result.innerText) ? text : result.innerText, result.itemData, markerData);
        let commentInfo: CommentProperties = {
            author: markerData.author,
            isResolved: markerData.done,
            dateTime: this.parseDateTime(markerData.date),
        }
        const newComment = new Comment(markerData.commentId, commentInfo, text);
        return newComment;
    }

    private getCommentInfo(text: string): { itemData: FieldSettingsModel[]; innerText: string } {
        let itemData: FieldSettingsModel[] = [];
        let data: any = [];
        type MailtoResult = {
            mailto?: string;
            text: string;
        }
        let result: MailtoResult[] = [];
        const mailtoRegex = /<a href="mailto:([^"]+)">([^<]+)<\/a>/g;
        let lastIndex = 0;
        let match;
        while ((match = mailtoRegex.exec(text)) !== null) {
            if (match.index > lastIndex) {
                result.push({ text: text.substring(lastIndex, match.index) });
            }
            result.push({
                mailto: match[1],
                text: match[2]
            });
            lastIndex = mailtoRegex.lastIndex;
        }
        if (lastIndex < text.length) {
            result.push({ text: text.substring(lastIndex) });
        }
        let innerText: string = '';
        if (result.length > 0) {
            for (let i = 0; i < result.length; i++) {
                if (result[i].mailto) {
                    data.push({ text: result[i].text.replace('@', ''), value: result[i].mailto });
                    innerText += '<span contenteditable="false" class="e-mention-chip">' + result[i].text.replace('@', '') + '</span>';
                } else if (result[i].text) {
                    innerText += result[i].text.replace(/(\r\n|\n\r|\n|\r)/g, "<br>");
                }
            }
        } else if (text !== '') {
            innerText = text.replace(/(\r\n|\n\r|\n|\r)/g, "<br>");
        }
        itemData = data;
        return { itemData, innerText };
    }

    /**
     * Inserts the comment.
     *
     * @param {string} text Specify the comment text to be inserted.
     * @returns {void}
     */
    // Comment implementation starts
    public insertComment(text?: string): void;
    /**
     * Inserts a comment with the specified properties.
     *
     * @param {string} text The text of the comment to be inserted.
     * @param {CommentProperties} commentProperties The properties of the comment (author, isResolved, dateTime).
     * @returns {Comment} The inserted comment.
     */
    public insertComment(text: string, commentProperties: CommentProperties): Comment;
    /**
     * Inserts the comment.
     *
     * @param {string} text Specify the comment text to be inserted.
     * @param {CommentProperties} commentProperties The properties of the comment (author, isResolved, dateTime).
     * @returns {Comment}
     */
    public insertComment(text?: string, commentProperties?: CommentProperties): Comment | void {
        if (isNullOrUndefined(this.selection.start) || (this.owner.isReadOnlyMode && !this.documentHelper.isCommentOnlyMode) || this.viewer.owner.enableHeaderAndFooter
            || !this.viewer.owner.enableComment || this.selection.isPlainContentControl()) {
            return;
        }
        if (this.viewer.owner.commentReviewPane.commentPane.isEditMode) {
            return this.alertBox();
        }
        if (isNullOrUndefined(text)) {
            text = '';
        }
        let markerData: MarkerInfo = {};
        const result = this.getCommentInfo(text);
        if (!isNullOrUndefined(commentProperties)) {
            let authorInternal: string = isNullOrUndefined(commentProperties.author) ? this.owner.currentUser : commentProperties.author;
            markerData = {
                author: authorInternal,
                initial: this.constructCommentInitial(authorInternal),
                text: SanitizeHtmlHelper.sanitize(result.innerText === '' ? text : result.innerText),
                commentId: Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15),
                done: commentProperties.isResolved ? commentProperties.isResolved : false,
                date: commentProperties.dateTime ? HelperMethods.getUtcDate(commentProperties.dateTime) : HelperMethods.getUtcDate()
            };

        } else {
            markerData = {
                author: this.owner.currentUser ? SanitizeHtmlHelper.sanitize(this.owner.currentUser) : 'Guest user',
                initial: this.constructCommentInitial(this.owner.currentUser ? SanitizeHtmlHelper.sanitize(this.owner.currentUser) : 'Guest user'),
                text: SanitizeHtmlHelper.sanitize(text),
                commentId: Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15),
                done: false,
                date: HelperMethods.getUtcDate(),
            }
        }
        this.insertCommentInternal(!isNullOrUndefined(result.innerText) ? result.innerText : '', markerData, result.itemData);
        let commentInfo: CommentProperties = {
            author: markerData.author,
            isResolved: markerData.done,
            dateTime: this.parseDateTime(markerData.date),
        }
        const newComment = new Comment(markerData.commentId, commentInfo, text);
        return newComment;
    }
    
    /**
     * @private
     */
    public parseDateTime(dateTime: string): Date {
        let date = new Date(dateTime);
        const finalDate = new Date(date.getTime() + date.getTimezoneOffset() * 60000);
        return finalDate;
    }

    private insertCommentInternal(text: string, markerData: MarkerInfo, mentions?: FieldSettingsModel[]): void {
        this.documentHelper.layout.allowLayout = false;
        if (this.selection.isEmpty) {
            // If selection is at paragraph end, move selection to previous word similar to MS Word
            if (this.selection.start.isAtSamePosition(this.selection.end) && this.selection.start.isAtParagraphEnd) {
                const startOffset: number = this.selection.start.offset;
                this.selection.start.offset = startOffset - 1 !== -1 ? startOffset - 1 : startOffset;
            }
            this.selection.selectCurrentWord();
        }
        // If paragraph mark selected, remove paragraph mark selection
        if (this.selection.isParagraphLastLine(this.selection.end.currentWidget)
            && this.selection.end.offset === this.selection.getLineLength(this.selection.end.currentWidget) + 1) {
            this.selection.end.offset -= 1;
        }
        const paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(this.selection.start);
        const startIndex: string = this.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
        let startPosition: TextPosition = this.selection.start;
        let endPosition: TextPosition = this.selection.end;
        const position: TextPosition = new TextPosition(this.owner);
        if (!this.selection.isForward) {
            startPosition = this.selection.end;
            endPosition = this.selection.start;
        }
        // Clones the end position.
        position.setPositionInternal(startPosition);
        this.initComplexHistory('InsertComment');
        const commentRangeStart: CommentCharacterElementBox = new CommentCharacterElementBox(0);
        const commentRangeEnd: CommentCharacterElementBox = new CommentCharacterElementBox(1);
        // Adds comment end at selection end position.
        startPosition.setPositionInternal(endPosition);
        this.initInsertInline(commentRangeEnd);
        if (isNullOrUndefined(position.paragraph) || position.currentWidget.indexInOwner === -1) {
            const startPos: TextPosition = this.selection.getTextPosBasedOnLogicalIndex(startIndex);
            position.setPositionInternal(startPos);
        }
        // Adds comment end and comment at selection end position.
        startPosition.setPositionInternal(position);
        endPosition.setPositionInternal(position);
        this.initInsertInline(commentRangeStart);
        let commentAdv: CommentElementBox = new CommentElementBox(markerData.date);
        if (mentions && mentions.length > 0) {
            commentAdv.mentions = mentions;
        }
        if (this.owner.editorHistoryModule) {
            this.initHistory('InsertCommentWidget');
            this.owner.editorHistoryModule.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Marker_Start + CONTROL_CHARACTERS.Marker_End;
            this.owner.editorHistoryModule.currentBaseHistoryInfo.removedNodes.push(commentAdv);
        }
        this.updateCommentElement(commentAdv, commentRangeStart, commentRangeEnd, markerData);
        this.addCommentWidget(commentAdv, true, true, true);
        if (this.owner.isSpellCheck && commentRangeStart.previousElement && commentRangeStart.previousElement instanceof TextElementBox) {
            commentRangeStart.previousElement.isChangeDetected = true;
        }
        if (this.owner.isSpellCheck && commentRangeEnd.previousElement && commentRangeEnd.previousElement instanceof TextElementBox && commentRangeStart.line !== commentRangeEnd.line) {
            commentRangeEnd.previousElement.isChangeDetected = true;
        }
        if (this.editorHistory) {
            this.editorHistory.currentBaseHistoryInfo.insertPosition = this.getCommentHierarchicalIndex(commentAdv);
            this.editorHistory.updateHistory();
        }


        // this.selection.selectPosition(this.selection.getTextPosBasedOnLogicalIndex(startIndex), this.selection.getTextPosBasedOnLogicalIndex(endIndex));
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistory();
        }
        this.reLayout(this.selection, false);
        this.documentHelper.layout.allowLayout = true;
        if (!this.isUserInsert) {
            const comment: CommentView = this.owner.commentReviewPane.commentPane.comments.get(commentAdv);
            if (mentions && mentions.length > 0) {
                comment.itemData = mentions;
            }
            comment.postComment();
        }
    }

    /**
     * @private
     */
    public updateCommentElement(commentAdv: CommentElementBox, commentRangeStart: CommentCharacterElementBox, commentRangeEnd: CommentCharacterElementBox, markerData: MarkerInfo): CommentElementBox {
        commentAdv.author = markerData.author;
        commentAdv.initial = markerData.initial;
        commentAdv.text = markerData.text;
        commentAdv.commentId = markerData.commentId;
        if (!isNullOrUndefined(markerData.done)) {
            commentAdv.isResolved = markerData.done;
        }
        if (!isNullOrUndefined(markerData.isReply)) {
            commentAdv.isReply = markerData.isReply;
        }
        if(!isNullOrUndefined(commentRangeStart) && !isNullOrUndefined(commentRangeEnd))
        {
        commentRangeStart.comment = commentAdv;
        commentRangeStart.commentId = commentAdv.commentId;
        commentRangeEnd.comment = commentAdv;
        commentRangeEnd.commentId = commentAdv.commentId;
        commentAdv.commentStart = commentRangeStart;
        commentAdv.commentEnd = commentRangeEnd;
        }

        return commentAdv;
    }

    /**
     * Deletes all the comments in the current document.
     *
     * @returns {void}
     */
    public deleteAllComments(): void {
        if (this.documentHelper.comments.length === 0) {
            return;
        }

        // this.documentHelper.clearSearchHighlight();
        this.initComplexHistory('DeleteAllComments');
        this.owner.isLayoutEnabled = false;
        let historyInfo: HistoryInfo;
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            historyInfo = this.editorHistory.currentHistoryInfo;
        }
        while (this.documentHelper.comments.length > 0) {
            const comment: CommentElementBox = this.documentHelper.comments[0];
            this.initComplexHistory('DeleteComment');
            this.deleteCommentInternal(comment);
            if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
                historyInfo.addModifiedAction(this.editorHistory.currentHistoryInfo);
            }
        }
        this.selection.selectContent(this.owner.documentStart, true);
        if (this.editorHistory) {
            this.editorHistory.currentHistoryInfo = historyInfo;
            this.editorHistory.updateComplexHistory();
        }
    }
    /**
     * Deletes the specified comment. 
     * If the provided id corresponds to a parent comment, the entire comment along with its replies will be deleted.
     * If the provided id corresponds to a single reply comment, only that particular reply will be deleted.
     *
     * @param {string} [id] - The unique identifier of the comment to be deleted. If not provided, the currently selected comment will be deleted.
     * @returns {void}
     */
    public deleteComment(id?: string): void {
        if ((this.owner.isReadOnlyMode && !this.documentHelper.isCommentOnlyMode) || isNullOrUndefined(this.owner) || isNullOrUndefined(this.owner.viewer)
            || (isNullOrUndefined(this.owner.documentHelper.currentSelectedComment) && isNullOrUndefined(id)) || this.owner.enableHeaderAndFooter
            || !this.viewer.owner.enableComment) {
            return;
        }
        let comment: CommentElementBox;
        if (!isNullOrUndefined(id)) {
            let tempcomment: CommentElementBox;
            if (this.documentHelper.comments.length > 0) {
                for (let i: number = 0; i < this.documentHelper.comments.length; i++) {
                    tempcomment = this.documentHelper.comments[i];
                    if (tempcomment.commentId === id) {
                        comment = this.documentHelper.comments[i];
                        break;
                    } else if (tempcomment.replyComments && tempcomment.replyComments.length > 0) {
                        for (let j: number = 0; j < tempcomment.replyComments.length; j++) {
                            if (tempcomment.replyComments[j].commentId === id) {
                                comment = tempcomment.replyComments[j];
                                break;
                            }
                        }
                    }
                }
            }
            if (!isNullOrUndefined(comment)) {
                this.deleteCommentInternal(comment);
            } else {
                throw new Error('Enter a valid comment id.');
            }
        } else {
            this.deleteCommentInternal(this.owner.documentHelper.currentSelectedComment);
        }
    }
    /**
     * @param {CommentElementBox} comment - Specified the comment element box
     * @private
     * @returns {void}
     */
    public deleteCommentInternal(comment: CommentElementBox): void {
        this.initComplexHistory('DeleteComment');
        if (comment) {
            if (comment.replyComments.length > 0) {
                for (let i: number = comment.replyComments.length - 1; i >= 0; i--) {
                    this.deleteCommentInternal(comment.replyComments[i]);
                }
            }
            this.deleteCommentWidgetInternal(comment);
            const commentStart: CommentCharacterElementBox = comment.commentStart;
            const commentEnd: CommentCharacterElementBox = comment.commentEnd;
            if (commentEnd.indexInOwner !== -1) {
                this.removeInline(commentEnd);
            }
            if (commentStart.indexInOwner !== -1) {
                this.removeInline(commentStart);
            }
            commentStart.removeCommentMark();
        }
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistory();
        }
    }

    private deleteCommentWidgetInternal(comment: CommentElementBox): void {
        if (this.owner.editorHistoryModule) {
            this.initHistory('DeleteCommentWidget');
            this.owner.editorHistoryModule.currentBaseHistoryInfo.insertPosition = this.getCommentHierarchicalIndex(comment);
            this.owner.editorHistoryModule.currentBaseHistoryInfo.removedNodes.push(comment);
        }
        this.deleteCommentWidget(comment);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
    }

    /**
     * @param {CommentElementBox} comment - Specified the comment element box
     * @private
     * @returns {void}
     */
    public deleteCommentWidget(comment: CommentElementBox): void {

        let commentIndex: number = this.documentHelper.comments.indexOf(comment);
        if (commentIndex !== -1) {
            this.documentHelper.comments.splice(commentIndex, 1);
        } else if (comment.isReply && comment.ownerComment) {
            commentIndex = comment.ownerComment.replyComments.indexOf(comment);
            comment.ownerComment.replyComments.splice(commentIndex, 1);
        }
        if (this.owner.commentReviewPane) {
            this.owner.commentReviewPane.deleteComment(comment);
            if (this.documentHelper.currentSelectedComment === comment) {
                this.documentHelper.currentSelectedComment = undefined;
            }
        }

    }

    /**
     * @param {CommentElementBox} comment - Specified the comment element box
     * @private
     * @returns {void}
     */
    public resolveComment(comment: CommentElementBox): void {
        if (this.owner.isReadOnlyMode && !this.documentHelper.isCommentOnlyMode) {
            return;
        }
        const eventArgs: CommentActionEventArgs = { author: comment.author, cancel: false, type: 'Resolve' };
        this.owner.trigger(beforeCommentActionEvent, eventArgs);
        if (eventArgs.cancel && eventArgs.type === 'Resolve') {
            return;
        }
        this.initHistory('ResolveComment');
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            this.editorHistory.currentBaseHistoryInfo.removedNodes.push(comment);
        }
        this.resolveOrReopenComment(comment, true);
    }

    /**
     * @param {CommentElementBox} comment - Specified the comment element box
     * @private
     * @returns {void}
     */
    public reopenComment(comment: CommentElementBox): void {
        if (this.owner.isReadOnlyMode && !this.documentHelper.isCommentOnlyMode) {
            return;
        }
        const eventArgs: CommentActionEventArgs = { author: comment.author, cancel: false, type: 'Reopen' };
        this.owner.trigger(beforeCommentActionEvent, eventArgs);
        if (eventArgs.cancel && eventArgs.type === 'Reopen') {
            return;
        }
        this.initHistory('ResolveComment');
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            this.editorHistory.currentBaseHistoryInfo.removedNodes.push(comment);
        }
        this.resolveOrReopenComment(comment, false);
    }

    /**
     * @private
     */
    public resolveOrReopenComment(comment: CommentElementBox, resolve: boolean): void {
        comment.isResolved = resolve;
        for (let i: number = 0; i < comment.replyComments.length; i++) {
            comment.replyComments[i].isResolved = resolve;
        }
        if (this.owner.commentReviewPane) {
            if (resolve) {
                this.owner.commentReviewPane.resolveComment(comment);
            } else {
                this.owner.commentReviewPane.reopenComment(comment);
            }
        }
        this.reLayout(this.selection, false, false);
    }

    /**
     * @param {CommentElementBox} parentComment - Specified the parent comment
     * @param {string} text - Specified the text.
     * @private
     * @returns {void}
     */
    public replyComment(parentComment: CommentElementBox, text?: string, mentions?: FieldSettingsModel[], markerData?: MarkerInfo): void {
        if (this.owner.isReadOnlyMode && !this.documentHelper.isCommentOnlyMode) {
            return;
        }
        const commentWidget: CommentElementBox = parentComment;
        if (parentComment) {
            let replyComment: CommentElementBox;
            if (markerData) {
                replyComment = new CommentElementBox(markerData.date);
                replyComment.author = markerData.author;
                replyComment.text = text;
                replyComment.mentions = mentions ? mentions : [];
                replyComment.commentId = markerData.commentId;
                replyComment.isReply = true;
            } else {
                replyComment = new CommentElementBox(HelperMethods.getUtcDate());
                replyComment.author = this.owner.currentUser ? SanitizeHtmlHelper.sanitize(this.owner.currentUser) : 'Guest user';
                replyComment.text = text ? text : '';
                replyComment.mentions = mentions ? mentions : [];
                replyComment.commentId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
                replyComment.isReply = true;
            }
            const eventArgs: CommentActionEventArgs = { author: replyComment.author, cancel: false, type: 'Post', text: replyComment.text, mentions: replyComment.mentions };
            this.owner.trigger(beforeCommentActionEvent, eventArgs);
            if (eventArgs.cancel && eventArgs.type === 'Post') {
                return;
            }
            this.initComplexHistory('InsertComment');
            const currentCmtStart: CommentCharacterElementBox = commentWidget.commentStart;
            const currentCmtEnd: CommentCharacterElementBox = commentWidget.commentEnd;
            let replyCmtLength: number = commentWidget.replyComments.length;
            const offset: number = currentCmtStart.line.getOffset(currentCmtStart, replyCmtLength + 1);

            let startPosition: TextPosition = new TextPosition(this.documentHelper.owner);
            startPosition.setPositionParagraph(currentCmtStart.line, offset);
            const endOffset: number = currentCmtEnd.line.getOffset(currentCmtEnd, replyCmtLength + 1);

            let endPosition: TextPosition = new TextPosition(this.documentHelper.owner);
            endPosition.setPositionParagraph(currentCmtEnd.line, endOffset);
            this.selection.start.setPositionInternal(startPosition);
            this.selection.end.setPositionInternal(endPosition);

            startPosition = this.selection.start;
            endPosition = this.selection.end;

            const position: TextPosition = new TextPosition(this.owner);
            // Clones the end position.
            position.setPositionInternal(endPosition);

            const commentRangeStart: CommentCharacterElementBox = new CommentCharacterElementBox(0);
            const commentRangeEnd: CommentCharacterElementBox = new CommentCharacterElementBox(1);
            const isAtSameLine: boolean = startPosition.currentWidget === endPosition.currentWidget;

            // Adds comment start at selection start position.
            endPosition.setPositionInternal(startPosition);
            let lineIndex: number = position.currentWidget.indexInOwner;
            this.initInsertInline(commentRangeStart);
            if (position.currentWidget.indexInOwner === -1) {
                position.currentWidget = position.currentWidget.paragraph.childWidgets[lineIndex] as LineWidget;
            }
            // Updates the cloned position, since comment start is added in the same paragraph.
            if (isAtSameLine) {
                position.setPositionParagraph(position.currentWidget, position.offset + commentRangeStart.length);
            }

            // Adds comment end and comment at selection end position.
            startPosition.setPositionInternal(position);
            endPosition.setPositionInternal(position);

            this.initInsertInline(commentRangeEnd);
            commentWidget.replyComments.push(replyComment);
            replyComment.ownerComment = commentWidget;
            if (this.owner.editorHistoryModule) {
                this.initHistory('InsertCommentWidget');
                this.owner.editorHistoryModule.currentBaseHistoryInfo.removedNodes.push(replyComment);
                this.owner.editorHistoryModule.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Marker_Start + CONTROL_CHARACTERS.Marker_End;
            }
            commentRangeStart.comment = replyComment;
            commentRangeStart.commentId = replyComment.commentId;
            commentRangeEnd.comment = replyComment;
            commentRangeEnd.commentId = replyComment.commentId;
            replyComment.commentStart = commentRangeStart;
            replyComment.commentEnd = commentRangeEnd;

            if (this.owner.commentReviewPane) {
                this.owner.commentReviewPane.addReply(replyComment, false, true);
            }
            if (this.editorHistory) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = this.getCommentHierarchicalIndex(replyComment);
                this.editorHistory.updateHistory();
            }

            if (this.editorHistory) {
                this.editorHistory.updateComplexHistory();
            }
            this.isSkipOperationsBuild = this.owner.enableCollaborativeEditing;
            this.reLayout(this.selection);
            this.isSkipOperationsBuild = false;
        }
    }



    private removeInline(element: ElementBox): void {
        this.selection.start.setPositionParagraph(element.line, element.line.getOffset(element, 0));
        this.selection.end.setPositionParagraph(this.selection.start.currentWidget, this.selection.start.offset + element.length);
        this.initHistory('RemoveInline');
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            this.updateHistoryPosition(this.selection.start, true);
        }
        this.removeSelectedContents(this.documentHelper.selection);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.fireContentChange();
    }
    /**
     * @param {CommentElementBox} commentWidget - Specifies the comment
     * @param {boolean} isNewComment - Specifies is new comment
     * @param {boolean} showComments - Specifies show comments
     * @param {boolean} selectComment - Specified select comment
     * @private
     * @returns {void}
     */
    public addCommentWidget(commentWidget: CommentElementBox, isNewComment: boolean, showComments: boolean, selectComment: boolean): void {
        if (this.documentHelper.comments.indexOf(commentWidget) === -1) {
            let isInserted: boolean = false;
            if (this.documentHelper.comments.length > 0) {

                const currentStart: TextPosition = this.selection.getElementPosition(commentWidget.commentStart).startPosition;
                for (let i: number = 0; i < this.documentHelper.comments.length; i++) {
                    /* eslint-disable-next-line max-len */
                    const paraIndex: TextPosition = this.selection.getElementPosition(this.documentHelper.comments[i].commentStart).startPosition;
                    if (currentStart.isExistBefore(paraIndex)) {
                        isInserted = true;
                        this.documentHelper.comments.splice(i, 0, commentWidget);
                        break;
                    }
                }
            }
            if (!isInserted) {
                this.documentHelper.comments.push(commentWidget);
            }
            if (this.owner.commentReviewPane) {
                this.owner.showComments = showComments;
                this.owner.commentReviewPane.selectedTab = 0;
                this.owner.commentReviewPane.addComment(commentWidget, isNewComment, selectComment);
                this.owner.commentReviewPane.reviewTab.selectedItem = 0;
                if (selectComment) {
                    this.owner.selectionModule.selectComment(commentWidget);
                }
            }
        }
    }
    /**
     * @param {CommentElementBox} comment - Specifies comment element box
     * @param {string} hierarchicalIndex - Specifies the hierachical index.
     * @private
     * @returns {void}
     */
    public addReplyComment(comment: CommentElementBox, hierarchicalIndex: string): void {
        const index: string[] = hierarchicalIndex.split(';');
        const ownerComment: CommentElementBox = this.documentHelper.comments[parseInt(index[1], 10)];
        if (index[2] !== '') {
            ownerComment.replyComments.splice(parseInt(index[2], 10), 0, comment);
            comment.ownerComment = ownerComment;
        }
        if (this.owner.commentReviewPane) {
            this.owner.showComments = true;
            this.owner.commentReviewPane.addReply(comment, false, true);
            this.owner.selectionModule.selectComment(comment);
        }
    }

    /**
     * @param {string} password - Specifies the password
     * @param {string} protectionType - Specifies the protection type
     * @param {boolean} isAsync - specifies whether the send method is synchronous or asynchronous
     * @private
     * @returns {void}
     */
    public async addProtection(password: string, protectionType: ProtectionType, isAsync?: boolean): Promise<void> {
        return new Promise(
            (resolve: Function, reject: Function) => {
                isAsync = isNullOrUndefined(isAsync) ? true : isAsync;
                if (password === '') {
                    this.protectDocument(protectionType);
                    resolve();
                } else {
                    this.currentProtectionType = protectionType;
                    const enforceProtectionHandler: XmlHttpRequestHandler = new XmlHttpRequestHandler();
                    const passwordBase64: string = this.base64.encodeString(password);
                    /* eslint-disable @typescript-eslint/no-explicit-any */
                    const formObject: any = {
                        passwordBase64: passwordBase64,
                        saltBase64: '',
                        spinCount: 100000
                    };
                    /* eslint-enable @typescript-eslint/no-explicit-any */
                    const url: string = this.owner.serviceUrl + this.owner.serverActionSettings.restrictEditing;
                    enforceProtectionHandler.url = url;
                    enforceProtectionHandler.contentType = 'application/json;charset=UTF-8';
                    enforceProtectionHandler.onSuccess = (result: any) => {
                        this.enforceProtectionInternal(result);
                        resolve();
                    }
                    enforceProtectionHandler.onFailure = (result: any) => {
                        this.protectionFailureHandler(result);
                        reject();
                    }
                    enforceProtectionHandler.onError = (result: any) => {
                        this.protectionFailureHandler(result);
                        reject();
                    }
                    enforceProtectionHandler.customHeaders = this.owner.headers;
                    const httprequestEventArgs: XmlHttpRequestEventArgs = { serverActionType: 'RestrictEditing', headers: this.owner.headers, timeout: 0, cancel: false, withCredentials: false };
                    this.owner.trigger(beforeXmlHttpRequestSend, httprequestEventArgs);
                    if (httprequestEventArgs.cancel) {
                        if (this.documentHelper.dialog.visible) {
                            this.documentHelper.dialog.hide();
                        }
                    } else {
                        enforceProtectionHandler.send(formObject, httprequestEventArgs, isAsync);
                    }
                }
            }
        );
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    private protectionFailureHandler(result: any): void {
        if (this.owner) {
            const localeValue: L10n = new L10n('documenteditor', this.owner.defaultLocale);
            localeValue.setLocale(this.documentHelper.owner.locale);
            if (result.name === 'onError') {
                DialogUtility.alert(localeValue.getConstant('Error in establishing connection with web server'));
            } else {
                this.owner.fireServiceFailure(result);
                console.error(result.statusText);
            }
        }
    }
    private enforceProtectionInternal(result: any): void {
        const data: string[] = JSON.parse(result.data);
        this.enforceProtectionAssign(data[0], data[1], this.currentProtectionType);
        this.owner.showHideRulers();
    }
    /**
     * @private
     */
    public enforceProtectionAssign(saltValue: string, hashValue: string, protectionType: ProtectionType): void {
        if(this.documentHelper) {
            this.documentHelper.saltValue = saltValue;
            this.documentHelper.hashValue = hashValue;
            this.protectDocument(protectionType);
        }
    }
    private toggleTrackChangesProtection(enabled: boolean): void {
        this.viewer.owner.enableTrackChanges = enabled;
        let eventArgs: TrackChangeEventArgs = { isTrackChangesEnabled: enabled };
        this.owner.trigger(trackChangeEvent, eventArgs);
    }
    /**
     * @private
     */
    public protectDocument(protectionType: ProtectionType): void {
        this.documentHelper.owner.getSettingData("protection", null, this.documentHelper.hashValue, this.documentHelper.saltValue, protectionType);
        this.protect(protectionType);
        const restrictPane: HTMLElement = this.documentHelper.restrictEditingPane.restrictPane;
        if (restrictPane && restrictPane.style.display === 'block') {
            this.documentHelper.restrictEditingPane.showStopProtectionPane(true);
            this.documentHelper.restrictEditingPane.loadPaneValue();
            if (this.documentHelper.dialog.visible) {
                this.documentHelper.dialog.hide();
            }
        }
        this.owner.notify(protectionTypeChangeEvent, {});
        if (protectionType === 'RevisionsOnly') {
            this.toggleTrackChangesProtection(true);
        }
        this.owner.trackChangesPane.enableDisableButton(false, true);
        if (!this.documentHelper.owner.enableCollaborativeEditing) {
            this.fireContentChange();
        }
    }
    /**
     * Stops the document protection.
     *
     * @param {string} password Specify the password to stop protection.
     * @returns {void}
     */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    public stopProtection(password: string): void {
        if (this.documentHelper.isDocumentProtected) {
            if ((!isNullOrUndefined(this.documentHelper.saltValue) && this.documentHelper.saltValue === '')
                && (!isNullOrUndefined(this.documentHelper.hashValue) && this.documentHelper.hashValue === '')
                && (!isNullOrUndefined(password) && password === '')) {
                this.unProtectDocument();
                return;
            }
            const unProtectDocumentHandler: XmlHttpRequestHandler = new XmlHttpRequestHandler();
            const passwordBase64: string = this.base64.encodeString(password);
            const formObject: any = {
                passwordBase64: passwordBase64,
                saltBase64: this.documentHelper.saltValue,
                spinCount: 100000
            };
            unProtectDocumentHandler.url = this.owner.serviceUrl + this.owner.serverActionSettings.restrictEditing;
            unProtectDocumentHandler.contentType = 'application/json;charset=UTF-8';
            unProtectDocumentHandler.customHeaders = this.owner.headers;
            unProtectDocumentHandler.onSuccess = this.onUnProtectionSuccess.bind(this);
            unProtectDocumentHandler.onFailure = this.protectionFailureHandler.bind(this);
            unProtectDocumentHandler.onError = this.protectionFailureHandler.bind(this);
            const httprequestEventArgs: XmlHttpRequestEventArgs = { serverActionType: 'RestrictEditing', headers: this.owner.headers, timeout: 0, cancel: false, withCredentials: false };
            this.owner.trigger(beforeXmlHttpRequestSend, httprequestEventArgs);
            if (httprequestEventArgs.cancel) {
                if (this.documentHelper.dialog.visible) {
                    this.documentHelper.dialog.hide();
                }
            } else {
                unProtectDocumentHandler.send(formObject, httprequestEventArgs, false);
            }
            if (!this.owner.enableTrackChanges) {
                this.toggleTrackChangesProtection(false);
            }
        }
    }
    /**
     * Stops the document protection.
     *
     * @param {string} password Specify the password to stop protection.
     * @returns {Promise} Returns a Promise which is resolved when protection is stopped, or rejected if for any reason protection cannot be stopped.
     */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    public async stopProtectionAsync(password: string): Promise<void> {
        return new Promise(
            (resolve: Function, reject: Function) => {
                if (this.documentHelper.isDocumentProtected) {
                    if ((!isNullOrUndefined(this.documentHelper.saltValue) && this.documentHelper.saltValue === '')
                        && (!isNullOrUndefined(this.documentHelper.hashValue) && this.documentHelper.hashValue === '')
                        && (!isNullOrUndefined(password) && password === '')) {
                        this.unProtectDocument();
                        resolve();
                        return;
                    }
                    const unProtectDocumentHandler: XmlHttpRequestHandler = new XmlHttpRequestHandler();
                    const passwordBase64: string = this.base64.encodeString(password);
                    const formObject: any = {
                        passwordBase64: passwordBase64,
                        saltBase64: this.documentHelper.saltValue,
                        spinCount: 100000
                    };
                    unProtectDocumentHandler.url = this.owner.serviceUrl + this.owner.serverActionSettings.restrictEditing;
                    unProtectDocumentHandler.contentType = 'application/json;charset=UTF-8';
                    unProtectDocumentHandler.customHeaders = this.owner.headers;
                    unProtectDocumentHandler.onSuccess = (result: any) => {
                        let protectionSuccess: boolean = this.onUnProtectionSuccess(result);
                        if (protectionSuccess) {
                            resolve();
                        }
                        else {
                            reject();
                        }
                    }
                    unProtectDocumentHandler.onFailure = (result: any) => {
                        this.protectionFailureHandler(result);
                        reject();
                    }
                    unProtectDocumentHandler.onError = (result: any) => {
                        this.protectionFailureHandler(result);
                        reject();
                    }
                    const httprequestEventArgs: XmlHttpRequestEventArgs = { serverActionType: 'RestrictEditing', headers: this.owner.headers, timeout: 0, cancel: false, withCredentials: false };
                    this.owner.trigger(beforeXmlHttpRequestSend, httprequestEventArgs);
                    if (httprequestEventArgs.cancel) {
                        if (this.documentHelper.dialog.visible) {
                            this.documentHelper.dialog.hide();
                        }
                    } else {
                        unProtectDocumentHandler.send(formObject, httprequestEventArgs);
                    }
                    if (!this.owner.enableTrackChanges) {
                        this.toggleTrackChangesProtection(false);
                    }
                }
            }
        );
    }
    private onUnProtectionSuccess(result: any): boolean {
        const encodeString: string[] = JSON.parse(result.data);
        let validateValue: boolean = this.validateHashValue(encodeString[1]);
        this.owner.showHideRulers();
        return validateValue;
    }
    /**
     * @private
     */
    public validateHashValue(currentHashValue: string): boolean {
        this.currentHashValue = currentHashValue;
        const localeValue: L10n = new L10n('documenteditor', this.owner.defaultLocale);
        localeValue.setLocale(this.documentHelper.owner.locale);
        const decodeUserHashValue: Uint8Array = this.base64.decodeString(currentHashValue);
        const documentHashValue: string = this.documentHelper.hashValue;
        const defaultHashValue: Uint8Array = this.base64.decodeString(documentHashValue);
        let stopProtection: boolean = true;
        if (decodeUserHashValue.length === defaultHashValue.length) {
            for (let i: number = 0; i < decodeUserHashValue.length; i++) {
                if (decodeUserHashValue[i] !== defaultHashValue[i]) {
                    stopProtection = false;
                    break;
                }
            }
        } else {
            stopProtection = false;
        }
        if (stopProtection) {
            this.unProtectDocument();
            return true;
        } else {
            DialogUtility.alert(localeValue.getConstant('The password is incorrect'));
            return false;
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public unProtectDocument(): void {
        this.documentHelper.owner.getSettingData('protection', false, this.currentHashValue);
        this.currentHashValue = null;
        let previousProtectionType: ProtectionType = this.documentHelper.protectionType;
        this.documentHelper.isDocumentProtected = false;
        this.documentHelper.restrictFormatting = false;
        this.documentHelper.protectionType = 'NoProtection';
        this.documentHelper.saltValue = '';
        this.documentHelper.hashValue = '';
        this.documentHelper.selection.highlightEditRegion();
        const restrictPane: HTMLElement = this.documentHelper.restrictEditingPane.restrictPane;
        if (restrictPane && restrictPane.style.display === 'block') {
            this.documentHelper.restrictEditingPane.showStopProtectionPane(false);
        }
        if (previousProtectionType === 'RevisionsOnly' && !this.owner.enableTrackChanges) {
            this.toggleTrackChangesProtection(false);
        }
        this.owner.trackChangesPane.enableDisableButton(true, true);
        if (!isNullOrUndefined(this.editorHistory)) {
            this.owner.editorHistoryModule.clearHistory();
        }
        this.owner.notify(protectionTypeChangeEvent, {});
        if (this.documentHelper.dialog.visible) {
            this.documentHelper.dialog.hide();
        }
        this.owner.showHideRulers();
        if (!this.documentHelper.owner.enableCollaborativeEditing) {
            this.fireContentChange();
        }
    }
    /**
     * Notify content change event
     *
     * @private
     * @returns {void}
     */
    public fireContentChange(): void {
        this.owner.documentHelper.render.commentMarkDictionary.clear();
        if (this.selection.isHighlightEditRegion) {
            if (this.owner.enableLockAndEdit) {
                this.owner.collaborativeEditingModule.updateLockRegion();
            } else {
                this.selection.onHighlight();
            }
        }
        this.selection.highlightFormFields();
        if (!this.isPaste) {
            this.copiedContent = undefined;
            this.copiedTextContent = '';
            this.previousSectionFormat = undefined;
            this.previousParaFormat = undefined;
            this.previousCharFormat = undefined;
            this.selection.isViewPasteOptions = false;
            if (this.isPasteListUpdated) {
                this.isPasteListUpdated = false;
            }
            this.selection.showHidePasteOptions(undefined, undefined);
        }
        if (this.documentHelper.owner.isLayoutEnabled && !this.documentHelper.owner.editorModule.isUserInsert && !this.documentHelper.owner.isShiftingEnabled && !this.isSkipOperationsBuild && !this.isRemoteAction) {
            this.documentHelper.owner.fireContentChange();
        }
        if (!isNullOrUndefined(this.owner.optionsPaneModule) && this.owner.optionsPaneModule.isOptionsPaneShow
            && !this.owner.optionsPaneModule.isUpdateHeading && this.selection.paragraphFormat.outlineLevel !== 'BodyText' && this.owner.optionsPaneModule.isHeadingTab) {
            this.owner.optionsPaneModule.updateHeadingTab();
        }
        if (this.owner.isSpellCheck && !isNullOrUndefined(this.selection.editPosition)) {
            this.triggerPageSpellCheck = false;
        }
    }
    /**
     * Update physical location for text position
     *
     * @param {boolean} isSelectionChanged - Specifies the selection change
     * @private
     * @returns {void}
     */
    public updateSelectionTextPosition(isSelectionChanged: boolean): void {
        this.getOffsetValue(this.selection);
        this.selection.start.updatePhysicalPosition(true);
        if (this.selection.isEmpty) {
            this.selection.end.setPositionInternal(this.selection.start);
        } else {
            this.selection.end.updatePhysicalPosition(true);
        }
        this.selection.upDownSelectionLength = this.selection.end.location.x;
        this.selection.fireSelectionChanged(isSelectionChanged);
    }
    /**
     * @private
     * @returns {void}
     */
    public onTextInputInternal = (): void => {
        if (Browser.isDevice) {
            const documentHelper: DocumentHelper = this.documentHelper;
            const nbsp: RegExp = new RegExp(String.fromCharCode(160), 'g');
            const lineFeed: RegExp = new RegExp(String.fromCharCode(10), 'g');
            documentHelper.prefix = documentHelper.prefix.replace(nbsp, ' ').replace(lineFeed, ' ');
            const text: string = documentHelper.editableDiv.textContent.replace(nbsp, ' ').replace(lineFeed, ' ');
            const textBoxText: string = text.substring(2);
            if (documentHelper.isCompositionStart && documentHelper.isCompositionUpdated) {
                documentHelper.isCompositionUpdated = false;
                if (!documentHelper.owner.isReadOnlyMode && documentHelper.owner.isDocumentLoaded && this.canEditContentControl) {
                    if (documentHelper.prefix.substring(2) !== textBoxText) {
                        if (this.selection.isEmpty) {
                            /* eslint-disable-next-line max-len */
                            this.selection.start.setPositionForLineWidget(documentHelper.selection.start.currentWidget, this.selection.start.offset - (documentHelper.prefix.length - 2));
                            this.handleTextInput(textBoxText);
                            documentHelper.prefix = '@' + String.fromCharCode(160) + textBoxText;
                        } else {
                            this.handleTextInput(textBoxText);
                            documentHelper.prefix = '@' + String.fromCharCode(160) + textBoxText;
                        }
                    }
                }
                return;
            } else if (documentHelper.isCompositionStart && documentHelper.isCompositionEnd && documentHelper.suffix === '') {
                if (documentHelper.prefix.substring(2) !== textBoxText) {
                    if (this.selection.isEmpty && documentHelper.isCompositionStart) {
                        documentHelper.isCompositionStart = false;
                        /* eslint-disable-next-line max-len */
                        this.selection.start.setPositionForLineWidget(documentHelper.selection.start.currentWidget, this.selection.start.offset - documentHelper.prefix.substring(2).length);
                        this.selection.retrieveCurrentFormatProperties();
                        if (documentHelper.suffix === '' || textBoxText === '') {
                            this.handleTextInput(textBoxText);
                        }
                    } else if (!this.selection.isEmpty) {
                        documentHelper.isCompositionStart = false;
                        this.handleTextInput(textBoxText);
                    }
                } else if (textBoxText === '') {
                    documentHelper.isCompositionStart = false;
                    this.handleBackKey();
                } else if (documentHelper.prefix.substring(2) === textBoxText && documentHelper.suffix === '') {
                    documentHelper.isCompositionStart = false;
                    this.handleTextInput(' ');
                }
                documentHelper.isCompositionEnd = false;
                return;

            } else if (documentHelper.isCompositionEnd || documentHelper.isCompositionStart && !documentHelper.isCompositionUpdated) {
                if (textBoxText.length < documentHelper.prefix.length &&
                    /* eslint-disable-next-line max-len */
                    textBoxText === documentHelper.prefix.substring(2, documentHelper.prefix.length - 1) || documentHelper.editableDiv.innerText.length < 2) {
                    this.handleBackKey();
                    return;
                } else if (documentHelper.suffix !== '' &&
                    documentHelper.editableDiv.innerText[documentHelper.editableDiv.innerText.length - 1] !== String.fromCharCode(160)) {
                    documentHelper.isCompositionStart = false;
                    //When cursor is placed in between a word and chosen a word from predicted words.
                    /* eslint-disable-next-line max-len */
                    this.selection.start.setPositionForLineWidget(documentHelper.selection.start.currentWidget, this.selection.start.offset - (documentHelper.prefix.length - 2));
                    /* eslint-disable-next-line max-len */
                    this.selection.end.setPositionForLineWidget(documentHelper.selection.end.currentWidget, this.selection.end.offset + documentHelper.suffix.length);
                    //Retrieve the character format properties. Since the selection was changed manually.
                    this.selection.retrieveCurrentFormatProperties();
                    this.handleTextInput(textBoxText);
                    return;
                }
            }

            if (text !== '\r' && text !== '\b' && text !== String.fromCharCode(27) && !documentHelper.owner.isReadOnlyMode && documentHelper.isControlPressed === false && this.canEditContentControl) {
                if (text === '@' || text[0] !== '@' || text === '' || text.length < documentHelper.prefix.length &&
                    textBoxText === documentHelper.prefix.substring(2, documentHelper.prefix.length - 1)) {
                    this.handleBackKey();
                    if (documentHelper.editableDiv.innerText.length < 2) {
                        this.predictText();
                    }
                } else if (text.indexOf(documentHelper.prefix) === 0 && text.length > documentHelper.prefix.length) {
                    this.handleTextInput(text.substring(documentHelper.prefix.length));
                } else if (text.indexOf(documentHelper.prefix) === -1 && text[text.length - 1] !== String.fromCharCode(160)
                    && text[text.length - 1] !== ' ') {
                    if ((textBoxText.charAt(0).toLowerCase() + textBoxText.slice(1)) === documentHelper.prefix.substring(2)) {
                        /* eslint-disable-next-line max-len */
                        this.selection.start.setPositionParagraph(documentHelper.selection.start.currentWidget, this.selection.start.offset - (documentHelper.prefix.length - 2));
                    }
                    this.handleTextInput(textBoxText);
                } else if (text.length !== 2) {
                    this.handleTextInput(' ');
                }
            }
        } else {
            const text: string = this.documentHelper.editableDiv.innerText;
            if (text !== String.fromCharCode(160)) {

                if (text !== '\r' && text !== '\b' && text !== String.fromCharCode(27) && !this.owner.isReadOnlyMode && this.documentHelper.isControlPressed === false && this.canEditContentControl) {
                    this.handleTextInput(text);
                }
            } else {
                this.handleTextInput(' ');
            }
            this.documentHelper.editableDiv.innerText = '';
        }
    };
    /**
     * Predict text
     *
     * @private
     * @returns {void}
     */
    public predictText(): void {
        this.documentHelper.suffix = '';
        if (this.selection.start.paragraph.isEmpty() || this.selection.start.offset === 0 &&
            this.selection.start.currentWidget.isFirstLine() || this.selection.end.offset === 0 &&
            this.selection.end.currentWidget.isFirstLine()) {
            this.documentHelper.prefix = '';
        } else {
            this.getPrefixAndSuffix();
        }
        this.documentHelper.prefix = '@' + String.fromCharCode(160) + this.documentHelper.prefix; // &nbsp;
        this.documentHelper.editableDiv.innerText = this.documentHelper.prefix;
        this.documentHelper.selection.setEditableDivCaretPosition(this.documentHelper.prefix.length);
    }

    /* eslint-disable  */
    private getPrefixAndSuffix(): void {
        //let viewer: LayoutViewer = this.owner.viewer;
        let editor: DocumentEditor = this.owner;
        let documentHelper: DocumentHelper = editor.documentHelper;
        if (this.selection.text !== '') {
            documentHelper.prefix = '';
            return;
        } else {
            let startIndex: number = 0;
            let inlineInfo: ElementInfo = this.selection.start.currentWidget.getInline(this.selection.start.offset, startIndex);
            let inline: ElementBox = inlineInfo.element;
            startIndex = inlineInfo.index;
            if (inline !== undefined) {
                let boxInfo: ElementInfo = this.selection.getElementBoxInternal(inline, startIndex);
                let box: ElementBox = boxInfo.element;
                startIndex = boxInfo.index;
                let spaceIndex: number = 0;
                if (!isNullOrUndefined(box)) {
                    let prefixAdded: Boolean = false;
                    if (box instanceof TextElementBox && startIndex > 0) {
                        documentHelper.prefix = '';
                    }
                    if (!(inline instanceof TextElementBox)) {
                        inline = this.selection.getPreviousTextElement(inline);
                    }
                    /* eslint-disable no-cond-assign */
                    while ((spaceIndex = documentHelper.prefix.lastIndexOf(' ')) < 0 && inline instanceof TextElementBox) {
                        if (inline.previousNode instanceof TextElementBox && documentHelper.prefix.indexOf(' ') === -1) {
                            if (!prefixAdded) {
                                documentHelper.prefix = inline.text.substring(0, startIndex);
                                prefixAdded = true;
                            } else {
                                documentHelper.prefix = inline.text + documentHelper.prefix;
                            }
                            inline = inline.previousNode as TextElementBox;
                            // If the line has no elements then break the loop to avoid the exception.
                            if (inline instanceof ListTextElementBox) {
                                break;
                            }
                            if (!(inline instanceof TextElementBox)) {
                                inline = this.selection.getPreviousTextElement(inline);
                            }
                        } else if (!(inline.previousNode instanceof TextElementBox)) {
                            if (!prefixAdded) {
                                documentHelper.prefix = inline.text.substring(0, startIndex);
                                prefixAdded = true;
                            } else {
                                documentHelper.prefix = inline.text + documentHelper.prefix;
                            }
                            break;
                        }
                    }
                    if (!(documentHelper.prefix.length > 1 && documentHelper.prefix[documentHelper.prefix.length - 1] === ' ' &&
                        documentHelper.prefix[documentHelper.prefix.length - 2] === '.')) {
                        spaceIndex = documentHelper.prefix.lastIndexOf(' ');
                    } else {
                        spaceIndex = -1;
                        documentHelper.prefix = '';
                    }
                    documentHelper.prefix = spaceIndex < 0 ? documentHelper.prefix : documentHelper.prefix.substring(spaceIndex);
                    if (documentHelper.prefix.indexOf(' ') === 0 && documentHelper.prefix.length >= 1) {
                        documentHelper.prefix = documentHelper.prefix.substring(1);
                    }
                    // suffix text prediction
                    let endIndex: number = 0;
                    let endInlineInfo: ElementInfo = this.selection.end.currentWidget.getInline(this.selection.end.offset, endIndex);
                    let endInline: ElementBox = endInlineInfo.element;
                    endIndex = endInlineInfo.index;
                    boxInfo = this.selection.getElementBoxInternal(endInline, endIndex);
                    box = boxInfo.element;
                    endIndex = boxInfo.index;
                    if (box) {
                        let suffixAdded: boolean = false;
                        if (box instanceof TextElementBox && endIndex < (box as TextElementBox).length) {
                            documentHelper.suffix = '';
                        }
                        // boxIndex = renderedElements.get(endInline).indexOf(box);
                        while ((spaceIndex = documentHelper.suffix.indexOf(' ')) < 0 && endInline instanceof TextElementBox) {
                            if (endInline.nextNode instanceof TextElementBox && documentHelper.suffix.indexOf(' ') === -1) {
                                if (!suffixAdded) {
                                    documentHelper.suffix = (box as TextElementBox).text.substring(endIndex);
                                    suffixAdded = true;
                                } else {
                                    documentHelper.suffix = documentHelper.suffix + endInline.text;
                                }
                                endInline = endInline.nextNode as TextElementBox;
                            } else if (!(endInline.nextNode instanceof TextElementBox)) {
                                if (!suffixAdded) {
                                    documentHelper.suffix = (box as TextElementBox).text.substring(endIndex);
                                    suffixAdded = true;
                                } else {
                                    documentHelper.suffix = documentHelper.suffix + endInline.text;
                                }
                                break;
                            }
                        }
                        spaceIndex = documentHelper.suffix.indexOf(' ');
                        documentHelper.suffix = spaceIndex < 0 ? documentHelper.suffix : documentHelper.suffix.substring(0, spaceIndex);
                    }
                }
            }
        }
    }
    /**
     * Fired on paste.
     *
     * @param {ClipboardEvent} event - Specfies clipboard event
     * @private
     * @returns {void}
     */
    public onPaste = (event: ClipboardEvent): void => {
        if (!this.owner.isReadOnlyMode && this.canEditContentControl) {
            this.pasteInternal(event);
        }
        event.preventDefault();
    }
    /**
     * key action
     * @private
     * @returns {void}
     */
    /* eslint-disable  */
    public onKeyDownInternal(event: KeyboardEvent, ctrl: boolean, shift: boolean, alt: boolean): void {
        let key: number = event.which || event.keyCode;
        this.owner.focusIn();
        if (ctrl && !shift && !alt) {
            this.documentHelper.isControlPressed = true;
            switch (key) {
                case 8:
                    event.preventDefault();
                    this.handleCtrlBackKey();
                    break;
                case 46:
                    event.preventDefault();
                    this.handleCtrlDelete();
                    break;
                case 9:
                    event.preventDefault();
                    if (this.owner.acceptTab) {
                        this.selection.handleTabKey(false, false);
                    }
                    break;
                case 13:
                    event.preventDefault();
                    this.insertPageBreak();
                    break;
                case 48:
                    event.preventDefault();
                    let value: number = 0;
                    let beforeSpacing: number = this.documentHelper.selection.start.paragraph.paragraphFormat.beforeSpacing;
                    if (beforeSpacing > 12) {
                        value = 12;
                    } else if (beforeSpacing > 0 && beforeSpacing <= 12) {
                        value = 0;
                    } else if (beforeSpacing === 0) {
                        value = 12;
                    }
                    this.onApplyParagraphFormat('beforeSpacing', value, true, false);
                    break;
                case 49:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
                        this.onApplyParagraphFormat('lineSpacing', 1, false, false);
                    }
                    break;
                case 50:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
                        this.onApplyParagraphFormat('lineSpacing', 2, false, false);
                    }
                    break;
                case 53:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
                        this.onApplyParagraphFormat('lineSpacing', 1.5, false, false);
                    }
                    break;
                case 66:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
                        this.toggleBold();
                    }
                    break;
                case 68:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode && this.owner.fontDialogModule) {
                        this.owner.fontDialogModule.showFontDialog();
                    }
                    break;
                case 69:
                    if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
                        this.toggleTextAlignment('Center');
                    }
                    event.preventDefault();
                    break;
                case 72:
                    event.preventDefault();
                    if (!this.owner.isReadOnly && this.owner.optionsPaneModule) {
                        this.owner.optionsPaneModule.isReplace = true;
                        this.owner.documentEditorSettings.showNavigationPane = true;
                    }
                    break;
                case 73:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
                        this.toggleItalic();
                    }
                    break;
                case 74:
                    if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
                        this.toggleTextAlignment('Justify');
                    }
                    event.preventDefault();
                    break;
                case 75:
                    event.preventDefault();
                    if (this.owner.hyperlinkDialogModule && !this.owner.isReadOnlyMode) {
                        this.owner.hyperlinkDialogModule.show();
                    }
                    break;
                case 76:
                    if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
                        this.toggleTextAlignment('Left');
                    }
                    event.preventDefault();
                    break;
                case 77:
                    if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
                        this.owner.selectionModule.increaseIndent();
                    }
                    event.preventDefault();
                    break;
                case 78:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.openBlank();
                    }
                    break;
                case 82:
                    if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
                        this.toggleTextAlignment('Right');
                    }
                    event.preventDefault();
                    break;
                case 85:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
                        this.owner.selectionModule.toggleUnderline('Single');
                    }
                    break;
                case 88:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.editorModule.cut();
                    }
                    break;
                case 89:
                    if (this.owner.enableEditorHistory) {
                        this.editorHistory.redo();
                        event.preventDefault();
                    }
                    break;
                case 90:
                    if (this.owner.enableEditorHistory) {
                        this.editorHistory.undo();
                        event.preventDefault();
                    }
                    break;
                case 219:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
                        this.onApplyCharacterFormat('fontSize', 'decrement', true);
                    }
                    break;
                case 221:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
                        this.onApplyCharacterFormat('fontSize', 'increment', true);
                    }
                    break;
                case 187:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
                        this.toggleBaselineAlignment('Subscript');
                    }
                    break;
            }
        } else if (shift && !ctrl && !alt) {
            switch (key) {
                case 9:
                    if (this.owner.acceptTab) {
                        event.preventDefault();
                        this.selection.handleTabKey(false, true);
                    }
                    else {
                        this.documentHelper.editableDiv.blur();
                    }
                    break;
                case 13:
                    this.handleShiftEnter();
                    event.preventDefault();
                    break;
                case 114:
                    event.preventDefault();
                    this.changeCase(this.toggleChangeCase());
                    break;
            }
        } else if (shift && ctrl && !alt) {
            switch (key) {
                case 13:
                    if (!this.owner.isReadOnlyMode) {
                        event.preventDefault();
                        this.insertColumnBreak();
                    }
                    break;
                case 68:
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.selectionModule.toggleUnderline('Double');
                    }
                    break;
                case 77:
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.selectionModule.decreaseIndent();
                    }
                    event.preventDefault();
                    break;
                case 188:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyCharacterFormat('fontSize', 'decrement', true);
                    }
                    break;
                case 190:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyCharacterFormat('fontSize', 'increment', true);
                    }
                    break;
                case 187:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleBaselineAlignment('Superscript');
                    }
                    break;
                case 69:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        let eventArgs: TrackChangeEventArgs = { isTrackChangesEnabled: !this.owner.enableTrackChanges };
                        this.owner.trigger(trackChangeEvent, eventArgs);

                    }
            }
        } else if (!shift && ctrl && alt) {
            switch (key) {
                case 72:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode && this.owner.isDocumentLoaded) {
                        this.toggleHighlightColor();
                    }
                    break;
                case 70:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode && this.owner.isDocumentLoaded) {
                        this.insertFootnote();
                    }
                    break;
                case 68:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode && this.owner.isDocumentLoaded) {
                        this.insertEndnote();
                    }
                    break;
            }
        } else {
            switch (key) {
                case 8:
                    event.preventDefault();
                    this.handleBackKey();
                    break;
                case 9:
                    if (this.owner.acceptTab) {
                        event.preventDefault();
                        this.selection.handleTabKey(true, false);
                    }
                    else {
                        this.documentHelper.editableDiv.blur();
                    }
                    break;
                case 13:
                    event.preventDefault();
                    if (this.owner.isSpellCheck) {
                        this.documentHelper.triggerSpellCheck = true;
                    }
                    this.handleEnterKey();
                    if (this.owner.isSpellCheck) {
                        this.documentHelper.triggerSpellCheck = false;
                    }

                    break;
                case 27:
                    event.preventDefault();
                    if (!this.isPaste) {
                        this.copiedContent = undefined;
                        this.copiedTextContent = '';
                        this.previousParaFormat = undefined;
                        this.previousCharFormat = undefined;
                        this.previousSectionFormat = undefined;
                        this.selection.isViewPasteOptions = false;
                        if (this.isPasteListUpdated) {
                            this.isPasteListUpdated = false;
                        }
                        this.selection.showHidePasteOptions(undefined, undefined);
                    }
                    break;
                case 46:
                    this.handleDelete();
                    event.preventDefault();
                    break;
                case 32:
                    this.selection.handleSpaceBarKey();
                    break;
                case 120:
                    let textPosition: TextPosition = this.selection.getDocumentEnd();
                    textPosition.offset = (this.selection.getDocumentEnd().offset + 1);
                    if (this.selection.start.isAtSamePosition(this.selection.getDocumentStart()) &&
                        this.selection.end.isAtSamePosition(textPosition)) {
                        this.owner.updateFields();
                    } else {
                        this.selection.updateRefField();
                    }
                    break;

            }
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public handleShiftEnter(): void {
        if (!this.owner.isReadOnlyMode) {
            this.handleTextInput('\v');
        }
        this.selection.checkForCursorVisibility();
    }
    /**
     * Handles back key.
     *
     * @private
     * @returns {void}
     */
    public handleBackKey(): void {
        if (!this.owner.isReadOnlyMode && this.canEditContentControl || (this.documentHelper.protectionType === 'FormFieldsOnly' && this.canEditContentControl && !isNullOrUndefined(this.documentHelper.selection) && this.documentHelper.selection.checkContentControlLocked()) || this.selection.isInlineFormFillMode()) {
            this.owner.editorModule.onBackSpace();
        }
        this.selection.checkForCursorVisibility();
    }

    /**
     * Handles delete
     *
     * @private
     * @returns {void}
     */
    public handleDelete(): void {
        if (!this.owner.isReadOnlyMode && this.canEditContentControl || (this.documentHelper.protectionType === 'FormFieldsOnly' && this.canEditContentControl && !isNullOrUndefined(this.documentHelper.selection) && this.documentHelper.selection.checkContentControlLocked()) || this.selection.isInlineFormFillMode()) {
            this.owner.editorModule.delete();
        }
        this.selection.checkForCursorVisibility();
    }
    /**
     * Handles enter key.
     *
     * @private
     * @returns {void}
     */
    public handleEnterKey(): void {
        let contentControl : ContentControl = this.documentHelper.owner.selection.currentContentControl;
        if ((!this.owner.isReadOnlyMode && !this.documentHelper.selection.checkContentControlLocked()) || this.selection.isInlineFormFillMode() ||
            ((this.documentHelper.protectionType === 'FormFieldsOnly' || this.documentHelper.protectionType == 'NoProtection') && (contentControl.contentControlProperties.multiline && !isNullOrUndefined(this.documentHelper.selection) && this.documentHelper.selection.checkContentControlLocked()))
              || (!isNullOrUndefined(contentControl) && contentControl.contentControlProperties.type === 'RichText' && this.canEditContentControl && (contentControl.contentControlWidgetType === 'Block' || contentControl.contentControlWidgetType === 'Cell') )) {
            if (Browser.isDevice) {
                this.documentHelper.isCompositionStart = false;
            }
            this.owner.editorModule.onEnter();
        }
        this.selection.checkForCursorVisibility();
    }
    /**
     * Handles Control back key.
     *
     * @private
     * @returns {void}
     */
    public handleCtrlBackKey(): void {
        let start: TextPosition = this.selection.start;
        let end: TextPosition = this.selection.end;
        if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
            if (!this.selection.isForward) {
                start = end;
            }
            if (this.selection.isEmpty) {
                this.selection.handleControlShiftLeftKey();
                this.owner.editorModule.onBackSpace();
                /* eslint-disable max-len */
            } else if (((isNullOrUndefined(start.paragraph.previousRenderedWidget) || start.paragraph.previousRenderedWidget instanceof TableWidget)
                && start.offset === 0)) {
                return;
            } else {
                this.selection.handleLeftKey();
                this.selection.handleControlShiftLeftKey();
                this.owner.editorModule.onBackSpace();
            }
        }
    }
    /**
     * Handles Ctrl delete
     *
     * @private
     * @returns {void}
     */
    public handleCtrlDelete(): void {
        if ((!this.owner.isReadOnlyMode && this.canEditContentControl) || this.selection.isInlineFormFillMode()) {
            if (!this.selection.isEmpty) {
                this.selection.handleLeftKey();
                this.selection.handleControlShiftRightKey();
                let selectedText: string = this.selection.text;
                let checkSpace: boolean = HelperMethods.endsWith(selectedText);
                if (checkSpace) {
                    this.selection.handleShiftLeftKey();
                }
                this.owner.editorModule.delete();
            } else {
                this.selection.handleControlShiftRightKey();
                this.owner.editorModule.delete();
            }
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public handleTextInput(text: string): void {
        if (!this.owner.isReadOnlyMode && this.canEditContentControl || (this.documentHelper.protectionType === 'FormFieldsOnly' && this.canEditContentControl && !isNullOrUndefined(this.documentHelper.selection) && this.documentHelper.selection.checkContentControlLocked()) || this.selection.isInlineFormFillMode()) {
            if (this.animationTimer) {
                clearTimeout(this.animationTimer);
            }
            classList(this.selection.caret, [], ['e-de-cursor-animation']);
            this.handledTextInput = true;
            this.owner.editorModule.insertText(text);
            this.handledTextInput = false;
            /* eslint-disable @typescript-eslint/indent */
            this.animationTimer = Number(setTimeout(() => {
                if (this.animationTimer) {
                    clearTimeout(this.animationTimer);
                }
                if (this.selection && this.selection.caret) {
                    classList(this.selection.caret, ['e-de-cursor-animation'], []);
                }
            }, 600));
        }
        this.selection.checkForCursorVisibility();
    }
    /**
     * Copies to format.
     * @param {WCharacterFormat} format
     * @private
     * @returns {void}
     */
    public copyInsertFormat(format: WCharacterFormat, copy: boolean, widget?:ParagraphWidget): WCharacterFormat {
        let insertFormat: WCharacterFormat = widget ? new WCharacterFormat(widget) : new WCharacterFormat();
        let sFormat: SelectionCharacterFormat = this.selection.characterFormat;
        if (copy) {
            insertFormat.copyFormat(format);
        }
        if (!isNullOrUndefined(sFormat.bidi) && format.bidi !== sFormat.bidi) {
            insertFormat.bidi = sFormat.bidi;
        }
        if (!isNullOrUndefined(sFormat.bold) && format.bold !== sFormat.bold) {
            insertFormat.bold = sFormat.bold;
        }
        if (!isNullOrUndefined(sFormat.italic) && format.italic !== sFormat.italic) {
            insertFormat.italic = sFormat.italic;
        }
        if (sFormat.fontSize > 0 && format.fontSize !== sFormat.fontSize) {
            insertFormat.fontSize = sFormat.fontSize;
        }
        if (!isNullOrUndefined(sFormat.fontFamily) && format.fontFamily !== sFormat.fontFamily) {
            insertFormat.fontFamily = sFormat.fontFamily;
        }
        if (!isNullOrUndefined(sFormat.highlightColor) && format.highlightColor !== sFormat.highlightColor) {
            insertFormat.highlightColor = sFormat.highlightColor;
        }
        if (!isNullOrUndefined(sFormat.baselineAlignment) && format.baselineAlignment !== sFormat.baselineAlignment) {
            insertFormat.baselineAlignment = sFormat.baselineAlignment;
        }
        if (!isNullOrUndefined(sFormat.fontColor) && format.fontColor !== sFormat.fontColor) {
            insertFormat.fontColor = sFormat.fontColor;
        }
        if (!isNullOrUndefined(sFormat.underline) && format.underline !== sFormat.underline) {
            insertFormat.underline = sFormat.underline;
        }
        if (!isNullOrUndefined(sFormat.strikethrough) && format.strikethrough !== sFormat.strikethrough) {
            insertFormat.strikethrough = sFormat.strikethrough;
        }
        if (!isNullOrUndefined(sFormat.boldBidi) && format.boldBidi !== sFormat.boldBidi) {
            insertFormat.boldBidi = sFormat.boldBidi;
        }
        if (!isNullOrUndefined(sFormat.italicBidi) && format.italicBidi !== sFormat.italicBidi) {
            insertFormat.italicBidi = sFormat.italicBidi;
        }
        if (sFormat.fontSizeBidi > 0 && format.fontSizeBidi !== sFormat.fontSizeBidi) {
            insertFormat.fontSizeBidi = sFormat.fontSizeBidi;
        }
        return insertFormat;
    }
    /**
     * @private
     */
    public getResultContentControlText(element: ContentControl): string {
        let ele: ElementBox = element.nextNode;
        let text: string = '';
        while (!(ele instanceof ContentControl)) {
            if (ele instanceof TextElementBox) {
                text += ele.text;
            }
            if (isNullOrUndefined(ele)) {
                break;
            }
            if (isNullOrUndefined(ele.nextNode)) {
                if (ele.paragraph.nextRenderedWidget) {
                    ele = (ele.paragraph.nextRenderedWidget.firstChild as LineWidget).children[0];
                } else {
                    break;
                }
            } else {
                ele = ele.nextNode;
            }
        }
        return text;
    }
    public insertContentControlPlaceholder(): void {
        let contentControl: ContentControl = this.owner.selection.currentContentControl;
        if (!isNullOrUndefined(contentControl) && contentControl.nextElement instanceof ContentControl && contentControl.nextElement === contentControl.reference) {
            let span: TextElementBox = new TextElementBox();
            const locale: L10n = new L10n('documenteditor', this.owner.defaultLocale);
            locale.setLocale(this.owner.locale);
            span.text = locale.getConstant('Default Content Control Text');
            if (contentControl.contentControlProperties.type === 'ComboBox' || contentControl.contentControlProperties.type === 'DropDownList') {
                span.text = locale.getConstant('Choose an item');
            }
            if (contentControl.contentControlProperties.type === 'Date') {
                span.text = locale.getConstant('Default Date Picker');
            }
            span.characterFormat = this.owner.editor.copyInsertFormat(this.selection.start.paragraph.characterFormat, true);
            this.owner.editor.insertElementsInternal(this.owner.selectionModule.end, [span]);
            contentControl.contentControlProperties.hasPlaceHolderText = true;
        }
    }
    
    /**
     * Inserts a content control.
     * 
     * @param {ContentControlType} type - The type of content control to insert.
     * @param {string} [value] - The value for the content control, if applicable.
     * @returns {ContentControlInfo} The inserted content control information.
     * 
     * {% codeBlock src='editor-insertContentControl/index.md' %}{% endcodeBlock %}
     */
    public insertContentControl(type: ContentControlType, value?: string): ContentControlInfo;

    /**
     * Inserts a content control.
     * 
     * @param {ContentControlType} type - The type of content control to insert.
     * @param {boolean} [value] - The boolean value for the content control, if applicable.
     * @returns {ContentControlInfo} The inserted content control information.
     * 
     * {% codeBlock src='editor-insertContentControl/index.md' %}{% endcodeBlock %}
     */
    public insertContentControl(type: ContentControlType, value?: boolean): ContentControlInfo;

    /**
     * Inserts a content control.
     * 
     * @param {ContentControlType} type - The type of content control to insert.
     * @param {string} [value] - The value for the content control, if applicable.
     * @param {string[]} [items] - The items for the content control, applicable if the type is combobox or dropdownlist.
     * @returns {ContentControlInfo} The inserted content control information.
     * 
     * {% codeBlock src='editor-insertContentControl/index.md' %}{% endcodeBlock %}
     */
    public insertContentControl(type: ContentControlType, value?: string, items?: string[]): ContentControlInfo;
    /**
     * Inserts a content control with the specified content control properties.
     * 
     * @param {ContentControlInfo} info - The content control information specifying the properties of the content control to insert
     * @returns {ContentControlInfo} The inserted content control information.
     * 
     * {% codeBlock src='editor-insertContentControl/index.md' %}{% endcodeBlock %}
     */
    public insertContentControl(info: ContentControlInfo): ContentControlInfo;
    public insertContentControl(typeOrInfo: ContentControlType | ContentControlInfo, value?: string | boolean, items?: string[]): ContentControlInfo {
        if (this.selection.isPlainContentControl()) {
            return undefined;
        }
        let type: ContentControlType;
        let info: ContentControlInfo;
        if (!(typeof typeOrInfo === 'string')) {
            type = typeOrInfo.type;
            value = typeOrInfo.value;
            items = typeOrInfo.items;
            info = typeOrInfo as ContentControlInfo;
        } else {
            type = typeOrInfo;
        }
        if(isNullOrUndefined(info)){
            info = {
                title: undefined,
                tag: undefined,
                value: String(value),
                canDelete: false,
                canEdit: false,
                type: type,
                xmlString: undefined,
                xmlPath: undefined
            };
        }
        if (!isNullOrUndefined(info)) {
            if (!isNullOrUndefined(info.xmlString) && !isNullOrUndefined(info.xmlString)) {
                info = this.mapXmlStringPath(info);
                value = info.value;
                this.owner.isXmlMapCC = true;
            }
        }
        if(this.isInsertNewLineAfterContentControl()){
            this.onEnter();
        }
        switch(type) {
            case 'RichText':
                if (!isNullOrUndefined(value)) {
                    try {
                        let parsed: any = value;
                        if (typeof parsed !== 'object') {
                            parsed = JSON.parse(value as string);
                        }
                        if (parsed && typeof parsed === 'object' || 'sections' in parsed) {
                            this.applyRichText(value as string, info.title, info.tag, info.canDelete, info.canEdit);
                        }
                      } catch (e) {
                        let sfdt = {
                            "sections": [
                                {
                                    "blocks": [
                                        {
                                            "inlines": [
                                                {
                                                    "text": value as string
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        };
                        this.applyRichText(JSON.stringify(sfdt), info.title, info.tag, info.canDelete, info.canEdit);
                      }
                } else {
                    this.applyRichText();
                }
                break;
            case 'Text':
                if(!isNullOrUndefined(value)){
                    this.applyPlainText(value as string, info.title, info.tag, info.canDelete, info.canEdit);
                } else{
                    this.applyPlainText();
                }
                
                break;
            case 'Picture':
                this.applyPictureContentControl(type, value as string, info.title, info.tag, info.canDelete, info.canEdit);
                break;
            case 'ComboBox':
                this.applyComboBox('ComboBox', items, value as string, info.title, info.tag, info.canDelete, info.canEdit);
                break;
            case 'DropDownList':
                this.applyComboBox('DropDownList', items, value as string, info.title, info.tag, info.canDelete, info.canEdit);
                break;
            case 'Date':
                this.applyDatePickerContentControl(type, value as string, info.title, info.tag, info.canDelete, info.canEdit);
                break;
            case 'CheckBox':
                this.applyCheckBoxContentControl(type, String.fromCharCode(9744), value as boolean, info.title, info.tag, info.canDelete, info.canEdit);
                break;
        }
        let contentControl: ContentControl = this.selection.currentContentControl;
        if(isNullOrUndefined(contentControl)) {
            return undefined;
        }
        let contentControlInfo: ContentControlInfo = {
            title: contentControl.contentControlProperties.title,
            tag: contentControl.contentControlProperties.tag,
            value: String(value),
            canDelete: contentControl.contentControlProperties.lockContentControl,
            canEdit: contentControl.contentControlProperties.lockContents,
            type: contentControl.contentControlProperties.type,
            xmlString: info.xmlString,
            xmlPath: info.xmlPath
        };
        return contentControlInfo;
    }
    private openContentDialog(richText: boolean) {
        const locale: L10n = new L10n('documenteditor', this.owner.defaultLocale);
        locale.setLocale(this.owner.locale);
        DialogUtility.alert({
            title: locale.getConstant('Information'),
            content: richText ? locale.getConstant('Rich text Controls') : locale.getConstant('Plain text Controls'),
            showCloseIcon: true,
            closeOnEscape: true,
            animationSettings: { effect: 'Zoom' },
            position: { X: 'center', Y: 'center' }
        });
    }
    /**
     * @private
     * @returns {void}
     */
    public updatePropertiesToBlock(contentControl: ContentControl, isUpdate?: boolean): void {
        const properties = contentControl.contentControlProperties;
        if (properties.contentControlWidgetType === 'Inline') {
            return;
        }
        const startParagraph = (contentControl.line as LineWidget).paragraph;
        const endParagraph = (contentControl.reference.line as LineWidget).paragraph;
        if (properties.contentControlWidgetType === 'Cell' && startParagraph.associatedCell) {
            startParagraph.associatedCell.contentControlProperties = isUpdate ? contentControl.contentControlProperties : undefined;
        } else if (properties.contentControlWidgetType === 'Block') {
            let startBlock: BlockWidget = startParagraph.isInsideTable ? this.documentHelper.layout.getParentTable(startParagraph)
                : startParagraph;
            const endBlock: BlockWidget = endParagraph.isInsideTable ? this.documentHelper.layout.getParentTable(endParagraph)
                : endParagraph;
            while (startBlock) {
                if (!startBlock.contentControlProperties) {
                    startBlock.contentControlProperties = isUpdate ? contentControl.contentControlProperties : undefined;
                }
                startBlock = startBlock !== endBlock ? startBlock.nextRenderedWidget as BlockWidget : undefined;
            }
        }
    }
    private updateContentControlPosition(start: TextPosition, end: TextPosition): void {
        if (!this.selection.isEmpty) {
            let elementStart: ElementInfo = start.currentWidget.getInline(start.offset, 0);
            let elementEnd: ElementInfo = end.currentWidget.getInline(end.offset, 0);
            if (elementStart && elementStart.element instanceof ContentControl && elementStart.element.contentControlWidgetType === 'Block') {
                start.offset++;
            }
            if (elementEnd && elementEnd.element instanceof ContentControl && elementEnd.element.contentControlWidgetType === 'Block') {
                end.offset--;
            }
        }
    }
    private applyRichText(value?: string, title?: string, tag?: string, lock?: boolean, lockContents?: boolean): void {
        let positionStart: TextPosition;
        let positionEnd: TextPosition;
        let contentControlWidgetType: ContentControlWidgetType = 'Inline';
        if (!isNullOrUndefined(this.selection.currentContentControl) && this.selection.currentContentControl.contentControlProperties.hasPlaceHolderText) {
            if (this.editorHistory) {
                this.initComplexHistory('InsertContentControl');
            }
            this.delete();
            this.selection.selectContentControlInternal(this.selection.currentContentControl);
            positionStart = this.selection.start.clone();
            positionEnd = this.selection.end.clone();
            contentControlWidgetType = this.selection.currentContentControl.contentControlWidgetType;
        } else {
            positionStart = this.selection.isForward ? this.selection.start.clone() : this.selection.end.clone();
            positionEnd = this.selection.isForward ? this.selection.end.clone() : this.selection.start.clone();
            if (this.selection.isParagraphMarkSelected()) {
                if (positionStart.isAtSamePosition(positionEnd)) {
                    positionStart.offset -= 1;
                }
                positionEnd.offset -= 1;
            }
            if (positionStart.paragraph !== positionEnd.paragraph) {
                if (!positionStart.isAtParagraphStart) {
                    positionEnd.setPositionParagraph(positionStart.paragraph.lastChild as LineWidget, (positionStart.paragraph.lastChild as LineWidget).getEndOffset());
                } else if (positionStart.isAtParagraphStart && !positionEnd.isAtParagraphEnd) {
                    let previousParagraph: ParagraphWidget;
                    if (positionEnd.paragraph.previousRenderedWidget instanceof TableWidget) {
                        previousParagraph = this.selection.getLastBlockInLastCell(positionEnd.paragraph.previousRenderedWidget) as ParagraphWidget;
                    } else {
                        previousParagraph = positionEnd.paragraph.previousRenderedWidget as ParagraphWidget;
                    }
                    positionEnd.setPositionParagraph(previousParagraph.lastChild as LineWidget, (previousParagraph.lastChild as LineWidget).getEndOffset());
                }
            }
            this.updateContentControlPosition(positionStart, positionEnd);
            if (positionStart.isAtParagraphStart && positionEnd.isAtParagraphEnd) {
                contentControlWidgetType = 'Block';
            }
            //If the selection is in same cell, then the content control widget type is cell.
            if (positionStart.paragraph.isInsideTable && positionEnd.paragraph.isInsideTable && positionStart.paragraph.associatedCell === positionEnd.paragraph.associatedCell) {
                const cell: TableCellWidget = positionStart.paragraph.associatedCell as TableCellWidget;
                if (cell.isEmpty() || (!positionStart.isAtSamePosition(positionEnd) && this.selection.isCellSelected(cell, positionStart, positionEnd, true))) {
                    contentControlWidgetType = 'Cell';
                }
            }
            if (this.editorHistory) {
                this.initComplexHistory('InsertContentControl');
            }
        }
        const blockStartContentControl: ContentControl = new ContentControl(contentControlWidgetType);
        const blockEndContentControl: ContentControl = new ContentControl(contentControlWidgetType);
        let properties: ContentControlProperties = new ContentControlProperties(contentControlWidgetType);
        properties.color = "#00000000";
        properties.hasPlaceHolderText = positionStart.isAtSamePosition(positionEnd) ? true : false;
        properties.isTemporary = false;
        properties.lockContentControl = !isNullOrUndefined(lock) ? !lock : false;
        properties.lockContents = !isNullOrUndefined(lockContents) ? !lockContents : false;
        properties.tag = !isNullOrUndefined(tag) ? tag : undefined;
        properties.title = !isNullOrUndefined(title) ? title : undefined;
        properties.multiline = false;
        properties.type = 'RichText';
        if (this.owner.isXmlMapCC) {
            this.addXmlProperties(properties, this.owner.xPathString);
        }
        blockStartContentControl.contentControlProperties = properties;
        blockEndContentControl.contentControlProperties = blockStartContentControl.contentControlProperties;
        blockStartContentControl.type = 0;
        blockEndContentControl.type = 1;
        blockStartContentControl.reference = blockEndContentControl;
        blockEndContentControl.reference = blockStartContentControl;
        if (properties.hasPlaceHolderText) {
            let span: TextElementBox = new TextElementBox();
            const locale: L10n = new L10n('documenteditor', this.owner.defaultLocale);
            locale.setLocale(this.owner.locale);
            span.text = locale.getConstant('Default Content Control Text');
            span.characterFormat = this.copyInsertFormat(this.selection.start.paragraph.characterFormat, true);

            const paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(positionStart);
            this.insertElementsInternal(positionStart, [blockEndContentControl]);
            let lineInfo: LineInfo = this.selection.getLineInfoBasedOnParagraph(paragraphInfo.paragraph, paragraphInfo.offset);
            positionStart.setPositionFromLine(lineInfo.line, lineInfo.offset);
            this.insertElementsInternal(positionStart, [span]);
            lineInfo = this.selection.getLineInfoBasedOnParagraph(paragraphInfo.paragraph, paragraphInfo.offset);
            positionStart.setPositionFromLine(lineInfo.line, lineInfo.offset);
            this.insertElementsInternal(positionStart, [blockStartContentControl]);
        }
        else {
            this.insertElementsInternal(positionEnd, [blockEndContentControl]);
            this.insertElementsInternal(positionStart, [blockStartContentControl]);
        }
        if (!isNullOrUndefined(value)) {
            this.documentHelper.selection.selectContentControlInternal(blockStartContentControl);
            this.paste(value);
            properties.hasPlaceHolderText = false;
        }
        this.updatePropertiesToBlock(blockStartContentControl, true);
        if (properties.hasPlaceHolderText) {
            this.selection.selectPlaceHolderText(blockStartContentControl);
        } else {
            this.selection.selectContentControlInternal(blockStartContentControl);
        }
        this.selection.contentControleditRegionHighlighters.clear();
        this.selection.onHighlightContentControl();
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistory();
        }
        if (this.documentHelper.owner.enableHeaderAndFooter) {
            this.updateHeaderFooterWidget();
        }
        this.documentHelper.viewer.updateScrollBars();

    }
    private isInsertNewLineAfterContentControl(): boolean {
        if (isNullOrUndefined(this.selection.currentContentControl) && this.selection.isEmpty) {
            const inline = this.selection.start.currentWidget.getInline(this.selection.start.offset, 0);
            const element = inline.element;
            if (element instanceof ContentControl && element.type == 1 && element.contentControlWidgetType === 'Block' && element.reference && element.paragraph !== element.reference.paragraph) {
                return true;
            }
        }
        return false;
    }
    private isInvalidElementPresent(positionStart: TextPosition, positionEnd: TextPosition): boolean {
        let startElement: ElementInfo = this.selection.getElementInfo(positionStart.currentWidget, positionStart.offset + 1);
        let endElement: ElementInfo = this.selection.getElementInfo(positionEnd.currentWidget, positionEnd.offset);
        for (let i: number = positionStart.currentWidget.indexInOwner; i < positionEnd.currentWidget.indexInOwner + 1; i++) {
            let line: LineWidget = positionStart.currentWidget.paragraph.childWidgets[i] as LineWidget;
            for (let j: number = startElement.element.indexInOwner; j < line.children.length; j++) {
                let currentElement: ElementBox = line.children[j];
                if (!(currentElement instanceof TextElementBox)) {
                    return true;
                }
                if (endElement.element == currentElement) {
                    return false;
                }
            }
        }
        return false;
    }
    private applyPlainText(value?: string, title?: string, tag?: string, lock?: boolean, lockContents?: boolean): void {
        let contentControl: ContentControl = this.selection.currentContentControl;
        if (isNullOrUndefined(contentControl) || contentControl.contentControlProperties.type === 'RichText') {
            let positionStart: TextPosition = this.selection.isForward ? this.selection.start.clone() : this.selection.end.clone();
            let positionEnd: TextPosition = this.selection.isForward ? this.selection.end.clone() : this.selection.start.clone();
            if (this.selection.isParagraphMarkSelected()) {
                if (positionStart.isAtSamePosition(positionEnd)) {
                    positionStart.offset -= 1;
                }
                positionEnd.offset -= 1;
            }
            if (positionStart.paragraph !== positionEnd.paragraph) {
                positionEnd.setPositionParagraph(positionStart.paragraph.lastChild as LineWidget, (positionStart.paragraph.lastChild as LineWidget).getEndOffset());
            }
            let contentControlWidgetType: ContentControlWidgetType = 'Inline';
            if (positionStart.isAtParagraphStart && positionEnd.isAtParagraphEnd) {
                contentControlWidgetType = 'Block';
            }
            let isEmpty: boolean = positionStart.isAtSamePosition(positionEnd);
            if (!isEmpty && this.isInvalidElementPresent(positionStart, positionEnd)) {
                this.openContentDialog(false);
                return;
            }
            //If the selection is in same cell, then the content control widget type is cell.
            if (positionStart.paragraph.isInsideTable && positionEnd.paragraph.isInsideTable && positionStart.paragraph.associatedCell === positionEnd.paragraph.associatedCell) {
                const cell: TableCellWidget = positionStart.paragraph.associatedCell as TableCellWidget;
                if (cell.isEmpty() || (!isEmpty && this.selection.isCellSelected(cell, positionStart, positionEnd, true))) {
                    contentControlWidgetType = 'Cell';
                }
            }
            const blockStartContentControl: ContentControl = new ContentControl(contentControlWidgetType);
            const blockEndContentControl: ContentControl = new ContentControl(contentControlWidgetType);
            let properties: ContentControlProperties = new ContentControlProperties(contentControlWidgetType);
            properties.color = "#00000000";
            isEmpty ? properties.hasPlaceHolderText = true : properties.hasPlaceHolderText = false;
            properties.isTemporary = false;
            properties.lockContentControl = !isNullOrUndefined(lock) ? !lock : false;
            properties.lockContents = !isNullOrUndefined(lockContents) ? !lockContents : false;
            properties.tag = !isNullOrUndefined(tag) ? tag : undefined;
            properties.title = !isNullOrUndefined(title) ? title : undefined;
            properties.multiline = false;
            properties.type = 'Text';
            if (this.owner.isXmlMapCC) {
                this.addXmlProperties(properties, this.owner.xPathString);
            }
            blockStartContentControl.contentControlProperties = properties;
            blockEndContentControl.contentControlProperties = blockStartContentControl.contentControlProperties;
            blockStartContentControl.type = 0;
            blockEndContentControl.type = 1;
            blockStartContentControl.reference = blockEndContentControl;
            blockEndContentControl.reference = blockStartContentControl;
            if (this.editorHistory) {
                this.initComplexHistory('InsertContentControl');
            }
            if (properties.hasPlaceHolderText) {
                let span: TextElementBox = new TextElementBox();
                if (!isNullOrUndefined(value)) {
                    span.text = value;
                    properties.hasPlaceHolderText = false;
                } else {
                    const locale: L10n = new L10n('documenteditor', this.owner.defaultLocale);
                    locale.setLocale(this.owner.locale);
                    span.text = locale.getConstant('Default Content Control Text');
                }
                span.characterFormat = this.copyInsertFormat(this.selection.start.paragraph.characterFormat, true);

                const paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(positionStart);
                this.insertElementsInternal(positionStart, [blockEndContentControl]);
                let lineInfo: LineInfo = this.selection.getLineInfoBasedOnParagraph(paragraphInfo.paragraph, paragraphInfo.offset);
                positionStart.setPositionFromLine(lineInfo.line, lineInfo.offset);
                this.insertElementsInternal(positionStart, [span]);
                lineInfo = this.selection.getLineInfoBasedOnParagraph(paragraphInfo.paragraph, paragraphInfo.offset);
                positionStart.setPositionFromLine(lineInfo.line, lineInfo.offset);
                this.insertElementsInternal(positionStart, [blockStartContentControl]);
            }
            else {
                this.insertElementsInternal(positionEnd, [blockEndContentControl]);
                this.insertElementsInternal(positionStart, [blockStartContentControl]);
                this.documentHelper.selection.selectContentControlInternal(blockStartContentControl);
                if (!isNullOrUndefined(value)) {
                    this.insertText(value);
                }
            }
            this.updatePropertiesToBlock(blockStartContentControl, true);
            if (properties.hasPlaceHolderText) {
                this.selection.selectPlaceHolderText(blockStartContentControl);
            } else {
                this.selection.selectContentControlInternal(blockStartContentControl);
            }
            if (this.editorHistory) {
                this.editorHistory.updateComplexHistory();
            }
            if (this.documentHelper.owner.enableHeaderAndFooter) {
                this.updateHeaderFooterWidget();
            }
            this.documentHelper.viewer.updateScrollBars();
        }
    }
    private applyComboBox(type:ContentControlType, items?: string[], value?: string, title?: string, tag?: string, lock?: boolean, lockContents?: boolean):void{
        let contentControl: ContentControl = this.selection.currentContentControl;
        if(isNullOrUndefined(contentControl) || contentControl.contentControlProperties.type === 'RichText'){
            const blockStartContentControl: ContentControl = new ContentControl('Inline');
            const blockEndContentControl: ContentControl = new ContentControl('Inline');
            let properties:ContentControlProperties=new ContentControlProperties('Inline');
            properties.color="#00000000";
            properties.type=type;
            properties.tag = !isNullOrUndefined(tag) ? tag : undefined;
            properties.title = !isNullOrUndefined(title) ? title : undefined;
            this.selection.isEmpty ?  properties.hasPlaceHolderText = true :  properties.hasPlaceHolderText = false ;
            properties.isTemporary=false;
            properties.lockContentControl = !isNullOrUndefined(lock) ? lock : false;
            properties.lockContents = !isNullOrUndefined(lockContents) ? lockContents : false;
            properties.multiline = false;
            let list: ContentControlListItems[] = [];
            if (!isNullOrUndefined(items)) {
                for (let i = 0; i < items.length; i++) {
                    let span: ContentControlListItems = new ContentControlListItems();
                    span.displayText = items[i];
                    span.value = items[i];
                    list.push(span);
                }
            } else {
                let span: ContentControlListItems = new ContentControlListItems();
                const localeValue: L10n = new L10n('documenteditor', this.owner.defaultLocale);
                span.displayText = localeValue.getConstant('Choose an item');
                span.value = localeValue.getConstant('Choose an item');
                list.push(span);
            }
            properties.contentControlListItems = list;
            //properties.appearance='Bounding Box';
            properties.contentControlWidgetType='Inline';
            if (this.owner.isXmlMapCC) {
                this.addXmlProperties(properties, this.owner.xPathString);
            }
            blockStartContentControl.contentControlProperties=properties;
            blockEndContentControl.contentControlProperties = blockStartContentControl.contentControlProperties;
            blockStartContentControl.type = 0;
            blockEndContentControl.type = 1;
            blockStartContentControl.reference = blockEndContentControl;
            blockEndContentControl.reference = blockStartContentControl;
            if (this.editorHistory) {
                this.initComplexHistory('InsertContentControl');
            }
            let positionStart : TextPosition = this.selection.isForward ? this.selection.start.clone() : this.selection.end.clone();
            let positionEnd : TextPosition = this.selection.isForward ? this.selection.end.clone() : this.selection.start.clone();
            if (positionEnd.paragraph !== positionStart.paragraph ){
                positionEnd = new TextPosition(this.owner);
                positionEnd.setPositionParagraph(positionStart.paragraph.lastChild as LineWidget, (positionStart.paragraph.lastChild as LineWidget).getEndOffset());
            }
            if(properties.hasPlaceHolderText){
                let span: TextElementBox = new TextElementBox();
                const localeValue: L10n = new L10n('documenteditor', this.owner.defaultLocale);
                span.text = localeValue.getConstant('Choose an item');
                span.characterFormat = this.copyInsertFormat(this.selection.start.paragraph.characterFormat,true);
                
                const paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(positionStart);
                this.insertElementsInternal(positionStart, [blockEndContentControl]);
                let lineInfo: LineInfo = this.selection.getLineInfoBasedOnParagraph(paragraphInfo.paragraph, paragraphInfo.offset);
                positionStart.setPositionFromLine(lineInfo.line, lineInfo.offset);
                this.insertElementsInternal(positionStart, [span]);
                lineInfo = this.selection.getLineInfoBasedOnParagraph(paragraphInfo.paragraph, paragraphInfo.offset);
                positionStart.setPositionFromLine(lineInfo.line, lineInfo.offset);
                this.insertElementsInternal(positionStart, [blockStartContentControl]);
            }
            else{
                this.insertElementsInternal(positionEnd,[blockEndContentControl]);
                this.insertElementsInternal(positionStart,[blockStartContentControl]);
            }
            let inlineInfo: ElementInfo = this.selection.start.currentWidget.getInline(this.selection.start.offset-1, 0);
            let inline: ElementBox = inlineInfo.element;
            inline.contentControlProperties = properties;
            if (!isNullOrUndefined(items)) {
                this.dropDownChange(blockStartContentControl, value);
            } else {
                this.selection.selectContentControlInternal(blockStartContentControl);
            }
            if (this.editorHistory) {
                this.editorHistory.updateComplexHistory();
            }
            if (this.documentHelper.owner.enableHeaderAndFooter) {
                this.updateHeaderFooterWidget();
            }
            this.documentHelper.viewer.updateScrollBars();
        }
        
    }
    private applyDatePickerContentControl(type:ContentControlType, value?:string, title?: string, tag?: string, lock?: boolean, lockContents?: boolean):void{
        this.dateValue = value;
        let contentControl: ContentControl = this.selection.currentContentControl;
        if(isNullOrUndefined(contentControl) || contentControl.contentControlProperties.type === 'RichText'){
            const blockStartContentControl: ContentControl = new ContentControl('Inline');
            const blockEndContentControl: ContentControl = new ContentControl('Inline');
            //blockStartContentControl.contentControlProperties.lockContents=true;
            let properties:ContentControlProperties=new ContentControlProperties('Inline');
            properties.color="#00000000";
            this.selection.isEmpty ?  properties.hasPlaceHolderText = true :  properties.hasPlaceHolderText = false ;
            properties.isTemporary=false;
            properties.lockContentControl = !isNullOrUndefined(lock) ? !lock : false;
            properties.lockContents = !isNullOrUndefined(lockContents) ? !lockContents : false;
            properties.tag = !isNullOrUndefined(tag) ? tag : undefined;
            properties.title = !isNullOrUndefined(title) ? title : undefined;
            properties.multiline=false;
            properties.type=type;
            //properties.appearance='Bounding Box';
            properties.contentControlWidgetType = 'Inline';
            if (this.owner.isXmlMapCC) {
                this.addXmlProperties(properties, this.owner.xPathString);
            }
            blockStartContentControl.contentControlProperties=properties;
            blockEndContentControl.contentControlProperties = blockStartContentControl.contentControlProperties;
            blockStartContentControl.type = 0;
            blockEndContentControl.type = 1;
            blockStartContentControl.reference = blockEndContentControl;
            blockEndContentControl.reference = blockStartContentControl;
            if (this.editorHistory) {
                this.initComplexHistory('InsertContentControl');
            }
            let positionStart : TextPosition = this.selection.isForward ? this.selection.start.clone() : this.selection.end.clone();
            let positionEnd : TextPosition = this.selection.isForward ? this.selection.end.clone() : this.selection.start.clone();
            if (positionEnd.paragraph !== positionStart.paragraph ){
                positionEnd = new TextPosition(this.owner);
                positionEnd.setPositionParagraph(positionStart.paragraph.lastChild as LineWidget, (positionStart.paragraph.lastChild as LineWidget).getEndOffset());
            }
            if(properties.hasPlaceHolderText){
                let span: TextElementBox = new TextElementBox();
                if (value) {
                    span.text = value;
                } else {
                    const locale: L10n = new L10n('documenteditor', this.owner.defaultLocale);
                    locale.setLocale(this.owner.locale);
                    span.text = locale.getConstant('Default Date Picker');
                }
                span.characterFormat = this.copyInsertFormat(this.selection.start.paragraph.characterFormat,true);
                
                const paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(positionStart);
                this.insertElementsInternal(positionStart, [blockEndContentControl]);
                let lineInfo: LineInfo = this.selection.getLineInfoBasedOnParagraph(paragraphInfo.paragraph, paragraphInfo.offset);
                positionStart.setPositionFromLine(lineInfo.line, lineInfo.offset);
                this.insertElementsInternal(positionStart, [span]);
                lineInfo = this.selection.getLineInfoBasedOnParagraph(paragraphInfo.paragraph, paragraphInfo.offset);
                positionStart.setPositionFromLine(lineInfo.line, lineInfo.offset);
                this.insertElementsInternal(positionStart, [blockStartContentControl]);
            }
            else{
                this.insertElementsInternal(positionEnd,[blockEndContentControl]);
                this.insertElementsInternal(positionStart,[blockStartContentControl]);
            }
            let inlineInfo: ElementInfo = this.selection.start.currentWidget.getInline(this.selection.start.offset-1, 0);
            let inline: ElementBox = inlineInfo.element;
            inline.contentControlProperties = properties;
            this.selection.selectContentControlInternal(blockStartContentControl);
            if (this.editorHistory) {
                this.editorHistory.updateComplexHistory();
            }
            if (this.documentHelper.owner.enableHeaderAndFooter) {
                this.updateHeaderFooterWidget();
            }
            this.documentHelper.viewer.updateScrollBars();
        }
        
    }
    private applyCheckBoxContentControl(type: ContentControlType, value: string, inputValue?: boolean, title?: string, tag?: string, lock?: boolean, lockContents?: boolean):void{
        let contentControl: ContentControl = this.selection.currentContentControl;
        if(isNullOrUndefined(contentControl) || contentControl.contentControlProperties.type === 'RichText'){
            const blockStartContentControl: ContentControl = new ContentControl('Inline');
            const blockEndContentControl: ContentControl = new ContentControl('Inline');
            //blockStartContentControl.contentControlProperties.lockContents=true;
            let properties:ContentControlProperties=new ContentControlProperties('Inline');
            properties.color="#00000000";
            properties.hasPlaceHolderText=false;
            properties.isTemporary=false;
            properties.lockContentControl = !isNullOrUndefined(lock) ? lock : false;
            properties.lockContents = !isNullOrUndefined(lockContents) ? lockContents : false;
            properties.multiline=false;
            properties.type=type;
            properties.tag = !isNullOrUndefined(tag) ? tag : undefined;
            properties.title = !isNullOrUndefined(title) ? title : undefined;
            if (!isNullOrUndefined(inputValue)) {
                properties.isChecked = inputValue;
            } else {
                properties.isChecked = false;
            }
            properties.uncheckedState = new CheckBoxState();
            properties.uncheckedState.font = this.selection.characterFormat.fontFamily;
            properties.uncheckedState.value = String.fromCharCode(9744);
            properties.checkedState = new CheckBoxState();
            properties.checkedState.font = this.selection.characterFormat.fontFamily;
            properties.checkedState.value = String.fromCharCode(9746);
            properties.contentControlWidgetType='Inline';
            if (this.owner.isXmlMapCC) {
                this.addXmlProperties(properties, this.owner.xPathString);
            }
            blockStartContentControl.contentControlProperties=properties;
            blockEndContentControl.contentControlProperties = blockStartContentControl.contentControlProperties;
            blockStartContentControl.type = 0;
            blockEndContentControl.type = 1;
            blockStartContentControl.reference = blockEndContentControl;
            blockEndContentControl.reference = blockStartContentControl;
            if (this.editorHistory) {
                this.initComplexHistory('InsertContentControl');
            }
            let positionStart : TextPosition = this.selection.isForward ? this.selection.start.clone() : this.selection.end.clone();
            let positionEnd : TextPosition = this.selection.isForward ? this.selection.end.clone() : this.selection.start.clone();
            if (positionEnd.paragraph !== positionStart.paragraph ){
                positionEnd = new TextPosition(this.owner);
                positionEnd.setPositionParagraph(positionStart.paragraph.lastChild as LineWidget, (positionStart.paragraph.lastChild as LineWidget).getEndOffset());
            }
            if (this.selection) {
                let span: TextElementBox = new TextElementBox();
                span.text = value;
                span.characterFormat = this.copyInsertFormat(this.selection.start.paragraph.characterFormat, true);
                
                const paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(positionStart);
                this.insertElementsInternal(positionStart, [blockEndContentControl]);
                let lineInfo: LineInfo = this.selection.getLineInfoBasedOnParagraph(paragraphInfo.paragraph, paragraphInfo.offset);
                positionStart.setPositionFromLine(lineInfo.line, lineInfo.offset);
                this.insertElementsInternal(positionStart, [span]);
                lineInfo = this.selection.getLineInfoBasedOnParagraph(paragraphInfo.paragraph, paragraphInfo.offset);
                positionStart.setPositionFromLine(lineInfo.line, lineInfo.offset);
                this.insertElementsInternal(positionStart, [blockStartContentControl]);
            }
            this.selection.selectContentControlInternal(blockStartContentControl);
            if (this.editorHistory) {
                this.editorHistory.updateComplexHistory();
            }
            if (this.documentHelper.owner.enableHeaderAndFooter) {
                this.updateHeaderFooterWidget();
            }
            this.documentHelper.viewer.updateScrollBars();
        }
        
    }
    /**
    * Apply the content Control properties to the picture content Control
    * @param {type} refers the type of Content control.
    */
    private applyPictureContentControl(type: ContentControlType, value?: string, title?: string, tag?: string, lock?: boolean, lockContents?: boolean): void {
        let contentControl: ContentControl = this.selection.currentContentControl;
        if (isNullOrUndefined(contentControl) || contentControl.contentControlProperties.type === 'RichText') {
            const blockStartContentControl: ContentControl = new ContentControl('Inline');
            const blockEndContentControl: ContentControl = new ContentControl('Inline');
            //blockStartContentControl.contentControlProperties.lockContents=true;
            let properties: ContentControlProperties = new ContentControlProperties('Inline');
            properties.color = "#00000000";
            properties.hasPlaceHolderText = false;
            properties.isTemporary = false;
            properties.lockContentControl = !isNullOrUndefined(lock) ? lock : false;
            properties.lockContents = !isNullOrUndefined(lockContents) ? lockContents : false;
            properties.multiline = false;
            properties.type = type;
            properties.tag = !isNullOrUndefined(tag) ? tag : undefined;
            properties.title = !isNullOrUndefined(title) ? title : undefined;
            //properties.appearance='Bounding Box';
            properties.contentControlWidgetType = 'Inline';
            if (this.owner.isXmlMapCC) {
                this.addXmlProperties(properties, this.owner.xPathString);
            }
            blockStartContentControl.contentControlProperties = properties;
            blockEndContentControl.contentControlProperties = blockStartContentControl.contentControlProperties;
            blockStartContentControl.type = 0;
            blockEndContentControl.type = 1;
            if (this.editorHistory) {
                this.initComplexHistory('InsertContentControl');
            }
            let positionStart = this.selection.start.clone();
            let positionEnd = this.selection.end.clone();
            if (!this.selection.isForward) {
                blockStartContentControl.type = 1;
                blockEndContentControl.type = 0;
            }
            if (this.selection.start.paragraph == this.selection.end.paragraph) {
                // To Do: Need to handle first insert end and then start.
                this.insertElementsInternal(positionStart, [blockStartContentControl]);
                if (!isNullOrUndefined(value)) {
                    this.insertImageAsync(value);
                }
                this.insertElementsInternal(positionEnd, [blockEndContentControl]);
            }
            if (this.editorHistory) {
                this.editorHistory.updateComplexHistory();
            }
            if (this.documentHelper.owner.enableHeaderAndFooter) {
                this.updateHeaderFooterWidget();
            }
            this.documentHelper.viewer.updateScrollBars();
        }
    }
    /**
      * To get Prefix Mapping for XML Properties.
      * @param {ContentControlType} contentcontroltype.
      * @param {string} xmlString.
      * @private
      * @returns {void}
      */
    public getPrefixMapping(xmlString: string): void {
        // Parse the XML string
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlString, "application/xml");
        // Access the namespace URI to get prefixMappings
        this.documentHelper.owner.prefixMappings = xmlDoc.documentElement.namespaceURI;
    }
    /**
    * add xml properties to the content control properties
    * @param {ContentControlProperties} properties.
    * @param {string} xPath.
    * @private
    */
    public addXmlProperties(properties: ContentControlProperties, xPath: string) {
        properties.xmlMapping = new XmlMapping();
        properties.xmlMapping.isMapped = true;
        if (!isNullOrUndefined(this.documentHelper.owner.prefixMappings)) {
            properties.xmlMapping.prefixMapping = this.documentHelper.owner.prefixMappings;
        } else {
            properties.xmlMapping.prefixMapping = " ";
        }
        properties.xmlMapping.xPath = xPath;
        if (isNullOrUndefined(this.guid)) {
            this.guid = this.createGuid();
        }
        properties.xmlMapping.storeItemId = "{" + this.guid + "}";
        this.documentHelper.customXmlData.add(properties.xmlMapping.storeItemId, this.xmlStringValue);
    }
    /**
    * To Get XML Store id
    * @returns {string} store item Id.
    */
    private createGuid(): string {
        let dateTime: number = new Date().getTime();
        const uuid: string = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (char: string): string => {
            const randNo: number = (dateTime + Math.random() * 16) % 16 | 0;
            dateTime = Math.floor(dateTime / 16);
            return (char === 'x' ? randNo : (randNo & 0x3 | 0x8)).toString(16);
        });
        return uuid;
    }
    /**
    * To Get data from xml string and path
    * @param {ContentControlInfo} An object containing the updated details for the content control.
    * @returns {ContentControlInfo} The updated content control information after applying the changes, or `undefined` if no matching content control is found.
    */
    private mapXmlStringPath(controlInfo: ContentControlInfo): ContentControlInfo {
        this.getPrefixMapping(controlInfo.xmlString);
        const parsedXml = this.parseXml(controlInfo.xmlString);
        const arr = this.objectToArray(parsedXml);
        this.setXmlData(parsedXml, arr);
        let xmlValue = this.xmlData;
        // Split the string by the '/' character and get the last element
        const lastString = controlInfo.xmlPath.split('/').pop();
        // Split the string by the '/' character
        const segments = controlInfo.xmlPath.split('/');
        // Get the segment before the last one
        const beforeLastString = segments[segments.length - 2];
        let dataXMLValue = this.getXmlValue(beforeLastString, lastString);
        this.owner.isXmlMapCC = true;
        controlInfo.xmlPath = this.transformString(controlInfo.xmlPath);
        this.owner.xPathString = "/" + controlInfo.xmlPath;
        controlInfo.value = dataXMLValue;
        return controlInfo;
    }
    /**
     * Sets the existing content control within the editor using the provided information.
     * The content control is identified by its unique combination of `title` and `tag`.
     * @param {ContentControlInfo} An object containing the updated details for the content control.
     * @returns {ContentControlInfo|undefined} The updated content control information after applying the changes, or `undefined` if no matching content control is found.
     */
    public setContentControlInfo(info: ContentControlInfo): ContentControlInfo {
        let controlInfo: ContentControlInfo = this.documentHelper.selection.getContentControlInfo();
        if (!isNullOrUndefined(controlInfo)) {
            controlInfo.xmlString = info.xmlString;
            controlInfo.xmlPath = info.xmlPath;
            controlInfo.title = info.title;
            controlInfo.tag = info.tag;
            controlInfo.value = info.value;
            controlInfo.canDelete = info.canDelete;
            controlInfo.canEdit = info.canEdit;
            //To change the normal content control to xml mapped content control.
            let contantControlCheck: ContentControl = this.selection.currentContentControl;
            let contentControlImage: ElementBox = this.documentHelper.owner.getImageContentControl();
            if ((!isNullOrUndefined(contantControlCheck) || !isNullOrUndefined(contentControlImage)) && !isNullOrUndefined(controlInfo)) {
                if (!isNullOrUndefined(controlInfo.xmlString) && !isNullOrUndefined(controlInfo.xmlString)) {
                    controlInfo = this.mapXmlStringPath(controlInfo);
                    this.documentHelper.owner.selection.selectContentControlInternal(contantControlCheck);
                    this.insertText(controlInfo.value);
                    let propertiesInfo: ContentControl = this.getContentControl();
                    this.addXmlProperties(propertiesInfo.contentControlProperties, this.owner.xPathString);
                    this.owner.isXmlMapCC = false;
                }
                if (!isNullOrUndefined(controlInfo.tag) && controlInfo.tag !== contantControlCheck.contentControlProperties.tag)
                {
                    contantControlCheck.contentControlProperties.tag =  controlInfo.tag;
                }
                if (!isNullOrUndefined(controlInfo.title) && controlInfo.title !== contantControlCheck.contentControlProperties.title)
                {
                    contantControlCheck.contentControlProperties.title =  controlInfo.title;
                }
                if (!isNullOrUndefined(controlInfo.value) && (contantControlCheck.nextElement as TextElementBox).text !== controlInfo.value && !controlInfo.canEdit)
                {
                    this.insertText(controlInfo.value);
                }
                if (!isNullOrUndefined(controlInfo.canDelete)  && controlInfo.canDelete !== contantControlCheck.contentControlProperties.lockContentControl)
                {
                    contantControlCheck.contentControlProperties.lockContentControl =  controlInfo.canDelete;
                }
                if (!isNullOrUndefined(controlInfo.canEdit) && controlInfo.canEdit !== contantControlCheck.contentControlProperties.lockContents)
                {
                    contantControlCheck.contentControlProperties.lockContents = controlInfo.canEdit;
                }
            }
            return controlInfo;
        }
        return undefined;
    }
    /**
    * To get xpath format.
    * @param {string} inputxpath.
    * @returns {string}
    */
    private transformString(inputxpath: string): string {
        // Split the string at each '/'
        const parts = inputxpath.split('/');
        // Join the parts with '[1]/' and append '[1]' to the last part
        return parts.map(part => `${part}[1]`).join('/');
    }
    /**
    * To get Xml Value.
    * @param {string} beforeLastString.
    * @param {string} lastString.
    * @returns {string}
    */
    private getXmlValue(beforeLastString: string, lastString: string): string {
        let parentId;
        let currentId;
        let dataXMLValue;
        for (let i = 0; i < this.xmlData.length; i++) {
            if (this.xmlData[i].displayText == beforeLastString) {
                parentId = this.xmlData[i].id;
            }
            parentId = Number(parentId);
            if (!isNaN(parentId) && this.xmlData[i].displayText == lastString && this.xmlData[parentId - 1].displayText == beforeLastString) {
                currentId = this.xmlData[i].id;

                currentId = Number(currentId);
                dataXMLValue = this.xmlData[i].displayValue;
                dataXMLValue = dataXMLValue.toString();
                break;
            }
        }
        return dataXMLValue;
    }
    /**
    * To convert the object into Array.
    * @param {any} obj.
    * @private
    * @returns {Array}
    */
    public objectToArray(obj: { [key: string]: any }): { index: string, data: any }[] {
        return Object.keys(obj).map((key, index) => ({
            index: String(index + 1), // Convert index to string, and start from 1
            data: obj[key]
        }));
    }
    /**
    * To Parse the XML string into an XMLDocument To Convert the XMLDocument to JSON.
    * @param {string} xmlString.
    * @private
    * @returns {void}
    */
    public parseXml(xmlString: string) {
        this.xmlStringValue = xmlString;
        try {
            // Parse the XML string into an XMLDocument
            let parser = new DOMParser();
            let xmlDoc = parser.parseFromString(xmlString, 'text/xml');

            // Convert the XMLDocument to JSON
            let jsonData = this.xmlToJson(xmlDoc.documentElement);
            this.xmlTitle = xmlDoc.documentElement.nodeName;
            // Output the JSON data
            //console.log(jsonData);
            return jsonData;
        } catch (error) {
            console.error('Error parsing XML string:', error);
            return null;
        }
    }
    /**
    * To Convert the XMLDocument to JSON.
    * @param {Element} xml.
    * @private
    * @returns {any}
    */
    public xmlToJson(xml: Element): any {
        // Create the object that will hold the JSON representation
        let obj: any = {};
        // If the XML node has child nodes, process them
        if (xml.hasChildNodes()) {
            // Loop through each child node
            for (let i = 0; i < xml.childNodes.length; i++) {
                let item = xml.childNodes[i];
                // If the node is an element, recursively process it
                if (item.nodeType === 1) {
                    // Check if this node has siblings with the same nodeName to decide whether it should be an array or object
                    if (item.nextSibling && item.nextSibling.nodeName === item.nodeName) {
                        if (!obj[item.nodeName]) {
                            obj[item.nodeName] = [];
                        }
                        obj[item.nodeName].push(this.xmlToJson(item as Element)); // Push into an array
                    } else {
                        // If there's only one node with this name, directly assign it
                        obj[item.nodeName] = this.xmlToJson(item as Element);
                    }
                } else if (item.nodeType === 3) { // Node.TEXT_NODE
                    // Handle text content
                    let text = item.textContent.trim();
                    if (text) {
                        obj = text; // Assign text directly to the object
                    }
                }
            }
        }
        return obj;
    }
    /**
    * To set the updated xml json into xml Data for treeview.
    * @param {any} parsedXmlObj.
    * @param {any} parsedXmlArr.
    * @private
    * @returns {void}
    */
    public setXmlData(parsedXmlObj: any, parsedXmlArr: any) {
        let index = 2;
        this.xmlData = [];
        this.xmlData.push({
            id: 1,
            displayText: this.xmlTitle,
            hasChild: true,
            expanded: true,
        });
        let i = 0;
        for (const key in parsedXmlObj) {
            let open = true;
            for (i = i; i < parsedXmlArr.length; i++) {
                let arrayDatahasChild = parsedXmlArr[i].data;
                if (arrayDatahasChild instanceof Object && Object.keys(arrayDatahasChild).length > 0) {
                    open = true;
                } else {
                    open = false;
                }
                i = i + 1;
                break;
            }
            this.xmlData.push({
                id: index++,
                displayText: key,
                displayValue: parsedXmlObj[key],
                pid: '1',
                hasChild: open,
                expanded:open,
            });
            let dataAsObj = parsedXmlObj[key];
            let j = 0;
            for (j; j < parsedXmlArr.length; j++) {
                let arrayData = parsedXmlArr[j].data;
                let level = (index - 1).toString();
                if (arrayData instanceof Object) {
                    if (arrayData == dataAsObj) {
                        for (const key in arrayData) {
                            this.xmlData.push({
                                id: index++,
                                displayText: key,
                                displayValue: dataAsObj[key],
                                pid: level,
                            });
                        }
                    }
                }
            }
        }
        this.dictionaryObject[this.dictionaryObjectIndexIncrement++] = {
            ID: '(no namespace)_' + this.dictionaryObjcetIDIncreament,
            Data: this.xmlData
        };
        this.dictionaryObjcetIDIncreament++;
    }
    /**
     * @private
     * @returns {void}
     */
    public dropDownChange(contentControl: ContentControl,value:string): void {
       if(!isNullOrUndefined(contentControl)){
            this.documentHelper.selection.selectContentControlInternal(contentControl);
            this.insertTextInternal(value,true);
            if(contentControl.contentControlProperties.isTemporary){
                this.removeContentControl();
            }
       }
       return;
    }
    private updateXmlMappedContentControl(): void {
        if (this.isXmlMapped) {
            let startInlineEle: ContentControl = this.selection.currentContentControl;
            if (startInlineEle && startInlineEle.contentControlProperties && startInlineEle.contentControlProperties.xmlMapping) {
                this.updateCustomXml(startInlineEle.contentControlProperties.xmlMapping.storeItemId,
                    startInlineEle.contentControlProperties.xmlMapping.xPath, this.getResultContentControlText(startInlineEle));
            }
        }
    }
    private updateCustomXml(itemId: string, xPath: string, text: string): void {
        if (this.documentHelper.customXmlData.containsKey(itemId) && !isNullOrUndefined(xPath)) {
            let xml: string = this.documentHelper.customXmlData.get(itemId);
            let parser: DOMParser = new DOMParser();
            let xmlDoc: Document = parser.parseFromString(xml, 'text/xml');
            let lastText: string = xPath.substring(xPath.lastIndexOf('/') + 1);
            lastText = lastText.split('[')[0];
            lastText = lastText.substring(lastText.lastIndexOf(':') + 1);
            lastText = lastText.substring(lastText.lastIndexOf('@') + 1);
            let htmlCollec: HTMLCollectionOf<Element> = xmlDoc.getElementsByTagName(lastText);
            if (htmlCollec.length > 0) {
                htmlCollec[0].childNodes[0].nodeValue = text;
            } else if (xmlDoc.documentElement.attributes.length > 0 && xmlDoc.documentElement.attributes.getNamedItem(lastText) !== null) {
                xmlDoc.documentElement.attributes.getNamedItem(lastText).value = text;
            } else {
                return;
            }
            let newXml: XMLSerializer = new XMLSerializer();
            let xmlString: string = newXml.serializeToString(xmlDoc);
            this.documentHelper.customXmlData.set(itemId, xmlString);
        }
    }
    /**
     * Inserts the specified text at cursor position
     * @param {string} text Specify the text to insert.
     */
    public insertText(text: string): void {
        if (isNullOrUndefined(text) || text === ''
            || this.owner.isReadOnly
            || this.documentHelper.protectionType === 'ReadOnly' && !this.selection.isSelectionInEditRegion()
            || this.documentHelper.protectionType === 'CommentsOnly' && this.owner.isReadOnly) {
            return;
        }   
        this.isInsertingText = true;
        this.insertTextInternal(text, false);
        this.isInsertingText = false;
    }
    /**
     * @private
     * @returns {void}
     */
    /* eslint-disable  */
    public insertTextInternal(text: string, isReplace: boolean, revisionType?: RevisionType, allowLayout?: boolean): void {
        if (text.indexOf('\r') >= 0 || text.indexOf('\n') >= 0) {
            if (text === '\r' || text === '\n' || text === '\r\n') {
                this.onEnter();
            } else {
                this.isInsertText = true;
                this.pasteContents(text);
                this.isInsertText = false;
            }
            return;
        }
        if (this.documentHelper.protectionType === 'FormFieldsOnly' && this.selection.isInlineFormFillMode()) {
            let inline: FieldElementBox = this.selection.currentFormField;
            if (!inline.formFieldData.enabled) {
                return;
            }
            let resultText: string = this.getFieldResultText(inline);
            let rex: RegExp = new RegExp(this.owner.documentHelper.textHelper.getEnSpaceCharacter(), 'gi');
            if (resultText.length > 0 && resultText.replace(rex, '') === '') {
                resultText = '';
                this.selection.selectFieldInternal(inline);
            }
            let maxLength: number = (inline.formFieldData as TextFormField).maxLength;
            if (maxLength !== 0 && resultText.length >= maxLength) {
                return;
            }
        }
        if (isReplace) {
            this.documentHelper.layout.isReplaceAll = !isNullOrUndefined(allowLayout) ? !allowLayout : false;
        }
        let contentControl: ContentControl = this.documentHelper.owner.selection.currentContentControl;
        let hasPlaceHolderText: boolean = false;
        if(!isNullOrUndefined(contentControl) && contentControl.contentControlProperties.hasPlaceHolderText)
            {
                hasPlaceHolderText = contentControl.contentControlProperties.hasPlaceHolderText
                this.documentHelper.selection.selectContentControlInternal(contentControl);
                contentControl.contentControlProperties.hasPlaceHolderText = false;
            }
        let selection: Selection = this.documentHelper.selection;
        let insertPosition: TextPosition;
        let isRemoved: boolean = true;
        let isInsertPositionUpdated: boolean = false;
        revisionType = (this.owner.enableTrackChanges && isNullOrUndefined(revisionType)) ? 'Insertion' : revisionType;
        let commentStarts: CommentCharacterElementBox[] = this.checkAndRemoveComments(isReplace);
        this.isListTextSelected();
        if (this.documentHelper.isBookmarkInserted && !selection.isEmpty) {
            const selectionBookmark: string[] = selection.bookmarks;
            if (selectionBookmark.length > 0) {
                this.extendSelectionToBookmarkStart(selectionBookmark);
            }
        }
        let initComplexHistory: boolean = false;
        if (selection.isEmpty) {
            const inlineObj: ElementInfo = selection.start.currentWidget.getInline(selection.start.offset, 0);
            const element: ElementBox = inlineObj.element;
            if (element instanceof BookmarkElementBox && element.bookmarkType === 1
                && !isNullOrUndefined(element.properties) && element.properties.hasOwnProperty('isAfterParagraphMark') && element.properties['isAfterParagraphMark']) {
                selection.start.setPositionParagraph(element.line, element.line.getOffset(element, 0));
                selection.end.setPositionInternal(selection.start);
            }
            const isAtParagraphStart = selection.start.isAtParagraphStart;
            const isAtParagraphEnd = selection.end.isAtParagraphEnd;
            if (isAtParagraphStart || isAtParagraphEnd) {               
                if (element && element instanceof ContentControl && isNullOrUndefined(selection.currentContentControl) && element.contentControlWidgetType === 'Block' && element.reference &&
                    element.paragraph !== element.reference.paragraph) {
                    this.initComplexHistory('Insert');
                    initComplexHistory = true;
                    this.onEnter();
                    if (isAtParagraphStart) {
                        const previousParagraph: Widget = element.paragraph.previousWidget;
                        if (previousParagraph instanceof ParagraphWidget && previousParagraph.isEmpty()) {
                            selection.moveToPreviousParagraph();
                        }
                    }
                }
            }
        }
        if (isNullOrUndefined(revisionType) || revisionType === 'Insertion') {
            this.initHistory('Insert');
            if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                this.editorHistory.currentBaseHistoryInfo.insertedText = text;
                if (this.documentHelper.protectionType === 'FormFieldsOnly') {
                    let field: FieldElementBox = this.documentHelper.selection.getCurrentFormField();
                    if (field && field instanceof FieldElementBox && field.formFieldData && field.formFieldData instanceof DropDownFormField) {
                        this.editorHistory.currentBaseHistoryInfo.fieldBegin = field;
                        this.editorHistory.currentBaseHistoryInfo.dropDownIndex = field.formFieldData.selectedIndex;
                    }
                }
            }
        }
        let paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(selection.start);
        let paraFormat: WParagraphFormat = paragraphInfo.paragraph.paragraphFormat;
        selection.editPosition = selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
        let bidi: boolean = selection.start.paragraph.paragraphFormat.bidi;
        if ((!selection.isEmpty && !selection.isImageSelected) ||
            this.documentHelper.isListTextSelected && selection.contextType === 'List') {
            selection.isSkipLayouting = true;
            selection.skipFormatRetrieval = true;
            let endPosition: TextPosition = undefined;
            let endParagraphInfo: ParagraphInfo = undefined;
            let endOffset: number = 0;
            let paragraphLength: number = 0;
            if (this.owner.enableTrackChanges) {
                if (!this.selection.start.isExistBefore(this.selection.end)) {
                    endParagraphInfo = this.selection.getParagraphInfo(selection.start);
                    endPosition = this.selection.start.clone();
                } else {
                    endParagraphInfo = this.selection.getParagraphInfo(selection.end);
                    endPosition = this.selection.end.clone();
                }
                paragraphLength = endParagraphInfo.paragraph.getLength();
                endOffset = endParagraphInfo.offset - 1 === paragraphLength ? endParagraphInfo.offset - 1 : endParagraphInfo.offset;
                this.skipReplace = true;
            }
            
            isRemoved = this.removeSelectedContents(selection);
            if (isRemoved) {
                this.updateInsertPosition();
                isInsertPositionUpdated = true;
            }
            this.skipReplace = false;
            if (!isNullOrUndefined(endPosition) && this.owner.searchModule && this.owner.searchModule.isRepalceTracking) {
                this.owner.searchModule.isRepalceTracking = false;
                this.selection.start.setPositionInternal(this.selection.start);
                this.selection.end.setPositionInternal(endPosition);
            } else if (endOffset > 0 && endOffset <= paragraphLength) {
                let updatedParagraphLength: number = endParagraphInfo.paragraph.getLength();
                if (paragraphLength !== updatedParagraphLength) {
                    endOffset -= paragraphLength - updatedParagraphLength;
                }
                this.setPositionParagraph(endParagraphInfo.paragraph, endOffset, true);
            }
            selection.skipFormatRetrieval = false;
            selection.isSkipLayouting = false;
        } else if (selection.isEmpty && !this.documentHelper.isListTextSelected && !isReplace) {
            this.documentHelper.isTextInput = true;
        }
        paragraphInfo = this.selection.getParagraphInfo(selection.start);
        paragraphInfo.paragraph.paragraphFormat.copyFormat(paraFormat);
        let isSpecialChars: boolean = this.documentHelper.textHelper.containsSpecialCharAlone(text);
        if (isRemoved) {
            selection.owner.isShiftingEnabled = true;
            if (!isInsertPositionUpdated && (isNullOrUndefined(revisionType) || revisionType === 'Insertion')) {
                this.updateInsertPosition();
            }
            insertPosition = selection.start;
            if (insertPosition.paragraph.isEmpty()) {
                let span: TextElementBox = new TextElementBox();
                let insertFormat: WCharacterFormat = this.copyInsertFormat(insertPosition.paragraph.characterFormat, true);
                span.characterFormat.copyFormat(insertFormat);
                span.text = text;
                let isBidi: boolean = this.documentHelper.textHelper.getRtlLanguage(text).isRtl || this.selection.characterFormat.bidi;
                span.characterFormat.bidi = isBidi;
                insertFormat.bidi = isBidi;
                span.isRightToLeft = isBidi;
                span.line = (insertPosition.paragraph as ParagraphWidget).childWidgets[0] as LineWidget;
                span.margin = new Margin(0, 0, 0, 0);
                span.line.children.push(span);
                this.setCharFormatForCollaborativeEditing(span.characterFormat);
                if (this.owner.enableTrackChanges) {
                    this.insertRevision(span, revisionType);
                }
                if ((insertPosition.paragraph.paragraphFormat.textAlignment === 'Center'
                    || insertPosition.paragraph.paragraphFormat.textAlignment === 'Right'
                    || (insertPosition.paragraph.paragraphFormat.textAlignment === 'Justify' 
                    && insertPosition.paragraph.paragraphFormat.bidi)) 
                    && insertPosition.paragraph.paragraphFormat.listFormat.listId === -1) {
                    insertPosition.paragraph.x = insertPosition.paragraph.clientX;
                    insertPosition.paragraph.clientX = undefined;
                    if (insertPosition.paragraph.hasOwnProperty('absoluteXPosition')) {
                        delete insertPosition.paragraph['absoluteXPosition'];
                    }
                }
                if (span instanceof TextElementBox && span.text.length > 90) {
                    // Here, the text is split based on the maximum character length of 90.
                    HelperMethods.splitWordByMaxLength(span, span.line);
                }
                this.documentHelper.layout.reLayoutParagraph(insertPosition.paragraph, 0, 0);
            } else {
                let indexInInline: number = 0;

                let inlineObj: ElementInfo = insertPosition.currentWidget.getInline(insertPosition.offset, indexInInline, bidi, (isReplace || this.isInsertingText) ? false : true);
                let inline: ElementBox = inlineObj.element;
                indexInInline = inlineObj.index;
                inline.isChangeDetected = true;
                if (!inline.paragraph.isInsideTable && inline instanceof BookmarkElementBox && inline.bookmarkType === 1 
                    && !isNullOrUndefined(inline.properties) && inline.properties.hasOwnProperty('isAfterParagraphMark')) {
                    delete inline.properties['isAfterParagraphMark'];
                }
                if (inline instanceof TextElementBox && text !== ' ' && this.documentHelper.owner.isSpellCheck) {
                    this.owner.spellCheckerModule.removeErrorsFromCollection({ 'element': inline, 'text': (inline as TextElementBox).text });
                    if (!isReplace) {
                        (inline as TextElementBox).ignoreOnceItems = [];
                    }
                }
                if (inline.canTrigger && (inline as TextElementBox).text.length <= 1) {
                    inline.canTrigger = false;
                }
                // Todo: compare selection format
                let insertFormat: WCharacterFormat = this.copyInsertFormat(inline.characterFormat, true);
                if (insertFormat.hidden) {
                    insertFormat.hidden = false;
                }
                let isBidi: boolean = this.documentHelper.textHelper.getRtlLanguage(text).isRtl || this.selection.characterFormat.bidi;
                //let insertLangId: number = this.documentHelper.textHelper.getRtlLanguage(text).id;
                let inlineLangId: number = 0;
                let isRtl: boolean = false;
                //let isInlineContainsSpecChar: boolean = false;
                let isTextContainsSpecChar: boolean = false;
                if (inline instanceof TextElementBox) {
                    inlineLangId = this.documentHelper.textHelper.getRtlLanguage(inline.text).id;
                    isRtl = this.documentHelper.textHelper.getRtlLanguage(inline.text).isRtl;
                    isTextContainsSpecChar = this.documentHelper.textHelper.containsSpecialCharAlone(text);
                }
                if ((!isBidi && inline.characterFormat.bidi && (inlineLangId !== 0 || (isTextContainsSpecChar && isRtl)))
                    || (text === ' ' && this.selection.characterFormat.bidi)) {
                    isBidi = true;
                }
                if (isBidi || !this.documentHelper.owner.isSpellCheck) {
                    insertFormat.bidi = isBidi;
                }
                this.setCharFormatForCollaborativeEditing(insertFormat);

                if ((!this.documentHelper.owner.isSpellCheck || (text !== ' ' && (<TextElementBox>inline).text !== ' ')) && !(inline instanceof ContentControl) && !(inline instanceof CommentCharacterElementBox) && insertFormat.isSameFormat(inline.characterFormat) && inline.revisionLength <= 1 && this.canInsertRevision(inline, revisionType)
                    || (text.trim() === '' && !isBidi && inline.characterFormat.bidi) || isRtl && insertFormat.isSameFormat(inline.characterFormat) && isSpecialChars) {
                    this.insertTextInline(inline, selection, text, indexInInline, undefined, revisionType, isBidi);
                    this.setCharFormatForCollaborativeEditing(inline.characterFormat);
                } else {
                    let tempSpan: TextElementBox = new TextElementBox();
                    tempSpan.text = text;
                    tempSpan.line = inline.line;
                    tempSpan.isRightToLeft = isRtl;
                    if (!isNullOrUndefined(inline) && inline.contentControlProperties) {
                        tempSpan.contentControlProperties = inline.contentControlProperties;
                        if (hasPlaceHolderText) {
                            tempSpan.characterFormat.copyFormat(inline.characterFormat);
                        } else {
                            tempSpan.characterFormat = this.copyInsertFormat(new WCharacterFormat(), false);
                        }
                    } else {
                        tempSpan.characterFormat.copyFormat(insertFormat);
                    }
                    this.setCharFormatForCollaborativeEditing(tempSpan.characterFormat);
                    if (inline instanceof FootnoteElementBox) {
                        tempSpan.characterFormat.baselineAlignment = 'Normal';
                    }
                    let isRevisionCombined: boolean = false;
                    let insertIndex: number = inline.indexInOwner;
                    if (indexInInline === inline.length) {
                        let index: number = -1;
                        index = (inline instanceof CommentCharacterElementBox && inline.commentType == 0) ? insertIndex : insertIndex + 1;
                        if (this.owner.enableTrackChanges && !(inline instanceof BookmarkElementBox)) {
                            isRevisionCombined = this.checkToMapRevisionWithInlineText(inline, indexInInline, tempSpan, isBidi, revisionType);
                            if (!isRevisionCombined) {
                                isRevisionCombined = this.checkToMapRevisionWithNextNode(inline.nextNode, tempSpan, isBidi, revisionType);
                            }
                        }
                        inline.line.children.splice(index, 0, tempSpan);
                        if (!isRevisionCombined) {
                            this.checkToSplitRevisionInPrevNxt(tempSpan);
                            if (this.owner.enableTrackChanges) {
                                this.insertRevision(tempSpan, revisionType);
                            }
                        }
                    } else if (indexInInline === 0) {
                        if (this.owner.enableTrackChanges) {
                            isRevisionCombined = this.checkToMapRevisionWithInlineText(inline, indexInInline, tempSpan, isBidi, revisionType);
                            if (!isRevisionCombined) {
                                this.checkToMapRevisionWithPreviousNode(inline.previousNode, tempSpan, isBidi, revisionType);
                            }
                        }
                        inline.line.children.splice(insertIndex, 0, tempSpan);
                        if (!isRevisionCombined) {
                            this.checkToSplitRevisionInPrevNxt(tempSpan);
                            if (this.owner.enableTrackChanges) {
                                this.insertRevision(tempSpan, revisionType);
                            }
                        }
                    } else {
                        if (inline instanceof TextElementBox) {
                            let splittedSpan: TextElementBox = new TextElementBox();
                            splittedSpan.line = inline.line;
                            splittedSpan.characterFormat.copyFormat(inline.characterFormat);
                            if(!isNullOrUndefined(inline)  && inline.contentControlProperties){
                                splittedSpan.contentControlProperties = inline.contentControlProperties;
                            }
                            // Commented because character format is not syncing correctly.
                            // this.setCharFormatForCollaborativeEditing(splittedSpan.characterFormat);
                            splittedSpan.text = (inline as TextElementBox).text.substring(indexInInline);
                            for (let m: number = 0; m < inline.revisionLength; m++) {
                                splittedSpan.addRevision(inline.getRevision(m));
                            }
                            if (splittedSpan.text !== '') {
                                inline.line.children.splice(insertIndex + 1, 0, splittedSpan);
                            }
                            (inline as TextElementBox).text = (inline as TextElementBox).text.slice(0, indexInInline);
                            inline.isWidthUpdated = false;
                            inline.line.children.splice(insertIndex + 1, 0, tempSpan);
                            if (!this.owner.enableTrackChanges && !this.selection.isInField) {
                                this.updateRevisionForSpittedTextElement(inline, splittedSpan, tempSpan);
                            }
                            if (this.owner.enableTrackChanges) {
                                isRevisionCombined = this.checkToMapRevisionWithInlineText(inline, indexInInline, tempSpan, isBidi, revisionType);
                                if (isRevisionCombined) {
                                    this.copyElementRevision(inline, splittedSpan);
                                } else {
                                    this.updateRevisionForSpittedTextElement(inline, splittedSpan, tempSpan);
                                    this.insertRevision(tempSpan, revisionType);
                                }
                            } else if (this.selection.isInField) {
                                this.copyElementRevision(inline, splittedSpan);
                            }
                            if (this.owner.isSpellCheck) {
                                this.owner.spellCheckerModule.updateSplittedElementError(inline, splittedSpan);
                            }
                        }
                    }
                    if (tempSpan instanceof TextElementBox && tempSpan.text.length > 90) {
                        // Here, the text is split based on the maximum character length of 90.
                        HelperMethods.splitWordByMaxLength(tempSpan, tempSpan.line);
                    }
                    if (!(!isNullOrUndefined(revisionType) && revisionType === 'Deletion' && !insertPosition.paragraph.isLayouted)) {
                        this.documentHelper.layout.reLayoutParagraph(insertPosition.paragraph, inline.line.indexInOwner, 0);
                    }
                    if (inline instanceof TextElementBox && inline.line.children.indexOf(inline) !== -1 && inline.text === '') {
                        inline.line.children.splice(inline.line.children.indexOf(inline), 1);
                    }
                }
            }
            if(!isNullOrUndefined(contentControl) && contentControl.contentControlProperties.isTemporary){
                this.removeContentControl();
            }
            this.documentHelper.layout.allowLayout = true;
            this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + text.length, true);
            if (isNullOrUndefined(revisionType) || revisionType === 'Insertion') {
                this.updateEndPosition();
            }
            if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)
                && (this.editorHistory.currentHistoryInfo.action === 'ListSelect') &&
                this.documentHelper.isListTextSelected) {
                this.editorHistory.updateHistory();
                this.editorHistory.updateComplexHistory();
            }
            if ((isNullOrUndefined(revisionType) || revisionType === 'Insertion') && !this.isFieldOperation) {
                this.reLayout(selection);
            }
            if (initComplexHistory && this.editorHistory) {
                this.editorHistory.updateComplexHistory();
            }
            this.documentHelper.isTextInput = false;
        }
        this.updateXmlMappedContentControl();
        if (!isReplace && isRemoved && (text === ' ' || text === '\t' || text === '\v')) {
            let isList: boolean = false;
            if (!(text === '\v') && !this.isRemoteAction) {
                isList = this.checkAndConvertList(selection, text === '\t');
            }
            if (!isList) {
                if (!isNullOrUndefined(selection.getHyperlinkField())) {
                    return;
                }
                //Checks if the previous text is URL, then it is auto formatted to hyperlink.
                this.checkAndConvertToHyperlink(selection, false);
            }
        }
        this.updateHistoryForComments(commentStarts);
    }

    private extendSelectionToBookmarkStart(selectionBookmark: string[]): void {
        if (this.documentHelper.bookmarks.length > 0) {
            let startPos: TextPosition = this.selection.start;
            let endPos: TextPosition = this.selection.end;
            if (!this.selection.isForward) {
                startPos = this.selection.end;
                endPos = this.selection.start;
            }
            let bookMark: BookmarkElementBox;
            for (let i: number = 0; i < selectionBookmark.length; i++) {
                bookMark = this.documentHelper.bookmarks.get(selectionBookmark[i]);
                if (this.selection.isElementInSelection(bookMark.reference, false) &&
                    !this.selection.isElementInSelection(bookMark, true)) {
                    let bookmarkPargraph: ParagraphWidget = bookMark.line.paragraph;
                    let selectionParagraphInfo: ParagraphInfo = this.selection.getParagraphInfo(startPos);
                    if (bookmarkPargraph.equals(selectionParagraphInfo.paragraph)) {
                        let elementOffset: number = bookMark.line.getOffset(bookMark, bookMark.bookmarkType);
                        if (bookMark.line === startPos.currentWidget && selectionParagraphInfo.offset === elementOffset + 1) {
                            startPos.offset--;
                        }
                    }
                }
            }
        }
    }

    /**
     * Retrieves the resultant field text from the specified field element box.
     * @param item Specify the field element box to retrieve field text.
     * @returns Returns the resultant field text.
     */
    public retrieveFieldResultantText(item: FieldElementBox): string {
        let resultantText: string = '';
        if (item.fieldType === 1) {
            let textElement: TextElementBox = item.previousElement as TextElementBox;
            // Get the last child of previous line if the field code presents at the start of the current line.
            if (isNullOrUndefined(textElement) && item.indexInOwner === 0 && !isNullOrUndefined(item.line) && !isNullOrUndefined(item.line.previousLine) && item.line.previousLine.children[item.line.previousLine.children.length - 1] instanceof TextElementBox) {
                textElement = item.line.previousLine.children[item.line.previousLine.children.length - 1] as TextElementBox;
            }
            while (!isNullOrUndefined(textElement) && textElement instanceof TextElementBox) {
                resultantText = textElement.text + resultantText;
                textElement = (!isNullOrUndefined(textElement.previousNode)) ? textElement.previousNode.previousValidNodeForTracking as TextElementBox : undefined;
            }
        }
        return resultantText;
    }

    private checkToMapRevisionWithNextNode(inline: ElementBox, tempSpan: ElementBox, isBidi: boolean, revisionType: RevisionType): boolean {
        if (isNullOrUndefined(inline)) {
            return false;
        }
        let nextElement: ElementBox = inline.nextValidNodeForTracking;
        if (!isNullOrUndefined(nextElement)) {
            return this.checkToMapRevisionWithInlineText(nextElement, 0, tempSpan, isBidi, revisionType);
        }
        return false;
    }

    private checkToMapRevisionWithPreviousNode(inline: ElementBox, tempSpan: ElementBox, isBidi: boolean, revisionType: RevisionType): boolean {
        if (isNullOrUndefined(inline)) {
            return false;
        }
        let prevElement: ElementBox = inline.previousValidNodeForTracking;
        if (!isNullOrUndefined(prevElement)) {
            return this.checkToMapRevisionWithInlineText(prevElement, prevElement.length, tempSpan, isBidi, revisionType);
        }
        return false;
    }
    private checkToMapRevisionWithInlineText(inline: ElementBox, indexInInline: number, newElement: ElementBox, isBidi: boolean, revisionType: RevisionType): boolean {
        if (!isNullOrUndefined(inline)) {
            if (revisionType === 'Deletion') {
                this.updateLastDeletedRevision(newElement);
            }
            if (inline.length === indexInInline && inline.previousValidNodeForTracking != undefined) {
                inline = inline.previousValidNodeForTracking;
                indexInInline = inline.length;
                if (inline.revisionLength > 0) {
                    return this.applyMatchedRevisionInorder(inline, newElement, indexInInline, false, isBidi, revisionType);
                }
            } else if (indexInInline === 0) {
                inline = inline.nextValidNodeForTracking;
                if (!isNullOrUndefined(inline) && inline.revisionLength > 0) {
                    return this.applyMatchedRevisionInorder(inline, newElement, indexInInline, true, isBidi, revisionType);
                }
            }
        }
        return false;
    }

    private combineElementRevisions(inline: ElementBox, elementToCombine: ElementBox): void {
        if (inline.revisionLength === 0 || elementToCombine.revisionLength === 0) {
            return;
        }
        for (let i: number = 0; i < inline.revisionLength; i++) {
            let prevRevision: Revision = inline.getRevision(i);
            for (let j: number = 0; j < elementToCombine.revisionLength; j++) {
                let currentRevision: Revision = elementToCombine.getRevision(j);
                if (prevRevision.getRange().indexOf(elementToCombine) === -1 && this.compareTwoRevisions(prevRevision, currentRevision)) {
                    let currentRevisionInsertedElements: ElementBox[] = currentRevision.getRange(true) as ElementBox[];
                    //To combine all the element with same revision.
                    for (let k: number = 0; k < currentRevisionInsertedElements.length; k++) {
                        let currentElement: ElementBox = currentRevisionInsertedElements[k];
                        currentElement.removeRevision(j);
                        currentElement.insertRevisionAt(j, prevRevision);
                    }
                    this.owner.revisions.remove(currentRevision);
                    this.owner.trackChangesPane.updateCurrentTrackChanges(prevRevision);
                }
            }
        }
    }
    private applyMatchedRevisionInorder(inline: ElementBox, newElement: ElementBox, indexInInline: number, isBegin: boolean, isBidi: boolean, revisionType: RevisionType, inlinePara?: WCharacterFormat): boolean {
        let revisionsMatched: Revision[];
        if (!isNullOrUndefined(inlinePara) && isNullOrUndefined(inline)) {
            revisionsMatched = this.getMatchedRevisionsToCombine(inlinePara.getAllRevision(), revisionType);
            if (revisionsMatched.length > 0) {
                return this.mapMatchedRevisions(revisionsMatched, inlinePara, newElement, isBegin);
            }
            return false;
        } else {
            revisionsMatched = this.getMatchedRevisionsToCombine(inline.getAllRevision(), revisionType);
            if (revisionsMatched.length > 0) {
                return this.mapMatchedRevisions(revisionsMatched, inline, newElement, isBegin);
            }
            return false;
        }
    }
    private copyElementRevision(elementToCopy: ElementBox, elementToInclude: ElementBox): void {
        if (!this.isTrackingFormField) {
            for (let i: number = 0; i < elementToCopy.revisionLength; i++) {
                let currentRevision: Revision = elementToCopy.getRevision(i);
                elementToInclude.insertRevisionAt(0, currentRevision);
                this.owner.trackChangesPane.updateCurrentTrackChanges(currentRevision);
            }
        }
    }

    /* eslint-disable @typescript-eslint/no-explicit-any */
    private mapMatchedRevisions(revisions: Revision[], revisionElement: any, elementToInclude: ElementBox | WCharacterFormat | WRowFormat, isBegin: boolean): boolean {
        for (let i: number = 0; i < revisions.length; i++) {
            let currentRevision: Revision = revisions[i];
            if (!this.isRevisionAlreadyIn(elementToInclude, currentRevision)) {
                elementToInclude.insertRevisionAt(0, currentRevision);
                if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && this.editorHistory.currentBaseHistoryInfo.markerData.length === 0) {
                    this.editorHistory.currentBaseHistoryInfo.markerData.push(this.getMarkerData(undefined, undefined, currentRevision));
                }
                if (elementToInclude instanceof FootnoteElementBox) {
                    this.insertRevisionForFootnoteWidget(elementToInclude, currentRevision);
                }
                this.owner.trackChangesPane.updateCurrentTrackChanges(currentRevision);
                return true;
            }
        }
        return false;
    }
    private isRevisionAlreadyIn(element: any, revision: Revision): boolean {
        if (element.revisionLength > 0) {
            for (let i = 0; i < element.revisionLength; i++) {
                let elementRevision: Revision = element.revisions[i];
                if (elementRevision.revisionID === revision.revisionID) {
                    return true;
                }
            }
        }
        return false;
    }
    private getMatchedRevisionsToCombine(revisions: Revision[], revisionType: RevisionType): Revision[] {
        let matchedRevisions: Revision[] = [];
        for (let i: number = 0; i < revisions.length; i++) {
            if (this.isRevisionMatched(revisions[i], revisionType)) {
                matchedRevisions.push(revisions[i]);
            }
        }
        return matchedRevisions;
    }
    /**
     * @private
     * @returns {void}
     */
    public insertIMEText(text: string, isUpdate: boolean): void {
        if (this.documentHelper.lastComposedText === text && isUpdate) {
            return;
        }
        // Clone selection start position
        let paragraphInfo: ParagraphInfo = this.selection.isForward ? this.selection.getParagraphInfo(this.selection.start) : this.selection.getParagraphInfo(this.selection.end);
        let startPosition: string = this.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
        // Insert IME text in current selection
        this.insertText(text);
        this.documentHelper.lastComposedText = text;
        // update selection start
        let start: TextPosition = this.selection.start;
        this.setPositionForCurrentIndex(start, startPosition);
        // Update selection end
        let endPosition: TextPosition = new TextPosition(this.owner);
        endPosition.setPositionForLineWidget(start.currentWidget, start.offset + text.length);
        if (this.owner.enableTrackChanges) {
            if (!isUpdate) {
                this.selection.start.setPositionInternal(this.selection.end);
            }
            this.selection.end.updatePhysicalPosition(true);
        } else {
            this.selection.selectPosition(isUpdate ? start : endPosition, endPosition);
        }
    }
    /**
      * Inserts the section break at cursor position with specified section break type.
      *
      * @param {SectionBreakType} sectionBreakType Specifies the section break type.
      * > If this parameter is not set, it inserts the section break of type new page.
      * @returns {void}
      */
    public insertSectionBreak(sectionBreakType?: SectionBreakType, sectionFormat?: WSectionFormat): void {
        if (isNullOrUndefined(sectionBreakType)) {
            sectionBreakType = SectionBreakType.NewPage;
        }
        let selection: Selection = this.documentHelper.selection;
        if (isNullOrUndefined(selection) || this.owner.isReadOnlyMode || selection.start.paragraph.isInHeaderFooter) {
            return;
        }
        if (sectionBreakType === SectionBreakType.Continuous) {
            this.initHistory('SectionBreakContinuous');
        } else {
            this.initHistory('SectionBreak');
        }
        if (!selection.isEmpty) {
            selection.selectContent(selection.isForward ? selection.start : selection.end, true);
        }
        this.documentHelper.owner.isShiftingEnabled = true;
        this.updateInsertPosition();
        if (sectionBreakType === SectionBreakType.Continuous) {
	    this.documentHelper.layout.isSectionBreakCont = true;
            this.insertSection(selection, true, undefined, true, undefined, sectionFormat);
        } else {
            this.insertSection(selection, true, undefined, undefined, true, sectionFormat); 
        }
        this.updateEndPosition();
        this.reLayout(selection, true);
        //if (this.owner.layoutType === 'Continuous') {
        this.documentHelper.layout.layoutWholeDocument(true);
        //} 
	this.documentHelper.layout.isSectionBreakCont = false;
    }


    /**
     * Removes the specified revision from the document.
     * 
     * @param revisionToRemove Specify the revision to be removed.
     * @returns {void}
     */
    public removeRevision(revisionToRemove: Revision): any {
        let elementInfo: ElementInfo = this.selection.start.currentWidget.getInline(this.selection.start.offset + 1, 0);
        let elementBox: ElementBox = elementInfo.element;
        if (elementInfo.element.revisionLength > 0) {
            for (let i: number = 0; i < elementBox.revisionLength; i++) {
                if (elementBox.getRevision(i).revisionType === revisionToRemove.revisionType) {
                    let revision: Revision = elementBox.getRevision(i);
                    let range: (ElementBox | WCharacterFormat | WRowFormat)[] = revision.getRange(true);
                    let startIndex: number = range.indexOf(elementBox);
                    for (let j: number = startIndex; startIndex < range.length; startIndex++) {
                        range[j].removeRevision(i);
                        this.owner.trackChangesPane.updateCurrentTrackChanges(revision);
                    }
                }
            }
        }
    }

    /**
     * Clears the specified revision from the document.
     * 
     * @param revision Specify the revision to clear from the document.
     * @returns {void}
     */
    public clearElementRevision(revision: Revision): void {
        if (isNullOrUndefined(revision)) {
            return;
        }
        //ToDo: No history
        for (let i: number = 0; i < revision.getRange().length; i++) {
            if (revision.getRange()[i] instanceof ElementBox) {
                let currentElement: ElementBox = revision.getRange()[i] as ElementBox;
                currentElement.removeRevision(currentElement.revisionLength - 1);
                this.owner.trackChangesPane.updateCurrentTrackChanges(revision);
            }
        }
    }
    /**
     * @private
     * @returns {void}
     */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    public insertRevision(item: ElementBox | WCharacterFormat | WRowFormat, type: RevisionType, author?: string, date?: string, spittedRange?: object[], skip?: boolean, parseRevisionId?: string): Revision {
        if ((this.isRemoteAction && isNullOrUndefined(this.revisionData) && !this.documentHelper.owner.parser.isPaste)) {
            return undefined;
        }
        let revisionId: string;
        if (isNullOrUndefined(spittedRange) && !isNullOrUndefined(this.revisionData) && this.revisionData.length > 0) {
            let newRevisionData: MarkerInfo = this.revisionData[0];
            author = newRevisionData.author;
            date = newRevisionData.date;
        }
        if (!isNullOrUndefined(parseRevisionId)) {
            revisionId = parseRevisionId;
        }
        author = !isNullOrUndefined(author) ? author : this.owner.currentUser ? this.owner.currentUser : 'Guest user';
        let currentDate: string = !isNullOrUndefined(date) ? date : HelperMethods.getUtcDate();
        let revision: Revision = new Revision(this.owner, author, currentDate, this.getOwnerNodeForRevision(item));
        revision.revisionType = type;
        if (this.owner.documentEditorSettings.revisionSettings && this.owner.documentEditorSettings.revisionSettings.customData) {
            revision.customData = this.owner.documentEditorSettings.revisionSettings.customData;
        }
        if (this.owner.enableCollaborativeEditing && this.isRemoteAction && !isNullOrUndefined(revisionId) && revisionId != '') {
            revision.revisionID = revisionId;
        } else {
            revision.revisionID = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        }
        if (!isNullOrUndefined(spittedRange) && spittedRange.length > 0) {
            this.clearAndUpdateRevisions(spittedRange, revision, spittedRange.indexOf(item));
        }
        if (!isNullOrUndefined(item)) {
            if (item.getAllRevision().indexOf(revision) === -1) {
                item.addRevision(revision);
            }
        }
        if (this.isRemoteAction && this.documentHelper.owner.parser.isPaste) {
            this.remotePasteRevision.push(revision);
        } else if (revision.getRange().length > 0 && !this.documentHelper.owner.parser.isPaste) {
            // Above isPaste condition is used because when pasting the content with revision we need to create only the revision. Because widgets is not pushed in the DOM level.
            // So we will update the revision to the collection in the insert block internal method after the widgets are pushed into dom level.
            this.updateRevisionCollection(revision);
        }
        if (!isNullOrUndefined(item)) {
            if (item instanceof FootnoteElementBox) {
                this.insertRevisionForFootnoteWidget(item, revision);
            }
            if (this.owner.enableCollaborativeEditing && !isNullOrUndefined(this.editorHistory) && this.editorHistory.currentBaseHistoryInfo && !skip) {
                this.editorHistory.currentBaseHistoryInfo.markerData.splice(0, 0, this.getMarkerData(item as any, undefined, revision));
            }
        }
        return revision;
    }

    private getOwnerNodeForRevision(item: WRowFormat | WCharacterFormat | ElementBox): ParagraphWidget | WCharacterFormat | WRowFormat {
        if (item instanceof ElementBox) {
            return item.paragraph.getSplitWidgets()[0] as ParagraphWidget;
        } else {
            return item;
        }
    }

    private insertRevisionForFootnoteWidget(element: FootnoteElementBox, revision: Revision): void {
        let blocks: BlockWidget[] = element.bodyWidget.childWidgets as BlockWidget[];
        this.skipFootNoteDeleteTracking = true;
        this.footnoteRevision = revision;
        for (let j: number = 0; j < blocks.length; j++) {
            this.insertRevisionForBlock(blocks[j] as ParagraphWidget, revision.revisionType, false, revision, undefined, undefined, undefined, true);
        }
        this.footnoteRevision = undefined;
        this.skipFootNoteDeleteTracking = false;
    }

    /**
     * Method help to clear previous revisions and include new revision at specified index
     *
     * @param range - range of elements to be cleared
     * @param revision - revision to be inserted
     * @param index - index at which to be included in the revision range
     * @returns {void}
     */
    private clearAndUpdateRevisions(range: object[], revision: Revision, index: number): void {
        //TODO: 
        // if (revision.getRange().filter(range => range instanceof WCharacterFormat)) {
        //     index += 1;
        // }
        for (let i: number = index; i < range.length; i++) {
            if (range[i] instanceof ElementBox || range[i] instanceof WCharacterFormat) {
                let currentElement: ElementBox = (range[i] as ElementBox);
                if (currentElement instanceof TextElementBox && currentElement.text === '') {
                    currentElement.removeRevision(currentElement.revisionLength - 1);
                    continue;
                }
                for (let j: number = 0; j < currentElement.revisionLength; j++) {
                    let currentRevision: Revision = currentElement.getRevision(j);
                    if (this.compareTwoRevisions(currentRevision, revision)) {
                        currentElement.removeRevision(j);
                        currentElement.insertRevisionAt(j, revision);
                    }
                }
            }
        }
        this.owner.trackChangesPane.updateCurrentTrackChanges(revision);
    }
    private splitRevisionByElement(item: ElementBox | WCharacterFormat, revision: Revision): object[] {
        if (item.revisionLength > 0) {
            let range: object[] = revision.getRange(true);
            this.owner.trackChangesPane.updateCurrentTrackChanges(revision);
            return range;
        }
        return undefined;
    }
    /**
     * Method to update revision for the splitted text element
     * @param inline - Original text element
     * @param splittedSpan - Splitted element
     */
    private updateRevisionForSpittedTextElement(inline: TextElementBox, splittedSpan: TextElementBox, currentItem: ElementBox | WCharacterFormat | WRowFormat): any {
        for (let i: number = 0; i < inline.revisionLength; i++) {
            let revision: Revision = inline.getRevision(i);
            if (splittedSpan.getAllRevision().indexOf(revision) !== -1) {
                /* eslint-disable @typescript-eslint/no-explicit-any */
                // let splittedRange: any = this.splitRevisionByElement(inline, revision);
                let splittedParagraph: ParagraphWidget = splittedSpan.paragraph;
                let splittedRange: ElementBox[] = splittedParagraph.getRevisionRange(revision);
                if (splittedSpan && splittedSpan instanceof TextElementBox && splittedSpan.text === '') {
                    continue;
                }
                this.insertRevision(splittedSpan, revision.revisionType, revision.author, revision.date, splittedRange, true);
            }
        }
        this.splitRevisionsAndViewBasedOnUntrackedContent(currentItem);
    }
    /**
     * @private
     */
    public getRevision(revisionId: string): Revision {
        for (let i = 0; i < this.owner.documentHelper.revisionsInternal.length; i++) {
            let revision: string = this.owner.documentHelper.revisionsInternal.keys[i];
            if (revision === revisionId) {
                return this.owner.documentHelper.revisionsInternal.get(revision);
            }
        }
        return undefined;
    }
    private isRevisionMatched(item: any, type: RevisionType): boolean {
        let author: string = this.owner.currentUser ? this.owner.currentUser : 'Guest user';
        if (item instanceof Revision) {
            if ((isNullOrUndefined(type) || type === item.revisionType) && item.author === author) {
                return true;
            }
        } else if (item.revisionLength > 0) {
            for (let i: number = 0; i < item.revisionLength; i++) {
                let elementRevision: Revision = item.revisions[i];
                if ((isNullOrUndefined(type) || type === elementRevision.revisionType) && elementRevision.author === author) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * @private
     */
    public compareElementRevision(element: any, compare: ElementBox | WCharacterFormat): boolean {
        if (element.revisionLength === 0 || compare.revisionLength === 0) {
            return false;
        }
        for (let i: number = 0; i < element.revisionLength; i++) {
            let currentRevision: Revision = element.revisions[i];
            for (let j: number = 0; j < compare.revisionLength; j++) {
                if (this.compareTwoRevisions(currentRevision, compare.getRevision(j))) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
    * @private
    */
    public compareTwoRevisions(revision: Revision, compare: Revision): boolean {
        if (revision.revisionType === compare.revisionType && revision.author === compare.author) {
            return true;
        }
        return false;
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    private canInsertRevision(item: any, type: RevisionType): boolean {
        let revisionType: RevisionType = isNullOrUndefined(type) ? 'Insertion' : type;
        if (revisionType === 'Deletion') {
            return false;
        }
        if (this.owner.enableTrackChanges) {
            return this.isRevisionMatched(item, revisionType);
            //if it has revision
        } else if (item.revisionLength > 0) {
            return false;
        }
        return true;
    }

    private insertRevisionAtEnd(item: ElementBox, newElement: ElementBox, revisionType: RevisionType): boolean {

        if (newElement instanceof BookmarkElementBox || newElement instanceof CommentCharacterElementBox || newElement instanceof EditRangeStartElementBox || newElement instanceof EditRangeEndElementBox || newElement instanceof ContentControl) {
            return false;
        }
        item = item.previousValidNodeForTracking;
        if (isNullOrUndefined(item)) {
            return false;
        }
        return this.insertRevisionAtPosition(item, newElement, true, revisionType);
    }

    private insertRevisionAtPosition(item: ElementBox, newElement: ElementBox, isEnd: boolean, revisionType: RevisionType): boolean {
        // if (newElement instanceof FieldElementBox && (newElement as FieldElementBox).fieldType === 2) {
        //     return false;
        // }
        let prevRevisionLength: number = newElement.revisionLength;

        let isRevisionCombined: boolean = this.checkToMapRevisionWithInlineText(item, (isEnd) ? item.length : 0, newElement, false, revisionType);
        // Check to combine with previous and next element
        if (isEnd) {
            if (!isRevisionCombined && newElement.revisionLength === prevRevisionLength) {
                isRevisionCombined = this.checkToMapRevisionWithNextNode(item.nextNode, newElement, false, revisionType);
            }
        } else {
            if (!isRevisionCombined && newElement.revisionLength === prevRevisionLength) {
                isRevisionCombined = this.checkToMapRevisionWithPreviousNode(item.previousNode, newElement, false, revisionType);
            }
        }
        return isRevisionCombined;
    }

    private insertRevisionAtBegining(item: ElementBox, newElement: ElementBox, revisionType: RevisionType): boolean {

        if (newElement instanceof BookmarkElementBox || newElement instanceof CommentCharacterElementBox || newElement instanceof EditRangeStartElementBox || newElement instanceof EditRangeEndElementBox || newElement instanceof ContentControl) {
            return false;
        }
        item = item.nextValidNodeForTracking;
        if (isNullOrUndefined(item)) {
            return false;
        }
        return this.insertRevisionAtPosition(item, newElement, false, revisionType);
    }

    private splitRevisionForSpittedElement(element: ElementBox, spittedElement: ElementBox): any {
        for (let i: number = element.revisionLength - 1; i >= 0; i--) {
            let revision: Revision = element.getRevision(i);
            let splittedRange: object[] = this.splitRevisionByElement(element, revision);
            this.insertRevision(spittedElement, revision.revisionType, revision.author, revision.date, splittedRange);
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public combineElementRevisionToPrevNxt(newElement: ElementBox): void {
        if (newElement.revisionLength > 0 && newElement.nextNode instanceof ElementBox && newElement.nextNode.revisionLength > 0) {
            this.combineElementRevision(newElement.getAllRevision(), newElement.nextNode.getAllRevision());
        }
    }
    private combineElementRevision(currentElementRevisions: Revision[], elementToCombine: Revision[], isReverse?: boolean): void {
        for (let i: number = 0; i < currentElementRevisions.length; i++) {
            for (let j: number = 0; j < elementToCombine.length; j++) {
                let currentRevision: Revision = currentElementRevisions[i];
                let revisionToCombine: Revision = elementToCombine[j];
                if (currentRevision === revisionToCombine) {
                    break;
                }
                if (this.compareTwoRevisions(currentRevision, revisionToCombine)) {
                    let rangeLength: number = revisionToCombine.getRange(true).length;
                    for (let k: number = 0; k < rangeLength; k++) {
                        let item: (ElementBox  | WCharacterFormat | WRowFormat) = revisionToCombine.getRange(true)[0];
                        item.removeRevision(item.getAllRevision().indexOf(revisionToCombine));
                        this.owner.trackChangesPane.updateCurrentTrackChanges(revisionToCombine);
                        // Create the new currentChangeView if the current element contains revisions but is not present in the pane case.
                        let currentChangeView: ChangesSingleView;
                        if (!isNullOrUndefined(currentRevision)) {
                            currentChangeView = this.owner.trackChangesPane.changes.get(currentRevision);
                        }
                        if (isNullOrUndefined(currentChangeView) && currentRevision.getRange().length > 0) {
                            this.updateRevisionCollection(currentRevision);
                        }
                        item.addRevision(currentRevision);
                        this.owner.trackChangesPane.updateCurrentTrackChanges(currentRevision);
                    }
                    if (revisionToCombine.getRange(true).length === 0) {
                        this.owner.revisions.remove(revisionToCombine);
                    }
                }
            }
        }
    }

    /**
     * Method to update the revision for whole block
     *
     * @private
     * @returns {void}
     */
    public insertRevisionForBlock(widget: ParagraphWidget, revisionType: RevisionType, isPaste?: boolean, revision?: Revision, skipReLayout?: boolean, isRemoveInline?: boolean, isAssOrder?: boolean, skipParaForFootNote?: boolean): void {
        if (widget.childWidgets.length === 0 || (!this.owner.enableTrackChanges && !isPaste)) {
            return;
        }
        if (revisionType === 'Deletion' && !this.editorHistory.isUndoing && !isPaste) {
            let editPosition: string = this.selection.editPosition;
            let start: TextPosition = this.selection.start.clone();
            let end: TextPosition = this.selection.end.clone();
            this.documentHelper.layout.clearListElementBox(widget);
            let isLastChild: boolean = (widget == this.getLastParaForBodywidgetCollection(widget));
            let nextParagraph: ParagraphWidget = this.selection.getNextParagraphBlock(widget);
            let paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(this.selection.start);
            let endParagraphInfo: ParagraphInfo = this.selection.getParagraphInfo(this.selection.end);
            const startIndex: string = this.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
            const endIndex: string = this.selection.getHierarchicalIndex(endParagraphInfo.paragraph, endParagraphInfo.offset.toString());
            let canRemovePara: boolean = false;
            let canTrackParaMark: boolean = false;
            if ((!isLastChild || (this.editorHistory && this.editorHistory.currentBaseHistoryInfo && this.editorHistory.currentBaseHistoryInfo.action === "RemoveRowTrack")) && !(isNullOrUndefined(nextParagraph) && widget.isEmpty()) && !isRemoveInline) {
                canTrackParaMark = true;
            }
            if (canTrackParaMark) {
                // Added the condition to remove section if current and next para have different section indexes if selection is covered till the end of section.
                if (!isNullOrUndefined(nextParagraph) && !nextParagraph.isInsideTable && widget.bodyWidget.sectionIndex !== nextParagraph.bodyWidget.sectionIndex) {
                    this.addRemovedNodes(widget.bodyWidget);
                }
                if (!isAssOrder) {
                    if (!skipParaForFootNote && !this.isPasteOverWriteCells) {
                        this.addRemovedNodes(widget.clone());
                    }
                    canRemovePara = this.handleDeleteParaMark(widget);
                }
            }
            for (let i: number = widget.childWidgets.length - 1; i > -1; i--) {
                let line: LineWidget = (widget.childWidgets[i]) as LineWidget;
                this.removeContent(line, 0, this.documentHelper.selection.getLineLength(line), undefined, isAssOrder ? true : (isRemoveInline ? false: !isLastChild));
            }
            if (canTrackParaMark) { 
                if (isAssOrder) {
                    canRemovePara = this.handleDeleteParaMark(widget);
                }               
                if (canRemovePara) {
                    if (widget.isEmpty()) {
                        this.removeBlock(widget);
                    } else {
                        // Update the editPosition before the block will be combined
                        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && this.editorHistory.currentBaseHistoryInfo.action === 'Delete') {
                            editPosition = this.selection.getHierarchicalIndex(widget, this.documentHelper.selection.getLineLength(widget.lastChild as LineWidget).toString());
                        }
                        this.deleteParagraphMark(widget, this.selection, 0, false, true, true);
                    }
                }
            }
            this.selection.editPosition = editPosition;
            this.selection.start.setPositionInternal(start);
            this.selection.end.setPositionInternal(end);
            // let textPosition: TextPosition = this.selection.getTextPosBasedOnLogicalIndex(editPostion);
            // this.selection.selectContent(textPosition, true);
            this.removeEmptyLine(widget);
            if (!skipReLayout && !isNullOrUndefined(widget.containerWidget)) {
                this.documentHelper.layout.reLayoutParagraph(widget, 0, 0);
                if (this.selection.start.currentWidget.indexInOwner === -1 && paragraphInfo.paragraph.indexInOwner !== -1) {
                    const startPos: TextPosition = this.selection.getTextPosBasedOnLogicalIndex(startIndex);
                    this.selection.start.setPositionInternal(startPos);
                }
                if (this.selection.end.currentWidget.indexInOwner === -1 && endParagraphInfo.paragraph.indexInOwner !== -1) {
                    const endPos: TextPosition = this.selection.getTextPosBasedOnLogicalIndex(endIndex);
                    this.selection.end.setPositionInternal(endPos);
                }
            }
        } else {
            for (let i: number = 0; i < widget.childWidgets.length; i++) {
                let elements: ElementBox[] = (widget.childWidgets[i] as LineWidget).children;
                for (let j: number = 0; j < elements.length; j++) {
                    //Logic used for when pasting the content when track changes enable and not enabled. Because in track changes after pushing the element only need to update the revision collection.
                    if (this.owner.enableTrackChanges) {
                        this.updateRevisions(elements[j]);
                        if (j === 0) {
                            let prevRevisionCount: number = elements[j].revisionLength;
                            revision = this.insertRevision(elements[j], revisionType);
                            if (elements[i].revisionLength > prevRevisionCount) {
                                revision = elements[i].getRevision(elements[j].revisionLength - 1);
                            } else {
                                elements[j].addRevision(revision);
                            }
                        } else {
                            elements[j].addRevision(revision);
                        }
                    } else if (isPaste && elements[j].revisionLength > 0) {
                        this.updateRevisions(elements[j]);
                    }
                }
            }
            if (!skipParaForFootNote) {
                if (this.owner.enableTrackChanges) {
                    this.insertRevision(widget.characterFormat, revisionType);
                } else if (isPaste && widget.characterFormat.revisionLength > 0) {
                    this.updateRevisions(widget.characterFormat);
                }
            }
        }
    }
    private checkToSplitRevisionInPrevNxt(element: ElementBox): void {
        let previousElement: ElementBox = element.previousNode;
        let nextElement: ElementBox = element.nextNode;
        let alreadySplitted: boolean = false;
        if (previousElement && nextElement) {
            previousElement = previousElement.previousValidNodeForTracking;
            nextElement = nextElement.nextValidNodeForTracking;
            if (previousElement && element && !this.compareElementRevision(previousElement, element) && nextElement && this.compareElementRevision(previousElement, nextElement)
                && !(element instanceof BookmarkElementBox || element instanceof CommentCharacterElementBox || element instanceof EditRangeStartElementBox || element instanceof EditRangeEndElementBox)) {
                this.updateRevisionForSpittedTextElement(previousElement as any, nextElement as any, element);
                alreadySplitted = true;
            }
        }
        if (!alreadySplitted) {
            this.splitRevisionsAndViewBasedOnUntrackedContent(element);
        }
    }
    /**
    * @private
    */
    public getLastParaForBodywidgetCollection(widget: ParagraphWidget) {
        const bodywidget = widget.containerWidget;
        if (bodywidget.containerWidget instanceof FootNoteWidget || (bodywidget instanceof TableCellWidget)) {
            const splitWidgets = bodywidget.getSplitWidgets();
            let splitWidgetsLength: number = splitWidgets.length;
            while (splitWidgetsLength > 0 && splitWidgets[splitWidgetsLength - 1].childWidgets.length === 0) {
                splitWidgetsLength--;
            }
            return splitWidgets[splitWidgetsLength - 1].lastChild;
        }
        else if ((bodywidget instanceof TextFrame) || (bodywidget instanceof HeaderFooterWidget)) {
            return bodywidget.childWidgets[bodywidget.childWidgets.length - 1];
        }
        const lastPage = this.documentHelper.pages[this.documentHelper.pages.length - 1];
        const lastBodyWidget = lastPage.bodyWidgets[lastPage.bodyWidgets.length - 1];
        const lastPara = lastBodyWidget.childWidgets[lastBodyWidget.childWidgets.length - 1];
        return lastPara;
    }

    private updatePasteRevision(): void {
        for (let i: number = 0; i < this.remotePasteRevision.length; i++) {
            if (this.owner.revisions.changes.indexOf(this.remotePasteRevision[i]) < 0) {
                this.updateRevisionCollection(this.remotePasteRevision[i]);
            } else {
                this.owner.trackChangesPane.updateCurrentTrackChanges(this.remotePasteRevision[i]);
            }
        }
        this.remotePasteRevision = [];
    }

    /**
    * @private
    */
    public updateRevisionCollection(revision: Revision): void {
        // Check if the revision is already present in the revision changes collection
        if (this.owner.revisions.changes.indexOf(revision) >= 0) {
            return; // If it's already there, no need to proceed
        }

        // Add revision to internal map if it's not exist in revisionInternal
        if (!this.documentHelper.revisionsInternal.containsKey(revision.revisionID)) {
            this.documentHelper.revisionsInternal.add(revision.revisionID, revision);
        }

        // Get the first element of the revision's range and its position in the document
        const rangeToInsert: ElementBox | WCharacterFormat | WRowFormat = revision.getRange(true)[0];
        const currentStart: TextPosition = this.getPositionFromRange(rangeToInsert);
        let isInserted: boolean = false;

        const changes: Revision[] = this.owner.revisions.changes;
        let insertIndex: number = changes.length;

        // Use binary search to find the correct insertion index
        if (changes.length > 0 && currentStart) {
            let low: number = 0;
            let high: number = changes.length - 1;
            while (low <= high) {
                const mid: number = Math.floor((low + high) / 2);
                let currentRange: ElementBox | WCharacterFormat | WRowFormat = changes[mid].getRange(false)[0];
                if (currentRange instanceof ElementBox && !isNullOrUndefined((currentRange as ElementBox).line) && (currentRange as ElementBox).line.paragraph.bodyWidget) {
                    if (currentRange instanceof FootnoteEndnoteMarkerElementBox && (currentRange.paragraph.containerWidget as BodyWidget).footNoteReference.revisionLength > 0) {
                        currentRange = (currentRange.paragraph.containerWidget as BodyWidget).footNoteReference;
                    }
                }
                const paraIndex: TextPosition = this.getPositionFromRange(currentRange);
                // Special case: If the footnote revision is found, insert right after it
                if (this.footnoteRevision === changes[mid]) {
                    const index: number = changes.indexOf(this.footnoteRevision);
                    this.owner.revisions.insertRevisionAt(index + 1, revision);
                    isInserted = true;
                    break;
                }
                // If paraIndex is not defined, skip this iteration
                if (isNullOrUndefined(paraIndex)) {
                    low = mid + 1;
                    continue;
                }
                // Use position comparison to decide direction of binary search
                if (currentStart.isExistBefore(paraIndex)) {
                    // If new revision comes before mid, search left half
                    high = mid - 1;
                    insertIndex = mid;
                } else {
                    // Else, search right half
                    low = mid + 1;
                }
            }
            // Insert revision at the calculated index
            if (!isInserted) {
                this.owner.revisions.insertRevisionAt(insertIndex, revision);
                isInserted = true;
            }
        }
        // If not inserted yet, add revision at the end
        if (!isInserted) {
            this.owner.revisions.addRevision(revision);
        }
        this.documentHelper.updateAuthorIdentity();
    }


    /**
     * Gets the position from the range.
     * @param range 
     */
    private getPositionFromRange(range: ElementBox | WCharacterFormat | WRowFormat): TextPosition {
        if (range instanceof ElementBox) {
            return this.selection.getElementPosition(range, false, false).startPosition;
        } else if (range instanceof WCharacterFormat) {
            const paraWidget = range.ownerBase as ParagraphWidget;
            if (paraWidget.lastChild) {
                const offset = paraWidget.getLength() + 1;
                const startPosition = new TextPosition(this.owner);
                startPosition.setPositionParagraph(paraWidget.lastChild as LineWidget, offset, false);
                return startPosition;
            }
        } else if (range instanceof WRowFormat) {
            const firstCell = this.getFirstCellFromRow(range.ownerBase as TableRowWidget);
            const firstPara = this.selection.getFirstParagraph(firstCell);
            const startPosition = new TextPosition(this.owner);
            startPosition.setPositionParagraph(firstPara.firstChild as LineWidget, 0, false);
            return startPosition;
        }
        return null;
    }

    private getFirstCellFromRow(rowWidget: TableRowWidget): TableCellWidget {
        let firstCell: TableCellWidget = rowWidget.childWidgets[0] as TableCellWidget;
        if (firstCell.childWidgets.length === 0) {
            for (let j: number = 1; j < rowWidget.childWidgets.length; j++) {
                if ((rowWidget.childWidgets[j] as TableCellWidget).childWidgets.length > 0) {
                    firstCell = rowWidget.childWidgets[j] as TableCellWidget;
                    break;
                }
            }
        }
        return firstCell;
    }
    /**
     * @private
     * @returns {BodyWidget}
     */
    public insertSection(selection: Selection, selectFirstBlock: boolean, isUndoing?: boolean, sectionBreakContinuous?: boolean, sectionBreakNewPage?:boolean, sectionFormat?: WSectionFormat): BlockWidget {
        let newSectionFormat: WSectionFormat;
        let startPara: ParagraphWidget = this.selection.start.paragraph;
        if (sectionBreakContinuous && !isUndoing && !startPara.isInsideTable && selection.start.offset === 0 && selection.start.currentWidget === startPara.firstChild && !isNullOrUndefined(startPara.previousRenderedWidget) && startPara.previousRenderedWidget instanceof ParagraphWidget && startPara.previousRenderedWidget.isEndsWithPageBreak) {
            this.selection.start.paragraph.bodyWidget.sectionFormat.breakCode = 'NoBreak';
            this.selection.start.paragraph.index = 0;
            this.updateNextBlocksIndex(this.selection.start.paragraph, true);
            this.updateSectionIndex(this.selection.start.paragraph.bodyWidget.sectionFormat, this.selection.start.paragraph.bodyWidget, true);
            this.selection.moveToNextParagraph();
            this.editorHistory.currentBaseHistoryInfo.insertPosition = undefined;
            this.updateInsertPosition();
            return undefined;
        }
        if (!isNullOrUndefined(sectionFormat)) {
            newSectionFormat = sectionFormat;
        } else {
            newSectionFormat = this.selection.start.paragraph.bodyWidget.sectionFormat.cloneFormat();
        }
        let lastBlock: BlockWidget;
        let firstBlock: BlockWidget;
        if (selection.start.paragraph.isInsideTable) {
            lastBlock = this.splitTableBasedonBreak(selection, true) as BlockWidget;
        } else {
            let paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(selection.start);
            let selectionStart: string = this.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
            //Split Paragraph
            if (!isUndoing) {
                this.splitParagraphInternal(selection, selection.start.paragraph, selection.start.currentWidget, selection.start.offset, selection.start.paragraph.characterFormat);
            }
            this.setPositionForCurrentIndex(selection.start, selectionStart);
            lastBlock = selection.start.paragraph.getSplitWidgets().pop() as BlockWidget;
            if (isUndoing && lastBlock.previousRenderedWidget !== undefined) {
                lastBlock = lastBlock.previousRenderedWidget as BlockWidget;
            }
        }
        //Split body widget
        firstBlock = this.splitBodyWidget(lastBlock.bodyWidget, newSectionFormat, lastBlock, sectionBreakContinuous, sectionBreakNewPage).firstChild as BlockWidget;
        // if (isUndoing) {
        //     this.layoutWholeDocument(true);
        // }
        // When applying break if the last para is empty need to layout the paragraph in the previous block similar to MS word. 
        const previousBlock: Widget = lastBlock.previousWidget;
        if (lastBlock instanceof ParagraphWidget && lastBlock.isEmpty() && previousBlock instanceof ParagraphWidget) {
            lastBlock.isSectionBreak = true;
            this.documentHelper.layout.reLayoutParagraph(lastBlock, 0, 0);
        }
        if (firstBlock instanceof TableWidget) {
            firstBlock.updateRowIndex(0);
        }
        this.documentHelper.layout.layoutBodyWidgetCollection(firstBlock.index, firstBlock.containerWidget, firstBlock, false);
        if (firstBlock instanceof TableWidget) {
            firstBlock = this.documentHelper.getFirstParagraphInFirstCell(firstBlock);
        }
        if (selectFirstBlock) {
            selection.selectParagraphInternal(firstBlock as ParagraphWidget, true);
        }
        return firstBlock;
    }

    
    /**
     * @private
     */
    public splitBodyWidget(bodyWidget: BodyWidget, sectionFormat: WSectionFormat, startBlock: BlockWidget, sectionBreakContinuous?: boolean, sectionBreakNewPage?: boolean): BodyWidget {
        //let sectionIndex: number;
        let isUpdated: boolean = true;
        //Move blocks after the start block to next body widget
        let newBodyWidget: BodyWidget = this.documentHelper.layout.moveBlocksToNextPage(startBlock, true, undefined, sectionBreakContinuous);
        if (this.editorHistory.isUndoing || (this.editorHistory.isRedoing && !isNullOrUndefined(sectionFormat.ownerBase))) {
            startBlock.bodyWidget.sectionFormat = sectionFormat;
        }
        if (newBodyWidget.page === undefined) {
            newBodyWidget.page = bodyWidget.page;
            bodyWidget.page.bodyWidgets.splice(bodyWidget.page.bodyWidgets.indexOf(bodyWidget) + 1, 0, newBodyWidget);

        } else if (bodyWidget.page.bodyWidgets.length > 1 && newBodyWidget.page !== undefined && !this.editorHistory.isUndoing) {
            let temp_NewBody: BodyWidget = newBodyWidget;

            while (!isNullOrUndefined(bodyWidget.nextRenderedWidget) && newBodyWidget !== bodyWidget.nextRenderedWidget) {
                let startindex: number = (bodyWidget.nextRenderedWidget as BodyWidget).page.bodyWidgets.indexOf(bodyWidget.nextRenderedWidget as BodyWidget);
                newBodyWidget.page.bodyWidgets.push(bodyWidget.nextRenderedWidget as BodyWidget);
                (bodyWidget.nextRenderedWidget as BodyWidget).page.bodyWidgets.splice(startindex, 1);
            }

            while (!isNullOrUndefined(newBodyWidget.nextRenderedWidget)) {
                (newBodyWidget.nextRenderedWidget as BodyWidget).page = newBodyWidget.page;
                newBodyWidget = newBodyWidget.nextRenderedWidget as BodyWidget;
            }

            newBodyWidget = temp_NewBody;
            newBodyWidget.sectionFormat = new WSectionFormat(newBodyWidget);
            if (sectionFormat.numberOfColumns > 1) {
                this.viewer.owner.parser.parseSectionFormat(0, bodyWidget.sectionFormat, newBodyWidget.sectionFormat);
                isUpdated = false;
            }
            newBodyWidget.sectionFormat.breakCode = 'NewPage';
        }
        //Update SectionIndex for splitted body widget
        if (sectionBreakContinuous) {
            if (sectionFormat.numberOfColumns > 1 && isUpdated) {
                newBodyWidget.sectionFormat = sectionFormat;
                this.viewer.owner.parser.parseSectionFormat(0, bodyWidget.sectionFormat, newBodyWidget.sectionFormat);
            } else {
                newBodyWidget.sectionFormat = new WSectionFormat(newBodyWidget);
                if (sectionFormat.numberOfColumns > 1 || (!isNullOrUndefined(bodyWidget.page) && !isNullOrUndefined(bodyWidget.page.nextPage) && this.documentHelper.getPageWidth(bodyWidget.page) !== this.documentHelper.getPageWidth(bodyWidget.page.nextPage))) {
                    this.viewer.owner.parser.parseSectionFormat(0, bodyWidget.sectionFormat, newBodyWidget.sectionFormat);
                }
            }
            newBodyWidget.sectionFormat.breakCode = 'NoBreak';
        }
        if (sectionBreakNewPage) {
            if (sectionFormat.numberOfColumns > 1 && isUpdated) {
                newBodyWidget.sectionFormat = sectionFormat;
                this.viewer.owner.parser.parseSectionFormat(0, bodyWidget.sectionFormat, newBodyWidget.sectionFormat);
            } else {
                newBodyWidget.sectionFormat = new WSectionFormat(newBodyWidget);
                this.viewer.owner.parser.parseSectionFormat(0, bodyWidget.sectionFormat, newBodyWidget.sectionFormat);
            }
            newBodyWidget.sectionFormat.breakCode = 'NewPage';
        }
        this.updateSectionIndex(newBodyWidget.sectionFormat, newBodyWidget, true);
        if (newBodyWidget.sectionFormat.numberOfColumns > 1) {
            this.updateColumnIndex(newBodyWidget, false);
        }
        // insert New header footer widget in to section index 
        if (this.editorHistory && !this.editorHistory.isUndoing) {
            this.insertRemoveHeaderFooter(newBodyWidget.sectionIndex, true);
        }
        // if (this.documentHelper.viewer instanceof PageLayoutViewer) {
        //     //update header and footer for splitted widget

        //     this.documentHelper.layout.layoutHeaderFooter(newBodyWidget, this.owner.viewer as PageLayoutViewer, newBodyWidget.page);
        // }
        // Calculate proper block index for multicolumn layouts
        let blockStartIndex: number = 0;
        if (newBodyWidget.firstChild && newBodyWidget.firstChild === startBlock.nextSplitWidget) {
            blockStartIndex = startBlock.index;
        }
        //Update Child item index from 0 for new Section
        this.updateBlockIndex(blockStartIndex, newBodyWidget.firstChild as BlockWidget);
        // Start sinfting from first block
        this.owner.viewer.updateClientArea(newBodyWidget, newBodyWidget.page);
        return newBodyWidget;
    }
    private insertRemoveHeaderFooter(sectionIndex: number, insert: boolean): void {
        if (this.documentHelper.headersFooters[sectionIndex]) {
            // Need to handle further
            this.documentHelper.headersFooters.splice(sectionIndex, 0, {});
        } else {
            this.documentHelper.headersFooters[sectionIndex] = {};
        }
    }
    private updateBlockIndex(blockIndex: number, block: BlockWidget): void {
        let blocks: BlockWidget[];
        let sectionIndex: number = block.bodyWidget.sectionIndex;
        do {
            blocks = block.getSplitWidgets() as BlockWidget[];
            for (let i: number = 0; i < blocks.length; i++) {
                blocks[i].index = blockIndex;
            }
            blockIndex++;
            block = blocks.pop().nextRenderedWidget as BlockWidget;
        } while (!isNullOrUndefined(block) && block.bodyWidget.sectionIndex === sectionIndex);
    }
    /**
     * @private
     * @returns {void}
     */
    public updateSectionIndex(sectionFormat: WSectionFormat, startBodyWidget: BodyWidget, increaseIndex: boolean): void {
        let currentSectionIndex: number = startBodyWidget.sectionIndex;
        let blockIndex: number = 0;
        let bodyWidget: BodyWidget = startBodyWidget;
        do {
            if (bodyWidget.index === currentSectionIndex && sectionFormat) {
                bodyWidget.sectionFormat = sectionFormat;
            }
            if (increaseIndex) {
                bodyWidget.index++;
            } else {
                bodyWidget.index--;
            }
            bodyWidget = bodyWidget.nextRenderedWidget as BodyWidget;
        } while (bodyWidget);
    }
    /**
    * @private
    * @returns {void}
    */
    public updateColumnIndex(startBodyWidget: BodyWidget, increaseIndex: boolean): void {
        let bodyWidget: BodyWidget = startBodyWidget;
        do {
            if (!increaseIndex && bodyWidget.columnIndex === 0) {
                break;
            }
            if (increaseIndex) {
                bodyWidget.columnIndex++;
            } else {
                bodyWidget.columnIndex--;
            }
            if (!isNullOrUndefined(bodyWidget.nextRenderedWidget) && bodyWidget.sectionIndex !== (bodyWidget.nextRenderedWidget as BodyWidget).sectionIndex) {
                break;
            }
            bodyWidget = bodyWidget.nextRenderedWidget as BodyWidget;
        } while (bodyWidget);
    }
    //Auto convert List
    private checkAndConvertList(selection: Selection, isTab: boolean): boolean {
        let list: WList = selection.paragraphFormat.getList();
        if (!isNullOrUndefined(list) || selection.start.paragraph.containerWidget instanceof FootNoteWidget) {
            return false;
        }
        let convertList: boolean = false;
        let isLeadingZero: boolean = false;
        let indexInInline: number = 0;
        let inlineObj: ElementInfo = selection.start.currentWidget.getInline(selection.start.offset - 1, indexInInline);
        let inline: ElementBox = inlineObj.element;
        indexInInline = inlineObj.index;
        if (!(inline instanceof TextElementBox)) {
            return false;
        }
        let span: TextElementBox = inline as TextElementBox;
        let text: string = span.text.substring(0, indexInInline);
        let tabValue: number = 0;
        let length: number = 0;
        while (!isNullOrUndefined(span.previousNode)) {

            if (span.previousNode instanceof TextElementBox && (span.previousNode.text === '\t' || span.previousNode.text.trim().length === 0)) {
                (span.previousNode.text === '\t') ? tabValue += 36 : length = span.previousNode.text.length * 2.5;
                span = span.previousNode;
                continue;
            }
            return false;
        }
        span = inline;
        let index: number = 0;
        let tabIndex: number = text.lastIndexOf('\t');
        index = (tabIndex >= 0) ? tabIndex + 1 : text.lastIndexOf(' ') + 1;
        while (span.previousNode instanceof TextElementBox && index === 0) {
            span = span.previousNode as TextElementBox;
            let previousText: string = span.text;
            tabIndex = previousText.lastIndexOf('\t');
            index = (tabIndex >= 0) ? tabIndex + 1 : previousText.lastIndexOf(' ') + 1;
            text = span.text + text;
            text = text.substring(index);
        }

        text = HelperMethods.trimStart(text);
        let numberFormat: string = text.substring(1, 2);

        let previousList: WList = undefined;
        let listLevelPattern: ListLevelPattern = this.getListLevelPattern(text.substring(0, 1));
        if (listLevelPattern !== 'None' && this.checkNumberFormat(numberFormat, listLevelPattern === 'Bullet', text)) {
            previousList = this.checkNextLevelAutoList(text);
            convertList = true;
        } else if (this.checkLeadingZero(text)) {
            isLeadingZero = true;
            convertList = true;
        } else {
            previousList = this.checkNextLevelAutoList(text);
            if (!isNullOrUndefined(previousList)) {
                convertList = true;
            }

        }
        if (convertList && listLevelPattern === 'Bullet' && inline.text === '- ' && (!isNullOrUndefined(inline.paragraph.previousWidget) && !(((inline.paragraph.previousWidget as ParagraphWidget).firstChild as LineWidget).children[0] instanceof ListTextElementBox))) {
            convertList = false;
        }
        if (convertList) {
            this.initComplexHistory('AutoList');
            let paragraph: ParagraphWidget = inline.paragraph as ParagraphWidget;

            selection.start.setPositionParagraph(paragraph.childWidgets[0] as LineWidget, (paragraph.childWidgets[0] as LineWidget).getOffset(inline, indexInInline + 1));
            selection.end.setPositionParagraph(paragraph.childWidgets[0] as LineWidget, 0);
            this.initHistory('Delete');
            this.deleteSelectedContents(selection, false);
            this.reLayout(selection, false);
            let followCharacter: FollowCharacterType = isTab ? 'Tab' : 'Space';
            numberFormat = !isLeadingZero ? '%1' + numberFormat : '%1' + text.substring(text.length - 1, text.length);
            let leadingZeroText: string = text.substring(text.length - 3, text.length - 1);
            listLevelPattern = !isLeadingZero ? listLevelPattern : this.getListLevelPattern(leadingZeroText);
            let listLevel: WListLevel = new WListLevel(undefined);
            listLevel.listLevelPattern = listLevelPattern;
            if (listLevelPattern === 'Bullet') {
                if (text === '*') {
                    listLevel.numberFormat = String.fromCharCode(61623);
                    listLevel.characterFormat.fontFamily = 'Symbol';
                } else if (text === '-') {
                    listLevel.numberFormat = '-';
                }
            } else {
                listLevel.numberFormat = numberFormat;
            }
            listLevel.followCharacter = followCharacter;
            let leftIndent: number = selection.paragraphFormat.leftIndent;
            if (tabValue !== 0 || length !== 0) {
                listLevel.paragraphFormat.leftIndent = leftIndent + 18 + tabValue + length;
            } else if (indexInInline > 2) {
                listLevel.paragraphFormat.leftIndent = leftIndent + (indexInInline - 2) * 2.5 + 18;
            } else if (leftIndent > 0) {
                listLevel.paragraphFormat.leftIndent = leftIndent + 18;
            } else {
                listLevel.paragraphFormat.leftIndent = 36;
            }
            listLevel.paragraphFormat.firstLineIndent = -18;
            if ((!isLeadingZero && text.substring(0, 1) === '0') || leadingZeroText === '00') {
                listLevel.startAt = 0;
            } else {
                listLevel.startAt = 1;
            }
            if (!isNullOrUndefined(previousList)) {
                selection.paragraphFormat.setList(previousList);
            } else {
                this.autoConvertList(selection, listLevel);
            }
            if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
                this.editorHistory.updateComplexHistory();
            } else {
                this.reLayout(selection);
            }

        }
        return convertList;
    }
    private checkNextLevelAutoList(text: string): WList {
        let selection: Selection = this.documentHelper.selection;
        let previousList: WList = undefined;
        let convertList: boolean = false;
        let currentParagraph: ParagraphWidget = selection.start.paragraph;
        let prevParagraph: ParagraphWidget = selection.getPreviousParagraphBlock(currentParagraph) as ParagraphWidget;
        while (!isNullOrUndefined(prevParagraph) && prevParagraph instanceof ParagraphWidget) {
            if (prevParagraph.paragraphFormat.listFormat && prevParagraph.paragraphFormat.listFormat.listId !== -1) {
                const levelNumber: number = prevParagraph.paragraphFormat.listFormat.listLevelNumber;
                convertList = this.isConvertList(text, prevParagraph);
                if (convertList) {
                    this.listLevelNumber = levelNumber;
                    this.isAutoList = true;
                    break;
                } else if (text === '*' || text === '-') {
                    this.isAutoList = true;
                    convertList = true;
                    break;
                }
            }
            prevParagraph = selection.getPreviousParagraphBlock(prevParagraph, true) as ParagraphWidget;
        }
        if (convertList) {
            previousList = this.documentHelper.getListById(prevParagraph.paragraphFormat.listFormat.listId);
        }
        return previousList;
    }

    private isConvertList(text: string, paragraph: ParagraphWidget): boolean {
        let convertList: boolean = false;
        let listNumber: string = this.documentHelper.layout.getListNumber(paragraph, true);
        let prevListText: string = listNumber.substring(0, listNumber.length - 1);
        let currentListText: string = text.substring(0, text.length - 1);
        //check if numberFormat equal
        let inputString: number;
        if (listNumber.substring(listNumber.length - 1) !== text.substring(text.length - 1)) {
            convertList = false;
        } else if (currentListText.match(/^[0-9]+$/) && prevListText.match(/^[0-9]+$/)) {
            inputString = parseInt(currentListText, 10);
            if (parseInt(prevListText, 10) === inputString || parseInt(prevListText, 10) + 1 === inputString
                || parseInt(prevListText, 10) + 2 === inputString) {
                convertList = true;
            }
        } else if (currentListText.match(/^[a-zA-Z]+$/) && prevListText.match(/^[a-zA-Z]+$/)) {
            if (prevListText.charCodeAt(0) === text.charCodeAt(0) || prevListText.charCodeAt(0) + 1 === text.charCodeAt(0)
                || prevListText.charCodeAt(0) + 2 === text.charCodeAt(0)) {
                convertList = true;
            } else if (currentListText.match(/^[MDCLXVImdclxvi]+$/) && prevListText.match(/^[MDCLXVImdclxvi]+$/)) {
                let prevListNumber: number = this.getNumber(prevListText.toUpperCase());
                let currentListNumber: number = this.getNumber(currentListText.toUpperCase());
                if (prevListNumber === currentListNumber || prevListNumber + 1 === currentListNumber
                    || prevListNumber + 2 === currentListNumber) {
                    convertList = true;
                }
            }
        }
        return convertList;
    }
    private getNumber(roman: string): number {
        let conversion: object = { 'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1 };
        let arr: string[] = roman.split('');
        let num: number = 0;
        for (let i: number = 0; i < arr.length; i++) {
            let currentValue: number = conversion[arr[i]];
            let nextValue: number = conversion[arr[i + 1]];
            if (currentValue < nextValue) {
                num -= (currentValue);
            } else {
                num += (currentValue);
            }
        }

        return num;
    }
    private getListLevelPattern(value: string): ListLevelPattern {
        switch (value) {
            case '0':
            case '1':
                return 'Arabic';
            case 'I':
                return 'UpRoman';
            case 'i':
                return 'LowRoman';
            case 'A':
                return 'UpLetter';
            case 'a':
                return 'LowLetter';
            case '*':
            case '-':
                return 'Bullet';
            case '00':
            case '01':
                return 'LeadingZero';
            default:
                return 'None';
        }
    }
    private autoConvertList(selection: Selection, listLevel: WListLevel): void {
        let start: TextPosition = selection.start;
        if (!selection.isForward) {
            start = selection.end;
        }
        let newList: WList = new WList();
        if (this.documentHelper.lists.length > 0) {
            newList.listId = this.documentHelper.lists[this.documentHelper.lists.length - 1].listId + 1;
        } else {
            newList.listId = 0;
        }
        let newAbstractList: WAbstractList = new WAbstractList();
        let layout: DocumentHelper = this.documentHelper;
        if (layout.abstractLists.length > 0) {
            newAbstractList.abstractListId = layout.abstractLists[layout.abstractLists.length - 1].abstractListId + 1;
        } else {
            newAbstractList.abstractListId = 0;
        }
        newList.abstractListId = newAbstractList.abstractListId;
        newList.abstractList = newAbstractList;
        newList.nsid = newAbstractList.nsid = HelperMethods.generateUniqueId(layout.lists);
        layout.abstractLists.push(newAbstractList);
        newAbstractList.levels.push(listLevel);
        listLevel.ownerBase = newAbstractList;
        selection.paragraphFormat.setList(newList);
        selection.paragraphFormat.listLevelNumber = 0;
    }
    private checkNumberFormat(numberFormat: string, isBullet: boolean, text: string): boolean {
        if (isBullet) {
            return numberFormat === '';
        } else {
            let index: number = text.indexOf(numberFormat);
            return (numberFormat === '.' || numberFormat === ')'
                || numberFormat === '>' || numberFormat === '-') && text.substring(index, text.length - 1) === '';
        }
    }
    private checkLeadingZero(text: string): boolean {
        let j: number;
        let isZero: boolean = false;
        for (let i: number = 0; i <= text.length - 1; i++) {
            if (text.charAt(i) === '0') {
                isZero = true;
                continue;
            }
            j = i;
            break;
        }
        let numberFormat: string = undefined;
        if (text.charAt(j) === '1') {
            numberFormat = text.charAt(j + 1);
        } else {
            numberFormat = text.charAt(j);
        }
        return isZero && this.checkNumberFormat(numberFormat, false, text);
    }
    private getPageFromBlockWidget(block: BlockWidget): Page {
        let page: Page = undefined;
        if (block.containerWidget instanceof BodyWidget) {
            page = (block.containerWidget as BodyWidget).page;
        } else if (block.containerWidget instanceof HeaderFooterWidget) {
            page = (block.containerWidget as HeaderFooterWidget).page;
        } else if (block.containerWidget instanceof TableCellWidget) {
            page = (block.containerWidget as TableCellWidget).bodyWidget.page;
        }
        return page;
    }

    /**
     * @private
     * @returns {void}
     */
    public insertTextInline(element: ElementBox, selection: Selection, text: string, index: number, skipReLayout?: boolean, revisionType?: RevisionType, isBidi?: boolean): void {
	    if (element instanceof TextElementBox) {
            element.text = HelperMethods.insert(element.text, index, text);
            element.isWidthUpdated = false;
            if (this.owner.enableTrackChanges) {
                let revision = element.getRevision(0);
                if(!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                    this.editorHistory.currentBaseHistoryInfo.markerData.push(this.getMarkerData(undefined, undefined, revision));
                }         
                this.owner.trackChangesPane.updateCurrentTrackChanges(revision);
            }
            let paragraph: ParagraphWidget = (element.line as LineWidget).paragraph;
            let lineIndex: number = paragraph.childWidgets.indexOf(element.line);
            let elementIndex: number = element.line.children.indexOf(element);
            if (element instanceof TextElementBox && element.text.length > 90) {
                // Here, the text is split based on the maximum character length of 90.
                HelperMethods.splitWordByMaxLength(element, element.line);
            }
            if (isNullOrUndefined(skipReLayout) || !skipReLayout) {
                this.documentHelper.layout.reLayoutParagraph(paragraph, lineIndex, elementIndex, element.line.paragraph.bidi);
            }
        } else if (element instanceof ImageElementBox) {
            this.insertImageText(element as ImageElementBox, selection, text, index);
        } else if (element instanceof FieldElementBox) {
            if (element.fieldType === 0) {
                this.insertFieldBeginText(element, selection, text, index);
                if (!isNullOrUndefined(revisionType) && this.canInsertRevision(element, revisionType)) {
                    this.checkToMapRevisionWithInlineText(element, index, element.nextElement, isBidi, revisionType);
                }
            } else if (element.fieldType === 2) {
                this.insertFieldSeparatorText(element, selection, text, index);
            } else {
                this.insertFieldEndText(element, selection, text, index);
            }
        } else if (element instanceof BookmarkElementBox || element instanceof EditRangeStartElementBox
            || element instanceof EditRangeEndElementBox) {
            this.insertBookMarkText(element, text);
        }
    }
    private insertFieldBeginText(fieldBegin: FieldElementBox, selection: Selection, text: string, index: number): void {
        let spanObj: TextElementBox = new TextElementBox();
        spanObj.text = text;
        let lineIndex: number = fieldBegin.line.paragraph.childWidgets.indexOf(fieldBegin.line);
        let spanIndex: number = (fieldBegin.line as LineWidget).children.indexOf(fieldBegin);
        if (this.owner.enableCollaborativeEditing && this.isRemoteAction) {
            spanIndex ++;
        }
        spanObj.characterFormat.copyFormat(fieldBegin.characterFormat);
        (fieldBegin.line as LineWidget).children.splice(spanIndex, 0, spanObj);
        spanObj.line = fieldBegin.line;
        this.documentHelper.layout.reLayoutParagraph(fieldBegin.line.paragraph, lineIndex, spanIndex);
    }
    private insertBookMarkText(element: ElementBox, text: string): void {
        let spanObj: TextElementBox = new TextElementBox();
        spanObj.text = text;
        let lineIndex: number = element.line.paragraph.childWidgets.indexOf(element.line);
        let spanIndex: number = (element.line as LineWidget).children.indexOf(element);
        spanObj.characterFormat.copyFormat(element.characterFormat);
        (element.line as LineWidget).children.splice(spanIndex + 1, 0, spanObj);
        spanObj.line = element.line;
        this.documentHelper.layout.reLayoutParagraph(element.line.paragraph, lineIndex, spanIndex);
    }

    private insertFieldSeparatorText(fieldSeparator: FieldElementBox, selection: Selection, text: string, index: number): void {
        let previousInline: ElementBox = selection.getPreviousTextInline(fieldSeparator);
        let nextInline: ElementBox = selection.getNextTextInline(fieldSeparator);
        let span: TextElementBox = new TextElementBox();
        span.text = text;
        let spanIndex: number = (fieldSeparator.line as LineWidget).children.indexOf(fieldSeparator);
        if (index === fieldSeparator.length) {
            spanIndex++;
        }
        if (isNullOrUndefined(previousInline) && isNullOrUndefined(nextInline)) {
            span.characterFormat.copyFormat((fieldSeparator.line.paragraph as ParagraphWidget).characterFormat);
        } else if (isNullOrUndefined(previousInline)) {
            span.characterFormat.copyFormat(nextInline.characterFormat);
        } else {
            if (this.owner.enableCollaborativeEditing && this.isRemoteAction) {
                const temp: WCharacterFormat = this.getCharacterFormat(this.selection);
                span.characterFormat.copyFormat(temp);
            } else {
                span.characterFormat.copyFormat(previousInline.characterFormat);
            }
        }
        fieldSeparator.line.children.splice(spanIndex, 0, span);
        span.line = fieldSeparator.line;
        let lineIndex: number = fieldSeparator.line.paragraph.childWidgets.indexOf(fieldSeparator.line);
        this.documentHelper.layout.reLayoutParagraph(fieldSeparator.line.paragraph, lineIndex, spanIndex);
    }
    private insertFieldEndText(fieldEnd: FieldElementBox, selection: Selection, text: string, index: number): void {
        let span: TextElementBox = new TextElementBox();
        span.text = text;
        let spanIndex: number = (fieldEnd.line as LineWidget).children.indexOf(fieldEnd);
        span.characterFormat.copyFormat(fieldEnd.characterFormat);
        if (selection.isInlineFormFillMode() && index == 0) {
            // special case to insert text before fieldEnd while filling a text form field.
            // when spell check enabled the white space and charaters are inserted as saperate text element box and getInline returns fieldEnd with index 0
            fieldEnd.line.children.splice(spanIndex, 0, span);
        } else {
            fieldEnd.line.children.splice(spanIndex + 1, 0, span);
        }
        span.line = fieldEnd.line;
        let lineIndex: number = fieldEnd.line.paragraph.childWidgets.indexOf(fieldEnd.line);
        if (this.owner.enableTrackChanges) {
            let isBidi: boolean = this.documentHelper.textHelper.getRtlLanguage(text).isRtl;
            let revisionType: RevisionType = 'Insertion';
            let isRevisionCombined: boolean = this.checkToMapRevisionWithInlineText(fieldEnd, index, span, isBidi, revisionType);
            if (!isRevisionCombined && span.revisionLength === 0) {
                isRevisionCombined = this.checkToMapRevisionWithNextNode(fieldEnd.nextNode, span, isBidi, revisionType);
            }
        }
        this.documentHelper.layout.reLayoutParagraph(fieldEnd.line.paragraph, lineIndex, spanIndex);
    }
    private insertImageText(image: ImageElementBox, selection: Selection, text: string, index: number): void {
        let previousInlineObj: ElementBox = selection.getPreviousTextInline(image);
        let nextInlineObj: ElementBox = selection.getNextTextInline(image);
        let line: LineWidget = image.line;
        let element: TextElementBox = new TextElementBox();
        let paragraph: ParagraphWidget = line.paragraph;
        let lineIndex: number = paragraph.childWidgets.indexOf(line);
        element.text = text;
        let spanIndex: number = line.children.indexOf(image);
        if (index === image.length) {
            spanIndex++;
        }
        if (isNullOrUndefined(previousInlineObj) && isNullOrUndefined(nextInlineObj)) {
            element.characterFormat.copyFormat(paragraph.characterFormat);
        } else if (isNullOrUndefined(previousInlineObj)) {
            element.characterFormat.copyFormat(nextInlineObj.characterFormat);
        } else {
            element.characterFormat.copyFormat(previousInlineObj.characterFormat);
        }
        line.children.splice(spanIndex, 0, element);
        element.line = line;
        this.documentHelper.layout.reLayoutParagraph(paragraph, lineIndex, spanIndex);
    }
    /**
     * @private
     */
    private isListTextSelected(): void {
        if (this.documentHelper.isListTextSelected) {
            this.initComplexHistory('ListSelect');

            if (this.documentHelper.selection.start.paragraph.paragraphFormat.listFormat && this.documentHelper.selection.start.paragraph.paragraphFormat.listFormat.listId !== -1) {
                this.onApplyList(undefined);
            }
        }
    }
    //Auto Format and insert Hyperlink Implementation starts
    private checkAndConvertToHyperlink(selection: Selection, isEnter: boolean, paragraph?: ParagraphWidget): void {
        let text: string;
        let span: TextElementBox;
        if (isEnter) {
            span = (paragraph.lastChild as LineWidget).children[(paragraph.lastChild as LineWidget).children.length - 1] as TextElementBox;
            text = span.text;
        } else {
            let indexInInline: number = 0;
            let inlineObj: ElementInfo = selection.start.currentWidget.getInline(selection.start.offset - 1, indexInInline);
            let inline: ElementBox = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!(inline instanceof TextElementBox)) {
                return;
            }
            span = inline as TextElementBox;
            text = span.text.substring(0, indexInInline);
        }
        let index: number = 0;
        let tabCharIndex: number = text.lastIndexOf('\t');
        index = (tabCharIndex >= 0) ? tabCharIndex + 1 : text.lastIndexOf(' ') + 1;
        while (span.previousElement instanceof TextElementBox && index === 0) {
            span = span.previousNode as TextElementBox;
            let previousText: string = span.text;
            tabCharIndex = previousText.lastIndexOf('\t');
            index = (tabCharIndex >= 0) ? tabCharIndex + 1 : previousText.lastIndexOf(' ') + 1;
            text = span.text + text;
        }
        text = text.substring(index);
        let lowerCaseText: string = text.toLowerCase();
        let containsURL: boolean = false;
        if (lowerCaseText.substring(0, 8) === 'file:///'
            || (lowerCaseText.substring(0, 7) === 'http://' && lowerCaseText.length > 7)
            || (lowerCaseText.substring(0, 8) === 'https://' && lowerCaseText.length > 8)
            || (lowerCaseText.substring(0, 4) === 'www.' && lowerCaseText.length > 4)
            || (lowerCaseText.substring(0, 3) === '\\' && lowerCaseText.length > 3)
            || (lowerCaseText.substring(0, 7) === 'mailto:' && lowerCaseText.length > 7)) {
            containsURL = true;
            if (lowerCaseText.substring(0, 4) === 'www.' && lowerCaseText.length > 4) {
                text = 'http://' + text;
            }
        } else {
            let atIndex: number = text.indexOf('@');
            let dotIndex: number = text.lastIndexOf('.');
            if (atIndex > 0 && atIndex < dotIndex && dotIndex < text.length - 1) {
                containsURL = true;
                text = 'mailto:' + text;
            }
        }
        if (containsURL) {
            let startPos: TextPosition = new TextPosition(this.documentHelper.owner);
            startPos.setPositionParagraph(span.line, span.line.getOffset(span, index));
            let endPos: TextPosition = new TextPosition(this.documentHelper.owner);
            if (isEnter) {
                endPos.setPositionParagraph(span.line, span.line.getEndOffset());
            } else {
                if (selection.end.currentWidget.children.length === 0 && selection.end.offset === 0) {
                    let prevLine: LineWidget = selection.end.currentWidget.previousLine;
                    endPos.setPositionParagraph(prevLine, prevLine.getEndOffset());
                } else {
                    endPos.setPositionParagraph(selection.end.currentWidget, selection.end.offset - 1);
                }
            }

            this.autoFormatHyperlink(selection, text, startPos, endPos);
        }
    }
    private autoFormatHyperlink(selection: Selection, url: string, startPosition: TextPosition, endPosition: TextPosition): void {
        if (this.owner.enableCollaborativeEditing && this.isRemoteAction) {
            return;
        }
        this.initComplexHistory('AutoFormatHyperlink');
        let blockInfo: ParagraphInfo = this.selection.getParagraphInfo(startPosition);
        let start: string = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.editorHistory.currentHistoryInfo.insertPosition = start;
        }

        // Moves the selection to URL text start and end position.
        selection.start.setPositionInternal(startPosition);
        selection.end.setPositionInternal(endPosition);

        // Preserves the character format for hyperlink field.
        let temp: WCharacterFormat = this.getCharacterFormat(selection);
        let format: WCharacterFormat = new WCharacterFormat();
        format.copyFormat(temp);

        let fieldEnd: FieldElementBox = this.createHyperlinkElement(url, startPosition, endPosition, format);
        // Moves the selection to the end of field end position.
        selection.start.setPositionParagraph(fieldEnd.line, (fieldEnd.line).getOffset(fieldEnd, 1));
        // Moves to next text position. (To achieve common behavior for space and enter).
        selection.start.moveNextPosition();
        selection.end.setPositionInternal(selection.start);
        blockInfo = this.selection.getParagraphInfo(selection.end);
        let end: string = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.editorHistory.currentHistoryInfo.endPosition = end;
            this.isSkipOperationsBuild = this.owner.enableCollaborativeEditing;
            this.editorHistory.updateComplexHistory();
            this.isSkipOperationsBuild = false;
            this.reLayout(selection);
        } else {
            this.updateComplexWithoutHistory(0, start, end);
        }
    }
    private appylingHyperlinkFormat(selection: Selection): void {
        this.initHistory('Underline');
        this.updateCharacterFormatWithUpdate(selection, 'underline', 'Single', false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.reLayout(selection, false);
        // Applies font color for field result.
        this.initHistory('FontColor');
        this.isForHyperlinkFormat = true;
        this.updateCharacterFormatWithUpdate(selection, 'fontColor', '#0563c1', false);
        this.isForHyperlinkFormat = false;
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.reLayout(selection, false);
    }

    private createHyperlinkElement(url: string, startPosition: TextPosition, endPosition: TextPosition, format: WCharacterFormat): FieldElementBox {
        let selection: Selection = this.selection;
        this.documentHelper.layout.allowLayout = false;
        this.documentHelper.layout.isReplaceAll = true;
        this.appylingHyperlinkFormat(selection);
        //this.documentHelper.layout.allowLayout = true;
        // Adds the field end at the URL text end position.
        let fieldEnd: FieldElementBox = new FieldElementBox(1);
        fieldEnd.characterFormat.copyFormat(format);
        fieldEnd.line = selection.end.currentWidget;
        selection.start.setPositionInternal(selection.end);
        // this.insertElementInCurrentLine(selection, fieldEnd, true);
        this.initInsertInline(fieldEnd);
        // Moves the selection to URL text start position.        
        selection.start.setPositionInternal(startPosition);
        selection.end.setPositionInternal(selection.start);

        // Adds field begin, field code and field separator at the URL text start position.
        let begin: FieldElementBox = this.insertHyperlinkfield(selection, format, url);
        let lineIndex: number = selection.start.paragraph.childWidgets.indexOf(begin.line);
        let index: number = begin.line.children.indexOf(begin);
        fieldEnd.linkFieldCharacter(this.documentHelper);
        this.documentHelper.layout.isReplaceAll = false;
        this.documentHelper.layout.allowLayout = true;
        this.documentHelper.layout.reLayoutParagraph(selection.start.paragraph, lineIndex, index);
        return fieldEnd;
    }
    private insertHyperlinkfield(selection: Selection, format: WCharacterFormat, url: string, isBookmark?: boolean): FieldElementBox {
        // Adds field begin, field code and field separator at the URL text start position.
        let begin: FieldElementBox = new FieldElementBox(0);
        begin.characterFormat.copyFormat(format);
        begin.line = selection.start.currentWidget;
        this.initInsertInline(begin);
        let span: TextElementBox = new TextElementBox();
        span.characterFormat.copyFormat(format);
        if (isBookmark) {
            span.text = ' HYPERLINK \\l \"' + url + '\" ';
        } else {
            span.text = ' HYPERLINK \"' + url + '\" ';
        }
        span.line = selection.start.currentWidget;
        this.initInsertInline(span);
        let separator: FieldElementBox = new FieldElementBox(2);
        separator.characterFormat.copyFormat(format);
        separator.line = selection.start.currentWidget;
        this.initInsertInline(separator);
        return begin;
    }
    /**
     * @private
     */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    public unlinkRevisionFromItem(item: any): void {
        for (let i: number = item.revisionLength - 1; i >= 0; i--) {
            let currentRevision: Revision = item.revisions[i];
            item.removeRevision(item.getAllRevision().indexOf(currentRevision));
            this.owner.trackChangesPane.updateCurrentTrackChanges(currentRevision);
            if (currentRevision.getRange(true).length === 0) {
                this.owner.revisions.remove(currentRevision);
                if (this.isRemoveRevision && this.documentHelper.revisionsInternal.containsKey(currentRevision.revisionID)) {
                    this.documentHelper.revisionsInternal.remove(currentRevision.revisionID);
                    this.owner.trackChangesPane.updateTrackChanges();
                }
            }
        }
        this.constructRevisionsForLink(item, true);
    }
    /**
     * @private
     */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    // used to update the revisions for elements present between the field separator and field end when performing undo if the link covered multiple blocks.
    public constructRevisionsForLink(inline: any, isRemove: boolean) {
        if (inline instanceof FieldElementBox && inline.fieldType === 2 && !isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.historyInfoStack) && this.editorHistory.historyInfoStack.length > 0 && this.editorHistory.historyInfoStack[0].action === 'InsertHyperlink') {
            let element: ElementBox = inline.nextElement;
            let isConstructRevision: boolean = false;
            if (!isNullOrUndefined(inline.fieldEnd) && inline.fieldEnd.indexInOwner !== -1) {
                isConstructRevision = true;
            }
            while (!isNullOrUndefined(element)) {
                if (element instanceof FieldElementBox && element.fieldType === 1) {
                    break;
                }
                if (isRemove) {
                    this.addRemovedRevisionInfo(element);
                    this.unlinkRevisionFromItem(element);
                } else if (isConstructRevision && element.removedIds.length > 0) {
                    this.constructRevisionFromID(element, false);
                }
                if (isNullOrUndefined(element.nextElement)) {
                    if (!isNullOrUndefined(element.paragraph) && !isNullOrUndefined(element.paragraph.nextRenderedWidget) && element.paragraph.nextRenderedWidget instanceof ParagraphWidget && !element.paragraph.nextRenderedWidget.isEmpty()) {
                        if (isRemove) {
                            this.addRemovedRevisionInfo(element.paragraph.characterFormat, undefined);
                            this.unlinkRevisionFromItem(element.paragraph.characterFormat);
                        } else if (isConstructRevision && element.paragraph.characterFormat.removedIds.length > 0) {
                            this.constructRevisionFromID(element.paragraph.characterFormat);
                        }
                        element = ((element.paragraph.nextRenderedWidget as ParagraphWidget).firstChild as LineWidget).children[0];
                    } else {
                        element = undefined;
                    }
                } else {
                    element = element.nextElement;
                }
            }
        }
    }

    /**
     * @private
     * @returns {void}
     */
    public unLinkFieldCharacter(inline: ElementBox): void {
        if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            if (inline.fieldEnd) {
                if (this.documentHelper) {
                    this.documentHelper.fieldToLayout = inline;
                    this.documentHelper.fieldEndParagraph = inline.line.paragraph;
                }
                // inline.line.paragraph.addFieldCharacter(inline.fieldEnd);
                if (inline.fieldEnd) {
                    inline.fieldEnd.fieldBegin = undefined;
                }
                inline.fieldEnd = undefined;
            }
        }
        if (inline instanceof FieldElementBox && inline.fieldType === 2) {
            if (!isNullOrUndefined(inline.fieldEnd)) {
                if (this.documentHelper) {
                    this.documentHelper.fieldToLayout = inline.fieldBegin;
                    this.documentHelper.fieldEndParagraph = inline.line.paragraph;
                }
                inline.fieldBegin.fieldSeparator = undefined;
                inline.fieldEnd.fieldSeparator = undefined;
            }
        } else if (inline instanceof FieldElementBox && inline.fieldType === 1) {
            if (inline.fieldBegin) {
                if (!isNullOrUndefined(this.documentHelper)) {
                    this.documentHelper.fieldToLayout = inline.fieldBegin;
                    this.documentHelper.fieldEndParagraph = inline.line.paragraph;
                }
                let fieldIndex: number = this.documentHelper.fields.indexOf(inline.fieldBegin);
                if (fieldIndex !== -1) {
                    this.documentHelper.fields.splice(fieldIndex, 1);
                }
                let formFieldIndex: number = this.documentHelper.formFields.indexOf(inline.fieldBegin);
                if (formFieldIndex !== -1) {
                    this.documentHelper.formFields.splice(formFieldIndex, 1);
                }
                inline.fieldBegin.fieldEnd = undefined;
                inline.fieldBegin = undefined;
            }
        }
    }

    private getCharacterFormat(selection: Selection): WCharacterFormat {
        if (selection.start.paragraph.isEmpty()) {
            return selection.start.paragraph.characterFormat;
        } else {
            let info: ElementInfo = selection.start.currentWidget.getInline(selection.start.offset + 1, 0);
            return info.element.characterFormat;
        }
    }
    /**
     * Inserts the Hyperlink.
     *
     * @param {string} address Specify the Hyperlink URL to be inserted.
     * @param {string} displayText Specify the display text for the hyperlink
     * @param {string} screenTip Specify the screen tip text.
     * @returns {void}
     */
    public insertHyperlink(address: string, displayText?: string, screenTip?: string): void {
        if (HelperMethods.startsWith(address, 'http://') || HelperMethods.startsWith(address, 'https://')) {
            address = address.replace(/\s/g, "");
        }
        if (isNullOrUndefined(displayText)) {
            displayText = address;
        }
        if (!isNullOrUndefined(screenTip)) {
            address = address + '\" \\o \"' + screenTip;
        }
        this.insertHyperlinkInternal(address, displayText, this.owner.selectionModule.text !== displayText, false);
    }
    /**
     * @private
     */
    public insertHyperlinkInternal(url: string, displayText: string, remove: boolean, isBookmark?: boolean): void {
        let selection: Selection = this.documentHelper.selection;
        if (selection.start.paragraph.associatedCell !== selection.end.paragraph.associatedCell || this.selection.isPlainContentControl()) {
            return;
        }
        let startPosition: TextPosition = selection.start;
        let endPosition: TextPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        // if selection end is covering paraMark exclude paraMark
        if (endPosition.offset == endPosition.paragraph.getLength() + 1) {
            let elementInfo: ElementInfo = this.selection.getElementInfo(endPosition.currentWidget, endPosition.offset - 1);
            // if selection end is BookmarkElementBox and paraMark was included, excluding paraMark
            if (elementInfo.element instanceof BookmarkElementBox && elementInfo.element.bookmarkType === 1
                && !isNullOrUndefined(elementInfo.element.properties) && elementInfo.element.properties.hasOwnProperty('isAfterParagraphMark')
                && elementInfo.element.properties['isAfterParagraphMark']) {
                endPosition.setPositionParagraph(elementInfo.element.line, elementInfo.element.line.getOffset(elementInfo.element, 0));
            } else {
                endPosition.movePreviousPosition();
            }
        }
        if (remove) {
            //Empty selection Hyperlink insert
            this.insertHyperlinkInternalInternal(selection, url, displayText, isBookmark);
        } else {
            this.documentHelper.layout.allowLayout = false;
            //Non-Empty Selection- change the selected text to Field       
            // this.preservedFontCol = this.getFontColor();
            let fieldStartPosition: TextPosition = new TextPosition(this.documentHelper.owner);
            fieldStartPosition.setPositionInternal(startPosition);

            let temp: WCharacterFormat = this.getCharacterFormat(selection);
            let format: WCharacterFormat = new WCharacterFormat(undefined);
            format.copyFormat(temp);
            this.initComplexHistory('InsertHyperlink');
            let blockInfo: ParagraphInfo = this.selection.getParagraphInfo(startPosition);
            let start: string = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
                this.editorHistory.currentHistoryInfo.insertPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            }
            this.appylingHyperlinkFormat(selection);

            startPosition.setPositionInternal(endPosition);
            // Adds the field end at the URL text end position.
            let fieldEnd: FieldElementBox = new FieldElementBox(1);
            fieldEnd.characterFormat.copyFormat(format);
            fieldEnd.line = selection.end.currentWidget;
            startPosition.setPositionInternal(endPosition);
            // this.insertElementInCurrentLine(selection, fieldEnd, true);
            this.initInsertInline(fieldEnd);
            // Moves the selection to URL text start position.        
            startPosition.setPositionInternal(fieldStartPosition);
            endPosition.setPositionInternal(startPosition);

            // Adds field begin, field code and field separator at the URL text start position.
            let begin: FieldElementBox = this.insertHyperlinkfield(selection, format, url, isBookmark);
            fieldEnd.linkFieldCharacter(this.documentHelper);
            let lineIndex: number = selection.start.paragraph.childWidgets.indexOf(begin.line);
            let index: number = begin.line.children.indexOf(begin);
            this.documentHelper.layout.allowLayout = true;
            this.documentHelper.layout.reLayoutParagraph(selection.start.paragraph, lineIndex, index);
            let lineWidget: LineWidget = fieldEnd.line;
            selection.selects(lineWidget, lineWidget.getOffset(fieldEnd, fieldEnd.length), true);
            blockInfo = this.selection.getParagraphInfo(endPosition);
            let end: string = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            if (this.editorHistory && this.editorHistory.currentHistoryInfo) {

                this.editorHistory.currentHistoryInfo.endPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
                this.editorHistory.updateComplexHistory();
            } else {
                this.updateComplexWithoutHistory(1, start, end);
            }
        }
    }
    private insertHyperlinkInternalInternal(selection: Selection, url: string, displayText: string, isBookmark?: boolean): void {
        if (isNullOrUndefined(selection.start)) {
            return;
        }
        if (this.editHyperlink(selection, url, displayText)) {
            return;
        }
        let commentStarts: CommentCharacterElementBox[] = this.checkAndRemoveComments();
        // Preserves the character format for hyperlink field.
        const temp: WCharacterFormat = this.getCharacterFormat(selection);
        this.initHistory('InsertHyperlink');
        let isRemoved: boolean = true;
        if (!selection.isEmpty) {
            let isTrackEnabled: boolean = this.owner.enableTrackChanges;
            this.owner.enableTrackChanges = false;
            isRemoved = this.removeSelectedContents(selection);
            this.owner.enableTrackChanges = isTrackEnabled;
        }
        if (isRemoved) {
            let format: WCharacterFormat = new WCharacterFormat();
            format.copyFormat(temp);
            this.insertHyperlinkByFormat(selection, url, displayText, format, isBookmark);
        }
        this.updateHistoryForComments(commentStarts);
    }

    private insertHyperlinkByFormat(selection: Selection, url: string, displayText: string, format: WCharacterFormat, isBookmark?: boolean): void {
        this.updateInsertPosition();
        selection.owner.isShiftingEnabled = true;
        let indexInInline: number = 0;
        //let initial: number = indexInInline;
        let element: ElementBox[] = [];
        let fieldBegin: FieldElementBox = new FieldElementBox(0);
        if (!isNullOrUndefined(this.editorHistory) && this.editorHistory.currentBaseHistoryInfo) {
            this.editorHistory.currentBaseHistoryInfo.fieldBegin = fieldBegin;
        }
        fieldBegin.characterFormat.copyFormat(format);
        element.push(fieldBegin);
        let span: TextElementBox = new TextElementBox();
        if (isBookmark) {
            span.text = ' HYPERLINK \\l \"' + url + '\" ';
        } else {
            span.text = ' HYPERLINK \"' + url + '\" ';
        }
        span.characterFormat.copyFormat(format);
        element.push(span);
        let fieldSeparator: FieldElementBox = new FieldElementBox(2);
        fieldSeparator.characterFormat.copyFormat(format);
        element.push(fieldSeparator);
        if (!isNullOrUndefined(displayText) && displayText !== '') {
            span = new TextElementBox();
            span.characterFormat.copyFormat(format);
            span.characterFormat.underline = 'Single';
            span.characterFormat.fontColor = '#0563c1';
            span.text = displayText;
            element.push(span);
        }
        let fieldEnd: FieldElementBox = new FieldElementBox(1);
        fieldEnd.characterFormat.copyFormat(format);
        element.push(fieldEnd);
        fieldBegin.fieldSeparator = fieldEnd.fieldSeparator = fieldSeparator;
        fieldBegin.fieldEnd = fieldSeparator.fieldEnd = fieldEnd;
        fieldSeparator.fieldBegin = fieldEnd.fieldBegin = fieldBegin;
        this.insertElement(element);
        //let paragraph: ParagraphWidget = selection.start.paragraph;
        fieldEnd.linkFieldCharacter(this.documentHelper);
        if (this.documentHelper.fields.indexOf(fieldBegin) === -1) {
            this.documentHelper.fields.push(fieldBegin);
        }
        //let offset: number = fieldEnd.line.getOffset(fieldEnd, 1);
        selection.selects(fieldEnd.line, fieldEnd.line.getOffset(fieldEnd, fieldEnd.length), true);
        this.updateEndPosition();
        this.reLayout(selection, true);
    }
	/**
     * @private
     */
    public initInsertInline(element: ElementBox, insertHyperlink?: boolean, isInsertRemovedBookamrk?: boolean): void {
        let selection: Selection = this.selection;
        let isSelectionUpdated: boolean = false;
        // if (!this.isInsertingTOC && isInsertRemovedBookamrk && element instanceof BookmarkElementBox) {
        //     selection.start.offset--;
        //     selection.end.offset--;
        //     isSelectionUpdated = true;
        // }
        this.initHistory('InsertInline');
        this.insertInlineInSelection(selection, element);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        // if (isSelectionUpdated) {
        //     selection.start.offset++;
        //     selection.end.offset++;
        // }
    }

    private insertElementInCurrentLine(selection: Selection, inline: ElementBox): void {
        if (this.checkIsNotRedoing()) {
            selection.owner.isShiftingEnabled = true;
        }
        if (!selection.isEmpty) {
            this.removeSelectedContents(selection);
        }
        this.updateInsertPosition();
        this.insertElement([inline]);
        if (this.checkEndPosition(selection)) {
            this.updateHistoryPosition(selection.start, false);
        }
        this.fireContentChange();
    }
    /**
     * Edit Hyperlink
     * @param {Selection} selection - Specified the selection
     * @param {string} url - Specifies the url
     * @param {string} displayText - Specified the display test
     * @param {boolean} isBookmark - Specifies is bookmark
     * @private
     * @returns {boolean} - Return tru of hyperlink is edited.
     */
    public editHyperlink(selection: Selection, url: string, displayText: string, isBookmark?: boolean): boolean {
        let fieldBegin: FieldElementBox = selection.getHyperlinkField();
        if (isNullOrUndefined(fieldBegin)) {
            return false;
        }
        this.initHistory('InsertHyperlink');
        this.editHyperlinkInternal = isNullOrUndefined(this.editorHistory)
            || (this.editorHistory && isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo));
        let fieldResult: string = '';
        let isNestedField: boolean = false;
        // Preserves the character format for hyperlink field.
        let temp: WCharacterFormat = this.getCharacterFormat(selection);
        let format: WCharacterFormat = new WCharacterFormat();
        format.copyFormat(temp);
        let fieldSeparator: FieldElementBox = undefined;
        if (!isNullOrUndefined(fieldBegin.fieldSeparator)) {
            fieldSeparator = fieldBegin.fieldSeparator;

            let fieldObj: HyperlinkTextInfo = selection.getHyperlinkDisplayText(fieldBegin.fieldSeparator.line.paragraph, fieldBegin.fieldSeparator, fieldBegin.fieldEnd, isNestedField, format);
            fieldResult = fieldObj.displayText;
            isNestedField = fieldObj.isNestedField;
            format = fieldObj.format;
        }
        let offset: number = fieldBegin.line.getOffset(fieldBegin, 0);
        selection.start.setPositionParagraph(fieldBegin.line, offset);
        offset = fieldBegin.fieldEnd.line.getOffset(fieldBegin.fieldEnd, 1);
        selection.end.setPositionParagraph(fieldBegin.fieldEnd.line, offset);
        this.skipFieldDeleteTracking = true;
        this.deleteSelectedContents(selection, true);
        if (!isNestedField && fieldResult !== displayText || isNullOrUndefined(fieldSeparator)) {
            this.insertHyperlinkByFormat(selection, url, displayText, format, isBookmark);
            this.skipFieldDeleteTracking = false;
        } else {
            //Modify the new hyperlink url. Inserts field begin, url and field separator.
            this.updateInsertPosition();
            let newFieldBegin: FieldElementBox = new FieldElementBox(0);
            if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                this.editorHistory.currentBaseHistoryInfo.fieldBegin = newFieldBegin;
                this.editorHistory.currentBaseHistoryInfo.isEditHyperlink = true;
            }
            newFieldBegin.characterFormat.copyFormat(fieldBegin.characterFormat);
            newFieldBegin.line = selection.start.currentWidget;
            this.insertInlineInternal(newFieldBegin);
            let span: TextElementBox = new TextElementBox();
            span.characterFormat.copyFormat(fieldBegin.characterFormat);
            if (isBookmark) {
                span.text = ' HYPERLINK \\l \"' + url + '\" ';
            } else {
                span.text = ' HYPERLINK \"' + url + '\" ';
            }
            span.line = selection.start.currentWidget;
            this.insertInlineInternal(span);
            let nodes: IWidget[] = this.editorHistory && this.editorHistory.currentBaseHistoryInfo ?
                this.editorHistory.currentBaseHistoryInfo.removedNodes : this.nodes;
            this.insertClonedFieldResult(selection, nodes, fieldSeparator);
            let fieldEnd: FieldElementBox = selection.end.currentWidget.getInline(selection.end.offset, 0).element as FieldElementBox;
            fieldEnd.linkFieldCharacter(this.documentHelper);
            this.skipFieldDeleteTracking = false;
            let paragraph: ParagraphWidget = newFieldBegin.line.paragraph;
            let lineIndex: number = newFieldBegin.line.paragraph.childWidgets.indexOf(newFieldBegin.line);
            let elementIndex: number = newFieldBegin.line.children.indexOf(newFieldBegin);
            this.documentHelper.layout.reLayoutParagraph(paragraph, lineIndex, elementIndex);
            offset = newFieldBegin.fieldEnd.line.getOffset(newFieldBegin.fieldEnd, 1);
            selection.selects(newFieldBegin.fieldEnd.line, offset, true);
            this.updateEndPosition();
            this.reLayout(selection, true);
        }
        this.editHyperlinkInternal = false;
        this.nodes = [];
        return true;
    }
    private insertClonedFieldResult(selection: Selection, nodes: any, fieldSeparator: FieldElementBox): void {
        let fieldEnd: FieldElementBox;
        let isStarted: boolean = false;
        for (let i: number = nodes.length - 1; i > -1; i--) {
            let node: any = nodes[i] as any;
            if (!isStarted) {
                if (fieldSeparator === node) {
                    isStarted = true;
                } else {
                    if (node instanceof ParagraphWidget && node === fieldSeparator.line.paragraph) {
                        isStarted = true;
                        let paragraph: ParagraphWidget = undefined;
                        if (i === nodes.length - 1) {
                            paragraph = selection.start.paragraph;
                            let fieldParagraph: ParagraphWidget = fieldSeparator.line.paragraph;
                            this.getClonedFieldResultWithSel(fieldParagraph, selection, fieldSeparator);
                        } else {

                            paragraph = this.getClonedFieldResult(fieldSeparator.line.paragraph, fieldSeparator);
                            this.insertParagraph(paragraph, true);
                        }
                        selection.selectParagraphInternal(selection.getNextParagraphBlock(paragraph), true);
                    }
                    continue;
                }
            }
            if (node instanceof ElementBox) {
                this.insertInlineInternal(node.clone());
            } else if (node instanceof BlockWidget) {
                this.insertBlock((node as BlockWidget).clone());
            }
            // else if (node instanceof WSection)
            //     editor.insertSection((node as WSection)._Clone());
        }
    }

    private getClonedFieldResultWithSel(paragraph: ParagraphWidget, selection: Selection, fieldSeparator: ElementBox): void {
        let lineIndex: number = paragraph.childWidgets.indexOf(fieldSeparator.line);
        let elementIndex: number = (paragraph.childWidgets[lineIndex] as LineWidget).children.indexOf(fieldSeparator);
        for (let j: number = lineIndex; j < paragraph.childWidgets.length; j++) {
            let lineWidget: LineWidget = paragraph.childWidgets[j] as LineWidget;
            if (j !== lineIndex) {
                elementIndex = 0;
            }
            for (let i: number = elementIndex; i < lineWidget.children.length; i++) {
                this.insertInlineInternal(lineWidget.children[i].clone());
            }
        }
    }
    private getClonedFieldResult(curParagraph: ParagraphWidget, fieldSeparator: ElementBox): ParagraphWidget {
        let paragraph: ParagraphWidget = new ParagraphWidget();
        paragraph.characterFormat.copyFormat(curParagraph.characterFormat);
        paragraph.paragraphFormat.copyFormat(curParagraph.paragraphFormat);
        let lineIndex: number = curParagraph.childWidgets.indexOf(fieldSeparator.line);
        let elementIndex: number = (curParagraph.childWidgets[lineIndex] as LineWidget).children.indexOf(fieldSeparator);
        for (let j: number = lineIndex; j < curParagraph.childWidgets.length; j++) {
            let lineWidget: LineWidget = curParagraph.childWidgets[j] as LineWidget;
            if (j !== lineIndex) {
                elementIndex = 0;
            }
            for (let i: number = elementIndex; i < lineWidget.children.length; i++) {
                (paragraph.childWidgets[0] as LineWidget).children.push(lineWidget.children[i]);
            }
        }
        return paragraph;
    }
     /**
     * Removes the content control if selection is in content control
     * @returns {void}
     * @private
     */
    public removeContentControl():void {
        let contentControl: ContentControl = this.documentHelper.owner.selection.currentContentControl;
        if(contentControl instanceof ContentControl){
            const contentControlEnd: ContentControl = contentControl.reference;
            let start: TextPosition = this.selection.start.clone();
            let end: TextPosition = this.selection.end.clone();
            let endElementInfo : ElementInfo = this.selection.getElementInfo(end.currentWidget, end.offset);
            this.selection.start.setPositionParagraph(contentControl.line, contentControl.line.getOffset(contentControl, contentControl.length));
            this.selection.end.setPositionParagraph(contentControlEnd.line, contentControlEnd.line.getOffset(contentControlEnd, contentControlEnd.length) -1);
            this.initHistory('RemoveContentControl');
            this.selection.selectPosition(start, end);
            if (this.editorHistory) {
                this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Marker_Start;
                this.editorHistory.currentBaseHistoryInfo.markerData.push({ text: 'RemoveContentControl', type: contentControl.contentControlWidgetType });
                this.editorHistory.currentBaseHistoryInfo.setContentControlInfo(contentControl);
            }
            this.removeContentControlInternal(contentControl);
            if (this.editorHistory) {
                this.editorHistory.updateHistory();
            }
            if (endElementInfo.element !== contentControl && endElementInfo.element !== contentControlEnd) {
                this.selection.end.setPositionParagraph(endElementInfo.element.line, endElementInfo.element.line.getOffset(endElementInfo.element, endElementInfo.index));
            }
        }
        this.fireContentChange();
        //if (this.owner.documentEditorSettings.showBookmarks == true) {
            this.viewer.updateScrollBars();
        //}
    }
    /**
     * Removes the content control if selection is in content control
     * @returns {void}
     * @private
     */
    public removeContentControlInternal(contentControl?: ContentControl): void {
        if (isNullOrUndefined(contentControl)) {
            contentControl = this.documentHelper.owner.selection.currentContentControl;
        }
        if (contentControl.contentControlProperties.type == 'Picture') {
            this.owner.renderPictureContentControlElement(this.owner, false, false);
        }
        const index: number = this.documentHelper.contentControlCollection.indexOf(contentControl);
        if (index >= 0) {
            this.updatePropertiesToBlock(contentControl);
            this.documentHelper.contentControlCollection.splice(index, 1);
            contentControl.line.children.splice(contentControl.indexInOwner, 1)
            if (!isNullOrUndefined(contentControl.reference)) {
                contentControl.reference.line.children.splice(contentControl.reference.indexInOwner, 1);
                this.updatePropertiesToBlock(contentControl);
            }
        }
        this.selection.updateContentControlHighlightSelection();
        let element = document.getElementById("contenticon");
        let picElement = document.getElementById(this.owner.element.id + 'PICTURE_CONTENT_CONTROL');
        if (element) {
            element.style.display = 'none';
        }
        if (picElement) {
            picElement.style.display = 'none';
        }
        this.viewer.updateScrollBars();
    }
    /**
     * Removes the hyperlink if selection is within hyperlink.
     *
     * @returns {void}
     */
    public removeHyperlink(): void {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        let selection: Selection = this.selection;
        let fieldBegin: FieldElementBox = selection.getHyperlinkField();
        if (isNullOrUndefined(fieldBegin)) {
            return;
        }
        let fieldEnd: FieldElementBox = fieldBegin.fieldEnd;
        let fieldSeparator: FieldElementBox = fieldBegin.fieldSeparator;
        let fieldStartPosition: TextPosition = new TextPosition(selection.owner);

        fieldStartPosition.setPositionParagraph(fieldBegin.line, (fieldBegin.line).getOffset(fieldBegin, 0));
        let blockInfo: ParagraphInfo = this.selection.getParagraphInfo(fieldStartPosition);
        let fieldStartString: string = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        let fieldSeparatorPosition: TextPosition = new TextPosition(selection.owner);

        fieldSeparatorPosition.setPositionParagraph(fieldSeparator.line, (fieldSeparator.line).getOffset(fieldSeparator, fieldSeparator.length));
        blockInfo = this.selection.getParagraphInfo(fieldSeparatorPosition);
        let fieldSeparatorString: string = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        this.initComplexHistory('RemoveHyperlink');
        selection.start.setPositionParagraph(fieldEnd.line, (fieldEnd.line).getOffset(fieldEnd, 0));
        blockInfo = this.selection.getParagraphInfo(selection.start);
        let startIndex: string = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        selection.end.setPositionParagraph(fieldEnd.line, (fieldEnd.line).getOffset(fieldEnd, 1));
        this.delete();

        selection.start.setPositionInternal(this.selection.getTextPosBasedOnLogicalIndex(fieldSeparatorString));
        this.initHistory('Underline');
        this.updateCharacterFormatWithUpdate(selection, 'underline', 'None', false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        selection.end.setPositionInternal(this.selection.getTextPosBasedOnLogicalIndex(startIndex));
        // Applies font color for field result.
        this.initHistory('FontColor');
        this.updateCharacterFormatWithUpdate(selection, 'fontColor', undefined, false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.reLayout(selection, false);
        selection.end.setPositionInternal(selection.start);
        selection.start.setPositionInternal(this.selection.getTextPosBasedOnLogicalIndex(fieldStartString));
        this.initHistory('Delete');
        this.deleteSelectedContents(selection, false);
        this.reLayout(selection, true);
        // Bug 873011: Combined the field begin and field end revisions to preserve single tracking in track changes pane.
        this.combineElementRevision(fieldSeparator.getAllRevision(), fieldEnd.getAllRevision());
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
            this.editorHistory.updateComplexHistory();
        }
    }
    /**
     * @private
     */
    public updateHyperlinkFormat(selection: Selection): void {
        let fieldBegin: FieldElementBox = selection.getHyperlinkField();
        if (isNullOrUndefined(fieldBegin)) {
            return;
        }
        let fieldEnd: FieldElementBox = fieldBegin.fieldEnd;
        let fieldSeparator: FieldElementBox = fieldBegin.fieldSeparator;
        selection.start.setPositionParagraph(fieldSeparator.line, (fieldSeparator.line).getOffset(fieldSeparator, fieldSeparator.length));
        selection.end.setPositionParagraph(fieldEnd.line, (fieldEnd.line).getOffset(fieldEnd, 0));
        this.initHistory('Underline');
        this.updateCharacterFormatWithUpdate(selection, 'underline', 'Single', false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.reLayout(selection, false);
        // Applies font color for field result.
        this.initHistory('FontColor');
        this.isForHyperlinkFormat = true;
        this.updateCharacterFormatWithUpdate(selection, 'fontColor', '#0563c1', false);
        this.isForHyperlinkFormat = false;
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.reLayout(selection, false);
    }
    
    /**
     * Triggers the beforePaste event.
     * 
     * @param {string} sfdt - The SFDT content to be pasted.
     * @param {PasteType} pasteType - Type of content being pasted.
     * @returns {boolean} Returns true if paste operation should continue, false if canceled.
     * @private
     */
    private triggerBeforePasteEvent(pasteContent: string, pasteType: PasteType): BeforePasteEventArgs {
        if (!isNullOrUndefined(this.owner) && !isNullOrUndefined(this.owner.beforePaste)) {
            // Create event args object
            const eventArgs: BeforePasteEventArgs = {
                cancel: false,
                pasteContent: pasteContent,
                pasteType: pasteType
            };
            // Trigger event
            this.owner.trigger(beforePaste, eventArgs);
            // Return false if canceled to prevent paste operation
            return eventArgs;
        }
        return undefined;
    }
    //Paste Implementation starts
    /**
     * Paste copied clipboard content on Paste event
     * @param {ClipboardEvent} event - Specifies the paste event
     * @param {any} pasteWindow - Specifies the paste window
     * @private
     */
    public pasteInternal(event: ClipboardEvent, pasteWindow?: any): void {
        this.currentPasteOptions = this.owner.defaultPasteOption;
        this.isHtmlPaste = false;
        if (this.documentHelper.owner.enableLocalPaste) {
            this.paste();
        } else {
            this.selection.isViewPasteOptions = true;
            if (this.selection.pasteElement) {
                this.selection.pasteElement.style.display = 'none';
            }
            if (isNullOrUndefined(pasteWindow)) {
                pasteWindow = window;
            }
            let textContent: string = '';
            let htmlContent: string = '';
            let rtfContent: string = '';
            let sfdtContent: string = '';
            let clipbordData: DataTransfer = pasteWindow.clipboardData ? pasteWindow.clipboardData : event.clipboardData;
            if (Browser.info.name !== 'msie') {
                rtfContent = clipbordData.getData('Text/Rtf');
                htmlContent = clipbordData.getData('Text/Html');
                sfdtContent = clipbordData.getData('application/json');
            }
            this.copiedTextContent = textContent = HelperMethods.sanitizeString(clipbordData.getData('Text'));

            this.previousCharFormat = new WCharacterFormat();
            this.previousCharFormat.copyFormat(this.selection.start.paragraph.characterFormat);
            this.previousParaFormat = new WParagraphFormat();
            this.previousParaFormat.copyFormat(this.selection.start.paragraph.paragraphFormat);
            if (this.documentHelper.protectionType === 'FormFieldsOnly' && this.documentHelper.selection.isInlineFormFillMode()) {
                htmlContent = '';
                rtfContent = '';
            }
            if (sfdtContent !== '') {
                this.isInternalPaste = true;
                this.type = '.sfdt';
                this.pasteFormattedContent({ data: JSON.parse(sfdtContent) });
                this.isInternalPaste = false;
            } else if (rtfContent !== '') {
                this.pasteAjax(rtfContent, '.rtf');
            } else if (htmlContent !== '') {
                this.isHtmlPaste = true;
                this.pasteAjax(htmlContent, '.html');
            } else if (textContent !== null && textContent !== '') {
                this.selection.currentPasteAction = 'TextOnly';
                this.type = '.text';
                let data: any = textContent;
                this.beforePasteEvent(data, this.type);
                this.applyPasteOptions(this.currentPasteOptions, true);
                this.copiedContent = undefined;
                this.documentHelper.editableDiv.innerHTML = '';
            } else if (Browser.info.name !== 'msie' && clipbordData.items !== undefined && clipbordData.items.length !== 0) {
                for (let m: number = 0; m < clipbordData.items.length; m++) {
                    let item: DataTransferItem = clipbordData.items[m];
                    if (item.type === 'image/png' || (item.type === "image/svg+xml" && item.kind !== 'string')) {
                        this.pasteImage(item.getAsFile());
                    }
                }
            } else if (Browser.info.name === 'msie' && clipbordData.files !== undefined && clipbordData.files.length !== 0 &&
                (clipbordData.files[0].type === 'image/png')) {
                this.pasteImage(clipbordData.files[0] as File);
            }
            // if (textContent !== '') {
            //     this.pasteContents(textContent);
            //     this.documentHelper.editableDiv.innerHTML = '';
            // }
        }
    }

    private pasteImage(imgFile: File): void {
        let fileReader: FileReader = new FileReader();
        fileReader.onload = (): void => {
            this.onPasteImage(fileReader.result as string);
        };
        fileReader.readAsDataURL(imgFile);
    }
    /**
     * @private
     * @returns {void}
     */
    public onPasteImage(data: string): void {
        let image: HTMLImageElement = document.createElement('img');
        let editor: Editor = this;
        image.addEventListener('load', function (): void {
            editor.insertImageInternal(data, true, this.width, this.height, this.alt);
        });
        image.src = data;
    }

    private pasteAjax(content: string, type: string): void {
        let proxy: Editor = this;
        /* eslint-disable @typescript-eslint/no-explicit-any */
        let formObject: any = {
            content: content,
            type: type
        };
        this.type = type;
        let editor: any = this;
        this.pasteRequestHandler = new XmlHttpRequestHandler();
        this.owner.documentHelper.viewerContainer.focus();
        showSpinner(this.owner.element);
        this.pasteRequestHandler.url = proxy.owner.serviceUrl + this.owner.serverActionSettings.systemClipboard;
        this.pasteRequestHandler.responseType = 'json';
        this.pasteRequestHandler.contentType = 'application/json;charset=UTF-8';
        this.pasteRequestHandler.customHeaders = proxy.owner.headers;
        this.pasteRequestHandler.onSuccess = this.pasteFormattedContent.bind(this);
        this.pasteRequestHandler.onFailure = this.onPasteFailure.bind(this);
        this.pasteRequestHandler.onError = this.onPasteFailure.bind(this);
        const httprequestEventArgs: XmlHttpRequestEventArgs = { serverActionType: 'SystemClipboard', headers: this.owner.headers, timeout: 0, cancel: false, withCredentials: false, clipboardData: formObject };
        this.owner.trigger(beforeXmlHttpRequestSend, httprequestEventArgs);
        if (httprequestEventArgs.cancel) {
            hideSpinner(this.owner.element);
        } else {
            this.pasteRequestHandler.send(formObject, httprequestEventArgs);
        }
    }
    private getPasteTypeFromFileExtension(fileExtension: string): PasteType {
        switch (fileExtension) {
            case '.html':
                return 'Html';
            case '.rtf':
                return 'Rtf';
            case '.sfdt':
                return 'Sfdt';
            default:
                return 'Text';
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public pasteFormattedContent(result: any): void {
        if (this.isPasteListUpdated) {
            this.isPasteListUpdated = false;
        }
        let data: any = result.data == null ? this.copiedTextContent : result.data instanceof Object ? JSON.stringify(result.data) : result.data;
        this.beforePasteEvent(data, this.type);
        if (this.currentPasteOptions !== 'KeepSourceFormatting') {
            this.applyPasteOptions(this.currentPasteOptions);
        }
        hideSpinner(this.owner.element);
        setTimeout((): void => {
            if (!isNullOrUndefined(this.viewer)) {
                this.documentHelper.isScrollHandler = true;
                this.isPasteContentCheck = true;
                this.viewer.updateScrollBars();
                this.documentHelper.isScrollHandler = false;
                this.isPasteContentCheck = false;
            }
        }, 0);
    }
    private beforePasteEvent(data: any, type: any){
        let eventArgs: BeforePasteEventArgs = this.triggerBeforePasteEvent(isNullOrUndefined(data) ? this.copiedTextContent : data, this.getPasteTypeFromFileExtension(type));
        if (eventArgs && eventArgs.cancel) {
            hideSpinner(this.owner.element);
            return;
        }
        if (eventArgs) {
            if (isNullOrUndefined(eventArgs.pasteContent)) {
                alert("Provide valid paste content");
            }
            else {
                data = eventArgs.pasteContent;
            }
        }
        try {
            // Parse the SFDT content and perform paste if it's valid; otherwise, fallback to plain text paste.
            const parsedData = JSON.parse(data);
            this.pasteContents(HelperMethods.getSfdtDocument(parsedData));
        } catch {
            this.pasteContents(isNullOrUndefined(data) ? this.copiedTextContent : data);
        }
    }
    private onPasteFailure(result: any): void {
        this.owner.fireServiceFailure(result);
        console.error(result.status, result.statusText);
        hideSpinner(this.owner.element);
        this.documentHelper.updateFocus();
    }

    /**
     * Pastes the provided content into the editor.
     *
     * @param {string} [sfdt] - The content to be pasted, in string format.
     * @param {TablePasteOptions} [tablePasteOption] - The option specifying how the content should be pasted into a table.
     *
     * @returns {void}
     */
    public paste(sfdt: string, tablePasteOption: TablePasteOptions): void;

    /**
     * Pastes the provided sfdt content or the data present in local clipboard if any.
     *
     * @param {string} sfdt Specifies the sfdt content to paste at current position.
     * @param {PasteOptions} defaultPasteOption Specifies the paste options.
     * @returns {void}
     */
    public paste(sfdt?: string, defaultPasteOption?: PasteOptions): void;

    public paste(sfdt?: string, defaultPasteOption?: PasteOptions | TablePasteOptions): void {
        if (isNullOrUndefined(sfdt)) {
            sfdt = this.owner.enableLocalPaste ? this.copiedData : undefined;
        }
        if (!isNullOrUndefined(defaultPasteOption)) {
            this.currentPasteOptions = defaultPasteOption;
        }
        let isPaste: boolean = this.canEditContentControl ? true : false;
        if (!this.canEditContentControl && this.owner.editorHistoryModule && this.owner.editorHistoryModule.currentHistoryInfo
            && this.owner.editorHistoryModule.currentHistoryInfo.action === 'InsertContentControl') {
            isPaste = true;
        }
        /* eslint-disable @typescript-eslint/no-explicit-any */
        if (sfdt && isPaste) {
            let document: any = HelperMethods.getSfdtDocument(sfdt);
            this.pasteContents(document, null, defaultPasteOption);
            this.applyPasteOptions(this.currentPasteOptions);
            this.currentPasteOptions = undefined;
            if (this.chartType) {
                setTimeout((): void => {
                    if (!isNullOrUndefined(this.viewer)) {
                        this.viewer.updateScrollBars();
                    }
                }, 30);
                this.chartType = false;
            }
        }
    }
    /**
     * @private
     */
    public getUniqueListOrAbstractListId(isList: boolean): number {
        if (isList && this.documentHelper.lists.length) {
            let sortedList: WList[] = this.documentHelper.lists.slice().sort((a: any, b: any) => {
                return a.listId - b.listId;
            });
            return sortedList[sortedList.length - 1].listId + 1;
        } else if (this.documentHelper.abstractLists.length) {
            let sortedAbsList: WAbstractList[] = this.documentHelper.abstractLists.slice().sort((a: any, b: any) => {
                return a.abstractListId - b.abstractListId;
            });
            return sortedAbsList[sortedAbsList.length - 1].abstractListId + 1;
        }
        return 0;
    }

    private getBlocksToUpdate(blocks: any): any[] {
        let blcks: any[] = [];
        for (let i: number = 0; i < blocks.length; i++) {
            let obj: any = blocks[i];
            if (obj[paragraphFormatProperty[this.keywordIndex]] && obj[paragraphFormatProperty[this.keywordIndex]][listFormatProperty[this.keywordIndex]]
                && Object.keys(obj[paragraphFormatProperty[this.keywordIndex]][listFormatProperty[this.keywordIndex]]).length > 0) {
                blcks.push(obj);
            } else if (obj[rowsProperty[this.keywordIndex]]) {
                for (let j: number = 0; j < obj[rowsProperty[this.keywordIndex]].length; j++) {
                    let currentRow: any = obj[rowsProperty[this.keywordIndex]][j];
                    for (let k: number = 0; k < currentRow[cellsProperty[this.keywordIndex]].length; k++) {
                        let cell: any = currentRow[cellsProperty[this.keywordIndex]][k];
                        blcks = blcks.concat(this.getBlocksToUpdate(cell[blocksProperty[this.keywordIndex]]));
                    }
                }
            }
        }
        return blcks;
    }
    private updateListIdForBlocks(blocks: any, abstractList: any, list: WList, id: number, idToUpdate: number, isPrevParaListFormat?: boolean, uniqueNsid?: number): boolean {
        let update: boolean = false;
        for (let i: number = 0; i < blocks.length; i++) {
            let obj: any = blocks[i];
            if (obj[paragraphFormatProperty[this.keywordIndex]] && obj[paragraphFormatProperty[this.keywordIndex]][listFormatProperty[this.keywordIndex]]
                && Object.keys(obj[paragraphFormatProperty[this.keywordIndex]][listFormatProperty[this.keywordIndex]]).length > 0) {
                let format: any = obj[paragraphFormatProperty[this.keywordIndex]][listFormatProperty[this.keywordIndex]];
                let existingList: WList = this.isNsIdMatchWithExistingAbstractList(abstractList[nsidProperty])
                if (format[listIdProperty[this.keywordIndex]] === id) {
                    if (isNullOrUndefined(existingList)) {
                        update = true;
                        format[listIdProperty[this.keywordIndex]] = idToUpdate;
                    } else if (isPrevParaListFormat) {
                        update = true;
                        format[listIdProperty[this.keywordIndex]] = idToUpdate;
                        format[nsidProperty] = uniqueNsid;
                    } else {
                        if (!format.isUpdated) {
                            format[listIdProperty[this.keywordIndex]] = existingList.listId;
                            format.isUpdated = true;
                        }
                        update = false;
                    }
                }
            } else if (obj[rowsProperty[this.keywordIndex]]) {
                for (let j: number = 0; j < obj[rowsProperty[this.keywordIndex]].length; j++) {
                    let row: any = obj[rowsProperty[this.keywordIndex]][j];
                    for (let k: number = 0; k < row[cellsProperty[this.keywordIndex]].length; k++) {
                        let cell: any = row[cellsProperty[this.keywordIndex]][k];
                        let toUpdate: boolean = this.updateListIdForBlocks(cell[blocksProperty[this.keywordIndex]], abstractList, list, id, idToUpdate);
                        if (!update) {
                            update = toUpdate;
                        }
                    }
                }
            }
        }

        return update;
    }
    private isNsIdMatchWithExistingAbstractList(nsid: number): WList {
        for (let i: number = 0; i < this.documentHelper.lists.length; i++) {
            let list: WList = this.documentHelper.lists[i];
            if (list.abstractList.nsid === nsid) {
                return list;
            }
        }
        return undefined;
    }
    private updatePasteContent(pasteContent: any, sectionId: number): void {
        let uniqueListId: number = this.getUniqueListOrAbstractListId(true);

        if (pasteContent[listsProperty[this.keywordIndex]].filter((obj: any): any => { return obj[listIdProperty[this.keywordIndex]] === uniqueListId; }).length > 0) {
            let sortedPasteList: any[] = pasteContent[listsProperty[this.keywordIndex]].slice().sort((a: any, b: any) => {
                return a[listIdProperty[this.keywordIndex]] - b[listIdProperty[this.keywordIndex]];
            });
            uniqueListId = sortedPasteList[sortedPasteList.length - 1][listIdProperty[this.keywordIndex]] + 1;
        }
        let uniqueAbsLstId: number = this.getUniqueListOrAbstractListId(false);
        if (pasteContent[abstractListsProperty[this.keywordIndex]].filter((obj: any): any => {
            return obj[abstractListIdProperty[this.keywordIndex]] === uniqueAbsLstId;
        }).length > 0) {
            let sortedPasteAbsList: any[] = pasteContent[abstractListsProperty[this.keywordIndex]].slice().sort((a: any, b: any) => {
                return a[abstractListIdProperty[this.keywordIndex]] - b[abstractListIdProperty[this.keywordIndex]];
            });
            uniqueAbsLstId = sortedPasteAbsList[sortedPasteAbsList.length - 1][abstractListIdProperty[this.keywordIndex]] + 1;
        }
        const pastedListCount: number = pasteContent[listsProperty[this.keywordIndex]].length;
        for (let k: number = 0; k < pasteContent[listsProperty[this.keywordIndex]].length; k++) {
            let list: WList = pasteContent[listsProperty[this.keywordIndex]][k];
            let abstractList: any = pasteContent[abstractListsProperty[this.keywordIndex]].filter((obj: any) => {
                return obj[abstractListIdProperty[this.keywordIndex]] === list[abstractListIdProperty[this.keywordIndex]];
            })[0];
            let lstDup: WList[] = this.documentHelper.lists.filter((obj: WList) => {
                return obj.listId === list[listIdProperty[this.keywordIndex]];
            });
            if (!isNullOrUndefined(abstractList)) {
                let isPrevParaListFormat: boolean = false;
                let uniqueNsid: number = 0;
                if (!isNullOrUndefined(this.selection) && !isNullOrUndefined(this.selection.start.paragraph)) {
                    if (this.selection.start.paragraph.paragraphFormat.listFormat.listId !== -1) {
                        isPrevParaListFormat = false;
                    }
                    else {
                        isPrevParaListFormat = this.getPreviousParagraphListFormat(this.selection.start.paragraph, pastedListCount);
                        if (isPrevParaListFormat) {
                            uniqueNsid = HelperMethods.generateUniqueId(this.documentHelper.lists);
                        }
                    }
                }
                let isUpdate: boolean = this.updateListIdForBlocks(pasteContent[sectionsProperty[this.keywordIndex]][sectionId][blocksProperty[this.keywordIndex]], abstractList, lstDup[0], list[listIdProperty[this.keywordIndex]], uniqueListId, isPrevParaListFormat, uniqueNsid);
                if (isUpdate) {
                    let absListId: number = abstractList[abstractListIdProperty[this.keywordIndex]];
                    // iterate the list object from pasteContent and update the abstractListId with new value.
                    for (let i: number = 0; i < pasteContent[listsProperty[this.keywordIndex]].length; i++) {
                        let listObj: any = pasteContent[listsProperty[this.keywordIndex]][i];
                        if (listObj[abstractListIdProperty[this.keywordIndex]] === absListId) {
                            listObj[abstractListIdProperty[this.keywordIndex]] = uniqueAbsLstId;
                        }
                    }
                    abstractList[abstractListIdProperty[this.keywordIndex]] = uniqueAbsLstId;
                    list[listIdProperty[this.keywordIndex]] = uniqueListId;
                    if (isPrevParaListFormat && uniqueNsid !== 0) {
                        abstractList[nsidProperty] = list[nsidProperty] = uniqueNsid;
                    }
                    uniqueListId++;
                    uniqueAbsLstId++;
                } else {
                    pasteContent[listsProperty[this.keywordIndex]].splice(k, 1);
                    pasteContent[abstractListsProperty[this.keywordIndex]].splice(pasteContent[abstractListsProperty[this.keywordIndex]].indexOf(abstractList), 1);
                    k--;
                }
            }
        }
        let blocks: any[] = this.getBlocksToUpdate(pasteContent[sectionsProperty[this.keywordIndex]][sectionId][blocksProperty[this.keywordIndex]]);
        for (let i: number = 0; i < blocks.length; i++) {
            let blck: any = blocks[i];
            delete blck[paragraphFormatProperty[this.keywordIndex]][listFormatProperty[this.keywordIndex]].isUpdated;
        }
    }
    private getPreviousParagraphListFormat(paragraph: ParagraphWidget, pastedListCount: number): boolean {
        if (!isNullOrUndefined(this.documentHelper.layout)) {
            let previousParagraph: ParagraphWidget = this.selection.getPreviousParagraphBlock(paragraph);
            while (!isNullOrUndefined(previousParagraph) && (previousParagraph.isEmpty() || !this.documentHelper.layout.hasValidElement(previousParagraph))) {
                previousParagraph = this.selection.getPreviousParagraphBlock(previousParagraph)
            }
            if (!isNullOrUndefined(previousParagraph) && previousParagraph.paragraphFormat.listFormat.listId === -1 && pastedListCount === 1) {
                return true;
            }
        }
        return false;
    }
    /**
     * @private
     */

    public getBlocks(pasteContent: any, isPaste: boolean, sections?: BodyWidget[], comments?: CommentElementBox[], revision?: Revision[], isContextBasedPaste?: boolean): BodyWidget[] {
        let widgets: BodyWidget[] = [];
        if (typeof (pasteContent) === 'string') {
            let startParagraph: ParagraphWidget = this.selection.start.paragraph;
            if (!this.selection.isForward) {
                startParagraph = this.selection.end.paragraph;
            }
            let arr: string[] = [];
            let txt: string = pasteContent;
            txt = txt.replace(/\r?\n/g, '\r');
            arr = txt.split('\r');
            let widget: BlockWidget[] = [];
            let bodyWidget: BodyWidget = new BodyWidget();
            bodyWidget.sectionFormat = new WSectionFormat(bodyWidget);
            bodyWidget.childWidgets = widget;
            for (let i: number = 0; i < arr.length; i++) {
                if (i === arr.length - 1 && arr[i].length === 0 && !this.isInsertText) {
                    continue;
                }
                let currentInline: ElementInfo = this.selection.start.currentWidget.getInline(this.selection.start.offset, 0);
                let element: ElementBox = this.selection.getPreviousValidElement(currentInline.element);
                if (element !== currentInline.element) {
                    element = this.documentHelper.getNextValidElement(currentInline.element);
                }
                let insertFormat: WCharacterFormat;
                if (startParagraph.isEmpty()) {
                    insertFormat = startParagraph.characterFormat;
                } else if (!isNullOrUndefined(element) && !this.isInsertText) {
                    insertFormat = element.characterFormat;
                } else {
                    this.copyInsertFormat(startParagraph.characterFormat, false);
                }
                let insertParaFormat: WParagraphFormat;
                if (this.isInsertText && !this.selection.isEmpty) {
                    insertParaFormat = new WParagraphFormat();
                    insertParaFormat.copyFormat(this.selection.end.paragraph.paragraphFormat)
                } else {
                    insertParaFormat = this.documentHelper.selection.copySelectionParagraphFormat();
                }
                if (!isNullOrUndefined(this.previousParaFormat)) {
                    insertParaFormat = this.previousParaFormat;
                }
                let paragraph: ParagraphWidget = new ParagraphWidget();
                paragraph.paragraphFormat.copyFormat(insertParaFormat);
                let line: LineWidget = new LineWidget(paragraph);
                if (arr[i].length > 0) {
                    //Too many character in single line it took time past the content will cause layout performance, so spliting by space.
                    var words = arr[i].split(/(\s+)/);
                    for (var j = 0; j < words.length; j++) {
                        let textElement: TextElementBox = new TextElementBox();
                        textElement.characterFormat.copyFormat(insertFormat);
                        textElement.text = words[j];
                        line.children.push(textElement);
                        textElement.line = line;
                    }
                }
                paragraph.childWidgets.push(line);
                paragraph.containerWidget = bodyWidget;
                widget.push(paragraph);
            }
            widgets.push(bodyWidget);
        } else {
            let parser: SfdtReader = this.documentHelper.owner.parser;
            parser.keywordIndex = this.keywordIndex;
            parser.isPaste = isPaste;
            parser.isContextBasedPaste = !isNullOrUndefined(isContextBasedPaste)? isContextBasedPaste: false;
            parser.isHtmlPaste = this.isHtmlPaste;
            if (!isContextBasedPaste) {
                parser.addCustomStyles(pasteContent);
                if (pasteContent[commentsProperty[this.keywordIndex]] && pasteContent[commentsProperty[this.keywordIndex]].length > 0) {
                    parser.commentsCollection = new Dictionary<string, CommentElementBox>();
                    parser.commentStarts = new Dictionary<string, CommentCharacterElementBox>();
                    parser.commentEnds = new Dictionary<string, CommentCharacterElementBox>();
                    parser.parseComments(pasteContent, comments ? comments : this.documentHelper.comments);
                }
                if (pasteContent[customXmlProperty[this.keywordIndex]] && pasteContent[customXmlProperty[this.keywordIndex]].length > 0) {
                    parser.parseCustomXml(pasteContent);
                }
            }
            let bodyWidget: BodyWidget;
            this.selection.currentPasteAction = 'DefaultPaste';
            for (let i: number = 0; i < pasteContent[sectionsProperty[this.keywordIndex]].length; i++) {
                if(!isContextBasedPaste) { 
                if (!this.isPasteListUpdated && !isNullOrUndefined(pasteContent[listsProperty[this.keywordIndex]])) {
                    if (this.documentHelper.lists.length > 0) {
                        this.updatePasteContent(pasteContent, i);
                    }
                    this.isPasteListUpdated = true;
                    if (!isNullOrUndefined(pasteContent[abstractListsProperty[this.keywordIndex]])) {
                        parser.parseAbstractList(pasteContent, this.documentHelper.abstractLists);
                    }
                    if (!isNullOrUndefined(pasteContent[listsProperty[this.keywordIndex]])) {
                        parser.parseList(pasteContent, this.documentHelper.lists);
                    }
                }
                if (!isNullOrUndefined(pasteContent[revisionsProperty[this.keywordIndex]])) {
                    if (isPaste) {
                        let revisionChanges: Revision[] = this.viewer.owner.revisionsInternal.changes;
                        if (!isNullOrUndefined(parser.revisionCollection)) {
                            parser.revisionCollection = undefined;
                        }
                        if (this.isRemoteAction) {
                            parser.revisionCollection = this.documentHelper.revisionsInternal;
                        } else {
                            parser.revisionCollection = new Dictionary<string, Revision>();
                        }
                        let revisionCollection: Dictionary<string, Revision> = parser.revisionCollection;
                        if (!(this.documentHelper.owner.sfdtExportModule.copyWithTrackChange && parser.isCutPerformed)) {
                            if (pasteContent[revisionsProperty[this.keywordIndex]].length >= 1) {
                                for (let i: number = 0; i < pasteContent[revisionsProperty[this.keywordIndex]].length; i++) {
                                    if (!revisionCollection.containsKey(pasteContent[revisionsProperty[this.keywordIndex]][i][revisionIdProperty[this.keywordIndex]])) {
                                        parser.parseRevisions(pasteContent, []);
                                    }
                                }
                            }
                        }
                        this.documentHelper.owner.sfdtExportModule.copyWithTrackChange = false;
                    } else {
                        parser.revisionCollection = this.documentHelper.revisionsInternal;
                        parser.parseRevisions(pasteContent, revision);
                        }
                    }
                }
                bodyWidget = new BodyWidget();
                bodyWidget.sectionFormat = new WSectionFormat(bodyWidget);
                if (!isPaste || isContextBasedPaste) {
                    sections.unshift(bodyWidget);
                } else {
                    widgets.push(bodyWidget);
                }
                if (isPaste && !isContextBasedPaste && !isNullOrUndefined(pasteContent[stylesProperty[this.keywordIndex]])) {
                    for (var j = 0; j < pasteContent[stylesProperty[this.keywordIndex]].length; j++) {
                        let styleName: string = pasteContent[stylesProperty[this.keywordIndex]][j][nameProperty[this.keywordIndex]];
                        let style: WStyle = this.documentHelper.styles.findByName(styleName) as WStyle;
                        if (isNullOrUndefined(style)) {
                            parser.parseStyle(pasteContent, pasteContent[stylesProperty[this.keywordIndex]][j], this.documentHelper.styles)
                        }
                    }
                }
                parser.parseBody(pasteContent[sectionsProperty[this.keywordIndex]][i][blocksProperty[this.keywordIndex]], bodyWidget.childWidgets as BlockWidget[], undefined, undefined, undefined, pasteContent[stylesProperty[this.keywordIndex]]);
                if (((pasteContent[lastParagraphMarkCopiedProperty[this.keywordIndex]] || this.owner.enableLocalPaste) && this.selection.start.paragraph.isEmpty() && this.documentHelper.pages.length == 1 && this.documentHelper.pages[0].bodyWidgets[0].childWidgets.length == 1)
                    || (pasteContent[sectionsProperty[this.keywordIndex]][i][sectionFormatProperty[this.keywordIndex]]
                        && pasteContent[sectionsProperty[this.keywordIndex]][i][sectionFormatProperty[this.keywordIndex]][numberOfColumnsProperty[this.keywordIndex]] > 1) || (pasteContent[sectionsProperty[this.keywordIndex]][i][sectionFormatProperty[this.keywordIndex]]
                            && pasteContent[sectionsProperty[this.keywordIndex]][i][sectionFormatProperty[this.keywordIndex]][breakCodeProperty[this.keywordIndex]] === 'NoBreak')) {
                    parser.parseSectionFormat(this.keywordIndex, pasteContent[sectionsProperty[this.keywordIndex]][i][sectionFormatProperty[this.keywordIndex]], bodyWidget.sectionFormat);
                }
                if (isPaste && !this.isRemoteAction && !isNullOrUndefined(comments)) {
                    let existingCommentIds: string[] = [];
                    for (let i: number = 0; i < this.documentHelper.comments.length; i++) {
                        existingCommentIds.push(this.documentHelper.comments[i].commentId);
                    }
                    // Updating unique Comment Id when pasting the comments with existingCommentId.
                    for (let j: number = 0; j < comments.length; j++) {
                        let comment: CommentElementBox = comments[j];
                        if (existingCommentIds.indexOf(comment.commentId) !== -1 && !isNullOrUndefined(comment.commentStart) && !isNullOrUndefined(comment.commentEnd)) {
                            let newCommentId: string = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
                            comment.commentId = comment.commentStart.commentId = comment.commentEnd.commentId = newCommentId;
                        }
                        this.documentHelper.comments.push(comment);
                    }
                }
                parser.isPaste = false;
                parser.isHtmlPaste = false;
                parser.isContextBasedPaste = false;
            }
            if ((pasteContent[lastParagraphMarkCopiedProperty[this.keywordIndex]] && !isContextBasedPaste) || this.owner.documentEditorSettings.pasteAsNewParagraph) {
                this.isLastParaMarkCopied = true;
                let paragraphWidget: ParagraphWidget = new ParagraphWidget();
                bodyWidget.childWidgets.push(paragraphWidget);
            }
        }
        if (this.currentPasteOptions === 'MergeWithExistingFormatting' && !isContextBasedPaste) {
            this.applyMergeFormat(widgets);
        }
        return widgets;
    }
    private applyMergeFormat(bodyWidgets: BodyWidget[]): void {
        let startParagraph: ParagraphWidget = this.selection.start.paragraph;
        let currentInline: ElementInfo = this.selection.start.currentWidget.getInline(this.selection.start.offset, 0);
        let element: ElementBox = this.selection.getPreviousValidElement(currentInline.element);
        let insertFormat: WCharacterFormat = new WCharacterFormat();
        if (!isNullOrUndefined(element) && element.contentControlProperties) {
            insertFormat = this.copyInsertFormat(new WCharacterFormat(), false);
        } else {
            insertFormat = element ? element.characterFormat : this.copyInsertFormat(startParagraph.characterFormat, true, startParagraph);
        }
        let insertParaFormat: SelectionParagraphFormat = this.documentHelper.selection.paragraphFormat;
        for (let k: number = 0; k < bodyWidgets.length; k++) {
            let widgets: BlockWidget[] = bodyWidgets[k].childWidgets as BlockWidget[];
            for (let i: number = 0; i < widgets.length; i++) {
                let widget: BlockWidget = widgets[i];
                if (widget instanceof ParagraphWidget) {
                    this.applyParaFormatInternal(widget.paragraphFormat, insertParaFormat);
                    this.applyFormatInternal(widget, insertFormat);
                } else {
                    for (let j: number = 0; j < widget.childWidgets.length; j++) {
                        let row: TableRowWidget = widget.childWidgets[j] as TableRowWidget;
                        for (let k: number = 0; k < row.childWidgets.length; k++) {
                            let cell: TableCellWidget = row.childWidgets[k] as TableCellWidget;
                            for (let l: number = 0; l < cell.childWidgets.length; l++) {
                                this.applyFormatInternal(cell.childWidgets[l] as BlockWidget, insertFormat);
                            }
                        }
                    }
                }
            }
        }
    }

    private applyParaFormatInternal(paragraphFormat: WParagraphFormat, insertedParaFormat: SelectionParagraphFormat): void {
        if (!isNullOrUndefined(insertedParaFormat.leftIndent)) {
            paragraphFormat.leftIndent = insertedParaFormat.leftIndent;
        }
        if (!isNullOrUndefined(insertedParaFormat.rightIndent)) {
            paragraphFormat.rightIndent = insertedParaFormat.rightIndent;
        }
        if (!isNullOrUndefined(insertedParaFormat.firstLineIndent)) {
            paragraphFormat.firstLineIndent = insertedParaFormat.firstLineIndent;
        }
        if (!isNullOrUndefined(insertedParaFormat.textAlignment)) {
            paragraphFormat.textAlignment = insertedParaFormat.textAlignment;
        } else {
            paragraphFormat.textAlignment = 'Left';
        }
        if (!isNullOrUndefined(insertedParaFormat.outlineLevel)) {
            paragraphFormat.outlineLevel = insertedParaFormat.outlineLevel;
        } else {
            paragraphFormat.outlineLevel = 'BodyText';
        }
        if (insertedParaFormat.beforeSpacing === -1) {
            paragraphFormat.beforeSpacing = 0;
        } else {
            paragraphFormat.beforeSpacing = insertedParaFormat.beforeSpacing;
        }
        if (insertedParaFormat.afterSpacing === -1) {
            paragraphFormat.afterSpacing = 0;
        } else {
            paragraphFormat.afterSpacing = insertedParaFormat.afterSpacing;
        }
        if (insertedParaFormat.lineSpacing === 0) {
            paragraphFormat.lineSpacing = 1;
        } else {
            paragraphFormat.lineSpacing = insertedParaFormat.lineSpacing;
        }
        if (!isNullOrUndefined(insertedParaFormat.lineSpacingType)) {
            paragraphFormat.lineSpacingType = insertedParaFormat.lineSpacingType;
        }
        if (!isNullOrUndefined(insertedParaFormat.bidi)) {
            paragraphFormat.bidi = insertedParaFormat.bidi;
        }
        if (!isNullOrUndefined(insertedParaFormat.spaceAfterAuto)) {
            paragraphFormat.spaceAfterAuto = insertedParaFormat.spaceAfterAuto;
        }
        if (!isNullOrUndefined(insertedParaFormat.spaceBeforeAuto)) {
            paragraphFormat.spaceBeforeAuto = insertedParaFormat.spaceBeforeAuto;
        }
        if (!isNullOrUndefined(insertedParaFormat.keepWithNext)) {
            paragraphFormat.keepWithNext = insertedParaFormat.keepWithNext;
        }
        if (!isNullOrUndefined(insertedParaFormat.keepLinesTogether)) {
            paragraphFormat.keepLinesTogether = insertedParaFormat.keepLinesTogether;
        }
        if (!isNullOrUndefined(insertedParaFormat.widowControl)) {
            paragraphFormat.widowControl = insertedParaFormat.widowControl;
        }
        if (!isNullOrUndefined(insertedParaFormat.contextualSpacing)) {
            paragraphFormat.contextualSpacing = insertedParaFormat.contextualSpacing;
        }
        if (paragraphFormat.tabs) {
            paragraphFormat.tabs = [];
        }
    }

    private applyFormatInternal(widget: BlockWidget, insertFormat: WCharacterFormat): void {
        if (widget instanceof ParagraphWidget) {
            for (let j: number = 0; j < widget.childWidgets.length; j++) {
                let lineWidget: LineWidget = widget.childWidgets[j] as LineWidget;
                for (let k: number = 0; k < lineWidget.children.length; k++) {
                    let inlineCharacterFormat: WCharacterFormat = lineWidget.children[k].characterFormat;
                    let characterFormat: WCharacterFormat = inlineCharacterFormat.cloneFormat();
                    if (characterFormat.bold) {
                        lineWidget.children[k].characterFormat.bold = characterFormat.bold;
                    }
                    if (characterFormat.italic) {
                        lineWidget.children[k].characterFormat.italic = characterFormat.italic;
                    }
                    if (characterFormat.underline !== 'None') {
                        lineWidget.children[k].characterFormat.underline = characterFormat.underline;
                    }
                    if (this.currentPasteOptions === 'MergeWithExistingFormatting' && !isNullOrUndefined(insertFormat)) {
                        if (insertFormat.bold) {
                            lineWidget.children[k].characterFormat.bold = insertFormat.bold;
                        }
                        if (insertFormat.italic) {
                            lineWidget.children[k].characterFormat.italic = insertFormat.italic;
                        }
                        if (insertFormat.underline !== 'None') {
                            lineWidget.children[k].characterFormat.underline = insertFormat.underline;
                        }
                        if (lineWidget.children[k].characterFormat.fontColor !== insertFormat.fontColor) {
                            lineWidget.children[k].characterFormat.fontColor = insertFormat.fontColor;
                        }
                        if (lineWidget.children[k].characterFormat.highlightColor !== insertFormat.highlightColor) {
                            lineWidget.children[k].characterFormat.highlightColor = insertFormat.highlightColor;
                        }
                        if (lineWidget.children[k].characterFormat.fontSize !== insertFormat.fontSize) {
                            lineWidget.children[k].characterFormat.fontSize = insertFormat.fontSize;
                            lineWidget.children[k].characterFormat.fontSizeBidi = insertFormat.fontSizeBidi;
                        }
                        if (lineWidget.children[k].characterFormat.fontFamily !== insertFormat.fontFamily) {
                            lineWidget.children[k].characterFormat.fontFamily = insertFormat.fontFamily;
                            lineWidget.children[k].characterFormat.fontFamilyBidi = insertFormat.fontFamilyBidi;
                        }
                        if (lineWidget.children[k].characterFormat.fontFamilyAscii !== insertFormat.fontFamilyAscii) {
                            lineWidget.children[k].characterFormat.fontFamilyAscii = insertFormat.fontFamilyAscii;
                        }
                        if (lineWidget.children[k].characterFormat.fontFamilyFarEast !== insertFormat.fontFamilyFarEast) {
                            lineWidget.children[k].characterFormat.fontFamilyFarEast = insertFormat.fontFamilyFarEast;
                        }
                        if (lineWidget.children[k].characterFormat.fontFamilyAscii !== insertFormat.fontFamilyAscii) {
                            lineWidget.children[k].characterFormat.fontFamilyAscii = insertFormat.fontFamilyAscii;
                        }
                    }
                }
            }
        } else {
            for (let j: number = 0; j < widget.childWidgets.length; j++) {
                let rowWidget: TableRowWidget = widget.childWidgets[j] as TableRowWidget;
                for (let k: number = 0; k < rowWidget.childWidgets.length; k++) {
                    let cellWidget: TableCellWidget = rowWidget.childWidgets[k] as TableCellWidget;
                    for (let l: number = 0; l < cellWidget.childWidgets.length; l++) {
                        this.applyFormatInternal(cellWidget.childWidgets[l] as BlockWidget, insertFormat);
                    }
                }
            }
        }
    }

    /**
     * @private
     */
    public applyPasteOptions(options: PasteOptions | TablePasteOptions, isPasteOptionTextOnly?: boolean): void {
        if (isNullOrUndefined(this.copiedContent) || this.copiedTextContent === '' || isPasteOptionTextOnly) {
            return;
        }
        //this.isSkipHistory = true;
        this.currentPasteOptions = options;
        let start: TextPosition = this.selection.isForward ? this.selection.start : this.selection.end;
        let currentFormat: WParagraphFormat = start.paragraph.paragraphFormat;
        let copiedContent: any = this.copiedContent;
        let copiedTextContent: string = this.copiedTextContent;
        if (this.editorHistory && this.editorHistory.canUndo()) {
            this.editorHistory.undo();
            this.editorHistory.redoStack.pop();
        }
        this.copiedContent = copiedContent;
        this.copiedTextContent = copiedTextContent;
        this.selection.isViewPasteOptions = true;
        // }
        switch (options) {
            case 'KeepSourceFormatting':
                this.pasteContents(this.copiedContent !== '' ? this.copiedContent : this.copiedTextContent);
                break;
            case 'MergeWithExistingFormatting':
                this.pasteContents(this.copiedContent !== '' ? this.copiedContent : this.copiedTextContent, currentFormat);
                break;
            case 'KeepTextOnly':
                this.pasteContents(this.copiedTextContent);
                break;
        }
        //this.isSkipHistory = false;
    }

    /**
     * @private
     */
    public applyTablePasteOptions(options: TablePasteOptions): void {
        if (isNullOrUndefined(this.copiedContent) || this.copiedTextContent === '') {
            return;
        }
        this.isPaste = true;
        let copiedContent: object = this.copiedContent !== '' ? this.copiedContent : this.copiedTextContent;
        if (this.editorHistory && this.editorHistory.canUndo()) {
            // this.isSkipOperationsBuild = this.owner.enableCollaborativeEditing;
            this.editorHistory.undo();
            this.editorHistory.redoStack.pop();
            // this.isSkipOperationsBuild = false;
        }
        let widgets: BodyWidget[] = this.getBlocks(copiedContent, true);
        let currentFormat: WParagraphFormat = this.selection.start.paragraph.paragraphFormat;
        switch (options) {
            case 'NestTable':
                this.pasteAsNestedTable(widgets, currentFormat);
                break;
            case 'InsertAsRows':
                this.pasteAsNewRow(widgets[0].childWidgets[0] as TableWidget);
                break;
            case 'InsertAsColumns':
                this.pasteAsNewColumn(widgets[0].childWidgets[0] as TableWidget);
                break;
            case 'OverwriteCells':
                this.pasteOverwriteCell(widgets[0].childWidgets[0] as TableWidget);
                break;
        }
        this.isPaste = false;
    }

    /**
     * @private
     * @returns {void}
     */
    public pasteContents(content: any, currentFormat?: WParagraphFormat, pasteOptions?: PasteOptions | TablePasteOptions): void {
        if (!isNullOrUndefined(content.optimizeSfdt) && content.optimizeSfdt) {
            this.keywordIndex = 1;
        } else {
            this.keywordIndex = 0;
        }
        if (typeof (content) !== 'string') {
            this.copiedContent = content;
        }
        if (!isNullOrUndefined(this.documentHelper)) {
            if (this.documentHelper.protectionType === 'FormFieldsOnly' && this.documentHelper.selection.isInlineFormFillMode()) {
                let inline: FieldElementBox = this.selection.getCurrentFormField();
                let resultText: string = this.getFieldResultText();
                let maxLength: number = (inline.formFieldData as TextFormField).maxLength;
                let selectedTextLength: number = this.documentHelper.selection.text.length;
                if (maxLength > 0) {
                    if (selectedTextLength === 0) {
                        let contentlength: number = maxLength - resultText.length;
                        content = content.substring(0, contentlength);
                    } else if (selectedTextLength > 0) {
                        content = content.substring(0, selectedTextLength);
                    }
                }
            }
            if (!isNullOrUndefined(content[imagesProperty[this.keywordIndex]])) {
                let images = content[imagesProperty[this.keywordIndex]];
                if (this.documentHelper.images.length > 0) {
                    this.pasteImageIndex = new Dictionary();
                    let newImages = {};
                    for (let img in images) {
                        let newIndex = (Math.max(...this.documentHelper.images.keys) + 1) + parseInt(img);
                        newImages[newIndex] = images[img];
                        this.pasteImageIndex.add(img, newIndex.toString());
                    }
                    images = newImages;
                }
                this.documentHelper.owner.parser.parseImages(images);
            }
            let pastedComments: CommentElementBox[] = [];
            const widgets: BodyWidget[] = this.getBlocks(content, true, undefined, pastedComments);
            this.pasteContentsInternal(widgets, true, currentFormat, pasteOptions, pastedComments);
            if (!isNullOrUndefined(pastedComments) && pastedComments.length > 0) {
                this.documentHelper.layout.layoutComments(pastedComments);
            }
            if (!isNullOrUndefined(this.pasteImageIndex)) {
                this.pasteImageIndex.destroy();
            }
            this.pasteImageIndex = undefined;
            this.isInsertField = false;
            this.isPasteListUpdated = false;
            this.isLastParaMarkCopied = false;
        }
    }
    private pasteContentsInternal(widgets: BodyWidget[], isPaste: boolean, currentFormat?: WParagraphFormat, pasteOptions?: PasteOptions | TablePasteOptions, pastedComments?: CommentElementBox[]): void {
        this.isPaste = isPaste;
        let selection: Selection = this.documentHelper.selection;
        if (selection.start.paragraph.isInsideTable && selection.end.paragraph.isInsideTable && !this.documentHelper.isDragging) {
            let isTablePaste: boolean = false;
            if (widgets.length === 1) {
                let childWidgets: IWidget[] = widgets[0].childWidgets;
                if ((childWidgets.length < 3)) {
                    if (childWidgets.length === 1 && childWidgets[0] instanceof TableWidget || childWidgets.length === 2 && childWidgets[0] instanceof TableWidget && (childWidgets[1] as ParagraphWidget).isEmpty()) {
                        isTablePaste = true;
                    }
                }
            }
            if (isTablePaste) {
                let startCell: TableCellWidget = selection.start.paragraph.associatedCell;
                let endCell: TableCellWidget = selection.end.paragraph.associatedCell;
                let newTable: TableWidget = widgets[0].childWidgets[0] as TableWidget;
                // tslint:disable-next-line:max-line-length
                if (isNullOrUndefined(pasteOptions) || (pasteOptions === 'MergeWithExistingFormatting') || (pasteOptions === 'KeepSourceFormatting') || (pasteOptions === 'KeepTextOnly')) {
                    if (startCell.ownerTable.equals(endCell.ownerTable)) {
                        if (selection.start.paragraph.associatedCell.rowIndex === 0 && selection.end.paragraph.associatedCell.rowIndex === 0
                            && startCell.equals(endCell) && !this.selection.isCellSelected(startCell, selection.start, selection.end)
                            && (!this.isInternalPaste || this.isLastParaMarkCopied)) {
                            this.selection.currentPasteAction = 'InsertAsColumns';
                            this.pasteAsNewColumn(newTable);
                        } else {
                            this.selection.currentPasteAction = 'OverwriteCells';
                            this.pasteOverwriteCell(newTable);
                        }
                    }
                }
                else {
                    switch (pasteOptions) {
                        case 'InsertAsColumns': {
                            this.selection.currentPasteAction = 'InsertAsColumns';
                            this.pasteAsNewColumn(newTable);
                            break;
                        }
                        case 'OverwriteCells': {
                            this.selection.currentPasteAction = 'OverwriteCells';
                            this.pasteOverwriteCell(newTable);
                            break;
                        }
                        case 'NestTable': {
                            this.selection.currentPasteAction = 'NestTable';
                            this.pasteAsNestedTable(widgets);
                            break;
                        }
                        case 'InsertAsRows': {
                            this.selection.currentPasteAction = 'InsertAsRows';
                            this.pasteAsNewRow(newTable);
                            break;
                        }
                    }
                }
                this.isPaste = false;
                return;
            }
        }
        let commentStartToInsert: CommentCharacterElementBox[];
        //if (!this.isSkipHistory) {
        commentStartToInsert = this.checkAndRemoveComments();
        //}

        this.defaultPaste(widgets as BodyWidget[], currentFormat, pastedComments);

        //if (!this.isSkipHistory) {
        this.updateHistoryForComments(commentStartToInsert);
        //}
    }

    private defaultPaste(widgets: BodyWidget[], currentFormat?: WParagraphFormat, pastedComments?: CommentElementBox[]): void {
        let selection: Selection = this.documentHelper.selection;
        let isRemoved: boolean = true;
        let layoutWholeDocument: boolean = false;
        //if (!this.isSkipHistory) {
        this.initComplexHistory('Paste');
        //}
        if (this.documentHelper.isListTextSelected) {
            let paragraph: ParagraphWidget = selection.start.paragraph;
            if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId !== -1) {
                this.onApplyList(undefined);
            }
        }
        //if (!this.isSkipHistory) {
        this.initHistory('Paste');
        //}
        if ((!selection.isEmpty && (!this.owner.documentHelper.isDragging || !this.owner.selection.isImageSelected)) || this.documentHelper.isListTextSelected) {
            isRemoved = this.removeSelectedContentInternal(selection, selection.start, selection.end);
        }
        if (isRemoved) {
            layoutWholeDocument = this.pasteContent(widgets, currentFormat);
            if(this.owner.enableTrackChanges && this.isInsertingTOC && isNullOrUndefined(this.owner.documentHelper.blockToShift)){
                this.owner.documentHelper.blockToShift = this.selection.start.paragraph as BlockWidget;
            }
            if (this.isRemoteAction) {
                this.updatePasteRevision();
                if (this.owner.showRevisions) {
                    this.owner.trackChangesPane.updateTrackChanges();
                }
            }
        } else if (this.editorHistory) {
            this.editorHistory.currentBaseHistoryInfo = undefined;
        }

        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            if (this.editorHistory.currentBaseHistoryInfo) {
                if (this.editorHistory.currentBaseHistoryInfo.action === 'Paste') {
                    if (this.editorHistory.currentBaseHistoryInfo.endRevisionLogicalIndex) {
                        this.editorHistory.currentBaseHistoryInfo.endRevisionLogicalIndex = undefined;
                    }
                    let start: TextPosition = this.selection.getTextPosBasedOnLogicalIndex(this.editorHistory.currentBaseHistoryInfo.insertPosition);
                    let end: TextPosition = this.selection.getTextPosBasedOnLogicalIndex(this.editorHistory.currentBaseHistoryInfo.endPosition);
                    if (!this.isRemoteAction) {
                        let documentContent: any = !isNullOrUndefined(this.owner.sfdtExportModule) ? this.owner.sfdtExportModule.write((this.owner.documentEditorSettings.optimizeSfdt ? 1 : 0), start.currentWidget, start.offset, end.currentWidget, end.offset, false, true) : {};
                        this.editorHistory.currentBaseHistoryInfo.pasteContent = documentContent;
                    }
                    if (!isNullOrUndefined(pastedComments) && pastedComments.length > 0) {
                        this.editorHistory.currentBaseHistoryInfo.pastedComments.push(...pastedComments);
                    }
                }
            }
            this.editorHistory.updateHistory();
            this.editorHistory.updateComplexHistory();
            selection.isHighlightContentControlEditRegion = true;
        } else {
            this.reLayout(selection, selection.isEmpty);
        }
        if (layoutWholeDocument) {
            if (this.selection.pasteElement) {
                this.selection.pasteElement.style.display = 'none';
            }
            if (!this.restrictLayout && this.viewer.owner.enableLayout) {
                this.documentHelper.layout.layoutWholeDocument(true);
            }
        }
        this.isPaste = false;
    }

    private pasteAsNewColumn(data: TableWidget): void {
        if (this.owner.isReadOnlyMode || !this.canEditContentControl) {
            return;
        }
        if (this.selection.start.paragraph.isInsideTable) {
            if (this.checkIsNotRedoing()) {
                this.initHistory('PasteColumn');
            }
            let startCell: TableCellWidget = this.getOwnerCell(this.selection.isForward);
            let table: TableWidget = startCell.ownerRow.ownerTable.combineWidget(this.owner.viewer) as TableWidget;
            if (this.editorHistory) {
                //Clones the entire table to preserve in history.
                let clonedTable: TableWidget = this.cloneTableToHistoryInfo(table);
            }
            this.selection.owner.isLayoutEnabled = false;
            let cloneTable: TableWidget = data.clone();
            let rowWidget: TableRowWidget = cloneTable.childWidgets[0] as TableRowWidget;
            let numberOfRows: number = cloneTable.childWidgets.length;
            let numberOfColumns: number = rowWidget.childWidgets.length;
            let cellIndex: number = startCell.columnIndex;
            let startParagraph: ParagraphWidget = undefined;
            let newCell: TableCellWidget = undefined;
            let columnCount: number = numberOfColumns;
            let rowSpannedCells: TableCellWidget[] = [];
            if (numberOfRows > table.childWidgets.length) {
                this.addRows(numberOfRows - table.childWidgets.length, table);
                this.tableUpdate(table);
            } else if (table.childWidgets.length > numberOfRows) {
                this.addRows(table.childWidgets.length - numberOfRows, cloneTable, table);
                this.tableUpdate(table);
            }
            for (let i: number = 0; i < columnCount; i++) {
                for (let j: number = 0; j < table.childWidgets.length; j++) {
                    let row: TableRowWidget = table.childWidgets[j] as TableRowWidget;
                    let rowWidget: TableRowWidget = cloneTable.childWidgets[j] as TableRowWidget;
                    let cellWidget: TableCellWidget = rowWidget.childWidgets[i] as TableCellWidget;
                    if (isNullOrUndefined(cellWidget)) {
                        continue;
                    }
                    let cell: TableCellWidget = row.childWidgets[startCell.columnIndex] as TableCellWidget;
                    newCell = this.createColumn(this.selection.getLastParagraph(startCell));
                    newCell.index = j;
                    newCell.rowIndex = row.index;
                    newCell.containerWidget = row; let prevCell: TableCellWidget = row.previousWidget as TableCellWidget;
                    let spannedCell = this.rowspannedCollection(row, rowSpannedCells);

                    if (cell != null) {
                        newCell.cellFormat.copyFormat(cell.cellFormat);
                        newCell.cellFormat.rowSpan = 1;
                    } else if (spannedCell.length > 0) {
                        for (let z: number = 0; z < spannedCell.length; z++) {
                            if (prevCell.rowIndex + (spannedCell[z].cellFormat.rowSpan - 1) >= row.rowIndex) {
                                newCell.cellFormat.copyFormat(spannedCell[z].cellFormat);
                                newCell.cellFormat.rowSpan = 1;
                            }
                        }
                    }

                    cellWidget.containerWidget = newCell.containerWidget;
                    newCell.childWidgets = cellWidget.childWidgets;
                    if (isNullOrUndefined(startParagraph)) {
                        startParagraph = this.selection.getFirstParagraph(newCell);
                    }
                    if (cellIndex === 0) {
                        row.childWidgets.splice(i, 0, newCell);
                    } else {
                        this.insertSpannedCells(row, rowSpannedCells, newCell, cellIndex);
                    }
                }
            }
            this.tableReLayout(table, startParagraph, newCell, true);
        }
    }

    private pasteAsNestedTable(widgets: BodyWidget[], currentFormat?: WParagraphFormat): void {
        let data: TableWidget = widgets[0].childWidgets[0] as TableWidget;
        if (this.selection.start.paragraph.isInsideTable) {
            if (this.checkIsNotRedoing()) {
                this.initHistory('PasteNested');
            }
            let startCell: TableCellWidget = this.getOwnerCell(this.selection.isForward);
            let table: TableWidget = startCell.ownerRow.ownerTable.combineWidget(this.owner.viewer) as TableWidget;
            if (this.editorHistory) {
                //Clones the entire table to preserve in history.
                this.cloneTableToHistoryInfo(table);
            }
            let startParagraph: ParagraphWidget = undefined;
            let dataTable: TableWidget = data.clone();
            let endCell: TableCellWidget = this.selection.end.paragraph.containerWidget as TableCellWidget;
            let pasteCell: TableCellWidget;
            if (startCell != endCell) {
                let row: TableRowWidget = startCell.ownerRow as TableRowWidget;
                while (row != endCell.ownerRow.nextRow) {
                    for (let cellIndex: number = startCell.columnIndex; cellIndex <= endCell.columnIndex; cellIndex++) {
                        pasteCell = row.childWidgets[cellIndex] as TableCellWidget;
                        let clonedTable: TableWidget = dataTable.clone() as TableWidget;
                        let newPara: ParagraphWidget = new ParagraphWidget();
                        pasteCell.childWidgets = [];
                        pasteCell.childWidgets[0] = clonedTable;
                        pasteCell.childWidgets[1] = newPara;
                        newPara.containerWidget = pasteCell;
                        clonedTable.containerWidget = pasteCell;
                        clonedTable.index = 0;
                        newPara.index = 1;
                        row.childWidgets[cellIndex] = pasteCell;
                        if (isNullOrUndefined(startParagraph)) {
                            startParagraph = this.selection.getFirstParagraph(pasteCell);
                        }
                    }
                    row = row.nextRow;
                }
                this.tableReLayout(table, startParagraph, pasteCell);
            }
            else {
                this.defaultPaste(widgets, currentFormat);
            }
        }
    }

    private pasteOverwriteCell(data: TableWidget): void {
        if (this.selection.start.paragraph.isInsideTable) {
            if (this.checkIsNotRedoing()) {
                this.initHistory('PasteOverwrite');
            }
            let startCell: TableCellWidget = this.getOwnerCell(this.selection.isForward);
            let table: TableWidget = startCell.ownerRow.ownerTable.combineWidget(this.owner.viewer) as TableWidget;
            if (this.editorHistory) {
                //Clones the entire table to preserve in history.
                this.cloneTableToHistoryInfo(table);
            }
            let cloneTable: TableWidget = data.clone();
            // let rowWidget: TableRowWidget = cloneTable.childWidgets[0] as TableRowWidget;
            let numberOfRows: number = cloneTable.childWidgets.length;
            let endCell: TableCellWidget = this.getOwnerCell(!this.selection.isForward);
            // let columnCount: number = numberOfColumns;
            // let newCell: TableCellWidget = undefined;
            let coloumnIndexPaste: number = startCell.columnIndex;
            let rowIndexPaste: number = startCell.rowIndex;
            let startParagraph: ParagraphWidget = undefined;
            let row: TableRowWidget = this.selection.start.paragraph.associatedCell.ownerRow as TableRowWidget;
            let rowWidget: TableRowWidget = cloneTable.childWidgets[0] as TableRowWidget;
            let newCells: TableCellWidget;// = rowWidget.childWidgets[0] as TableCellWidget;
            let numberOfColumns: number = rowWidget.childWidgets.length;
            let row2: TableRowWidget = startCell.ownerRow as TableRowWidget;
            if (startCell != endCell) {
                let k: number = 0;
                let rowSpan: number;
                let rowSpanIndex: number;
                let columnSpan: number;
                let cloneCells: TableCellWidget;
                let pasteCell: TableCellWidget;
                while (row2 != endCell.ownerRow.nextRow) {
                    rowWidget = cloneTable.childWidgets[k] as TableRowWidget || cloneTable.childWidgets[k = 0] as TableRowWidget;
                    let rowWidgetLength: number = rowWidget.childWidgets.length;
                    let cellIndexSE: number = 0;
                    for (let cellIndex: number = startCell.columnIndex; cellIndex <= endCell.columnIndex; cellIndex++) {
                        rowWidget = cloneTable.childWidgets[k] as TableRowWidget;
                        pasteCell = row2.getCell(row2.index, cellIndex) as TableCellWidget;
                        if (isNullOrUndefined(pasteCell)) {
                            continue;
                        }
                        if (rowSpan > 1 && rowSpanIndex === cellIndex) {
                            cellIndex++;
                            rowSpan--;
                            rowSpanIndex = null;
                        }
                        if (columnSpan > 1 && cellIndexSE >= (rowWidgetLength - (columnSpan - 1))) {
                            columnSpan = 1;
                            cellIndex = cellIndex + (columnSpan - 1);
                            cellIndexSE = 0;
                        }
                        newCells = rowWidget.childWidgets[cellIndexSE] as TableCellWidget || rowWidget.childWidgets[cellIndexSE = 0] as TableCellWidget;
                        cloneCells = newCells.clone();
                        for (let x: number = 0; x < cloneCells.childWidgets.length; x++) {
                            let newPara: ParagraphWidget = cloneCells.childWidgets[x] as ParagraphWidget;
                            newPara.containerWidget = pasteCell;
                            cloneCells.childWidgets[x] = newPara;
                        }
                        if (this.owner.enableTrackChanges) {
                            this.replaceCellContents(pasteCell, cloneCells);
                        }
                        else {
                            pasteCell.childWidgets = cloneCells.childWidgets;
                        }
                        if (newCells.cellFormat.rowSpan > 1) {
                            rowSpan = newCells.cellFormat.rowSpan;
                            rowSpanIndex = cellIndex;
                        }
                        if (newCells.cellFormat.columnSpan > 1) {
                            columnSpan = newCells.cellFormat.columnSpan;
                        }
                        if (isNullOrUndefined(startParagraph)) {
                            startParagraph = this.selection.getFirstParagraph(cloneCells);
                        }
                        cellIndexSE++;
                    }
                    row2 = row2.nextRow;
                    k++;
                }
                this.tableReLayout(table, startParagraph, pasteCell, true);
            }
            else {
                let rowsToAdd: number;
                let rowSpan: number;
                let rowSpanIndex: number;
                let pasteCell: TableCellWidget;
                for (let i: number = 0; i < numberOfRows; i++) {
                    let cellIndex: number = startCell.columnIndex;
                    rowWidget = cloneTable.childWidgets[i] as TableRowWidget;
                    let numberOfColumns: number = rowWidget.childWidgets.length;
                    for (let cellIterate: number = 0; cellIterate < numberOfColumns; cellIterate++) {
                        newCells = rowWidget.childWidgets[cellIterate] as TableCellWidget;
                        let cloneCells: TableCellWidget = newCells.clone();
                        if (rowSpan > 1 && rowSpanIndex === cellIndex) {
                            cellIndex++;
                            rowSpan--;
                            rowSpanIndex = null;
                        }
                        pasteCell = row.childWidgets[cellIndex] as TableCellWidget;
                        if (!pasteCell) {
                            pasteCell = this.createColumn(undefined);
                            pasteCell.containerWidget = row;
                            pasteCell.index = cellIndex;
                            pasteCell.cellFormat.preferredWidth = cloneCells.cellFormat.cellWidth;
                            for (let index: number = 0; index < cloneCells.childWidgets.length; index++) {
                                let newPara: ParagraphWidget = cloneCells.childWidgets[index] as ParagraphWidget;
                                newPara.containerWidget = pasteCell;
                                cloneCells.childWidgets[index] = newPara;
                                if (this.owner.enableTrackChanges) {
                                    this.insertRevisionForBlock(newPara, 'Insertion');
                                }
                            }
                            pasteCell.childWidgets = cloneCells.childWidgets;
                            row.childWidgets.splice(cellIndex, 1, pasteCell);
                            cellIndex++;
                        } else {
                            for (let index: number = 0; index < cloneCells.childWidgets.length; index++) {
                                let newPara: ParagraphWidget = cloneCells.childWidgets[index] as ParagraphWidget;
                                newPara.containerWidget = pasteCell;
                                cloneCells.childWidgets[index] = newPara;
                            }
                            if (this.owner.enableTrackChanges) {
                                this.replaceCellContents(pasteCell, cloneCells);
                                cellIndex++;
                            }
                            else {
                                pasteCell.childWidgets = cloneCells.childWidgets;
                                if (newCells.cellFormat.rowSpan > 1) {
                                    rowSpan = newCells.cellFormat.rowSpan;//getting span
                                    rowSpanIndex = cellIndex;
                                }
                                row.childWidgets.splice(cellIndex++, 1, pasteCell);
                            }
                        }
                        if (isNullOrUndefined(startParagraph)) {
                            startParagraph = this.selection.getFirstParagraph(pasteCell);
                        }
                    }
                    if (isNullOrUndefined(row.nextRow)) {
                        if (numberOfRows > table.childWidgets.length - rowIndexPaste) {
                            rowsToAdd = numberOfRows - table.childWidgets.length + rowIndexPaste;
                            this.addRows(rowsToAdd, table);
                        }
                    }
                    row = row.nextRow;
                }
                this.tableReLayout(table, startParagraph, pasteCell, true);
            }
        }
    }

    private replaceCellContents(targetCell: TableCellWidget, newCell: TableCellWidget): void {
        for (let index: number = 0; index < targetCell.childWidgets.length; index++) {
            let newBlock: BlockWidget = targetCell.childWidgets[index] as BlockWidget;
            if (newBlock.childWidgets.length > 0) {
                if (newBlock instanceof ParagraphWidget) {
                    this.selection.start.setPosition(newBlock.firstChild as LineWidget, true);
                    this.selection.end.setPositionParagraph(newBlock.lastChild as LineWidget, (newBlock.lastChild as LineWidget).getEndOffset() + 1);
                }
                else {
                    const firstPara: ParagraphWidget = this.documentHelper.getFirstParagraphBlock(newBlock);
                    const lastPara: ParagraphWidget = this.documentHelper.getLastParagraphBlock(newBlock);
                    const offset: number = (lastPara.lastChild as LineWidget).getEndOffset();
                    this.selection.start.setPosition(firstPara.childWidgets[0] as LineWidget, true);
                    this.selection.end.setPositionParagraph((lastPara.lastChild as LineWidget), offset + 1);
                    this.selection.selectPosition(this.selection.start, this.selection.end);
                }
                this.isPasteOverWriteCells = true;
                this.deleteSelectedContents(this.selection, true);
                this.isPasteOverWriteCells = false;
            }

        }
        const firstParagraph: BlockWidget = targetCell.firstChild as BlockWidget;
        if (!isNullOrUndefined(firstParagraph) && firstParagraph instanceof ParagraphWidget) {
            if (firstParagraph.isEmptyInternal(true)) {
                let line: LineWidget = new LineWidget(firstParagraph);
                firstParagraph.childWidgets.push(line);
            }
            this.selection.selectParagraphInternal(firstParagraph, true);
        }
        for (let index: number = 0; index < newCell.childWidgets.length; index++) {
            let block: BlockWidget = newCell.childWidgets[index] as BlockWidget;
            if (block instanceof ParagraphWidget && index === newCell.childWidgets.length - 1) {
                if (block.childWidgets.length > 0 && (block.childWidgets[0] as LineWidget).children.length > 0) {
                    this.insertElement((block.childWidgets[0] as LineWidget).children, block.paragraphFormat);
                }
            }
            else {
                if (block instanceof TableWidget) {
                    this.generateTableRevision(block);
                }
                this.insertBlockInternal(block);
            }
        }
    }

    private pasteAsNewRow(data: TableWidget): void {
        if (this.owner.isReadOnlyMode || !this.canEditContentControl) {
            return;
        }
        if (this.checkIsNotRedoing()) {
            this.initHistory('PasteRow');
        }
        this.documentHelper.owner.isShiftingEnabled = true;
        let startCell: TableCellWidget = this.getOwnerCell(this.selection.isForward).getSplitWidgets()[0] as TableCellWidget;
        let endCell: TableCellWidget = this.getOwnerCell(!this.selection.isForward).getSplitWidgets()[0] as TableCellWidget;
        let table: TableWidget = startCell.ownerTable.combineWidget(this.owner.viewer) as TableWidget;
        let row: TableRowWidget = endCell.ownerRow;
        if (this.editorHistory) {
            this.cloneTableToHistoryInfo(table);
        }
        let rowCount: number = this.getRowCountToInsert();
        let columncount: number = this.getColumnCountToInsert();
        let rows: TableRowWidget[] = [];
        let index: number = row.rowIndex;
        index++;
        let pasteRowCount: number = data.childWidgets.length;
        for (let i: number = 0; i < pasteRowCount; i++) {
            let newRow: TableRowWidget = (data.childWidgets[i] as TableRowWidget).clone();
            if (this.owner.enableTrackChanges) {
                this.insertRevision(newRow.rowFormat, 'Insertion');
            }
            rows.push(newRow);
        }
        table.insertTableRowsInternal(rows, index, false);
        let cellWidget: TableCellWidget = undefined;
        let paragraphWidget: ParagraphWidget = undefined;
        if ((table.childWidgets[index] instanceof TableRowWidget)) {
            cellWidget = ((table.childWidgets[index] as TableRowWidget).firstChild as TableCellWidget);
            paragraphWidget = this.selection.getFirstParagraph(cellWidget);
        } else {
            let widget: Widget = undefined;
            while (!(widget instanceof TableWidget)) {
                widget = table.nextRenderedWidget;
            }
            paragraphWidget = this.documentHelper.getFirstParagraphInFirstCell(widget);
        }
        this.copyContent(table);
        this.documentHelper.layout.reLayoutTable(table);
        this.selection.selectParagraphInternal(paragraphWidget, true);
        this.reLayout(this.selection, true);
    }

    private tableUpdate(table: TableWidget): void {
        table.isGridUpdated = false;
        table.calculateGrid();
        table.buildTableColumns();
        table.isGridUpdated = true;
    }

    private rowspannedCollection(row: TableRowWidget, rowSpannedCells: TableCellWidget[]) {
        for (let j: number = 0; j < row.childWidgets.length; j++) {
            let rowCell: TableCellWidget = row.childWidgets[j] as TableCellWidget;
            if (rowCell.cellFormat.rowSpan > 1) {
                rowSpannedCells.push(rowCell);
            }
        }
        return rowSpannedCells;
    }

    private insertSpannedCells(row: TableRowWidget, rowSpannedCells: TableCellWidget[], newCell: TableCellWidget, cellIndex: number): void {
        let isCellInserted: boolean = false;
        for (let j: number = 0; j < row.childWidgets.length; j++) {
            let rowCell: TableCellWidget = row.childWidgets[j] as TableCellWidget;
            // Add the row spanned cells to colection for adding column before / after row spnned cells.
            if (rowCell.cellFormat.rowSpan > 1) {
                rowSpannedCells.push(rowCell);
            }
            if (rowCell.columnIndex + rowCell.cellFormat.columnSpan === cellIndex) {
                row.childWidgets.splice(rowCell.cellIndex + 1, 0, newCell);
                isCellInserted = true;
            } else if (cellIndex > rowCell.columnIndex && rowCell.columnIndex + rowCell.cellFormat.columnSpan > cellIndex
                && cellIndex < rowCell.columnIndex + rowCell.cellFormat.columnSpan) {
                row.childWidgets.splice(rowCell.cellIndex + 1, 0, newCell);
                isCellInserted = true;
            }
            if (isCellInserted) {
                break;
            }
        }
        // If the cell is not inserted for row, then check for row spanned cells.
        if (!isCellInserted) {
            if (rowSpannedCells.length > 0) {
                for (let k: number = 0; k < rowSpannedCells.length; k++) {
                    let rowSpannedCell: TableCellWidget = rowSpannedCells[k];
                    if (rowSpannedCell.ownerRow !== row
                        && row.rowIndex <= rowSpannedCell.ownerRow.rowIndex + rowSpannedCell.cellFormat.rowSpan - 1) {
                        if (rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan === cellIndex) {
                            if (rowSpannedCell.cellIndex > row.childWidgets.length) {
                                row.childWidgets.push(newCell);
                            } else {
                                row.childWidgets.splice(rowSpannedCell.cellIndex + 1, 0, newCell);
                            }
                            isCellInserted = true;
                        } else if (cellIndex > rowSpannedCell.columnIndex &&
                            rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan > cellIndex
                            && cellIndex < rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan) {
                            row.childWidgets.splice(rowSpannedCell.columnIndex, 0, newCell);
                            isCellInserted = true;
                        }
                    }
                    if (isCellInserted) {
                        break;
                    }
                }
            }
        }
    }

    private addRows(count: number, table: TableWidget, ownerTable?: TableWidget): void {
        let rowPlacement: RowPlacement = 'Below';
        if (this.owner.isReadOnlyMode || !this.canEditContentControl) {
            return;
        }
        let startPos: TextPosition = this.selection.isForward ? this.selection.start : this.selection.end;
        let endPos: TextPosition = this.selection.isForward ? this.selection.end : this.selection.start;
        let rows: number = table.childWidgets.length;
        let rowWidget: TableRowWidget = table.childWidgets[rows - 1] as TableRowWidget;
        let column: number = rowWidget.childWidgets.length;
        let cloneTable: TableWidget = ownerTable ? ownerTable : table;
        if (startPos.paragraph.isInsideTable) {
            let startCell: TableCellWidget = this.getOwnerCell(this.selection.isForward).getSplitWidgets()[0] as TableCellWidget;
            let endCell: TableCellWidget = rowWidget.childWidgets[column - 1] as TableCellWidget;
            let row: TableRowWidget = endCell.ownerRow;
            this.rowInsertion(count, rowPlacement, startCell, endCell, row, table, false);
        }
        //this.reLayout(this.selection, true);
    }

    private pasteContent(widgets: BodyWidget[], currentFormat?: WParagraphFormat): boolean {
        this.documentHelper.owner.isShiftingEnabled = true;
        let insertPosition: string = '';
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            this.editorHistory.currentBaseHistoryInfo.insertPosition = undefined;
            this.updateInsertPosition();
            insertPosition = this.editorHistory.currentBaseHistoryInfo.insertPosition;
        } else {
            let position: TextPosition = this.selection.start;
            if (!this.selection.isForward) {
                position = this.selection.end;
            }
            let blockInfo: ParagraphInfo = this.selection.getParagraphInfo(position);
            insertPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        }
        this.documentHelper.owner.isLayoutEnabled = true;
        this.documentHelper.owner.isPastingContent = true;
        let layoutWholeDocument: boolean = this.pasteCopiedData(widgets, currentFormat);

        let endPosition: string = '';

        this.updateEndPosition();
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            endPosition = this.editorHistory.currentBaseHistoryInfo.endPosition;
        } else {
            let blockInfo: ParagraphInfo = this.selection.getParagraphInfo(this.selection.start);
            endPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        }
        if (this.selection.start.paragraph.isEmpty() && this.selection.start.paragraph.paragraphFormat.bidi) {
            this.documentHelper.layout.reLayoutParagraph(this.selection.start.paragraph, 0, 0);
        }
        let startPosition: TextPosition = new TextPosition(this.documentHelper.owner);
        this.setPositionForCurrentIndex(startPosition, insertPosition);
        let end: TextPosition = new TextPosition(this.documentHelper.owner);
        this.setPositionForCurrentIndex(end, endPosition);
        this.pasteTextPosition = { startPosition: startPosition, endPosition: end };
        this.documentHelper.owner.isPastingContent = false;
        this.documentHelper.selection.fireSelectionChanged(true);
        return layoutWholeDocument;
    }

    private pasteCopiedData(bodyWidget: BodyWidget[], currentFormat?: WParagraphFormat): boolean {
        let isSelectionInsideTable: boolean = this.selection.start.paragraph.isInsideTable;
        let layoutWholeDocument: boolean = false;
        let hasFootNoteElement: boolean = false;
        if (this.documentHelper.layout.isBidiReLayout) {
            this.documentHelper.layout.isBidiReLayout = false;
        }
        if (this.isPaste && this.isSectionEmpty(this.selection) && !this.selection.start.paragraph.isInHeaderFooter) {
            this.previousSectionFormat = new WSectionFormat();
            this.previousSectionFormat.copyFormat(this.selection.start.paragraph.bodyWidget.sectionFormat);
            this.selection.start.paragraph.bodyWidget.sectionFormat.copyFormat(bodyWidget[0].sectionFormat);
            this.selection.start.paragraph.bodyWidget.sectionFormat.footerDistance = this.previousSectionFormat.footerDistance;
            this.selection.start.paragraph.bodyWidget.sectionFormat.headerDistance = this.previousSectionFormat.headerDistance;
            if (this.owner.viewer instanceof PageLayoutViewer) {
                let page: Page = this.selection.start.paragraph.bodyWidget.page;
                this.owner.viewer.updatePageBoundingRectangle(this.selection.start.paragraph.bodyWidget, page, page.boundingRectangle.y);
                this.owner.viewer.updateClientArea(this.selection.start.paragraph.bodyWidget, page);
            }
            layoutWholeDocument = true;
        }
        this.documentHelper.layout.isPastingContent = true;
        for (let k: number = 0; k < bodyWidget.length; k++) {
            if (k !== 0) {
                this.insertSectionBreak(bodyWidget[k].sectionFormat.breakCode as SectionBreakType, bodyWidget[k].sectionFormat);
            }
            let widgets: BlockWidget[] = bodyWidget[k].childWidgets as BlockWidget[];
            let isConsiderLastBlock: boolean = false;
            const isLasteSection: boolean = (k === bodyWidget.length - 1);
            for (let j: number = 0; j < widgets.length; j++) {
                const isLastBlock: boolean = (j === widgets.length - 1);
                if (isLastBlock) {
                    isSelectionInsideTable = !isLastBlock;
                }
                if(isLastBlock && isLasteSection) {
                    this.documentHelper.layout.isPastingContent = false;
                }
                let widget: BlockWidget = widgets[j];
                if (widget instanceof TableWidget) {
                    isConsiderLastBlock = true;
                }
                if (widget instanceof ParagraphWidget && widget.childWidgets.length === 0) {
                    widget.childWidgets[0] = new LineWidget(widget as ParagraphWidget);
                }
                if (widget instanceof ParagraphWidget && !isNullOrUndefined(currentFormat)) {
                    widget.paragraphFormat.copyFormat(currentFormat);
                    let insertFormat: WCharacterFormat = this.copyInsertFormat(this.selection.start.paragraph.characterFormat, false);
                    widget.characterFormat.mergeFormat(insertFormat);
                }
                if (j !== widgets.length - 1 && this.isPaste && isNullOrUndefined(currentFormat) && this.previousParaFormat &&
                    widget instanceof ParagraphWidget && !isNullOrUndefined(widget.paragraphFormat.listFormat) && isNullOrUndefined(widget.paragraphFormat.listFormat.list) && widget.paragraphFormat.listFormat.listId === -1) {
                    if (this.previousParaFormat.listFormat && this.previousParaFormat.listFormat.list && this.previousParaFormat.listFormat.listId !== -1) {
                        widget.paragraphFormat.listFormat.copyFormat(this.previousParaFormat.listFormat);
                        widget.paragraphFormat.leftIndent = this.previousParaFormat.leftIndent;
                    } else if (this.previousParaFormat.baseStyle && this.previousParaFormat.baseStyle instanceof WParagraphStyle && this.previousParaFormat.baseStyle.paragraphFormat.listFormat
                        && this.previousParaFormat.baseStyle.paragraphFormat.listFormat.list && this.previousParaFormat.baseStyle.paragraphFormat.listFormat.listId !== -1) {
                        let paraFormat: WParagraphFormat = this.previousParaFormat.baseStyle.paragraphFormat;
                        widget.paragraphFormat.listFormat.copyFormat(paraFormat.listFormat);
                        widget.paragraphFormat.leftIndent = paraFormat.leftIndent;
                    }
                }
                if (j === widgets.length - 1 && widget instanceof ParagraphWidget
                    && ((!isNullOrUndefined(widget.paragraphFormat.listFormat)
                        && isNullOrUndefined(widget.paragraphFormat.listFormat.list)
                        && widget.paragraphFormat.listFormat.listId === -1) || this.isInsertField)) {
                    let newParagraph: ParagraphWidget = widget as ParagraphWidget;
                    if (newParagraph.childWidgets.length > 0
                        && (newParagraph.childWidgets[0] as LineWidget).children.length > 0) {
                        let insertPosition: TextPosition = this.selection.start;
                        if ((insertPosition.paragraph.paragraphFormat.textAlignment === 'Center'
                            || insertPosition.paragraph.paragraphFormat.textAlignment === 'Right') &&
                            insertPosition.paragraph.paragraphFormat.listFormat.listId === -1) {
                            insertPosition.paragraph.x = this.owner.viewer.clientActiveArea.x;
                        }
                        if (!isNullOrUndefined(this.editorHistory) && this.editorHistory.currentBaseHistoryInfo) {
                            this.editorHistory.currentBaseHistoryInfo.insertedNodes.push(newParagraph.clone());
                        }
                        hasFootNoteElement = this.insertElement((newParagraph.childWidgets[0] as LineWidget).children, newParagraph.paragraphFormat, true);
                    } else if(isLastBlock && isLasteSection) {
                        //Handle to update list  numbering for all paragraph below this paragraph
                        let lastParagraph: ParagraphWidget = this.selection.start.paragraph;
                        this.documentHelper.layout.reLayoutParagraph(lastParagraph, 0, 0, lastParagraph.paragraphFormat.bidi);
                    }
                } else if (widget instanceof BlockWidget) {
                    let block: BlockWidget = widget;
                    let startParagraph: ParagraphWidget = this.selection.start.paragraph;
                    let isTable: boolean = block instanceof TableWidget;
                    if (isTable) {
                        let table: TableWidget = block as TableWidget;
                        this.generateTableRevision(table);
                        if (startParagraph.isInsideTable) {
                            //Handled to resize table based on parent cell width.
                            let clientWidth: number = startParagraph.getContainerWidth();
                            table.fitCellsToClientArea(clientWidth);
                        }
                        if (startParagraph.isEmpty() && startParagraph.previousWidget instanceof TableWidget && !this.isPaste) {
                            this.insertTableRows(table, startParagraph.previousWidget as TableWidget);
                            return layoutWholeDocument;
                        }
                    }
                    this.insertBlockInternal(block, undefined, isSelectionInsideTable, this.isRemoteAction, true);
                }
            }
        }
        this.documentHelper.layout.isPastingContent = false;
        if (hasFootNoteElement) {
            layoutWholeDocument = true;
            if (this.pasteFootNoteType === 'Footnote') {
                this.arrangeFootnoteCollection();
            } else if (this.pasteFootNoteType === 'Endnote') {
                this.arrangeEndnoteCollection();
            }
        }
        if (!layoutWholeDocument && isNullOrUndefined(this.documentHelper.blockToShift)) {
            this.shiftFootnoteContent();
        }
        return layoutWholeDocument;
    }
    private arrangeEndnoteCollection(): void {
        for (let i = 0; i < this.documentHelper.endnoteCollection.length; i++) {
            for (let j = 0; j < this.documentHelper.endnoteCollection.length - 1 - i; j++) {
                const currentStart = this.selection.getElementPosition(this.documentHelper.endnoteCollection[j]).startPosition;
                const nextStart = this.selection.getElementPosition(this.documentHelper.endnoteCollection[j + 1]).startPosition;
                if (!currentStart.isExistBefore(nextStart)) {
                    const tempElementBox = this.documentHelper.endnoteCollection[j];
                    this.documentHelper.endnoteCollection[j] = this.documentHelper.endnoteCollection[j + 1];
                    this.documentHelper.endnoteCollection[j + 1] = tempElementBox;
                }
            }
        }
    }
    private arrangeFootnoteCollection(): void {
        for (let i = 0; i < this.documentHelper.footnoteCollection.length; i++) {
            for (let j = 0; j < this.documentHelper.footnoteCollection.length - 1 - i; j++) {
                const currentStart = this.selection.getElementPosition(this.documentHelper.footnoteCollection[j]).startPosition;
                const nextStart = this.selection.getElementPosition(this.documentHelper.footnoteCollection[j + 1]).startPosition;
                if (!currentStart.isExistBefore(nextStart)) {
                    const tempElementBox = this.documentHelper.footnoteCollection[j];
                    this.documentHelper.footnoteCollection[j] = this.documentHelper.footnoteCollection[j + 1];
                    this.documentHelper.footnoteCollection[j + 1] = tempElementBox;
                }
            }
        }
    }
    private generateTableRevision(table: TableWidget): void {
        if (this.owner.enableTrackChanges && !isNullOrUndefined(table)) {
            for (let i = 0; i < table.childWidgets.length; i++) {
                let row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
                this.insertRevision(row.rowFormat, 'Insertion');
                for (let j = 0; j < row.childWidgets.length; j++) {
                    let cell: TableCellWidget = row.childWidgets[j] as TableCellWidget;
                    for (let k = 0; k < cell.childWidgets.length; k++) {
                        let block: ParagraphWidget = cell.childWidgets[k] as ParagraphWidget;
                        if (!isNullOrUndefined(block)) {
                            if (block instanceof ParagraphWidget) {
                                this.insertRevisionForBlock(block, 'Insertion');
                            } else {
                                this.generateTableRevision(block as TableWidget);
                            }
                        }
                    }
                }
            }
        }
    }

    private isSectionEmpty(selection: Selection): boolean {
        let startParagraph: ParagraphWidget = selection.start.paragraph;
        if (startParagraph) {
            if (startParagraph.isInsideTable || startParagraph.isInHeaderFooter ||
                startParagraph !== selection.end.paragraph) {
                return false;
            }
            let bodyWidget: BodyWidget = startParagraph.bodyWidget;
            if (bodyWidget) {
                let page: Page = bodyWidget.page;
                if (page) {
                    if ((isNullOrUndefined(page.previousPage) || page.previousPage.sectionIndex !== page.sectionIndex)
                        && isNullOrUndefined(page.nextPage) && startParagraph.isEmpty() &&
                        bodyWidget.childWidgets.length === 1) {
                        let isEmpty: boolean = true;
                        let sectionIndex: number = selection.start.paragraph.bodyWidget.sectionIndex;
                        let headerFooters: HeaderFooters = this.documentHelper.headersFooters[sectionIndex];
                        if (headerFooters) {
                            for (const index in headerFooters) {
                                let headerFooter: HeaderFooterWidget = headerFooters[index];
                                if (!isNullOrUndefined(headerFooter)) {
                                    let widget: BlockWidget = headerFooter.childWidgets[0] as BlockWidget;
                                    if (widget instanceof TableWidget) {
                                        isEmpty = false;
                                    } else if ((widget instanceof ParagraphWidget) && !widget.isEmpty()) {
                                        isEmpty = false;
                                    }
                                } else {
                                    isEmpty = false;
                                }
                                if (!isEmpty) {
                                    break;
                                }
                            }
                            return isEmpty;
                        }
                    }
                }
            }
        }
        return false;
    }
    /**
     * Insert table on undo
     *
     * @param {TableWidget} table - Specifies the table
     * @param {TableWidget} newTable - Speciefies the new table
     * @param {boolean} moveRows - Specifies the new row
     * @private
     * @private {void}
     */
    public insertTableInternal(table: TableWidget, newTable: TableWidget, moveRows: boolean, skipRemoving?: boolean): void {
        //Gets the index of current table.
        let insertIndex: number = table.index;
        let owner: Widget;
        if (!skipRemoving && table.isInsideTable && !newTable.isInsideTable) {
            table = this.documentHelper.layout.getParentTable(table);
        }
        let currentParagraph: ParagraphWidget = this.selection.start.paragraph;
        if (!table.isInsideTable && newTable.isInsideTable) {
            insertIndex = newTable.index;
            skipRemoving = true;
            owner = currentParagraph.containerWidget;
        }

        if (moveRows) {
            //Moves the rows to table.
            for (let i: number = 0, index: number = 0; i < table.childWidgets.length; i++, index++) {
                let row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
                newTable.childWidgets.splice(index, 0, row);
                row.containerWidget = newTable;
                table.childWidgets.splice(i, 1);
                i--;
            }
        }
        if (!currentParagraph.isInsideTable && isNullOrUndefined(owner)) {
            table.containerWidget = currentParagraph.containerWidget;
            owner = currentParagraph.containerWidget;
        } else if (isNullOrUndefined(owner)) {
            owner = table.containerWidget;
        }
        if (table.isInsideTable) {
            owner = owner.combineWidget(this.owner.viewer);
        }
        //remove old table revisions if it is present.
        if (!skipRemoving) {
            this.removeBlock(table, true, false, false, true);
        }
        this.removeRevisionFromTable(newTable);
        if (owner instanceof TableCellWidget) {
            owner = owner.combineWidget(this.owner.viewer);
        } else {
            let curretBlock: BlockWidget = this.documentHelper.layout.checkAndGetBlock(owner, insertIndex);
            if (owner.childWidgets.indexOf(curretBlock) !== -1) {
                insertIndex = owner.childWidgets.indexOf(curretBlock);
            }
        }
        //Inserts table in the current table position.
        let blockAdvCollection: IWidget[] = owner.childWidgets;
        blockAdvCollection.splice(insertIndex, 0, newTable);
        if (!skipRemoving) {
            table.containerWidget = undefined;
            newTable.index = table.index;
        }
        newTable.containerWidget = owner;
        this.updateNextBlocksIndex(newTable, true);
        this.documentHelper.layout.clearTableWidget(newTable, true, true, true);
        newTable.buildTableColumns();
        this.constructRevisionsForTable(newTable, true);
        newTable.isGridUpdated = true;
        this.documentHelper.layout.linkFieldInTable(newTable);
        this.documentHelper.layout.layoutBodyWidgetCollection(newTable.index, owner as Widget, newTable, false);
    }

    private removeRevisionFromTable(table: TableWidget): void {
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
            if (row.rowFormat.revisionLength > 0) {
                for (let j: number = 0; j < row.rowFormat.revisionLength; j++) {
                    if (row.rowFormat.getAllRevision()[j].getRange().length === 0) {
                        let revisionIndex: number = row.rowFormat.getAllRevision().indexOf(row.rowFormat.getAllRevision()[j]);
                        row.rowFormat.removeRevision(revisionIndex);
                        j--;
                    }
                }
            }
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell: TableCellWidget = row.childWidgets[j] as TableCellWidget;
                for (let k = 0; k < cell.childWidgets.length; k++) {
                    let block: BlockWidget = cell.childWidgets[k] as BlockWidget;
                    if (block instanceof TableWidget) {
                        this.removeRevisionFromTable(block);
                    }
                }
            }
        }
    }

    /* eslint-disable @typescript-eslint/no-explicit-any */
    private canConstructRevision(item: WCharacterFormat | ElementBox | WRowFormat): boolean {
        if ((item.revisionLength > 0 && (isNullOrUndefined(item.getRevision(0).ownerNode) || item.getRevision(0).getRange().length === 0)) || item.removedIds.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    public constructRevisionsForTable(table: TableWidget, canConstructRevision: boolean): void {
        for (let i: number = 0; i < table.childWidgets.length; i++) {
            let rowWidget: TableRowWidget = table.childWidgets[i] as TableRowWidget;
            if (canConstructRevision) {
                if (this.canConstructRevision(rowWidget.rowFormat)) {
                    this.constructRevisionFromID(rowWidget.rowFormat);
                }
                for (let rowIndex: number = 0; rowIndex < rowWidget.childWidgets.length; rowIndex++) {
                    let cellWidget: TableCellWidget = rowWidget.childWidgets[rowIndex] as TableCellWidget;
                    for (let paraIndex: number = 0; paraIndex < cellWidget.childWidgets.length; paraIndex++) {
                        if (cellWidget.childWidgets[paraIndex] instanceof ParagraphWidget) {
                            this.constructRevisionsForBlock(cellWidget.childWidgets[paraIndex] as ParagraphWidget, canConstructRevision);
                        } else if (cellWidget.childWidgets[paraIndex] instanceof TableWidget) {
                            this.constructRevisionsForTable(cellWidget.childWidgets[paraIndex] as TableWidget, true);
                        }
                    }
                }
            } else {
                this.addRemovedRevisionInfo(rowWidget.rowFormat);
                this.removeRevisionsInRow(rowWidget, true, true);
            }
        }
    }
    private constructRevisionForFootnote(footnote: FootnoteElementBox,canConstructRevision: boolean){
        for(let i=0;i<footnote.bodyWidget.childWidgets.length;i++){
            if(footnote.bodyWidget.childWidgets[i] instanceof ParagraphWidget){
                this.constructRevisionsForBlock(footnote.bodyWidget.childWidgets[i] as ParagraphWidget,canConstructRevision);
            }
           }
    }
    private constructRevisionsForBlock(paragraph: ParagraphWidget, canConstructRevision: boolean): void {
        for (let linIndex: number = 0; linIndex < paragraph.childWidgets.length; linIndex++) {
            let lineWidget: LineWidget = paragraph.childWidgets[linIndex] as LineWidget;
            for (let elementIndex: number = 0; elementIndex < lineWidget.children.length; elementIndex++) {
                if (canConstructRevision) {

                    if (lineWidget.children[elementIndex] instanceof ElementBox && this.canConstructRevision(lineWidget.children[elementIndex])) {
                        this.constructRevisionFromID(lineWidget.children[elementIndex]);
                    }
                    if(lineWidget.children[elementIndex] instanceof FootnoteElementBox){
                        let footnote=lineWidget.children[elementIndex] as FootnoteElementBox;
                        this.constructRevisionForFootnote(footnote,canConstructRevision);
                     }
                }
            }
        }
        if (this.canConstructRevision(paragraph.characterFormat)) {
            this.constructRevisionFromID(paragraph.characterFormat);
        }
    }
    /**
     * @private
     * @param paraWidget 
     * @param startoffset 
     * @param endoffset 
     * @param revisionId 
     * @param isParaMarkIncluded 
     * @returns {void}
     */

    public applyRevisionForCurrentPara(paraWidget: ParagraphWidget, startoffset: number, endoffset: number, revisionId: string, isParaMarkIncluded: boolean): void {
        let elementInfo: ElementInfo = paraWidget.getInline(startoffset + 1, 0);
        let currentElement: ElementBox = elementInfo.element;
        if (elementInfo.element instanceof TextElementBox && elementInfo.element.text === "" && !isNullOrUndefined(elementInfo.element.previousElement)) {
            currentElement = elementInfo.element.previousElement;
        }
        let skipElement: boolean = false;
        if (startoffset === paraWidget.getLength()) {
            skipElement = true;
        }
        // Update the end offset if start and end both are same and both are positioned in the end of previous para of splitted para.
        if (startoffset === endoffset && paraWidget.nextSplitWidget) {
            endoffset += currentElement.length;
        }
        let endElement: ElementBox = paraWidget.getInline(endoffset, 0).element;
        // Set false if paraWidget contains nextSplitWidget because we shouldn't include paramark if current para contains nextSplitWidget.
        if (!isNullOrUndefined(paraWidget.nextSplitWidget)) {
            isParaMarkIncluded = false;
        }
        // Get the total length of previous splitted widgets of current para to include paramark because endoffset point out to the end of current. 
        let lastIndex: number = 0;
        let tempPara: ParagraphWidget = paraWidget;
        if (tempPara.nextSplitWidget) {
            while (tempPara) {
                if (!isNullOrUndefined(tempPara)) {
                    lastIndex += tempPara.getLength();
                }
                tempPara = tempPara.nextSplitWidget as ParagraphWidget;
            }
        }
        else {
            while (tempPara) {
                if (!isNullOrUndefined(tempPara)) {
                    lastIndex += tempPara.getLength();
                }
                tempPara = tempPara.previousSplitWidget as ParagraphWidget;
            }
        }
        if (!isNullOrUndefined(paraWidget.previousSplitWidget) && lastIndex !== 0 && startoffset !== lastIndex) {
            skipElement = false;
        }
        if (endoffset > lastIndex) {
            isParaMarkIncluded = true;
        }

        if(!isParaMarkIncluded) {
            if (!isNullOrUndefined(currentElement) && !isNullOrUndefined(endElement)) {
                if (!skipElement && currentElement === endElement) {
                    currentElement.removedIds.push(revisionId);
                    this.constructRevisionFromID(currentElement, true);
                } else {
                    while (!isNullOrUndefined(currentElement) && currentElement !== endElement) {
                        if (!skipElement) {
                            currentElement.removedIds.push(revisionId);
                            this.constructRevisionFromID(currentElement, true);
                        }
                        if (!isNullOrUndefined(currentElement.nextNode)) {
                            if (currentElement.nextNode instanceof BookmarkElementBox) {
                                currentElement = currentElement.nextNode;
                            }
                            else {
                                currentElement = currentElement.nextNode.nextValidNodeForTracking;
                            }
                        }
                        skipElement = false;
                    }
                    if (!isNullOrUndefined(currentElement) && !skipElement) {
                        currentElement.removedIds.push(revisionId);
                        this.constructRevisionFromID(currentElement, true);
                    }
                }
            } else if (!isNullOrUndefined(currentElement) && !skipElement) {
                currentElement.removedIds.push(revisionId);
                this.constructRevisionFromID(currentElement, true);
            } else if (!isNullOrUndefined(endElement)) {
                endElement.removedIds.push(revisionId);
                this.constructRevisionFromID(endElement, true);
            }
        } else {
            paraWidget.characterFormat.removedIds = [];
            paraWidget.characterFormat.removedIds.push(revisionId);
            this.constructRevisionFromID(paraWidget.characterFormat, true);
        }
    }
    /**
     * Insert table on undo
     *
     * @param {Selection} selection - Specified the selection
     * @param {WBlock} block - Spcifies the block
     * @param {WTable} table - Specifies the table.
     * @private
     * @returns {void}
     */
    public insertBlockTable(selection: Selection, block: BlockWidget, table: TableWidget): void {
        let offset: number = selection.start.offset;
        let lineIndex: number = selection.start.paragraph.childWidgets.indexOf(selection.start.currentWidget);
        if (block instanceof ParagraphWidget && offset > 0) {
            //Moves the inline items before selection start to the inserted paragraph.

            this.moveInlines(selection.start.paragraph, block as ParagraphWidget, 0, 0, selection.start.paragraph.firstChild as LineWidget, offset, selection.start.currentWidget);
            selection.selectParagraphInternal(selection.start.paragraph, true);
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(this.selection.getHierarchicalIndex((block as ParagraphWidget), offset.toString()), true);
            }
        }
        if (offset > 0 && this.checkInsertPosition(selection)) {
            this.updateHistoryPosition(selection.start, true);
        }
        let index: number = table.indexInOwner;
        (table.containerWidget as Widget).childWidgets.splice(index, 0, block);
        block.containerWidget = table.containerWidget;
        block.index = table.index;
        this.updateNextBlocksIndex(block, true);
        // Insert the revision based on id when perform accept + undo in pagebreak case
        if (block instanceof ParagraphWidget) {
            this.constructRevisionsForBlock(block, true);
        }
        this.documentHelper.layout.layoutBodyWidgetCollection(block.index, block.containerWidget as Widget, block, false);
        if (this.checkInsertPosition(selection)) {
            let paragraph: BlockWidget = undefined;
            if (block instanceof ParagraphWidget) {
                paragraph = block as ParagraphWidget;
            }
            if (block instanceof TableWidget) {
                paragraph = this.documentHelper.getFirstParagraphInFirstCell(block as TableWidget);
            }
            this.updateHistoryPosition(this.selection.getHierarchicalIndex(paragraph, '0'), true);
        }
    }
    /**
     * On cut handle selected content remove and relayout
     *
     * @param {Selection} selection - Specified the selection
     * @private
     * @returns {void}
     */
    public handleCut(selection: Selection): void {
        let startPosition: TextPosition = selection.start;
        let endPosition: TextPosition = selection.end;
        let removedCommentStart: CommentCharacterElementBox[] = this.checkAndRemoveComments();
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        // this.owner.isShiftingEnabled = true;     
        let image: ImageElementBox = undefined;
        if (startPosition.paragraph === endPosition.paragraph && startPosition.offset + 1 === endPosition.offset) {
            //Gets selected image and copy image to clipboard.
            let index: number = 0;
            let currentInline: ElementInfo = startPosition.paragraph.getInline(endPosition.offset, index);
            let inline: ElementBox = currentInline.element;
            image = inline as ImageElementBox;
        }
        let blockInfo: ParagraphInfo = this.selection.getParagraphInfo(startPosition);
        selection.editPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        this.initHistory('Cut');
        selection.owner.isShiftingEnabled = true;
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(selection.editPosition, true);
            }
        }
        this.deleteSelectedContent(endPosition.paragraph, selection, startPosition, endPosition, 3);
        let textPosition: TextPosition = new TextPosition(selection.owner);
        this.setPositionForCurrentIndex(textPosition, selection.editPosition);
        selection.selectContent(textPosition, true);
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            if (this.checkEndPosition(selection)) {
                this.updateHistoryPosition(selection.end, false);
            }
        }
        this.reLayout(selection);
        this.updateHistoryForComments(removedCommentStart);
    }

    private insertInlineInternal(element: ElementBox, revisionType?: RevisionType): void {
        let selection: Selection = this.selection;
        let length: number = element.length;
        let paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(selection.start);
        revisionType = (isNullOrUndefined(revisionType) ? 'Insertion' : revisionType);
        if (selection.start.paragraph.isEmpty()) {
            let paragraph: ParagraphWidget = selection.start.paragraph as ParagraphWidget;
            if ((paragraph.paragraphFormat.textAlignment === 'Center' || paragraph.paragraphFormat.textAlignment === 'Right')
                && paragraph.paragraphFormat.listFormat.listId === -1) {
                paragraph.x = this.owner.viewer.clientActiveArea.x;
            }
            let isUndoing: boolean = !isNullOrUndefined(this.editorHistory) ? (this.editorHistory.isUndoing || this.editorHistory.isRedoing) : false;
            (paragraph.childWidgets[0] as LineWidget).children.push(element);
            element.line = (paragraph.childWidgets[0] as LineWidget);
            if (this.owner.enableTrackChanges && element.isValidNodeForTracking && !isUndoing && !(!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && this.editorHistory.currentBaseHistoryInfo.action === 'InsertHyperlink')) {
                this.insertRevision(element, revisionType);
            }
            if (element.removedIds.length > 0 || isUndoing) {
                this.constructRevisionFromID(element);
            }
            element.linkFieldCharacter(this.documentHelper);
            if (element instanceof FootnoteElementBox) {
                this.constructRevisionForFootnote(element as FootnoteElementBox,true);
                if(isUndoing){
                    element.isLayout=false;
                }
                if (element.footnoteType === 'Footnote') {
                    this.updateFootnoteCollection(element);
                }
                if (element.footnoteType === 'Endnote') {
                    this.updateEndnoteCollection(element);
                }
            }
            this.documentHelper.layout.reLayoutParagraph(paragraph, 0, 0, undefined, undefined);
        } else {
            let indexInInline: number = 0;
            let inlineObj: ElementInfo = selection.start.currentWidget.getInline(selection.start.offset, indexInInline);
            let curInline: ElementBox = inlineObj.element;
            indexInInline = inlineObj.index;
            this.insertElementInternal(curInline, element, indexInInline, revisionType, true);
        }
        this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + length, true);
        this.checkToSplitRevisionInPrevNxt(element);
    }
    private insertElement(element: ElementBox[], paragraphFormat?: WParagraphFormat, isPaste?: boolean): boolean {
        let isElementHasEndNote: boolean = false;
        let selection: Selection = this.selection;
        let length: number = 0;
        let paragraph: ParagraphWidget = undefined;
        let lineIndex: number = -1;
        let lineWidget: LineWidget = undefined;
        let insertIndex: number = 0;
        let begin: boolean = undefined;
        let isCopyParaFormat: boolean = undefined;
        let paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(selection.start);
        let isTrackingEnabled: boolean = this.owner.enableTrackChanges;
        let curInline: ElementBox = undefined;
        let prevElement: TextElementBox = undefined;
        let indexInInline: number = 0;
        if (selection.start.paragraph.isEmpty()) {
            paragraph = selection.start.paragraph as ParagraphWidget;
            lineWidget = (paragraph.childWidgets[0] as LineWidget);
            lineIndex = 0;
        } else {
            let inlineObj: ElementInfo = selection.start.currentWidget.getInline(selection.start.offset, indexInInline);
            curInline = inlineObj.element;
            indexInInline = inlineObj.index;
            paragraph = curInline.line.paragraph;
            lineIndex = paragraph.childWidgets.indexOf(curInline.line);
            insertIndex = curInline.indexInOwner;
            lineWidget = curInline.line;
            let nextNode: ElementBox = curInline.nextNode;
            if (this.isPaste && curInline instanceof ContentControl && curInline.type == 0 && !isNullOrUndefined(nextNode) && nextNode instanceof ContentControl && nextNode.type == 1) {
                isCopyParaFormat = true;
            }
            if (indexInInline === curInline.length) { // Add new Element in current 
                insertIndex++;
                begin = false;
            } else if (indexInInline === 0) {
                if (isNullOrUndefined(curInline.previousNode)) {
                    insertIndex = 0;
                }
                begin = true;
            } else {
                insertIndex++;
                prevElement = new TextElementBox();
                prevElement.characterFormat.copyFormat(curInline.characterFormat);
                prevElement.text = (curInline as TextElementBox).text.substring(indexInInline);
                (curInline as TextElementBox).text = (curInline as TextElementBox).text.slice(0, indexInInline);
                for (let m: number = 0; m < curInline.revisionLength; m++) {
                    prevElement.addRevision(curInline.getRevision(m));
                }
                curInline.isWidthUpdated = false;
                lineWidget.children.splice(insertIndex, 0, prevElement);
                prevElement.line = curInline.line;
                if (curInline.revisionLength > 0 && !this.owner.enableTrackChanges) {
                    this.splitRevisionForSpittedElement(curInline, prevElement);
                }
            }
        }
        for (let i: number = 0; i < element.length; i++) {
            length += element[i].length;
            if (element[i] instanceof TextElementBox && (element[i] as TextElementBox).text.indexOf(' ') >= 0) {
                this.documentHelper.triggerSpellCheck = true;
            }
            let prevRevisionsCount: number = element[i].revisionLength;
            element[i].isChangeDetected = true;
            lineWidget.children.splice(insertIndex, 0, element[i]);
            element[i].line = lineWidget;
            element[i].linkFieldCharacter(this.documentHelper);
            // Logic used for when pasting the content when track changes enable and not enabled. Because in track changes after pushing the element only need to update the revision collection.
            if (isPaste && !isTrackingEnabled) {
                this.updateRevisions(element[i]);
            } else {
                let isRevisionCombined: boolean = this.updateRevisionForElement(curInline, element[i], indexInInline, (i === 0) ? true : false, prevElement, begin);
                //Check to combine elements with previous / next para
                if (isTrackingEnabled && !isRevisionCombined && element[i].revisionLength === prevRevisionsCount) {
                    //if (!(element[i] instanceof FieldElementBox && (element[i] as FieldElementBox).fieldType === 2)) {
                    this.checkToSplitRevisionInPrevNxt(element[i]);
                    if (!(element[i] instanceof BookmarkElementBox || element[i] instanceof CommentCharacterElementBox || element[i] instanceof EditRangeStartElementBox || element[i] instanceof EditRangeEndElementBox)) {
                        this.insertRevision(element[i], 'Insertion');
                    }
                    //}
                }
            }
            curInline = element[i];
            insertIndex++;
            if (element[i] instanceof FootnoteElementBox) {
                this.pasteFootNoteType = (element[i] as FootnoteElementBox).footnoteType;
                isElementHasEndNote = true;
            }
            
        }
        if ((!this.isPaste || isCopyParaFormat) && paragraphFormat && (isNullOrUndefined(paragraph.paragraphFormat.listFormat.list) ||
            (!isNullOrUndefined(paragraph.paragraphFormat.listFormat) && paragraph.paragraphFormat.listFormat.listId === -1))) {
            paragraph.paragraphFormat.copyFormat(paragraphFormat);
        }

        if (this.isPaste) {
            if (this.isRemoteAction) {
                let revision: Revision[] = (paragraphFormat.ownerBase as ParagraphWidget).characterFormat.getAllRevision();
                let isBreak: boolean = false;
                for (let i: number = 0; i < revision.length; i++) {
                    paragraph.characterFormat.addRevision(revision[i]);
                    let range: object[] = revision[i].getRange();
                    for (let j: number = 0; j < range.length; j++) {
                        if (range[j] instanceof WCharacterFormat && (range[j] as WCharacterFormat) == (paragraphFormat.ownerBase as ParagraphWidget).characterFormat) {
                            isBreak = true;
                            break;
                        }
                    }
                    if (isBreak) {
                        break;
                    }
                }
            }
            paragraph.textWrapWidth = false;
            this.viewer.updateClientAreaForBlock(paragraph, true);
            paragraph.x = this.viewer.clientActiveArea.x;
        }
        this.documentHelper.layout.reLayoutParagraph(paragraph, lineIndex, 0, this.isInsertField ? undefined : paragraph.paragraphFormat.bidi);
        this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + length, true);
        return isElementHasEndNote;
    }

    private updateRevisionForElement(currentElement: ElementBox, newElement: ElementBox, indexInInline: number, isFirstItem: boolean, prevElement: TextElementBox, isBeginning?: boolean): boolean {
        if (!this.owner.enableTrackChanges) {
            return false;
        }
        if (isNullOrUndefined(currentElement) && isNullOrUndefined(prevElement)) {
            return false;
        }
        let isMiddle: boolean = isNullOrUndefined(isBeginning) ? true : false;
        let prevRevisionCount: number = newElement.revisionLength;
        if (isFirstItem) {
            if (isMiddle) {

                let isRevisionCombined: boolean = this.checkToMapRevisionWithInlineText(currentElement, indexInInline, newElement, false, 'Insertion');
                if (isRevisionCombined || newElement.revisionLength > prevRevisionCount) {
                    this.copyElementRevision(currentElement, prevElement);
                } else if (newElement.revisionLength === 0) {
                    this.splitRevisionForSpittedElement(currentElement, prevElement);
                    this.insertRevision(newElement, 'Insertion');
                }
            } else if (isBeginning) {
                return this.insertRevisionAtBegining(currentElement, newElement, 'Insertion');
            } else {
                return this.insertRevisionAtEnd(currentElement, newElement, 'Insertion');
            }
        } else {
            // if (currentElement instanceof FieldElementBox && currentElement.fieldType === 2) {
            //     currentElement = (currentElement as FieldElementBox).previousElement;
            // }
            return this.insertRevisionAtEnd(currentElement, newElement, 'Insertion');
        }
        return false;
    }

    private insertElementInternal(element: ElementBox, newElement: ElementBox, index: number, revisionType: RevisionType, relayout?: boolean, isNavigationPane?: boolean): void {
        let line: LineWidget = element.line;
        let paragraph: ParagraphWidget = line.paragraph;
        let lineIndex: number = line.indexInOwner;
        let insertIndex: number = element.indexInOwner;
        let isBidi: boolean = paragraph.paragraphFormat.bidi && element.isRightToLeft;
        let isEqualFormat: boolean = false;
        revisionType = isNullOrUndefined(revisionType) ? 'Insertion' : revisionType;

        let isUndoing: boolean = this.skipTracking();
        let isTrackingEnabled: boolean = this.owner.enableTrackChanges;
        let isRevisionCombined: boolean = false;
        if (this.owner.editorHistoryModule && (this.owner.editorHistoryModule.isUndoing || this.owner.editorHistoryModule.isRedoing)
            && newElement instanceof TextElementBox) {
            isEqualFormat = element.characterFormat.isEqualFormat(newElement.characterFormat)
                && this.documentHelper.textHelper.isRTLText(newElement.text);
        }
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            // Check if we are not currently undoing or redoing an action
            if (!this.editorHistory.isUndoing && !this.editorHistory.isRedoing) {
                // Mark whether the current history item had track changes enabled
                this.editorHistory.currentHistoryInfo.isTrackingEnabled = isTrackingEnabled;
            }
            // During undo or redo operations, get the tracking state of the current history item
            // If the state was stored previously, update the current tracking enabled status
            if ((this.editorHistory.isUndoing || this.editorHistory.isRedoing) && !isNullOrUndefined(this.editorHistory.currentHistoryInfo.isTrackingEnabled)) {
                isTrackingEnabled = this.editorHistory.currentHistoryInfo.isTrackingEnabled;
            }
        }
        newElement.line = line;
        if (!isEqualFormat) {
            if (index === element.length) {
                insertIndex = this.incrementCommentIndex(isBidi, element, insertIndex);
                line.children.splice(insertIndex, 0, newElement);
                // Add new Element in current 
                if (newElement.removedIds.length > 0 || isUndoing) {
                    this.constructRevisionFromID(newElement, false);
                } else if (isTrackingEnabled && !isUndoing && !this.skipFieldDeleteTracking) {
                    isRevisionCombined = this.insertRevisionAtEnd(element, newElement, revisionType);
                }
                if (newElement instanceof FootnoteElementBox) {
                    if (newElement.revisionLength > 0) {
                        this.footnoteRevision = newElement.getRevision(0);
                    }
                    this.constructRevisionForFootnote(newElement as FootnoteElementBox, true);
                    this.footnoteRevision = undefined;
                }
                if (newElement instanceof FieldElementBox && newElement.fieldType === 2) {
                    this.constructRevisionsForLink(newElement, false);
                }
                if (!isRevisionCombined) {
                    // As per MS word behaviour: If track changes disabled, we may need to split the insert revisions.
                    if (element.revisionLength > 0 && !isTrackingEnabled && newElement.removedIds.length === 0) {
                        if (newElement instanceof CommentCharacterElementBox) {
                            if (newElement.commentType === 1 && newElement.nextNode) {
                                // Split the revision for split elements
                                this.splitRevisionForSpittedElement(element, newElement.nextNode);
                            } else {
                                // For other cases, copy the revision from the existing element to the new element
                                this.copyElementRevision(element, newElement);
                            }
                        }
                    }
                    // When track changes is enabled in MS Word, revisions should be split if they involve a deletion or if the revisions collection contains a delete revision
                    else if (isTrackingEnabled) {
                        if (newElement instanceof CommentCharacterElementBox) {
                            if (newElement.commentType === 1 && !isNullOrUndefined(this.retrieveRevisionByType(element, 'Deletion')) && newElement.nextNode) {
                                // Split the revision for split elements
                                this.splitRevisionForSpittedElement(element, newElement.nextNode);
                            } else {
                                // For other cases, copy the revision from the existing element to the new element
                                this.copyElementRevision(element, newElement);
                            }
                        }
                    }
                }
            } else if (index === 0) {
                if (isNullOrUndefined(element.previousNode)) {
                    element.line.children.splice(0, 0, newElement);
                    insertIndex = 0;
                } else {
                    element.line.children.splice(insertIndex, 0, newElement);
                }
                // newElement.line = line;
                if (newElement.removedIds.length > 0 || isUndoing) {
                    // 885534 (insertIndex used for this bug).
                    this.constructRevisionFromID(newElement, false);
                } else if (isTrackingEnabled && !isUndoing && !this.skipFieldDeleteTracking) {
                    isRevisionCombined = this.insertRevisionAtBegining(element, newElement, revisionType);
                }
            } else if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo && this.editorHistory.currentBaseHistoryInfo.isHyperlinkField && newElement instanceof FieldElementBox && newElement.fieldType === 1 && newElement.removedIds.length > 0) {
                line.children.splice(insertIndex, 0, newElement);
                // newElement.line = line;
                this.constructRevisionFromID(newElement, false);
            } else {
                insertIndex = this.incrementCommentIndex(isBidi, element, insertIndex);
                let textElement: TextElementBox = new TextElementBox();
                textElement.characterFormat.copyFormat(element.characterFormat);
                textElement.text = (element as TextElementBox).text.substring(index);
                (element as TextElementBox).text = (element as TextElementBox).text.substr(0, index);
                element.isWidthUpdated = false;
                textElement.isChangeDetected = true;
                line.children.splice(insertIndex, 0, textElement);
                textElement.line = element.line;
                isRevisionCombined = true;
                line.children.splice(insertIndex, 0, newElement);
                 // As per MS word behaviour: If track changes disabled, we may need to split the insert revisions.
                if (element.revisionLength > 0 && !isTrackingEnabled && !isUndoing && newElement.removedIds.length === 0) {
                    if (newElement instanceof CommentCharacterElementBox) {
                        this.copyElementRevision(element, textElement);
                        if (newElement.commentType === 1) {
                            // Split the revision for split elements
                            this.splitRevisionForSpittedElement(element, textElement);
                        }
                        else {
                            // For other cases, copy the revision from the existing element to the new element
                            this.copyElementRevision(element, newElement);
                        }
                    }
                }
                // newElement.line = line;
                this.isTrackingFormField = element.previousElement instanceof FieldElementBox ? true : false;
                if (newElement.removedIds.length > 0 && !this.isTrackingFormField) {
                    this.constructRevisionFromID(newElement, false);
                    this.copyElementRevision(element, textElement);
                } else if (isTrackingEnabled) {
                    if (!(newElement instanceof BookmarkElementBox) && !(newElement instanceof CommentCharacterElementBox) && !(newElement instanceof EditRangeStartElementBox) && !(newElement instanceof EditRangeEndElementBox)) {
                        let isRevisionCombined: boolean = this.checkToMapRevisionWithInlineText(element, index, newElement, isBidi, revisionType);
                        if (isRevisionCombined) {
                            this.copyElementRevision(element, textElement);
                        } else {
                            this.copyElementRevision(element, textElement);
                            this.splitRevisionForSpittedElement(element, textElement);
                            this.insertRevision(newElement, revisionType);
                        }
                    } 
                     // When track changes is enabled in MS Word, revisions should be split if they involve a deletion or if the revisions collection contains a delete revision
                    else if (newElement instanceof CommentCharacterElementBox) {
                        this.copyElementRevision(element, textElement);
                        if (newElement.commentType === 1 && !isNullOrUndefined(this.retrieveRevisionByType(element, 'Deletion'))) {
                            // Split the revision for split elements
                            this.splitRevisionForSpittedElement(element, textElement);
                        }
                        else {
                             // For other cases, copy the revision from the existing element to the new element
                            this.copyElementRevision(element, newElement);
                        }
                    } else {
                        this.copyElementRevision(element, textElement);
                    }
                }
                //Inserts the new inline.
                insertIndex -= 1;
            }
        } else {

            (element as TextElementBox).text = (element as TextElementBox).text.substring(0, index) + (newElement as TextElementBox).text + (element as TextElementBox).text.substring(index);
            element.isWidthUpdated = false;
        }
        if (newElement instanceof TextElementBox) {
            newElement.isChangeDetected = true;
        }
        if (newElement instanceof BookmarkElementBox) {
            let bookmarkCol: Dictionary<string, BookmarkElementBox> = this.documentHelper.bookmarks;
            if(newElement.reference){
                newElement.reference.reference = newElement;
                }
            if (!bookmarkCol.containsKey(newElement.name)) {
                bookmarkCol.add(newElement.name, newElement);
            }
        }
        if (!isNullOrUndefined(newElement.line.paragraph.containerWidget) && !isNullOrUndefined(newElement.line.paragraph.containerWidget.containerWidget) && newElement.line.paragraph.containerWidget.containerWidget instanceof FootNoteWidget) {
            newElement.line.paragraph.containerWidget.containerWidget.height += newElement.height;
        }
        newElement.linkFieldCharacter(this.documentHelper);
        if (newElement instanceof ContentControl && newElement.type === 0) {
            this.insertContentControlInCollection(newElement);
            if (this.owner.editorHistoryModule && (this.owner.editorHistoryModule.isUndoing || this.owner.editorHistoryModule.isRedoing)) {
                this.updatePropertiesToBlock(newElement, true);
            }
        }
        if ((newElement instanceof ImageElementBox && newElement.textWrappingStyle !== 'Inline') || newElement instanceof ShapeElementBox) {
            if (paragraph.floatingElements.indexOf(newElement) === -1) {
                paragraph.floatingElements.push(newElement);
            }
            if (paragraph.bodyWidget.floatingElements.indexOf(newElement) === -1 && newElement.textWrappingStyle !== 'Inline') {
                paragraph.bodyWidget.floatingElements.push(newElement);
            }
        }
        if (isTrackingEnabled && !isRevisionCombined && !isUndoing && !this.skipFieldDeleteTracking && !this.isInsertingTOC) {
            if(!(newElement instanceof BookmarkElementBox) && !(newElement instanceof CommentCharacterElementBox) && !(newElement instanceof EditRangeStartElementBox) && !(newElement instanceof EditRangeEndElementBox)) {
                this.insertRevision(newElement, revisionType);
            }
        }
        if (newElement instanceof FootnoteElementBox) {
            if (isUndoing) {
                // this.documentHelper.layout.isLayoutWhole = true;
                newElement.isLayout = false;
            }
            if (newElement.footnoteType === 'Footnote') {
                this.updateFootnoteCollection(newElement);
                this.updateFootNoteIndex();
            }
            if (newElement.footnoteType === 'Endnote') {
                this.updateEndnoteCollection(newElement);
                this.updateEndNoteIndex();
            }
        }
        if (!(newElement instanceof CommentCharacterElementBox)) {
            this.combineElementRevisionToPrevNxt(newElement);
        }
        if (relayout && !isNavigationPane) {
            this.documentHelper.layout.reLayoutParagraph(paragraph, lineIndex, insertIndex, undefined, undefined);
        }
        else if (isNavigationPane && newElement instanceof BookmarkElementBox) {
            this.documentHelper.layout.updateMargin(line);
        }
    }
    private incrementCommentIndex(isBidi: boolean, element: ElementBox, insertIndex: number): number {
        if (!this.owner.editorHistoryModule || !(this.owner.editorHistoryModule && this.owner.editorHistoryModule.currentHistoryInfo) || (this.owner.editorHistoryModule && this.owner.editorHistoryModule.currentHistoryInfo
            && (this.owner.editorHistoryModule.currentHistoryInfo.action !== "SkipCommentInline" ||
                this.owner.editorHistoryModule.currentHistoryInfo.action === "SkipCommentInline" &&
                (this.owner.editorHistoryModule.currentHistoryInfo.modifiedActions[0] === this.editorHistory.currentBaseHistoryInfo
                    || (this.owner.editorHistoryModule.currentHistoryInfo.modifiedActions[0] !== this.editorHistory.currentBaseHistoryInfo
                        && !(element instanceof CommentCharacterElementBox)))))) {
            insertIndex++;
        }
        return insertIndex;
    }
    /**
     * @private
     * @returns {void}
     */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    public constructRevisionFromID(insertElement: ElementBox | WCharacterFormat | WRowFormat, skipUpdate?: boolean): void {
        if (insertElement.removedIds.length > 0) {
            for (let i: number = 0; i < insertElement.removedIds.length; i++) {
                let revisionToInclude: Revision = undefined;
                if (this.documentHelper.revisionsInternal.containsKey(insertElement.removedIds[i])) {
                    revisionToInclude = this.documentHelper.revisionsInternal.get(insertElement.removedIds[i]);
                    revisionToInclude.ownerNode = this.getOwnerNodeForRevision(insertElement);
                    insertElement.addRevision(revisionToInclude);
                    if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                        // Handle collab editing for track changes.
                        this.editorHistory.currentBaseHistoryInfo.markerData.push(this.getMarkerData(insertElement as ElementBox, undefined, revisionToInclude));
                    }
                    if (!skipUpdate) {
                        this.owner.trackChangesPane.updateCurrentTrackChanges(revisionToInclude);
                    }
                    this.updateRevisionCollection(revisionToInclude);
                }
            }
            insertElement.removedIds = [];
        } else {
            // on undoing revisions will be cloned , so need to update range information.
            for (let i: number = 0; i < insertElement.revisionLength; i++) {
                let currentRevision: Revision = insertElement.getRevision(i);
                if (this.documentHelper.revisionsInternal.containsKey(currentRevision.revisionID)) {
                    currentRevision = this.documentHelper.revisionsInternal.get(currentRevision.revisionID);
                    currentRevision.ownerNode = this.getOwnerNodeForRevision(insertElement);
                    insertElement.removeRevision(i);
                    insertElement.insertRevisionAt(i, currentRevision);
                    this.updateRevisionCollection(currentRevision);
                }
            }
        }
    }

    /**
     * Insert block on undo
     *
     * @param {Selection} selection - Specifies the selection
     * @param {WBlock} block - Specifes the block
     * @private
     * @returns {void}
     */
    public insertBlock(block: BlockWidget, isSelectionInsideTable?: boolean): void {
        let isRemoved: boolean = true;
        let isSkipEmptyPara: boolean = false;
        let selection: Selection = this.selection;
        if (!selection.isEmpty) {
            isRemoved = this.removeSelectedContents(selection);
            isSkipEmptyPara = true;
        }
        if (!isRemoved) {
            selection.selectContent(selection.start, false);
        }
        this.insertBlockInternal(block, isSkipEmptyPara, isSelectionInsideTable);
        if (this.checkInsertPosition(selection)) {
            let paragraph: BlockWidget = undefined;
            if (block instanceof ParagraphWidget) {
                paragraph = block as BlockWidget;
            } else {
                paragraph = this.documentHelper.getFirstParagraphInFirstCell(block as TableWidget);
            }

            this.updateHistoryPosition(this.selection.getHierarchicalIndex(paragraph, '0'), true);
        }
        this.fireContentChange();
    }
    private updateRevisions(item: ElementBox | WCharacterFormat | WRowFormat): void {
        // When pasting in parsing we won't update the revision to the collection. But we create only revision. So after inserting the blocks to the DOM. We need to update the revision to the collection.
        for (let i: number = 0; i < item.revisionLength; i++) {
            this.updateRevisionCollection(item.getRevision(i));
        }
    }
    private insertBlockInternal(block: BlockWidget, isRemoved?: boolean, isSelectionInsideTable?: boolean, isSkipRevision?: boolean, isPaste?: boolean): void {
        let selection: Selection = this.selection;
        let startPara: ParagraphWidget = this.selection.start.paragraph;
        let paraStart: boolean = this.selection.start.isAtParagraphStart;
        //Checking the selection is exist after para mark. Then updating the offset.
        if (this.selection.getLineLength(this.selection.start.currentWidget) + 1 === this.selection.start.offset) {
            this.selection.start.offset -= 1;
        }
        if (!selection.start.isAtParagraphStart) {
            if (block instanceof ParagraphWidget) {
                const index: string = this.selection.startOffset;
                if (!isNullOrUndefined(this.editorHistory) && this.editorHistory.currentBaseHistoryInfo) {
                    if (!this.editorHistory.isUndoing && !this.editorHistory.isRedoing) {
                        this.editorHistory.currentBaseHistoryInfo.insertedNodes.push(block.clone());
                    }
                }
                this.insertNewParagraphWidget(block as ParagraphWidget, false);
                // Updating the revision after combining the block based on the track changes enable or not.
                // Logic used for when pasting the content when track changes enable and not enabled. Because in track changes after pushing the element only need to update the revision collection.
                if (!this.skipTracking() && !isSkipRevision) {
                    const position: TextPosition = this.documentHelper.selection.getTextPosBasedOnLogicalIndex(index);
                    const elementInfo: ElementInfo = this.selection.getElementInfo(position.currentWidget, position.offset);
                    let element: ElementBox = elementInfo.element.nextNode;
                    const revision: Revision = undefined;
                    while (!isNullOrUndefined(element)) {
                        if (this.owner.enableTrackChanges) {
                            this.updateRevisions(element);
                            if (isNullOrUndefined(revision)) {
                                this.insertRevision(element, 'Insertion');
                            } else {
                                element.addRevision(revision);
                            }
                        } else if (isPaste && element.revisionLength > 0) {
                            this.updateRevisions(element);
                        }
                        element = element.nextNode;
                    }
                    if (this.owner.enableTrackChanges) {
                        this.updateRevisions(block.characterFormat);
                        this.insertRevision(block.characterFormat, 'Insertion');
                    } else {
                        if (isPaste && block.characterFormat.revisionLength > 0) {
                            this.updateRevisions(block.characterFormat);
                        }
                    }
                }
                return;
            }
            this.updateInsertPosition();
            startPara = startPara.combineWidget(this.owner.viewer) as ParagraphWidget;
            if (!isNullOrUndefined(this.editorHistory) && this.editorHistory.currentBaseHistoryInfo) {
                if (!this.editorHistory.isUndoing && !this.editorHistory.isRedoing) {
                    this.editorHistory.currentBaseHistoryInfo.insertedNodes.push(startPara.clone());
                }
            }
            this.splitParagraph(startPara, startPara.firstChild as LineWidget, 0, selection.start.currentWidget, selection.start.offset, false);
            selection.selectParagraphInternal(this.selection.start.paragraph as ParagraphWidget, true);
        }
        let bodyWidget: BodyWidget = selection.start.paragraph.containerWidget as BodyWidget;
        let blockIndex: number = selection.start.paragraph.index;

        if (!isNullOrUndefined(bodyWidget)) {

            if (!isNullOrUndefined(this.editorHistory)) {
                if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && !this.editorHistory.isUndoing && !this.editorHistory.isRedoing) {
                    this.editorHistory.currentBaseHistoryInfo.insertedNodes.push(block.clone());
                }
                // Added the condition to skip adding an empty paragraph when performing a redo if the document has an empty case.
                if (this.editorHistory.isRedoing && isRemoved && bodyWidget.firstChild instanceof ParagraphWidget && bodyWidget.firstChild.isEmpty() && bodyWidget.firstChild === bodyWidget.lastChild && block instanceof ParagraphWidget && block.isEmpty()) {
                    return;
                }
            }
            let insertIndex: number = bodyWidget.childWidgets.indexOf(selection.start.paragraph);
            // When deleting the section break it will delete the previous paragraph. So, need to update the insert index.
            if (bodyWidget.childWidgets[bodyWidget.childWidgets.length - 1] === selection.start.paragraph && block instanceof ParagraphWidget && block.isSectionBreak) {
                insertIndex++;
                blockIndex++;
            }
            if(selection.start.paragraph.isEmpty() && selection.start.paragraph.index === block.index && bodyWidget.childWidgets.length === 1 && selection.start.paragraph.containerWidget.containerWidget instanceof FootNoteWidget && this.owner.editorHistory.isUndoing){
                bodyWidget.childWidgets.splice(0,1);
            }
            bodyWidget.childWidgets.splice(insertIndex, 0, block);
            block.containerWidget = bodyWidget;
            block.index = blockIndex;
            block.height = 0;
            if (block instanceof TableWidget) {
                block.isGridUpdated = false;
                block.buildTableColumns();
                block.isGridUpdated = true;
            }
            this.updateNextBlocksIndex(block, true);
            if (block instanceof ParagraphWidget) {
                this.documentHelper.layout.linkFieldInParagraph(block);
            }
            if (!this.skipTracking() && block instanceof ParagraphWidget && !isSkipRevision && !(!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && this.editorHistory.currentBaseHistoryInfo.action === 'InsertHyperlink')) {
                this.insertRevisionForBlock(block, 'Insertion', isPaste);
            } else if (block instanceof ParagraphWidget) {
                this.constructRevisionsForBlock(block, true);
                this.splitRevisionsAndViewBasedOnUntrackedContent(block.characterFormat);
            } else if (block instanceof TableWidget) {
                this.constructRevisionsForTable(block, true);
            }
            if (this.documentHelper.owner.editorModule.isRemoteAction && !paraStart && block instanceof TableWidget) {
                this.updateNextBlocksIndex(block.nextWidget as BlockWidget, false);
                bodyWidget.childWidgets.splice(block.indexInOwner + 1, 1);
            }
            if (this.isPaste && !isNullOrUndefined(block.previousWidget) && block.previousWidget instanceof ParagraphWidget
                && block instanceof ParagraphWidget && block.paragraphFormat.contextualSpacing && !isSelectionInsideTable) {
                this.documentHelper.layout.reLayoutParagraph(block.previousWidget, 0, 0);
            }
            this.documentHelper.layout.layoutBodyWidgetCollection(blockIndex, bodyWidget, block, false, undefined, isSelectionInsideTable);
        }
    }
    /**
     * Inserts the image with specified size at cursor position in the document editor.
     * 
     * @deprecated
     *
     * @param {string} imageString  Base64 string, web URL or file URL.
     * @param {number} width Specify the image width.
     * @param {number} height Specify the image height.
     * @param {string} alternateText Specify the image alternateText.
     * @returns {void}
     */
    public insertImage(imageString: string, width?: number, height?: number,alternateText?: string): void {
        this.insertImageInternal(imageString, false, width, height,alternateText);
    }
    /**
     * Inserts an image with a specified size at the cursor position in the DocumentEditor component.
     *
     * @param {string} imageString - The Base64 string, web URL, or file URL of the image to be inserted.
     * @param {number} width - The width of the image. Optional parameter, if not specified, the original width of the image will be used.
     * @param {number} height - The height of the image. Optional parameter, if not specified, the original height of the image will be used.
     * @param {string} alternateText - The alternate text of the image. Optional parameter, if specified, this text will be displayed when the image is not available or when images are disabled in the document.
     * @returns {Promise<void>} - A Promise that is resolved when the image has been inserted successfully, or rejected if the image could not be inserted for any reason.
     */
    public async insertImageAsync(imageString: string, width?: number, height?: number,alternateText?: string): Promise<void> {
        await this.insertImageInternal(imageString, false, width, height,alternateText);
    }
    /**
     * Inserts the image with specified size at cursor position in the document editor.
     *
     * @private
     * @param {string} imageString Base64 string, web URL or file URL.
     * @param {boolean} isUiInteracted Is image instered from UI interaction.
     * @param {number} width? Image width
     * @param {number} height? Image height
     * @param {string} alternateText? Image alternateText
     * @returns {void}
     */
    public async insertImageInternal(imageString: string, isUiInteracted: boolean, width?: number, height?: number,alternateText?: string): Promise<void> {
        return new Promise(
            (resolve: Function, reject: Function) => {
                let formField: FieldElementBox = this.selection.getCurrentFormField();
                let isFormFillProtectedMode: boolean = this.documentHelper.protectionType === 'FormFieldsOnly' && !isNullOrUndefined(formField) && formField.formFieldData instanceof TextFormField;
                if ((this.owner.isReadOnlyMode || !this.canEditContentControl) && !isFormFillProtectedMode) {
                    resolve();
                    return;
                }
                if (isNullOrUndefined(width) || isNullOrUndefined(height)) {
                    const image: HTMLImageElement = document.createElement('img');
                    let editor: Editor = this;
                    image.addEventListener('load', function (): void {
                        this.width = isNullOrUndefined(width) ? this.width : width;
                        this.height = isNullOrUndefined(height) ? this.height : height;
                        editor.insertPicture(imageString, this.width, this.height, this.alt, true);
                        resolve();
                    });
                    image.src = imageString;
                }
                else {
                    this.insertPicture(imageString, width, height, alternateText, isUiInteracted);
                    resolve();
                }
                setTimeout((): void => {
                    if (!isNullOrUndefined(this.documentHelper)) {
                        this.viewer.updateScrollBars();
                    }
                }, 30);
            }
        );
    }

    /**
     * Inserts a table of specified size at cursor position in the document editor.
     *
     * @param {number} rows Default value of ‘rows’ parameter is 1.
     * @param {number} columns Default value of ‘columns’ parameter is 1.
     * @returns {void}
     */
    public insertTable(rows?: number, columns?: number): void {
        let startPos: TextPosition = this.selection.start;
        if (this.owner.isReadOnlyMode || !this.canEditContentControl || this.selection.isPlainContentControl()) {
            return;
        }
        rows = rows || 1;
        columns = columns || 1;
        const localeValue: L10n = new L10n('documenteditor', this.owner.defaultLocale);
        localeValue.setLocale(this.documentHelper.owner.locale);
        if (columns < 1 || columns > this.documentHelper.owner.documentEditorSettings.maximumColumns) {
            let columnAlertPopup: string = localeValue.getConstant('Number of columns must be between') + ' 1 ' + localeValue.getConstant('and') + ' ' + this.documentHelper.owner.documentEditorSettings.maximumColumns.toString();
            DialogUtility.alert(columnAlertPopup).enableRtl = this.documentHelper.owner.enableRtl;
            return;
        }
        if (rows < 1 || rows > this.documentHelper.owner.documentEditorSettings.maximumRows) {
            let rowAlertPopup: string = localeValue.getConstant('Number of rows must be between') + ' 1 ' + localeValue.getConstant('and') + ' ' + this.documentHelper.owner.documentEditorSettings.maximumColumns.toString();
            localeValue.getConstant('Number of rows must be between 1 and 32767.').replace("32767", this.documentHelper.owner.documentEditorSettings.maximumRows.toString());
            DialogUtility.alert(rowAlertPopup).enableRtl = this.documentHelper.owner.enableRtl;
            return;
        }
        let isCombineTable: boolean = false;
        let prevBlock: Widget = startPos.paragraph.previousWidget;
        if (startPos.currentWidget.isFirstLine() && startPos.offset === 0 && prevBlock instanceof TableWidget) {
            isCombineTable = true;
        }
        let table: TableWidget = this.createTable(rows, columns);
        let clientWidth: number = startPos.paragraph.getContainerWidth() - table.tableFormat.leftIndent;
        table.splitWidthToTableCells(clientWidth);
        let removedComment: CommentCharacterElementBox[];
        // let prevBlock: Widget = startPos.paragraph.previousWidget;
        if (isCombineTable && prevBlock instanceof TableWidget) {
            this.insertTableRows(table, prevBlock, true);
            table.destroy();
            return;
        } else {
            removedComment = this.checkAndRemoveComments();
            this.initHistory('InsertTable');
            this.documentHelper.owner.isShiftingEnabled = true;
            this.insertBlock(table);
            if (!isNullOrUndefined(table.containerWidget) && !isNullOrUndefined(table.containerWidget.containerWidget) && table.containerWidget.containerWidget instanceof FootNoteWidget) {
                table.containerWidget.containerWidget.height += table.height;
                this.isTableInsert = true;
            }
        }
        let splittedTable: TableWidget[] = table.getSplitWidgets() as TableWidget[];
        if (this.owner.enableTrackChanges) {
            for (let i: number = 0; i < splittedTable.length; i++) {
                for (let j: number = 0; j < splittedTable[i].childWidgets.length; j++) {
                    let row: TableRowWidget = splittedTable[i].childWidgets[j] as TableRowWidget;
                    this.insertRevision(row.rowFormat, 'Insertion');
                }
            }
        }
        let startLine: LineWidget = this.documentHelper.getFirstParagraphInFirstCell(table).childWidgets[0] as LineWidget;
        startPos.setPosition(startLine, true);
        this.selection.end.setPositionInternal(startPos);
        let lastParagraph: ParagraphWidget = this.documentHelper.getLastParagraphInLastCell(table.getSplitWidgets().pop() as TableWidget);
        let endOffset: number = lastParagraph.getLength() + 1;
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {

            this.editorHistory.currentBaseHistoryInfo.endPosition = this.selection.getHierarchicalIndex(lastParagraph, endOffset.toString());
        }
        this.reLayout(this.selection);
        this.isTableInsert = false;
        this.updateHistoryForComments(removedComment);
    }
    /**
     * Inserts the specified number of rows to the table above or below to the row at cursor position.
     *
     * @param {boolean} above The above parameter is optional and if omitted, 
     * it takes the value as false and inserts below the row at cursor position.
     * @param {number} count The count parameter is optional and if omitted, it takes the value as 1.
     * @returns {void}
     */
    public insertRow(above?: boolean, count?: number): void {
        let rowPlacement: RowPlacement = above ? 'Above' : 'Below';
        if (this.owner.isReadOnlyMode || !this.canEditContentControl) {
            return;
        }
        let isInsertRow: boolean = true;
        let startPos: TextPosition = this.selection.isForward ? this.selection.start : this.selection.end;
        let endPos: TextPosition = this.selection.isForward ? this.selection.end : this.selection.start;
        if (startPos.paragraph.isInsideTable) {
            if (this.checkIsNotRedoing()) {
                this.initHistory(rowPlacement === 'Above' ? 'InsertRowAbove' : 'InsertRowBelow');
            }
            this.documentHelper.owner.isShiftingEnabled = true;
            let startCell: TableCellWidget = this.getOwnerCell(this.selection.isForward).getSplitWidgets()[0] as TableCellWidget;
            let endCell: TableCellWidget = this.getOwnerCell(!this.selection.isForward).getSplitWidgets()[0] as TableCellWidget;
            let table: TableWidget = startCell.ownerTable.combineWidget(this.owner.viewer) as TableWidget;
            let row: TableRowWidget = rowPlacement === 'Below' ? endCell.ownerRow : startCell.ownerRow;
            if (this.editorHistory) {
                let clonedTable: TableWidget = this.cloneTableToHistoryInfo(table);
            }
            this.rowInsertion(count, rowPlacement, startCell, endCell, row, table, isInsertRow);
        }

        this.reLayout(this.selection, true);
    }

    private rowInsertion(count: number, rowPlacement: RowPlacement, startCell: TableCellWidget, endCell: TableCellWidget, row: TableRowWidget, table: TableWidget, isInsertRow: boolean): void {
        let rowCount: number = count ? count : this.getRowCountToInsert();
        let rows: TableRowWidget[] = [];
        let index: number = row.rowIndex;
        if (rowPlacement === 'Below') {
            index++;
            let isAffectedByRowSpannedCell: boolean = isNullOrUndefined(endCell.previousWidget)
                || endCell.columnIndex === (endCell.previousWidget as TableCellWidget).columnIndex + 1;
            let isRowSpanEnd: boolean = endCell.cellIndex !== endCell.columnIndex && isAffectedByRowSpannedCell
                && row.rowIndex + startCell.cellFormat.rowSpan - 1 === endCell.ownerRow.rowIndex;
            if (!isRowSpanEnd) {
                if (endCell.cellFormat.rowSpan > 1) {
                    if (!isNullOrUndefined(row.nextWidget) && row.nextWidget instanceof TableRowWidget) {
                        endCell.cellFormat.rowSpan += rowCount;
                        row = row.nextWidget as TableRowWidget;
                    }
                }
            }
            row.bottomBorderWidth = 0;
        }
        for (let i: number = 0; i < rowCount; i++) {
            let cellCountInfo: CellCountInfo = this.updateRowspan(row, rowPlacement === 'Below' ? endCell : startCell, rowPlacement);
            let newRow: TableRowWidget = this.createRowAndColumn(cellCountInfo.count, i, index, table);
            newRow.rowFormat = row.rowFormat.cloneFormat();
            // Insert row in table the removedIDs set for newRow when clone the rowFormat
            newRow.rowFormat.removedIds = [];
            newRow.containerWidget = row.containerWidget;
            newRow.rowFormat.ownerBase = newRow;
            this.updateCellFormatForInsertedRow(newRow, cellCountInfo.cellFormats);
            if (!isNullOrUndefined(this.editorHistory) && this.editorHistory.currentBaseHistoryInfo && this.owner.enableCollaborativeEditing) {
                this.editorHistory.currentBaseHistoryInfo.insertedNodes.push(newRow);
            }
            rows.push(newRow);
        }
        let newRows: TableRowWidget[] =  [...rows];
        table.insertTableRowsInternal(rows, index, isInsertRow);
        if (this.owner.enableTrackChanges) {
            for (let i: number = 0; i < newRows.length; i++) {
                this.insertRevision(newRows[i].rowFormat, 'Insertion');
            }
        }
        if (isInsertRow) {
            this.splitRevisionsAndViewBasedOnUntrackedContent((table.childWidgets[index] as TableRowWidget).rowFormat);
            let cell: TableCellWidget = undefined;
            let paragraph: ParagraphWidget = undefined;
            if ((table.childWidgets[index] instanceof TableRowWidget)) {
                cell = ((table.childWidgets[index] as TableRowWidget).firstChild as TableCellWidget);
                paragraph = this.selection.getFirstParagraph(cell);
            } else {
                let widget: Widget = undefined;
                while (!(widget instanceof TableWidget)) {
                    widget = table.nextRenderedWidget;
                }
                paragraph = this.documentHelper.getFirstParagraphInFirstCell(widget);
            }
            this.documentHelper.layout.reLayoutTable(table);
            this.selection.selectParagraphInternal(paragraph, true);
        }
    }
    /**
     * Check the valid previous element to combine and returns it.
     * @private
     * @returns {void}
     */
    public getPreviousNodeRevision(previousElement: ElementBox): ElementBox {
        while ((previousElement instanceof ListTextElementBox || previousElement instanceof BookmarkElementBox || previousElement instanceof EditRangeStartElementBox || previousElement instanceof EditRangeEndElementBox) && previousElement.revisionLength === 0) {
            previousElement = previousElement.previousNode;
        }
        return previousElement;
    }
    /**
     * Check the valid next element to combine and returns it. 
     * @private
     * @returns {void}
     */
    public getNextNodeRevision(nextElement: ElementBox): ElementBox {
        while ((nextElement instanceof ListTextElementBox || nextElement instanceof BookmarkElementBox || nextElement instanceof EditRangeStartElementBox || nextElement instanceof EditRangeEndElementBox) && nextElement.revisionLength === 0) {
            nextElement = nextElement.nextNode;
        }
        return nextElement;
    }
    /**
     *
     * @private
     * @returns {void}
     */
    public splitRevisionsAndViewBasedOnUntrackedContent(currentElement: (ElementBox | WCharacterFormat | WRowFormat)): void {
        let previousRevisions: Revision[];
        let nextRevisions: Revision[];
        let splitRevision: boolean = true;
        // While inserting inside a tracked table cell, 
        // we do not want to split.
        // so we set splitRevision to false.
        if (currentElement instanceof ElementBox) {
            splitRevision = !(currentElement.paragraph.containerWidget instanceof TableCellWidget && currentElement.paragraph.containerWidget.ownerRow.rowFormat.revisionLength > 0);
        } else if (currentElement instanceof WCharacterFormat) {
            if (currentElement.ownerBase instanceof ParagraphWidget) {
                splitRevision = !(currentElement.ownerBase.containerWidget instanceof TableCellWidget && currentElement.ownerBase.containerWidget.ownerRow.rowFormat.revisionLength > 0);;
            }
        } else if (currentElement instanceof WRowFormat) {
            if (currentElement.ownerBase instanceof TableRowWidget && currentElement.ownerBase.ownerTable.containerWidget instanceof TableCellWidget && currentElement.ownerBase.ownerTable.containerWidget.ownerRow.rowFormat.revisionLength > 0) {
                splitRevision = false;
            }
        }
        if (splitRevision && currentElement.revisionLength === 0 && !(currentElement instanceof ListTextElementBox || currentElement instanceof BookmarkElementBox || currentElement instanceof EditRangeStartElementBox || currentElement instanceof EditRangeEndElementBox)) {
            // Logic to get a previousRevision
            if (currentElement instanceof ElementBox) {
                let previousElement: ElementBox = this.getPreviousNodeRevision(currentElement.previousNode);
                let currentParagraph: ParagraphWidget = (currentElement.paragraph.getSplitWidgets()[0] as ParagraphWidget);
                let previousBlock: BlockWidget = currentParagraph.previousRenderedWidget as BlockWidget;
                if (previousElement instanceof ElementBox && previousElement.revisionLength > 0) {
                    previousRevisions = previousElement.getAllRevision();
                }
                else if (isNullOrUndefined(previousElement) && previousBlock instanceof ParagraphWidget && previousBlock.characterFormat.revisionLength > 0) {
                    previousRevisions = previousBlock.characterFormat.getAllRevision();

                }
            } else if (currentElement instanceof WCharacterFormat) {
                let block: ParagraphWidget = currentElement.ownerBase as ParagraphWidget;
                let splittedParagraph: ParagraphWidget[] = block.getSplitWidgets() as ParagraphWidget[];
                let previousBlock: BlockWidget = splittedParagraph[0].previousRenderedWidget as BlockWidget;
                let previousElement: ElementBox | WCharacterFormat;
                if (block.isEmpty() && previousBlock instanceof ParagraphWidget) {
                    previousElement = previousBlock.characterFormat;
                } else {
                    let lastLine: LineWidget = (splittedParagraph[splittedParagraph.length - 1].lastChild as LineWidget);
                    previousElement = this.getPreviousNodeRevision(lastLine.children[lastLine.children.length - 1]);
                    if (isNullOrUndefined(previousElement) && previousBlock instanceof ParagraphWidget) {
                        previousElement = previousBlock.characterFormat;
                    }
                }
                if (!isNullOrUndefined(previousElement) && previousElement.revisionLength > 0) {
                    previousRevisions = previousElement.getAllRevision();
                }
            } else if (currentElement instanceof WRowFormat) {
                let rowWidget: TableRowWidget = currentElement.ownerBase;
                let previousRow: TableRowWidget = rowWidget.previousRenderedWidget as TableRowWidget;
                if (!isNullOrUndefined(previousRow) && previousRow.rowFormat.revisionLength > 0) {
                    previousRevisions = previousRow.rowFormat.getAllRevision();
                }
            }
            if (isNullOrUndefined(previousRevisions)) {
                let block: BlockWidget;
                if (currentElement instanceof ElementBox) {
                    block = currentElement.paragraph;
                } else if (currentElement instanceof WCharacterFormat) {
                    block = currentElement.ownerBase as ParagraphWidget;
                } else if (currentElement instanceof WRowFormat) {
                    block = (currentElement.ownerBase as TableRowWidget).ownerTable;
                }
                let container: BlockContainer = block.containerWidget as BlockContainer;
                if (container instanceof TableCellWidget) {
                    let rowFormat: WRowFormat = container.ownerRow.rowFormat;
                    if (rowFormat.revisionLength > 0) {
                        previousRevisions = rowFormat.getAllRevision();
                    }
                }
            }

            // Logic to get a nextRevision

            if (currentElement instanceof ElementBox) {
                let nextNode: ElementBox = (currentElement as ElementBox).nextNode;
                let currentParagraph: ParagraphWidget = (currentElement.paragraph.getSplitWidgets()[0] as ParagraphWidget);
                if (nextNode instanceof ElementBox && nextNode.revisionLength > 0) {
                    nextRevisions = nextNode.getAllRevision();
                } else if (isNullOrUndefined(nextNode) && currentParagraph.characterFormat.revisionLength > 0) {
                    nextRevisions = currentParagraph.characterFormat.getAllRevision();
                }
            } else if (currentElement instanceof WCharacterFormat) {
                let block: ParagraphWidget = currentElement.ownerBase as ParagraphWidget;
                let splittedParagraph: ParagraphWidget[] = block.getSplitWidgets() as ParagraphWidget[];
                let nextBlock: BlockWidget = splittedParagraph[splittedParagraph.length - 1].nextRenderedWidget as BlockWidget;
                let nextElement: ElementBox | WCharacterFormat;
                if (nextBlock instanceof ParagraphWidget) {
                    if (nextBlock.isEmpty()) {
                        nextElement = nextBlock.characterFormat;
                    } else {
                        nextElement = this.getNextNodeRevision((nextBlock.firstChild as LineWidget).children[0]);
                        if (isNullOrUndefined(nextElement) && nextBlock instanceof ParagraphWidget) {
                            nextElement = nextBlock.characterFormat;
                        }
                    }
                }
                if (!isNullOrUndefined(nextElement) && nextElement.revisionLength > 0) {
                    nextRevisions = nextElement.getAllRevision();
                }
            } else if (currentElement instanceof WRowFormat) {
                let rowWidget: TableRowWidget = currentElement.ownerBase;
                let nextRow: TableRowWidget = rowWidget.nextRenderedWidget as TableRowWidget;
                if (!isNullOrUndefined(nextRow) && nextRow.rowFormat.revisionLength > 0) {
                    nextRevisions = nextRow.rowFormat.getAllRevision();
                }
            }
        }
        // ---
        // Split view if both previous and next revisions view are same
        // ---
        if (previousRevisions && nextRevisions) {
            for (const prevRev of previousRevisions) {
                const previousSingleView = this.owner.trackChangesPane.changes.get(prevRev);
                if (previousSingleView) {
                    for (const nextRev of nextRevisions) {
                        const nextSingleView = this.owner.trackChangesPane.changes.get(nextRev);
                        if (nextSingleView && previousSingleView === nextSingleView) {
                            const threadIndex: number = previousSingleView.outerSingleDiv ?
                                this.owner.revisions.getChildIndexQuery(previousSingleView.outerSingleDiv) : 0;
                            this.owner.revisions.splitView(prevRev, previousSingleView, nextSingleView, threadIndex);
                            break;
                        }
                    }
                }
            }
        }
    }
    /**
     *
     * @private
     * @returns {void}
     */
    public combineRevisionsAndViewBasedOnUntrackedContent(currentElement: (ElementBox | WCharacterFormat | WRowFormat)): void {
        let previousRevisions: Revision[];
        let nextRevisions: Revision[];
        if (currentElement.revisionLength === 0) {
            // Logic to get a previousRevision
            if (currentElement instanceof ElementBox) {
                let previousElement: ElementBox = this.getPreviousNodeRevision(currentElement.previousNode);
                let currentParagraph: ParagraphWidget = (currentElement.paragraph.getSplitWidgets()[0] as ParagraphWidget);
                let previousBlock: BlockWidget = currentParagraph.previousRenderedWidget as BlockWidget;
                if (previousElement instanceof ElementBox && previousElement.revisionLength > 0) {
                    previousRevisions = previousElement.getAllRevision();
                }
                else if (isNullOrUndefined(previousElement) && previousBlock instanceof ParagraphWidget && previousBlock.characterFormat.revisionLength > 0) {
                    previousRevisions = previousBlock.characterFormat.getAllRevision();

                }
            } else if (currentElement instanceof WCharacterFormat) {
                let block: ParagraphWidget = currentElement.ownerBase as ParagraphWidget;
                let splittedParagraph: ParagraphWidget[] = block.getSplitWidgets() as ParagraphWidget[];
                let previousBlock: BlockWidget = splittedParagraph[0].previousRenderedWidget as BlockWidget;
                let previousElement: ElementBox | WCharacterFormat;
                if (block.isEmpty() && previousBlock instanceof ParagraphWidget) {
                    previousElement = previousBlock.characterFormat;
                } else {
                    let lastLine: LineWidget = (splittedParagraph[splittedParagraph.length - 1].lastChild as LineWidget);
                    previousElement = this.getPreviousNodeRevision(lastLine.children[lastLine.children.length - 1]);
                    if (isNullOrUndefined(previousElement) && previousBlock instanceof ParagraphWidget) {
                        previousElement = previousBlock.characterFormat;
                    }
                }
                if (!isNullOrUndefined(previousElement) && previousElement.revisionLength > 0) {
                    previousRevisions = previousElement.getAllRevision();
                }
            } else if (currentElement instanceof WRowFormat) {
                let rowWidget: TableRowWidget = currentElement.ownerBase;
                let previousRow: TableRowWidget = rowWidget.previousRenderedWidget as TableRowWidget;
                if (!isNullOrUndefined(previousRow) && previousRow.rowFormat.revisionLength > 0) {
                    previousRevisions = previousRow.rowFormat.getAllRevision();
                }
            }
            if (isNullOrUndefined(previousRevisions)) {
                let block: BlockWidget;
                if (currentElement instanceof ElementBox) {
                    block = currentElement.paragraph;
                } else if (currentElement instanceof WCharacterFormat) {
                    block = currentElement.ownerBase as ParagraphWidget;
                } else if (currentElement instanceof WRowFormat) {
                    block = (currentElement.ownerBase as TableRowWidget).ownerTable;
                }
                let container: BlockContainer = block.containerWidget as BlockContainer;
                if (container instanceof TableCellWidget) {
                    let rowFormat: WRowFormat = container.ownerRow.rowFormat;
                    if (rowFormat.revisionLength > 0) {
                        previousRevisions = rowFormat.getAllRevision();
                    }
                }
            }

            // Logic to get a nextRevision

            if (currentElement instanceof ElementBox) {
                let nextNode: ElementBox = (currentElement as ElementBox).nextNode;
                let currentParagraph: ParagraphWidget = (currentElement.paragraph.getSplitWidgets()[0] as ParagraphWidget);
                if (nextNode instanceof ElementBox && nextNode.revisionLength > 0) {
                    nextRevisions = nextNode.getAllRevision();
                } else if (isNullOrUndefined(nextNode) && currentParagraph.characterFormat.revisionLength > 0) {
                    nextRevisions = currentParagraph.characterFormat.getAllRevision();
                }
            } else if (currentElement instanceof WCharacterFormat) {
                let block: ParagraphWidget = currentElement.ownerBase as ParagraphWidget;
                let splittedParagraph: ParagraphWidget[] = block.getSplitWidgets() as ParagraphWidget[];
                let nextBlock: BlockWidget = splittedParagraph[splittedParagraph.length - 1].nextRenderedWidget as BlockWidget;
                let nextElement: ElementBox | WCharacterFormat;
                if (nextBlock instanceof ParagraphWidget) {
                    if (nextBlock.isEmpty()) {
                        nextElement = nextBlock.characterFormat;
                    } else {
                        nextElement = this.getNextNodeRevision((nextBlock.firstChild as LineWidget).children[0]);
                        if (isNullOrUndefined(nextElement) && nextBlock instanceof ParagraphWidget) {
                            nextElement = nextBlock.characterFormat;
                        }
                    }
                }
                if (!isNullOrUndefined(nextElement) && nextElement.revisionLength > 0) {
                    nextRevisions = nextElement.getAllRevision();
                }
            } else if (currentElement instanceof WRowFormat) {
                let rowWidget: TableRowWidget = currentElement.ownerBase;
                let nextRow: TableRowWidget = rowWidget.nextRenderedWidget as TableRowWidget;
                if (!isNullOrUndefined(nextRow) && nextRow.rowFormat.revisionLength > 0) {
                    nextRevisions = nextRow.rowFormat.getAllRevision();
                }
            }
        }
        // ---
        // Combine view if both previous and next revision are same revisions but the view is different
        // ---
        if (previousRevisions && nextRevisions) {
            for (let i = 0; i < previousRevisions.length; i++) {
                const previousSingleView = this.owner.trackChangesPane.changes.get(previousRevisions[i]);
                for (let j = 0; j < nextRevisions.length; j++) {
                    const nextSingleView = this.owner.trackChangesPane.changes.get(nextRevisions[j]);
                    if (previousSingleView && nextSingleView && previousSingleView !== nextSingleView
                        && this.compareTwoRevisions(previousRevisions[i], nextRevisions[j])) {
                        this.owner.revisions.combineWithNextRevision(previousRevisions[i], nextRevisions[j]);
                    }
                }
            }
        }
    }
    /**
     * Fits the table based on AutoFitType.
     *
     * @param {AutoFitType} fitType Specify the auto fit type.
     * @returns {void}
     */
    public autoFitTable(fitType: AutoFitType): void {
        if (this.documentHelper.owner.isReadOnlyMode || !this.canEditContentControl) {
            return;
        }
        this.insertAutoFitTable(fitType);
    }
    /**
     *
     * @private
     * @returns {void}
     */
    public insertAutoFitTable(fitType: AutoFitType, tableAdv?: TableWidget): void {
        if(isNullOrUndefined(tableAdv)) {
            let startPosition: TextPosition = this.selection.start;
            let endPosition: TextPosition = this.selection.end;
            if (!this.selection.isForward) {
                startPosition = this.selection.end;
                endPosition = this.selection.start;
            }
            tableAdv = this.selection.getTable(startPosition, endPosition);
            tableAdv = tableAdv.getSplitWidgets()[0] as TableWidget;
        }
        let parentTable: TableWidget = this.documentHelper.layout.getParentTable(tableAdv);
        if (!isNullOrUndefined(parentTable)) {
            this.setOffsetValue(this.selection);
            parentTable = parentTable.combineWidget(this.owner.viewer) as TableWidget;
            this.initHistory(fitType === 'FitToContents' ? 'TableAutoFitToContents' : fitType === 'FitToWindow' ? 'TableAutoFitToWindow' : 'TableFixedColumnWidth');
            if (this.documentHelper.owner.editorHistoryModule) {
                this.cloneTableToHistoryInfo(parentTable);
            }
            parentTable.updateProperties(true, tableAdv, fitType);
            this.documentHelper.owner.isShiftingEnabled = true;
            //Layouts the table.
            this.documentHelper.layout.reLayoutTable(tableAdv);
            this.reLayout(this.selection, true);
        }
    }

    /**
     * Inserting the row for collaborative editing.
     * @private
     * @returns {void}
     */
    public rowInsertionForCE(index: number, cellCount: number, insertrow: number, table: TableWidget, rowData: any, cellData: any[], paragraphData: any[], characterData: any[]): void {
        let rows: TableRowWidget[] = [];
        for (let i: number = 0; i < insertrow; i++) {
            let newRow: TableRowWidget = this.createRowAndColumn(cellCount, i, index, table);
            this.documentHelper.owner.parser.parseRowFormat(rowData, newRow.rowFormat, 0);
            for (let j: number = 0; j < cellCount; j++) {
                let cellWidget: TableCellWidget = newRow.childWidgets[j] as TableCellWidget;
                this.documentHelper.owner.parser.parseCellFormat(cellData[j], cellWidget.cellFormat, 0);
                this.documentHelper.owner.parser.parseParagraphFormat(0, paragraphData[j], (cellWidget.childWidgets[0] as ParagraphWidget).paragraphFormat);
                this.documentHelper.owner.parser.parseCharacterFormat(0, characterData[j], (cellWidget.childWidgets[0] as ParagraphWidget).characterFormat);
            }
            rows.push(newRow);
        }
        let newRows: TableRowWidget[] =  [...rows];
        table.insertTableRowsInternal(rows, index, true);
        if (this.owner.enableTrackChanges) {
            for (let i: number = 0; i < newRows.length; i++) {
                this.insertRevision(newRows[i].rowFormat, 'Insertion');
            }
        }
        this.splitRevisionsAndViewBasedOnUntrackedContent((table.childWidgets[index] as TableRowWidget).rowFormat);
        let cell: TableCellWidget = undefined;
        let paragraph: ParagraphWidget = undefined;
        if ((table.childWidgets[index] instanceof TableRowWidget)) {
            cell = ((table.childWidgets[index] as TableRowWidget).firstChild as TableCellWidget);
            paragraph = this.selection.getFirstParagraph(cell);
        } else {
            let widget: Widget = undefined;
            while (!(widget instanceof TableWidget)) {
                widget = table.nextRenderedWidget;
            }
            paragraph = this.documentHelper.getFirstParagraphInFirstCell(widget);
        }
        this.documentHelper.layout.reLayoutTable(table);
        this.selection.selectParagraphInternal(paragraph, true);
        this.reLayout(this.selection, true);
    }

    private updateCellFormatForInsertedRow(newRow: TableRowWidget, cellFormats: WCellFormat[]): void {
        for (let i: number = 0; i < newRow.childWidgets.length; i++) {
            (newRow.childWidgets[i] as TableCellWidget).cellFormat.copyFormat(cellFormats[i]);
            (newRow.childWidgets[i] as TableCellWidget).cellFormat.rowSpan = 1;
        }
    }
    private updateRowspan(row: TableRowWidget, startCell: TableCellWidget, rowPlacement: RowPlacement): CellCountInfo {
        let spannedCells: TableCellWidget[] = row.getPreviousRowSpannedCells(true);
        let count: number = 0;
        let cellFormats: WCellFormat[] = [];
        for (let i: number = 0; i < row.childWidgets.length; i++) {
            let cell: TableCellWidget = row.childWidgets[i] as TableCellWidget;
            let isCellIncluded: boolean = false;
            // Need to check with all the row spanned cells. if the start cell contains rowspan greater than 1, 
            // and when inserting below, need to increment rowspan for all row spanned cells by 1 except
            // if the spanned cells is placed in the same column or cell to be cloned has the same row index of cloned cell row index.
            // and when inserting above, if cloned cell placed in the same row of start cell or
            // if the cloned cell has equal column index, need to skip updating rowspan value of cloned cell.
            // else update row span value for spanned cell except 
            // if the spanned cells is placed in the same column or cell to be cloned has the same row index of cloned cell row index.
            let isRowSpanned: boolean = (isNullOrUndefined(cell.previousWidget)
                || cell.columnIndex !== (cell.previousWidget as TableCellWidget).columnIndex + 1);
            for (let j: number = 0; j < spannedCells.length; j++) {
                if (isRowSpanned) {
                    let spannedCell: TableCellWidget = spannedCells[j];

                    let clonedRowIndex: number = spannedCell.ownerRow.rowIndex + spannedCell.cellFormat.rowSpan - 1;

                    if (cell.columnIndex < spannedCell.columnIndex && cell.cellIndex !== cell.columnIndex && !isCellIncluded) {
                        isCellIncluded = true;
                        count++;
                        cellFormats.push(cell.cellFormat);
                    }
                    if (startCell.cellFormat.rowSpan === 1) {
                        // Need to check whether cell is affected by a row spanned cell. if cell is placed on the row where it is affected 
                        // by row spanned cell, then if we are inserting row below, need to add new cell with spanned cell width
                        // or if we are inserting above, need to update row span value of the spanned cell.
                        // if cell is placed inbetween the spanned cell , 
                        // then if we are inserting below, need to update row span value of spanned cell or
                        // if we are inserting above, need to skip updating row span value except
                        // if start cell is placed on the same row of spanned cell or if start cell placed in the same column.
                        if (clonedRowIndex > cell.ownerRow.rowIndex) {
                            if (rowPlacement === 'Above'
                                && spannedCell.ownerRow === startCell.ownerRow) {
                                continue;
                            } else {
                                spannedCell.cellFormat.rowSpan += 1;
                                spannedCells.splice(j, 1);
                                j--;
                            }
                        } else if (cell.cellIndex !== cell.columnIndex && isRowSpanned && clonedRowIndex === cell.ownerRow.rowIndex) {
                            if (rowPlacement === 'Above') {
                                spannedCell.cellFormat.rowSpan += 1;
                                spannedCells.splice(j, 1);
                                j--;
                            } else {
                                count++;
                                cellFormats.push(spannedCell.cellFormat);
                                spannedCells.splice(j, 1);
                                j--;
                            }
                        }
                    } else {
                        if (spannedCell !== startCell) {
                            if (rowPlacement === 'Above'
                                && (spannedCell.ownerRow === startCell.ownerRow || spannedCell.columnIndex === startCell.columnIndex)) {
                                continue;
                            } else {
                                if (spannedCell.columnIndex !== startCell.columnIndex
                                    && spannedCell.ownerRow.rowIndex !== cell.ownerRow.rowIndex
                                    && (clonedRowIndex > startCell.ownerRow.rowIndex
                                        || (rowPlacement === 'Above' && clonedRowIndex === startCell.ownerRow.rowIndex))) {
                                    spannedCell.cellFormat.rowSpan += 1;
                                    spannedCells.splice(j, 1);
                                    j--;
                                }
                            }
                        }
                    }
                }
            }
            if (spannedCells.indexOf(cell) === -1 && cell.cellFormat.rowSpan > 1) {
                isCellIncluded = true;
            }
            if (!isCellIncluded) {
                count++;
                cellFormats.push(cell.cellFormat);
            }
        }
        cellFormats.sort((a: WCellFormat, b: WCellFormat) => (a.ownerBase as TableCellWidget).columnIndex - (b.ownerBase as TableCellWidget).columnIndex);
        return { count, cellFormats };
    }

    private getInsertedTable(table: TableWidget, index: number): void {
        if (table.childWidgets && table.childWidgets.length > 0) {
            table.childWidgets.splice(0, index);
            if (this.owner.enableCollaborativeEditing) {
                this.editorHistory.currentBaseHistoryInfo.insertedNodes.push(table);
            }
        }
    }

    private insertTableRows(table: TableWidget, prevBlock: TableWidget, isInsertRevision?: boolean): void {
        this.initHistory('InsertTableBelow');
        table.containerWidget = prevBlock.containerWidget;
        prevBlock = prevBlock.combineWidget(this.owner.viewer) as TableWidget;
        // if (this.editorHistory) {
        //     let clonedTable: TableWidget = this.cloneTableToHistoryInfo(prevBlock);
        // }
        let row: TableRowWidget = prevBlock.childWidgets[prevBlock.childWidgets.length - 1] as TableRowWidget;
        let index: number = prevBlock.childWidgets.length;
        let initilizeCellBorder: boolean = false;
        let newTableBorders: WBorders = table.tableFormat.borders;
        let prevTableBorders: WBorders = prevBlock.tableFormat.borders;
        if (newTableBorders.left.lineStyle !== prevTableBorders.left.lineStyle || newTableBorders.top.lineStyle !== prevTableBorders.top.lineStyle ||
            newTableBorders.right.lineStyle !== prevTableBorders.right.lineStyle || newTableBorders.bottom.lineStyle !== prevTableBorders.bottom.lineStyle) {
            initilizeCellBorder = true;
        }
        prevBlock.insertTableRowsInternal(table.childWidgets as TableRowWidget[], index, true, initilizeCellBorder);
        let cloneTable: TableWidget = prevBlock.clone();
        this.getInsertedTable(cloneTable, index);
        if (isInsertRevision && this.owner.enableTrackChanges) {
            for (let i: number = index; i < prevBlock.childWidgets.length; i++) {
                let tableRow: TableRowWidget = prevBlock.childWidgets[i] as TableRowWidget;
                this.insertRevision(tableRow.rowFormat, 'Insertion');
            }
        }
        let paragraph: ParagraphWidget = this.selection.getFirstParagraph(row.nextWidget.childWidgets[0] as TableCellWidget);
        prevBlock.isDefaultFormatUpdated = false;
        this.documentHelper.layout.reLayoutTable(prevBlock);
        if (this.checkInsertPosition(this.selection)) {
            this.updateHistoryPosition(this.selection.getHierarchicalIndex(paragraph, '0'), true);
        }
        this.selection.start.setPosition(paragraph.firstChild as LineWidget, true);
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            this.updateHistoryPosition(this.selection.end, false);
        }
        this.selection.end.setPosition(paragraph.firstChild as LineWidget, true);
        this.reLayout(this.selection);
    }
    /**
     * Inserts the specified number of columns to the table left or right to the column at cursor position.
     *
     * @param {number} left The left parameter is optional and if omitted, it takes the value as false and 
     * inserts to the right of column at cursor position.
     * @param {number} count The count parameter is optional and if omitted, it takes the value as 1.
     * @returns {void}
     */
    public insertColumn(left?: boolean, count?: number): void {
        if (this.owner.isReadOnlyMode || !this.canEditContentControl) {
            return;
        }
        let columnPlacement: ColumnPlacement = left ? 'Left' : 'Right';
        if (this.selection.start.paragraph.isInsideTable) {
            if (this.checkIsNotRedoing()) {
                this.initHistory(columnPlacement === 'Left' ? 'InsertColumnLeft' : 'InsertColumnRight');
            }
            this.selection.owner.isShiftingEnabled = true;
            let startCell: TableCellWidget = this.getOwnerCell(this.selection.isForward);
            let endCell: TableCellWidget = this.getOwnerCell(!this.selection.isForward);
            let table: TableWidget = startCell.ownerRow.ownerTable.combineWidget(this.owner.viewer) as TableWidget;
            if (this.editorHistory) {
                //Clones the entire table to preserve in history.
                this.cloneTableToHistoryInfo(table);
            }
            this.selection.owner.isLayoutEnabled = false;
            let cellIndex: number = startCell.columnIndex;
            if (columnPlacement === 'Right') {
                cellIndex = endCell.columnIndex + endCell.cellFormat.columnSpan;
            }
            let startParagraph: ParagraphWidget = undefined;
            let newCell: TableCellWidget = undefined;
            let columnCount: number = count ? count : this.getColumnCountToInsert();
            let rowSpannedCells: TableCellWidget[] = [];
            //let rowSpanCellIndex: number = cellIndex;
            for (let i: number = 0; i < columnCount; i++) {
                for (let j: number = 0; j < table.childWidgets.length; j++) {
                    let row: TableRowWidget = table.childWidgets[j] as TableRowWidget;
                    newCell = this.createColumn(this.selection.getLastParagraph(startCell));
                    newCell.index = j;
                    newCell.rowIndex = row.rowIndex;
                    newCell.containerWidget = row;
                    newCell.cellFormat.copyFormat(startCell.cellFormat);
                    newCell.cellFormat.rowSpan = 1;
                    if (isNullOrUndefined(startParagraph)) {
                        startParagraph = this.selection.getFirstParagraph(newCell);
                    }
                    if (cellIndex === 0) {
                        row.childWidgets.splice(cellIndex, 0, newCell);
                    } else {
                        this.insertSpannedCells(row, rowSpannedCells, newCell, cellIndex);
                    }
                    this.copyCellFormats(row, cellIndex);
                    for (let i: number = 0; i < row.rowFormat.revisionLength; i++) {
                        row.rowFormat.getRevision(i).hasChanges = true;
                    }
                    if (this.owner.enableCollaborativeEditing) {
                        this.editorHistory.currentBaseHistoryInfo.insertedNodes.push(newCell); 
                    }
                }
            }
            this.tableReLayout(table, startParagraph, newCell);
        }
    }
    /**
     * Inserting the cell for collaborative editing.
     * @private
     * @returns {void}
     */
    public cellInsertionForCE(index: number, row: TableRowWidget, cellData: any, paragraphData: any, characterData: any): void {
        let startParagraph: ParagraphWidget = undefined;
        let newCell: TableCellWidget = undefined;
        newCell = this.createColumn(undefined);
        let line: LineWidget = new LineWidget(newCell.childWidgets[0] as ParagraphWidget);
        (newCell.childWidgets[0] as ParagraphWidget).childWidgets.push(line);
        newCell.index = row.index;
        newCell.rowIndex = row.rowIndex;
        newCell.containerWidget = row;
        this.documentHelper.owner.parser.parseCellFormat(cellData, newCell.cellFormat, 0);
        this.documentHelper.owner.parser.parseParagraphFormat(0, paragraphData, (newCell.childWidgets[0] as ParagraphWidget).paragraphFormat);
        this.documentHelper.owner.parser.parseCharacterFormat(0, characterData, (newCell.childWidgets[0] as ParagraphWidget).characterFormat);
        newCell.cellFormat.rowSpan = 1;
        row.childWidgets.splice(index, 0, newCell);
    }

    private copyCellFormats(row: TableRowWidget, index: number) {
        let newCell: TableCellWidget = row.childWidgets[index] as TableCellWidget;
        if (!isNullOrUndefined(newCell)) {
            let newCellPara: ParagraphWidget = newCell.childWidgets[0] as ParagraphWidget;
            (index == (row.childWidgets.length - 1)) ? --index : ++index;
            let nextCell: TableCellWidget = row.childWidgets[index] as TableCellWidget;
            let widget: BlockWidget = nextCell.childWidgets[0] as BlockWidget;
            while (widget instanceof TableWidget) {
                widget = ((widget.childWidgets[0] as TableRowWidget).childWidgets[0] as TableCellWidget).childWidgets[0] as BlockWidget;
            }
            let nextCellpara: ParagraphWidget = nextCell.childWidgets[0] as ParagraphWidget;
            let line: LineWidget;
            let nextCellTextBox: TextElementBox;
            if (nextCellpara.childWidgets.length > 0) {
                line = nextCellpara.childWidgets[0] as LineWidget;
                if (line.children.length > 0) {
                    nextCellTextBox = line.children[0] as TextElementBox;
                }
            }
            newCellPara.paragraphFormat.copyFormat(nextCellpara.paragraphFormat);
            if (!isNullOrUndefined(nextCellTextBox)) {
                newCellPara.characterFormat.copyFormat(nextCellTextBox.characterFormat);
            } else {
                newCellPara.characterFormat.copyFormat(nextCellpara.characterFormat);
            }
        }
    }

    private copyContent(table: TableWidget): void {
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo && this.owner.enableCollaborativeEditing) {
            let lastPara: ParagraphWidget = this.documentHelper.getLastParagraphBlock(table);
            let firstPara: ParagraphWidget = this.documentHelper.getFirstParagraphBlock(table);
            if (firstPara.childWidgets.length === 0) {
                firstPara.childWidgets[0] = new LineWidget(firstPara);
            }
            if (lastPara.childWidgets.length === 0) {
                lastPara.childWidgets[0] = new LineWidget(lastPara);
            }
            let startLine: LineWidget = firstPara.firstChild as LineWidget;
            let lastLine: LineWidget = lastPara.lastChild as LineWidget;
            let endoffset: number = (lastPara.lastChild as LineWidget).getEndOffset();
            let documentContent: any = !isNullOrUndefined(this.owner.sfdtExportModule) ? this.owner.sfdtExportModule.write((this.owner.documentEditorSettings.optimizeSfdt ? 1 : 0), startLine, 0, lastLine, endoffset, false, true) : {};
            this.editorHistory.currentBaseHistoryInfo.pasteContent = documentContent;
        }
    } 

    private tableReLayout(table: TableWidget, startParagraph: ParagraphWidget, newCell: TableCellWidget, isCollaborativePaste?: Boolean): void {
        table.updateRowIndex(0);
        let parentTable: TableWidget = this.documentHelper.layout.getParentTable(table);
        if (parentTable) {
            parentTable.fitChildToClientArea();
        } else {
            table.fitChildToClientArea();
        }
        this.selection.owner.isLayoutEnabled = true;
        table.isGridUpdated = false;
        table.buildTableColumns();
        table.isGridUpdated = true;
        this.documentHelper.skipScrollToPosition = true;
        if (isCollaborativePaste) {
            this.copyContent(table);
        }
        this.documentHelper.layout.reLayoutTable(table);
        this.selection.start.setPosition(startParagraph.firstChild as LineWidget, true);
        this.selection.end.setPosition(this.selection.getLastParagraph(newCell).firstChild as LineWidget, false);
        if (this.checkIsNotRedoing() || isNullOrUndefined(this.editorHistory)) {
            this.reLayout(this.selection);
        }
    }

    /**
     * Creates table with specified rows and columns.
     * @private
     * 
     * @returns {TableWidget}
     */
    public createTable(rows: number, columns: number): TableWidget {
        let startPara: ParagraphWidget = this.selection.start.paragraph;
        let table: TableWidget = new TableWidget();
        table.tableFormat.preferredWidthType = 'Auto';
        table.tableFormat.leftIndent = this.selection.start.paragraph.leftIndent;
        table.tableFormat.initializeTableBorders();
        let index: number = 0;
        while (index < rows) {
            let tableRow: TableRowWidget = this.createRowAndColumn(columns, index);
            tableRow.rowFormat.heightType = 'Auto';
            tableRow.containerWidget = table;
            table.childWidgets.push(tableRow);
            index++;
        }
        return table;
    }
    private createRowAndColumn(columns: number, rowIndex: number, index?: number, table?: TableWidget): TableRowWidget {
        let tableWidget: TableWidget = table;
        let startPara: ParagraphWidget = this.selection.start.paragraph;
        let tableRow: TableRowWidget = new TableRowWidget();
        tableRow.rowFormat = new WRowFormat(tableRow);
        tableRow.index = rowIndex;
        for (let i: number = 0; i < columns; i++) {
            if (!isNullOrUndefined(index) && !isNullOrUndefined(tableWidget)) {
                if (index && index > 0 && tableWidget.childWidgets[index - 1] && (tableWidget.childWidgets[index - 1] as TableRowWidget).childWidgets[i]) {
                    let widget: BlockWidget = ((tableWidget.childWidgets[index - 1] as TableRowWidget).childWidgets[i] as TableCellWidget).childWidgets[0] as ParagraphWidget;
                    while (widget instanceof TableWidget) {
                        widget = ((widget.childWidgets[0] as TableRowWidget).childWidgets[0] as TableCellWidget).childWidgets[0] as BlockWidget;
                    }
                    startPara = widget as ParagraphWidget;
                }
                else if (index == 0) {
                    let widget: BlockWidget = ((tableWidget.childWidgets[index] as TableRowWidget).childWidgets[i] as TableCellWidget).childWidgets[0] as BlockWidget;
                    while (widget instanceof TableWidget) {
                        widget = ((widget.childWidgets[0] as TableRowWidget).childWidgets[0] as TableCellWidget).childWidgets[0] as BlockWidget;
                    }
                    startPara = widget as ParagraphWidget;
                }
            }
            let tableCell: TableCellWidget = this.createColumn(startPara, true);
            tableCell.index = i;
            tableCell.rowIndex = rowIndex;
            tableCell.containerWidget = tableRow;
            tableRow.childWidgets.push(tableCell);
        }
        return tableRow;
    }
    private createColumn(paragraph: ParagraphWidget, isNewRow?: boolean): TableCellWidget {
        let tableCell: TableCellWidget = new TableCellWidget();
        let para: ParagraphWidget = new ParagraphWidget();
        let line: LineWidget = new LineWidget(para);
        para.childWidgets.push(line);
        if (isNewRow) {
            para.paragraphFormat.copyFormat(paragraph.paragraphFormat);
            para.paragraphFormat.leftIndent = 0;
            para.paragraphFormat.firstLineIndent = 0;
            let elementBox: TextElementBox ;
            if(!isNullOrUndefined(paragraph.childWidgets[0])){
                elementBox = (paragraph.childWidgets[0] as LineWidget).children[0] as TextElementBox;
            }
            if(!isNullOrUndefined(elementBox)){
                para.characterFormat.copyFormat(elementBox.characterFormat);
            } else {
                para.characterFormat.copyFormat(paragraph.characterFormat);
            }
            para.characterFormat.removedIds = [];
        }
        if (paragraph && paragraph.associatedCell) {
            tableCell.columnIndex = paragraph.associatedCell.columnIndex;
        }
        para.containerWidget = tableCell;
        tableCell.childWidgets.push(para);
        tableCell.cellFormat = new WCellFormat(tableCell);
        return tableCell;
    }
    private getColumnCountToInsert(): number {
        let count: number = 1;
        let start: TextPosition = this.selection.start;
        let end: TextPosition = this.selection.end;
        if (!this.selection.isForward) {
            start = this.selection.end;
            end = this.selection.start;
        }
        if (start && end && this.selection.getTable(start, end)) {
            if (start.paragraph.associatedCell === end.paragraph.associatedCell) {
                return count = 1;
            }
            if (start.paragraph.associatedCell.ownerRow === end.paragraph.associatedCell.ownerRow) {
                return count = count + end.paragraph.associatedCell.cellIndex - start.paragraph.associatedCell.cellIndex;
            } else {
                count = 0;

                let selectedCells: TableCellWidget[] = start.paragraph.associatedCell.ownerTable.getColumnCellsForSelection(start.paragraph.associatedCell, end.paragraph.associatedCell);
                for (let i: number = 0; i < selectedCells.length; i++) {
                    if (start.paragraph.associatedCell.ownerRow === selectedCells[i].ownerRow) {
                        count++;
                    }
                }
            }
        }
        return count === 0 ? 1 : count;
    }
    private getRowCountToInsert(): number {
        let count: number = 1;
        let start: TextPosition = this.selection.start;
        let end: TextPosition = this.selection.end;
        if (!this.selection.isForward) {
            start = this.selection.end;
            end = this.selection.start;
        }
        if (!isNullOrUndefined(start) && !isNullOrUndefined(end) && !isNullOrUndefined(this.selection.getTable(start, end))) {
            if (start.paragraph.associatedCell === end.paragraph.associatedCell ||
                start.paragraph.associatedCell.ownerRow === end.paragraph.associatedCell.ownerRow) {
                return count = 1;
            } else {
                return count = count +
                    this.getOwnerRow(!this.selection.isForward).rowIndex - this.getOwnerRow(this.selection.isForward).rowIndex;
            }
        }
        return count === 0 ? 1 : count;
    }
    /**
     * @private
     */
    public getOwnerCell(isStart: boolean): TableCellWidget {
        let cell: TableCellWidget = undefined;
        let startCell: TableCellWidget = isStart ? this.selection.start.paragraph.associatedCell
            : this.selection.end.paragraph.associatedCell;
        let endCell: TableCellWidget = isStart ? this.selection.end.paragraph.associatedCell
            : this.selection.start.paragraph.associatedCell;
        cell = startCell;
        let owner: TableWidget = cell.ownerTable;
        while (!isNullOrUndefined(owner) && owner.containerWidget instanceof TableCellWidget && owner !== endCell.ownerTable) {
            cell = (owner.containerWidget as TableCellWidget);
            owner = cell.ownerTable;
        }
        return cell;
    }
    private getOwnerRow(isStart: boolean): TableRowWidget {
        let row: TableRowWidget;
        let startRow: TableRowWidget = isStart ? this.selection.start.paragraph.associatedCell.ownerRow
            : this.selection.end.paragraph.associatedCell.ownerRow;
        let endRow: TableRowWidget = isStart ? this.selection.end.paragraph.associatedCell.ownerRow
            : this.selection.start.paragraph.associatedCell.ownerRow;
        row = startRow;
        let owner: TableWidget = row.ownerTable;
        while (!isNullOrUndefined(owner) && owner.containerWidget instanceof TableCellWidget && owner !== endRow.ownerTable) {
            row = (owner.containerWidget as TableCellWidget).ownerRow;
            owner = row.ownerTable;
        }
        return row;
    }
    private getOwnerTable(isStart: boolean): TableWidget {
        let table: TableWidget = undefined;
        let startTable: TableWidget = this.selection.start.paragraph.isInsideTable ? this.selection.start.paragraph.associatedCell.ownerTable : undefined;
        let endTable: TableWidget = this.selection.end.paragraph.isInsideTable ? this.selection.end.paragraph.associatedCell.ownerTable : undefined;
        table = isStart ? startTable : endTable;
        while (!isNullOrUndefined(table) && table.containerWidget instanceof TableCellWidget && table !== (isStart ? endTable : startTable)) {
            table = (table.containerWidget as TableCellWidget).ownerTable;
        }
        return table;
    }
    /**
     * Merge Selected cells
     *
     * @private
     * @returns {void}
     */
    public mergeSelectedCellsInTable(): void {
        if (!this.canMergeCells()) {
            return;
        }
        if (this.owner.enableTrackChanges) {
            let localizeValue: L10n = new L10n('documenteditor', this.owner.defaultLocale);
            localizeValue.setLocale(this.owner.locale);
            this.alertDialog = DialogUtility.alert({
                title: localizeValue.getConstant('UnTrack'),
                content: localizeValue.getConstant('Merge Track'),
                showCloseIcon: true,
                okButton: {
                    text: 'Ok', click: this.confirmCellMerge.bind(this)
                },
                closeOnEscape: true,
                position: { X: 'center', Y: 'center' },
                animationSettings: { effect: 'Zoom' }
            });
            this.alertDialog.enableRtl = this.owner.enableRtl;
        } else {
            this.confirmCellMerge();
        }

    }
    private confirmCellMerge(): void {
        if (this.checkIsNotRedoing()) {
            this.initHistory('MergeCells');
        }
        this.selection.owner.isShiftingEnabled = true;
        let startPosition: TextPosition = this.selection.start;
        let endPosition: TextPosition = this.selection.end;
        if (!this.selection.isForward) {
            startPosition = this.selection.end;
            endPosition = this.selection.start;
        }
        let startOwnerCell: TableCellWidget = this.getOwnerCell(this.selection.isForward);
        let endOwnerCell: TableCellWidget = this.getOwnerCell(!this.selection.isForward);
        let containerCell: TableCellWidget = this.selection.getContainerCellOf(startOwnerCell, endOwnerCell);
        if (containerCell.ownerTable.contains(endOwnerCell)) {
            if (!this.selection.containsCell(containerCell, endOwnerCell)) {
                //Start and End are in different cells.               
                let table: TableWidget = startOwnerCell.ownerTable.combineWidget(this.owner.viewer) as TableWidget;
                startOwnerCell = this.selection.getSelectedCell(startOwnerCell, containerCell);
                endOwnerCell = this.selection.getSelectedCell(endOwnerCell, containerCell);
                //Merges the selected cells.               
                let mergedCell: TableCellWidget = this.mergeSelectedCells(table, startOwnerCell, endOwnerCell);
                let firstParagraph: ParagraphWidget = this.selection.getFirstParagraph(mergedCell);
                startPosition.setPosition(firstParagraph.firstChild as LineWidget, true);
                let lastParagraph: ParagraphWidget = this.selection.getLastParagraph(mergedCell);
                endPosition.setPosition(lastParagraph.lastChild as LineWidget, false);
                this.selection.fireSelectionChanged(false);
            }
        }
        if (this.checkIsNotRedoing() || isNullOrUndefined(this.editorHistory)) {
            this.reLayout(this.selection, false);
        }
        if (!isNullOrUndefined(this.alertDialog)) {
            this.alertDialog.close();
            this.alertDialog = undefined;
        }
    }
    private mergeSelectedCells(table: TableWidget, startCell: TableCellWidget, endCell: TableCellWidget): TableCellWidget {
        //Clones the entire table to preserve in history.
        let clonedTable: TableWidget = this.cloneTableToHistoryInfo(table);
        this.selection.owner.isLayoutEnabled = false;
        //Merges the selected cells.
        let start: number = this.selection.getCellLeft(startCell.ownerRow, startCell);
        let end: number = start + startCell.cellFormat.cellWidth;
        let endCellLeft: number = this.selection.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight: number = endCellLeft + endCell.cellFormat.cellWidth;
        let cellInfo: CellInfo = this.updateSelectedCellsInTable(start, end, endCellLeft, endCellRight);
        start = cellInfo.start;
        end = cellInfo.end;
        let endCellRowSpan: number = endCell.cellFormat.rowSpan;
        let count: number = table.childWidgets.indexOf(endCell.ownerRow);
        let rowStartIndex: number = table.childWidgets.indexOf(startCell.ownerRow);
        let mergedCell: TableCellWidget = undefined;
        let firstBlock: BlockWidget;
        for (let i: number = rowStartIndex; i <= count; i++) {
            let row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
            for (let j: number = 0; j < row.childWidgets.length; j++) {
                let cell: TableCellWidget = row.childWidgets[j] as TableCellWidget;
                let cellStart: number = this.selection.getCellLeft(row, cell);
                if (HelperMethods.round(start, 2) <= HelperMethods.round(cellStart, 2)
                    && HelperMethods.round(cellStart, 2) < HelperMethods.round(end, 2)) {
                    let lastBlock: BlockWidget = cell.lastChild as BlockWidget;
                    if (lastBlock instanceof ParagraphWidget && lastBlock.isEmpty()) {
                        cell.childWidgets.pop();
                    }
                    if (isNullOrUndefined(mergedCell)) {
                        mergedCell = cell;
                        firstBlock = lastBlock;
                    } else {
                        if (i === rowStartIndex) {
                            mergedCell.cellFormat.preferredWidth += cell.cellFormat.preferredWidth;
                            mergedCell.cellFormat.columnSpan += cell.cellFormat.columnSpan;
                            this.mergeBorders(mergedCell, cell);
                        }
                        for (let k: number = 0; k < cell.childWidgets.length; k++) {
                            let block: BlockWidget = cell.childWidgets[k] as BlockWidget;
                            let newBlock: BlockWidget = block.clone();
                            newBlock.containerWidget = mergedCell;
                            mergedCell.childWidgets.push(newBlock);
                            this.removeFieldInBlock(block);
                            this.removeFieldInBlock(block, true);
                        }
                        row.childWidgets.splice(j, 1);
                        cell.destroy();
                        j--;
                        for (var l = this.documentHelper.contentControlCollection.length - 1; l > -1; l--) {
                            var content = this.documentHelper.contentControlCollection[l];
                            if (isNullOrUndefined(content.contentControlProperties)) {
                                this.documentHelper.contentControlCollection.splice(l);
                            }
                        }
                    }
                }
            }
            //To Ensure minimul content. 

            if ((mergedCell.childWidgets.length === 0 || mergedCell.childWidgets.length === 1 && mergedCell.childWidgets[0] instanceof TableWidget) && firstBlock) {
                let newBlock: BlockWidget = firstBlock.clone();
                mergedCell.childWidgets.push(newBlock);
                newBlock.containerWidget = mergedCell;
            }
            if (row.childWidgets.length === 0) {
                let rowIndex: number = table.childWidgets.indexOf(row);
                row.updateRowBySpannedCells();
                table.childWidgets.splice(rowIndex, 1);
                // This line is commented because if we destroy the row it is also reflected in removedNodes in EditorHistoryModule which leads to exception while performing undo of merged cells.
                // row.destroy();
                count--;
                i--;
            }
        }
        if (!isNullOrUndefined(mergedCell) && rowStartIndex < count) {
            mergedCell.cellFormat.rowSpan = count - rowStartIndex + endCellRowSpan;
        }
        this.updateBlockIndexAfterMerge(mergedCell);
        table.updateRowIndex(0);
        table.calculateGrid();
        table.isGridUpdated = false;
        table.buildTableColumns();
        table.isGridUpdated = true;
        this.documentHelper.layout.linkFieldInTable(table);
        this.documentHelper.layout.reLayoutTable(table);
        //Layouts the table after merging cells.
        this.selection.owner.isLayoutEnabled = true;
        return mergedCell;
    }

    private mergeBorders(mergedCell: TableCellWidget, tableCell: TableCellWidget): void {
        let mergedCellborders: WBorders = undefined;
        let cellBorders: WBorders = null;
        if (!isNullOrUndefined(mergedCell.cellFormat.borders)) {
            mergedCellborders = mergedCell.cellFormat.borders;
        }
        if (!isNullOrUndefined(tableCell.cellFormat.borders)) {
            cellBorders = tableCell.cellFormat.borders;
        }
        if (isNullOrUndefined(mergedCellborders) && isNullOrUndefined(cellBorders)) {
            return;
        }
        if (isNullOrUndefined(mergedCellborders)) {
            mergedCellborders = new WBorders(mergedCell.cellFormat);
            mergedCellborders.copyFormat(cellBorders);
        } else if (isNullOrUndefined(cellBorders)) {
            return;
        } else {
            if (mergedCell.ownerRow.rowIndex === tableCell.ownerRow.rowIndex) {
                mergedCellborders.top = mergedCell.getBorderBasedOnPriority(mergedCellborders.top, cellBorders.bottom);
                mergedCellborders.bottom = mergedCell.getBorderBasedOnPriority(mergedCellborders.bottom, cellBorders.bottom);
            }
        }
    }
    private updateBlockIndexAfterMerge(cell: TableCellWidget): void {
        for (let i: number = 0; i < cell.childWidgets.length; i++) {
            (cell.childWidgets[i] as BlockWidget).index = i;
        }
    }
    /**
     * Determines whether the merge cell operation can be done.
     *
     * @returns {boolean} Returns true if to merge cells; Otherwise, false.
     */
    public canMergeCells(): boolean {
        if (this.selection.isEmpty || !this.selection.start.paragraph.isInsideTable || !this.selection.end.paragraph.isInsideTable) {
            return false;
        }
        let startPos: TextPosition = this.selection.start;
        let endPos: TextPosition = this.selection.end;
        if (!this.selection.isForward) {
            startPos = this.selection.end;
            endPos = this.selection.start;
        }
        let startCell: TableCellWidget = this.getOwnerCell(this.selection.isForward);
        let endCell: TableCellWidget = this.getOwnerCell(!this.selection.isForward);
        let containerCell: TableCellWidget = this.selection.getContainerCellOf(startCell, endCell);
        if (containerCell.ownerTable.contains(endCell)) {
            if (!this.selection.containsCell(containerCell, endCell)) {
                startCell = this.selection.getSelectedCell(startCell, containerCell);
                endCell = this.selection.getSelectedCell(endCell, containerCell);
                let rowSpan: number = 1;
                if (startCell.ownerRow === endCell.ownerRow) {
                    let startCellIndex: number = startCell.ownerRow.childWidgets.indexOf(startCell);
                    for (let i: number = startCellIndex; i <= startCell.ownerRow.childWidgets.indexOf(endCell); i++) {
                        let cell: TableCellWidget = startCell.ownerRow.childWidgets[i] as TableCellWidget;
                        let prevCell: TableCellWidget = cell.previousWidget as TableCellWidget;
                        if (i !== startCellIndex) {
                            if (cell.cellFormat.rowSpan !== rowSpan) {
                                return false;
                            }
                            if (!isNullOrUndefined(prevCell)
                                && cell.columnIndex !== (prevCell.cellFormat.columnSpan + prevCell.columnIndex)) {
                                return false;
                            }
                        }
                        rowSpan = cell.cellFormat.rowSpan;
                    }
                    return true;
                }
                return this.canMergeSelectedCellsInTable(startCell.ownerTable, startCell, endCell);
            }
        }
        return false;
    }
    private canMergeSelectedCellsInTable(table: TableWidget, startCell: TableCellWidget, endCell: TableCellWidget): boolean {
        let count: number = table.childWidgets.indexOf(endCell.ownerRow);
        let rowStartIndex: number = table.childWidgets.indexOf(startCell.ownerRow);
        let startLeft: number = this.selection.getCellLeft(startCell.ownerRow, startCell);
        let endLeft: number = startLeft + startCell.cellFormat.cellWidth;
        let endCellLeft: number = this.selection.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight: number = endCellLeft + endCell.cellFormat.cellWidth;
        let cellInfo: CellInfo = this.updateSelectedCellsInTable(startLeft, endLeft, endCellLeft, endCellRight);
        startLeft = cellInfo.start;
        endLeft = cellInfo.end;
        let selectionLeft: number = 0; let selectionRight: number = 0;
        let isRowLeftWithinSel: boolean = false;
        let isRowRightWithinSel: boolean = false;
        let rowSpannedCells: TableCellWidget[] = [];
        for (let i: number = rowStartIndex; i <= count; i++) {
            let row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
            let rowLeft: number = 0; let rowRight: number = 0;
            let isStarted: boolean = false;
            for (let j: number = 0; j < row.childWidgets.length; j++) {
                let cell: TableCellWidget = row.childWidgets[j] as TableCellWidget;
                let cellStart: number = this.selection.getCellLeft(row, cell);
                if (this.checkCellWithInSelection(startLeft, endLeft, cellStart)) {
                    isRowLeftWithinSel = false;
                    isRowRightWithinSel = false;
                    if (cell.cellFormat.rowSpan > 1) {
                        rowSpannedCells.push(cell);
                    }
                    if (!isStarted) {
                        rowLeft = cellStart;
                        rowRight = cellStart;
                        isStarted = true;
                    }
                    let prevCell: TableCellWidget = cell.previousWidget as TableCellWidget;
                    if (rowRight !== 0 && HelperMethods.round(rowRight, 0) !== HelperMethods.round(cellStart, 0)) {
                        rowRight = cellStart;
                    }
                    rowRight += HelperMethods.convertPointToPixel(cell.cellFormat.cellWidth);
                    let isPrevCellWithinSel: boolean = this.checkPrevOrNextCellIsWithinSel(startLeft, endLeft, cell, true);
                    let isNextCellWithinSel: boolean = this.checkPrevOrNextCellIsWithinSel(startLeft, endLeft, cell, false);
                    // When selected cell not having row spanned cells and column index is not having immediate cell index value,
                    // then returned false.
                    let isNoRowSpan: boolean = rowSpannedCells.length === 0 || rowSpannedCells.length === 1 && rowSpannedCells[0] === cell;
                    // checks whether current cell is with in selection.
                    let isCellWithInSel: boolean = this.checkCurrentCell(rowSpannedCells, cell, isPrevCellWithinSel, isNextCellWithinSel);
                    // when last selected row not having equal row span then returned false.
                    if (i === count && !isNullOrUndefined(prevCell) && cell.cellFormat.rowSpan > prevCell.cellFormat.rowSpan
                        && !isCellWithInSel) {
                        return false;
                    }
                    if (i !== rowStartIndex) {
                        for (let m: number = 0; m < rowSpannedCells.length; m++) {
                            {
                                let rowSpan: number = (rowSpannedCells[m].ownerRow.rowIndex + rowSpannedCells[m].cellFormat.rowSpan) - 1;
                                if (rowSpan >= row.rowIndex) {
                                    if (rowSpannedCells[m].columnIndex > cell.columnIndex) {
                                        isRowRightWithinSel = true;
                                    } else {
                                        isRowLeftWithinSel = true;
                                    }
                                    if (i === count && rowSpannedCells[m] !== cell
                                        && rowSpan > (cell.ownerRow.rowIndex + cell.cellFormat.rowSpan - 1)) {
                                        return false;
                                    }
                                    if (rowSpan === row.rowIndex && !this.checkPrevOrNextCellIsWithinSel(startLeft, endLeft, cell, false)) {
                                        rowSpannedCells.splice(rowSpannedCells.indexOf(rowSpannedCells[m]), 1);
                                    }
                                }
                            }
                        }
                    }
                    if (isPrevCellWithinSel && !isNullOrUndefined(prevCell)
                        && isNoRowSpan
                        && (cell.columnIndex !== prevCell.columnIndex + 1 && this.checkCellWidth(cell))) {
                        return false;
                    }
                }
            }
            if (i === rowStartIndex) {
                selectionLeft = rowLeft;
                selectionRight = rowRight;
            } else {
                if (rowRight > 0 && rowLeft > 0) {
                    if (!((isRowLeftWithinSel || Math.round(selectionLeft) === Math.round(rowLeft))
                        && (isRowRightWithinSel || Math.round(selectionRight) === Math.round(rowRight)))) {
                        return false;
                    }
                }
                if (i === count) {
                    return true;
                }
            }
        }
        return false;
    }
    private checkCellWidth(cell: TableCellWidget): boolean {
        let prevCell: TableCellWidget = cell.previousWidget as TableCellWidget;
        let cellLeft: number = this.documentHelper.selection.getCellLeft(cell.ownerRow, cell);
        let prevCellLeft: number = this.documentHelper.selection.getCellLeft(cell.ownerRow, prevCell);
        let left: number = prevCellLeft + HelperMethods.convertPointToPixel(prevCell.cellFormat.cellWidth);
        if (HelperMethods.round(left, 2) !== HelperMethods.round(cellLeft, 2)) {
            return true;
        }
        return false;
    }
    private checkCellWithInSelection(startLeft: number, endLeft: number, cellStart: number): boolean {
        if (HelperMethods.round(startLeft, 2) <= HelperMethods.round(cellStart, 2)
            && HelperMethods.round(cellStart, 2) < HelperMethods.round(endLeft, 2)) {
            return true;
        }
        return false;
    }
    private checkPrevOrNextCellIsWithinSel(startLeft: number, endLeft: number, cell: TableCellWidget, isPrev: boolean): boolean {
        let prevOrNextCell: TableCellWidget = isPrev ? cell.previousWidget as TableCellWidget : cell.nextWidget as TableCellWidget;
        let cellStart: number = 0;
        if (isNullOrUndefined(prevOrNextCell)) {
            return false;
        }
        cellStart = this.documentHelper.selection.getCellLeft(prevOrNextCell.ownerRow, prevOrNextCell);
        return this.checkCellWithInSelection(startLeft, endLeft, cellStart);
    }

    private checkCurrentCell(rowSpannedCells: TableCellWidget[], cell: TableCellWidget, isPrevCellWithInSel: boolean, isNextCellWithinSel: boolean): boolean {
        let cellOwner: TableRowWidget = cell.ownerRow;
        if (rowSpannedCells.length > 0) {
            for (let i: number = 0; i < rowSpannedCells.length; i++) {
                let spannedCellOwner: TableRowWidget = rowSpannedCells[i].ownerRow;
                let rowSpan: number = (spannedCellOwner.rowIndex + rowSpannedCells[i].cellFormat.rowSpan) - 1;
                if (rowSpannedCells[i] === cell && (rowSpannedCells.length === 1 || this.checkRowSpannedCells(rowSpannedCells, cell))
                    && !(isNextCellWithinSel || isPrevCellWithInSel)) {
                    return true;
                }
                if (rowSpannedCells[i] !== cell && spannedCellOwner.rowIndex < cellOwner.rowIndex
                    && rowSpan === (cellOwner.rowIndex + cell.cellFormat.rowSpan - 1)) {
                    return true;
                }
            }
        }
        return false;
    }
    private checkRowSpannedCells(rowSpannedCells: TableCellWidget[], cell: TableCellWidget): boolean {
        for (let i: number = 0; i < rowSpannedCells.length; i++) {
            if (rowSpannedCells[i] !== cell && rowSpannedCells[i].columnIndex === cell.columnIndex) {
                return true;
            }
        }
        return false;
    }
    /**
     * @private
     * @returns {void}
     */
    public insertNewParagraphWidget(newParagraph: ParagraphWidget, insertAfter: boolean): void {
        this.updateInsertPosition();
        this.insertParagraph(newParagraph, insertAfter);
        if (!insertAfter) {
            let nextParagraph: ParagraphWidget;
            let currentParagraph: ParagraphWidget = newParagraph;
            do {
                nextParagraph = this.selection.getNextParagraphBlock(currentParagraph as ParagraphWidget) as ParagraphWidget;
                currentParagraph = nextParagraph;
            } while (nextParagraph && nextParagraph.equals(newParagraph));
            if (!isNullOrUndefined(nextParagraph)) {
                this.selection.selectParagraphInternal(nextParagraph, true);
            } else {
                this.selection.selectParagraphInternal(newParagraph, true);
            }
        }
        this.fireContentChange();
    }
    private insertParagraph(newParagraph: ParagraphWidget, insertAfter: boolean): void {
        let lineWidget: LineWidget = this.selection.start.currentWidget;
        let offset: number = this.selection.start.offset;
        if (this.editorHistory && this.editorHistory.isUndoing && this.editorHistory.currentBaseHistoryInfo &&
            this.editorHistory.currentBaseHistoryInfo.action === 'InsertTextParaReplace') {
            offset = 0;
        }
        let currentParagraph: ParagraphWidget = this.selection.start.paragraph;
        currentParagraph = currentParagraph.combineWidget(this.owner.viewer) as ParagraphWidget;
        if (insertAfter) {
            let length: number = this.selection.getLineLength(currentParagraph.lastChild as LineWidget);
            let insertIndex: number = newParagraph.firstChild ? (newParagraph.firstChild as LineWidget).children.length : 0;
            this.moveInlines(currentParagraph, newParagraph, insertIndex, offset, lineWidget, length, currentParagraph.lastChild as LineWidget);
        } else if (offset > 0) {
            this.moveInlines(currentParagraph, newParagraph, 0, 0, currentParagraph.firstChild as LineWidget, offset, lineWidget);
        }
        let splittedWidget: ParagraphWidget[] = currentParagraph.getSplitWidgets() as ParagraphWidget[];
        currentParagraph = insertAfter ? splittedWidget[splittedWidget.length - 1] : splittedWidget[0];
        let insertIndex: number = currentParagraph.containerWidget.childWidgets.indexOf(currentParagraph);
        if (insertAfter) {
            insertIndex++;
        }
        let bodyWidget: BodyWidget = currentParagraph.containerWidget as BodyWidget;
        newParagraph.index = currentParagraph.index;
        newParagraph.containerWidget = bodyWidget;
        bodyWidget.childWidgets.splice(insertIndex, 0, newParagraph);
        this.constructRevisionsForBlock(newParagraph, true);
        this.updateNextBlocksIndex(insertAfter ? currentParagraph : newParagraph, true);
        //Splitted the paragraph revisions after the paragraphs are updated in the bodywidget.
        if (insertAfter) {
            this.updateRevisionForSplittedPara(currentParagraph, newParagraph);
        } else {
            this.splitRevisionsAndViewBasedOnUntrackedContent(newParagraph.characterFormat);
        }
        newParagraph.height = 0;
        if (newParagraph instanceof ParagraphWidget) {
            this.documentHelper.layout.linkFieldInParagraph(newParagraph);
        }
        this.documentHelper.layout.layoutBodyWidgetCollection(newParagraph.index, bodyWidget, newParagraph, false);
    }
    private moveInlines(currentParagraph: ParagraphWidget, newParagraph: ParagraphWidget, insertIndex: number, startOffset: number, startLine: LineWidget, endOffset: number, endLine: LineWidget, removeBlock?: boolean): void {
        if (newParagraph.childWidgets.length === 0) {
            let line: LineWidget = new LineWidget(newParagraph);
            newParagraph.childWidgets.push(line);
        }
        let isMoved: boolean = false;
        this.documentHelper.layout.clearListElementBox(currentParagraph);
        this.documentHelper.layout.clearListElementBox(newParagraph);
        for (let j: number = 0; j < currentParagraph.childWidgets.length; j++) {
            let lineWidget: LineWidget = currentParagraph.childWidgets[j] as LineWidget;
            if (startLine === lineWidget && endLine === lineWidget) {
                insertIndex = this.moveContent(lineWidget, startOffset, endOffset, insertIndex, newParagraph);
                break;
            }
            if (endLine === lineWidget) {
                insertIndex = this.moveContent(lineWidget, 0, endOffset, insertIndex, newParagraph);
                break;
            } else if (startLine === lineWidget) {
                isMoved = true;

                insertIndex = this.moveContent(lineWidget, startOffset, this.documentHelper.selection.getLineLength(lineWidget), insertIndex, newParagraph);

            } else if (isMoved) {
                insertIndex = this.moveContent(lineWidget, 0, this.documentHelper.selection.getLineLength(lineWidget), insertIndex, newParagraph);
            }
        }
        this.removeEmptyLine(currentParagraph);
        //To update the ownerNode of the revisions in the new paragraph.
        newParagraph.getAllRevisions(true);
        if (!currentParagraph.isInsideTable && !removeBlock) {
            this.viewer.updateClientArea(currentParagraph.bodyWidget, currentParagraph.bodyWidget.page);
            this.documentHelper.layout.reLayoutParagraph(currentParagraph, 0, 0);
        }
    }


    private moveContent(lineWidget: LineWidget, startOffset: number, endOffset: number, insertIndex: number, paragraph: ParagraphWidget): number {
        let count: number = 0;
        //let lineIndex: number = lineWidget.paragraph.childWidgets.indexOf(lineWidget);
        for (let i: number = 0; i < lineWidget.children.length; i++) {
            let inline: ElementBox = lineWidget.children[i];
            if (startOffset >= count + inline.length || inline instanceof ListTextElementBox) {
                if (!(inline instanceof ListTextElementBox)) {
                    count += inline.length;
                }
                continue;
            }
            let startIndex: number = 0;
            if (startOffset > count) {
                startIndex = startOffset - count;
            }

            let endIndex: number = endOffset - count;
            if (endIndex > inline.length) {
                endIndex = inline.length;
            }
            if (startIndex > 0) {
                count += startIndex;
            }
            if (startIndex === 0 && endIndex === inline.length) {
                if (inline instanceof ShapeBase) {
                    let shapeIndex: number = lineWidget.paragraph.floatingElements.indexOf(inline);
                    if (shapeIndex !== -1) {
                        lineWidget.paragraph.floatingElements.splice(shapeIndex, 1);
                    }
                }
                if (!paragraph.paragraphFormat.isSameFormat(inline.paragraph.paragraphFormat)) {
                    inline.isWidthUpdated = false;
                }
                (paragraph.firstChild as LineWidget).children.splice(insertIndex, 0, inline);
                inline.line = (paragraph.firstChild as LineWidget);
                insertIndex++;
                // if (editAction < 4) {
                // this.unLinkFieldCharacter(inline);
                    lineWidget.children.splice(i, 1);
                    if (!isNullOrUndefined(lineWidget.layoutedElements) && lineWidget.layoutedElements.length > 0) {
                        lineWidget.layoutedElements.splice(i, 1);
                    }
                i--;
                // }
            } else if (inline instanceof TextElementBox) {
                // if (editAction < 4) {
                let span: TextElementBox = new TextElementBox();
                span.characterFormat.copyFormat(inline.characterFormat);
                span.text = inline.text.substr(startIndex, endIndex - startIndex);
                inline.isChangeDetected = true;
                span.isChangeDetected = true;
                if (span.text !== '') {
                    (paragraph.firstChild as LineWidget).children.splice(insertIndex, 0, span);
                    span.line = (paragraph.firstChild as LineWidget);
                    if (inline.revisionLength > 0) {
                        for (let i: number = 0; i < inline.revisionLength; i++) {
                            let currentRevision: Revision = inline.getRevision(i);
                            span.addRevision(currentRevision);
                        }
                    }
                }
                insertIndex++;
                inline.text = inline.text.slice(0, startIndex) + inline.text.slice(endIndex);
                inline.isWidthUpdated = false;
                inline.isChangeDetected = true;
            }
            if (endOffset <= count + endIndex - startIndex) {
                break;
            }
            count += endIndex - startIndex;
        }
        return insertIndex;
    }
    private updateRevisionForSplittedPara(newParagraph: ParagraphWidget, currentParagraph: ParagraphWidget): void {
        let newParaLastLineIndex: number = newParagraph.childWidgets.length - 1;
        let newParaLastElementIndex: number = (newParagraph.childWidgets[newParaLastLineIndex] as LineWidget).children.length - 1;
        let newParaLastElement: TextElementBox = (newParagraph.childWidgets[newParaLastLineIndex] as LineWidget).children[newParaLastElementIndex] as TextElementBox;
        let currentParaFirstElement: TextElementBox = (currentParagraph.firstChild as LineWidget).children[0] as TextElementBox;
        if (!isNullOrUndefined(currentParaFirstElement) && !isNullOrUndefined(newParaLastElement) && this.compareElementRevision(newParaLastElement, currentParaFirstElement)) {
            this.updateRevisionForSpittedTextElement(newParaLastElement, currentParaFirstElement, newParagraph.characterFormat);
        }
    }

    /**
     * update complex changes when history is not preserved
     *
     * @param {number} action - Specifies the action
     * @param {string} start - Specifies the selection start
     * @param {string} end - Specified the selection end
     * @private
     * @returns {void}
     */
    public updateComplexWithoutHistory(action?: number, start?: string, end?: string): void {
        let selection: Selection = this.documentHelper.selection;
        if (action === 0) {
            let startPosition: TextPosition = new TextPosition(selection.owner);
            this.setPositionForCurrentIndex(startPosition, start);
            this.documentHelper.layout.reLayoutParagraph(startPosition.paragraph, 0, 0);
            this.setPositionForCurrentIndex(selection.start, end);
            this.setPositionForCurrentIndex(selection.end, end);
        }
        if (action === 1) {
            let startPosition: TextPosition = new TextPosition(selection.owner);
            this.setPositionForCurrentIndex(startPosition, start);
            let endPosition: TextPosition = new TextPosition(selection.owner);
            this.setPositionForCurrentIndex(endPosition, end);
            this.documentHelper.layout.reLayoutParagraph(startPosition.paragraph, 0, 0);
            if (endPosition.paragraph !== startPosition.paragraph) {
                this.documentHelper.layout.reLayoutParagraph(endPosition.paragraph, 0, 0);
            }
        }
        if (selection.owner.isShiftingEnabled) {
            this.documentHelper.layout.shiftLayoutedItems(false);
            if (this.documentHelper.owner.enableHeaderAndFooter) {
                this.updateHeaderFooterWidget();
            }
        }
        selection.owner.isShiftingEnabled = false;
        selection.start.updatePhysicalPosition(true);
        if (selection.isEmpty) {
            selection.end.setPositionInternal(selection.start);
        } else {
            selection.end.updatePhysicalPosition(true);
        }
        selection.upDownSelectionLength = selection.end.location.x;
        selection.fireSelectionChanged(true);
        this.documentHelper.updateFocus();
        this.owner.viewer.updateScrollBars();
        this.fireContentChange();
        this.isHandledComplex = true;
    }
    private groupInsertAction(): void {
        if (this.editorHistory && this.editorHistory.undoStack && this.editorHistory.undoStack.length > 1) {
            let currentHistoryInfo: BaseHistoryInfo = this.editorHistory.undoStack[this.editorHistory.undoStack.length - 1];
            let PreviouseHistoryInfo: BaseHistoryInfo = this.editorHistory.undoStack[this.editorHistory.undoStack.length - 2];
            if (PreviouseHistoryInfo.action === 'Insert' && currentHistoryInfo.action === 'Insert' && PreviouseHistoryInfo.endPosition === currentHistoryInfo.insertPosition
                && !this.owner.editorModule.isSkipGrouping && !this.skipTracking() && this.handledTextInput && PreviouseHistoryInfo.insertedText.length <= 127) {
                PreviouseHistoryInfo.insertedText += currentHistoryInfo.insertedText;
                PreviouseHistoryInfo.endPosition = currentHistoryInfo.endPosition;
                this.editorHistory.undoStack.splice(this.editorHistory.undoStack.length - 1, 1);
            } else if (!this.skipTracking()) {
                this.owner.editorModule.isSkipGrouping = false;
            }
        }
    }
    /**
     * Re-layout content.
     *
     * @param {Selection} selection - Specifies the selection 
     * @param isSelectionChanged - Specifies the selection changed
     * @private
     * @returns {void}
     */
    public reLayout(selection: Selection, isSelectionChanged?: boolean, isLayoutChanged?: boolean, isFromGroupAcceptReject?: boolean): void {
        if (!isNullOrUndefined(this.previousBlockToLayout)) {
            // Layout content for previous page to fix content based on KeepWithNext format.
            let previousBlock: BlockWidget = this.previousBlockToLayout;
            this.documentHelper.layout.layoutBodyWidgetCollection(previousBlock.index, previousBlock.bodyWidget, previousBlock, false, false);
            this.previousBlockToLayout = undefined;
        }
        if (!this.documentHelper.isComposingIME && this.editorHistory && this.editorHistory.isHandledComplexHistory() && !isFromGroupAcceptReject) {
            if (this.editorHistory.currentHistoryInfo && this.editorHistory.currentHistoryInfo.action !== 'ClearFormat') {
                if (this.editorHistory.currentHistoryInfo.action !== 'ApplyStyle') {
                    if (this.editorHistory.currentHistoryInfo.action === 'DragAndDropContent') {
                        this.documentHelper.layout.shiftLayoutedItems(true);
                    }
                    this.startParagraph = undefined;
                    this.endParagraph = undefined;
                }
            }
            this.isHandledComplex = false;
            if (this.editorHistory.currentHistoryInfo && (this.editorHistory.currentHistoryInfo.action === 'ColumnBreak'
                || this.editorHistory.currentHistoryInfo.action === 'PageBreak')) {
            } else {
                this.shiftFootnoteContent();
                this.selection.updateContentControlHighlightSelection();
                return;
            }
        }
        if (!isNullOrUndefined(selection.editRegionHighlighters)) {
            selection.editRegionHighlighters.clear();
        }
        if (isNullOrUndefined(this.documentHelper.blockToShift) || isNullOrUndefined(this.documentHelper.blockToShift.containerWidget)) {
            this.documentHelper.removeEmptyPages();
            this.documentHelper.layout.updateFieldElements();
            this.documentHelper.layout.checkAndShiftEndnote(true);
            this.selection.updateContentControlHighlightSelection();
            /*  if (!isNullOrUndefined(selection.start.paragraph.bodyWidget.page.footnoteWidget)) {
                  let foot: FootNoteWidget = selection.start.paragraph.bodyWidget.page.footnoteWidget;
                  //this.documentHelper.layout.layoutfootNote(foot);
              }
              if (!isNullOrUndefined(selection.start.paragraph.bodyWidget.page.endnoteWidget)) {
                  let foot: FootNoteWidget = selection.start.paragraph.bodyWidget.page.endnoteWidget;
                  //this.documentHelper.layout.layoutfootNote(foot);
              }*/
            if (!this.documentHelper.owner.enableHeaderAndFooter && !selection.isHighlightEditRegion) {
                this.owner.viewer.updateScrollBars();
            }
            if (!selection.owner.isShiftingEnabled || this.documentHelper.isRowOrCellResizing) {
                selection.fireSelectionChanged(true);
                this.startParagraph = undefined;
                this.endParagraph = undefined;
            }
        }
        if (isNullOrUndefined(isSelectionChanged)) {
            isSelectionChanged = selection.isEmpty;
        }
        if (this.owner.showRevisions && this.owner.trackChangesPane.isUpdateTrackChanges(this.owner.revisions.length)) {
            //this.updateRevision(this.selection.start.paragraph);
            this.owner.trackChangesPane.updatePendingChangesToView();
            this.owner.trackChangesPane.updateTrackChanges();
        }
        if (selection.owner.isShiftingEnabled) {
            selection.owner.isShiftingEnabled = false;
            selection.owner.isLayoutEnabled = true;
            let bodyWidget: BodyWidget = selection.start.paragraph.bodyWidget;
            let splittedSection: BodyWidget[] = bodyWidget.getSplitWidgets() as BodyWidget[];
            bodyWidget = splittedSection[splittedSection.length - 1];
            const isColumnBreak: boolean = (this.editorHistory && this.editorHistory.currentHistoryInfo && this.editorHistory.currentHistoryInfo.action === 'ColumnBreak' && this.documentHelper.layout.isMultiColumnDoc) ? true : false;
            if (this.documentHelper.compatibilityMode === "Word2010" && (bodyWidget.isWord2010NextColumn || (!isNullOrUndefined(bodyWidget.nextRenderedWidget) && ((bodyWidget.nextRenderedWidget as BodyWidget).isWord2010NextColumn || ((bodyWidget.nextRenderedWidget as BodyWidget).sectionFormat.numberOfColumns > 1 && (bodyWidget.nextRenderedWidget as BodyWidget).sectionFormat.breakCode === "NoBreak")))) && !(bodyWidget instanceof HeaderFooterWidget) && !(!isNullOrUndefined(bodyWidget.containerWidget) && bodyWidget.containerWidget instanceof FootNoteWidget)) {
                this.documentHelper.layout.layoutWholeDocument(true, true);
            } else if (((!isNullOrUndefined(bodyWidget.nextRenderedWidget) && (bodyWidget.nextRenderedWidget as BodyWidget).sectionFormat.breakCode === 'NoBreak' && this.documentHelper.layout.isMultiColumnDoc) || (bodyWidget.sectionFormat.breakCode === 'NoBreak' && (bodyWidget.sectionIndex === bodyWidget.page.bodyWidgets[0].sectionIndex) && bodyWidget.sectionFormat.numberOfColumns > 1) || isColumnBreak) && !(bodyWidget instanceof HeaderFooterWidget) && !(!isNullOrUndefined(bodyWidget.containerWidget) && bodyWidget.containerWidget instanceof FootNoteWidget)) {
                let startPosition: TextPosition = this.documentHelper.selection.start;
                let endPosition: TextPosition = this.documentHelper.selection.end;
                let startInfo: ParagraphInfo = this.selection.getParagraphInfo(startPosition);
                let endInfo: ParagraphInfo = this.selection.getParagraphInfo(endPosition);
                let startIndex: string = this.selection.getHierarchicalIndex(startInfo.paragraph, startInfo.offset.toString());
                let endIndex: string = this.selection.getHierarchicalIndex(endInfo.paragraph, endInfo.offset.toString());
                this.documentHelper.layout.shiftLayoutedItems(true);
                this.setPositionForCurrentIndex(startPosition, startIndex);
                this.setPositionForCurrentIndex(endPosition, endIndex);
                this.documentHelper.selection.selectPosition(startPosition, endPosition);
                if (!this.documentHelper.owner.enableHeaderAndFooter) {
                    this.owner.viewer.updateScrollBars();
                }
            } else {
                this.documentHelper.layout.shiftLayoutedItems(true);
            }
            if (this.documentHelper.owner.enableHeaderAndFooter) {
                this.updateHeaderFooterWidget();
                // We are considered headerWigetIn and footerWidgetIn for rendering the header and footer. So, we called the updateScrollBars method once the headerWidgetIn and footerWidgetIn were updated.
                this.owner.viewer.updateScrollBars();
            }
            if (!this.documentHelper.isRowOrCellResizing) {
                this.shiftFootnoteContent();
                this.getOffsetValue(selection);
                selection.upDownSelectionLength = selection.end.location.x;
                selection.fireSelectionChanged(true);
                if (this.owner.enableAutoFocus) {
                    this.documentHelper.updateFocus();
                }
                this.startParagraph = undefined;
                this.endParagraph = undefined;
                //this.documentHelper.layout.allowLayout = true;
            }
        } else if (this.documentHelper.owner.enableHeaderAndFooter) {
            this.updateHeaderFooterWidget();
            // We are considered headerWigetIn and footerWidgetIn for rendering the header and footer. So, we called the updateScrollBars method once the headerWidgetIn and footerWidgetIn were updated.
            this.owner.viewer.updateScrollBars();
        }
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo &&
            ((this.editorHistory.currentBaseHistoryInfo.action !== 'RowResizing'
                && this.editorHistory.currentBaseHistoryInfo.action !== 'CellResizing')
                || (this.editorHistory.isUndoing || this.editorHistory.isRedoing))) {
            if (this.editorHistory.currentBaseHistoryInfo.modifiedProperties.length > 0 && this.editorHistory.currentBaseHistoryInfo.action !== 'AddRevision') {
                this.editorHistory.currentBaseHistoryInfo.updateSelection();
            }
            if (!(this.editorHistory.undoStack && this.editorHistory.undoStack.length > 0 && this.editorHistory.undoStack[this.editorHistory.undoStack.length - 1] instanceof HistoryInfo &&
                (this.editorHistory.undoStack[this.editorHistory.undoStack.length - 1] as HistoryInfo).modifiedActions &&
                (this.editorHistory.undoStack[this.editorHistory.undoStack.length - 1] as HistoryInfo).modifiedActions[(this.editorHistory.undoStack[this.editorHistory.undoStack.length - 1] as HistoryInfo).modifiedActions.length - 1] === this.editorHistory.currentBaseHistoryInfo)) {
                this.editorHistory.updateHistory();
            }
            else {
                this.editorHistory.currentBaseHistoryInfo = undefined;
            }
        }
        if (isLayoutChanged) {
            if(!isNullOrUndefined(selection) && this.documentHelper.formFields.length > 0){
                selection.highlightFormFields();
            }
            return;
        }
        this.fireContentChange();
        this.groupInsertAction();
        if (this.owner.enableLockAndEdit) {
            // Editable region border get updated in content changes event.
            // So, handled rerendering content after applying border.
            this.owner.viewer.updateScrollBars();
        }
        this.owner.documentHelper.layout.isRelayout = false;
        this.isFootnoteElementRemoved = false;
        this.isEndnoteElementRemoved = false;
    }

    private shiftFootnoteContent(): void {
        if (!isNullOrUndefined(this.selection.start.paragraph)) {
            if (!isNullOrUndefined(this.selection.start.paragraph.bodyWidget) && !isNullOrUndefined(this.selection.start.paragraph.bodyWidget.containerWidget) && this.selection.start.paragraph.bodyWidget.containerWidget instanceof FootNoteWidget) {
                if (this.selection.start.paragraph.bodyWidget.containerWidget.footNoteType === 'Footnote') {
                    this.documentHelper.layout.isRelayoutFootnote = true;
                    this.shiftFootnotePageContent(this.selection.start.paragraph.bodyWidget.containerWidget);
                    //this.documentHelper.layout.layoutfootNote(selection.start.paragraph.bodyWidget.containerWidget);
                } else {
                    this.documentHelper.layout.isRelayoutFootnote = false;
                    this.shiftFootnotePageContent();
                }
            }
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public updateHeaderFooterWidget(headerFooterWidget?: HeaderFooterWidget): void {
        if (isNullOrUndefined(headerFooterWidget)) {
            headerFooterWidget = this.selection.start.paragraph.bodyWidget as HeaderFooterWidget;
        }
        this.updateHeaderFooterWidgetToPage(headerFooterWidget);

        this.shiftPageContent(headerFooterWidget.headerFooterType, headerFooterWidget.sectionFormat);
    }

    private updateHeaderFooterWidgetToPage(node: HeaderFooterWidget): void {
        let currentPage: Page = node.page;
        //node = this.documentHelper.layout.updateHeaderFooterToParent(node);
        let isEvenPage: boolean = (node.headerFooterType === 'EvenHeader' || node.headerFooterType === 'EvenFooter');
        let isFirstPage: boolean = (node.headerFooterType === 'FirstPageHeader' || node.headerFooterType === 'FirstPageFooter');
        for (let i: number = 0; i < this.documentHelper.pages.length; i++) {
            let page: Page = this.documentHelper.pages[i];
            if (page.bodyWidgets[0].sectionFormat.differentFirstPage && isFirstPage
                && (page.headerWidgetIn.headerFooterType == node.headerFooterType || page.footerWidgetIn.headerFooterType == node.headerFooterType)) {
                    this.updateHeaderFooterWidgetToPageInternal(page, node, node.headerFooterType.indexOf('Header') !== -1);
                continue;
            }
            if (page.bodyWidgets[0].sectionFormat.differentFirstPage &&
                (isFirstPage || (!isFirstPage && page.index == 0 || page.sectionIndex != page.previousPage.sectionIndex))) {
                continue;
            }
            //if (currentPage !== page) {
            if (page.bodyWidgets[0].sectionFormat.differentOddAndEvenPages) {
                if (isEvenPage && (i + 1) % 2 === 0) {
                    this.updateHeaderFooterWidgetToPageInternal(page, node, node.headerFooterType.indexOf('Header') !== -1);
                } else if ((!isEvenPage && (i + 1) % 2 !== 0)) {
                    if (i > 0 || !(page.bodyWidgets[0].sectionFormat.differentFirstPage)) {
                        this.updateHeaderFooterWidgetToPageInternal(page, node, node.headerFooterType.indexOf('Header') !== -1);
                    }
                }
            } else {
                this.updateHeaderFooterWidgetToPageInternal(page, node, node.headerFooterType.indexOf('Header') !== -1);
            }
            //}
        }
    }

    private updateHeaderFooterWidgetToPageInternal(page: Page, widget: HeaderFooterWidget, isHeader: boolean): void {
        let update: boolean = false;
        if (isHeader) {
            update = widget != page.headerWidgetIn && widget.page.headerWidget == page.headerWidget;
        } else {
            update = widget != page.footerWidgetIn && widget.page.footerWidget == page.footerWidget;
        }
        if (update) {
            let hfWidget: HeaderFooterWidget = widget.clone();
            this.documentHelper.layout.clearBlockWidget(hfWidget.childWidgets, true, true, true);
            hfWidget.page = page;
            hfWidget.parentHeaderFooter = widget;
            this.documentHelper.layout.updateRevisionsToHeaderFooter(hfWidget, page);
            (this.owner.viewer as PageLayoutViewer).updateHFClientArea(hfWidget.sectionFormat, isHeader);
            hfWidget = this.documentHelper.layout.layoutHeaderFooterItems(this.owner.viewer, hfWidget);
            let headerOrFooter: HeaderFooterWidget;
            if (isHeader) {
                headerOrFooter = page.headerWidgetIn;
                page.headerWidget = hfWidget;
            } else {
                headerOrFooter = page.footerWidgetIn;
                page.footerWidget = hfWidget;
            }
            this.removeFieldInWidget(headerOrFooter);
            this.removeFieldInWidget(headerOrFooter, undefined, true);
            headerOrFooter.destroy();
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public removeFieldInWidget(widget: Widget, isBookmark?: boolean, isContentControl?: boolean, isEditRange?: boolean): void {
        if (isNullOrUndefined(isBookmark)) {
            isBookmark = false;
        }
        for (let i: number = 0; i < widget.childWidgets.length; i++) {
            this.removeFieldInBlock(widget.childWidgets[i] as BlockWidget, isBookmark, isContentControl, isEditRange);
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public removeFieldInBlock(block: BlockWidget, isBookmark?: boolean, isContentControl?: boolean, isEditRange?: boolean): void {
        if (block instanceof TableWidget) {
            if (block.wrapTextAround && !isNullOrUndefined(block.bodyWidget)) {
                let index: number = block.bodyWidget.floatingElements.indexOf(block);
                if (index !== -1) {
                    block.bodyWidget.floatingElements.splice(index, 1);
                }
            }
            this.removeFieldTable(block, isBookmark, isContentControl, isEditRange);
        } else if (block instanceof TableRowWidget) {
            for (let i: number = 0; i < block.childWidgets.length; i++) {
                this.removeFieldInWidget(block.childWidgets[i] as Widget, isBookmark, isContentControl, isEditRange);
            }
        } else {
            this.removeField(block as ParagraphWidget, isBookmark, isContentControl,isEditRange);
        }
    }

    private removeFieldTable(table: TableWidget, isBookmark?: boolean, isContentControl?: boolean, isEditRange?: boolean): void {
        for (let i: number = 0; i < table.childWidgets.length; i++) {
            let row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
            for (let j: number = 0; j < row.childWidgets.length; j++) {
                this.removeFieldInWidget(row.childWidgets[j] as Widget, isBookmark, isContentControl, isEditRange);
            }
        }
    }
    private shiftFootnotePageContent(foot?: FootNoteWidget): void {
        let section: BodyWidget = this.documentHelper.pages[0].bodyWidgets[0];
        if (!isNullOrUndefined(foot)) {
            let index: number = this.documentHelper.pages.indexOf(foot.page);
            section = this.documentHelper.pages[index].bodyWidgets[0];
        }
        if (!isNullOrUndefined(section.page.footnoteWidget)) {
            this.checkAndShiftFromBottom(section.page, section.page.footnoteWidget, !isNullOrUndefined(foot) ? true : false);
        }
        if (!isNullOrUndefined(section.page.endnoteWidget)) {
            //this.checkAndShiftFromBottom(section.page, section.page.endnoteWidget);
        }
        if (this.documentHelper.blockToShift) {
            this.documentHelper.renderedLists.clear();
            this.documentHelper.renderedLevelOverrides = [];
            this.documentHelper.layout.shiftLayoutedItems(false);
            this.documentHelper.layout.checkAndShiftEndnote(false);
        }

    }
    /**
     * @private
     * @returns {void}
     */
    public shiftPageContent(type: HeaderFooterType, sectionFormat: WSectionFormat): void {
        // let type: HeaderFooterType = headerFooter.headerFooterType;
        let pageIndex: number;
        if (type.indexOf('First') !== -1) {
            pageIndex = 0;
        } else if (sectionFormat.differentOddAndEvenPages) {
            let isEven: boolean = type.indexOf('Even') !== -1;
            if (sectionFormat.differentFirstPage) {
                pageIndex = isEven ? 1 : 2;
            } else {
                pageIndex = !isEven ? 0 : 1;
            }
        } else {
            pageIndex = sectionFormat.differentFirstPage ? 1 : 0;
            if (pageIndex === 1 && this.documentHelper.pages.length === 1) {
                pageIndex = 0;
            }
        }
        let section: BodyWidget = this.documentHelper.pages[pageIndex].bodyWidgets[0];
        do {
            if (type.indexOf('Header') !== -1) {
                let widget: HeaderFooterWidget = section.page.headerWidget;
                let isNotEmpty: boolean = !widget.isEmpty || widget.isEmpty && this.owner.enableHeaderAndFooter;
                let firstBlock: BlockWidget = (section.firstChild as BlockWidget);
                let top: number = HelperMethods.convertPointToPixel(sectionFormat.topMargin);
                let headerDistance: number = HelperMethods.convertPointToPixel(sectionFormat.headerDistance);
                if (isNotEmpty) {
                    top = Math.max(headerDistance + section.page.headerWidget.height, top);
                }
                if (firstBlock.y !== top && section.sectionFormat.breakCode !== "NoBreak") {
                    this.owner.viewer.updateClientArea(section, section.page);
                    firstBlock = firstBlock.combineWidget(this.owner.viewer) as BlockWidget;
                    let prevWidget: BlockWidget = firstBlock.previousRenderedWidget as BlockWidget;
                    if (prevWidget) {
                        if (firstBlock.containerWidget.equals(prevWidget.containerWidget) && !(prevWidget.containerWidget.lastChild instanceof ParagraphWidget && (prevWidget.containerWidget.lastChild.isEndsWithPageBreak || prevWidget.containerWidget.lastChild.isEndsWithColumnBreak))) {
                            this.owner.viewer.cutFromTop(prevWidget.y + prevWidget.height);

                            this.documentHelper.layout.updateContainerWidget(firstBlock as Widget, prevWidget.containerWidget as BodyWidget, prevWidget.indexInOwner + 1, false);
                        }
                    }
                    this.documentHelper.blockToShift = firstBlock;
                }
            } else {
                this.checkAndShiftFromBottom(section.page, section.page.footerWidget);
            }
            if (this.documentHelper.blockToShift) {
                this.documentHelper.renderedLists.clear();
                this.documentHelper.renderedLevelOverrides = [];
                this.documentHelper.layout.shiftLayoutedItems(false);
            }
            while (section) {
                let previousSection = section;
                do {
                    //To skip section continuous, since it already shifted in `shiftLayoutedItems` method.
                    let splittedSection: BodyWidget[] = section.getSplitWidgets() as BodyWidget[];
                    section = splittedSection[splittedSection.length - 1].nextRenderedWidget as BodyWidget;
                } while (section && previousSection.page === section.page);
                if (section) {
                    if (pageIndex === 0) {
                        break;
                    } else {
                        if (section.page.index + 1 % 2 === 0 && pageIndex === 1 ||
                            (section.page.index + 1 % 2 !== 0 && pageIndex === 2)) {
                            break;
                        }
                        let nextPage: Page = section.page.nextPage;
                        if (!isNullOrUndefined(nextPage) && nextPage.bodyWidgets[0].equals(section)) {
                            section = nextPage.bodyWidgets[0];
                            break;
                        }
                    }
                }
            }

        } while (section);

    }

    private checkAndShiftFromBottom(page: Page, footerWidget: HeaderFooterWidget | FootNoteWidget, isFootNote?: boolean): void {
        let bodyWidget: BodyWidget = page.bodyWidgets[0];
        let blockToShift: BlockWidget;
        if (bodyWidget.childWidgets.length > 1) {
            for (let i: number = 0; i < bodyWidget.childWidgets.length; i++) {
                let block: BlockWidget = bodyWidget.childWidgets[i] as BlockWidget;
                if (block.y + block.height > footerWidget.y) {
                    blockToShift = block;
                    break;
                }
                if (!(footerWidget instanceof FootNoteWidget)) {
                    if (bodyWidget.childWidgets.length - 1 === i && block.y + block.height < footerWidget.y) {
                        blockToShift = block as BlockWidget;
                        break;
                    }
                }
            }
            if (isNullOrUndefined(blockToShift) && isFootNote) {
                blockToShift = bodyWidget.lastChild as BlockWidget;
            }
            if (!isNullOrUndefined(blockToShift)) {
                this.owner.viewer.updateClientArea(bodyWidget, page, true);
                this.owner.viewer.cutFromTop(blockToShift.y);
                this.documentHelper.blockToShift = blockToShift;
            }
        }
    }

    private allowFormattingInFormFields(property: string): boolean {
        if (this.documentHelper.protectionType === 'FormFieldsOnly' && this.selection.isInlineFormFillMode() &&
            !isNullOrUndefined(this.owner.documentEditorSettings.formFieldSettings.formattingExceptions)) {
            for (let j: number = 0; j < this.owner.documentEditorSettings.formFieldSettings.formattingExceptions.length; j++) {
                if (property.toLowerCase() === this.owner.documentEditorSettings.formFieldSettings.formattingExceptions[j].toLowerCase()) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * @private
     * @returns {void}
     */
    public insertContentControlInCollection(element: ContentControl): void {
        let contentConterolCollection: ContentControl[] = this.documentHelper.contentControlCollection;
        let currentStart: TextPosition = this.selection.getElementPosition(element).startPosition;
        if (isNullOrUndefined(currentStart)) {
            currentStart = this.selection.isForward ? this.selection.start : this.selection.end;
        }
        let paraIndex: TextPosition = undefined;
        let isInserted: boolean = false;
        if (contentConterolCollection.indexOf(element) === -1) {
            for (let i: number = 0; i < contentConterolCollection.length; i++) {
                let contentControl: ContentControl = contentConterolCollection[i];
                paraIndex = this.selection.getElementPosition(contentControl).startPosition;
                if (!isNullOrUndefined(currentStart) && !isNullOrUndefined(paraIndex) && currentStart.isExistBefore(paraIndex)) {
                    contentConterolCollection.splice(i, 0, element);
                    isInserted = true;
                    break;
                }
            }
        } else {
            isInserted = true;
        }
        if (!isInserted) {
            contentConterolCollection.push(element);
        }
    }
    /**
     * @private
     * @returns {ContentControl}
     */
    public getContentControl(): ContentControl {
        let contentControl: ContentControl[] = this.getContentControls();
        if (contentControl.length > 0) {
            return contentControl[contentControl.length - 1];
        }
        return undefined;
    }
    /**
     * @private
     * @returns {ContentControl[]}
     */
    public getContentControls(): ContentControl[] {
        let contentControl: ContentControl[] = [];
        for (let i: number = 0; i < this.documentHelper.contentControlCollection.length; i++) {
            if (this.documentHelper.contentControlCollection[i].paragraph.isInHeaderFooter && this.documentHelper.owner.layoutType === "Continuous") {
                continue;
            }
            let contentControlStart: ContentControl = this.documentHelper.contentControlCollection[i];
            if (this.owner.enableHeaderAndFooter) {
                if(contentControlStart.paragraph.isInHeaderFooter){
                    if (this.pushContentControlByOrder(contentControlStart, contentControl)) {
                        break;
                    }
                } 
            } else if (!contentControlStart.paragraph.isInHeaderFooter) {
                if (this.pushContentControlByOrder(contentControlStart, contentControl)) {
                    break;
                }
            }
        }
        return contentControl;
    }
    private pushContentControlByOrder(contentControlStart: ContentControl, contentControls: ContentControl[]): boolean {
        let line: LineWidget = contentControlStart.line as LineWidget;
        if (!isNullOrUndefined(line.children) && !isNullOrUndefined(line.children.length)) {
            let position: PositionInfo = this.selection.getPosition(contentControlStart, true);
            if (position.startPosition && position.endPosition) {
                let cCstart: TextPosition = position.startPosition;
                let cCend: TextPosition = position.endPosition;
                let start: TextPosition = this.selection.start;
                let end: TextPosition = this.selection.end;
                if (!this.selection.isForward) {
                    start = this.selection.end;
                    end = this.selection.start;
                }
                const isExistAfter: boolean = start.isExistAfter(cCstart) || start.isAtSamePosition(cCstart);
                const isExistBefore: boolean = end.isExistBefore(cCend) || end.isAtSamePosition(cCend);
                if (isExistAfter && isExistBefore) {
                    contentControls.push(contentControlStart)
                } else if (!contentControlStart.paragraph.isInHeaderFooter && !isExistAfter) {
                    return true;
                }
            }
        }
        return false;
    }

    private checkPlainTextContentControl(): void {
        let start: TextPosition = this.selection.start;
        let end: TextPosition = this.selection.end;
        if (!this.selection.isForward) {
            end = this.selection.start;
            start = this.selection.end;
        }
        let startIndex: number = 0;
        let endIndex: number = 0;
        let startInline: ElementInfo = start.currentWidget.getInline(start.offset, startIndex) as ElementInfo;
        let endInline: ElementInfo = end.currentWidget.getInline(end.offset, endIndex) as ElementInfo;
        startIndex = startInline.index;
        endIndex = endInline.index;
        let startInlineEle: ElementBox = startInline.element;
        let endInlineEle: ElementBox = endInline.element;
        let startPosition: TextPosition;
        let endPosition: TextPosition;
        if ((startInlineEle && startInlineEle.contentControlProperties && startInlineEle.contentControlProperties.type === 'Text')
            || (endInlineEle && endInlineEle.contentControlProperties && endInlineEle.contentControlProperties.type === 'Text')) {
            startInlineEle = this.getContentControl();
            if (!isNullOrUndefined(startInlineEle) && startInlineEle.contentControlProperties) {
                let offset: number = startInlineEle.line.getOffset(startInlineEle, 1);
                startPosition = new TextPosition(this.owner);
                startPosition.setPositionParagraph(startInlineEle.line, offset);
            } else {
                startPosition = start;
            }
            if (endInlineEle.contentControlProperties && !isNullOrUndefined(startInlineEle)
                && (startInlineEle as ContentControl).reference) {
                endInlineEle = (startInlineEle as ContentControl).reference;
                let endoffset: number = endInlineEle.line.getOffset(endInlineEle, endInlineEle.length);
                endPosition = new TextPosition(this.owner);
                endPosition.setPositionParagraph(endInlineEle.line, endoffset);
            } else {
                endPosition = end;
            }
            this.selection.selectRange(startPosition, endPosition);
        } else if (start.paragraph.contentControlProperties
            && start.paragraph.contentControlProperties.type === 'Text') {
            this.selection.selectParagraph();
        }
    }
    //Paste Implementation ends
    //Character Format apply implementation starts

    /**
     * Applies character format for selection.
     *
     * @param {string} property - Specifies the property
     * @param {Object} value - Specifies the value
     * @param {boolean} update - Spcifies the update
     * @private
     * @returns {void}
     */
    public onApplyCharacterFormat(property: string, value: Object, update?: boolean, applyStyle?: boolean): void {
        let allowFormatting: boolean = this.documentHelper.isFormFillProtectedMode
            && this.documentHelper.selection.isInlineFormFillMode() && this.allowFormattingInFormFields(property);
        if ((this.restrictFormatting && !allowFormatting) || (!isNullOrUndefined(this.selection) && this.selection.checkContentControlLocked(true))) {
            return;
        }
        this.documentHelper.layout.isBidiReLayout = true;
        let selection: Selection = this.documentHelper.selection;
        if ((selection.owner.isReadOnlyMode && !allowFormatting) || !selection.owner.isDocumentLoaded) {
            return;
        }
        update = isNullOrUndefined(update) ? false : update;
        applyStyle = isNullOrUndefined(applyStyle) ? false : applyStyle;
        let action: Action = (property[0].toUpperCase() + property.slice(1)) as Action;
        let paragraph: ParagraphWidget = selection.start.paragraph;
        let lastLine: LineWidget = paragraph.childWidgets[paragraph.childWidgets.length - 1] as LineWidget;
        this.checkPlainTextContentControl();
        if (selection.isEmpty && selection.contextType !== 'List' && !applyStyle) {
            selection.skipFormatRetrieval = true;
            if (selection.end.isAtParagraphEnd) {
                this.initHistory(action);
                this.documentHelper.owner.isShiftingEnabled = true;
                this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
                this.reLayout(this.documentHelper.selection);
                this.documentHelper.updateFocus();
            } else {
                selection.fireSelectionChanged(true);
            }
            selection.skipFormatRetrieval = false;
            return;
        }
        //Skip consider highlightcolor if paragraph mark alone is selected similar to Microsoft Word behaviour
        if (property === 'highlightColor' && selection.start.isInSameParagraph(selection.end)) {
            let start: TextPosition = selection.start;
            let end: TextPosition = selection.end;
            if (!this.selection.isForward) {
                end = selection.start;
                start = selection.end;
            }
            if (end.offset === selection.getLineLength(end.currentWidget) + 1 && end.offset - 1 === start.offset) {
                return;
            }
        }

        this.setOffsetValue(selection);
        this.initHistory(action);
        // Todo: Complete Microsoft Word behavior on apply formatting in empty selection
        // if (selection.isEmpty) {
        //     this.documentHelper.owner.isShiftingEnabled = true;
        //     this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
        //     this.reLayout(this.documentHelper.selection);
        //     this.documentHelper.updateFocus();
        //     return;
        // }
        if (selection.contextType === 'List') {
            // this.updateCharacterFormatForListText(selection, action, value, update);
            this.applyCharacterFormatForListText(selection, property, value, update);
        } else {
            //Iterate and update format.
            this.updateSelectionCharacterFormatting(property, value, update);
        }
        this.documentHelper.layout.isBidiReLayout = false;
    }


    private applyCharacterFormatForListText(selection: Selection, property: string, values: Object, update: boolean): void {
        let listLevel: WListLevel = selection.getListLevel(selection.start.paragraph);
        if (isNullOrUndefined(listLevel)) {
            return;
        }
        let characterFormat: WCharacterFormat = listLevel.characterFormat;
        switch (property) {
            case 'bold':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'bold', !(characterFormat.bold));
                break;
            case 'italic':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'italic', !(characterFormat.italic));
                break;
            case 'fontColor':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'fontColor', values);
                break;
            case 'fontFamily':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'fontFamily', values);
                break;
            case 'fontSize':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'fontSize', values);
                break;
            case 'highlightColor':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'highlightColor', values);
                break;
            case 'baselineAlignment':
                if (characterFormat.baselineAlignment === values) {
                    values = 'Normal';
                }
                this.applyListCharacterFormatByValue(selection, characterFormat, 'baselineAlignment', values);
                break;
            case 'strikethrough':
                if (characterFormat.strikethrough === values) {
                    values = 'None';
                }
                this.applyListCharacterFormatByValue(selection, characterFormat, 'strikethrough', values);
                break;
            case 'underline':
                if (characterFormat.underline === values) {
                    values = 'None';
                }
                this.applyListCharacterFormatByValue(selection, characterFormat, 'underline', values);
                break;
            case 'characterFormat':
                this.applyListCharacterFormatByValue(selection, characterFormat, undefined, values);
                break;
        }
    }
    private applyListCharacterFormatByValue(selection: Selection, format: WCharacterFormat, property: string, value: Object): void {
        this.initHistory('ListCharacterFormat');
        this.applyCharFormatValue(format, property, value, false);
        this.editorHistory.updateHistory();
        this.reLayout(selection);
        this.fireContentChange();
    }
    /**
     * @private
     * @returns {void}
     */
    public updateListCharacterFormat(selection: Selection, property: string, value: Object): void {
        this.updateListTextSelRange(selection, property, value, false);
    }
    private updateListTextSelRange(selection: Selection, property: string, value: Object, update: boolean): void {
        this.documentHelper.owner.isShiftingEnabled = true;
        let startPositionInternal: TextPosition = selection.start;
        let endPositionInternal: TextPosition = selection.end;
        if (!selection.isForward) {
            startPositionInternal = selection.end;
            endPositionInternal = selection.start;
        }
        this.initHistoryPosition(selection, startPositionInternal);
        let listLevel: WListLevel = selection.getListLevel(selection.start.paragraph);
        this.applyCharFormatValue(listLevel.characterFormat, property, value, update);
        this.startSelectionReLayouting(startPositionInternal.paragraph, selection, startPositionInternal, endPositionInternal);
    }
    /**
     * @private
     * @returns {void}
     */
    public updateInsertPosition(): void {
        let selection: Selection = this.documentHelper.selection;
        let position: TextPosition = selection.start;
        if (!selection.isForward) {
            position = selection.end;
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)
            && !isNullOrUndefined(position)) {
            if (isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition)) {
                this.updateHistoryPosition(position, true);
            }
        }
    }
    /**
     * Preserve paragraph and offset value for selection
     * 
     * @private
     * @returns {void}
     */
    public setOffsetValue(selection: Selection): void {
        let info: ParagraphInfo = this.selection.getParagraphInfo(selection.start);
        this.startParagraph = info.paragraph;
        this.startOffset = info.offset;
        info = this.selection.getParagraphInfo(selection.end);
        this.endParagraph = info.paragraph;
        this.endOffset = info.offset;
    }
    /**
     * Toggles the highlight color property of selected contents.
     *
     * @param {HighlightColor} highlightColor Specify the highlight color to be applied (default: Yellow).
     * @returns {void}
     */
    public toggleHighlightColor(highlightColor?: HighlightColor): void {
        let selection: Selection = this.documentHelper.selection;
        if (isNullOrUndefined(highlightColor) || highlightColor === 'NoColor') {
            highlightColor = 'Yellow';
        }
        //In Ms Word the highlight color is took from the ribbon. So we Have given yellow as constant.
        if (selection.characterFormat.highlightColor === highlightColor) {
            highlightColor = 'NoColor';
        }
        this.selection.characterFormat.highlightColor = highlightColor;
    }
    /**
     * Toggles the subscript formatting of selected contents.
     *
     * @returns {void}
     */
    public toggleSubscript(): void {
        if (this.owner.isReadOnlyMode || this.restrictFormatting) {
            return;
        }
        let value: BaselineAlignment = this.selection.characterFormat.baselineAlignment === 'Subscript' ? 'Normal' : 'Subscript';
        this.selection.characterFormat.baselineAlignment = value as BaselineAlignment;
    }
    /**
     * Toggles the superscript formatting of selected contents.
     *
     * @returns {void}
     */
    public toggleSuperscript(): void {
        if (this.owner.isReadOnlyMode || this.restrictFormatting) {
            return;
        }
        let value: BaselineAlignment = this.selection.characterFormat.baselineAlignment === 'Superscript' ? 'Normal' : 'Superscript';
        this.selection.characterFormat.baselineAlignment = value as BaselineAlignment;
    }
    /**
     * Increases the left indent of selected paragraphs to a factor of 36 points.
     *
     * @returns {void}
     */
    public increaseIndent(): void {
        if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
            this.increasedIndent = true;
            this.onApplyParagraphFormat('leftIndent', this.documentHelper.defaultTabWidth, true, false);
            this.increasedIndent = false;
        }
    }
    /**
     * Decreases the left indent of selected paragraphs to a factor of 36 points.
     *
     * @returns {void}
     */
    public decreaseIndent(): void {
        if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
            this.decreasedIndent = true;
            this.onApplyParagraphFormat('leftIndent', -this.documentHelper.defaultTabWidth, true, false);
            this.decreasedIndent = false;
        }
    }
    /**
     * Clears the list format for selected paragraphs.
     *
     * @returns {void}
     */
    public clearList(): void {
        this.selection.owner.editorModule.onApplyList(undefined);
    }
    /**
     * Applies the bullet list to selected paragraphs.
     *
     * @param {string} bullet Specify the bullet character to be applied.
     * @param {string} fontFamily Specify the bullet font family name.
     * @returns {void}
     */
    public applyBullet(bullet: string, fontFamily: string): void {
        if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
            this.applyBulletOrNumbering(bullet, 'Bullet', fontFamily);
        }
    }
    /**
     * Applies the numbering list to selected paragraphs.
     *
     * @param {string} numberFormat  “%n” representations in ‘numberFormat’ parameter will be replaced by respective list level’s value.
     * `“%1)” will be displayed as “1)” `
     * @param {ListLevelPattern} listLevelPattern  Default value of ‘listLevelPattern’ parameter is ListLevelPattern.Arabic
     * @returns {void}
     */
    public applyNumbering(numberFormat: string, listLevelPattern?: ListLevelPattern): void {
        if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
            this.applyBulletOrNumbering(numberFormat, listLevelPattern, 'Verdana');
        }
    }
    /**
     * Toggles the baseline alignment property of selected contents.
     *
     * @param {BaselineAlignment} baseAlignment Specifies the baseline alignment.
     * @returns {void}
     */
    public toggleBaselineAlignment(baseAlignment: BaselineAlignment): void {
        this.updateProperty(2, baseAlignment);
    }
    private clearFormattingInternal(isCompletePara?: boolean, isApplyStyle?: boolean): void {
        let selection: Selection = this.documentHelper.selection;
        this.setPreviousBlockToLayout();
        this.initComplexHistory('ClearFormat');
        // let startIndex: string = selection.start.getHierarchicalIndexInternal();
        // let endIndex: string = selection.end.getHierarchicalIndexInternal();
        if (selection.isEmpty || (!isNullOrUndefined(isCompletePara) && isCompletePara)) {
            selection.start.moveToParagraphStartInternal(selection, false);
            selection.end.moveToParagraphEndInternal(selection, false);
        }
        this.setOffsetValue(selection);
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('ClearCharacterFormat');
        }
        this.updateSelectionCharacterFormatting('ClearCharacterFormat', undefined, false);
        this.getOffsetValue(selection);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.setOffsetValue(selection);
        if (isNullOrUndefined(isCompletePara) || isCompletePara) {
            if (this.editorHistory) {
                this.editorHistory.initializeHistory('ClearParagraphFormat');
            }
            this.updateParagraphFormatInternal('ClearParagraphFormat', undefined, false);
        }
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.getOffsetValue(selection);
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
            if (isApplyStyle) {
                this.editorHistory.updateComplexHistoryInternal();
            } else {
                this.editorHistory.updateComplexHistory();
            }
        }
        this.startParagraph = undefined;
        this.endParagraph = undefined;
        // else {
        //     this.checkAndUpdatedSelection(startIndex, endIndex);
        // }
    }
    /**
     * Clears the formatting.
     *
     * @returns {void}
     */
    public clearFormatting(): void {
        this.clearFormattingInternal();
    }

    private updateProperty(type: number, value: Object): void {
        let selection: Selection = this.selection;
        if (((this.owner.isReadOnlyMode || this.restrictFormatting) && !this.selection.isInlineFormFillMode()) || !selection.owner.isDocumentLoaded) {
            return;
        }
        let startPosition: TextPosition = selection.start;
        let endPosition: TextPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        let indexInInline: number = 0;
        let inlineObj: ElementInfo = startPosition.currentWidget.getInline(startPosition.offset, indexInInline);
        let inline: ElementBox = inlineObj.element;
        indexInInline = inlineObj.index;
        let paragraph: ParagraphWidget = startPosition.paragraph;
        if (!isNullOrUndefined(inline) && inline.length === indexInInline && !this.selection.isEmpty) {
            inline = inline.nextNode as ElementBox;
        }
        if (type === 1) {
            let currentUnderline: Underline = 'None';
            if (!isNullOrUndefined(inline)) {
                currentUnderline = inline.characterFormat.underline;
            } else if (!isNullOrUndefined(paragraph)) {
                currentUnderline = paragraph.characterFormat.underline;
            }
            this.selection.characterFormat.underline = value === currentUnderline ? 'None' : value as Underline;
        } else {
            let script: BaselineAlignment = 'Normal';
            if (!isNullOrUndefined(inline)) {
                script = inline.characterFormat.baselineAlignment;
            } else if (!isNullOrUndefined(paragraph)) {
                script = paragraph.characterFormat.baselineAlignment;
            }
            if (script === value) {
                value = 'Normal';
            }
            this.selection.characterFormat.baselineAlignment = value as BaselineAlignment;
        }
    }
    private getCompleteStyles(): string {
        let completeStylesString: string = '{"styles":[';
        for (let name of this.documentHelper.preDefinedStyles.keys) {
            completeStylesString += (this.documentHelper.preDefinedStyles.get(name) + ',');
        }
        return completeStylesString.slice(0, -1) + ']}';
    }
    /**
     * Initialize default styles
     *
     * @private
     * @returns {void}
     */
    public intializeDefaultStyles(): void {
        this.owner.skipStyleUpdate = true;
        let existingStyles: string[] = this.owner.getStyleNames('Paragraph');
        let defaultStyleNames: string[] = ['Normal', 'Heading 1', 'Heading 2', 'Heading 3', 'Heading 4', 'Heading 5', 'Heading 6', 'Heading 7' , 'Heading 8' , 'Heading 9' , 'Header', 'Footer'];
        let styleNames: string[] = defaultStyleNames.filter((val: string) => {
            return existingStyles.indexOf(val) === -1;
        });
        for (let name of styleNames) {
            this.createStyle(this.documentHelper.preDefinedStyles.get(name));
        }
    }
    /**
     * Creates a new style or modifies an existing style with the specified style properties.
     *
     * > If modifyExistingStyle parameter is set to true and a style already exists with same name, it modifies the specified properties in the existing style.
     * > If modifyExistingStyle parameter is set to false and a style already exists with same name, it creates a new style with unique name by appending ‘_1’. Hence, the newly style will not have the specified name.
     * > If no style exists with same name, it creates a new style.
     *
     * @param {string} styleString The style properties.
     * @param {boolean} modifyExistingStyle The Boolean value denotes whether to modify the properties in the existing style or create a new style.
     * 
     * @returns {string} Returns the name of the created style.
     */
    public createStyle(styleString: string, modifyExistingStyle?: boolean): string {
        return (this.createStyleIn(styleString, modifyExistingStyle) as WStyle).name;
    }

    /**
     * @private
     * Adds a new style to the document or updates an existing style.
     *
     * @param {string} styleString - The style to be added or updated.
     * @param {boolean} modifyExistingStyle - Whether to modify an existing style.
     * @returns {Object} - The style that was added or updated.
     */
    public createStyleIn(styleString: string, modifyExistingStyle: boolean): Object {
        /* eslint-disable @typescript-eslint/no-explicit-any */
        let style: any = JSON.parse(styleString);
        let styleObj: any = this.documentHelper.styles.findByName(style.name);
        let inputStyleType: boolean = style.type;
        if (isNullOrUndefined(styleObj) || isNullOrUndefined(modifyExistingStyle) || !modifyExistingStyle) {
            if (styleObj !== undefined) {
                // Create a new style with new name and add it to collection.
                style.name = this.getUniqueStyleName(style.name);
            }
            this.documentHelper.owner.parser.parseStyle(JSON.parse(this.getCompleteStyles()), style, this.documentHelper.styles, true);
        } else {
            if (inputStyleType === styleObj.type) {
                // Update the existing style with the newly received style information(Json)
                this.setStyle(styleObj, style);
            } else {
                // Create a new style with new name and add it to collection.
                style.name = this.getUniqueStyleName(style.name);
                this.documentHelper.owner.parser.parseStyle(JSON.parse(this.getCompleteStyles()), style, this.documentHelper.styles, true);
            }
        }
        this.owner.notify(internalStyleCollectionChange, {});
        return this.documentHelper.styles.findByName(style.name);
    }
    /**
     * Modify the Style
     * @private
     * @returns {void}
     */
    private setStyle(styleObj: any, style: any): void {
        // based on Style
        if (!isNullOrUndefined(style.basedOn)) {
            const basedOn: Object = this.documentHelper.styles.findByName(style.basedOn);
            if (!isNullOrUndefined(basedOn)) {
                if ((basedOn as WStyle).type === style.type) {
                    styleObj.basedOn = basedOn;
                }
            } else {
                const basedStyle: any = this.getStyle(style.basedOn, JSON.parse(this.getCompleteStyles()));
                let styleData: any;
                if (!isNullOrUndefined(basedStyle) && basedStyle.type === style.type) {
                    styleData = basedStyle;
                } else {
                    if (style.type === 'Paragraph') {
                        styleData = JSON.parse('{"type":"Paragraph","name":"Normal","next":"Normal"}');
                    } else {
                        styleData = JSON.parse('{"type": "Character","name": "Default Paragraph Font"}');
                    }
                }
                styleObj.basedOn = this.documentHelper.styles.findByName(styleData.name);
            }
        }
        // next style
        if (!isNullOrUndefined(style.next)) {
            if (style.type === "Paragraph") {
                if (style.next === style.name) {
                    styleObj.next = styleObj;
                } else {
                    const next: Object = this.documentHelper.styles.findByName(style.next);
                    if (!isNullOrUndefined(next) && (next as WStyle).type === styleObj.type) {
                        styleObj.next = next;
                    } else {
                        styleObj.next = styleObj;
                    }
                }
            }
        }
        // link style
        if (!isNullOrUndefined(style.link)) {
            const link: Object = this.documentHelper.styles.findByName(style.link);
            let styleString: any;
            if (!isNullOrUndefined(link) && ((link as any).type === "Character")) {
                this.documentHelper.owner.parser.parseCharacterFormat(0, style.characterFormat, (link as any).characterFormat);
                styleObj.link = link;
            }
            else {
                //Construct the CharacterStyle string
                const charaStyle: any = {};
                charaStyle.characterFormat = style.characterFormat;
                let newCharStyle: any = this.documentHelper.styles.findByName(style.name + ' Char');
                if (newCharStyle.name !== undefined) {
                    charaStyle.name = this.getUniqueStyleName(style.name) + ' Char';
                } else {
                    charaStyle.name = style.name + ' Char';
                }
                charaStyle.type = 'Character';
                charaStyle.basedOn = 'Default Paragraph Font';
                styleString = charaStyle;
                this.documentHelper.owner.parser.parseStyle(JSON.parse(this.getCompleteStyles()), styleString, this.documentHelper.styles);
                styleObj.link = this.documentHelper.styles.findByName(styleString.name);
            }
            if (style.type == 'Character') {
                for (let i = 0; i < this.documentHelper.styles.length; i++) {
                    let styleFormCollection: any = this.documentHelper.styles.getItem(i);
                    let styleLink: any = styleFormCollection.link;
                    let linkName = styleLink === undefined ? "" : styleLink.name;
                    if (styleFormCollection.type === 'Paragraph' && linkName === style.link) {
                        if (!isNullOrUndefined(styleFormCollection.characterFormat)) {
                            this.documentHelper.owner.parser.parseCharacterFormat(0, style.characterFormat, styleFormCollection.characterFormat);
                        }
                    }
                }
            }
        }
        //update the new paragraph style 
        if (!isNullOrUndefined(style.paragraphFormat)) {
            this.documentHelper.owner.parser.parseParagraphFormat(0, style.paragraphFormat, styleObj.paragraphFormat);
        }
        //update the new character style 
        if (!isNullOrUndefined(style.characterFormat)) {
            this.documentHelper.owner.parser.parseCharacterFormat(0, style.characterFormat, styleObj.characterFormat);
        }
    }
    private getStyle(name: string, data: any): any {
        for (let i: number = 0; i < data.styles.length; i++) {
            if (data.styles[i].name === name) {
                return data.styles[i];
            }
        }
        return undefined;
    }
    private getUniqueStyleName(name: string): string {
        let uniqueName: string = this.getUniqueName(name);
        let style: Object = this.documentHelper.styles.findByName(uniqueName);
        while (!isNullOrUndefined(style)) {
            uniqueName = this.getUniqueStyleName((style as WStyle).name);
            style = this.documentHelper.styles.findByName(uniqueName);
        }
        return uniqueName;
    }
    private getUniqueName(name: string): string {
        let matchArray: RegExpMatchArray = name.match(/\d+$/);
        let returnName: string;
        if (!isNullOrUndefined(matchArray) && matchArray.length > 0) {
            return name.replace(matchArray[0], (parseInt(matchArray[0], 10) + 1).toString());
        } else {
            return name + '_1';
        }
    }
    /**
     * Update Character format for selection
     * @private
     */
    public updateSelectionCharacterFormatting(property: string, values: Object, update: boolean): void {
        if (isNullOrUndefined(property)) {
            property = 'CharacterFormat';
        }
        if (!isNullOrUndefined(this.editorHistory) && this.editorHistory.currentBaseHistoryInfo) {
            this.editorHistory.currentBaseHistoryInfo.insertedFormat = values;
        }
        switch (property) {
            case 'bold':
                this.updateCharacterFormat('bold', values);
                break;
            case 'italic':
                this.updateCharacterFormat('italic', values);
                break;
            case 'fontColor':
                this.updateCharacterFormat('fontColor', values);
                break;
            case 'fontFamily':
                this.updateCharacterFormat('fontFamily', values);
                break;
            case 'fontSize':
                this.documentHelper.layout.isBidiReLayout = false;
                this.updateCharacterFormatWithUpdate(this.documentHelper.selection, 'fontSize', values, update);
                break;
            case 'highlightColor':
                this.updateCharacterFormat('highlightColor', values);
                break;
            case 'baselineAlignment':
                this.updateCharacterFormat('baselineAlignment', values);
                break;
            case 'strikethrough':
                this.updateCharacterFormat('strikethrough', values);
                break;
            case 'underline':
                this.updateCharacterFormat('underline', values);
                break;
            case 'styleName':
                this.updateCharacterFormatWithUpdate(this.documentHelper.selection, 'styleName', values, true, true);
                break;
            case 'CharacterFormat':
                this.updateCharacterFormat(undefined, values);
                break;
            case 'ClearCharacterFormat':
                this.updateCharacterFormat(undefined, values);
                break;
            case 'allCaps':
                this.updateCharacterFormat('allCaps', values);
                break;
        }
        this.reLayout(this.documentHelper.selection);
    }

    private updateCharacterFormat(property: string, value: Object): void {
        this.updateCharacterFormatWithUpdate(this.documentHelper.selection, property, value, false);
    }
    private updateCharacterFormatWithUpdate(selection: Selection, property: string, value: Object, update: boolean, styleName?: boolean): void {
        styleName = isNullOrUndefined(styleName) ? false : styleName;
        this.documentHelper.owner.isShiftingEnabled = true;
        let startPosition: TextPosition = selection.start;
        let endPosition: TextPosition = selection.end;
        if (!selection.isEmpty && !selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        if (selection.isEmpty && styleName) {
            let offset: number = startPosition.offset;
            let preservedStartPosition: TextPosition = startPosition.clone();
            let preservedEndPosition: TextPosition = endPosition.clone();
            this.selection.selectCurrentWord();
            if (offset === this.selection.start.offset || offset === this.selection.end.offset - 1) {
                this.selection.start = preservedStartPosition;
                this.selection.end = preservedEndPosition;
            }
        }
        this.applyCharFormatSelectedContent(startPosition.paragraph, selection, startPosition, endPosition, property, value, update);
    }

    private applyCharFormatSelectedContent(paragraph: ParagraphWidget, selection: Selection, start: TextPosition, end: TextPosition, property: string, value: Object, update: boolean): void {
        //Selection start in cell.
        if (start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
            || start.paragraph.associatedCell !== end.paragraph.associatedCell
            || selection.isCellSelected(start.paragraph.associatedCell, start, end))) {
            let cell: TableCellWidget;
            start.paragraph.associatedCell.ownerTable.combineWidget(this.owner.viewer);
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(start, true);
            }
            cell = start.paragraph.associatedCell;
            let block: BlockWidget = this.applyCharFormatCell(cell, selection, start, end, property, value, update);
            while (block) {
                if (block instanceof ParagraphWidget) {
                    block = this.applyCharFormat(block, selection, start, end, property, value, update);
                } else {
                    block = this.applyCharFormatForTable(0, block as TableWidget, selection, start, end, property, value, update);
                }
            }
            let table: TableWidget = cell.ownerTable;

            this.documentHelper.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        } else {
            let block: BlockWidget = paragraph;
            do {
                if (block instanceof ParagraphWidget) {
                    block = this.applyCharFormat(block, selection, start, end, property, value, update);
                } else {
                    block = this.applyCharFormatForTable(0, block as TableWidget, selection, start, end, property, value, update);
                }
            } while (block)
        }
    }

    private applyCharFormatForSelectedPara(paragraph: ParagraphWidget, selection: Selection, property: string, value: Object, update: boolean): void {
        for (let i: number = 0; i < paragraph.childWidgets.length; i++) {
            let line: LineWidget = paragraph.childWidgets[i] as LineWidget;
            for (let j: number = 0; j < line.children.length; j++) {
                let element: ElementBox = line.children[j];
                element.isWidthUpdated = false;
                this.applyCharFormatValue(element.characterFormat, property, value, update);
            }
        }
        this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
    }
    private splittedLastParagraph(paragraph: ParagraphWidget): ParagraphWidget {
        let splittedWidets: ParagraphWidget[] = paragraph.getSplitWidgets() as ParagraphWidget[];
        return splittedWidets[splittedWidets.length - 1] as ParagraphWidget;
    }

    private getNextParagraphForCharacterFormatting(block: BlockWidget, start: TextPosition, end: TextPosition, property: string, value: Object, update: boolean): BlockWidget {
        let widgetCollection: BlockWidget[] = block.getSplitWidgets() as BlockWidget[];
        block = widgetCollection[widgetCollection.length - 1];
        return this.documentHelper.selection.getNextRenderedBlock(block);
    }

    private applyCharFormat(paragraph: ParagraphWidget, selection: Selection, start: TextPosition, end: TextPosition, property: string, value: Object, update: boolean): BlockWidget {
        let previousSplittedWidget: ParagraphWidget = paragraph.previousSplitWidget as ParagraphWidget;
        let isLayoutWhole: boolean = false;
        if (!isNullOrUndefined(previousSplittedWidget) && previousSplittedWidget instanceof ParagraphWidget) {
            isLayoutWhole = true;
        }
        paragraph = paragraph.combineWidget(this.owner.viewer) as ParagraphWidget;
        let startOffset: number = 0;
        let length: number = selection.getParagraphLength(paragraph);
        let startLineWidget: number = paragraph.childWidgets.indexOf(start.currentWidget) !== -1 ?
            paragraph.childWidgets.indexOf(start.currentWidget) : 0;
        let endOffset: number = end.offset;
        let endLineWidget: number = paragraph.childWidgets.indexOf(end.currentWidget) !== -1 ?
            paragraph.childWidgets.indexOf(end.currentWidget) : paragraph.childWidgets.length - 1;
        if (!isNullOrUndefined(selection)) {
            if (paragraph === start.paragraph) {
                startOffset = start.offset;
            }
        }
        if (!paragraph.equals(end.paragraph)) {
            let lastLine: LineWidget = paragraph.childWidgets[paragraph.childWidgets.length - 1] as LineWidget;
            //Skip consider highlightcolor if paragraph mark alone is selected similar to Microsoft Word behaviour
            if (!(property === 'highlightColor' && selection.isParagraphLastLine(lastLine)
                && start.currentWidget === lastLine && start.offset === selection.getLineLength(lastLine))) {
                this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
            }
            endOffset = length;

        } else {
            let lastLine: LineWidget = paragraph.childWidgets[paragraph.childWidgets.length - 1] as LineWidget;
            if (selection.isParagraphLastLine(lastLine) && end.currentWidget === lastLine
                && ((endOffset === selection.getLineLength(lastLine) + 1) || (selection.isEmpty && selection.end.isAtParagraphEnd))) {
                this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
            } 
        }
        // let count: number = 0;
        for (let i: number = startLineWidget; i <= endLineWidget; i++) {
            let line: LineWidget = paragraph.childWidgets[i] as LineWidget;
            if (i !== startLineWidget) {
                startOffset = selection.getStartLineOffset(line);
            }
            if (line === end.currentWidget) {
                endOffset = end.offset;
            } else {
                endOffset = selection.getLineLength(line);
            }
            let count: number = 0;
            let isStarted: boolean = true;
            let endElement: ElementBox = undefined;
            let indexOf: number = -1;
            let isIncrease: boolean = true;

            for (let j: number = 0; j < line.children.length; isIncrease ? j++ : j--) {
                let inlineObj: ElementBox = line.children[j] as ElementBox;
                isStarted = false;
                inlineObj.isWidthUpdated = false;
                if (inlineObj instanceof ListTextElementBox) {
                    continue;
                }
                if (endElement === inlineObj) {
                    endElement = undefined;
                    j = indexOf;
                    indexOf = -1;
                    isIncrease = true;
                }
                if (startOffset >= count + inlineObj.length) {
                    count += inlineObj.length;
                    continue;
                }
                let startIndex: number = 0;
                if (startOffset > count) {
                    startIndex = startOffset - count;
                }
                let endIndex: number = endOffset - count;
                let inlineLength: number = inlineObj.length;
                if (endIndex > inlineLength) {
                    endIndex = inlineLength;
                }
                let index: number = this.applyCharFormatInline(inlineObj, selection, startIndex, endIndex, property, value, update);
                // Added the revision for the character format of the current para when inserting the link when selecting the multiple para and inserting the link.
                if ((property !== "fontColor" || paragraph.characterFormat.revisionLength === 0) && !paragraph.equals(end.paragraph) && this.isForHyperlinkFormat && this.owner.enableTrackChanges && line.children[j].indexInOwner === line.children.length - 1 && line === line.paragraph.lastChild) {
                    if (!isNullOrUndefined(inlineObj) && inlineObj.revisionLength > 0) {
                        let currentRevision: Revision = inlineObj.getRevision(inlineObj.revisionLength - 1);
                        this.insertRevision(paragraph.characterFormat, currentRevision.revisionType);
                        //currentRevision.range.push(paragraph.characterFormat);
                        // this.owner.trackChangesPane.updateCurrentTrackChanges(currentRevision);
                    }
                }
                j += index;

                if (endOffset <= count + inlineLength) {
                break;
                }
                count += inlineLength;
            }
        }
        let endParagraph: ParagraphWidget = end.paragraph;
        this.documentHelper.layout.reLayoutParagraph(paragraph, isLayoutWhole ? 0 : startLineWidget, 0);

        if (paragraph.equals(endParagraph)) {
            return undefined;
        }
        return this.getNextParagraphForCharacterFormatting(paragraph, start, end, property, value, update);
    }
    /**
     * Toggles the bold property of selected contents.
     *
     * @returns {void}
     */
    public toggleBold(): void {
        if ((this.owner.isReadOnlyMode || this.restrictFormatting) && !this.selection.isInlineFormFillMode()) {
            return;
        }
        let value: boolean = this.getCurrentSelectionValue('bold');
        this.selection.characterFormat.bold = value;
    }
    /**
     * Toggles the bold property of selected contents.
     *
     * @returns {void}
     */
    public toggleItalic(): void {
        if ((this.owner.isReadOnlyMode || this.restrictFormatting) && !this.selection.isInlineFormFillMode()) {
            return;
        }
        let value: boolean = this.getCurrentSelectionValue('italic');
        this.selection.characterFormat.italic = value;
    }
    /**
     * Change the selected text to uppercase.
     * @private
     */
    public changeCase(property: string): void {
        if (this.selection.isEmpty || ((this.owner.isReadOnlyMode || this.restrictFormatting) && !this.selection.isInlineFormFillMode())) {
            return;
        }
        // this.selection.characterFormat.allCaps = (property === "Uppercase") ? true : false;
        this.initHistory(property as Action);
        this.documentHelper.owner.isShiftingEnabled = true;
        let selection: Selection = this.selection;
        let startPosition: TextPosition = selection.start;
        let endPosition: TextPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        this.changeSelectedTextCase(selection, startPosition, endPosition, property);
        this.reLayout(selection);
    }
    /**
     * Change the selected text case.
     * @private
     */
    /* eslint-disable-next-line max-len */
    public changeSelectedTextCase(selection: Selection, startPosition: TextPosition, endPosition: TextPosition, property: string, removedTextNodes?: IWidget[]): void {
        let blockInfo: ParagraphInfo = this.selection.getParagraphInfo(startPosition);
        selection.editPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(startPosition, true);
            }
        }
        let isRevert: boolean = this.editorHistory.isUndoing;
        if (isRevert && !isNullOrUndefined(removedTextNodes) && removedTextNodes.length > 0) {
            this.removedTextNodes = removedTextNodes;
        }
        let endPos: string = selection.isForward ? endPosition.selection.endOffset : endPosition.selection.startOffset;
        this.changeTextCase(startPosition.paragraph, selection, startPosition, endPosition, property, isRevert);
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            endPosition = selection.getTextPosBasedOnLogicalIndex(endPos);
            if (this.checkEndPosition(selection)) {
                this.updateHistoryPosition(endPosition, false);
            }
            selection.selectPosition(startPosition, endPosition);
        }
    }
    /* eslint-disable-next-line max-len */
    private changeTextCase(para: ParagraphWidget, selection: Selection, startPosition: TextPosition, endPosition: TextPosition, property: string, isRevert: boolean): void {
        if (startPosition.paragraph.isInsideTable && (!endPosition.paragraph.isInsideTable
            || startPosition.paragraph.associatedCell !== endPosition.paragraph.associatedCell
            || selection.isCellSelected(startPosition.paragraph.associatedCell, startPosition, endPosition))) {
            let tableCell: TableCellWidget;
            startPosition.paragraph.associatedCell.ownerTable.combineWidget(this.owner.viewer);
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(startPosition, true);
            }
            tableCell = startPosition.paragraph.associatedCell;
            this.changeCaseParaFormatInCell(tableCell, startPosition, endPosition, property, isRevert);
            let table: TableWidget = tableCell.ownerTable;
            this.documentHelper.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        } else {
            this.changeCaseParagraph(para, selection, startPosition, endPosition, property, isRevert);
        }
    }
    /* eslint-disable-next-line max-len */
    private changeCaseParagraph(para: ParagraphWidget, selection: Selection, startPos: TextPosition, endPos: TextPosition, property: string, isRevert: boolean): void {
        para = para.combineWidget(this.owner.viewer) as ParagraphWidget;
        let startOffsetVal: number = 0;
        let len: number = selection.getParagraphLength(para);
        let startLine: number = para.childWidgets.indexOf(startPos.currentWidget) !== -1 ?
            para.childWidgets.indexOf(startPos.currentWidget) : 0;
        let endOffsetVal: number = endPos.offset;
        let endLine: number = para.childWidgets.indexOf(endPos.currentWidget) !== -1 ?
            para.childWidgets.indexOf(endPos.currentWidget) : para.childWidgets.length - 1;
        if (!isNullOrUndefined(selection)) {
            if (para === startPos.paragraph) {
                startOffsetVal = startPos.offset;
            }
        }
        if (!para.equals(endPos.paragraph)) {
            endOffsetVal = len;
        }
        // let count: number = 0;
        for (let i: number = startLine; i <= endLine; i++) {
            this.checkLastLetterSpaceDot = '';
            this.checkLastLetterSpace = '';
            let line: LineWidget = para.childWidgets[i] as LineWidget;
            if (i !== startLine) {
                startOffsetVal = selection.getStartLineOffset(line);
            }
            if (line === endPos.currentWidget) {
                endOffsetVal = endPos.offset;
            } else {
                endOffsetVal = selection.getLineLength(line);
            }
            let textCount: number = 0;
            let isIterationStarted: boolean = true;
            let endElementBox: ElementBox = undefined;
            let childIndex: number = -1;
            let isIncreaseIteration: boolean = true;
            /* eslint-disable-next-line max-len */
            for (let j: number = 0; j < line.children.length; isIncreaseIteration ? j++ : j--) {
                let child: ElementBox = line.children[j] as ElementBox;
                let isPreviousTextElementBox : boolean = false;
                if(j === 0 || j>0 && line.children[j-1] instanceof TextElementBox)
                {
                    isPreviousTextElementBox = true;
                    if(j>0){
                        let textElement: TextElementBox = line.children[j-1] as TextElementBox;
                        this.checkLastLetterSpace = textElement.text.substr(-1);
                        this.checkLastLetterSpaceDot = textElement.text.substr(-2);
                    }
                }
                isIterationStarted = false;
                if (child instanceof ListTextElementBox) {
                    continue;
                }
                if (endElementBox === child) {
                    endElementBox = undefined;
                    j = childIndex;
                    childIndex = -1;
                    isIncreaseIteration = true;
                }
                if (startOffsetVal >= textCount + child.length) {
                    textCount += child.length;
                    continue;
                }
                let startIndex: number = 0;
                if (startOffsetVal > textCount) {
                    startIndex = startOffsetVal - textCount;
                }
                let endIndex: number = endOffsetVal - textCount;
                let inlineLength: number = child.length;
                if (endIndex > inlineLength) {
                    endIndex = inlineLength;
                }
                let index: number = this.changeCaseInline(child, selection, startIndex, endIndex, property, isRevert,isPreviousTextElementBox);
                j += index;
                if (endOffsetVal <= textCount + inlineLength) {
                    break;
                }
                textCount += inlineLength;
            }
        }
        let endPara: ParagraphWidget = endPos.paragraph;
        this.documentHelper.layout.reLayoutParagraph(para, startLine, 0);
        if (para.equals(endPara)) {
            return;
        }
        this.changeCaseNextBlock(para, startPos, endPos, property, isRevert);
    }
    /* eslint-disable-next-line max-len */
    private changeCaseInline(inline: ElementBox, selection: Selection, startIndex: number, endIndex: number, property: string, isRevert: boolean, isPreviousTextElementBox: boolean): number {
        if (inline instanceof TextElementBox) {
            if (startIndex === 0 && endIndex === inline.length) {
                this.changeCaseInlineInternal(inline, selection, startIndex, endIndex, property, isRevert,isPreviousTextElementBox);
            } else {
                return this.changeCaseInlineInternal(inline, selection, startIndex, endIndex, property, isRevert,isPreviousTextElementBox);
            }
        }
        return 0;
    }
    private addRemovedTextNodes(inline: ElementBox, newText: string): void {
        if (inline instanceof TextElementBox) {
            if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                let span: TextElementBox = this.editorHistory.currentBaseHistoryInfo.removedNodes[0] as TextElementBox;
                if (isNullOrUndefined(span)) {
                    span = new TextElementBox();
                    span.text = '';
                    this.editorHistory.currentBaseHistoryInfo.removedNodes.push(span);
                }
                span.text += newText;
                span.isWidthUpdated = false;
            }
        }
    }
    /* eslint-disable-next-line max-len */
    private changeCaseInlineInternal(inlineObj: ElementBox, selection: Selection, startIndex: number, endIndex: number, property: string, isRevert: boolean,isPreviousTextElementBox:boolean): number {
        let x: number = 0;
        let makeFirstLetterCapital: boolean = false;
        let index: number = inlineObj.line.children.indexOf(inlineObj);
        let paragraph: ParagraphWidget = inlineObj.paragraph;
        let lineIndex: number = paragraph.childWidgets.indexOf(inlineObj.line);
        let textElement: TextElementBox;
        inlineObj.isWidthUpdated = false;
        if (startIndex > 0) {
            let textToChange: string = (inlineObj as TextElementBox).text.substr(startIndex, endIndex - startIndex);
            this.addRemovedTextNodes(inlineObj, textToChange);
            textElement = new TextElementBox();
            textElement.characterFormat.copyFormat(inlineObj.characterFormat);
            textElement.line = inlineObj.line;
            //Change the text case
            if (property === 'CapitalizeEachWord') {
                let firstLetter: string = (inlineObj as TextElementBox).text.substr(startIndex - 1, 1);
                makeFirstLetterCapital = firstLetter === ' ';
            }
            if (property === 'SentenceCase') {
                let firstLetter: string = (inlineObj as TextElementBox).text.substr(startIndex - 2, 2);
                makeFirstLetterCapital = firstLetter === '. ';
            }
            textElement.characterFormat.allCaps = (property === "Uppercase") ? isRevert ? false : true : false;
            textElement.text = this.getChangeCaseText(textToChange, property, isRevert, makeFirstLetterCapital);
            textElement.isRightToLeft = inlineObj.isRightToLeft;
            index++;
            inlineObj.line.children.splice(index, 0, textElement);
            x++;
        }
        if (endIndex < inlineObj.length) {
            textElement = new TextElementBox();
            textElement.characterFormat.copyFormat(inlineObj.characterFormat);
            textElement.text = (inlineObj as TextElementBox).text.substring(endIndex);
            textElement.line = inlineObj.line;
            textElement.isRightToLeft = inlineObj.isRightToLeft;
            index++;
            inlineObj.line.children.splice(index, 0, textElement);
            x++;
        }
        let textElementBox: TextElementBox = (inlineObj as TextElementBox);
        if (startIndex === 0) {
            let newText: string = textElementBox.text.substr(0, endIndex);
            this.addRemovedTextNodes(inlineObj, newText);
            //Change the text case
            if (property === 'SentenceCase') {
                if (this.checkLastLetterSpaceDot === '. ') {
                    makeFirstLetterCapital = true;
                }
                else if (lineIndex === 0 && this.checkLastLetterSpaceDot === '') {
                    if(isPreviousTextElementBox){
                    let line : LineWidget = paragraph.childWidgets[0] as LineWidget;
                    let element : TextElementBox = line.children[0] as TextElementBox;
                    makeFirstLetterCapital = element === textElementBox;
                    }
                    else{
                        makeFirstLetterCapital = true;
                    }
                }
                this.checkLastLetterSpaceDot = textElementBox.text.substr(-2);
            }
            else if (property == 'CapitalizeEachWord') {
                    if(isPreviousTextElementBox){
                    makeFirstLetterCapital = selection.getIndexInInline(inlineObj) === 0 || this.checkLastLetterSpace === ' ' || textElementBox.previousElement instanceof TabElementBox;
                    }
                    else {
                        if (textElementBox.previousElement instanceof CommentCharacterElementBox ||
                            textElementBox.previousElement instanceof BookmarkElementBox ||
                            textElementBox.previousElement instanceof FieldElementBox) {
                            let tempString: string = !isNullOrUndefined(textElementBox.previousElement.previousElement) ? (textElementBox.previousElement.previousElement as TextElementBox).text : undefined;
                            if (isNullOrUndefined(tempString) || HelperMethods.endsWith(tempString)) {
                                makeFirstLetterCapital = true;
                            }
                            else {
                                makeFirstLetterCapital = false;
                            }
                        }
                        else {
                            makeFirstLetterCapital = true;
                        }
                    }
                this.checkLastLetterSpace = textElementBox.text.charAt(textElementBox.length - 1);
            }
            textElementBox.characterFormat.allCaps = (property === "Uppercase") ? isRevert ? false : true : false;
            textElementBox.text = this.getChangeCaseText(newText, property, isRevert, makeFirstLetterCapital);
        } else {
            let preText: string = textElementBox.text.substr(0, startIndex);
            textElementBox.text = preText;
        }
        return x;
    }
    /* eslint-disable-next-line max-len */
    private changeCaseNextBlock(block: BlockWidget, start: TextPosition, end: TextPosition, property: string, isRevert: boolean): void {
        block = this.getNextBlockForChangeCase(block, start, end, property, isRevert);
        if (!isNullOrUndefined(block)) { //Goto the next block.
            if (block instanceof ParagraphWidget) {
                this.changeCaseParagraph(block, this.documentHelper.selection, start, end, property, isRevert);
            } else {
                this.changeCaseForTable(0, block as TableWidget, this.documentHelper.selection, start, end, property, isRevert);
            }
        }
    }
    /* eslint-disable-next-line max-len */
    private getNextBlockForChangeCase(block: BlockWidget, start: TextPosition, end: TextPosition, property: string, isRevert: boolean): BlockWidget {
        let widgetCollection: BlockWidget[] = block.getSplitWidgets() as BlockWidget[];
        block = widgetCollection[widgetCollection.length - 1];
        block = this.documentHelper.selection.getNextRenderedBlock(block);
        return block;
    }
    private getChangeCaseText(input: string, property: string, isRevert: boolean, makeFirstLetterCapital?: boolean): string {
        if (isRevert) {
            if (!isNullOrUndefined(this.removedTextNodes) && this.removedTextNodes.length > 0) {
                let textElement: TextElementBox = this.removedTextNodes[0] as TextElementBox;
                let oldText: string = textElement.text.substr(0, input.length);
                textElement.text = textElement.text.substr(oldText.length, textElement.length - oldText.length);
                input = oldText;
                if (textElement.text === '') {
                    this.removedTextNodes.splice(0, 1);
                }
            }
        } else {
            switch (property) {
                case 'SentenceCase':
                    input = this.sentencecase(input, makeFirstLetterCapital);
                    break;
                case 'Uppercase':
                    input = input.toUpperCase();
                    break;
                case 'Lowercase':
                    input = input.toLowerCase();
                    break;
                case 'CapitalizeEachWord':
                    input = this.capitalizeFirst(input, makeFirstLetterCapital);
                    break;
                case 'ToggleCase':
                    input = this.togglecase(input);
                    break;
                default:
                    break;
            }
        }
        return input;
    }
    //Change text into capitalize each word
    private capitalizeFirst(inputString: string, makeFirstLetterCapital: boolean): string {
        const pattern = /\b\w+'\w+\b/g;
        if (pattern.test(inputString)) {
            let words: string = inputString.split(/[^a-zA-Z0-9'\-]+/).toString();
            words = inputString.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
            return words;
        }
        const words: string[] = inputString.split(/[^\w]+/g);
        const capitalizedWords: string[] = words.map((word, index) => {
            if (index === 0) {
                return makeFirstLetterCapital ? word.charAt(0).toUpperCase() + word.slice(1).toLowerCase() : word.toLowerCase();
            }
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        });
        const specialChars: string[] = inputString.split(/\w+/).filter(Boolean);
        const resultArray: string[] = [];
        for (let i = 0; i < Math.max(capitalizedWords.length, specialChars.length); i++) {
            if (capitalizedWords[i]) {
                resultArray.push(capitalizedWords[i]);
            }
            if (specialChars[i]) {
                resultArray.push(specialChars[i]);
            }
        }
        const resultString: string = resultArray.join('');
        return resultString;
    }
    //change text to sentence case
    private sentencecase(value: string, makeFirstLetterCapital: boolean): string {
        var sentences = value.split('. ');
        var capitalizedSentences = sentences.map((sentence, index) => {
            if (index === 0) {
                return makeFirstLetterCapital ? sentence.charAt(0).toUpperCase() + sentence.slice(1).toLowerCase() : sentence.toLowerCase();
            }
            return sentence.charAt(0).toUpperCase() + sentence.slice(1).toLowerCase();
        });
        var resultString = capitalizedSentences.join('. ');
        return resultString;
    }
    //Change text to toggle case
    private togglecase(value: string) {
        var text: string = '';
        var toggle: string[] = value.split('').map(char => {
            if (char === char.toLowerCase()) {
                return char.toUpperCase();
            } else {
                return char.toLowerCase();
            }
        });
        text = toggle.join('');
        return text;
    }
    // Table
    /* eslint-disable-next-line max-len */
    private changeCaseForTable(indexToStart: number, tableWidget: TableWidget, selection: Selection, startPos: TextPosition, endPos: TextPosition, property: string, isRevert: boolean): void {
        tableWidget = tableWidget.combineWidget(this.owner.viewer) as TableWidget;
        for (let i: number = indexToStart; i < tableWidget.childWidgets.length; i++) {
            let row: TableRowWidget = tableWidget.childWidgets[i] as TableRowWidget;
            for (let j: number = 0; j < row.childWidgets.length; j++) {
                this.changeCaseForSelectedCell((row.childWidgets[j] as TableCellWidget), selection, property, isRevert);
            }
            if (endPos.paragraph.isInsideTable && selection.containsRow(row, endPos.paragraph.associatedCell)) {
                this.documentHelper.layout.layoutBodyWidgetCollection(tableWidget.index, tableWidget.containerWidget, tableWidget, false);
                return;
            }
        }
        this.documentHelper.layout.layoutBodyWidgetCollection(tableWidget.index, tableWidget.containerWidget, tableWidget, false);
        this.changeCaseNextBlock(tableWidget, startPos, endPos, property, isRevert);
    }
    /* eslint-disable-next-line max-len */
    private changeCaseForSelectedCell(cell: TableCellWidget, selection: Selection, property: string, isRevert: boolean): void {
        for (let i: number = 0; i < cell.childWidgets.length; i++) {
            let block: BlockWidget = cell.childWidgets[i] as BlockWidget;
            if (block instanceof ParagraphWidget) {
                this.changeCaseForSelectedPara((block as ParagraphWidget), selection, property, isRevert);
            } else {
                this.changeCaseForSelTable(block as TableWidget, selection, property, isRevert);
            }
        }
    }
    /* eslint-disable-next-line max-len */
    private changeCaseForSelectedPara(paragraph: ParagraphWidget, selection: Selection, property: string, isRevert: boolean): void {
        for (let i: number = 0; i < paragraph.childWidgets.length; i++) {
            let line: LineWidget = paragraph.childWidgets[i] as LineWidget;
            let firstLetter: string = '';
            for (let j: number = 0; j < line.children.length; j++) {
                let element: TextElementBox = line.children[j] as TextElementBox;
                element.characterFormat.allCaps = (property === "Uppercase") ? isRevert ? false : true : false;
                let makeFirstLetterCapital: boolean = false;
                if (!isNullOrUndefined(element) && element instanceof TextElementBox) {
                    this.addRemovedTextNodes(element, element.text);
                    if (property === 'CapitalizeEachWord') {
                        makeFirstLetterCapital = j === 0 || firstLetter === ' ';
                        firstLetter = element.text.substr(element.length - 1, 1);
                    } else if (property === 'SentenceCase') {
                        makeFirstLetterCapital = (element.text.substr(element.length - 2, 2) === '. ') || j === 0;
                    }
                    element.text = this.getChangeCaseText(element.text, property, isRevert, makeFirstLetterCapital);
                    element.isWidthUpdated = false;
                }
            }
        }
    }
    /* eslint-disable-next-line max-len */
    private changeCaseForSelTable(tableWidget: TableWidget, selection: Selection, property: string, isRevert: boolean): void {
        for (let i: number = 0; i < tableWidget.childWidgets.length; i++) {
            let row: TableRowWidget = tableWidget.childWidgets[i] as TableRowWidget;
            for (let j: number = 0; j < row.childWidgets.length; j++) {
                this.changeCaseForSelectedCell((row.childWidgets[j] as TableCellWidget), selection, property, isRevert);
            }
        }
    }
    // Cell
    /* eslint-disable-next-line max-len */
    private changeCaseParaFormatInCell(tableCell: TableCellWidget, startPos: TextPosition, endPos: TextPosition, property: string, isRevert: boolean): void {
        let selection: Selection = this.documentHelper.selection;
        if (endPos.paragraph.isInsideTable) {
            let cellContainer: TableCellWidget = selection.getContainerCellOf(tableCell, endPos.paragraph.associatedCell);
            if (cellContainer.ownerTable.contains(endPos.paragraph.associatedCell)) {
                let startCell: TableCellWidget = selection.getSelectedCell(tableCell, cellContainer);
                let endCell: TableCellWidget = selection.getSelectedCell(endPos.paragraph.associatedCell, cellContainer);
                if (selection.containsCell(cellContainer, endPos.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (selection.isCellSelected(cellContainer, startPos, endPos)) {
                        this.changeCaseParaForCellInternal(cellContainer, selection, property, isRevert);
                    } else {
                        if (startCell === cellContainer) {
                            this.changeCaseParagraph(startPos.paragraph, selection, startPos, endPos, property, isRevert);
                        } else {
                            this.changeCaseParaForRow(startCell.ownerRow, selection, startPos, endPos, property, isRevert);
                        }
                    }
                } else {
                    //Change case of other selected cells in the current table.
                    this.changeCaseParaForTableCell(cellContainer.ownerTable, cellContainer, endCell, property, isRevert);
                }
            } else {
                this.changeCaseParaForRow(cellContainer.ownerRow, selection, startPos, endPos, property, isRevert);
            }
        } else {
            let wCell: TableCellWidget = selection.getContainerCell(tableCell);
            this.changeCaseParaForRow(wCell.ownerRow, selection, startPos, endPos, property, isRevert);
        }
    }
    // Table
    /* eslint-disable-next-line max-len */
    private changeCaseParaForTableCell(tableWidget: TableWidget, startCell: TableCellWidget, endCell: TableCellWidget, property: string, isRevert: boolean): void {
        let selection: Selection = this.documentHelper.selection;
        let cellStartValue: number = selection.getCellLeft(startCell.ownerRow, startCell);
        let cellEndValue: number = cellStartValue + startCell.cellFormat.cellWidth;
        let cellEndLeft: number = selection.getCellLeft(endCell.ownerRow, endCell);
        let cellEndRight: number = cellEndLeft + endCell.cellFormat.cellWidth;
        let cellInfo: CellInfo = this.updateSelectedCellsInTable(cellStartValue, cellEndValue, cellEndLeft, cellEndRight);
        cellStartValue = cellInfo.start;
        cellEndValue = cellInfo.end;
        let count: number = tableWidget.childWidgets.indexOf(endCell.ownerRow);
        for (let m: number = tableWidget.childWidgets.indexOf(startCell.ownerRow); m <= count; m++) {
            let row: TableRowWidget = tableWidget.childWidgets[m] as TableRowWidget;
            for (let j: number = 0; j < row.childWidgets.length; j++) {
                let left: number = selection.getCellLeft(row, row.childWidgets[j] as TableCellWidget);
                if (Math.round(cellStartValue) <= Math.round(left) && Math.round(left) < Math.round(cellEndValue)) {
                    this.changeCaseParaForCellInternal((row.childWidgets[j] as TableCellWidget), selection, property, isRevert);
                }
            }
        }
    }
    /* eslint-disable-next-line max-len */
    private changeCaseParaForCellInternal(tableCell: TableCellWidget, selection: Selection, property: string, isRevert: boolean): void {
        for (let i: number = 0; i < tableCell.childWidgets.length; i++) {
            let childBlock: BlockWidget = tableCell.childWidgets[i] as BlockWidget;
            if (childBlock instanceof ParagraphWidget) {
                this.changeCaseForSelectedPara((childBlock as ParagraphWidget), selection, property, isRevert);
            } else {
                this.changeCaseParaFormatTableInternal(childBlock as TableWidget, selection, property, isRevert);
            }
        }
    }
    /* eslint-disable-next-line max-len */
    private changeCaseParaFormatTableInternal(table: TableWidget, selection: Selection, property: string, isRevert: boolean): void {
        for (let x: number = 0; x < table.childWidgets.length; x++) {
            let row: TableRowWidget = table.childWidgets[x] as TableRowWidget;
            for (let y: number = 0; y < row.childWidgets.length; y++) {
                this.changeCaseParaForCellInternal((row.childWidgets[y] as TableCellWidget), selection, property, isRevert);
            }
        }
    }
    // Row
    /* eslint-disable-next-line max-len */
    private changeCaseParaForRow(wRow: TableRowWidget, selection: Selection, start: TextPosition, end: TextPosition, property: string, isRevert: boolean): void {
        for (let i: number = wRow.rowIndex; i < wRow.ownerTable.childWidgets.length; i++) {
            let row: TableRowWidget = wRow.ownerTable.childWidgets[i] as TableRowWidget;
            for (let j: number = 0; j < row.childWidgets.length; j++) {
                this.changeCaseParaForCellInternal((row.childWidgets[j] as TableCellWidget), selection, property, isRevert);
            }
            if (end.paragraph.isInsideTable && this.documentHelper.selection.containsRow(row, end.paragraph.associatedCell)) {
                return;
            }
        }
        this.changeCaseNextBlock(wRow.ownerTable, start, end, property, isRevert);
    }
    /**
     * Toggles the all Caps formatting for the selected content.
     *
     * @returns {void}
     */
    public toggleAllCaps(): void {
        if (this.documentHelper.owner.isReadOnlyMode && !this.selection.isInlineFormFillMode()) {
            return;
        }
        let value: boolean = this.getCurrentSelectionValue('allCaps');
        this.selection.characterFormat.allCaps = value;
    }
    public toggleChangeCase(): string {
        var casings = ['Uppercase', 'Lowercase', 'CapitalizeEachWord'];
        this.casingIndex++;
        if (this.casingIndex >= casings.length) {
            this.casingIndex = 0;
        }
        return casings[this.casingIndex];
    }
    private getCurrentSelectionValue(property: string): boolean {
        let value: boolean = false;
        if ((property === 'bold' || property === 'italic')) {
            let characterFormat: WCharacterFormat = this.getSelectedCharacterFormat();
            if (property === 'bold') {
                value = !(characterFormat.bold);
            }
            if (property === 'italic') {
                value = !(characterFormat.italic);
            }
        }
        return value;
    }
    private getSelectedCharacterFormat(): WCharacterFormat {
        let index: number = 0;
        let start: TextPosition = this.selection.start;
        if (!this.selection.isForward) {
            start = this.selection.end;
        }
        let lineWidget: LineWidget = start.currentWidget;
        let inlineObj: ElementInfo = lineWidget.getInline(start.offset, index);
        let inline: ElementBox = inlineObj.element;
        // inline.ownerBase
        index = inlineObj.index;
        let characterFormat: WCharacterFormat = lineWidget.paragraph.characterFormat;
        if (!isNullOrUndefined(inline)) {
            if (this.selection.isEmpty && this.selection.contextType === 'List') {
                let listLevel: WListLevel = this.selection.getListLevel(this.selection.start.paragraph);
                if (listLevel.characterFormat.uniqueCharacterFormat) {
                    characterFormat = listLevel.characterFormat;
                }
            } else if (!this.selection.isEmpty && index === inline.length) {
                characterFormat = isNullOrUndefined(inline.nextNode) ? lineWidget.paragraph.characterFormat
                    : (inline.nextNode as ElementBox).characterFormat;
            } else {
                characterFormat = inline.characterFormat;
            }
        }
        return characterFormat;
    }
    /**
     * Toggles the underline property of selected contents.
     *
     * @param underline Specify the underline to be toggled (default: Single).
     * @returns {void}
     */
    public toggleUnderline(underline?: Underline): void {
        if ((this.owner.isReadOnlyMode || this.restrictFormatting) && !this.selection.isInlineFormFillMode()) {
            return;
        }
        this.updateProperty(1, underline);
    }
    /**
     * Toggles the strike through property of selected contents.
     *
     * @param {Strikethrough} strikethrough Specify the strike through to be toggled (default: SingleStrike).
     * @returns {void}
     */
    public toggleStrikethrough(strikethrough?: Strikethrough): void {
        if (!this.owner.isReadOnlyMode || this.selection.isInlineFormFillMode()) {
            let value: Strikethrough;
            if (isNullOrUndefined(strikethrough)) {
                value = this.selection.characterFormat.strikethrough === 'SingleStrike' ? 'None' : 'SingleStrike';
            } else {
                value = strikethrough;
            }
            this.selection.characterFormat.strikethrough = value as Strikethrough;
        }
    }
    private updateFontSize(format: WCharacterFormat, value: Object): Object {
        if (typeof (value) === 'number' && !(value < 0 && format.fontSize === 1)) {
            return format.fontSize + value;
        }
        let fontsizeCollection: number[] = [8, 9, 10, 11, 12, 14, 16, 18, 20, 24, 26, 28, 36, 48, 72];
        if (typeof (value) === 'string' && value === 'increment') {
            if (format.fontSize < 8) {
                return format.fontSize + 1;
            } else if (format.fontSize >= 72 && format.fontSize < 80) {
                return 80;
            } else if (format.fontSize >= 80) {
                return format.fontSize + 10;
            } else {
                for (let i: number = 0; i < fontsizeCollection.length; i++) {
                    if (format.fontSize < fontsizeCollection[i]) {
                        return fontsizeCollection[i];
                    }
                }
            }
        } else if (typeof (value) === 'string' && value === 'decrement' && format.fontSize > 1) {
            if (format.fontSize <= 8) {
                return format.fontSize - 1;
            } else if (format.fontSize > 72 && format.fontSize <= 80) {
                return 72;
            } else if (format.fontSize > 80) {
                return format.fontSize - 10;
            } else {
                for (let i: number = 0; i < fontsizeCollection.length; i++) {
                    if (format.fontSize <= fontsizeCollection[i]) {
                        return fontsizeCollection[i - 1];
                    }
                }
            }
        }
        return format.fontSize;
    }
    // Inline

    private applyCharFormatInline(inline: ElementBox, selection: Selection, startIndex: number, endIndex: number, property: string, value: Object, update: boolean): number {
        if (startIndex === 0 && endIndex === inline.length) {
            this.applyCharFormatValue(inline.characterFormat, property, value, update);
            return 0;
        } else if (inline instanceof TextElementBox) {
            return this.formatInline(inline, selection, startIndex, endIndex, property, value, update);
        }
        return 0;
    }

    private formatInline(inline: ElementBox, selection: Selection, startIndex: number, endIndex: number, property: string, value: Object, update: boolean): number {
        let x: number = 0;
        let node: ElementBox = inline;
        let index: number = inline.line.children.indexOf(node);
        let paragraph: ParagraphWidget = inline.paragraph;
        let textElement: TextElementBox;
        let indexCountForRevision: number = 0;
        if (startIndex > 0) {
            indexCountForRevision += 1;
            textElement = new TextElementBox();
            textElement.characterFormat.copyFormat(inline.characterFormat);
            if(!isNullOrUndefined(inline.contentControlProperties)){
                textElement.contentControlProperties = inline.contentControlProperties;
            }
            textElement.line = inline.line;
            textElement.text = (inline as TextElementBox).text.substr(startIndex, endIndex - startIndex);
            textElement.isRightToLeft = inline.isRightToLeft;
            this.applyCharFormatValue(textElement.characterFormat, property, value, update);
            index++;
            node.line.children.splice(index, 0, textElement);
            x++;
            this.updateRevisionForFormattedContent(inline, textElement, indexCountForRevision);
            // this.addToLinkedFields(span);                      
        }
        if (endIndex < node.length) {
            indexCountForRevision += 1;
            textElement = new TextElementBox();
            textElement.characterFormat.copyFormat(inline.characterFormat);
            if(!isNullOrUndefined(inline.contentControlProperties)){
                textElement.contentControlProperties = inline.contentControlProperties;
            }
            textElement.text = (node as TextElementBox).text.substring(endIndex);
            textElement.line = inline.line;
            textElement.isRightToLeft = inline.isRightToLeft;
            index++;
            node.line.children.splice(index, 0, textElement);
            x++;
            this.updateRevisionForFormattedContent(inline, textElement, indexCountForRevision);
            // this.addToLinkedFields(span);                       
        }
        if (startIndex === 0) {
            (inline as TextElementBox).text = (inline as TextElementBox).text.substr(0, endIndex);
            this.applyCharFormatValue(inline.characterFormat, property, value, update);
        } else {
            (inline as TextElementBox).text = (inline as TextElementBox).text.substr(0, startIndex);
        }
        return x;
    }
    private updateRevisionForFormattedContent(inline: ElementBox, tempSpan: ElementBox, indexCount: number): any {
        for (let i: number = 0; i < inline.revisionLength; i++) {
            let currentRevision: Revision = inline.getRevision(i);
            tempSpan.insertRevisionAt(0, currentRevision);
            this.owner.trackChangesPane.updateCurrentTrackChanges(currentRevision);
        }
    }
    // Cell

    private applyCharFormatCell(cell: TableCellWidget, selection: Selection, start: TextPosition, end: TextPosition, property: string, value: Object, update: boolean): BlockWidget {
        if (end.paragraph.isInsideTable) {
            let containerCell: TableCellWidget = selection.getContainerCellOf(cell, end.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(end.paragraph.associatedCell)) {
                let startCell: TableCellWidget = selection.getSelectedCell(cell, containerCell);
                let endCell: TableCellWidget = selection.getSelectedCell(end.paragraph.associatedCell, containerCell);
                if (selection.containsCell(containerCell, end.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (selection.isCellSelected(containerCell, start, end)) {
                        value = this.getCharacterFormatValueOfCell(cell, selection, value, property);
                        this.applyCharFormatForSelectedCell(containerCell, selection, property, value, update);
                        return undefined;
                    } else {
                        if (startCell === containerCell) {
                            return this.applyCharFormat(start.paragraph, selection, start, end, property, value, update);
                        } else {
                            return this.applyCharFormatRow(startCell.ownerRow, selection, start, end, property, value, update);
                        }
                    }
                } else {//Format other selected cells in current table.
                    this.applyCharFormatForTableCell(containerCell.ownerTable, selection, containerCell, endCell, property, value, update);
                    return undefined;
                }
            } else {
                return this.applyCharFormatRow(containerCell.ownerRow, selection, start, end, property, value, update);
            }
        } else {
            let tableCell: TableCellWidget = selection.getContainerCell(cell);
            return this.applyCharFormatRow(tableCell.ownerRow, selection, start, end, property, value, update);
        }
    }

    private applyCharFormatForSelectedCell(cell: TableCellWidget, selection: Selection, property: string, value: Object, update: boolean): void {
        for (let i: number = 0; i < cell.childWidgets.length; i++) {
            let block: BlockWidget = cell.childWidgets[i] as BlockWidget;
            if (block instanceof ParagraphWidget) {
                this.applyCharFormatForSelectedPara((block as ParagraphWidget), selection, property, value, update);
            } else {
                this.applyCharFormatForSelTable(block as TableWidget, selection, property, value, update);
            }
        }
    }
    // Row

    private applyCharFormatRow(row: TableRowWidget, selection: Selection, start: TextPosition, end: TextPosition, property: string, value: Object, update: boolean): BlockWidget {
        value = this.getCharacterFormatValueOfCell((row.childWidgets[0] as TableCellWidget), selection, value, property);
        return this.applyCharFormatForTable(row.rowIndex, row.ownerTable, selection, start, end, property, value, update);
    }
    // Table

    private applyCharFormatForTable(index: number, table: TableWidget, selection: Selection, start: TextPosition, end: TextPosition, property: string, value: Object, update: boolean): BlockWidget {
        table = table.combineWidget(this.owner.viewer) as TableWidget;
        for (let i: number = index; i < table.childWidgets.length; i++) {
            let row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
            for (let j: number = 0; j < row.childWidgets.length; j++) {
                this.applyCharFormatForSelectedCell((row.childWidgets[j] as TableCellWidget), selection, property, value, update);
            }
            if (end.paragraph.isInsideTable && selection.containsRow(row, end.paragraph.associatedCell)) {
                this.documentHelper.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
                return undefined;
            }
        }
        this.documentHelper.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        return this.getNextParagraphForCharacterFormatting(table, start, end, property, value, update);

    }

    private applyCharFormatForSelTable(tableWidget: TableWidget, selection: Selection, property: string, value: Object, update: boolean): void {
        for (let i: number = 0; i < tableWidget.childWidgets.length; i++) {
            let row: TableRowWidget = tableWidget.childWidgets[i] as TableRowWidget;
            for (let j: number = 0; j < row.childWidgets.length; j++) {
                this.applyCharFormatForSelectedCell((row.childWidgets[j] as TableCellWidget), selection, property, value, update);
            }
        }
    }

    private applyCharFormatForTableCell(table: TableWidget, selection: Selection, startCell: TableCellWidget, endCell: TableCellWidget, property: string, value: Object, update: boolean): void {
        let startCellLeft: number = selection.getCellLeft(startCell.ownerRow, startCell);
        let startCellRight: number = startCellLeft + startCell.cellFormat.cellWidth;
        let endCellLeft: number = selection.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight: number = endCellLeft + endCell.cellFormat.cellWidth;
        let cellInfo: CellInfo = this.updateSelectedCellsInTable(startCellLeft, startCellRight, endCellLeft, endCellRight);
        startCellLeft = cellInfo.start;
        startCellRight = cellInfo.end;
        let count: number = table.childWidgets.indexOf(endCell.ownerRow);
        let isStarted: boolean = false;
        for (let i: number = table.childWidgets.indexOf(startCell.ownerRow); i <= count; i++) {
            let row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
            for (let j: number = 0; j < row.childWidgets.length; j++) {
                let left: number = selection.getCellLeft(row, row.childWidgets[j] as TableCellWidget);
                if (HelperMethods.round(startCellLeft, 2) <= HelperMethods.round(left, 2) &&
                    HelperMethods.round(left, 2) < HelperMethods.round(startCellRight, 2)) {
                    if (!isStarted) {
                        value = this.getCharacterFormatValueOfCell((row.childWidgets[j] as TableCellWidget), selection, value, property);
                        isStarted = true;
                    }
                    this.applyCharFormatForSelectedCell((row.childWidgets[j] as TableCellWidget), selection, property, value, update);
                }
            }
        }
    }
    /**
     * private
     * @returns {CellInfo}
     */
    public updateSelectedCellsInTable(start: number, end: number, endCellLeft: number, endCellRight: number): CellInfo {
        let selection: Selection = this.documentHelper.selection;
        if (start > endCellLeft) {
            start = endCellLeft;
        }
        if (end < endCellRight) {
            end = endCellRight;
        }
        if (start > selection.upDownSelectionLength) {
            start = selection.upDownSelectionLength;
        }
        if (end < selection.upDownSelectionLength) {
            end = selection.upDownSelectionLength;
        }
        return { start: start, end: end };
    }
    private getCharacterFormatValueOfCell(cell: TableCellWidget, selection: Selection, value: Object, property: string): Object {
        if (typeof (value) === 'boolean' || (value === undefined && (property === 'bold' || property === 'italic'))) {
            let firstParagraph: ParagraphWidget = selection.getFirstParagraph(cell);
            let format: WCharacterFormat = firstParagraph.characterFormat;
            if (firstParagraph.childWidgets.length > 0 && (firstParagraph.childWidgets[0] as LineWidget).children.length > 0) {
                format = (firstParagraph.childWidgets[0] as LineWidget).children[0].characterFormat;
            }
            value = !format.getPropertyValue(property);
        }
        return value;
    }
    /**
     * Apply Character format for selection 
     *
     * @private
     * @returns {void}
     */
    public applyCharFormatValueInternal(selection: Selection, format: WCharacterFormat, property: string, value: Object): void {
        this.applyCharFormatValue(format, property, value, false);
    }
    private copyInlineCharacterFormat(sourceFormat: WCharacterFormat, destFormat: WCharacterFormat): void {
        destFormat.uniqueCharacterFormat = sourceFormat.uniqueCharacterFormat;
        destFormat.baseCharStyle = sourceFormat.baseCharStyle;
    }
    private applyCharFormatValue(format: WCharacterFormat, property: string, value: Object, update: boolean): void {
        if (update && property === 'fontSize') {
            value = this.updateFontSize(format, value);
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedProperties(format, property, value);
            this.editorHistory.currentBaseHistoryInfo.insertedFormat = value;
        }
        if (value instanceof WCharacterFormat) {
            if (this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
                this.copyInlineCharacterFormat(value, format);
                if (this.owner.enableCollaborativeEditing && format.ownerBase instanceof ElementBox) {
                    this.editorHistory.currentBaseHistoryInfo.buildCharacterFormatOperation(format.ownerBase as ElementBox, format);
                }
            } else {
                format.copyFormat(value);
            }
            return;
        }
        if (this.isForHyperlinkFormat && this.owner.enableTrackChanges && format.ownerBase instanceof ElementBox) {
            let currentElement: ElementBox = format.ownerBase as ElementBox;
            let prevElement: ElementBox = currentElement.previousNode;
            while (!isNullOrUndefined(prevElement) && !(prevElement instanceof TextElementBox)) {
                prevElement = prevElement.previousNode;
            }
            if (!isNullOrUndefined(prevElement) && prevElement.revisionLength > 0) {
                let currentRevision: Revision = prevElement.getRevision(prevElement.revisionLength - 1);
                if ((property !== "fontColor" || currentElement.revisionLength === 0) && !this.isRevisionAlreadyIn(currentElement, currentRevision)) {
                    currentElement.addRevision(currentRevision);
                    //currentRevision.range.push(currentElement);
                    this.owner.trackChangesPane.updateCurrentTrackChanges(currentRevision);
                }

            } else {
                let currentRevision: Revision = currentElement.getRevision(currentElement.revisionLength - 1);
                if ((property !== "fontColor" || currentElement.revisionLength === 0) && !isNullOrUndefined(currentRevision) && currentRevision.getRange().length > 0) {
                    currentElement.removeRevision(currentElement.revisionLength- 1);
                    //let rangeIndex: number = currentRevision.range.indexOf(currentElement);
                    //currentRevision.range.splice(rangeIndex, 1);
                    this.owner.trackChangesPane.updateCurrentTrackChanges(currentRevision);
                }
                if (property !== "fontColor" || currentElement.revisionLength === 0) {
                    this.insertRevision(currentElement, 'Insertion');
                }
            }
        }
        if (isNullOrUndefined(value) && isNullOrUndefined(property)) {
            format.clearFormat();
            if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                this.editorHistory.currentBaseHistoryInfo.insertedFormat = format[property];
            }
            return;
        }
        if (property === 'bold') {
            if (this.isRTLFormat(format)) {
                format.boldBidi = format.bold == format.boldBidi ? value as boolean : !value as boolean;
            }
            format.bold = value as boolean;
        } else if (property === 'italic') {
            if (this.isRTLFormat(format)) {
                format.italicBidi = format.italic == format.italicBidi ? value as boolean : !value as boolean;
            }
            format.italic = value as boolean;
        } else if (property === 'fontColor') {
            format.fontColor = value as string;
        } else if (property === 'fontFamily') {
            format.fontFamily = value as string;
            format.fontFamilyAscii = value as string;
            format.fontFamilyFarEast = value as string;
            format.fontFamilyNonFarEast = value as string;
            format.fontFamilyBidi = value as string;
        } else if (property === 'fontSize') {
            format.fontSize = value as number;
            if (this.isRTLFormat(format)) {
                format.fontSizeBidi = value as number;
            }
        } else if (property === 'highlightColor') {
            format.highlightColor = value as HighlightColor;
        } else if (property === 'baselineAlignment') {
            format.baselineAlignment = value as BaselineAlignment;
        } else if (property === 'strikethrough') {
            format.strikethrough = value as Strikethrough;
        } else if (property === 'underline') {
            format.underline = value as Underline;
        } else if (property === 'styleName') {
            format.baseCharStyle = value as WStyle;
        } else if (property === 'allCaps') {
            format.allCaps = value as boolean;
        }
        if (property === 'fontColor') {
            if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                this.editorHistory.currentBaseHistoryInfo.insertedFormat = format.fontColor;
            }
        }
    }
    private isRTLFormat(format: WCharacterFormat): boolean {
        return format.bidi || format.complexScript || (!isNullOrUndefined(format.ownerBase) &&
            format.ownerBase instanceof TextElementBox && this.documentHelper.textHelper.getRtlLanguage(format.ownerBase.text).isRtl);
    }
    /**
     * @private
     */
    public updateStyleObject(styleData: Object): void {
        let styles: WStyles = new WStyles();
        let keyIndex: number = this.owner.parser.keywordIndex;
        this.owner.parser.keywordIndex = 1;
        let isRemoteAction: boolean = this.owner.editor.isRemoteAction;
        this.owner.editor.isRemoteAction = true;
        this.owner.parser.parseStyles(styleData, styles);
        for (let i = 0; i < styles.length; i++) {
            let style: WStyle = styles.getItem(i) as WStyle;
            let styleInCollection: WStyle = this.owner.documentHelper.styles.findByName(style.name) as WStyle;
            if (!isNullOrUndefined(styleData[abstractListsProperty[1]])) {
                this.owner.parser.parseAbstractList(styleData, this.owner.documentHelper.abstractLists);
                if (!isNullOrUndefined(styleData[listsProperty[1]])) {
                    this.owner.parser.parseList(styleData, this.owner.documentHelper.lists);
                }
            }
            if (!isNullOrUndefined(styleInCollection)) {
                if (this.owner.editorHistoryModule && (this.owner.editorHistoryModule.isUndoing || this.owner.editorHistoryModule.isRedoing) && i === 0) {
                    if (this.owner.editorHistoryModule.currentBaseHistoryInfo && this.owner.editorHistoryModule.currentBaseHistoryInfo.action === 'ModifyStyle') {
                        let listId: number = styleInCollection instanceof WParagraphStyle ? (styleInCollection as WParagraphStyle).paragraphFormat.listFormat.listId : -1;
                        let styleObject = this.owner.getStyleObject(styleInCollection, listId);
                        if (!isNullOrUndefined(styleData['isNew'])) {
                            styleObject['isNew'] = styleData['isNew'];
                        }
                        this.owner.editorHistoryModule.currentBaseHistoryInfo.modifiedProperties.push(styleObject);
                    }
                }
                if (styleData['isNew'] && this.owner.editorHistoryModule.isUndoing) {
                    this.owner.documentHelper.styles.remove(styleInCollection as WParagraphStyle | WCharacterStyle);
                } else {
                    this.owner.updateStyle(styleInCollection, style);
                }
            } else {
                if (this.owner.editorHistory.isRedoing) {
                    let listId: number = style instanceof WParagraphStyle ? (style as WParagraphStyle).paragraphFormat.listFormat.listId : -1;
                    let styleObject = this.documentHelper.owner.getStyleObject(style, listId);
                    styleObject["isNew"] = true;
                    this.documentHelper.owner.editorHistoryModule.currentBaseHistoryInfo.modifiedProperties.push(styleObject);
                }
                this.owner.documentHelper.styles.push(style as WParagraphStyle | WCharacterStyle);
            }
        }
        this.owner.editor.isRemoteAction = isRemoteAction;
        if (styles.length > 0) {
            this.owner.isShiftingEnabled = true;
            this.documentHelper.layout.layoutWholeDocument();
            this.owner.isShiftingEnabled = false;
        }
        this.owner.parser.keywordIndex = keyIndex;
    }
    /**
     * @private
     * @returns {void}
     */
    public onImageFormat(elementBox: ImageElementBox, width: number, height: number,alternateText: string): void {
        let modifiedFormat: ImageSizeInfo = new ImageSizeInfo(elementBox);
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('ImageResizing');
            this.editorHistory.currentBaseHistoryInfo.modifiedProperties.push(modifiedFormat);
            this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Image;
            this.editorHistory.currentBaseHistoryInfo.insertedData = {width: HelperMethods.convertPixelToPoint(width), height: HelperMethods.convertPixelToPoint(height), alternativeText: alternateText};
        }
        this.setOffsetValue(this.selection);
        elementBox.width = width;
        elementBox.height = height;
        elementBox.alternateText = alternateText;

        this.documentHelper.layout.reLayoutParagraph(elementBox.line.paragraph, elementBox.line.indexInOwner, 0);
        this.reLayout(this.selection, false);
        if (this.documentHelper.owner.imageResizerModule && !this.isRemoteAction) {
            this.documentHelper.owner.imageResizerModule.positionImageResizer(elementBox);
        }
    }
    /**
     * Toggles the text alignment of selected paragraphs.
     *
     * @param {TextAlignment} textAlignment Specifies the text alignment.
     * @returns {void}
     */
    public toggleTextAlignment(textAlignment: TextAlignment): void {

        if ((this.documentHelper.owner.isReadOnlyMode && !this.selection.isInlineFormFillMode()) || !this.documentHelper.owner.isDocumentLoaded) {
            return;
        }
        // Toggle performed based on current selection format similar to MS word behavior.

        if (!isNullOrUndefined(this.documentHelper.selection.paragraphFormat.textAlignment) && this.documentHelper.selection.paragraphFormat.textAlignment === textAlignment) {
            if (textAlignment === 'Left') {
                this.onApplyParagraphFormat('textAlignment', 'Justify', false, true);
            } else {
                this.onApplyParagraphFormat('textAlignment', 'Left', false, true);
            }
        } else {
            this.onApplyParagraphFormat('textAlignment', textAlignment, false, true);
        }
    }
    /**
     * @private
     */
    public setPreviousBlockToLayout(): void {
        let startPosition: TextPosition = this.documentHelper.selection.start;
        if (!this.documentHelper.selection.isForward) {
            startPosition = this.documentHelper.selection.end;
        }
        let startParagraph: ParagraphWidget = startPosition.paragraph;
        if (startParagraph.paragraphFormat.keepWithNext) {
            let bodyWidget: BlockContainer = startParagraph.bodyWidget;
            if (!isNullOrUndefined(bodyWidget) && bodyWidget instanceof BodyWidget && bodyWidget.page) {
                let previousPage: Page = bodyWidget.page.previousPage;
                if (previousPage) {
                    this.previousBlockToLayout = previousPage.bodyWidgets[0].lastChild as BlockWidget;
                }
            }
        }
    }
    /**
     * Apply borders for selected paragraph borders
     * @private
     */
    public applyParagraphBorders(property: string, bordersType: string, value: Object): void {
        let borders: WBorder = new WBorder();
        switch (property) {
            case 'color':
                borders.color = value as string;
                break;
            case 'lineWidth':
                borders.lineWidth = value as number;
                break;
            case 'lineStyle':
                borders.lineStyle = value as LineStyle;
                break;
            case 'shadow':
                borders.shadow = value as boolean;
                break;
            case 'space':
                borders.space = value as number;
                break;
        }
        this.onApplyParagraphFormat(bordersType, borders, false, false);
    }
    /**
     * @private
     */
    public applyRulerMarkerValues(type: string, initialValue: number, finalValue: number): void {
        let differenceValue: number = HelperMethods.convertPixelToPoint(finalValue - initialValue) / this.owner.zoomFactor;
        if (type === 'firstLineIndent') {
            let currentValue: number =  this.owner.selectionModule.start.paragraph.paragraphFormat.firstLineIndent;
            this.onApplyParagraphFormat(type, currentValue + differenceValue, false, false);
        } else if (type === 'hangingIndent') {
            let currentValue: number = this.owner.selectionModule.start.paragraph.paragraphFormat.firstLineIndent;
            this.onApplyParagraphFormat('firstLineIndent', currentValue - differenceValue, false, false);
            let leftIndentCurrentValue: number = this.owner.selectionModule.start.paragraph.paragraphFormat.leftIndent + currentValue;
            currentValue = currentValue - differenceValue;
            this.onApplyParagraphFormat('leftIndent', leftIndentCurrentValue - currentValue, false, false, true);
        } else if (type === 'leftIndent') {
            let currentValue: number =  this.owner.selectionModule.start.paragraph.paragraphFormat.leftIndent;
            this.onApplyParagraphFormat(type, currentValue + differenceValue, false, false);
        } else if (type === 'rightIndent') {
            let currentValue: number = this.owner.selectionModule.start.paragraph.paragraphFormat.rightIndent;
            this.onApplyParagraphFormat(type, currentValue + differenceValue, false, false);
        }
    }
    /**
     * Applies paragraph format for the selection ranges.
     *
     * @param {string} property - Specifies the property
     * @param {Object} value - Specifies the value
     * @param {boolean} update - Specifies the update
     * @param {boolean} isSelectionChanged - Specifies the selection change.
     * @private
     * @returns {void}
     */
    public onApplyParagraphFormat(property: string, value: Object, update: boolean, isSelectionChanged: boolean, isSkipPositionCheck?: boolean): void {
        let allowFormatting: boolean = this.documentHelper.isFormFillProtectedMode
            && this.documentHelper.selection.isInlineFormFillMode() && this.allowFormattingInFormFields(property);
        if ((this.restrictFormatting && !allowFormatting) || (!isNullOrUndefined(this.selection) && this.selection.checkContentControlLocked(true))) {
            return;
        }
        this.setPreviousBlockToLayout();
        let action: Action = property === 'bidi' ? 'ParagraphBidi' : (property[0].toUpperCase() + property.slice(1)) as Action;
        this.documentHelper.owner.isShiftingEnabled = true;
        let selection: Selection = this.documentHelper.selection;
        let currentPara: ParagraphWidget = selection.start.paragraph;
        let isFirstParaForList: boolean = false;
        if (!selection.isForward) {
            currentPara = selection.end.paragraph;
        }
        if (property == 'leftIndent') {
            isFirstParaForList = this.isFirstParaForList(selection, currentPara);
        }
        // To stop the indentation when the paragraph x position is at the clientArea's x position
        if ((value as number) <= 0 && property == 'leftIndent' && !isSkipPositionCheck) {
            let x: number = HelperMethods.convertPointToPixel(value as number);
            if ((currentPara.x + x) < this.viewer.clientArea.x && !currentPara.paragraphFormat.bidi) {
                this.documentHelper.owner.isShiftingEnabled = false;
                return;
            }
        }
        this.initHistory(action);
        if ((this.owner.isReadOnlyMode && !allowFormatting) || !this.owner.isDocumentLoaded) {
            return;
        }
        if (property === 'leftIndent') {
            if (!isNullOrUndefined(selection.paragraphFormat.listId) && selection.paragraphFormat.listId !== -1 && update) {
                if (isFirstParaForList) {
                    this.updateListLevelIndent(value, currentPara);
                }
                else {
                    this.updateListLevel((value as number) > 0);
                }
                return;
            }
        }
        let isSkipSelection = !((value instanceof WCharacterStyle) && property == 'styleName' && selection.isEmpty);
        if (isSkipSelection && selection.isEmpty) {
            this.setOffsetValue(selection);
            let isBidiList: boolean = selection.paragraphFormat.bidi &&
                (property === 'listFormat' || selection.paragraphFormat.listId !== -1);
            if (!isBidiList) {
                this.documentHelper.layout.isBidiReLayout = true;
            }
            if (update && property === 'leftIndent') {
                value = this.getIndentIncrementValue(selection.start.paragraph, value as number);
            }
            let para: ParagraphWidget = selection.start.paragraph;
            let layout: Layout = this.documentHelper.layout;
            // let footNoteWidgetsInfo: FootNoteWidgetsInfo = layout.getFootNodeWidgetsToShiftToPage(para);
            para = para.combineWidget(this.owner.viewer) as ParagraphWidget;
            this.applyParaFormatProperty(para, property, value, update);
            this.isMeasureParaWidth = true;
            this.layoutItemBlock(para, false);
            this.isMeasureParaWidth = false;
            // if (footNoteWidgetsInfo.footNoteWidgets.length > 0) {
            //     layout.moveFootNotesToPage(footNoteWidgetsInfo.footNoteWidgets, footNoteWidgetsInfo.fromBodyWidget, footNoteWidgetsInfo.toBodyWidget);
            //     layout.layoutfootNote(footNoteWidgetsInfo.toBodyWidget.page.footnoteWidget);
            // }
        } else {
            //Iterate and update formatting's.      
            if (action !== 'ParagraphBidi') {
                this.setOffsetValue(selection);
            }
            this.updateSelectionParagraphFormatting(property, value, update);
        }
        this.reLayout(selection);
    }

    /**
     * Updates the indent value in the ListLevel
     * @param {Object} value - Specifies the value
     * @param {ParagraphWidget} currentPara - Specifies the selected paragraph
     * @private
     * @returns {void}
     */
    public updateListLevelIndent(value: Object, currentPara: ParagraphWidget): void {
        let list = this.documentHelper.getListById(currentPara.paragraphFormat.listFormat.listId);
        let abstractList: WAbstractList = this.documentHelper.getAbstractListById(list.abstractListId);
        let level: WListLevel;
        let property: string = undefined;
        if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            property = this.editorHistory.currentBaseHistoryInfo.action;
        }
        this.initHistory('List');
        if ((value as number) < 0) {
            if ((abstractList.levels[0].paragraphFormat.leftIndent + (value as number)) <= 0) {
                value = 18 - abstractList.levels[0].paragraphFormat.leftIndent;
            }
        }
        if (value == 0) {
            return;
        }
        for (let i: number = 0; i < abstractList.levels.length; i++) {
            if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                this.editorHistory.currentBaseHistoryInfo.addModifiedPropertiesForList(abstractList.levels[i]);
            }
            level = abstractList.levels[i];
            level.paragraphFormat.leftIndent += value as number;
        }
        if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && !isNullOrUndefined(property)) {
            this.editorHistory.currentBaseHistoryInfo.insertedFormat = { [property.toString().charAt(0).toLowerCase() + property.toString().slice(1)]: value, "isFirstParaForList": true };
        }
        //To Do, Implement relayouting logic for this listStyle applied paragraphs alone.
        //And shift remaining elements without layouting again.
        //It will improve the performance in large size documents.
        //The same can be reused in style modifications.
        this.documentHelper.owner.isShiftingEnabled = true;
        this.documentHelper.layout.layoutWholeDocument();
        this.documentHelper.owner.isShiftingEnabled = false;
    }
    /**
     * To check the current selection is first paragraph for list
     * @param {Selection} selection - Specifies the selection
     * @param {ParagraphWidget} currentPara - Specifies the current paragraph
     * @private
     * @returns {boolean}
     */
    public isFirstParaForList(selection: Selection, currentPara: ParagraphWidget): boolean {
        let isFirstParaForList: boolean = false;
        if (!isNullOrUndefined(selection.paragraphFormat.listId) && selection.paragraphFormat.listId !== -1 && currentPara.paragraphFormat.listFormat.listLevelNumber === 0) {
            //Getting the previous paragraph with same listId
            let previousParagraph: ParagraphWidget = this.updateWholeListItems(currentPara, true, selection.paragraphFormat.listId);
            if (isNullOrUndefined(previousParagraph)) {
                isFirstParaForList = true;
            }
        }
        return isFirstParaForList;
    }
    /**
     * Update the list level 
     *
     * @param {boolean} increaseLevel - Specifies the increase level
     * @private
     * @returns {void}
     */
    public updateListLevel(increaseLevel: boolean): void {
        // Increment or Decrement list level for Multilevel lists.
        let documentHelper: DocumentHelper = this.documentHelper;
        let listFormat: WListFormat = this.documentHelper.selection.start.paragraph.paragraphFormat.listFormat;
        let paragraphFormat: WParagraphFormat = undefined;
        if (!this.documentHelper.selection.isForward) {
            paragraphFormat = documentHelper.selection.end.paragraph.paragraphFormat;
        } else {
            paragraphFormat = documentHelper.selection.start.paragraph.paragraphFormat;
        }
        let list: WList = documentHelper.getListById(paragraphFormat.listFormat.listId);
        let listLevel: WListLevel = documentHelper.layout.getListLevel(list, paragraphFormat.listFormat.listLevelNumber);
        const paraListLevelNumber: number = paragraphFormat.listFormat.listLevelNumber;
        let levelNumber: number;
        if (increaseLevel) {
            levelNumber = paraListLevelNumber === 8 ? paraListLevelNumber : paraListLevelNumber + 1;
        }
        else {
            levelNumber = paraListLevelNumber === 0 ? paraListLevelNumber : paraListLevelNumber - 1;
        }
        let nextListLevel: WListLevel = documentHelper.layout.getListLevel(list, levelNumber);
        if (!isNullOrUndefined(nextListLevel)) {
            this.onApplyListInternal(list, levelNumber);
            documentHelper.selection.start.updatePhysicalPosition(true);
            documentHelper.selection.end.updatePhysicalPosition(true);
            documentHelper.selection.updateCaretPosition();
        }
    }
    /**
     * Applies list
     *
     * @param {WList} list - Specified the list
     * @param {number} listLevelNumber - Specified the list level number
     * @private
     * @returns {void}
     */
    public onApplyListInternal(list: WList, listLevelNumber: number): void {
        //let selection: Selection = this.documentHelper.selection;
        let listFormat: WListFormat = new WListFormat();
        if (!isNullOrUndefined(list) && listLevelNumber >= 0 && listLevelNumber < 9) {
            listFormat.listId = list.listId;
            listFormat.listLevelNumber = listLevelNumber;
        }
        this.onApplyParagraphFormat('listFormat', listFormat, false, false);
    }
    /**
     * Apply paragraph format to selection range
     *
     * @param {string} property - Specifies the property
     * @param {Object} value - Specifies the value
     * @param {boolean} update - Specifies the update
     * @private
     * @returns {void}
     */
    public updateSelectionParagraphFormatting(property: string, value: Object, update: boolean): void {
        let selection: Selection = this.documentHelper.selection;
        if (property === 'leftIndent' && update) {
            if (!isNullOrUndefined(selection.start) && selection.start.isExistBefore(selection.end)) {
                value = this.getIndentIncrementValue(selection.start.paragraph, value as number);
            } else {
                value = this.getIndentIncrementValue(selection.end.paragraph, value as number);
            }
        }
        this.updateParagraphFormatInternal(property, value, update);
    }
    private getIndentIncrementValue(currentParagraph: ParagraphWidget, incrementFactor: number): number {
        let currentParagraphIndent: number = currentParagraph.paragraphFormat.leftIndent as number;
        if (currentParagraphIndent < 0) {
            // In MS Word, if the current paragraph left indent is lesser that or equal to 0
            // then performing decrement indent will set left indent to 0. 
            if (incrementFactor < 0 || currentParagraphIndent + incrementFactor >= 0) {
                return -currentParagraphIndent;
            } else {
                let incrementValue: number = -this.getIndentIncrementValueInternal(-currentParagraphIndent, -incrementFactor);
                return incrementValue % incrementFactor === 0 ? incrementValue : incrementValue + incrementFactor;
            }
        } else {
            return this.getIndentIncrementValueInternal(currentParagraphIndent, incrementFactor);
        }
    }
    private getIndentIncrementValueInternal(position: number, incrementFactor: number): number {
        let tabValue: number = Math.abs(incrementFactor);
        if (position === 0 || tabValue === 0) {
            return incrementFactor > 0 ? tabValue : 0;
        } else {
            let diff: number = ((Math.round(position) * 100) % (Math.round(tabValue) * 100)) / 100;
            let cnt: number = (Math.round(position) - diff) / Math.round(tabValue);
            let fPosition: number = cnt * tabValue;
            if (incrementFactor > 0) {
                fPosition += tabValue;
            }
            return (fPosition - position) === 0 ? incrementFactor : fPosition - position;
        }
    }
    private updateParagraphFormatInternal(property: string, value: Object, update: boolean): void {
        if (isNullOrUndefined(property)) {
            property = 'ParagraphFormat';
        }
        switch (property) {
            case 'afterSpacing':
                this.updateParagraphFormat('afterSpacing', value, false);
                break;
            case 'beforeSpacing':
                this.updateParagraphFormat('beforeSpacing', value, false);
                break;
            case 'spaceAfterAuto':
                this.updateParagraphFormat('spaceAfterAuto', value, false);
                break;
            case 'spaceBeforeAuto':
                this.updateParagraphFormat('spaceBeforeAuto', value, false);
                break;
            case 'rightIndent':
                this.updateParagraphFormat('rightIndent', value, false);
                break;
            case 'leftIndent':
                this.updateParagraphFormat('leftIndent', value, update);
                break;
            case 'firstLineIndent':
                this.updateParagraphFormat('firstLineIndent', value, false);
                break;
            case 'lineSpacing':
                this.updateParagraphFormat('lineSpacing', value, false);
                break;
            case 'lineSpacingType':
                this.updateParagraphFormat('lineSpacingType', value, false);
                break;
            case 'textAlignment':
                this.updateParagraphFormat('textAlignment', value, false);
                break;
            case 'borders':
            case 'topBorder':
            case 'bottomBorder':
            case 'leftBorder':
            case 'rightBorder':
            case 'horizontalBorder':
            case 'verticalBorder':
                this.updateParagraphFormat(property, value, false);
                break;
            case 'listFormat':
                this.updateParagraphFormat('listFormat', value, false);
                break;
            case 'ParagraphFormat':
                this.updateParagraphFormat(undefined, value, false);
                break;
            case 'styleName':
                this.updateParagraphFormat('styleName', value, false);
                break;
            case 'ClearParagraphFormat':
                // this.initializeHistory('ClearParagraphFormat', selectionRange);
                this.updateParagraphFormat(undefined, value, false);
                break;
            case 'bidi':
                let isBidiList: boolean = this.selection.paragraphFormat.listId !== -1;
                if (!isBidiList) {
                    this.documentHelper.layout.isBidiReLayout = true;
                }
                this.updateParagraphFormat('bidi', value, false);
                if (!isBidiList) {
                    this.documentHelper.layout.isBidiReLayout = false;
                }
                break;
            case 'contextualSpacing':
                this.updateParagraphFormat('contextualSpacing', value, false);
                break;
            case 'tabStop':
                this.updateParagraphFormat('tabStop', value, false);
                break;
        }
    }
    /**
     * Update paragraph format on undo
     *
     * @param {string} property - Specifies the property
     * @param {Object} value - Specifies the value
     * @param {boolean} update - Specifies the update
     * @private
     * @returns {void}
     */
    public updateParagraphFormat(property: string, value: Object, update: boolean): void {
        let selection: Selection = this.documentHelper.selection;
        let startPosition: TextPosition = selection.start;
        let endPosition: TextPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        // this.updateInsertPosition(selection, startPosition);
        this.applyParaFormatSelectedContent(startPosition, endPosition, property, value, update);
        // this.startSelectionReLayouting(startPosition.paragraph, selection, startPosition, endPosition);
    }
    private applyParaFormatSelectedContent(start: TextPosition, end: TextPosition, property: string, value: Object, update: boolean): void {
        let selection: Selection = this.documentHelper.selection;
        if (start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
            || start.paragraph.associatedCell !== end.paragraph.associatedCell
            || selection.isCellSelected(start.paragraph.associatedCell, start, end))) {
            let cell: TableCellWidget;
            start.paragraph.associatedCell.ownerTable.combineWidget(this.owner.viewer);
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(start, true);
            }
            cell = start.paragraph.associatedCell;
            this.applyParaFormatInCell(cell, start, end, property, value, update);
            let table: TableWidget = cell.ownerTable;
            this.documentHelper.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        } else {

            if (!isNullOrUndefined(value) && !this.selection.isEmpty && property === 'styleName' && this.applyCharacterStyle(start.paragraph, start, end, property, (value as WStyle), update)) {
                return;
            } else {
                this.applyParaFormat(start.paragraph, start, end, property, value, update);
            }
        }
    }

    /**
     * Apply Paragraph format
     *
     * @param {ParagraphWidget} paragraph - Specifies the selection
     * @param {string} property - Specifies the property
     * @param {Object} value - Specifies the value
     * @param {boolean} update - Specifies the update
     * @private
     * @returns {void}
     */
    public applyParaFormatProperty(paragraph: ParagraphWidget, property: string, value: Object, update: boolean): void {
        let format: WParagraphFormat = paragraph.paragraphFormat;
        if (update && property === 'leftIndent') {
            value = format.leftIndent + (value as number);
        }
        if (property === 'listFormat' && value instanceof WListFormat) {
            let listFormat: WListFormat = <WListFormat>value;
            if (!listFormat.hasValue('listLevelNumber')) {
                if (this.isAutoList) {
                    listFormat.listLevelNumber = this.listLevelNumber;
                    // reset the list level number to 0.
                    this.listLevelNumber = 0;
                    this.isAutoList = false;
                } else {
                    listFormat.listLevelNumber = format.listFormat.listLevelNumber;
                }
            }
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedPropertiesForParagraphFormat(format, property, value);
            this.editorHistory.currentBaseHistoryInfo.insertedFormat = value;
        }
        if (value instanceof WParagraphFormat) {
            if (isNullOrUndefined(property)) {
                if (this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
                    this.copyParagraphFormat(value as WParagraphFormat, format);
                } else if (this.isRemoteAction) {
                    this.copyParagraphFormat(value as WParagraphFormat, format);
                } else {
                    format.copyFormat(value as WParagraphFormat);
                }
            } else if (property === 'listFormat') {
                format.listFormat = value.listFormat;
                format.listFormat.ownerBase = format;
                format.copyFormat(value as WParagraphFormat);
                // this.handleListFormat(format, value as WParagraphFormat);
            }
            if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                if(this.owner.enableCollaborativeEditing && this.editorHistory.isUndoing) {
                    this.editorHistory.currentBaseHistoryInfo.getParagraohFormatOperation(paragraph, format);
                }
            }
        }
        if (isNullOrUndefined(value)) {
            format.clearFormat();
            this.documentHelper.layout.reLayoutParagraph(format.ownerBase as ParagraphWidget, 0, 0);
            return;
        }

        if (property === 'afterSpacing') {
            format.afterSpacing = value as number;
        } else if (property === 'beforeSpacing') {
            format.beforeSpacing = value as number;
        } else if (property === 'leftIndent') {
            format.leftIndent = value as number;
        } else if (property === 'lineSpacingType') {
            format.lineSpacingType = <LineSpacingType>value;
        } else if (property === 'lineSpacing') {
            format.lineSpacing = value as number;
        } else if (property === 'rightIndent') {
            format.rightIndent = value as number;
        } else if (property === 'firstLineIndent') {
            format.firstLineIndent = value as number;
        } else if (property === 'textAlignment') {
            let textAlignment: TextAlignment = <TextAlignment>value;
            if (format.bidi && !(this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
                if (textAlignment === 'Left') {
                    textAlignment = 'Right';
                } else if (textAlignment === 'Right') {
                    textAlignment = 'Left';
                }
            }
            format.textAlignment = textAlignment;
            //this.documentHelper.layout.allowLayout = false;
        } else if (property === 'outlineLevel') {
            format.outlineLevel = <OutlineLevel>value;
        } else if (property === 'topBorder') {
            this.applyBorder(format.borders.top, <WBorder>value);
        } else if (property === 'bottomBorder') {
            this.applyBorder(format.borders.bottom, <WBorder>value);
        } else if (property === 'leftBorder') {
            this.applyBorder(format.borders.left, <WBorder>value);
        } else if (property === 'rightBorder') {
            this.applyBorder(format.borders.right, <WBorder>value);
        } else if (property === 'horizontalBorder') {
            this.applyBorder(format.borders.horizontal, <WBorder>value);
        } else if (property === 'verticalBorder') {
            this.applyBorder(format.borders.vertical, <WBorder>value);
        } else if (property === 'borders') {
            format.borders.copyFormat(<WBorders>value);
        } else if (property === 'styleName') {
            if (typeof (value) === 'string') {
                value = this.documentHelper.styles.findByName(value);
            }
            format.applyStyle(value as WStyle);
        } else if (property === 'listFormat') {
            if (value instanceof WParagraphFormat) {
                value = value.listFormat;
            }
            format.listFormat.copyFormat(<WListFormat>value);
            this.documentHelper.layout.clearListElementBox(format.ownerBase as ParagraphWidget);
            if (format.listFormat.listId >= 0) {
                format.clearIndent();
            }
            this.layoutItemBlock(format.ownerBase as ParagraphWidget, false);
            return;
        } else if (property === 'bidi') {
            format.bidi = value as boolean;
        } else if (property === 'keepWithNext') {
            format.keepWithNext = value as boolean;
        } else if (property === 'keepLinesTogether') {
            format.keepLinesTogether = value as boolean;
        } else if (property === 'widowControl') {
            format.widowControl = value as boolean;
        } else if (property === 'contextualSpacing') {
            format.contextualSpacing = value as boolean;
        } else if (property === 'spaceAfterAuto') {
            format.spaceAfterAuto = value as boolean;
        } else if (property === 'spaceBeforeAuto') {
            format.spaceBeforeAuto = value as boolean;
        } else if (property === 'tabStop') {
            let isReplace: boolean = this.editorHistory.isUndoing || this.editorHistory.isRedoing;
            this.updateTabStopCollection(paragraph, value as WTabStop[], isReplace);
        }
    }
    private copyParagraphFormat(sourceFormat: WParagraphFormat, destFormat: WParagraphFormat): void {
        destFormat.uniqueParagraphFormat = sourceFormat.uniqueParagraphFormat;
        destFormat.listFormat = sourceFormat.listFormat;
        destFormat.listFormat.ownerBase = destFormat;
        destFormat.baseStyle = sourceFormat.baseStyle;
        //destFormat.borders = sourceFormat.borders;
    }
    /**
     * Copies list level paragraph format
     *
     * @param {WParagraphFormat} oldFormat - Specifies the old format
     * @param {WParagraphFormat} newFormat - Specifies the new format
     * @private
     * @returns {void}
     */
    public copyFromListLevelParagraphFormat(oldFormat: WParagraphFormat, newFormat: WParagraphFormat): void {
        if (!isNullOrUndefined(newFormat.leftIndent)) {
            oldFormat.leftIndent = newFormat.leftIndent;
        }
        if (!isNullOrUndefined(newFormat.firstLineIndent)) {
            oldFormat.firstLineIndent = newFormat.firstLineIndent;
        }
    }
    /**
     * Applies the continue numbering from the previous list.
     *
     * @returns {void}
     */
    public applyContinueNumbering(): void {
        let selection: Selection = this.selection;
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('ContinueNumbering');
        }
        this.applyContinueNumberingInternal(selection);
    }
    /**
     * Continues the numbering sequence of the current list from the selected paragraph.
     *
     * @returns {void}
     */
    public continueNumbering(): void {
        let selection: Selection = this.selection;
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('ContinueNumbering');
        }
        if(!isNullOrUndefined(selection)) {
            this.applyContinueNumberingInternal(selection);
        }
    }
    /**
     * @private
     * @param selection 
     * @param paraFormat 
     */
    public applyContinueNumberingInternal(selection: Selection, paraFormat?: WParagraphFormat): void {
        let paragraph: ParagraphWidget = selection.start.paragraph;
        let numberingInfo: ContinueNumberingInfo = this.getContinueNumberingInfo(paragraph);
        if (isNullOrUndefined(paraFormat)) {
            paraFormat = this.getParagraphFormat(paragraph, numberingInfo.listLevelNumber, numberingInfo.listPattern);
        }
        paraFormat = !isNullOrUndefined(paraFormat) ? paraFormat : paragraph.paragraphFormat;
        if (!isNullOrUndefined(numberingInfo.currentList)) {
            this.changeListId(numberingInfo.currentList, paragraph, paraFormat, numberingInfo.listLevelNumber, numberingInfo.listPattern);
            this.reLayout(selection, false);
            if (this.owner.enableAutoFocus) {
                this.documentHelper.updateFocus();
            }
        }
    }
    private getContinueNumberingInfo(paragraph: ParagraphWidget): ContinueNumberingInfo {
        let currentList: WList = undefined;
        let listLevelNumber: number = 0;
        let listPattern: ListLevelPattern = 'None';
        if (!isNullOrUndefined(paragraph.paragraphFormat)
            && !isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
            currentList = this.documentHelper.getListById(paragraph.paragraphFormat.listFormat.listId);
            listLevelNumber = paragraph.paragraphFormat.listFormat.listLevelNumber;
        }
        let documentHelper: DocumentHelper = this.documentHelper;
        if (listLevelNumber !== 0 && !isNullOrUndefined(currentList) &&
            !isNullOrUndefined(documentHelper.getAbstractListById(currentList.abstractListId))
            && !isNullOrUndefined(documentHelper.getAbstractListById(currentList.abstractListId).levels[listLevelNumber])) {
            let listLevel: WListLevel = this.documentHelper.layout.getListLevel(currentList, listLevelNumber);
            if (!isNullOrUndefined(listLevel)) {
                listPattern = listLevel.listLevelPattern;
            }
        }
        return {
            currentList: currentList,
            listLevelNumber: listLevelNumber,
            listPattern: listPattern
        };
    }
    /**
     * @private
     * @returns {void}
     */
    public revertContinueNumbering(selection: Selection, format: WParagraphFormat): void {
        let paragraph: ParagraphWidget = selection.start.paragraph;
        let numberingInfo: ContinueNumberingInfo = this.getContinueNumberingInfo(paragraph);
        this.changeListId(numberingInfo.currentList, paragraph, format, numberingInfo.listLevelNumber, numberingInfo.listPattern);
        this.reLayout(selection, false);
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.editorHistory.updateHistory();
        }
    }
    private changeListId(list: WList, block: BlockWidget, format: WParagraphFormat, levelNum: number, listType: string): void {
        if (isNullOrUndefined(block)) {
            return;
        }
        if (block instanceof ParagraphWidget) {
            if (list.listId === block.paragraphFormat.listFormat.listId) {
                if (this.editorHistory) {
                    let baseHistoryInfo: BaseHistoryInfo = this.editorHistory.currentBaseHistoryInfo;
                    if (!isNullOrUndefined(baseHistoryInfo)) {
                        format = <WParagraphFormat>baseHistoryInfo.addModifiedPropertiesForContinueNumbering(block.paragraphFormat, format);
                        baseHistoryInfo.insertedFormat = format;
                    }
                }
                if (levelNum === block.paragraphFormat.listFormat.listLevelNumber) {
                    block.paragraphFormat.copyFormat(format);
                } else {
                    block.paragraphFormat.listFormat.listId = format.listFormat.listId;
                }
                this.documentHelper.layout.reLayoutParagraph(block, 0, 0);
            }
        }
        return this.changeListId(list, block.nextRenderedWidget as BlockWidget, format, levelNum, listType);
    }
    private getParagraphFormat(paragraph: ParagraphWidget, levelNumber: number, listType: string): WParagraphFormat {
        if (!isNullOrUndefined(paragraph.previousRenderedWidget)) {
            if (paragraph.previousRenderedWidget instanceof ParagraphWidget) {
                if (!isNullOrUndefined(paragraph.previousRenderedWidget.paragraphFormat.listFormat)
                    && paragraph.previousRenderedWidget.paragraphFormat.listFormat.listId !== -1) {
                    // let listLevel: WListLevel = this.selection.getListLevel(paragraph.previousRenderedWidget);
                    if (levelNumber === paragraph.previousRenderedWidget.paragraphFormat.listFormat.listLevelNumber) {
                        return paragraph.previousRenderedWidget.paragraphFormat;
                    }
                    else {
                        return this.getParagraphFormat(paragraph.previousRenderedWidget, levelNumber, listType);
                    }
                } else {
                    return this.getParagraphFormat(paragraph.previousRenderedWidget, levelNumber, listType);
                }
            }
        }
        return undefined;
    }
    private checkNumberArabic(listType: string, levelPattern: ListLevelPattern): boolean {
        if ((listType === 'Number' && levelPattern === 'Arabic')
            || (levelPattern === 'Number' && listType === 'Arabic')) {
            return true;
        }
        return false;
    }
    /**
     * Restarts the numbering of the current list from the selected paragraph.
     */
    public restartNumbering(): void {
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('RestartNumbering');
        }
        let selection: Selection = this.documentHelper.selection;
        if (!isNullOrUndefined(selection)) {
            this.restartListAt(selection);
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public applyRestartNumbering(selection: Selection): void {
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('RestartNumbering');
        }
        this.restartListAt(selection);
    }
    /**
     * @private
     * @returns {void}
     */
    public restartListAt(selection: Selection): void {
        if (selection.paragraphFormat.getList()) {
            let currentList: WList = selection.paragraphFormat.getList();
            let list: WList = currentList.clone();
            list.listId = this.documentHelper.lists[(this.documentHelper.lists.length - 1)].listId + 1;
            //let nsid: number = HelperMethods.generateUniqueId(this.documentHelper.lists);
            this.documentHelper.lists.push(list);
            let abstractList: WAbstractList = currentList.abstractList.clone();
            abstractList.abstractListId = this.documentHelper.abstractLists[(this.documentHelper.abstractLists.length - 1)].abstractListId + 1;
            list.abstractListId = abstractList.abstractListId;
            list.nsid = abstractList.nsid;
            list.abstractList = abstractList;
            this.documentHelper.abstractLists.push(abstractList);
            this.restartListAtInternal(selection, list.listId, list.nsid);
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public restartListAtInternal(selection: Selection, listId: number, nsid?: number): void {
        let numberingInfo: ContinueNumberingInfo = this.getContinueNumberingInfo(selection.start.paragraph);
        this.changeRestartNumbering(numberingInfo.currentList, selection.start.paragraph, listId, nsid);
        this.reLayout(selection, false);
        this.documentHelper.updateFocus();
    }
    private changeRestartNumbering(list: WList, block: BlockWidget, listId: number, nsid: number): void {
        if (isNullOrUndefined(block)) {
            return;
        }
        if (block instanceof ParagraphWidget) {
            if (list.listId === block.paragraphFormat.listFormat.listId) {
                if (this.editorHistory) {
                    let baseHistoryInfo: BaseHistoryInfo = this.editorHistory.currentBaseHistoryInfo;
                    if (!isNullOrUndefined(baseHistoryInfo)) {
                        listId = <number>baseHistoryInfo.addModifiedPropertiesForRestartNumbering(block.paragraphFormat.listFormat, listId);
                        baseHistoryInfo.insertedFormat = {
                            listId: listId,
                            nsid: nsid
                        };
                    }
                }
                block.paragraphFormat.listFormat.listId = listId;
                this.documentHelper.layout.reLayoutParagraph(block, 0, 0);
            }
        }
        return this.changeRestartNumbering(list, block.nextRenderedWidget as BlockWidget, listId, nsid);
    }


    private applyParaFormat(paragraph: ParagraphWidget, start: TextPosition, end: TextPosition, property: string, value: Object, update: boolean): void {
        this.setOffsetValue(this.selection);
        paragraph = paragraph.combineWidget(this.owner.viewer) as ParagraphWidget;
        //Apply Paragraph Format for spitted paragraph
        this.applyParaFormatProperty(paragraph, property, value, update);
        this.isMeasureParaWidth = true;
        this.layoutItemBlock(paragraph, false);
        this.isMeasureParaWidth = false;
        this.getOffsetValue(this.selection);
        if (paragraph.equals(end.paragraph)) {
            return;
        }
        this.getNextParagraphForFormatting(paragraph, start, end, property, value, update);
    }
    private applyCharacterStyle(paragraph: ParagraphWidget, start: TextPosition, end: TextPosition, property: string, value: WStyle, update: boolean): boolean {
        let paragraphWidget: BlockWidget[] = paragraph.getSplitWidgets() as BlockWidget[];
        let selection: Selection = end.owner.selectionModule;
        let lastLine: LineWidget = end.currentWidget;
        let isParaSelected: boolean = start.offset === 0 && (selection.isParagraphLastLine(lastLine) && end.currentWidget === lastLine
            && end.offset === selection.getLineLength(lastLine) + 1 || end.isAtParagraphEnd);
        if (!isParaSelected && (end.paragraph === paragraph || paragraphWidget.indexOf(end.paragraph) !== -1)) {
            if (((value.type === 'Paragraph') && ((value.link) instanceof WCharacterStyle)) || (value.type === 'Character')) {
                let obj: WStyle = (value.type === 'Character') ? value : value.link;
                this.updateSelectionCharacterFormatting(property, obj, update);
                return true;
            }
        }
        return false;
    }
    // Cell

    private applyParaFormatInCell(cell: TableCellWidget, start: TextPosition, end: TextPosition, property: string, value: Object, update: boolean): void {
        let selection: Selection = this.documentHelper.selection;
        if (end.paragraph.isInsideTable) {
            let cellContainer: TableCellWidget = selection.getContainerCellOf(cell, end.paragraph.associatedCell);
            if (cellContainer.ownerTable.contains(end.paragraph.associatedCell)) {
                let startCell: TableCellWidget = selection.getSelectedCell(cell, cellContainer);
                let endCell: TableCellWidget = selection.getSelectedCell(end.paragraph.associatedCell, cellContainer);
                if (selection.containsCell(cellContainer, end.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (selection.isCellSelected(cellContainer, start, end)) {
                        value = this.getParaFormatValueInCell(cellContainer, property, value);
                        this.applyParaFormatCellInternal(cellContainer, property, value, update);
                    } else {
                        if (startCell === cellContainer) {
                            this.applyParaFormat(start.paragraph, start, end, property, value, update);
                        } else {
                            this.applyParagraphFormatRow(startCell.ownerRow, start, end, property, value, update);
                        }
                    }
                } else {
                    //Format other selected cells in current table.
                    this.applyParaFormatTableCell(cellContainer.ownerTable, cellContainer, endCell, property, value, update);
                }
            } else {
                this.applyParagraphFormatRow(cellContainer.ownerRow, start, end, property, value, update);
            }
        } else {
            let wCell: TableCellWidget = selection.getContainerCell(cell);
            this.applyParagraphFormatRow(wCell.ownerRow, start, end, property, value, update);
        }
    }
    private applyParaFormatCellInternal(cell: TableCellWidget, property: string, value: Object, update: boolean, isNext?: boolean): void {

        for (let i: number = 0; i < cell.childWidgets.length; i++) {
            let block: BlockWidget = cell.childWidgets[i] as BlockWidget;
            if (block instanceof ParagraphWidget) {
                if (property === 'listFormat' && value instanceof WListFormat && isNext && block.paragraphFormat.listFormat.hasValue("listLevelNumber") && value["listLevelNumber"] < block.paragraphFormat.listFormat.listLevelNumber) {
                    value["listLevelNumber"] = block.paragraphFormat.listFormat.listLevelNumber;
                }
                this.isMeasureParaWidth = true;
                this.applyParaFormatProperty((block as ParagraphWidget), property, value, update);
                this.isMeasureParaWidth = false;
            } else {
                this.applyParagraphFormatTableInternal(block as TableWidget, property, value, update, isNext);
            }
        }
    }
    private getParaFormatValueInCell(cell: TableCellWidget, property: string, value: Object): Object {
        if (typeof value === 'boolean') {
            let firstPara: ParagraphWidget = this.documentHelper.selection.getFirstParagraph(cell);
            value = !<boolean>firstPara.paragraphFormat.getPropertyValue(property);
        }
        return value;
    }
    // Row

    private applyParagraphFormatRow(wRow: TableRowWidget, start: TextPosition, end: TextPosition, property: string, value: Object, update: boolean): void {
        value = this.getParaFormatValueInCell((wRow.childWidgets[0] as TableCellWidget), property, value);
        for (let i: number = wRow.rowIndex; i < wRow.ownerTable.childWidgets.length; i++) {
            let row: TableRowWidget = wRow.ownerTable.childWidgets[i] as TableRowWidget;
            for (let j: number = 0; j < row.childWidgets.length; j++) {
                this.applyParaFormatCellInternal((row.childWidgets[j] as TableCellWidget), property, value, update);
            }
            if (end.paragraph.isInsideTable && this.documentHelper.selection.containsRow(row, end.paragraph.associatedCell)) {
                return;
            }
        }
        this.getNextParagraphForFormatting(wRow.ownerTable, start, end, property, value, update);
    }
    // Table

    private applyParaFormatTableCell(table: TableWidget, startCell: TableCellWidget, endCell: TableCellWidget, property: string, value: Object, update: boolean): void {
        let selection: Selection = this.documentHelper.selection;
        let startValue: number = selection.getCellLeft(startCell.ownerRow, startCell);
        let endValue: number = startValue + startCell.cellFormat.cellWidth;
        let endCellLeft: number = selection.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight: number = endCellLeft + endCell.cellFormat.cellWidth;
        let cellInfo: CellInfo = this.updateSelectedCellsInTable(startValue, endValue, endCellLeft, endCellRight);
        startValue = cellInfo.start;
        endValue = cellInfo.end;
        let count: number = table.childWidgets.indexOf(endCell.ownerRow);
        let isStarted: boolean = false;
        for (let m: number = table.childWidgets.indexOf(startCell.ownerRow); m <= count; m++) {
            let row: TableRowWidget = table.childWidgets[m] as TableRowWidget;
            for (let j: number = 0; j < row.childWidgets.length; j++) {
                let left: number = selection.getCellLeft(row, row.childWidgets[j] as TableCellWidget);
                if (Math.round(startValue) <= Math.round(left) && Math.round(left) < Math.round(endValue)) {
                    if (!isStarted) {
                        value = this.getParaFormatValueInCell((row.childWidgets[j] as TableCellWidget), property, value);
                        isStarted = true;
                    }
                    this.applyParaFormatCellInternal((row.childWidgets[j] as TableCellWidget), property, value, update);
                }
            }
        }
    }

    private applyParaFormatTable(table: TableWidget, start: TextPosition, end: TextPosition, property: string, value: Object, update: boolean, isNext?: boolean): void {
        table = table.combineWidget(this.owner.viewer) as TableWidget;
        let selection: Selection = this.documentHelper.selection;
        for (let m: number = 0; m < table.childWidgets.length; m++) {
            let tableRow: TableRowWidget = table.childWidgets[m] as TableRowWidget;
            for (let k: number = 0; k < tableRow.childWidgets.length; k++) {
                this.applyParaFormatCellInternal((tableRow.childWidgets[k] as TableCellWidget), property, value, update, isNext);
            }
            if (end.paragraph.isInsideTable && selection.containsRow(tableRow, end.paragraph.associatedCell)) {
                this.documentHelper.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
                return;
            }
        }
        this.documentHelper.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        this.getNextParagraphForFormatting(table, start, end, property, value, update);
    }

    private getNextParagraphForFormatting(block: BlockWidget, start: TextPosition, end: TextPosition, property: string, value: Object, update: boolean): void {
        let widgetCollection: TableWidget[] = block.getSplitWidgets() as TableWidget[];
        block = widgetCollection[widgetCollection.length - 1];
        block = this.documentHelper.selection.getNextRenderedBlock(block);
        if (!isNullOrUndefined(block)) { //Goto the next block.
            if (block instanceof ParagraphWidget) {
                if (value instanceof WListFormat && block.paragraphFormat.listFormat.hasValue("listLevelNumber")) {
                    const paraListLevelNumber: number = block.paragraphFormat.listFormat.listLevelNumber;
                    if (property === 'listFormat' && value["listLevelNumber"] < paraListLevelNumber && !this.increasedIndent && !this.decreasedIndent) {
                        value["listLevelNumber"] = paraListLevelNumber;
                    }
                    if (this.increasedIndent && value["listLevelNumber"] - 1 !== paraListLevelNumber) {
                        value["listLevelNumber"] = paraListLevelNumber === 8 ? paraListLevelNumber : paraListLevelNumber + 1;
                    }
                    if (this.decreasedIndent && value["listLevelNumber"] + 1 !== paraListLevelNumber) {
                        value["listLevelNumber"] = paraListLevelNumber === 0 ? paraListLevelNumber : paraListLevelNumber - 1;
                    }
                }
                this.applyParaFormat(block, start, end, property, value, update);
            } else {
                this.applyParaFormatTable(block as TableWidget, start, end, property, value, update, true);
            }
        }
    }
    private applyParagraphFormatTableInternal(table: TableWidget, property: string, value: Object, update: boolean, isNext?: boolean): void {
        for (let x: number = 0; x < table.childWidgets.length; x++) {
            let row: TableRowWidget = table.childWidgets[x] as TableRowWidget;
            for (let y: number = 0; y < row.childWidgets.length; y++) {
                this.applyParaFormatCellInternal((row.childWidgets[y] as TableCellWidget), property, value, update, isNext);
            }
        }
    }
    /**
     * Apply column format changes
     *
     * @param {string} property - Specifies the property
     * @param {Object} value - Specifies the value
     * @private
     * @returns {void}
     */
    public onApplyColumnFormat(property: string, value: Object): void {
        if (this.restrictFormatting) {
            return;
        }
        this.initHistory('SectionFormat');
        let selection: Selection = this.documentHelper.selection;
        selection.owner.isShiftingEnabled = true;
        let startPosition: TextPosition = selection.start;
        let endPosition: TextPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        let startPageIndex: number;
        let endPageIndex: number;
        this.documentHelper.clearContent();
        let startSectionIndex: number = startPosition.paragraph.bodyWidget.sectionIndex;
        let endSectionIndex: number = endPosition.paragraph.bodyWidget.sectionIndex;
        let isMultipleSection: boolean = false;
        for (let i: number = 0; i < this.documentHelper.pages.length; i++) {
            if (this.documentHelper.pages[i].bodyWidgets[0].index === startSectionIndex) {
                startPageIndex = i;
            } else {
                isMultipleSection = true;
            }
        }
        for (let i: number = startPageIndex; i < this.documentHelper.pages.length; i++) {
            let bodyWidget: BodyWidget = this.documentHelper.pages[i].bodyWidgets[0];
            endPageIndex = i;
            if ((bodyWidget.index === startSectionIndex)) {
                continue;
            } else if ((bodyWidget.index >= startSectionIndex) && bodyWidget.index <= endSectionIndex) {
                continue;
            } else {
                endPageIndex = i - 1;
                break;
            }
        }
        if (isMultipleSection && property == "differentOddAndEvenPages" && startPosition.paragraph.isInHeaderFooter) {
            startPageIndex = 0;
            endPageIndex = this.documentHelper.pages.length - 1;
        }
        // let startPageIndex: number = this.documentHelper.pages.indexOf((selection.start.paragraph.containerWidget as BodyWidget).page);
        // let endPageIndex: number = this.documentHelper.pages.indexOf((selection.end.paragraph.containerWidget as BodyWidget).page);
        let update: boolean = true;
        let index: number = 0;
        for (let i: number = startPageIndex; i <= endPageIndex; i++) {
            if (index !== this.documentHelper.pages[i].bodyWidgets[0].index && !update) {
                update = true;
            }
            this.applyPropertyValueForSection(this.documentHelper.pages[i].bodyWidgets[0].sectionFormat, property, value, update);
            index = this.documentHelper.pages[i].bodyWidgets[0].index;
            update = false;
        }
        this.documentHelper.layout.layoutWholeDocument();
        this.fireContentChange();
    }
    //Paragraph Format apply implementation Ends
    // Apply Selection Section Format Option Implementation Starts
    /**
     * Apply section format selection changes
     *
     * @param {string} property - Specifies the property
     * @param {Object} value - Specifies the value
     * @private
     * @returns {void}
     */
    public onApplySectionFormat(property: string, value: Object): void {
        if (this.restrictFormatting) {
            return;
        }
        if (!isNullOrUndefined(property)) {
            let action: Action = (property[0].toUpperCase() + property.slice(1)) as Action;
            this.initHistory(action);
        } else {
            this.initHistory('SectionFormat');
        }
        this.updateSectionFormat(property, value);
    }
    /**
     *
     * @private
     * @returns {void}
     */
    public removeInlineHeaderFooterWidget(sectionIndex: number, headerFooterType: HeaderFooterType, propertyName: string, value: Object ):void {
        if (sectionIndex != 0) {
            let headerFooters: HeaderFooters = this.documentHelper.headersFooters[sectionIndex];
            let index: number = (this.viewer as PageLayoutViewer).getHeaderFooter(headerFooterType);
            let sectionFormat: WSectionFormat = (this.selection.start.paragraph.containerWidget as HeaderFooterWidget).sectionFormat.cloneFormat();
            if(!isNullOrUndefined(value)) {
                if (!isNullOrUndefined(propertyName)) {
                    let action: Action = (propertyName[0].toUpperCase() + propertyName.slice(1)) as Action;
                    this.initHistory(action);
                    if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                        this.editorHistory.currentBaseHistoryInfo.insertedFormat = value
                    }
                    let blockInfo: ParagraphInfo = this.selection.getParagraphInfo(this.selection.start);
                    this.selection.editPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
                    if (this.checkInsertPosition(this.selection)) {
                        this.setPositionForHistory(this.selection.editPosition);
                    }
                }
                if (value) {
                    if (headerFooters && !isNullOrUndefined(headerFooters[index])) {
                        sectionFormat.removedHeaderFooters.push(headerFooters[index]);
                        this.editorHistory.currentBaseHistoryInfo.addModifiedPropertiesForSection(sectionFormat, propertyName, value);
                        delete headerFooters[index];
                    }
                } else {
                    let parentHeaderFooter: HeaderFooterWidget = (this.viewer as PageLayoutViewer).getCurrentHeaderFooter(headerFooterType, sectionIndex);
                    if (!isNullOrUndefined(parentHeaderFooter) && isNullOrUndefined(headerFooters[index])){
                        let HeaderFooterWidget: HeaderFooterWidget = parentHeaderFooter.clone();
                        headerFooters[index] = HeaderFooterWidget;
                        sectionFormat.removedHeaderFooters.push(HeaderFooterWidget);
                        this.editorHistory.currentBaseHistoryInfo.addModifiedPropertiesForSection(sectionFormat, propertyName, value);
                    }
                }
                this.selection.updateTextPositionForBlockContainer(this.selection.start.paragraph.containerWidget as BlockContainer);
                this.isSkipOperationsBuild = this.owner.enableCollaborativeEditing;
                this.documentHelper.layout.layoutWholeDocument();
                this.isSkipOperationsBuild = false;
                this.fireContentChange();
            }
        }
    }
    /**
     *
     * @private
     * @returns {void}
     */
    public updateHeaderFooters (propertyName: string, value: boolean, sectionIndex: number, widget: HeaderFooterWidget): void {
        let headerFooters: HeaderFooters = this.documentHelper.headersFooters[sectionIndex];
        let index: number = (this.viewer as PageLayoutViewer).getHeaderFooter(widget.headerFooterType);
        let headerFooter: HeaderFooterWidget = headerFooters[index];
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            if (isNullOrUndefined(headerFooter)) {
                this.documentHelper.headersFooters[sectionIndex][index] = widget;
            }
            else if (!isNullOrUndefined(headerFooter)) {
                delete headerFooters[index];
            }
        }
        this.selection.updateTextPositionForBlockContainer(this.selection.start.paragraph.containerWidget as BlockContainer);
        this.documentHelper.layout.layoutWholeDocument();
    }
    /**
     * Update section format
     *
     * @param {string} property - Specifies the property
     * @param {Object} value - Specifies the value
     * @private
     * @returns {void}
     */
    public updateSectionFormat(property: string, value: Object): void {
        if (this.documentHelper.selection.startPage === 1 && property === "differentFirstPage") {
            let paraInfo: ParagraphWidget;
            if (this.documentHelper.selection.start.paragraph.containerWidget instanceof TableCellWidget) {
                paraInfo = this.getFirstChildOfTable(this.documentHelper.selection.start.paragraph.containerWidget);
            } else {
                paraInfo = this.documentHelper.selection.start.paragraph.containerWidget.childWidgets[0] as ParagraphWidget;
            }
            let startIndex: string = this.selection.getHierarchicalIndex(paraInfo, "0");
            this.documentHelper.selection.select(startIndex, startIndex);
        }
        let selection: Selection = this.documentHelper.selection;
        selection.owner.isShiftingEnabled = true;
        let startPosition: TextPosition = selection.start;
        let endPosition: TextPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        let startPageIndex: number;
        let endPageIndex: number;
        this.documentHelper.clearContent();
        let startSectionIndex: number = startPosition.paragraph.bodyWidget.sectionIndex;
        let endSectionIndex: number = endPosition.paragraph.bodyWidget.sectionIndex;
        let isMultipleSection: boolean = false;
        let isSkip: boolean = false;
        for (let i: number = 0; i < this.documentHelper.pages.length; i++) {
            for (let j: number = 0; j < this.documentHelper.pages[i].bodyWidgets.length; j++) {
                if (this.documentHelper.pages[i].bodyWidgets[j].index === startSectionIndex) {
                    startPageIndex = i;
                    if (selection.isForward) {
                        isSkip = true;
                        break;
                    }
                } else {
                    isMultipleSection = true;
                }
            } if (isSkip) {
                break;
            }
        }
        for (let i: number = startPageIndex; i < this.documentHelper.pages.length; i++) {
            for (let j: number = 0; j < this.documentHelper.pages[i].bodyWidgets.length; j++) {
                let bodyWidget: BodyWidget = this.documentHelper.pages[i].bodyWidgets[j];
                if ((bodyWidget.index === startSectionIndex)) {
                    endPageIndex = i;
                    continue;
                } else if ((bodyWidget.index >= startSectionIndex) && bodyWidget.index <= endSectionIndex) {
                    endPageIndex = i;
                    continue;
                }
            }
        }
        if (isMultipleSection && property == "differentOddAndEvenPages" && startPosition.paragraph.isInHeaderFooter) {
            startPageIndex = 0;
            endPageIndex = this.documentHelper.pages.length - 1;
        }
        // let startPageIndex: number = this.documentHelper.pages.indexOf((selection.start.paragraph.containerWidget as BodyWidget).page);
        // let endPageIndex: number = this.documentHelper.pages.indexOf((selection.end.paragraph.containerWidget as BodyWidget).page);
        let update: boolean = true;
        let index: number = 0;
        for (let i: number = startPageIndex; i <= endPageIndex; i++) {
            for (let j: number = 0; j < this.documentHelper.pages[i].bodyWidgets.length; j++) {
                if ((this.documentHelper.pages[i].bodyWidgets[j].index >= startSectionIndex && this.documentHelper.pages[i].bodyWidgets[j].index <= endSectionIndex) ||
                    (!selection.isForward && this.documentHelper.pages[i].bodyWidgets[j].index <= startSectionIndex && this.documentHelper.pages[i].bodyWidgets[j].index >= endSectionIndex)) {
                    if (index !== this.documentHelper.pages[i].bodyWidgets[j].index && !update) {
                        update = true;
                    }
                    this.applyPropertyValueForSection(this.documentHelper.pages[i].bodyWidgets[j].sectionFormat, property, value, update);
                    index = this.documentHelper.pages[i].bodyWidgets[j].index;
                    update = false;
                    let body: BodyWidget = this.documentHelper.pages[i].bodyWidgets[j];
                    if (!isNullOrUndefined(body.nextWidget) && (body.sectionFormat.pageHeight !== (body.nextWidget as BodyWidget).sectionFormat.pageHeight || body.sectionFormat.pageWidth !== (body.nextWidget as BodyWidget).sectionFormat.pageWidth) && (body.nextWidget as BodyWidget).sectionFormat.breakCode === 'NoBreak') {
                        (body.nextWidget as BodyWidget).sectionFormat.breakCode = 'NewPage';
                        body = this.documentHelper.layout.getBodyWidget(body.nextWidget as BodyWidget, false);
                        if (!isNullOrUndefined(body.nextWidget)) {
                            (body.nextWidget as BodyWidget).sectionFormat.breakCode = 'NewPage';
                        }
                    }
                }
            }
        }
        this.isSkipOperationsBuild = this.owner.enableCollaborativeEditing;
        this.documentHelper.layout.layoutWholeDocument();
        this.isSkipOperationsBuild = false;
        this.fireContentChange();
    }
    private getFirstChildOfTable(cellWidget: TableCellWidget): ParagraphWidget {
        let ownerTable: TableWidget = cellWidget.ownerTable;
        return ((ownerTable.childWidgets[0] as TableRowWidget).childWidgets[0] as TableCellWidget).childWidgets[0] as ParagraphWidget;
    }
    //Apply Selection Table Format option implementation starts
    /**
     * Apply table format property changes
     *
     * @param {string} property - Specifies the property
     * @param {Object} value - Specifies the value
     * @private
     * @returns {void}
     */
    public onApplyTableFormat(property: string, value: Object, table?: TableWidget): void {
        if (this.restrictFormatting) {
            return;
        }
        let action: Action = this.getTableFormatAction(property);
        this.viewer.owner.isShiftingEnabled = true;
        let selection: Selection = this.documentHelper.selection;
        if(isNullOrUndefined(table)) {
            table = selection.start.paragraph.associatedCell.ownerTable;
        }
        table = table.combineWidget(this.owner.viewer) as TableWidget;
        if (selection.isEmpty) {
            this.initHistory(action);
            this.applyTablePropertyValue(property, value, table);
        } else {
            this.updateSelectionTableFormat(this.selection, action, value);
        }
        table.calculateGrid();
        this.selection.owner.isLayoutEnabled = true;
        this.documentHelper.layout.reLayoutTable(table);
        this.reLayout(selection, false);
    }
    private getTableFormatAction(property: string): Action {
        switch (property) {
            case 'tableAlignment':
                return 'TableAlignment';
            case 'leftIndent':
                return 'TableLeftIndent';
            case 'leftMargin':
                return 'DefaultCellLeftMargin';
            case 'rightMargin':
                return 'DefaultCellRightMargin';
            case 'bottomMargin':
                return 'DefaultCellBottomMargin';
            case 'topMargin':
                return 'DefaultCellTopMargin';
            case 'preferredWidth':
                return 'TablePreferredWidth';
            case 'preferredWidthType':
                return 'TablePreferredWidthType';
            case 'shading':
                return 'Shading';
            case 'bidi':
                return 'TableBidi';
            case 'title':
                return 'TableTitle';
            case 'description':
                return 'TableDescription';
            default:
                return 'DefaultCellSpacing';
        }
    }
    // Apply Selection Row Format Option Implementation Starts
    /**
     * Apply table row format property changes
     *
     * @param {string} property - Specifies the property
     * @param {Object} value - Specifies the value
     * @private
     * @returns {void}
     */
    public onApplyTableRowFormat(property: string, value: Object): void {
        if (this.restrictFormatting) {
            return;
        }
        let action: Action = this.getRowAction(property);
        this.documentHelper.owner.isShiftingEnabled = true;
        let selection: Selection = this.documentHelper.selection;
        if (selection.isEmpty) {
            this.initHistory(action);
            let table: TableWidget = selection.start.paragraph.associatedCell.ownerRow.ownerTable;
            this.applyRowPropertyValue(selection, property, value, selection.start.paragraph.associatedCell.ownerRow);
        } else {
            this.updateSelectionTableFormat(this.selection, action, value);
        }
        this.reLayout(selection, false);
    }
    private getRowAction(property: string): Action {
        switch (property) {
            case 'height':
                return 'RowHeight';
            case 'heightType':
                return 'RowHeightType';
            case 'isHeader':
                return 'RowHeader';
            default:
                return 'AllowBreakAcrossPages';
        }
    }
    /**
     * Apply table cell property changes
     *
     * @param {string} property - Specifies the property
     * @param {Object} value - Specifies the value
     * @private
     * @returns {void}
     */
    public onApplyTableCellFormat(property: string, value: Object): void {
        if (this.restrictFormatting) {
            return;
        }
        let action: Action = this.getTableCellAction(property);
        this.documentHelper.owner.isShiftingEnabled = true;
        let selection: Selection = this.documentHelper.selection;
        let table: TableWidget = selection.start.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.owner.viewer) as TableWidget;
        if (selection.isEmpty) {
            this.initHistory(action);
            this.applyCellPropertyValue(selection, property, value, selection.start.paragraph.associatedCell.cellFormat);
            table.calculateGrid();
            this.selection.owner.isLayoutEnabled = true;
            this.documentHelper.layout.reLayoutTable(table);
        } else {
            this.updateSelectionTableFormat(this.selection, action, value);
        }
        this.reLayout(selection, false);
    }

    private getTableCellAction(property: string): Action {
        switch (property) {
            case 'verticalAlignment':
                return 'CellContentVerticalAlignment';
            case 'leftMargin':
                return 'CellLeftMargin';
            case 'rightMargin':
                return 'CellRightMargin';
            case 'bottomMargin':
                return 'CellBottomMargin';
            case 'topMargin':
                return 'CellTopMargin';
            case 'preferredWidth':
                return 'CellPreferredWidth';
            case 'shading':
                return 'Shading';
            default:
                return 'CellPreferredWidthType';
        }
    }
    private applyPropertyValueForSection(sectionFormat: WSectionFormat, property: string, value: Object, update: boolean): void {
        //let selection: Selection = this.documentHelper.selection;
        if (update && this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            if (property === 'columns') {
                sectionFormat.numberOfColumns = (value as WColumnFormat[]).length;
            }
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedPropertiesForSection(sectionFormat, property, value);
            this.editorHistory.currentBaseHistoryInfo.insertedFormat = value
        }
        if (isNullOrUndefined(value)) {
            return;
        }
        if (value instanceof WSectionFormat) {
            if (isNullOrUndefined(property)) {
                sectionFormat.copyFormat(value as WSectionFormat, this.editorHistory);
            }
            return;
        }
        if (property === 'pageHeight') {
            sectionFormat.pageHeight = value as number;
        } else if (property === 'pageWidth') {
            sectionFormat.pageWidth = value as number;
        } else if (property === 'leftMargin') {
            sectionFormat.leftMargin = value as number;
        } else if (property === 'rightMargin') {
            sectionFormat.rightMargin = value as number;
        } else if (property === 'topMargin') {
            sectionFormat.topMargin = value as number;
        } else if (property === 'bottomMargin') {
            sectionFormat.bottomMargin = value as number;
        } else if (property === 'differentFirstPage') {
            sectionFormat.differentFirstPage = value as boolean;
        } else if (property === 'differentOddAndEvenPages') {
            sectionFormat.differentOddAndEvenPages = value as boolean;
        } else if (property === 'headerDistance') {
            sectionFormat.headerDistance = value as number;
        } else if (property === 'footerDistance') {
            sectionFormat.footerDistance = value as number;
        } else if (property === 'pageStartingNumber') {
            sectionFormat.pageStartingNumber = value as number;
        } else if (property === 'restartPageNumbering') {
            sectionFormat.restartPageNumbering = value as boolean;
        } else if (property === 'endnoteNumberFormat') {
            sectionFormat.endnoteNumberFormat = value as FootEndNoteNumberFormat;
        } else if (property === 'footNoteNumberFormat') {
            sectionFormat.footNoteNumberFormat = value as FootEndNoteNumberFormat;
        } else if (property === 'restartIndexForEndnotes') {
            sectionFormat.restartIndexForEndnotes = value as FootnoteRestartIndex;
        } else if (property === 'restartIndexForFootnotes') {
            sectionFormat.restartIndexForFootnotes = value as FootnoteRestartIndex;
        } else if (property === 'initialFootNoteNumber') {
            sectionFormat.initialFootNoteNumber = value as number;
        } else if (property === 'initialEndNoteNumber') {
            sectionFormat.initialEndNoteNumber = value as number;
        } else if (property == 'numberOfColumns') {
            sectionFormat.numberOfColumns = value as number;
        } else if (property == 'equalWidth') {
            sectionFormat.equalWidth = value as boolean;
        } else if (property == 'lineBetweenColumns') {
            sectionFormat.lineBetweenColumns = value as boolean;
        } else if (property == 'columns') {
            sectionFormat.columns = value as WColumnFormat[];
        }
    }
    
    private combineFollowingSection(): BodyWidget[] {
        let sections: BodyWidget[] = [];
        let nextSection: BodyWidget = this.documentHelper.selection.start.paragraph.bodyWidget.getSplitWidgets()[0] as BodyWidget;
        if (nextSection.childWidgets[0] instanceof ParagraphWidget) {
            this.updateWholeListItems(nextSection.childWidgets[0] as ParagraphWidget);
        } else {
            const block: ParagraphWidget = this.documentHelper.getFirstParagraphInFirstCell(nextSection.childWidgets[0] as TableWidget);
            this.viewer.owner.editorModule.updateWholeListItems(block);
        }
        let pageIndex: number = this.documentHelper.pages.indexOf(nextSection.page);
        let startIndex: number = nextSection.indexInOwner === 0 ? pageIndex : pageIndex + 1;
        do {
            nextSection = this.documentHelper.combineSectionChild(nextSection, sections, false);
        } while (nextSection);
        for (let i: number = startIndex; i < this.documentHelper.pages.length; i++) {
            this.documentHelper.pages[i].destroy();
            i--;
        }
        for (let j: number = pageIndex; j < this.documentHelper.pages.length; j++) {
            for (let k: number = 0; k < this.documentHelper.pages[j].bodyWidgets.length; k++) {
                if (this.documentHelper.pages[j].bodyWidgets[k].childWidgets.length === 0) {
                    this.documentHelper.pages[j].bodyWidgets.splice(k, 1);
                    k--;
                }
            }
        }
        return sections;
    }

    private updateSelectionTableFormat(selection: Selection, action: Action, value: Object): void {
        switch (action) {
            case 'TableAlignment':
                this.editorHistory.initializeHistory('TableAlignment');
                this.updateTableFormat(selection, 'tableAlignment', value);
                break;
            case 'TableLeftIndent':
                this.editorHistory.initializeHistory('TableLeftIndent');
                this.updateTableFormat(selection, 'leftIndent', value);
                break;
            case 'DefaultCellSpacing':
                this.editorHistory.initializeHistory('DefaultCellSpacing');
                this.updateTableFormat(selection, 'cellSpacing', value);
                break;
            case 'DefaultCellLeftMargin':
                this.editorHistory.initializeHistory('DefaultCellLeftMargin');
                this.updateTableFormat(selection, 'leftMargin', value);
                break;
            case 'DefaultCellRightMargin':
                this.editorHistory.initializeHistory('DefaultCellRightMargin');
                this.updateTableFormat(selection, 'rightMargin', value);
                break;
            case 'DefaultCellTopMargin':
                this.editorHistory.initializeHistory('DefaultCellTopMargin');
                this.updateTableFormat(selection, 'topMargin', value);
                break;
            case 'TablePreferredWidth':
                this.editorHistory.initializeHistory('TablePreferredWidth');
                this.updateTableFormat(selection, 'preferredWidth', value);
                break;
            case 'TablePreferredWidthType':
                this.editorHistory.initializeHistory('TablePreferredWidthType');
                this.updateTableFormat(selection, 'preferredWidthType', value);
                break;
            case 'DefaultCellBottomMargin':
                this.editorHistory.initializeHistory('DefaultCellBottomMargin');
                this.updateTableFormat(selection, 'bottomMargin', value);
                break;
            case 'CellContentVerticalAlignment':
                this.editorHistory.initializeHistory('CellContentVerticalAlignment');
                this.updateCellFormat(selection, 'verticalAlignment', value);
                break;
            case 'CellLeftMargin':
                this.editorHistory.initializeHistory('CellLeftMargin');
                this.updateCellFormat(selection, 'leftMargin', value);
                break;
            case 'CellRightMargin':
                this.editorHistory.initializeHistory('CellRightMargin');
                this.updateCellFormat(selection, 'rightMargin', value);
                break;
            case 'CellTopMargin':
                this.editorHistory.initializeHistory('CellTopMargin');
                this.updateCellFormat(selection, 'topMargin', value);
                break;
            case 'CellBottomMargin':
                this.editorHistory.initializeHistory('CellBottomMargin');
                this.updateCellFormat(selection, 'bottomMargin', value);
                break;
            case 'CellPreferredWidth':
                this.editorHistory.initializeHistory('CellPreferredWidth');
                this.updateCellFormat(selection, 'preferredWidth', value);
                break;
            case 'CellPreferredWidthType':
                this.editorHistory.initializeHistory('CellPreferredWidthType');
                this.updateCellFormat(selection, 'preferredWidthType', value);
                break;
            case 'Shading':
                this.editorHistory.initializeHistory('Shading');
                this.updateCellFormat(selection, 'shading', value);
                break;
            case 'RowHeight':
                this.editorHistory.initializeHistory('RowHeight');
                this.updateRowFormat(selection, 'height', value);
                break;
            case 'RowHeightType':
                this.editorHistory.initializeHistory('RowHeightType');
                this.updateRowFormat(selection, 'heightType', value);
                break;
            case 'RowHeader':
                this.editorHistory.initializeHistory('RowHeader');
                this.updateRowFormat(selection, 'isHeader', value);
                break;
            case 'AllowBreakAcrossPages':
                this.editorHistory.initializeHistory('AllowBreakAcrossPages');
                this.updateRowFormat(selection, 'allowBreakAcrossPages', value);
                break;
            case 'TableBidi':
                this.editorHistory.initializeHistory(action);
                this.updateTableFormat(selection, 'bidi', value);
                break;
            case 'TableTitle':
                this.editorHistory.initializeHistory(action);
                this.updateTableFormat(selection, 'title', value);
                break;
            case 'TableDescription':
                this.editorHistory.initializeHistory(action);
                this.updateTableFormat(selection, 'description', value);
                break;
        }
    }
    // Update Table Properties
    /**
     * Update Table Format on undo
     *
     * @param {Selection} selection - Specifies the selection
     * @param {string} property - Specifies the property
     * @param {Object} value - Specifies the value
     * @private
     * @returns {void}
     */
    public updateTableFormat(selection: Selection, property: string, value: object): void {
        let tableStartPosition: TextPosition = selection.start;
        let tableEndPosition: TextPosition = selection.end;
        if (!selection.isForward) {
            tableStartPosition = selection.end;
            tableEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, tableStartPosition);

        this.applyTablePropertyValue(property, value, tableStartPosition.paragraph.associatedCell.ownerTable);
        if (this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
            this.documentHelper.layout.reLayoutTable(tableStartPosition.paragraph.associatedCell.ownerTable);
        }
    }
    /**
     * update cell format on undo
     *
     * @param {Selection} selection - Specifies the selection
     * @param {string} property - Specifies the property
     * @param {Object} value - Specifies the value
     * @private
     * @returns {void}
     */
    public updateCellFormat(selection: Selection, property: string, value: Object): void {
        selection.owner.isShiftingEnabled = true;
        let newStartPosition: TextPosition = selection.start;
        let newEndPosition: TextPosition = selection.end;
        if (!selection.isForward) {
            newStartPosition = selection.end;
            newEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, newStartPosition);
        this.updateFormatForCell(selection, property, value);
    }
    /**
     * Update row format on undo
     *
     * @param {Selection} selection - Specifies the selection
     * @param {string} property - Specifies the property
     * @param {Object} value - Specifies the value
     * @private
     * @returns {void}
     */
    public updateRowFormat(selection: Selection, property: string, value: Object): void {
        let rowStartPosition: TextPosition = selection.start;
        let rowEndPosition: TextPosition = selection.end;
        if (!selection.isForward) {
            rowStartPosition = selection.end;
            rowEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, rowStartPosition);

        this.applyRowFormat(rowStartPosition.paragraph.associatedCell.ownerRow, rowStartPosition, rowEndPosition, property, value);
    }
    private initHistoryPosition(selection: Selection, position?: TextPosition): void {
        if (this.documentHelper.owner.editorHistoryModule && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            if (!isNullOrUndefined(position)) {
                if (isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition)) {
                    this.editorHistory.currentBaseHistoryInfo.insertPosition = position.getHierarchicalIndexInternal();
                }
            } else if (isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition)) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = selection.start.getHierarchicalIndexInternal();
            }
        }
    }
    private startSelectionReLayouting(paragraph: ParagraphWidget, selection: Selection, start: TextPosition, end: TextPosition): void {
        selection.owner.isLayoutEnabled = true;
        if (start.paragraph.isInsideTable) {
            let table: TableWidget = start.paragraph.associatedCell.ownerTable;
            while (table.isInsideTable) {
                table = table.associatedCell.ownerTable;
            }
            this.reLayoutSelectionOfTable(table, selection, start, end);
        } else {
            this.reLayoutSelection(paragraph, selection, start, end);
        }
    }
    private reLayoutSelectionOfTable(table: TableWidget, selection: Selection, start: TextPosition, end: TextPosition): boolean {
        let isEnded: boolean = false;
        this.documentHelper.layout.layoutBodyWidgetCollection(table.index, table.containerWidget as BodyWidget, table, false);
        // If the selection ends in the current table, need to stop relayouting.
        if (!isNullOrUndefined(end.paragraph.associatedCell) && table.contains(end.paragraph.associatedCell)) {
            return true;
        }
        let block: BlockWidget = selection.getNextRenderedBlock(table);
        // Relayout the next block.
        if (!isNullOrUndefined(block)) {
            isEnded = this.reLayoutSelectionOfBlock(block, selection, start, end);
        }
        return isEnded;
    }
    private reLayoutSelection(paragraph: ParagraphWidget, selection: Selection, start: TextPosition, end: TextPosition): boolean {
        if (start.paragraph === paragraph) {
            let startOffset: number = start.offset;
            let length: number = selection.getParagraphLength(paragraph);
            let indexInInline: number = 0;
            let index: number = 0;
            let inlineObj: ElementInfo = paragraph.getInline(start.offset, indexInInline);
            let inline: ElementBox = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!isNullOrUndefined(inline)) {
                if (indexInInline === inline.length && !isNullOrUndefined(inline.nextNode)) {
                    inline = inline.nextNode as ElementBox;
                }
                index = inline.line.children.indexOf(inline);
            }
            let lineIndex: number = 0;
            if (start.currentWidget.paragraph === paragraph) {
                lineIndex = paragraph.childWidgets.indexOf(start.currentWidget);
                index = start.currentWidget.children.indexOf(inline);
            }

            // If selection start inline is at new inline, need to relayout from the previous inline.
            if (inline instanceof TextElementBox && !inline.line && index > 0) {
                this.documentHelper.layout.reLayoutParagraph(paragraph, lineIndex, index - 1);
            } else {
                this.documentHelper.layout.reLayoutParagraph(paragraph, lineIndex, index);
            }
        } else {
            this.documentHelper.layout.reLayoutParagraph(paragraph, 0, 0);
        }
        // If the selection ends at the current paragraph, need to stop relayouting.
        if (end.paragraph === paragraph) {
            return true;
        }
        // _Relayout the next block.
        let block: BlockWidget = selection.getNextRenderedBlock(paragraph);
        if (!isNullOrUndefined(block)) {
            return this.reLayoutSelectionOfBlock(block, selection, start, end);
        }
        return false;
    }
    //Relayouting Start    
    private reLayoutSelectionOfBlock(block: BlockWidget, selection: Selection, start: TextPosition, end: TextPosition): boolean {
        if (block instanceof ParagraphWidget) {
            return this.reLayoutSelection(block as ParagraphWidget, selection, start, end);
        } else {
            return undefined;
            // return this.reLayoutSelectionOfTable(block as TableWidget, selection, start, end);
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public layoutItemBlock(block: BlockWidget, shiftNextWidget: boolean): void {
        let section: Widget = undefined;
        if (block.containerWidget instanceof BlockContainer || block.containerWidget instanceof TextFrame) {
            // let index: number = section.childWidgets.indexOf(block);
            if (!isNullOrUndefined(this.documentHelper.owner)
                && this.documentHelper.owner.isLayoutEnabled) {
                block = block.combineWidget(this.viewer) as BlockWidget;
                section = block.containerWidget as BlockContainer;
                this.documentHelper.layout.layoutBodyWidgetCollection(block.index, section as BodyWidget, block, false);
            }
        } else if (block.containerWidget instanceof TableCellWidget) {
            let cell: TableCellWidget = block.containerWidget as TableCellWidget;
            cell = this.documentHelper.selection.getContainerCell(cell);
            if (!isNullOrUndefined(this.documentHelper.owner)
                && this.documentHelper.owner.isLayoutEnabled) {
                this.documentHelper.layout.reLayoutTable(block);
            }
        }
    }
    /**
     * @private
     * @returns {boolean}
     */
    public removeSelectedContents(selection: Selection): boolean {
        return this.removeSelectedContentInternal(selection, selection.start, selection.end);
    }
    private removeSelectedContentInternal(selection: Selection, startPosition: TextPosition, endPosition: TextPosition): boolean {
        let startPos: TextPosition = startPosition;
        let endPos: TextPosition = endPosition;
        if (!startPosition.isExistBefore(endPosition)) {
            startPos = endPosition;
            endPos = startPosition;
        }

        if (startPos.paragraph === endPos.paragraph && startPos.paragraph.childWidgets.indexOf(startPos.currentWidget) === startPos.paragraph.childWidgets.length - 1 &&
            startPos.offset === selection.getParagraphLength(startPos.paragraph) && startPos.offset + 1 === endPos.offset) {
            selection.owner.isShiftingEnabled = true;
            selection.selectContent(startPos, true);
            return true;
        }
        let paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(startPos);
        selection.editPosition = this.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
        let start: TextPosition = startPos.clone();
        let body: BodyWidget = start.paragraph.containerWidget as BodyWidget;
        let isFirstLine: boolean = start.currentWidget.isFirstLine();
        let isMultipleSectionSelected = this.checkMultipleSectionSelected(start, endPos);
        let isRemoved: boolean = this.removeSelectedContent(endPos.paragraph, selection, startPos, endPos);
        let textPosition: TextPosition = new TextPosition(selection.owner);
        if (isMultipleSectionSelected && this.selection.currentPasteAction == "DefaultPaste" && isFirstLine && start.offset < 1) {
            let currentParagraph: ParagraphWidget = start.paragraph;
            let paragraph: ParagraphWidget = new ParagraphWidget();
            let line: LineWidget = new LineWidget(paragraph);
            line.paragraph = paragraph;
            paragraph.containerWidget = body;
            paragraph.childWidgets.push(line);
            body.childWidgets.push(paragraph);
            paragraph.index = currentParagraph.index;
            paragraph.x = start.location.x;
            paragraph.y = start.location.y;
        }
        this.setPositionForCurrentIndex(textPosition, selection.editPosition);
        selection.selectContent(textPosition, true);
        return isRemoved;
    }

    private checkMultipleSectionSelected(start: TextPosition, end: TextPosition): boolean {
        let startSectionIndex: number = this.getBodyWidgetIndex(start);
        let endSectionIndex: number = this.getBodyWidgetIndex(end)
        if (startSectionIndex == endSectionIndex) {
            return false;
        }
        return true;
    }

    private getBodyWidgetIndex(textPosition: TextPosition): number {
        let position: string = textPosition.hierarchicalPosition;
        let index: number = position.indexOf(';');
        let value: string = position.substring(0, index);
        position = position.substring(index).replace(';', '');
        index = position.indexOf(';');
        value = position.substring(0, index);
        let bodyWidgetIndex: number = parseInt(value, 10);
        return bodyWidgetIndex;
    }

    private removeSelectedContent(paragraph: ParagraphWidget, selection: Selection, start: TextPosition, end: TextPosition): boolean {
        //If end is not table end and start is outside the table, then skip removing the contents and move caret to start position.
        if (end.paragraph.isInsideTable
            && end.paragraph !== this.documentHelper.getLastParagraphInLastCell(end.paragraph.associatedCell.ownerTable)
            && (!start.paragraph.isInsideTable
                || start.paragraph.associatedCell.ownerTable.index !== end.paragraph.associatedCell.ownerTable.index)) {
            return false;
        }
        selection.owner.isShiftingEnabled = true;
        this.deleteSelectedContent(paragraph, selection, start, end, 2);
        return true;
    }

    private deleteSelectedContent(paragraph: ParagraphWidget, selection: Selection, start: TextPosition, end: TextPosition, editAction: number): void {
        //Handled special behaviour for content control start and end should not delete.
        let isParaMark: boolean = end.offset === this.selection.getLineLength(end.currentWidget) + 1;
        if (start.isAtParagraphStart && (isParaMark || end.isAtParagraphEnd)) {
            let startInlineObj: ElementInfo = start.currentWidget.getInline(start.offset, 0);
            let startInline: ElementBox = startInlineObj.element;
            let endInlineObj: ElementInfo = end.currentWidget.getInline(end.offset, 0);
            let endInline: ElementBox = endInlineObj.element;
            if (startInline instanceof ContentControl && !startInline.contentControlProperties.lockContents && endInline instanceof ContentControl && startInline.reference === endInline && startInline.nextNode != endInline) {
                start.offset += 1;
                end.offset -= isParaMark ? 2 : 1;
                const blockInfo: ParagraphInfo = this.selection.getParagraphInfo(start);
                selection.editPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
                //Updating for collaborative editing.
                if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                    this.editorHistory.currentBaseHistoryInfo.updateSelection();
                }
            }
        }
        let indexInInline: number = 0;
        let inlineObj: ElementInfo = start.currentWidget.getInline(start.offset, indexInInline);
        let inline: ElementBox = inlineObj.element;
        indexInInline = inlineObj.index;
        // if (!isNullOrUndefined(inline)) {
        //     inline = selection.getNextRenderedInline(inline, indexInInline);
        // }
        // if (inline instanceof WFieldBegin && !isNullOrUndefined((inline as WFieldBegin).fieldEnd)) {

        //     let fieldEndOffset: number = ((inline as WFieldBegin).fieldEnd.owner as WParagraph).getOffset((inline as WFieldBegin).fieldEnd, 1);
        //     let fieldEndIndex: string = WordDocument.getHierarchicalIndexOf((inline as WFieldBegin).fieldEnd.owner as WParagraph, fieldEndOffset.toString());
        //     let selectionEndIndex: string = end.getHierarchicalIndexInternal();
        //     if (!TextPosition.isForwardSelection(fieldEndIndex, selectionEndIndex)) {
        //         //If selection end is after field begin, moves selection start to field separator.
        //         start.moveToInline((inline as WFieldBegin).fieldSeparator, 1);
        //         selection.editPosition = start.getHierarchicalIndexInternal();
        //         if (!isNullOrUndefined(selection.currentBaseHistoryInfo)) {
        //             selection.currentBaseHistoryInfo.insertPosition = selection.editPosition;
        //         }
        //     }
        // }
        indexInInline = 0;
        inlineObj = end.currentWidget.getInline(end.offset, indexInInline);
        inline = inlineObj.element;
        indexInInline = inlineObj.index;
        // if (!isNullOrUndefined(inline)) {
        //     inline = selection.getNextRenderedInline(inline, indexInInline);
        // }
        // if (inline instanceof WFieldEnd && !isNullOrUndefined((inline as WFieldEnd).fieldBegin)) {

        //     let fieldBeginOffset: number = ((inline as WFieldEnd).fieldBegin.owner as WParagraph).getOffset((inline as WFieldEnd).fieldBegin, 0);
        //     let fieldBeginIndex: string = WordDocument.getHierarchicalIndexOf((inline as WFieldEnd).fieldBegin.owner as WParagraph, fieldBeginOffset.toString());
        //     let selectionStartIndex: string = start.getHierarchicalIndexInternal();
        //     if (!TextPosition.isForwardSelection(selectionStartIndex, fieldBeginIndex)) {
        //         //If field begin is before selection start, move selection end to inline item before field end.
        //         let prevInline: WInline = selection.getPreviousTextInline(inline);
        //         if (isNullOrUndefined(prevInline)) {
        //             end.moveBackward();
        //         } else {
        //             end.moveToInline(prevInline, prevInline.length);
        //         }
        //     }
        // }
        // if (inline instanceof FootnoteElementBox) {
        //     this.removeFootnote(inline);
        // }
        if (end.paragraph !== paragraph) {
            this.deleteSelectedContent(end.paragraph, selection, start, end, editAction);
            return;
        }
        let isDeleteCell: boolean = false;
        
        if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && (this.editorHistory.currentBaseHistoryInfo.action === 'BackSpace' || this.editorHistory.currentBaseHistoryInfo.action === 'DeleteCells'
            || this.editorHistory.currentBaseHistoryInfo.action === 'Accept Change' || this.editorHistory.currentBaseHistoryInfo.action === 'Reject Change'
            || (this.editorHistory.currentBaseHistoryInfo.action === 'RemoveRowTrack' && !this.editorHistory.currentBaseHistoryInfo.isClearCell) || (start.paragraph.isInsideTable && this.editorHistory.isUndoing && this.editorHistory.currentBaseHistoryInfo.action === 'InsertTable'))) {
            isDeleteCell = true;
        }
        //  Selection start in cell.
        if (end.paragraph.isInsideTable && (!start.paragraph.isInsideTable
            || (start.paragraph.associatedCell && !start.paragraph.associatedCell.equals(end.paragraph.associatedCell))
            || (selection.isCellSelected(end.paragraph.associatedCell, start, end)))) {
            end.paragraph.associatedCell.ownerTable.combineWidget(this.owner.viewer);
            this.deleteTableCell(end.paragraph.associatedCell, selection, start, end, editAction, isDeleteCell);
        } else {
            let shiftPara: BlockWidget = undefined;
            if (this.owner.viewer instanceof PageLayoutViewer && paragraph.bodyWidget.sectionFormat.numberOfColumns > 1 && paragraph === paragraph.bodyWidget.lastChild && !isNullOrUndefined(paragraph.bodyWidget.nextRenderedWidget) && paragraph.bodyWidget.index !== paragraph.bodyWidget.nextRenderedWidget.index && paragraph.bodyWidget.page === (paragraph.bodyWidget.nextRenderedWidget as BodyWidget).page) {
                shiftPara = paragraph.nextRenderedWidget as BlockWidget;
            }
            this.deletePara(paragraph, start, end, editAction);
            if (this.delBlockContinue && this.delBlock) {
                if (this.delSection) {
                    let bodyWidget: BodyWidget = paragraph.bodyWidget instanceof BodyWidget ? paragraph.bodyWidget : undefined;
                    this.deleteSection(selection, this.delSection, bodyWidget, editAction);
                    this.delSection = undefined;
                }
                this.deleteBlock((this.delBlock as ParagraphWidget), selection, start, end, editAction);
                this.delBlockContinue = false;
                this.delBlock = undefined;
            }
            if (this.owner.viewer instanceof PageLayoutViewer && shiftPara !== undefined) {
                this.documentHelper.blockToShift = shiftPara;
            }
        }
    }
    /**
     * Merges the selected cells.
     *
     * @returns {void}
     */
    public mergeCells(): void {
        if (this.owner.isReadOnlyMode || !this.canEditContentControl || !this.owner.isDocumentLoaded) {
            return;
        }
        if (!isNullOrUndefined(this.documentHelper) && !this.selection.isEmpty) {
            this.mergeSelectedCellsInTable();
        }
    }
    /**
     * Deletes the entire table at selection.
     *
     * @returns {void}
     */
    public deleteTable(): void {
        if (this.owner.isReadOnlyMode || !this.canEditContentControl) {
            return;
        }
        let startPos: TextPosition = this.selection.isForward ? this.selection.start : this.selection.end;
        if (startPos.paragraph.isInsideTable) {
            let table: TableWidget = this.getOwnerTable(this.selection.isForward).combineWidget(this.owner.viewer) as TableWidget;
            this.selection.selectTable();
            let commentStart: CommentCharacterElementBox[] = [];
            this.selection.owner.isShiftingEnabled = true;
            if (this.checkIsNotRedoing()) {
                commentStart = this.checkAndRemoveComments();
                this.initHistory('DeleteTable');
                //Sets the insert position in history info as current table.    
                this.updateHistoryPosition(startPos, true);
            }
            let considerTrackChanges: boolean = true;
            if (!this.skipTracking()) {
                let count: number = 0;
                for (let i: number = 0; i < table.childWidgets.length; i++) {
                    let row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
                    if (row.rowFormat.revisionLength === 1 && row.rowFormat.getRevision(0).revisionType === 'Insertion'
                        && row.rowFormat.getRevision(0).author === (this.owner.currentUser === '' ? 'Guest user' : this.owner.currentUser)) {
                        this.addRemovedRevisionInfo(row.rowFormat);
                        this.unlinkRevisionFromItem(row.rowFormat);
                        count++;
                    }
                }
                if (count === table.childWidgets.length) {
                    considerTrackChanges = false;
                }
            }
            let paragraph: ParagraphWidget = this.getParagraphForSelection(table);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Table;
                this.editorHistory.currentBaseHistoryInfo.removedNodes.push(table.clone());
            }
            if (this.owner.enableTrackChanges && considerTrackChanges) {
                for (let i: number = table.childWidgets.length - 1; i >= 0; i--) {
                    if (i === table.childWidgets.length - 1) {
                        let nextCell: TableCellWidget = table.childWidgets[0] as TableCellWidget;
                        paragraph = this.selection.getFirstParagraph(nextCell);
                    }
                    this.trackRowDeletion(table.childWidgets[i] as TableRowWidget);
                }

            } else {
                this.removeBlock(table, false, false, false, true);
            }
            this.selection.selectParagraphInternal(paragraph, true);
            if (this.checkIsNotRedoing() || isNullOrUndefined(this.editorHistory)) {
                this.reLayout(this.selection);
                this.updateHistoryForComments(commentStart);
            }
        }
    }
    /**
     * Deletes the selected column(s).
     *
     * @returns {void}
     */
    public deleteColumn(): void {
        if (this.owner.isReadOnlyMode || !this.canEditContentControl) {
            return;
        }
        if (this.owner.enableTrackChanges) {
            let locale: L10n = new L10n('documenteditor', this.owner.defaultLocale);
            locale.setLocale(this.owner.locale);
            this.alertDialog = DialogUtility.alert({
                title: locale.getConstant('UnTrack'),
                content: locale.getConstant('Merge Track'),
                showCloseIcon: true,
                okButton: {
                    text: 'Ok', click: this.onDeleteColumnConfirmed.bind(this)
                },
                closeOnEscape: true,
                position: { X: 'center', Y: 'center' },
                animationSettings: { effect: 'Zoom' }
            });
            this.alertDialog.enableRtl = this.owner.enableRtl;
        } else {
            this.onDeleteColumnConfirmed();
        }
    }
    private onDeleteColumnConfirmed(): void {
        let startPos: TextPosition = this.selection.isForward ? this.selection.start : this.selection.end;
        let endPos: TextPosition = this.selection.isForward ? this.selection.end : this.selection.start;
        if (startPos.paragraph.isInsideTable) {
            let startPosition: TextPosition = this.selection.start.clone();
            let endPosition: TextPosition = this.selection.end.clone();
            this.selection.selectColumn();
            let commentStart: CommentCharacterElementBox[] = [];
            this.selection.owner.isShiftingEnabled = true;
            if (this.checkIsNotRedoing()) {
                commentStart = this.checkAndRemoveComments();
                this.selection.start.setPositionInternal(startPosition);
                this.selection.end.setPositionInternal(endPosition);
                this.initHistory('DeleteColumn');
            }
            this.selection.start.setPositionInternal(startPosition);
            this.selection.end.setPositionInternal(endPosition);
            let startCell: TableCellWidget = this.getOwnerCell(this.selection.isForward);
            let endCell: TableCellWidget = this.getOwnerCell(!this.selection.isForward);
            let table: TableWidget = startCell.ownerTable.combineWidget(this.owner.viewer) as TableWidget;
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                this.cloneTableToHistoryInfo(table);
            }
            let paragraph: ParagraphWidget = undefined;
            if (endCell.nextWidget) {
                let nextCell: TableCellWidget = endCell.nextWidget as TableCellWidget;
                paragraph = this.selection.getFirstParagraph(nextCell);
            } else if (startCell.previousWidget) {
                let previousCell: TableCellWidget = startCell.previousWidget as TableCellWidget;
                paragraph = this.selection.getFirstParagraph(previousCell);
            }
            if (isNullOrUndefined(paragraph)) {
                paragraph = this.getParagraphForSelection(table);
            }
            //retrieve the cell collection based on start and end cell to remove. 
            let deleteCells: TableCellWidget[] = table.getColumnCellsForSelection(startCell, endCell);
            this.onDeleteColumn(table, deleteCells);
            if (table.childWidgets.length === 0) {
                // Before disposing table reset the paragrph.
                paragraph = this.getParagraphForSelection(table);
                this.removeBlock(table);
                if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                    this.editorHistory.currentBaseHistoryInfo.action = 'DeleteTable';
                }
                table.destroy();
            } else {
                this.updateTable(table);
            }
            this.selection.selectParagraphInternal(paragraph, true);
            if (isNullOrUndefined(this.editorHistory) || this.checkIsNotRedoing()) {
                this.reLayout(this.selection, true);
                this.updateHistoryForComments(commentStart);
            }
            if (!isNullOrUndefined(this.alertDialog)) {
                this.alertDialog.close();
                this.alertDialog = undefined;
            }
        }
    }
    /**
     * Delete the column for collaborative editing.
     * @private
     * @returns {void}
     */
    public onDeleteColumn(table: TableWidget, deleteCells: TableCellWidget[]): number {
        let length: number = 0;
        for (let i: number = 0; i < table.childWidgets.length; i++) {
            let row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
            if (row.childWidgets.length === 1) {
                if (deleteCells.indexOf(row.childWidgets[0] as TableCellWidget) >= 0) {
                    this.removeFieldInWidget(row.childWidgets[0] as Widget, true);
                    table.childWidgets.splice(table.childWidgets.indexOf(row), 1);
                    row.destroy();
                    length += 1;
                    i--;
                }
            } else {
                for (let j: number = 0; j < row.childWidgets.length; j++) {
                    let tableCell: TableCellWidget = row.childWidgets[j] as TableCellWidget;
                    if (deleteCells.indexOf(tableCell) >= 0) {
                        this.removeFieldInWidget(tableCell as Widget, true);
                        this.removeDeletedCellRevision(row, false, tableCell.columnIndex, tableCell.columnIndex + tableCell.cellFormat.columnSpan - 1);
                        row.childWidgets.splice(j, 1);
                        tableCell.destroy();
                        j--;
                    }
                }
                if (row.childWidgets.length === 0) {
                    table.childWidgets.splice(table.childWidgets.indexOf(row), 1);
                    row.destroy();
                    length += 1;
                    i--;
                }
            }
        }
        return length;
    }
    /**
     * Deletes the selected row(s).
     *
     * @returns {void}
     */
    public deleteRow(): void {
        if (this.owner.isReadOnlyMode || !this.canEditContentControl) {
            return;
        }
        let startPos: TextPosition = !this.selection.isForward ? this.selection.end : this.selection.start;
        let endPos: TextPosition = !this.selection.isForward ? this.selection.start : this.selection.end;
        let blockInfo: ParagraphInfo = this.selection.getParagraphInfo(startPos);
        let startIndex: string = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        if (startPos.paragraph.isInsideTable) {
            let startCell: TableCellWidget = this.getOwnerCell(this.selection.isForward);
            let endCell: TableCellWidget = this.getOwnerCell(!this.selection.isForward);
            this.selection.selectRow();
            let commentStart: CommentCharacterElementBox[] = [];
            if (this.checkIsNotRedoing()) {
                commentStart = this.checkAndRemoveComments();
                this.initHistory('DeleteRow');
            }
            this.selection.owner.isShiftingEnabled = true;
            let table: TableWidget = startCell.ownerTable.combineWidget(this.owner.viewer) as TableWidget;
            let row: TableRowWidget = this.getOwnerRow(true);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                this.cloneTableToHistoryInfo(table);
            }
            let paragraph: ParagraphWidget = undefined;
            if (row.nextWidget) {
                let nextCell: TableCellWidget = (row.nextWidget as TableRowWidget).childWidgets[0] as TableCellWidget;
                paragraph = this.selection.getFirstParagraph(nextCell);
            }
            if (isNullOrUndefined(paragraph)) {
                paragraph = this.getParagraphForSelection(table);
            }
            startPos = startPos.clone();
            if (!this.selection.isEmpty) {

                let containerCell: TableCellWidget = this.selection.getContainerCellOf(startCell, endCell);
                if (containerCell.ownerTable.contains(endCell)) {
                    startCell = this.selection.getSelectedCell(startCell, containerCell);
                    endCell = this.selection.getSelectedCell(endCell, containerCell);
                    if (this.selection.containsCell(containerCell, endCell)) {
                        row = startCell.ownerRow;
                        if (this.owner.enableTrackChanges) {
                            if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                                this.editorHistory.currentBaseHistoryInfo.action = 'RemoveRowTrack';
                                this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Row;
                            }
                            this.trackRowDeletion(row, true, false);
                        } else {
                            this.removeRow(row);
                        }
                    } else {
                        let startRow: TableRowWidget = startCell.ownerRow;
                        let endRow: TableRowWidget = endCell.ownerRow;
                        let startRowIndex: number = startRow.rowIndex;
                        let endRowIndex: number = endRow.rowIndex;
                        //Update the selection paragraph.
                        paragraph = undefined;
                        if (endRow.nextWidget) {
                            let nextCell: TableCellWidget = (endRow.nextWidget as TableRowWidget).childWidgets[0] as TableCellWidget;
                            paragraph = this.selection.getFirstParagraph(nextCell);
                        }
                        if (isNullOrUndefined(paragraph)) {
                            paragraph = this.getParagraphForSelection(table);
                        }
                        for (let i: number = table.childWidgets.length - 1; i >= 0; i--) {
                            let tableRow: TableRowWidget = table.childWidgets[i] as TableRowWidget;
                            if (tableRow.rowIndex >= startRowIndex && tableRow.rowIndex <= endRowIndex) {
                                if (this.owner.enableTrackChanges && this.checkIsNotRedoing()) {
                                    this.trackRowDeletion(tableRow, true, false);
                                } else {
                                    this.removeFieldInBlock(tableRow, true);
                                    let prevRenderedRow: TableRowWidget = tableRow.previousRenderedWidget as TableRowWidget;
                                    while (!isNullOrUndefined(prevRenderedRow)) {
                                        for (let j: number = 0; j < prevRenderedRow.childWidgets.length; j++) {
                                            let cell: TableCellWidget = prevRenderedRow.childWidgets[j] as TableCellWidget;
                                            if (tableRow.rowIndex < cell.ownerRow.rowIndex + cell.cellFormat.rowSpan) {
                                                cell.cellFormat.rowSpan--;
                                            }
                                        }
                                        prevRenderedRow = prevRenderedRow.previousRenderedWidget as TableRowWidget;
                                    }
                                    for (var j = 0; j < tableRow.childWidgets.length; j++) {
                                        let cell: TableCellWidget = tableRow.childWidgets[j] as TableCellWidget;
                                        let nextRenderedRow: TableRowWidget = tableRow.nextRenderedWidget as TableRowWidget;
                                        if (!isNullOrUndefined(nextRenderedRow)) {
                                            if (nextRenderedRow.rowIndex < cell.ownerRow.rowIndex + cell.cellFormat.rowSpan) {
                                                cell.cellFormat.rowSpan--;
                                                const cellWidget: TableCellWidget = this.createColumn(this.selection.getLastParagraph(cell));
                                                cellWidget.cellFormat.copyFormat(cell.cellFormat);
                                                cellWidget.index = cell.index;
                                                cellWidget.rowIndex = cell.rowIndex;
                                                cellWidget.columnIndex = cell.columnIndex;
                                                cellWidget.containerWidget = nextRenderedRow;
                                                cellWidget.margin = cell.margin.clone();
                                                cellWidget.leftBorderWidth = cell.leftBorderWidth;
                                                cellWidget.rightBorderWidth = cell.rightBorderWidth;
                                                nextRenderedRow.childWidgets.splice(cellWidget.columnIndex, 0, cellWidget);
                                            }
                                        }
                                        tableRow.childWidgets.splice(j, 1);
                                        j--;
                                    }
                                    tableRow.destroy();
                                }
                            }
                        }
                        if (table.childWidgets.length === 0) {
                            this.removeBlock(table);
                            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                                this.editorHistory.currentBaseHistoryInfo.action = 'DeleteTable';
                            }
                            table.destroy();
                        } else {
                            this.updateTable(table);
                        }
                    }
                }
            } else {
                if (this.owner.enableTrackChanges) {
                    this.trackRowDeletion(row, true, false);
                } else {
                    this.removeRow(row);
                }
            }
            if (!this.owner.enableTrackChanges || isNullOrUndefined(table.childWidgets)) {
                this.selection.selectParagraphInternal(paragraph, true);
            } else {
                let textPosition: TextPosition = this.selection.getTextPosBasedOnLogicalIndex(startIndex);
                this.selection.selectContent(textPosition, true);
                // this.selection.start.setPositionInternal(startPos);
                // this.selection.end.setPositionInternal(this.selection.start);
            }
            if (isNullOrUndefined(this.editorHistory) || this.checkIsNotRedoing()) {
                this.reLayout(this.selection, true);
                this.updateHistoryForComments(commentStart);
            }
        }
    }
    /**
     * @private
     */
    public trackRowDeletion(row: TableRowWidget, canremoveRow?: boolean, updateHistory?: boolean): boolean {
        let rowFormat: WRowFormat = row.rowFormat;
        if (!isNullOrUndefined(rowFormat)) {
            let canInsertRevision: boolean = true;
            if (rowFormat.revisionLength > 0) {
                let revision: Revision = this.retrieveRevisionInOder(rowFormat);
                if (revision.revisionType === 'Insertion') {
                    if (this.isRevisionMatched(rowFormat, undefined)) {
                        if (isNullOrUndefined(canremoveRow) || canremoveRow) {
                            this.removeRow(row);
                        } else {
                            this.removeRevisionsInRow(row);
                        }
                        return true;
                    }
                } else if (revision.revisionType === 'Deletion') {
                    this.unlinkRevisionFromItem(row.rowFormat);
                    if (this.owner.enableTrackChanges && !this.skipTracking()) {
                        canInsertRevision = true;
                    } else {
                        this.removeDeletedCellRevision(row);
                        canInsertRevision = false;
                    }
                }
            }
            if (canInsertRevision && !this.skipTracking()) {
                if ((isNullOrUndefined(updateHistory) || updateHistory) && this.editorHistory && this.editorHistory.currentBaseHistoryInfo && !this.isPasteOverWriteCells) {
                    this.editorHistory.currentBaseHistoryInfo.action = 'RemoveRowTrack';
                    if (this.owner.enableCollaborativeEditing) {
                        this.editorHistory.currentBaseHistoryInfo.createAcceptRejectRowOperation('RemoveRowTrack', rowFormat.ownerBase);
                    }
                }
                this.insertRevision(rowFormat, 'Deletion');
                this.updateLastDeletedRevision(row);
            }
            for (let i: number = row.childWidgets.length - 1; i >= 0; i--) {
                let cellWidget: TableCellWidget = row.childWidgets[i] as TableCellWidget;
                for (let j: number = cellWidget.childWidgets.length - 1; j >= 0; j--) {
                    if (cellWidget.childWidgets[j] instanceof TableWidget) {
                        // Following MS Word behavior: Delete/Backspace removes nested tables, hence canRemoveRow is set to true.
                        this.trackInnerTable(cellWidget.childWidgets[j] as TableWidget, true, updateHistory);
                    } else {
                        let paraWidget: ParagraphWidget = cellWidget.childWidgets[j] as ParagraphWidget;

                        // We used this boolean since for table tracking we should add removed nodes only for entire table not for every elements in the table
                        this.skipTableElements = true;
                        if (canInsertRevision && !this.skipTracking()) {
                            this.insertRevisionForBlock(paraWidget, 'Deletion', undefined, undefined, true, undefined, true);
                        }
                        this.skipTableElements = false;
                    }
                }
            }
        }
        return false;
    }
    private trackInnerTable(tableWidget: TableWidget, canremoveRow?: boolean, updateHistory?: boolean): any {
        for (let i: number = tableWidget.childWidgets.length - 1; i >= 0; i--) {
            this.trackRowDeletion(tableWidget.childWidgets[i] as TableRowWidget, canremoveRow, updateHistory);
        }
        if (tableWidget.childWidgets.length === 0) {
            this.removeBlock(tableWidget);
        } 
    }
    private removeRow(row: TableRowWidget): void {
        let table: TableWidget = row.ownerTable;
        this.removeRevisionsInRow(row);
        if (table.childWidgets.length === 1) {
            table.childWidgets.splice(table.childWidgets.indexOf(row), 1);
            // Skip setting action here, as 'ClearCells', 'RemoveRowTrack', and 'DeleteCells' already have appropriate history entries.
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo && this.editorHistory.currentBaseHistoryInfo.action !== 'InsertTable' && this.editorHistory.currentBaseHistoryInfo.action !== 'ClearCells' && this.editorHistory.currentBaseHistoryInfo.action !== 'RemoveRowTrack' && this.editorHistory.currentBaseHistoryInfo.action !== 'DeleteCells') {
                this.editorHistory.currentBaseHistoryInfo.action = 'Delete';
            }
        } else {
            this.removeFieldInBlock(row, true);
            table.childWidgets.splice(table.childWidgets.indexOf(row), 1);
            this.updateTable(table);
        }
    }
    /**
     * @private
     * @param {TableWidget} table Specifies the table widget
     * @returns {void}
     */
    public updateTable(table: TableWidget, skipCombine?: boolean): void {
        if (!skipCombine) {
            table = table.combineWidget(this.viewer) as TableWidget;
        }
        table.updateRowIndex(0);
        table.isGridUpdated = false;
        table.buildTableColumns();
        table.isGridUpdated = true;
        this.documentHelper.layout.reLayoutTable(table);
    }
    /**
     * @private
     * @param {TableWidget} table Specifies the table widget
     * @returns { ParagraphWidget }
     */
    public getParagraphForSelection(table: TableWidget): ParagraphWidget {
        let paragraph: ParagraphWidget = undefined;
        let nextWidget: Widget = table.nextWidget ? table.nextWidget : table.nextRenderedWidget;
        let previousWidget: Widget = table.previousWidget ? table.previousWidget : table.previousRenderedWidget;
        if (nextWidget) {
            paragraph = nextWidget instanceof ParagraphWidget ? nextWidget as ParagraphWidget
                : this.documentHelper.getFirstParagraphInFirstCell((nextWidget as TableWidget));
        } else if (previousWidget) {
            paragraph = previousWidget instanceof ParagraphWidget ? previousWidget as ParagraphWidget
                : this.documentHelper.getLastParagraphInLastCell((previousWidget as TableWidget));
        }
        return paragraph;
    }
    private deletePara(paragraph: ParagraphWidget, start: TextPosition, end: TextPosition, editAction: number): void {
        paragraph = paragraph.combineWidget(this.owner.viewer) as ParagraphWidget;
        let selection: Selection = this.documentHelper.selection;
        let paragraphStart: number = selection.getStartOffset(paragraph);
        let endParagraphStartOffset: number = selection.getStartOffset(end.paragraph);
        let startOffset: number = paragraphStart;
        let endOffset: number = 0;
        let isCombineNextParagraph: boolean = false;
        let lastLinelength: number = this.selection.getLineLength(paragraph.lastChild as LineWidget);
        let currentParagraph: ParagraphWidget = paragraph;
        let section: BodyWidget = paragraph.bodyWidget instanceof BodyWidget ? paragraph.bodyWidget as BodyWidget : undefined;
        let startLine: LineWidget = undefined;
        let endLineWidget: LineWidget = undefined;
        let isCombineLastBlock = this.combineLastBlock;
        let tempStartOffset : number;
        let isSelectionInsideTable: boolean = false;
        const startInlineObj = start.currentWidget.getInline(start.offset, 0);
        const startInline = startInlineObj.element;
        // BUG 926010: If multiple blocks are deleted into a single cell, then the entire table will be layout for each block deletion, which may lead to performance issues.
        // Therefore, we should layout the entire table only after the last block deletion.
        if (paragraph.isInsideTable && start.paragraph.isInsideTable) {
            isSelectionInsideTable = start.paragraph !== paragraph;
        }
        if (paragraph === start.paragraph) {
            startOffset = start.offset;
            startLine = start.currentWidget;
            tempStartOffset = startOffset;
            if ((startOffset + 1 === this.documentHelper.selection.getLineLength(paragraph.lastChild as LineWidget)) && isNullOrUndefined(paragraph.nextWidget)) {
                startOffset++;
            }
            if (end.paragraph.isInsideTable && (!this.owner.enableTrackChanges || this.skipTracking())) {
                isCombineNextParagraph = this.isEndInAdjacentTable(paragraph, end.paragraph);
            }
            if (!isCombineNextParagraph) {
                isCombineNextParagraph = this.combineLastBlock;
            }
            this.combineLastBlock = false;
        } else {
            startLine = paragraph.firstChild as LineWidget;
        }
        if (paragraph !== start.paragraph && selection.isSkipLayouting) {
            selection.isSkipLayouting = false;
        }
        if (paragraph === end.paragraph) {
            endLineWidget = end.currentWidget;
            endOffset = end.offset;
        } else {
            endLineWidget = paragraph.lastChild as LineWidget;
            endOffset = this.documentHelper.selection.getLineLength(paragraph.lastChild as LineWidget);
        }
        // If previous widget is splitted paragraph, combine paragraph widget.
        let block: BlockWidget = (!isNullOrUndefined(paragraph.previousRenderedWidget) && start.paragraph !== paragraph) ?
            paragraph.previousRenderedWidget.combineWidget(this.documentHelper.viewer) as BlockWidget : undefined;
        if (this.owner.enableTrackChanges && !isNullOrUndefined(block) && block instanceof TableWidget && paragraph.isEmpty() && isNullOrUndefined(paragraph.nextRenderedWidget)) {
            this.delBlockContinue = true;
            this.delBlock = block;
            return;
        }

        if (startOffset > paragraphStart && start.currentWidget === paragraph.lastChild &&
            startOffset === lastLinelength && (paragraph === end.paragraph && end.offset === startOffset + 1 ||
                paragraph.nextRenderedWidget === end.paragraph && end.offset === endParagraphStartOffset) ||
            (this.editorHistory && this.editorHistory.isUndoing && this.editorHistory.currentHistoryInfo &&
                this.editorHistory.currentHistoryInfo.action === 'PageBreak' && block && block.isPageBreak()
                && (startOffset === 0 && !start.currentWidget.isFirstLine || startOffset > 0)) ||
            start.paragraph !== end.paragraph && editAction === 2 && start.paragraph === paragraph && start.paragraph.nextWidget === end.paragraph && !this.owner.enableTrackChanges || !(paragraph.nextRenderedWidget instanceof TableWidget) && !isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && (((this.editorHistory.currentBaseHistoryInfo.isAcceptOrReject === 'Reject' || this.editorHistory.currentBaseHistoryInfo.action === 'Reject Change' || this.editorHistory.currentBaseHistoryInfo.isAcceptOrReject === 'Accept' || this.editorHistory.currentBaseHistoryInfo.action === 'Accept Change' || this.collabTrackAction) && ((start.paragraph === end.paragraph && end.currentWidget.isLastLine() && endOffset === selection.getLineLength(paragraph.lastChild as LineWidget) + 1) || (start.paragraph === paragraph && end.paragraph != paragraph)) && (!start.currentWidget.isFirstLine() || startOffset > paragraphStart)))) {
            isCombineNextParagraph = true;
        }
        if ((tempStartOffset + 1 === this.documentHelper.selection.getLineLength(paragraph.lastChild as LineWidget) && isNullOrUndefined(paragraph.nextWidget))) {
            startOffset--;
        }
        let paraEnd: TextPosition = end.clone();
        paraEnd.offset = paraEnd.offset - 1;
        // used the isRemoveInine property to skip the entire block (end of selection), removing and adding in history when inserting text.
        let isRemoveInline: boolean = false;
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && (this.editorHistory.currentBaseHistoryInfo.action === 'Insert' || this.editorHistory.currentBaseHistoryInfo.action === 'InsertTextParaReplace') && end.paragraph === paragraph && endOffset === selection.getLineLength(paragraph.lastChild as LineWidget) + 1) {
            isRemoveInline = true;
        }
        let paraReplace: boolean = (start.paragraph === paragraph && start.isAtParagraphStart && paraEnd.isAtParagraphEnd &&
            this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)
            && this.editorHistory.currentBaseHistoryInfo.action === 'Insert');
        if (paraReplace) {
            this.editorHistory.currentBaseHistoryInfo.action = 'InsertTextParaReplace';
            if (end.paragraph !== paragraph && this.owner.enableTrackChanges && editAction === 2) {
                paraReplace = false;
            }
        }
        let isStartParagraph: boolean = start.paragraph === paragraph;
         let isAcceptOrReject: boolean = (this.editorHistory && this.editorHistory.currentBaseHistoryInfo
            && (this.editorHistory.currentBaseHistoryInfo.action === 'Accept Change' || this.editorHistory.currentBaseHistoryInfo.isAcceptOrReject === "Accept"
                || this.editorHistory.currentBaseHistoryInfo.isAcceptOrReject === "Reject" || this.editorHistory.currentBaseHistoryInfo.action === 'Reject Change')) || this.collabTrackAction;
        if (end.paragraph === paragraph && end.currentWidget !== paragraph.lastChild ||
            (end.currentWidget === paragraph.lastChild && end.offset <= selection.getLineLength(paragraph.lastChild as LineWidget)) || paraReplace) {
            if (end.currentWidget.isFirstLine() && end.offset > paragraphStart || !end.currentWidget.isFirstLine() || paraReplace) {
                //If selection end with this paragraph and selection does not include paragraph mark.               
                this.removeInlines(paragraph, startLine, startOffset, endLineWidget, endOffset, editAction);
                //Removes the splitted paragraph.
            }
            if (!isNullOrUndefined(block) && !isStartParagraph && !paraReplace) {
                this.delBlockContinue = true;
                this.delBlock = block;
                let nextSection: BodyWidget = block.bodyWidget instanceof BodyWidget ? block.bodyWidget : undefined;
                if (nextSection && !section.equals(nextSection) && section.index !== nextSection.index) {
                    this.delSection = nextSection;
                } else {
                    this.delSection = undefined;
                }
            } else {
                this.delBlockContinue = false;
                this.delBlock = undefined;
            }
        } else if (start.paragraph === paragraph && (start.currentWidget !== paragraph.firstChild ||
            (start.currentWidget === paragraph.firstChild && startOffset > paragraphStart))) {
            // If selection start is after paragraph start
            //And selection does not end with this paragraph Or selection include paragraph mark.
            this.delBlockContinue = false;
            this.delBlock = undefined;
            if (editAction === 4) {
                return;
            } else {
                if (this.owner.enableTrackChanges && !this.skipTracking() && this.editorHistory.currentBaseHistoryInfo.action !== 'TOC' && this.editorHistory.currentBaseHistoryInfo.action !== 'Reject Change' && this.editorHistory.currentBaseHistoryInfo.action !== 'InsertHyperlink') {
                    // As per MS Word behavior: If the next widget is a table, and both the selection start and end are within the same paragraph,
                    // and the selection includes only the paragraph mark at the end, then no action should be taken (similar to MS Word's behavior).
                    if (!this.isSelectionBasedonEndRevision && end.paragraph === paragraph && paragraph.nextRenderedWidget instanceof TableWidget
                        && end.currentWidget === paragraph.lastChild && startOffset === lastLinelength && endOffset === lastLinelength + 1) {
                        // As per ms word behaviour, restrict the history preservation for this use case.
                        this.editorHistory.currentBaseHistoryInfo = undefined;
                        return;
                    }
                    let newParagraph: ParagraphWidget = new ParagraphWidget();
                    newParagraph.paragraphFormat.copyFormat(paragraph.paragraphFormat);
                    newParagraph.characterFormat.copyFormat(paragraph.characterFormat);
                    let lineWidget: LineWidget = new LineWidget(newParagraph);
                    newParagraph.childWidgets.push(lineWidget);
                    newParagraph.index = paragraph.index;
                    newParagraph.containerWidget = paragraph.containerWidget;
                    if (paragraph.lastChild === end.currentWidget && !isCombineNextParagraph) {
                        this.removeInlines(paragraph, startLine, startOffset, endLineWidget, endOffset, editAction);
                    } else if (isCombineNextParagraph) {
                        let canRemoveParaMark: boolean = this.handleDeleteParaMark(paragraph);
                        this.removeInlines(paragraph, startLine, startOffset, endLineWidget, endOffset, editAction, newParagraph);
                        // If we delete the paragraph inserted by the same user, we need to remove the paragraph mark and combine it with the next paragraph.
                        if (canRemoveParaMark) {
                            this.deleteParagraphMark(paragraph, selection, editAction, false);
                        }
                        this.addRemovedNodes(newParagraph);
                    } else {
                        this.handleDeleteParaMark(paragraph, true);
                        this.removeInlines(paragraph, startLine, startOffset, endLineWidget, endOffset, editAction, newParagraph);
                        this.addRemovedNodes(newParagraph);
                    }
                } else {
                    if (paragraph.lastChild === end.currentWidget && !isCombineNextParagraph && !isAcceptOrReject) {
                        this.removeInlines(paragraph, startLine, startOffset, endLineWidget, endOffset, editAction);
                    } else {
                        if (isAcceptOrReject && end.paragraph !== paragraph && isCombineNextParagraph) { 
                            isCombineLastBlock = true;
                        }
                        currentParagraph = this.splitParagraph(paragraph, paragraph.firstChild as LineWidget, 0, startLine, startOffset, true, true, isSelectionInsideTable);
                        if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && this.editorHistory.currentBaseHistoryInfo.isSameUserDeleteParaMark) {
                            for (let i: number = 0; i < paragraph.characterFormat.revisionLength; i++) {
                                const revision: Revision = paragraph.characterFormat.getRevision(i);
                                if (currentParagraph.characterFormat.getAllRevision().indexOf(revision) === -1) {
                                    currentParagraph.characterFormat.addRevision(revision);
                                }
                            }
                        }
                        this.insertParagraphPaste(paragraph, currentParagraph, start, end, this.isDeleteTrackedContent ? false : isCombineNextParagraph, editAction, isCombineLastBlock);
                        this.removeRevisionForBlock(paragraph, false, true);
                        if (!isNullOrUndefined(this.owner.editorHistory) && !isNullOrUndefined(this.owner.editorHistory.currentBaseHistoryInfo) && this.owner.editorHistory.currentBaseHistoryInfo.action === 'Paste' && this.owner.editorHistory.historyInfoStack.length > 0 && this.owner.editorHistory.historyInfoStack[0].action === 'DragAndDropContent') {
                            this.addRemovedNodes(paragraph.clone());
                            this.removeFieldInBlock(paragraph);
                            this.removeFieldInBlock(paragraph, true);
                            this.removeFieldInBlock(paragraph, undefined, true);
                            this.removeCommentsInBlock(paragraph);
                        } else {
                            this.addRemovedNodes(paragraph);
                        }
                        isCombineLastBlock = false;
                    }
                }
                return;
            }
        } else {
            // As per ms word behaviour, if the next widget is a table, then only remove the inlines.
            if (!this.isSelectionBasedonEndRevision && end.paragraph === paragraph && !paragraph.isEmpty() && paragraph.nextRenderedWidget instanceof TableWidget && !isAcceptOrReject && !this.isRemoteAction && !isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && this.editorHistory.currentBaseHistoryInfo.action !== 'Enter') {
                //In collaborative editing due to selection of para mark then length will be extra one.
                if (this.owner.enableCollaborativeEditing && this.selection.getLineLength(endLineWidget) + 1 == endOffset && this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                    this.editorHistory.currentBaseHistoryInfo.endIndex -= 1;
                }
                this.removeInlines(paragraph, startLine, startOffset, endLineWidget, endOffset, editAction);
            } else {
                if (startInline instanceof ContentControl && startInline.type == 0 && startInline.contentControlProperties.lockContents && startInline.paragraph == paragraph && startInline.reference instanceof ContentControl && startInline.paragraph != startInline.reference.paragraph) {
                    this.removedContentControlElements.push(startInline);
                }
                if ((!(this.owner.enableTrackChanges && !this.skipTracking()) && !(!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && this.editorHistory.currentBaseHistoryInfo.endRevisionLogicalIndex) && end.paragraph === paragraph && end.paragraph.isInsideTable && (start.currentWidget.isFirstLine() && start.offset > selection.getStartOffset(start.paragraph) || !start.currentWidget.isFirstLine()) &&
                    end.offset >= selection.getLineLength(end.paragraph.lastChild as LineWidget) && end.paragraph.nextRenderedWidget as ParagraphWidget) && !this.owner.documentHelper.isDragging) {
                    this.combineLastBlock = true;
                }
                let newParagraph: ParagraphWidget = undefined;
                let previousBlock: BlockWidget = paragraph.previousWidget as BlockWidget;
                let prevParagraph: ParagraphWidget = (previousBlock instanceof ParagraphWidget) ? previousBlock : undefined;
                if (editAction < 4) {
                    let skipParaMarkdeletion: boolean = false;
                    const isLastParagraph = (paragraph == this.getLastParaForBodywidgetCollection(paragraph));
                    if (isLastParagraph && paragraph === start.paragraph && !paragraph.isInsideTable && !isNullOrUndefined(paragraph.containerWidget) && isNullOrUndefined(paragraph.containerWidget.containerWidget) && this.editorHistory && this.editorHistory.currentBaseHistoryInfo && this.editorHistory.currentBaseHistoryInfo.action !== 'Delete' && this.editorHistory.currentBaseHistoryInfo.action !== 'Enter') {
                        skipParaMarkdeletion = true;
                    }
                    //Checks whether this is last paragraph of owner text body and previousBlock is not paragraph.
                    if (this.owner.enableTrackChanges && !this.skipTracking() && this.editorHistory.currentBaseHistoryInfo && this.editorHistory.currentBaseHistoryInfo.action !== 'TOC' && this.editorHistory.currentBaseHistoryInfo.action !== 'InsertHyperlink') {
                        //Here we need to check only the paramark is going to be deleted or not, so the thid parameter(checkOnlyIfParaMarkCanBeRemoved) was passed as true. Because, the revisions will be removed or inserted in the insertRevisionForBlock method.
                        let canRemoveParaMark: boolean = this.handleDeleteParaMark(paragraph, false, true);
                        if (canRemoveParaMark && !isLastParagraph && !paragraph.isInsideTable && paragraph.nextRenderedWidget instanceof ParagraphWidget && paragraph.bodyWidget.sectionIndex !== paragraph.nextRenderedWidget.bodyWidget.sectionIndex) {
                            this.deleteSection(selection, paragraph.bodyWidget, paragraph.nextRenderedWidget.bodyWidget, editAction);
                        }
                        this.insertRevisionForBlock(paragraph, 'Deletion', undefined, undefined, undefined, isRemoveInline);
                        if (start.paragraph !== paragraph && !isNullOrUndefined(block)) {
                            this.delBlockContinue = true;
                            this.delBlock = block;
                            return;
                        }

                    } else {
                        newParagraph = this.checkAndInsertBlock(paragraph, start, end, editAction, prevParagraph);
                        this.removeRevisionForBlock(paragraph, false, true);
                        //Checked again that the current paragraph is the last paragraph, because if a new paragraph is added, the current paragraph will no longer be the last 
                        const isLastChild = (paragraph == this.getLastParaForBodywidgetCollection(paragraph));
                        // Added the condition to skip to add entair paragraph (with para mark) into history if the current widget has the last widget. 
                        if (!isNullOrUndefined(newParagraph) || !isLastChild) {
                            skipParaMarkdeletion = false;
                        }
                        let isRemoved: boolean = false;
                        if ((this.owner.enableTrackChanges || skipParaMarkdeletion) && (isLastChild || isRemoveInline)) {
                            for (let i: number = paragraph.childWidgets.length - 1; i > -1; i--) {
                                let line: LineWidget = (paragraph.childWidgets[i]) as LineWidget;
                                this.removeContent(line, 0, this.documentHelper.selection.getLineLength(line), undefined, false);
                            }
                            this.removeEmptyLine(paragraph);
                            isRemoved = true;
                        } else {
                            // Added the condition to remove section if current and next para have different section indexes if selection is covered till the end of first section.
                            let nextParagraph: ParagraphWidget = this.selection.getNextParagraphBlock(paragraph);
                            if (!isLastChild && !paragraph.isInsideTable && !isNullOrUndefined(nextParagraph) && paragraph.bodyWidget.sectionIndex !== nextParagraph.bodyWidget.sectionIndex) {
                                this.deleteSection(selection, paragraph.bodyWidget, nextParagraph.bodyWidget, editAction);
                                isStartParagraph = true;
                            }
                            this.addRemovedNodes(paragraph.clone());
                        }
                        if (!isNullOrUndefined(block) && !isStartParagraph && !paraReplace) {
                            this.delBlock = block;
                            let nextSection: BodyWidget = block.bodyWidget instanceof BodyWidget ? block.bodyWidget : undefined;
                            if (nextSection && section.index !== nextSection.index) {
                                let bodyWidget: BodyWidget = paragraph.bodyWidget instanceof BodyWidget ? paragraph.bodyWidget : undefined;
                                this.deleteSection(selection, nextSection, bodyWidget, editAction);
                            }
                        }
                        if (!isRemoved) {
                            this.removeBlock(paragraph, undefined, undefined, isSelectionInsideTable);
                        }
                    }
                    if (this.documentHelper.blockToShift === paragraph) {
                        this.documentHelper.blockToShift = undefined;
                    }
                    if (!isNullOrUndefined(newParagraph)) {
                        selection.editPosition = this.selection.getHierarchicalIndex(newParagraph, '0');
                        let offset: number = selection.getParagraphLength(newParagraph) + 1;
                        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                            this.editorHistory.currentBaseHistoryInfo.endPosition = this.selection.getHierarchicalIndex(newParagraph, offset.toString());
                        }
                    } else if (paragraph === start.paragraph && !this.isInsertingTOC) {
                        let offset: number;
                        if (paragraph.indexInOwner > -1) {
                            if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && this.editorHistory.currentBaseHistoryInfo.action === 'Delete') {
                                if (isLastParagraph || (!isNullOrUndefined(paragraph.nextRenderedWidget) && paragraph.nextRenderedWidget instanceof TableWidget)) {
                                    if (!isNullOrUndefined(paragraph.containerWidget)) {
                                        offset = this.selection.getParagraphLength(paragraph);
                                        selection.editPosition = this.selection.getHierarchicalIndex(paragraph, offset.toString());
                                    }
                                }
                                else {
                                    if (!isNullOrUndefined(paragraph.nextRenderedWidget) && paragraph.nextRenderedWidget instanceof ParagraphWidget) {
                                        offset = this.selection.getStartOffset(paragraph.nextRenderedWidget);
                                        selection.editPosition = this.selection.getHierarchicalIndex(paragraph.nextRenderedWidget, offset.toString());
                                    }
                                }
                            }
                        }
                        else if (paragraph.indexInOwner === -1 && isLastParagraph) {
                            offset = this.selection.getParagraphLength(prevParagraph);
                            selection.editPosition = this.selection.getHierarchicalIndex(prevParagraph, offset.toString());
                            //In this case the last para was deleted so we need to update the insert position also
                            if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                                this.editorHistory.currentBaseHistoryInfo.insertPosition = selection.editPosition;
                            }
                        }
                        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                            this.updateHistoryPosition(this.editorHistory.currentBaseHistoryInfo.insertPosition, false);
                        }
                    }
                }
            }
            if (start.paragraph !== paragraph && !isNullOrUndefined(block)) {
                this.delBlockContinue = true;
                this.delBlock = block;
            } else {
                this.delBlockContinue = false;
                this.delBlock = undefined;
            }
        }
        this.insertParagraphPaste(paragraph, currentParagraph, start, end, isCombineNextParagraph, editAction, isCombineLastBlock);
    }
    private deleteSection(selection: Selection, section: BodyWidget, nextSection: BodyWidget, editAction: number): void {
        if (editAction < 4) {
            if (this.owner.enableCollaborativeEditing) {
                let paragraphInfo: ParagraphInfo;
                let positionInfo: AbsolutePositionInfo;
                // Find the start linear index of deleted HeadersFooters
                let headerFooterWidget: HeaderFooterWidget = this.owner.documentHelper.headersFooters[section.sectionIndex]['0'];
                if (!isNullOrUndefined(headerFooterWidget)) {
                    paragraphInfo = { 'paragraph': headerFooterWidget.firstChild as ParagraphWidget, 'offset': 0 };
                    positionInfo = this.owner.selectionModule.getPositionInfoForHeaderFooter(paragraphInfo, { position: 0, done: false });
                    this.editorHistory.currentBaseHistoryInfo.headerFooterStart = positionInfo.position;
                }
                // Find the end linear index of deleted HeadersFooters
                let keyCount: number = Object.keys(this.owner.documentHelper.headersFooters[section.sectionIndex]).length;
                if (keyCount > 0) {    
                    headerFooterWidget = this.owner.documentHelper.headersFooters[section.sectionIndex][(keyCount-1).toString()];
                    if (!isNullOrUndefined(headerFooterWidget)) {                
                        let paraLength: number = this.owner.selectionModule.getParagraphLength(headerFooterWidget.lastChild as ParagraphWidget);
                        paragraphInfo = { 'paragraph': headerFooterWidget.lastChild as ParagraphWidget, 'offset': paraLength + 1 };
                        positionInfo = this.owner.selectionModule.getPositionInfoForHeaderFooter(paragraphInfo, { position: 0, done: false });
                        this.editorHistory.currentBaseHistoryInfo.headerFooterEnd = positionInfo.position;
                    }
                }
            }

            this.combineSectionInternal(selection, section, nextSection);
        }
        //Copies the section properties, if this is last paragraph of section.
        if (editAction > 2) {
            section.sectionFormat.copyFormat(nextSection.sectionFormat);
        }
    }

    /**
     * 
     * @private
     */
    public combineSectionInternal(selection: Selection, section: BodyWidget, nextSection: BodyWidget): void {
        // if (section.sectionFormat.isEqualFormat(nextSection.sectionFormat)) {

        // } else {
        let bodyWidget: BodyWidget = section.getSplitWidgets()[0] as BodyWidget;
        let currentSection: BodyWidget[] = [];
        let previousY: number = bodyWidget.y;
        this.documentHelper.combineSectionChild(bodyWidget, currentSection, true);
        bodyWidget = currentSection[0];
        let lastBlockIndex: number = (bodyWidget.lastChild as BlockWidget).index;
        this.updateBlockIndex(lastBlockIndex + 1, nextSection.firstChild as BlockWidget);
        let insertIndex: number = 0;
        if (this.viewer instanceof PageLayoutViewer) {
            nextSection.page.headerWidget = (this.viewer as PageLayoutViewer).getCurrentPageHeaderFooter(nextSection, true);
            nextSection.page.footerWidget = (this.viewer as PageLayoutViewer).getCurrentPageHeaderFooter(nextSection, false);
        }
        let containerWidget: BodyWidget = nextSection;
        containerWidget.y = previousY;
        for (let i: number = 0; i < bodyWidget.childWidgets.length; i++) {
            let block: BlockWidget = bodyWidget.childWidgets.splice(i, 1)[0] as BlockWidget;
            containerWidget.childWidgets.splice(insertIndex, 0, block);
            block.containerWidget = containerWidget;
            this.documentHelper.layout.layoutBodyWidgetCollection(block.index, block.bodyWidget, block, false);
            block = block.getSplitWidgets().pop() as BlockWidget;
            containerWidget = block.containerWidget as BodyWidget;
            insertIndex = block.indexInOwner + 1;
            i--;
        }
        if (bodyWidget.sectionIndex >= 0 && this.documentHelper.headersFooters[bodyWidget.sectionIndex]) {
            const sectionIndex: number = bodyWidget.sectionIndex;
            const currentHeaderFooters: HeaderFooters = this.documentHelper.headersFooters[sectionIndex];
            const nextHeaderFooters: HeaderFooters = this.documentHelper.headersFooters[sectionIndex + 1];
            const currentHasHeaderFooters: boolean = !isNullOrUndefined(currentHeaderFooters) && Object.keys(currentHeaderFooters).length > 0;
            const nextHasHeaderFooters: boolean = !isNullOrUndefined(nextHeaderFooters) && Object.keys(nextHeaderFooters).length > 0;
            if(currentHasHeaderFooters && !isNullOrUndefined(nextHeaderFooters) && !nextHasHeaderFooters){
                this.documentHelper.headersFooters[sectionIndex + 1] = currentHeaderFooters;
            }
            if (!currentHasHeaderFooters || nextHasHeaderFooters || (!isNullOrUndefined(nextHeaderFooters) && !nextHasHeaderFooters)) {
                bodyWidget.removedHeaderFooters = [];
                let headerFooters: HeaderFooters = this.documentHelper.headersFooters.splice(sectionIndex, 1)[0];
                let keys: string[] = Object.keys(headerFooters);
                for (let i: number = 0; i < keys.length; i++) {
                    let headerWidgetIn: HeaderFooterWidget = headerFooters[keys[i]];
                    //if (headerWidgetIn.page) {
                    this.removeFieldInWidget(headerWidgetIn);
                    // Remove content control
                    this.removeFieldInWidget(headerWidgetIn, false, true);
                    //}
                    headerWidgetIn.page = undefined;
                }
                bodyWidget.removedHeaderFooters.push(headerFooters);
            }
        }
        this.updateSectionIndex(undefined, nextSection, false);
        this.addRemovedNodes(bodyWidget);
        this.documentHelper.removeEmptyPages();
        if (this.editorHistory && this.editorHistory.isUndoing && !(this.editorHistory.currentBaseHistoryInfo && (this.editorHistory.currentBaseHistoryInfo.endRevisionLogicalIndex || this.editorHistory.currentBaseHistoryInfo.lastDeletedNodeRevision))) {
            nextSection.sectionFormat = section.sectionFormat; 
        }
        let page = nextSection.page;
        do {
            this.documentHelper.layout.layoutHeaderFooter(page.bodyWidgets[0], this.viewer as PageLayoutViewer, page); 
            page = page.nextPage;
        } while(page);
         if (this.documentHelper.blockToShift && this.documentHelper.blockToShift.containerWidget instanceof BodyWidget && this.documentHelper.blockToShift.containerWidget.sectionFormat.columns.length === 0) {
            this.documentHelper.layout.shiftLayoutedItems(false, undefined, true);
        }
        // }
    }
    /* eslint-disable max-len */
    private checkAndInsertBlock(block: BlockWidget, start: TextPosition, end: TextPosition, editAction: number, previousParagraph: BlockWidget): ParagraphWidget {
        if (block instanceof ParagraphWidget && block === start.paragraph || block instanceof TableWidget) {
            let newParagraph: ParagraphWidget; //Adds an empty paragraph, to ensure minimal content.
            if (isNullOrUndefined(block.nextRenderedWidget) && (isNullOrUndefined(previousParagraph) || previousParagraph.nextRenderedWidget instanceof TableWidget)) {
                newParagraph = new ParagraphWidget();
                if (editAction === 1 && block instanceof ParagraphWidget && !isNullOrUndefined(block.paragraphFormat.baseStyle) && block.paragraphFormat.baseStyle.name === 'Normal') {
                    newParagraph.characterFormat.copyFormat(block.characterFormat);
                    // Added the condition to remove removedIds when document contain single empty paragraph
                    if (isNullOrUndefined(block.previousRenderedWidget) && newParagraph.characterFormat.removedIds.length !== 0) {
                        while (newParagraph.characterFormat.removedIds.length > 0) {
                            newParagraph.characterFormat.removedIds.splice(0, 1);
                        }
                    }
                    newParagraph.paragraphFormat.copyFormat(block.paragraphFormat);
                }
                newParagraph.index = block.index + 1;
                newParagraph.containerWidget = block.containerWidget;
                if (block instanceof ParagraphWidget) {
                    newParagraph.paragraphFormat.lineSpacing = block.paragraphFormat.lineSpacing;
                    newParagraph.paragraphFormat.lineSpacingType = block.paragraphFormat.lineSpacingType;
                    let style: Object = this.documentHelper.styles.findByName('Normal');
                    if (!isNullOrUndefined(style)) {
                        (newParagraph.paragraphFormat.baseStyle as WParagraphStyle) = new WParagraphStyle();
                        (newParagraph.paragraphFormat.baseStyle as WParagraphStyle).copyStyle(style as WParagraphStyle);
                    }
                }
                if (!this.owner.enableLayout) {
                    this.documentHelper.layout.addLineWidget(newParagraph);
                }
                this.documentHelper.layout.layoutBodyWidgetCollection(newParagraph.index, newParagraph.bodyWidget, newParagraph, false);
                if (block.containerWidget instanceof Widget) {
                    block.containerWidget.childWidgets.push(newParagraph);
                }
            }
            return newParagraph;
        }
        return undefined;
    }

    private splitParagraph(paragraphAdv: ParagraphWidget, startLine: LineWidget, startOffset: number, endLine: LineWidget, endOffset: number, removeBlock: boolean, skipElementRemoval?: boolean, isSelectionInsideTable?: boolean): ParagraphWidget {
        let paragraph: ParagraphWidget = new ParagraphWidget();
        paragraph.paragraphFormat = new WParagraphFormat(paragraph);
        paragraph.characterFormat = new WCharacterFormat(paragraph);
        paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
        paragraph.characterFormat.copyFormat(paragraphAdv.characterFormat);
        paragraph.characterFormat.removedIds = [];
        let lineWidget: LineWidget = new LineWidget(paragraph);
        paragraph.childWidgets.push(lineWidget);
        let blockIndex: number = paragraphAdv.index;
        let insertIndex: number = paragraphAdv.indexInOwner;
        this.moveInlines(paragraphAdv, paragraph, 0, startOffset, startLine, endOffset, endLine, removeBlock);
        if (paragraphAdv.containerWidget.childWidgets[insertIndex]) {
            let bookmarks: BookmarkElementBox[] = [];
            let line: BlockWidget = ((paragraphAdv.containerWidget.childWidgets[insertIndex] as ParagraphWidget));
            for (let i: number = 0; i < line.childWidgets.length; i++) {
                let linewid: LineWidget = line.childWidgets[i] as LineWidget
                for (let j: number = 0; j < linewid.children.length; j++) {
                    let inline: ElementBox = linewid.children[j];
                    if (inline instanceof FootnoteElementBox) {
                        this.removeFootnote(inline);
                    } else if (inline instanceof BookmarkElementBox && removeBlock) {
                        if (!this.owner.enableTrackChanges || this.owner.enableTrackChanges && this.skipTracking()) {
                            if (!(this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing))) {
                                if (inline instanceof BookmarkElementBox) {
                                    bookmarks.push(inline);
                                }
                            }
                            if (inline instanceof BookmarkElementBox) {
                                if (this.documentHelper.bookmarks.containsKey(inline.name)) {
                                    if (this.owner.enableCollaborativeEditing && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                                        this.editorHistory.currentBaseHistoryInfo.markerData.push({ bookmarkName: inline.name });
                                    }
                                    this.documentHelper.bookmarks.remove(inline.name);
                                }
                            }
                        }
                    }
                }
            }
            for (let i: number = bookmarks.length - 1; i >= 0; i--) {
                if (this.removedBookmarkElements.indexOf(bookmarks[i]) === -1) {
                    this.removedBookmarkElements.push(bookmarks[i]);
                }
            }
        }
        //Inserts new paragraph in the current text position.
        paragraphAdv.containerWidget.childWidgets.splice(insertIndex, 0, paragraph);
        paragraph.index = blockIndex;
        paragraph.containerWidget = paragraphAdv.containerWidget;
        this.updateNextBlocksIndex(paragraph, true);
        this.updateRevisionForSplittedPara(paragraph, paragraphAdv);
        if (removeBlock) {
            this.removeBlock(paragraphAdv, undefined, skipElementRemoval, isSelectionInsideTable);
        }

        this.documentHelper.layout.layoutBodyWidgetCollection(blockIndex, paragraph.containerWidget as BodyWidget, paragraph, false);
        return paragraph;
    }

    private removeCommentsInBlock(block: BlockWidget): void {
        if (block instanceof TableWidget) {
            for (let i: number = 0; i < block.childWidgets.length; i++) {
                let row: TableRowWidget = block.childWidgets[i] as TableRowWidget;
                for (let j: number = 0; j < row.childWidgets.length; j++) {
                    let cell: TableCellWidget = row.childWidgets[j] as TableCellWidget;
                    for (let k: number = 0; k < cell.childWidgets.length; k++) {
                        let block: BlockWidget = cell.childWidgets[k] as BlockWidget;
                        this.removeCommentsInBlock(block);
                    }
                }
            }
        } else {
            this.removeCommentInPara(block as ParagraphWidget);
        }
    }

    private removeCommentInPara(block: ParagraphWidget): void {
        for (let i: number = 0; i < block.childWidgets.length; i++) {
            let lineWidget: LineWidget = block.childWidgets[i] as LineWidget;
            //Iterate through each line widgets.
            for (let j: number = 0; j < lineWidget.children.length; j++) {
                this.removeCommentsInline(lineWidget.children[j] as ElementBox);
            }
        }
    }

    private removeCommentsInline(inline: ElementBox) {
        if (inline instanceof CommentCharacterElementBox) {
            if (inline.commentType === 1) {
                // if (!inline.comment.isReply) {
                //     for (let i: number = 0; i < inline.comment.replyComments.length; i++) {
                //         this.removeCommentsInline(inline.comment.replyComments[i].commentEnd);
                //     }
                // }
                // if (inline.comment.commentStart && inline.comment.commentStart.commentMark) {
                //     inline.comment.commentStart.removeCommentMark();
                // }
                // if (!inline.comment.isReply && this.documentHelper.comments.indexOf(inline.comment) >= 0
                //     || inline.comment.isReply && this.documentHelper.comments.indexOf(inline.comment.ownerComment) >= 0) {
                //     this.deleteCommentWidget(inline.comment);
                // }
            } else {
                inline.removeCommentMark();
            }
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public removeBlock(block: BlockWidget, isSkipShifting?: boolean, skipElementRemoval?: boolean, isSelectionInsideTable?: boolean, isRemoveRevision?: boolean): void {
        let index: number;
        let blockCollection: IWidget[];
        let containerWidget: Widget;
        if (!skipElementRemoval) {
            this.removeFieldInBlock(block);
            this.removeFieldInBlock(block, true);
            this.removeFieldInBlock(block, undefined, true);
            this.removeFieldInBlock(block, undefined, undefined, true);
            this.removeCommentsInBlock(block);
        }
        
        if (block.isInsideTable) {
            containerWidget = block.associatedCell;
            this.checkToCombineRevisionsInPane(block);
            if (isRemoveRevision) {
                this.checkAndRemoveRevisionFromBlock(block);
            }
            index = block.associatedCell.childWidgets.indexOf(block);
            blockCollection = block.associatedCell.childWidgets;
            this.updateNextBlocksIndex(block, false);
            block.associatedCell.childWidgets.splice(index, 1);
            block.containerWidget = undefined;
            this.documentHelper.layout.layoutBodyWidgetCollection(block.index, containerWidget, block, false, undefined, isSelectionInsideTable);
        } else {
            containerWidget = block.containerWidget;
            this.checkToCombineRevisionsInPane(block);
            if (isRemoveRevision) {
                this.checkAndRemoveRevisionFromBlock(block);
            }
            index = containerWidget.childWidgets.indexOf(block);
            blockCollection = containerWidget.childWidgets;
            this.updateNextBlocksIndex(block, false);
            containerWidget.childWidgets.splice(index, 1);
            block.containerWidget = undefined;
            containerWidget.height -= block.height;
            if (!isNullOrUndefined(containerWidget.containerWidget) && containerWidget.containerWidget instanceof FootNoteWidget) {
                containerWidget.containerWidget.height -= block.height;
            }
            this.documentHelper.layout.layoutBodyWidgetCollection(block.index, containerWidget, block, false, isSkipShifting, isSelectionInsideTable);
        }
    }
    private checkToCombineRevisionsInPane(block: BlockWidget): void {
        let previousBlock: BlockWidget = block.previousRenderedWidget as BlockWidget;
        let nextBlock: BlockWidget = block.nextRenderedWidget as BlockWidget;
        if (previousBlock instanceof ParagraphWidget && nextBlock instanceof ParagraphWidget) {
            let previousBlockCharacterFormat: WCharacterFormat = previousBlock.characterFormat;
            let nextBlockFirstElement: ElementBox | WCharacterFormat = !isNullOrUndefined(nextBlock.firstChild) ? !isNullOrUndefined((nextBlock.firstChild as LineWidget).children[0]) ? (nextBlock.firstChild as LineWidget).children[0] : nextBlock.characterFormat : undefined;
            if (!isNullOrUndefined(previousBlockCharacterFormat) && !isNullOrUndefined(nextBlockFirstElement)) {
                let previousBlockRevisions: Revision[] = previousBlockCharacterFormat.getAllRevision();
                let nextBlockRevisions: Revision[] = nextBlockFirstElement.getAllRevision();
                for (let i: number = 0; i < previousBlockRevisions.length; i++) {
                    for (let j: number = 0; j < nextBlockRevisions.length; j++) {
                        if (this.compareTwoRevisions(previousBlockRevisions[i], nextBlockRevisions[j])) {
                            this.owner.revisions.combineWithNextRevision(previousBlockRevisions[i], nextBlockRevisions[j]);
                        }
                    }
                }
            }
        }
    }
    private checkAndRemoveRevisionFromBlock(block: BlockWidget) {
        if (block instanceof TableWidget) {
            for (let i: number = 0; i < block.childWidgets.length; i++) {
                let row: TableRowWidget = block.childWidgets[i] as TableRowWidget;
                this.addRemovedRevisionInfo(row.rowFormat);
                this.removeRevisionsInRow(row, true, true);
            }
        } else if (block instanceof ParagraphWidget) {
            this.removeRevisionForBlock(block, false, true);
        }
    }
    private removePrevParaMarkRevision(currentBlock: BlockWidget, isFromDelete?: boolean, addRemovedIDs?: boolean): void {
        isFromDelete = isNullOrUndefined(isFromDelete) ? false : isFromDelete;
        if (this.owner.enableTrackChanges || (currentBlock as ParagraphWidget).characterFormat.revisionLength != 0) {
            let currentPara: ParagraphWidget = currentBlock as ParagraphWidget;
            let rangeIndex: number = -1;
            let revision: Revision;
            let nonEmptyEndPara: ParagraphWidget = currentPara;
            if (!isFromDelete && !isNullOrUndefined(nonEmptyEndPara.previousRenderedWidget)) {
                nonEmptyEndPara = nonEmptyEndPara.previousRenderedWidget as ParagraphWidget;
            }
            if (nonEmptyEndPara.characterFormat.revisionLength > 0) {
                revision = nonEmptyEndPara.characterFormat.getRevision(nonEmptyEndPara.characterFormat.revisionLength - 1);
                rangeIndex = 0;
            }
            if (rangeIndex >= 0 && !isNullOrUndefined(revision)) {
                let lastRange: WCharacterFormat = revision.getRange()[rangeIndex] as WCharacterFormat;
                let isParaMark: boolean = lastRange instanceof WCharacterFormat;
                if (isParaMark) {
                    //revision.range.splice(rangeIndex, 1);
                    this.owner.trackChangesPane.updateCurrentTrackChanges(revision);
                    if (nonEmptyEndPara.characterFormat && nonEmptyEndPara.characterFormat.getAllRevision().indexOf(revision) > -1) {
                        if (addRemovedIDs) {
                            (currentBlock as ParagraphWidget).characterFormat.removedIds.push(revision.revisionID);
                        }
                        nonEmptyEndPara.characterFormat.removeRevision(nonEmptyEndPara.characterFormat.getAllRevision().indexOf(revision));
                    }
                    if (revision.getRange().length == 0) {
                        this.owner.revisionsInternal.remove(revision);
                    }
                }
            }
        }
    }
    private isPasteRevertAction(): boolean {
        if (!isNullOrUndefined(this.editorHistory) && this.editorHistory.currentBaseHistoryInfo && this.editorHistory.currentBaseHistoryInfo.action === 'Paste') {
            return true;
        }
        return false;
    }
    private toCheckForTrack(block: BlockWidget, end: TextPosition): boolean {
        if (this.owner.enableTrackChanges) {
            if (block instanceof TableWidget && block.childWidgets.length > 0) {
                let considerPreviousRows: boolean = false;
                for (let i: number = block.childWidgets.length - 1; i >= 0; i--) {
                    let rowWidget: TableRowWidget = block.childWidgets[i] as TableRowWidget;
                    if (end.paragraph.isInsideTable && this.owner.selectionModule.containsRow(rowWidget, end.paragraph.associatedCell) || considerPreviousRows) {
                        if (!(rowWidget.rowFormat.revisionLength > 0 && rowWidget.rowFormat.getRevision(0).revisionType === 'Insertion'
                            && rowWidget.rowFormat.getRevision(0).author === (this.owner.currentUser === '' ? 'Guest user' : this.owner.currentUser))) {
                            return true;
                        }
                        considerPreviousRows = true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * @private
     */
    public removeFootnote(element: FootnoteElementBox, paragraph?: ParagraphWidget): void {
        if (element.paragraph.bodyWidget.page.footnoteWidget) {
            let footnoteWidget: FootNoteWidget = element.paragraph.bodyWidget.page.footnoteWidget;
            for (let j: number = 0; j < footnoteWidget.bodyWidgets.length; j++) {
                if (element === (footnoteWidget.bodyWidgets[j]).footNoteReference) {
                    footnoteWidget.height -= (footnoteWidget.bodyWidgets[j].childWidgets[0] as BlockWidget).height;
                    if (this.owner.enableTrackChanges) {
                        for (let i: number = 0; i < footnoteWidget.bodyWidgets[j].childWidgets.length; i++) {
                            this.removeRevisionForBlock(footnoteWidget.bodyWidgets[j].childWidgets[i] as ParagraphWidget, false, true);
                        }
                    }
                    footnoteWidget.bodyWidgets.splice(j, 1);
                    j--;
                    this.isFootnoteElementRemoved = true;
                }
            }
            if (footnoteWidget.bodyWidgets.length === 0) {
                element.paragraph.bodyWidget.page.footnoteWidget = undefined;
            }
        }
        this.documentHelper.footnoteCollection.splice(this.documentHelper.footnoteCollection.indexOf(element), 1);
        this.updateFootNoteIndex();
    }
    /**
     * @private
     */
    public removeEndnote(element: FootnoteElementBox, paragraph?: ParagraphWidget): void {
        const lastpage = this.documentHelper.pages.length;
        const bodyWidget = this.documentHelper.pages[lastpage - 1].bodyWidgets[0];
        if (bodyWidget.page.endnoteWidget) {
            let endnoteWidget: FootNoteWidget = bodyWidget.page.endnoteWidget;
            for (let j: number = 0; j < endnoteWidget.bodyWidgets.length; j++) {
                if (element === (endnoteWidget.bodyWidgets[j]).footNoteReference) {
                    endnoteWidget.height -= (endnoteWidget.bodyWidgets[j].childWidgets[0] as BlockWidget).height;
                    if (this.owner.enableTrackChanges) {
                        for (let i: number = 0; i < endnoteWidget.bodyWidgets[j].childWidgets.length; i++) {
                            this.removeRevisionForBlock(endnoteWidget.bodyWidgets[j].childWidgets[i] as ParagraphWidget, false, true);
                        }
                    }
                    endnoteWidget.bodyWidgets.splice(j, 1);
                    this.isEndnoteElementRemoved = true;
                    j--;
                }
            }
            if (endnoteWidget.bodyWidgets.length === 0) {
                bodyWidget.page.endnoteWidget = undefined;
            }
        }
        this.documentHelper.endnoteCollection.splice(this.documentHelper.endnoteCollection.indexOf(element), 1);
        this.updateEndNoteIndex();
    }
    private removeAutoShape(inline: ShapeBase): void {
        let shapeIndex: number = inline.line.paragraph.floatingElements.indexOf(inline);
        let floatingElementIndex: number = inline.line.paragraph.bodyWidget.floatingElements.indexOf(inline);
        if (floatingElementIndex > -1) {
            inline.line.paragraph.bodyWidget.floatingElements.splice(floatingElementIndex, 1);
        }
        inline.line.paragraph.floatingElements.splice(shapeIndex, 1);
    }
    /**
     * @private
     * @returns {void}
     */
    public removeField(block: BlockWidget, isBookmark?: boolean, isContentControl?: boolean, isEditRange?: boolean): void {
        if (isEditRange) {
            let editRangeCollection: string[] = this.documentHelper.editRanges.keys;
            for (let i: number = 0; i < editRangeCollection.length; i++) {
                let editRangeElements = this.documentHelper.editRanges.get(editRangeCollection[i]);
                for (let j: number = 0; j < editRangeElements.length; j++) {
                    let element = editRangeElements[j];
                    if (element.line.paragraph === block) {
                        editRangeElements.splice(j, 1);
                        j--;
                    }
                }
                if (editRangeElements.length === 0) {
                    this.documentHelper.editRanges.remove(editRangeCollection[i]);
                    i--;
                }
            }
        } else {
            let collection: FieldElementBox[] | string[] | ContentControl[] = this.documentHelper.fields;
            if (isBookmark) {
                collection = this.documentHelper.bookmarks.keys;
            } else if (isContentControl) {
                collection = this.documentHelper.contentControlCollection;
            }
            if ((block as ParagraphWidget).floatingElements.length > 0) {
                for (let z: number = 0; z < (block as ParagraphWidget).floatingElements.length; z++) {
                    let inline: ShapeBase = (block as ParagraphWidget).floatingElements[z];
                    if (inline instanceof ShapeElementBox && inline.textFrame && inline.textFrame.childWidgets.length > 0) {
                        for (let i: number = 0; i < inline.textFrame.childWidgets.length; i++) {
                            const block: BlockWidget = inline.textFrame.childWidgets[i] as BlockWidget;
                            this.removeFieldInBlock(block, isBookmark, isContentControl);
                        }
                    }
                    this.removeAutoShape(inline);
                    z--;
                }
            }
            for (let i: number = 0; i < collection.length; i++) {
                let element: FieldElementBox | BookmarkElementBox = isBookmark ?
                    this.documentHelper.bookmarks.get(collection[i] as string) : collection[i] as FieldElementBox;
                if (element.line.paragraph === block || (element instanceof BookmarkElementBox && !isNullOrUndefined(element.reference) && element.reference.line.paragraph === block)) {
                    if (isBookmark) {
                        this.documentHelper.bookmarks.remove(collection[i] as string);
                        element.line.children.splice(element.indexInOwner, 1);
                        if (!isNullOrUndefined(element.line.paragraph.associatedCell)) {
                            const cell = element.line.paragraph.associatedCell;
                            cell.isRenderBookmarkStart ? cell.isRenderBookmarkStart = false : cell.isRenderBookmarkEnd = false;
                        }
                        const endBookMarkElement = (element as BookmarkElementBox).reference;
                        if (endBookMarkElement) {
                            endBookMarkElement.line.children.splice(endBookMarkElement.indexInOwner, 1);
                        }
                        if (endBookMarkElement && !isNullOrUndefined(endBookMarkElement.line.paragraph.associatedCell)) {
                            const cell = endBookMarkElement.line.paragraph.associatedCell;
                            cell.isRenderBookmarkStart ? cell.isRenderBookmarkStart = false : cell.isRenderBookmarkEnd = false;
                        }
                    } else if (isContentControl) {
                        this.documentHelper.contentControlCollection.splice(i, 1);
                    } else {
                        this.documentHelper.fields.splice(i, 1);
                        if (this.documentHelper.formFields.indexOf(element as FieldElementBox) !== -1) {
                            this.documentHelper.formFields.splice(this.documentHelper.formFields.indexOf(element as FieldElementBox), 1);
                        }
                    }
                    i--;
                }
            }
        }
        if (this.documentHelper.footnoteCollection.length > 0) {
            for (let i: number = 0; i < this.documentHelper.footnoteCollection.length; i++) {
                let element: FootnoteElementBox = this.documentHelper.footnoteCollection[i] as FootnoteElementBox;
                if (element.line.paragraph === block) {
                    if (element.paragraph.bodyWidget.page.footnoteWidget) {
                        let footnote: FootNoteWidget = element.paragraph.bodyWidget.page.footnoteWidget;
                        for (let j: number = 0; j < footnote.bodyWidgets.length; j++) {
                            if (element === (footnote.bodyWidgets[j]).footNoteReference) {
                                footnote.height -= (footnote.bodyWidgets[j]).height;
                                footnote.bodyWidgets.splice(j, 1);
                                j--;
                            }
                        }
                        if (footnote.bodyWidgets.length === 0) {
                            element.paragraph.bodyWidget.page.footnoteWidget = undefined;
                        }
                    }
                    this.documentHelper.footnoteCollection.splice(i, 1);

                    i--;
                }
            }
        }
        if (this.documentHelper.endnoteCollection.length > 0) {
            for (let i: number = 0; i < this.documentHelper.endnoteCollection.length; i++) {
                let element: FootnoteElementBox = this.documentHelper.endnoteCollection[i] as FootnoteElementBox;
                if (element.line.paragraph === block) {
                    if (element.paragraph.bodyWidget.page.endnoteWidget) {
                        let endnote: FootNoteWidget = element.paragraph.bodyWidget.page.endnoteWidget;
                        for (let j: number = 0; j < endnote.bodyWidgets.length; j++) {
                            if (element === (endnote.bodyWidgets[j]).footNoteReference) {
                                endnote.height -= (endnote.bodyWidgets[j]).height;
                                endnote.bodyWidgets.splice(j, 1);
                                j--;
                            }
                        }
                        if (endnote.bodyWidgets.length === 0) {
                            element.paragraph.bodyWidget.page.endnoteWidget = undefined;
                        }
                    }
                    this.documentHelper.endnoteCollection.splice(i, 1);
                    i--;
                }
            }
        }
    }
    /**
     * @private
     */
    public getTabsInSelection(): WTabStop[] {
        let oldTabstops: WTabStop[] = [];
        let selection = this.owner.selectionModule;
        let selectedWidgets = selection.selectedWidgets.keys;
        let paragraphsInSelection: ParagraphWidget[] = [];
        if (selectedWidgets.length === 0) {
            return selection.start.paragraph.paragraphFormat.getUpdatedTabs();
        } else if (selection.start.paragraph === selection.end.paragraph) {
            return selection.start.paragraph.paragraphFormat.getUpdatedTabs();
        } else if (selection.start.paragraph !== selection.end.paragraph) {
            paragraphsInSelection = this.owner.selectionModule.getParagraphsInSelection();
        }
        let para: ParagraphWidget = paragraphsInSelection.length>0 ? paragraphsInSelection[0]:undefined;
        let tabs: WTabStop[] = !isNullOrUndefined(para)?para.paragraphFormat.getUpdatedTabs(): [];
        let isRemove: boolean = true;
        for (let j = 0; j < tabs.length; j++) {
            oldTabstops.push(tabs[j]);
        }
        for (let i = 1; i < paragraphsInSelection.length; i++) {
            let para: ParagraphWidget = paragraphsInSelection[i];
            let newCollection: WTabStop[] = para.paragraphFormat.getUpdatedTabs();
            let itemsToRemove: WTabStop[] = [];
            isRemove = true;
            for (let k = 0; k < oldTabstops.length; k++) {
                for (let j = 0; j < newCollection.length; j++) {
                    if (newCollection[j].equals(oldTabstops[k])) {
                        isRemove = false;
                        break;
                    }
                }
                if (isRemove) {
                    itemsToRemove.push(oldTabstops[k]);
                }
            }
            for (let k = 0; k < itemsToRemove.length; k++) {
                oldTabstops.splice(oldTabstops.indexOf(itemsToRemove[k]), 1);
            }
        }
        return oldTabstops;
    }
    /**
     * @private
     */
    public updateTabStopCollection(paragraph: ParagraphWidget, newCollection: WTabStop[], isReplace?: boolean): void {
        let oldCollection: WTabStop[] = paragraph.paragraphFormat.tabs;
        if (isReplace) {
            paragraph.paragraphFormat.tabs = [];
            for (let i = 0; i < newCollection.length; i++) {
                paragraph.paragraphFormat.tabs.push(newCollection[i]);
            }
            return;
        }
        for (let i = 0; i < newCollection.length; i++) {
            const newTab: WTabStop = newCollection[i];
            let index: number = -1;
            for (let j = 0; j < oldCollection.length; j++) {
                const oldTab = oldCollection[j];
                if (newTab.position === oldTab.position) {
                    index = j;
                    break;
                } else if (newTab.position < oldTab.position) {
                    break;
                }
            }
            if (index >= 0) {
                this.modifyTabStop(oldCollection[index], newTab);
            } else {
                this.addTabStopToCollection(oldCollection, newTab);
            }
        }
    }
    private modifyTabStop(oldTab: WTabStop, newTab: WTabStop): void {
        oldTab.deletePosition = newTab.deletePosition;
        oldTab.tabJustification = newTab.tabJustification;
        oldTab.tabLeader = newTab.tabLeader;
    }
    /**
     * @private
     */
    public removeTabStops(paragraphs: ParagraphWidget[], tabs: WTabStop[]): void {
        for (let k = 0; k < paragraphs.length; k++) {
            let tabCollection: WTabStop[] = paragraphs[k].paragraphFormat.tabs;
            for (let i = 0; i < tabs.length; i++) {
                const tab = tabs[i];
                for (let j = 0; j < tabCollection.length; j++) {
                    if (tabCollection[j].equals(tab)) {
                        tabCollection.splice(j, 1);
                        break;
                    }
                }
            }
        }
    }
    /**
     * @private
     */
    public addTabStopToCollection(collection: WTabStop[], tab: WTabStop, isReturnIndex?: boolean): number {
        let index: number = -1;
        for (let i = 0; i < collection.length; i++) {
            const element = collection[i];
            if (element.position > tab.position) {
                index = i;
                break;
            }
        }
        index = index === -1 ? collection.length: index;
        if (isReturnIndex) {
            return index;
        }
        collection.splice(index, 0, tab.clone());
        return index;
    }
    /**
     * @private
     * @param {IWidget} node Specifies the node.
     * @returns {void}
     */
    public addRemovedNodes(node: IWidget, isInsertBefore?: boolean): void {
        if (node instanceof CommentCharacterElementBox && node.commentType === 0 && node.commentMark) {
            node.removeCommentMark();
        }
        if (node instanceof ContentControl) {
            if(node.type === 0) {
                this.documentHelper.contentControlCollection.splice(this.documentHelper.contentControlCollection.indexOf(node), 1);
            } else {
                this.updatePropertiesToBlock(node.reference);
            }
        }
        if (node instanceof FieldElementBox && node.fieldType === 0) {
            if (this.documentHelper.fields.indexOf(node) !== -1) {
                this.documentHelper.fields.splice(this.documentHelper.fields.indexOf(node), 1);
            }
            if (this.documentHelper.formFields.indexOf(node) !== -1) {
                this.documentHelper.formFields.splice(this.documentHelper.formFields.indexOf(node), 1);
            }
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            if (isInsertBefore) {
                this.editorHistory.currentBaseHistoryInfo.removedNodes.splice(0, 0, node);
            } else {
                this.editorHistory.currentBaseHistoryInfo.removedNodes.push(node);
            }
        } else if (this.editHyperlinkInternal) {
            this.nodes.push(node);
        }
    }
    private deleteBlock(block: BlockWidget, selection: Selection, start: TextPosition, end: TextPosition, editAction: number): void {
        if (block instanceof ParagraphWidget) {
            this.deletePara(block as ParagraphWidget, start, end, editAction);
            if (this.delBlockContinue && this.delBlock) {
                if (this.delSection) {
                    let bodyWidget: BodyWidget = block.bodyWidget instanceof BodyWidget ? block.bodyWidget : undefined;
                    this.deleteSection(selection, this.delSection, bodyWidget, editAction);
                    this.delSection = undefined;
                }
                if (this.delBlock.indexInOwner !== -1) {
                    this.deleteBlock((this.delBlock as ParagraphWidget), selection, start, end, editAction);
                }
                this.delBlockContinue = false;
                this.delBlock = undefined;
            }
        } else {
            this.deleteTableBlock(block as TableWidget, selection, start, end, editAction);
            if (!isNullOrUndefined(block.bodyWidget) && this.owner.enableTrackChanges && !this.skipTracking()) {
                this.documentHelper.layout.reLayoutTable(block);
            }
        }
    }

    private deleteTableCell(cellAdv: TableCellWidget, selection: Selection, start: TextPosition, end: TextPosition, editAction: number, isDeleteCell?: boolean): void {
        let deletePreviousBlock: boolean = !(start.paragraph.isInsideTable && cellAdv.ownerTable.contains(start.paragraph.associatedCell));
        let previousBlock: BlockWidget = cellAdv.ownerTable.previousRenderedWidget as BlockWidget;
        if (start.paragraph.isInsideTable) {
            let containerCell: TableCellWidget = selection.getContainerCellOf(cellAdv, start.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(start.paragraph.associatedCell)) {
                let startCell: TableCellWidget = selection.getSelectedCell(cellAdv, containerCell);
                let endCell: TableCellWidget = selection.getSelectedCell(start.paragraph.associatedCell, containerCell);
                if (selection.containsCell(containerCell, start.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (selection.isCellSelected(containerCell, start, end)) {
                        if (isDeleteCell) {
                            //Container cell is completely selected.
                            this.updateEditPosition(containerCell, selection);
                            //Specifically handled for backspace. Delete selected cell in current table.
                            this.deleteCellsInTable(cellAdv.ownerRow.ownerTable, selection, start, end, editAction);
                        } else {
                            //Delete contents within table cell or Copy contents within table cell to clipboard.
                            let isCellCleared: boolean = this.clearCell(containerCell, selection, editAction, start, end);
                            if (!isCellCleared && editAction !== 2 && this.editorHistory) {
                                this.editorHistory.currentBaseHistoryInfo = undefined;
                            } else if (isCellCleared) {
                                if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo && !this.editorHistory.currentBaseHistoryInfo.isClearCell) {
                                    this.editorHistory.currentBaseHistoryInfo.isClearCell = true;
                                }
                                this.documentHelper.layout.reLayoutTable(containerCell.ownerRow.ownerTable);
                            }
                        }
                    } else {
                        if (startCell === containerCell) {
                            this.deletePara(end.paragraph, start, end, editAction);
                            if (this.delBlockContinue && this.delBlock) {
                                if (this.delSection) {
                                    let para: ParagraphWidget = end.paragraph;
                                    let bodyWidget: BodyWidget = para.bodyWidget instanceof BodyWidget ? para.bodyWidget : undefined;
                                    this.deleteSection(selection, this.delSection, bodyWidget, editAction);
                                    this.delSection = undefined;
                                }
                                this.deleteBlock((this.delBlock as ParagraphWidget), selection, start, end, editAction);
                                this.delBlockContinue = false;
                                this.delBlock = undefined;
                            }
                        } else {
                            this.deleteContainer(startCell, selection, start, end, editAction);
                        }
                    }
                } else {
                    let isAcceptOrReject = this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) &&
                        this.editorHistory.currentBaseHistoryInfo.action === 'Accept Change' || this.editorHistory.currentBaseHistoryInfo.action === 'Reject Change';
                    if (editAction === 2 && !isAcceptOrReject) {
                        //Delete contents within table cell.
                        this.deleteCell(cellAdv, selection, 2);
                    } else {
                        deletePreviousBlock = false;
                        //Delete other selected cells in current table.
                        this.deleteCellsInTable(containerCell.ownerTable, selection, start, end, editAction, undefined, true);
                    }
                }
            } else {
                //Selection end is different table.
                this.deleteContainer(containerCell, selection, start, end, editAction);
            }
        } else {
            //Selection start is outside table.
            let cell: TableCellWidget = selection.getContainerCell(cellAdv);
            //Added the condition to remove the entire table when the selection contains a table with the above paragraph.
            if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && this.editorHistory.currentBaseHistoryInfo.action === 'RemoveRowTrack') {
                this.deleteTableBlock(cell.ownerTable, selection, start, end, editAction);
                deletePreviousBlock = false;
            } else {
                this.deleteContainer(cell, selection, start, end, editAction);
            }
        }
        if (deletePreviousBlock) {
            let sectionAdv: BodyWidget = previousBlock.bodyWidget instanceof BodyWidget ? previousBlock.bodyWidget : undefined;
            // this.deleteContent(cellAdv.ownerTable, selection, editAction);
            if (!isNullOrUndefined(previousBlock)) {
                // let nextSection: WSection = blockAdv.section instanceof WSection ? blockAdv.section as WSection : undefined;
                // if (sectionAdv !== nextSection) {
                //     this.deleteSection(selection, sectionAdv, nextSection, editAction);
                // }
                //Goto the next block.
                this.deleteBlock(previousBlock, selection, start, end, editAction);
            }
        }
    }

    private deleteCellsInTable(table: TableWidget, selection: Selection, start: TextPosition, end: TextPosition, editAction: number, endCells?: TableCellWidget, trackDeletedContent?: boolean): void {
        let clonedTable: TableWidget = undefined;
        let action: Action = 'Delete';
        let isDeleteCells: boolean = false;
        let startCell: TableCellWidget = start.paragraph.associatedCell;
        let endCell: TableCellWidget = end.paragraph.associatedCell;
        if (!isNullOrUndefined(endCells)) {
            endCell = endCells;
        }

        let parentTable: TableWidget = this.documentHelper.layout.getParentTable(startCell);
        let parentStartCell: TableCellWidget = this.documentHelper.layout.getParentCell(startCell);
        let parentEndCell: TableCellWidget = this.documentHelper.layout.getParentCell(endCell);
        if (isNullOrUndefined(endCells) && start.paragraph.isInsideTable && end.paragraph.isInsideTable &&
            this.selection.isCellSelected(parentStartCell, start, end)) {
            startCell = parentStartCell;
            endCell = parentEndCell;
        }
        let startColumnIndex: number = startCell.columnIndex;
        let endColumnIndex: number = endCell.columnIndex + endCell.cellFormat.columnSpan - 1;
        let startRowIndex: number = startCell.rowIndex;
        let endRowIndex: number = endCell.rowIndex;
        let isRowSelected: boolean = this.isWholeRowSelected(startCell, endCell);
        let isAcceptOrReject = this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) &&
            (this.editorHistory.currentBaseHistoryInfo.action === 'Accept Change' || this.editorHistory.currentBaseHistoryInfo.action === 'Reject Change' || this.collabTrackAction);
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && !this.isPasteOverWriteCells) {
            action = this.editorHistory.currentBaseHistoryInfo.action;
            isDeleteCells = this.editorHistory.currentBaseHistoryInfo.action === 'BackSpace' || this.editorHistory.currentBaseHistoryInfo.action === 'DeleteCells' || isAcceptOrReject || this.editorHistory.currentBaseHistoryInfo.action === 'InsertTable' || this.editorHistory.currentBaseHistoryInfo.action === 'RemoveRowTrack' || (isNullOrUndefined(startCell.ownerRow.previousWidget)
                    && isNullOrUndefined(endCell.ownerRow.nextWidget) && this.editorHistory.currentBaseHistoryInfo.action === 'Cut');
            clonedTable = this.cloneTableToHistoryInfo(table, table === parentTable);
            if (this.editorHistory.isRedoing && this.editorHistory.currentBaseHistoryInfo.action === 'RemoveRowTrack') {
                for (let i: number = table.childWidgets.length - 1; i >= 0; i--) {
                    let row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
                    if (row.index >= startRowIndex && row.index <= endRowIndex) {
                        if (isRowSelected) {
                            this.trackRowDeletion(row, false);
                        }
                    }
                }
            }
            if (this.editorHistory.currentBaseHistoryInfo.action === 'RemoveRowTrack') {
                return;
            }
            this.editorHistory.currentBaseHistoryInfo.action = isDeleteCells ? 'DeleteCells' : 'ClearCells';
            selection.owner.isLayoutEnabled = false;
        }
        if (this.owner.enableTrackChanges && !this.skipTracking() && !isAcceptOrReject) {
            let isOkButtonClick: boolean = false;
            if (!isRowSelected) {
                if (editAction === 1) {
                    let localizeValue: L10n = new L10n('documenteditor', this.owner.defaultLocale);
                    const tiltle: string = localizeValue.getConstant('UnTrack');
                    const content: string = localizeValue.getConstant('Merge Track');
                    localizeValue.setLocale(this.owner.locale);
                    this.alertDialog = DialogUtility.alert({
                        title: tiltle,
                        content: content,
                        showCloseIcon: true,
                        okButton: {
                            text: 'Ok', click: (): void => {
                                isOkButtonClick = true;
                                this.onConfirmedTableCellsDeletion(table, selection, start, end, startRowIndex, endRowIndex, startColumnIndex, endColumnIndex, isDeleteCells, editAction, isRowSelected, action)
                            }
                        },
                        closeOnEscape: true, position: { X: 'center', Y: 'center' },
                        animationSettings: { effect: 'Zoom' },
                        close: (): void => {
                            if (!isOkButtonClick) {
                                this.documentHelper.layout.reLayoutTable(table);
                                this.viewer.updateScrollBars();
                            }
                        }
                    });
                    this.alertDialog.enableRtl = this.owner.enableRtl;
                } else {
                    this.trackDeletedContentInTableCell(table, selection, start, end, editAction, startRowIndex, endRowIndex, startColumnIndex, endColumnIndex);
                }
            } else {
                if (editAction !== 1 && trackDeletedContent) {
                    this.trackDeletedContentInTableCell(table, selection, start, end, editAction, startRowIndex, endRowIndex, startColumnIndex, endColumnIndex);
                } else {
                    this.onConfirmedTableCellsDeletion(table, selection, start, end, startRowIndex, endRowIndex, startColumnIndex, endColumnIndex, isDeleteCells, editAction, isRowSelected, action);
                }
            }
        } else {

            this.onConfirmedTableCellsDeletion(table, selection, start, end, startRowIndex, endRowIndex, startColumnIndex, endColumnIndex, isDeleteCells, editAction, isRowSelected, action, isAcceptOrReject);
        }
    }
    private removeDeletedCellRevision(row: TableRowWidget, isAddRemovedId?: boolean, startColumnIndex?: number, endColumnIndex?: number): any {
        for (let i: number = 0; i < row.childWidgets.length; i++) {
            let cellWidget: TableCellWidget = row.childWidgets[i] as TableCellWidget;
            if (
                (isNullOrUndefined(startColumnIndex) && isNullOrUndefined(endColumnIndex)) ||
                (!isNullOrUndefined(startColumnIndex) && !isNullOrUndefined(endColumnIndex) &&
                    cellWidget.columnIndex >= startColumnIndex && cellWidget.columnIndex <= endColumnIndex)
            ) {
                for (let j: number = 0; j < cellWidget.childWidgets.length; j++) {
                    let block: BlockWidget = cellWidget.childWidgets[j] as BlockWidget;
                    if (!isNullOrUndefined(block) && block instanceof ParagraphWidget) {
                        for (let lineIndex: number = 0; lineIndex < block.childWidgets.length; lineIndex++) {
                            let lineWidget: LineWidget = block.childWidgets[lineIndex] as LineWidget;
                            if (!isNullOrUndefined(lineWidget.children)) {
                                for (let elementIndex: number = 0; elementIndex < lineWidget.children.length; elementIndex++) {
                                    let element: ElementBox = lineWidget.children[elementIndex];
                                    if (element.revisionLength > 0) {
                                        if (isAddRemovedId) {
                                            this.addRemovedRevisionInfo(element);
                                        }
                                        this.unlinkRevisionFromItem(element);
                                    }
                                }
                            }
                        }
                        if (isAddRemovedId) {
                            this.addRemovedRevisionInfo(block.characterFormat);
                        }
                        this.unlinkRevisionFromItem(block.characterFormat);
                    } else if (!isNullOrUndefined(block) && block instanceof TableWidget) {
                        for (let k = 0; k < block.childWidgets.length; k++) {
                            let tableRow: TableRowWidget = block.childWidgets[k] as TableRowWidget;
                            this.removeRevisionsInRow(tableRow);
                        }
                    }
                }
            }
        }
    }
    /**
     * @private
     */
    public removeDeletedShapeRevision(shape: ShapeElementBox): any {
        let textFrame: TextFrame = shape.textFrame;
        if (!isNullOrUndefined(textFrame)) {
            for (let i: number = 0; i < textFrame.childWidgets.length; i++) {
                let paraWidget: BlockWidget = textFrame.childWidgets[i] as BlockWidget;
                if (!isNullOrUndefined(paraWidget) && paraWidget instanceof ParagraphWidget) {
                    for (let lineIndex: number = 0; lineIndex < paraWidget.childWidgets.length; lineIndex++) {
                        let lineWidget: LineWidget = paraWidget.childWidgets[lineIndex] as LineWidget;
                        if (!isNullOrUndefined(lineWidget.children)) {
                            for (let elementIndex: number = 0; elementIndex < lineWidget.children.length; elementIndex++) {
                                let element: ElementBox = lineWidget.children[elementIndex];
                                if (element.revisionLength > 0) {
                                    this.unlinkRevisionFromItem(element);
                                }
                            }
                        }
                    }
                    this.unlinkRevisionFromItem(paraWidget.characterFormat);
                }
            }
        }
    }

    /**
     * Public API for inserting shape.
     *
     * @private
     * @returns {ShapeElementBox} - Returns selection start position.
     */
    public insertShape(shapeType: AutoShapeType, shapeProperties?: ShapeProperties): void{
        let shape: ShapeElementBox = this.getShape(shapeType,shapeProperties);
        this.owner.documentHelper.selection.start.currentWidget.children.push(shape);
        this.reLayout(this.owner.documentHelper.selection);
        this.documentHelper.currentPage.bodyWidgets[0].floatingElements.push(shape);
    }

    /**
     * Returns the shape object of the user choice.
     *
     * @private
     * @returns {ShapeElementBox} - Returns selection start position.
     */
    private getShape(shapeType:AutoShapeType,shapeProperties?:ShapeProperties):ShapeElementBox{
        let shape: ShapeElementBox = new ShapeElementBox().clone();
        shape.shapeId = parseInt(Date.now().toString().slice(0,10),10);
        shape.name = shapeType + ` ${this.documentHelper.currentPage.bodyWidgets[0].floatingElements.length+1}`;
        shapeProperties = isNullOrUndefined(shapeProperties)? {}: shapeProperties;
        shape.x = isNullOrUndefined(shapeProperties.x) ? 50 :shapeProperties.x ;
        shape.y = isNullOrUndefined(shapeProperties.x) ? 50 :shapeProperties.y;
        shape.autoShapeType = shapeType;
        
        if(shapeType === 'UpDownArrow') {
            shape.height = isNullOrUndefined(shapeProperties.height) ? 140 :shapeProperties.height;
            shape.width =  isNullOrUndefined(shapeProperties.width) ? 96:  shapeProperties.width;
        }
        else if(shapeType === 'LeftRightArrow' || shapeType === 'LeftRightArrowCallout') {
            shape.height = isNullOrUndefined(shapeProperties.height) ? 80: shapeProperties.height;
            shape.width = isNullOrUndefined(shapeProperties.width) ? 140: shapeProperties.width;
        }
        else{
            shape.height = isNullOrUndefined(shapeProperties.height) ? 96 :shapeProperties.height;
            shape.width = isNullOrUndefined(shapeProperties.width) ?  96 : shapeProperties.width;
        }
        shape.visible = isNullOrUndefined(shapeProperties.visible) ? true: shapeProperties.visible;
        shape.widthScale = isNullOrUndefined(shapeProperties.widthScale) ? 100 : shapeProperties.widthScale;
        shape.heightScale = isNullOrUndefined(shapeProperties.heightScale) ? 100 : shapeProperties.heightScale;
        shape.verticalPosition = isNullOrUndefined(shapeProperties.verticalPosition) ? shape.y : shapeProperties.verticalPosition;
        // shape.verticalPosition = HelperMethods.convertPixelToPoint(this.owner.documentHelper.selection.start.location.y);
        shape.verticalOrigin = isNullOrUndefined(shapeProperties.verticalOrigin) ? "Paragraph" : shapeProperties.verticalOrigin;
        shape.verticalAlignment = isNullOrUndefined(shapeProperties.verticalAlignment ) ? 'None' : shapeProperties.verticalAlignment ;
        shape.verticalRelativePercent = -3.4028235e+38;
        shape.horizontalPosition = isNullOrUndefined(shapeProperties.horizontalPosition) ? shape.x: shapeProperties.horizontalPosition;
        // shape.horizontalPosition = HelperMethods.convertPixelToPoint(this.owner.documentHelper.selection.start.location.x);
        shape.horizontalRelativePercent = -3.4028235e+38;
        shape.heightRelativePercent = -3.4028235e+38;
        shape.widthRelativePercent = 0;
        shape.horizontalOrigin = isNullOrUndefined(shapeProperties.horizontalOrigin) ?'Column' : shapeProperties.horizontalOrigin;
        shape.horizontalAlignment = isNullOrUndefined(shapeProperties.horizontalAlignment) ?'None' : shapeProperties.horizontalAlignment;
        shape.zOrderPosition = 251659264;
        shape.allowOverlap = isNullOrUndefined(shapeProperties.allowOverLap)? true : shapeProperties.allowOverLap;
        shape.textWrappingStyle = isNullOrUndefined(shapeProperties.textWrappingStyle)? 'InFrontOfText' : shapeProperties.textWrappingStyle;
        shape.textWrappingType = isNullOrUndefined(shapeProperties.textWrappingType) ? 'Both' : shapeProperties.textWrappingType;
        shape.isBelowText = isNullOrUndefined(shapeProperties.isBelowText) ? false : shapeProperties.isBelowText;
        shape.distanceBottom = isNullOrUndefined(shapeProperties.distanceBottom) ? 0: shapeProperties.distanceBottom;
        shape.distanceTop = isNullOrUndefined(shapeProperties.distanceTop )? 0 : shapeProperties.distanceTop ;
        shape.distanceLeft = isNullOrUndefined(shapeProperties.distanceLeft)? 12: shapeProperties.distanceLeft;
        shape.distanceRight = isNullOrUndefined(shapeProperties.distanceRight)? 12 : shapeProperties.distanceRight;
        shape.isHorizontalRule = isNullOrUndefined(shapeProperties.isHorizontalRule) ? false : shapeProperties.isHorizontalRule;
        shape.layoutInCell = isNullOrUndefined(shapeProperties.layoutInCell)? true: shapeProperties.layoutInCell;
        shape.lockAnchor = isNullOrUndefined(shapeProperties.lockAnchor) ? false : shapeProperties.lockAnchor;
        
        let textFrame: TextFrame = new TextFrame();
        if(shapeType === 'Arc' || shapeType === 'CurvedConnector' || shapeType === 'ElbowConnector') {
            textFrame.textVerticalAlignment = 'Top';
        }
        else {
            textFrame.textVerticalAlignment = 'Middle';
            // textFrame.textVerticalAlignment = 'Center';
        }
        textFrame.marginLeft = 10;
        textFrame.marginRight = 10;
        textFrame.marginTop = 5;
        textFrame.marginBottom = 5;
        shape.textFrame = textFrame;
        textFrame.containerShape = shape;
        
        let fillFormat = new FillFormat();
        if(shapeType === 'Arc' || shapeType === 'CurvedConnector' || shapeType === 'ElbowConnector' || shapeType === 'DoubleBracket' || shapeType === 'DoubleBrace' || shapeType === 'RightBrace' || shapeType === 'LeftBrace' || shapeType === 'RightBracket' || shapeType === 'LeftBracket') {
            fillFormat.color = isNullOrUndefined(shapeProperties.fillColor) ? "#FFFFFFFF" : shapeProperties.fillColor;
            fillFormat.fill = isNullOrUndefined(shapeProperties.fill)? true: shapeProperties.fill;
        }
        else {
            fillFormat.fill = isNullOrUndefined(shapeProperties.fill)? true: shapeProperties.fill;
            fillFormat.color = isNullOrUndefined(shapeProperties.fillColor) ? '#156082FF': shapeProperties.fillColor;
        }
        shape.fillFormat = fillFormat;
        
        let lineFormat = new LineFormat();
        lineFormat.lineFormatType = isNullOrUndefined(shapeProperties.lineFormatType) ? "Solid" : shapeProperties.lineFormatType;
        lineFormat.dashStyle = isNullOrUndefined(shapeProperties.dashStyle) ? "Solid" : shapeProperties.dashStyle;
        lineFormat.line = isNullOrUndefined(shapeProperties.line)?true : shapeProperties.line;
        if(shapeType === 'Arc' || shapeType === 'CurvedConnector' || shapeType === 'ElbowConnector' || shapeType === 'DoubleBracket' || shapeType === 'DoubleBrace' || shapeType === 'RightBrace' || shapeType === 'LeftBrace' || shapeType === 'RightBracket' || shapeType === 'LeftBracket') {
            lineFormat.color = isNullOrUndefined(shapeProperties.lineColor) ? "#156082FF": shapeProperties.lineColor;
            lineFormat.weight = isNullOrUndefined(shapeProperties.lineWeight) ? 0.5 : shapeProperties.lineWeight;
        }
        else {
            lineFormat.color = isNullOrUndefined(shapeProperties.lineColor )? "#042433FF" : shapeProperties.lineColor ;
            lineFormat.weight = isNullOrUndefined(shapeProperties.lineWeight) ? 1 : shapeProperties.lineWeight;
        }
        shape.lineFormat = lineFormat;
        shape.line = this.owner.documentHelper.selection.start.currentWidget;
        return shape;
    }
    private trackDeletedContentInTableCell(table: TableWidget, selection: Selection, start: TextPosition, end: TextPosition, editAction: number, startRowIndex: number, endRowIndex: number, startColumnIndex: number, endColumnIndex: number): any {
        let startCell: TableCellWidget;
        let endCell: TableCellWidget;
        if (this.selection.hasMergedCells()) {
            startCell = this.selection.getCellFromSelectionInTable(0);
            endCell = this.selection.getCellFromSelectionInTable(1);
        } else {
            startCell = this.selection.getCellFromSelection(0);
            endCell = this.selection.getCellFromSelection(1);
        }
        let startIndex = this.selection.getActualOffset(startCell, 0);
        let endIndex = this.selection.getActualOffset(endCell, 1);
        let removedNodes: IWidget[] = [];
        let isBlockRemoved: boolean = false;
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            removedNodes.push(...this.editorHistory.currentBaseHistoryInfo.removedNodes);
        }
        for (let i: number = table.childWidgets.length - 1; i >= 0; i--) {
            let row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
            if (row.index >= startRowIndex && row.index <= endRowIndex) {
                for (let j: number = row.childWidgets.length - 1; j >= 0; j--) {
                    let cell: TableCellWidget = row.childWidgets[j] as TableCellWidget;
                    if (cell.columnIndex >= startColumnIndex && cell.columnIndex <= endColumnIndex) {
                        let cell: TableCellWidget = row.childWidgets[j] as TableCellWidget;
                        let blockCount: number = cell.childWidgets.length;
                        for (let k: number = cell.childWidgets.length - 1; k >= 0; k--) {
                            let block: BlockWidget = cell.childWidgets[k] as BlockWidget;
                            if (block instanceof ParagraphWidget) {
                                let paragraph: ParagraphWidget = block as ParagraphWidget;
                                this.insertRevisionForBlock(paragraph, 'Deletion', undefined, undefined, true);
                                if (blockCount !== cell.childWidgets.length) {
                                    blockCount = cell.childWidgets.length;
                                    isBlockRemoved = true;
                                }
                            } else {
                                let table: TableWidget = block as TableWidget;
                                for (let l: number = table.childWidgets.length - 1; l >= 0; l--) {
                                    this.trackRowDeletion(table.childWidgets[l] as TableRowWidget, undefined, false);
                                }
                                if (table.childWidgets.length === 0) {
                                    this.removeBlock(table);
                                }
                            }
                        }
                    }
                }
            }
        }
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            // The whole table is added to the removed nodes in the current base history, so the block inside the table that was added to the removed nodes should be removed from the current base history.
            // So, reset the removed nodes in the current base history.
            this.editorHistory.currentBaseHistoryInfo.removedNodes.length = 0;
            this.editorHistory.currentBaseHistoryInfo.removedNodes.push(...removedNodes);
            this.editorHistory.currentBaseHistoryInfo.isRevisionEndInAnotherCell = true;
            this.editorHistory.currentBaseHistoryInfo.selectionStart = startIndex;
            this.editorHistory.currentBaseHistoryInfo.insertPosition = startIndex;
            this.editorHistory.currentBaseHistoryInfo.selectionEnd = endIndex;
            this.editorHistory.currentBaseHistoryInfo.endPosition = endIndex;
            if (isBlockRemoved) {
                endIndex = this.selection.getActualOffset(endCell, 1);
                this.editorHistory.currentBaseHistoryInfo.selectionEnd = endIndex;
                this.editorHistory.currentBaseHistoryInfo.endPosition = endIndex;
                this.selection.editPosition = startIndex;
            }
        }
        this.documentHelper.layout.reLayoutTable(table);
    }
    
    private onConfirmedTableCellsDeletion(table: TableWidget, selection: Selection, start: TextPosition, end: TextPosition, startRowIndex: number, endRowIndex: number, startColumnIndex: number, endColumnIndex: number, isDeleteCells: boolean, editAction: number, isRowSelected: boolean, action: Action, isAcceptOrReject?: boolean): any {
        for (let i: number = table.childWidgets.length - 1; i >= 0; i--) {
            let row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
            let canRemoveRow: boolean = false;
            if (row.index >= startRowIndex && row.index <= endRowIndex) {
                if (this.owner.enableTrackChanges && !this.skipTracking() && !isAcceptOrReject) {
                    if (isRowSelected) {
                        canRemoveRow = this.trackRowDeletion(row, false);
                        if (canRemoveRow) {
                            this.onConfirmedCellDeletion(row, selection, start, end, startRowIndex, endRowIndex, startColumnIndex, endColumnIndex, isDeleteCells, editAction, isRowSelected);
                        }
                    } else {
                        this.onConfirmedCellDeletion(row, selection, start, end, startRowIndex, endRowIndex, startColumnIndex, endColumnIndex, isDeleteCells, editAction, isRowSelected);
                    }
                } else {
                    this.onConfirmedCellDeletion(row, selection, start, end, startRowIndex, endRowIndex, startColumnIndex, endColumnIndex, isDeleteCells, editAction, isRowSelected);
                }
            }
            if (canRemoveRow || row.childWidgets.length === 0) {
                let rowToRemove: TableRowWidget = table.childWidgets[i] as TableRowWidget;
                let prevRenderedRow: TableRowWidget = rowToRemove.previousRenderedWidget as TableRowWidget;
                while (!isNullOrUndefined(prevRenderedRow) && prevRenderedRow.ownerTable === rowToRemove.ownerTable) {
                    for (let k: number = 0; k < prevRenderedRow.childWidgets.length; k++) {
                        let cell: TableCellWidget = prevRenderedRow.childWidgets[k] as TableCellWidget;
                        if (rowToRemove.rowIndex < cell.ownerRow.rowIndex + cell.cellFormat.rowSpan) {
                            cell.cellFormat.rowSpan--;
                        }
                    }
                    prevRenderedRow = prevRenderedRow.previousRenderedWidget as TableRowWidget;
                }
                this.updateNextBlocksIndex(rowToRemove, false);
                table.childWidgets.splice(i, 1);
            }
        }
        //Layouts the table after delete cells.
        selection.owner.isLayoutEnabled = true;
        if (table.childWidgets.length === 0) {
            selection.editPosition = this.selection.getHierarchicalIndex(table, '0');
            this.setActionInternal(selection, action);
            this.removeBlock(table);
        } else {
            // Before lay outing need to update table grid.
            table.isGridUpdated = false;
            table.buildTableColumns();
            table.isGridUpdated = true;
            this.documentHelper.layout.reLayoutTable(table);
        }
        if (!isNullOrUndefined(this.alertDialog)) {
            let textPosition: TextPosition = selection.getTextPosBasedOnLogicalIndex(selection.editPosition);
            selection.selectContent(textPosition, true);
            this.reLayout(selection);
            this.alertDialog.close();
            this.alertDialog = undefined;
        }
    }
    /**
     * @private
     */
    public onConfirmedCellDeletion(row: TableRowWidget, selection: Selection, start: TextPosition, end: TextPosition, startRowIndex: number, endRowIndex: number, startColumnIndex: number, endColumnIndex: number, isDeleteCells: boolean, editAction: number, isRowSelected: boolean): void {
        let isStarted: boolean = false;
        //If the current action is ClearCells, then the row revisions will not be deleted.
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo && this.editorHistory.currentBaseHistoryInfo.action === "ClearCells") {
            isRowSelected = false;
        }
        this.removeRevisionsInRow(row, isRowSelected, undefined, startColumnIndex, endColumnIndex);
        for (let j: number = 0; j < row.childWidgets.length; j++) {
            let cell: TableCellWidget = row.childWidgets[j] as TableCellWidget;
            //this.removeRevisionForCell(cell, true);
            if (cell.columnIndex >= startColumnIndex && cell.columnIndex <= endColumnIndex) {
                if (!isStarted) {
                    this.updateEditPosition(cell, selection);
                    isStarted = true;
                }
                if (isDeleteCells) {
                    //Specific for Backspace and Cut if selection includes all rows.
                    let cell: TableCellWidget = row.childWidgets[j] as TableCellWidget;
                    this.updateNextBlocksIndex(cell, false);
                    for (let k: number = 0; k < cell.childWidgets.length; k++) {
                        let para: BlockWidget = cell.childWidgets[k] as BlockWidget;
                        for (let l: number = 0; l < para.childWidgets.length; l++) {
                            let block: LineWidget = para.childWidgets[l] as LineWidget;
                            if (block instanceof LineWidget) {
                                let line: LineWidget = block as LineWidget;
                                for (let j: number = 0; j < line.children.length; j++) {
                                    let element: ElementBox = line.children[j];
                                    if (element instanceof FootnoteElementBox) {
                                        this.removeFootnote(element);
                                    }
                                }
                            }
                        }
                    }
                    let nextRenderedRow: TableRowWidget = row.nextRenderedWidget as TableRowWidget;
                    if (!isNullOrUndefined(nextRenderedRow)) {
                        if (nextRenderedRow.rowIndex < cell.ownerRow.rowIndex + cell.cellFormat.rowSpan) {
                            cell.cellFormat.rowSpan--;
                            const cellWidget: TableCellWidget = this.createColumn(this.selection.getLastParagraph(cell));
                            cellWidget.cellFormat.copyFormat(cell.cellFormat);
                            cellWidget.index = cell.index;
                            cellWidget.rowIndex = cell.rowIndex;
                            cellWidget.columnIndex = cell.columnIndex;
                            cellWidget.containerWidget = nextRenderedRow;
                            cellWidget.margin = cell.margin.clone();
                            cellWidget.leftBorderWidth = cell.leftBorderWidth;
                            cellWidget.rightBorderWidth = cell.rightBorderWidth;
                            nextRenderedRow.childWidgets.splice(cellWidget.columnIndex, 0, cellWidget);
                        }
                    }
                    row.childWidgets.splice(j, 1);
                    j--;
                } else if (editAction < 4) {
                    this.deleteCell(cell, selection, editAction);
                }
            }
        }
    }
    /**
     * @private
     */
    public removeRevisionsInRow(rowWidget: TableRowWidget, isDeleteRevisionsInRow?: boolean, isAddRemovedIdForCell?: boolean, startColumnIndex?: number, endColumnIndex?: number): any {
        if (rowWidget.rowFormat.revisionLength > 0 && (isNullOrUndefined(isDeleteRevisionsInRow) || isDeleteRevisionsInRow)) {
            this.unlinkRevisionFromItem(rowWidget.rowFormat);
        }
        this.removeDeletedCellRevision(rowWidget, isAddRemovedIdForCell, startColumnIndex, endColumnIndex);
    }

    /**
     * @private
     */
    public removeRevisionForBlock(paraWidget: ParagraphWidget, skipParaMark: boolean, addToRevisionInfo: boolean): any {
        if (paraWidget.characterFormat.revisionLength > 0 && !skipParaMark) {
            if (addToRevisionInfo) {
                this.addRemovedRevisionInfo(paraWidget.characterFormat);
            }
            this.unlinkRevisionFromItem(paraWidget.characterFormat);
            paraWidget.characterFormat.clearRevision();
        }
        if (!isNullOrUndefined(paraWidget)) {
            for (let lineIndex: number = 0; lineIndex < paraWidget.childWidgets.length; lineIndex++) {
                let lineWidget: LineWidget = paraWidget.childWidgets[lineIndex] as LineWidget;
                for (let elementIndex: number = 0; elementIndex < lineWidget.children.length; elementIndex++) {
                    let currentElement: ElementBox = lineWidget.children[elementIndex];
                    if(currentElement instanceof FootnoteElementBox){
                        let nextRevision=currentElement.nextValidNodeForTracking as FootnoteElementBox;
                        if(nextRevision.footnoteType==='Footnote'){
                            this.removeFootnote(nextRevision);
                        } else {
                            this.removeEndnote(nextRevision);
                        }
                    }
                    if (!isNullOrUndefined(currentElement) && currentElement.revisionLength > 0) {
                        if (addToRevisionInfo) {
                            this.addRemovedRevisionInfo(currentElement);
                        }
                        this.unlinkRevisionFromItem(currentElement);
                        //ToDo:
                        currentElement.clearRevision();
                    }
                }
            }
        }
    }
    private isWholeRowSelected(startCell: TableCellWidget, endCell: TableCellWidget): boolean {
        if (startCell.cellIndex === 0 && endCell.cellIndex === endCell.ownerRow.childWidgets.length - 1) {
            return true;
        }
        return false;
    }
    private deleteCell(cell: TableCellWidget, selection: Selection, editAction: number): void {
        //Checks whether this is last paragraph of owner textbody.
        let block: BlockWidget = cell.childWidgets[0] as BlockWidget;
        if (cell.childWidgets.length === 1 && block instanceof ParagraphWidget && (block as ParagraphWidget).isEmpty()) {
            return;
        }
        const totalLength: number = cell.childWidgets.length - 1;
        for (let i: number = cell.childWidgets.length - 1; i > -1; i--) {
            block = cell.childWidgets[i] as BlockWidget;
            if (editAction < 4) {
                //Checks whether this is last paragraph of owner textbody.
                if (block instanceof ParagraphWidget && i === totalLength) {
                    //Preserves empty paragraph, to ensure minimal content.
                    let paragraph: ParagraphWidget = block as ParagraphWidget;
                    //Removes all the inlines in the paragraph.
                    if (!this.checkClearCells(selection)) {
                        for (let j: number = paragraph.childWidgets.length - 1; j >= 0; j--) {
                            let inline: LineWidget = paragraph.childWidgets[j] as LineWidget;
                            for (let k: number = inline.children.length - 1; k >= 0; k--) {
                                let element: ElementBox = inline.children[k];
                                if (element instanceof FootnoteElementBox) {
                                    this.removeFootnote(element);
                                } else if (element instanceof BookmarkElementBox && element.bookmarkType === 0 && this.documentHelper.bookmarks.containsKey(element.name)) {
                                    this.documentHelper.bookmarks.remove(element.name);
                                }
                                this.unLinkFieldCharacter(element);
                                inline.children.splice(k, 1);
                            }
                            if (paragraph.childWidgets.length > 1) {
                                paragraph.childWidgets.splice(j, 1);
                            }
                        }
                    } else if (!paragraph.isEmpty()) {
                        this.removeInlines(paragraph, paragraph.firstChild as LineWidget, 0, paragraph.lastChild as LineWidget, (paragraph.lastChild as LineWidget).getEndOffset(), editAction);
                        // Recombine cell widget due to relayout after inline removal.
                        cell = cell.combineWidget(this.owner.viewer) as TableCellWidget;
                    }
                    continue;
                }
                this.removeBlock(block);
                if (this.checkClearCells(selection)) {
                    this.addRemovedNodes(block);
                    if (cell.childWidgets.length === 1) {
                        //Add Index for line Widget
                        selection.editPosition = this.selection.getHierarchicalIndex(cell.childWidgets[0] as Widget, '0');
                        this.updateHistoryPosition(selection.editPosition, true);
                    }
                }
            }
        }
    }
    private clearCell(cell: TableCellWidget, selection: Selection, editAction: number, start: TextPosition, end: TextPosition): boolean {
        //Checks whether this is last paragraph of owner textbody.
        let block: BlockWidget = cell.childWidgets[0] as BlockWidget;
        if (cell.childWidgets.length === 1 && block instanceof ParagraphWidget && (block as ParagraphWidget).isEmpty()) {
            return false;
        }
        const totalLength: number = cell.childWidgets.length - 1;
        for (let i: number = cell.childWidgets.length - 1; i > -1; i--) {
            block = cell.childWidgets[i] as BlockWidget;
            if (editAction < 4) {
                //Checks whether this is last paragraph of owner textbody.
                if (block instanceof ParagraphWidget && i === totalLength) {
                    if (!block.isEmpty()) {
                        this.removeInlines(block, block.firstChild as LineWidget, 0, block.lastChild as LineWidget, (block.lastChild as LineWidget).getEndOffset(), editAction);
                        // Recombine cell widget due to relayout after inline removal.
                        cell = cell.combineWidget(this.owner.viewer) as TableCellWidget;
                    }
                    continue;
                }
                // Tracking is handled within the table cell.
                this.deleteBlock(block, selection, start, end, editAction);
                return true;
            }
        }
        return true;
    }
    private deleteContainer(cell: TableCellWidget, selection: Selection, start: TextPosition, end: TextPosition, editAction: number): void {
        let ownerTable: TableWidget = cell.ownerTable;
        if (ownerTable.childWidgets.length > 0) {
            let lastChild = ownerTable.childWidgets[ownerTable.childWidgets.length - 1] as TableRowWidget;
            //Last row selected, so need to remove entire table
            if (selection.containsRow(lastChild, end.paragraph.associatedCell)) {
                if (this.owner.enableTrackChanges) {
                    this.cloneTableToHistoryInfo(ownerTable);
                    for (let i: number = ownerTable.childWidgets.length - 1; i >= 0; i--) {
                        this.trackRowDeletion(ownerTable.childWidgets[i] as TableRowWidget);
                    }
                    if (ownerTable.childWidgets.length === 0 || (!isNullOrUndefined(this.editorHistory) && (this.editorHistory.isUndoing || this.editorHistory.isRedoing))) {
                        this.removeBlock(ownerTable);
                    }
                }
                else {
                    this.deleteContent(ownerTable, selection, editAction);
                }
            } else {
                if (this.toCheckForTrack(ownerTable, end)) {
                    this.cloneTableToHistoryInfo(ownerTable);
                    let considerPreviousRows: boolean = false;
                    for (let i: number = ownerTable.childWidgets.length - 1; i >= 0; i--) {
                        let rowWidget: TableRowWidget = ownerTable.childWidgets[i] as TableRowWidget;
                        if (end.paragraph.isInsideTable && selection.containsRow(rowWidget, end.paragraph.associatedCell) || considerPreviousRows) {
                            this.trackRowDeletion(rowWidget);
                            considerPreviousRows = true;
                        }
                    }
                    if (!isNullOrUndefined(this.editorHistory) && (this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
                        this.removeBlock(ownerTable);
                    } else {
                        this.documentHelper.layout.reLayoutTable(ownerTable);
                    }
                    return;
                } else {
                    for (let i: number = 0; i < ownerTable.childWidgets.length; i++) {
                        let row: TableRowWidget = ownerTable.childWidgets[i] as TableRowWidget;
                        if (editAction < 4) {
                            this.updateNextBlocksIndex(row, false);
                            this.addRemovedRevisionInfo(row.rowFormat);
                            this.removeRevisionsInRow(row, true, true);
                            ownerTable.childWidgets.splice(i, 1);
                            this.addRemovedNodes(row);
                            i--;
                        }
                        if (end.paragraph.isInsideTable && selection.containsRow(row, end.paragraph.associatedCell)) {
                            this.documentHelper.layout.reLayoutTable(ownerTable);
                            return;
                        }
                    }
                }
            }
        }
    }
    private deleteTableBlock(table: TableWidget, selection: Selection, start: TextPosition, end: TextPosition, editAction: number): void {
        table = table.combineWidget(this.owner.viewer) as TableWidget;
        if (start.paragraph.isInsideTable && table.contains(start.paragraph.associatedCell)) {
            let block: BlockWidget = table.previousRenderedWidget as BlockWidget;

            let previousBlock: ParagraphWidget = this.checkAndInsertBlock(table, start, end, editAction, block instanceof ParagraphWidget ? block : undefined);
            if (selection.containsRow((table.firstChild as TableRowWidget), start.paragraph.associatedCell)) {
                if (this.owner.enableTrackChanges) {
                    this.cloneTableToHistoryInfo(table);
                    for (let i: number = table.childWidgets.length - 1; i >= 0; i--) {
                        this.trackRowDeletion(table.childWidgets[i] as TableRowWidget);
                    }
                    if (table.childWidgets.length === 0 || (!isNullOrUndefined(this.editorHistory) && (this.editorHistory.isUndoing || this.editorHistory.isRedoing))) {
                        this.removeBlock(table);
                    }
                } else {
                    this.deleteContent(table, selection, editAction);
                }
            } else {
                if (this.owner.enableTrackChanges) {
                    if (isNullOrUndefined(end.paragraph.associatedCell) && !end.paragraph.isInsideTable) {
                        //let previousChild: TableCellWidget = end.paragraph.previousRenderedWidget.lastChild as TableCellWidget;
                        let endCells: TableCellWidget = (table.lastChild as TableRowWidget).lastChild as TableCellWidget;
                        this.deleteCellsInTable(table, selection, start, end, editAction, endCells);
                    }
                    //When the selection start and end in the different tables.
                    else if (!isNullOrUndefined(end.paragraph.associatedCell) && !isNullOrUndefined(start.paragraph.associatedCell) && start.paragraph.associatedCell.ownerTable !== end.paragraph.associatedCell.ownerTable) {
                        this.cloneTableToHistoryInfo(table);
                        for (let i: number = table.childWidgets.length - 1; i >= 0; i--) {
                            let rowWidget: TableRowWidget = table.childWidgets[i] as TableRowWidget;
                            this.trackRowDeletion(rowWidget);
                            if (start.paragraph.isInsideTable && selection.containsRow(rowWidget, start.paragraph.associatedCell)) {
                                this.documentHelper.layout.reLayoutTable(rowWidget.ownerTable);
                                return;
                            }
                        }
                    }
                } else {
                    let newTable: TableWidget = this.splitTable(table, start.paragraph.associatedCell.ownerRow);
                    this.deleteContent(table, selection, editAction);
                    this.documentHelper.layout.layoutBodyWidgetCollection(newTable.index, newTable.containerWidget, newTable, false);
                }
            }
            if (!isNullOrUndefined(previousBlock)) {
                selection.editPosition = this.selection.getHierarchicalIndex(previousBlock, '0');
                if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                    this.editorHistory.currentBaseHistoryInfo.endPosition = selection.editPosition;
                }
            }
        } else {
            let blockAdv: BlockWidget = table.previousRenderedWidget as BlockWidget;
            //let sectionAdv: BodyWidget = table.bodyWidget instanceof BodyWidget ? table.bodyWidget : undefined;
            if (this.owner.enableTrackChanges) {
                this.cloneTableToHistoryInfo(table);
                for (let i: number = table.childWidgets.length - 1; i >= 0; i--) {
                    this.trackRowDeletion(table.childWidgets[i] as TableRowWidget);
                }
                if (table.childWidgets.length === 0 || (!isNullOrUndefined(this.editorHistory) && (this.editorHistory.isUndoing || this.editorHistory.isRedoing))) {
                    this.removeBlock(table);
                }

            } else {
                this.deleteContent(table, selection, editAction);
            }
            if (!isNullOrUndefined(blockAdv)) {
                // let nextSection: WSection = blockAdv.section instanceof WSection ? blockAdv.section as WSection : undefined;
                // if (sectionAdv !== nextSection) {
                //     this.deleteSection(selection, sectionAdv, nextSection, editAction);
                // }
                //Goto the next block.
                this.deleteBlock(blockAdv, selection, start, end, editAction);
            }
        }
    }

    private splitTable(table: TableWidget, splitEndRow: TableRowWidget): TableWidget {
        let newTable: TableWidget = new TableWidget();
        newTable.tableFormat.copyFormat(table.tableFormat);
        newTable.index = table.index;
        //Moves the rows to new table.
        for (let i: number = 0; i < table.childWidgets.length; i++) {
            let row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
            if (row === splitEndRow) {
                break;
            }
            newTable.childWidgets.push(row);
            row.containerWidget = newTable;
            table.childWidgets.splice(i, 1);
            i--;
        }
        //Inserts new table in the current text position.
        let insertIndex: number = table.getIndex();
        table.containerWidget.childWidgets.splice(insertIndex, 0, newTable);
        newTable.containerWidget = table.containerWidget;
        this.updateNextBlocksIndex(newTable, true);
        return newTable;
    }
    private updateEditPosition(cell: TableCellWidget, selection: Selection): void {
        let firstParagraph: ParagraphWidget = this.documentHelper.getFirstParagraphInCell(cell);
        selection.editPosition = this.selection.getHierarchicalIndex(firstParagraph, '0');
    }

    private deleteContent(table: TableWidget, selection: Selection, editAction: number): void {
        if (editAction < 4) {
            this.removeBlock(table, false, false, false, true);
            this.addRemovedNodes(table);
        }
    }

    private setActionInternal(selection: Selection, action: Action): void {
        if (this.documentHelper.owner.enableHistoryMode && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.editorHistory.currentBaseHistoryInfo.action = action;
        }
    }
    private checkClearCells(selection: Selection): boolean {

        return this.editorHistory && this.editorHistory.currentBaseHistoryInfo && this.editorHistory.currentBaseHistoryInfo.action !== 'ClearCells';
    }
    private isEndInAdjacentTable(paragraph: ParagraphWidget, endParagraph: ParagraphWidget): boolean {
        let table: TableWidget = this.getOwnerTable(false);
        if (!isNullOrUndefined(table) && isNullOrUndefined(table.containerWidget)) {
            return true;
        }
        let start: string = this.selection.getHierarchicalIndex(paragraph, '');
        let end: string = this.selection.getHierarchicalIndex(endParagraph, '');
        let selectionStart: string[] = start.split(';');
        let selectionEnd: string[] = end.split(';');
        return selectionStart.length < selectionEnd.length;
    }
    /**
     * @private
     * @param table
     * @returns {TableWidget}
     */
    public cloneTableToHistoryInfo(table: TableWidget, isParentTable?: boolean): TableWidget {
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            //Clones the entire table to preserve in history.
            let clonedTable: TableWidget = table.clone() as TableWidget;
            clonedTable.index = table.index;
            //Preserves the cloned table in history info, for future undo operation.
            this.editorHistory.currentBaseHistoryInfo.removedNodes.push(clonedTable);
            //Sets the insert position in history info as current table.
            let startPos: TextPosition = this.documentHelper.selection.start;
            let endPos:TextPosition = this.documentHelper.selection.end;
            if (!this.documentHelper.selection.isForward) {
                startPos = endPos;
                endPos = startPos;
            }
            if (startPos.paragraph.isInsideTable &&
                startPos.paragraph.associatedCell.ownerTable === table || isParentTable) {
                this.updateHistoryPosition(this.selection.getHierarchicalIndex(table, '0'), true);
            }
            return clonedTable;
        }
        return undefined;
    }

    private insertParagraphPaste(paragraph: ParagraphWidget, currentParagraph: ParagraphWidget, start: TextPosition, end: TextPosition, isCombineNextParagraph: boolean, editAction: number, isCombineLastBlock?: boolean): void {
        if (this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && this.editorHistory.currentBaseHistoryInfo.action === 'Paste') {
            let nextParagraph: ParagraphWidget = this.selection.getNextParagraphBlock(currentParagraph);
            if (nextParagraph) {
                if (start.offset > 0 && nextParagraph === end.paragraph && paragraph === start.paragraph
                    && this.editorHistory.currentBaseHistoryInfo.action === 'Paste') {
                    //Combines the current paragraph with end paragraph specific for undo/redo paste action.
                    let insertIndex: number = 0;
                    this.documentHelper.layout.clearListElementBox(nextParagraph);
                    this.documentHelper.layout.clearListElementBox(currentParagraph);
                    if (!nextParagraph.paragraphFormat.isSameFormat(currentParagraph.paragraphFormat)) {
                        this.isMeasureParaWidth = true;
                    }
                    for (let i: number = 0; i < currentParagraph.childWidgets.length; i++) {
                        let line: LineWidget = currentParagraph.childWidgets[i] as LineWidget;
                        nextParagraph.childWidgets.splice(insertIndex, 0, line);
                        currentParagraph.childWidgets.splice(i, 1);
                        i--;
                        insertIndex++;
                        line.paragraph = nextParagraph;
                    }
                    this.removeBlock(currentParagraph);
                    this.documentHelper.layout.reLayoutParagraph(nextParagraph, 0, 0);
                    this.isMeasureParaWidth = false;
                    isCombineNextParagraph = false;
                    let offset: string = this.selection.editPosition.substring(this.selection.editPosition.lastIndexOf(';') + 1);
                    this.selection.editPosition = this.selection.getHierarchicalIndex(nextParagraph, offset);
                }
            }
        }
        if (isCombineNextParagraph) {
            this.deleteParagraphMark(currentParagraph, this.selection, editAction, false, isCombineLastBlock);
        }
    }

    private removeInlines(paragraph: ParagraphWidget, startLine: LineWidget, startOffset: number, endLine: LineWidget, endOffset: number, editAction: number, newParagraph?: ParagraphWidget): void {
        let isRemoved: boolean = false;
        this.documentHelper.layout.clearListElementBox(paragraph);
        let startIndex: number = paragraph.childWidgets.indexOf(startLine);
        let startPosition: TextPosition = this.selection.start.clone();
        let endPosition: TextPosition = this.selection.end.clone();
        // Handled special behaviour equivalent to MSWord, if the entire field isn't selected, then the field is not deleted.
        let startElementInfo: ElementInfo = this.selection.getElementInfo(startPosition.currentWidget, (startPosition.offset !== 0 && this.selection.isForward) ? startPosition.offset + 1 : startPosition.offset);
        let endElementInfo: ElementInfo = this.selection.getElementInfo(endPosition.currentWidget, (endPosition.offset !== 0 && !this.selection.isForward) ? endPosition.offset + 1 : endPosition.offset);
        if ((startElementInfo.element instanceof FieldElementBox && startElementInfo.element.fieldType !== 2 && !(endElementInfo.element instanceof FieldElementBox)) ||
            (endElementInfo.element instanceof FieldElementBox && endElementInfo.element.fieldType !== 2 && !(startElementInfo.element instanceof FieldElementBox))) {
            if (this.selection.isForward) {
                if (startElementInfo.element instanceof FieldElementBox && startElementInfo.element.fieldType === 0 && !isNullOrUndefined(startElementInfo.element.fieldEnd)) {
                    let fieldEndOffset: number = startElementInfo.element.fieldEnd.line.getOffset(startElementInfo.element.fieldEnd, 1);
                    let fieldEndPosition: TextPosition = new TextPosition(this.owner);
                    fieldEndPosition.setPositionParagraph(startElementInfo.element.fieldEnd.line, fieldEndOffset);
                    if (endPosition.isExistBefore(fieldEndPosition) && startElementInfo.element.fieldSeparator) {
                        this.selection.start.setPositionParagraph(startElementInfo.element.fieldSeparator.line, startElementInfo.element.fieldSeparator.line.getOffset(startElementInfo.element.fieldSeparator, 1));
                        startOffset = this.selection.start.offset;
                        if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                            this.editorHistory.currentBaseHistoryInfo.selectionStart = this.owner.selection.startOffset;
                            this.editorHistory.currentBaseHistoryInfo.insertPosition = this.owner.selection.startOffset;
                            this.selection.editPosition = this.owner.selection.startOffset;
                        }
                    }
                } else if (endElementInfo.element instanceof FieldElementBox && endElementInfo.element.fieldType === 1 && !isNullOrUndefined(endElementInfo.element.fieldBegin)) {
                    let fieldStartOffset: number = endElementInfo.element.fieldBegin.line.getOffset(endElementInfo.element.fieldBegin, 0);
                    let fieldStartPosition: TextPosition = new TextPosition(this.owner);
                    fieldStartPosition.setPositionParagraph(endElementInfo.element.fieldBegin.line, fieldStartOffset);
                    if (startPosition.isExistAfter(fieldStartPosition)) {
                        this.selection.end.setPositionParagraph(endElementInfo.element.line, endElementInfo.element.line.getOffset(endElementInfo.element, 0));
                        endOffset = this.selection.end.offset;
                        if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                            this.editorHistory.currentBaseHistoryInfo.selectionEnd = this.owner.selection.endOffset;
                        }
                    }
                }
            } else {
                if (startElementInfo.element instanceof FieldElementBox && startElementInfo.element.fieldType === 1 && !isNullOrUndefined(startElementInfo.element.fieldBegin)) {
                    let fieldStartOffset: number = startElementInfo.element.fieldBegin.line.getOffset(startElementInfo.element.fieldBegin, 0);
                    let fieldStartPosition: TextPosition = new TextPosition(this.owner);
                    fieldStartPosition.setPositionParagraph(startElementInfo.element.fieldBegin.line, fieldStartOffset);
                    if (endPosition.isExistAfter(fieldStartPosition)) {
                        this.selection.start.setPositionParagraph(startElementInfo.element.line, startElementInfo.element.line.getOffset(startElementInfo.element, 0));
                        endOffset = this.selection.start.offset;
                        if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                            this.editorHistory.currentBaseHistoryInfo.selectionStart = this.owner.selection.startOffset;
                            this.editorHistory.currentBaseHistoryInfo.insertPosition = this.owner.selection.endOffset;
                            this.selection.editPosition = this.owner.selection.endOffset;
                        }
                    }
                } else if (endElementInfo.element instanceof FieldElementBox && endElementInfo.element.fieldType === 0 && endElementInfo.element.fieldSeparator && !isNullOrUndefined(endElementInfo.element.fieldEnd)) {
                    let fieldEndOffset: number = endElementInfo.element.fieldEnd.line.getOffset(endElementInfo.element.fieldEnd, 1);
                    let fieldEndPosition: TextPosition = new TextPosition(this.owner);
                    fieldEndPosition.setPositionParagraph(endElementInfo.element.fieldEnd.line, fieldEndOffset);
                    if (startPosition.isExistBefore(fieldEndPosition)) {
                        this.selection.end.setPositionParagraph(endElementInfo.element.fieldSeparator.line, endElementInfo.element.fieldSeparator.line.getOffset(endElementInfo.element.fieldSeparator, 1));
                        startOffset = this.selection.end.offset;
                        if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                            this.editorHistory.currentBaseHistoryInfo.selectionEnd = this.owner.selection.endOffset;
                            this.editorHistory.currentBaseHistoryInfo.insertPosition = this.owner.selection.endOffset;
                            this.selection.editPosition = this.owner.selection.endOffset;

                        }
                    }
                }
            }
        }
        // As per MSWord behaviour, when we select the bookmark whole content except bookmark start and end, then bookmark should be removed.
        let previousElementInfo: ElementInfo = this.selection.getElementInfo(startPosition.currentWidget, this.selection.isForward ? startPosition.offset : startPosition.offset + 1);
        let nextElementInfo: ElementInfo = this.selection.getElementInfo(endPosition.currentWidget, this.selection.isForward ? endPosition.offset + 1 : endPosition.offset);
        const skipHistroy: boolean = isNullOrUndefined(this.editorHistory) ? false : (this.editorHistory.isUndoing || this.editorHistory.isRedoing);
        if (!this.selection.isExcludeBookmarkStartEnd && !skipHistroy && !this.isInsertingText && !(this.editorHistory && this.editorHistory.currentBaseHistoryInfo && this.editorHistory.currentBaseHistoryInfo.action === "Insert") && !isNullOrUndefined(previousElementInfo) && !isNullOrUndefined(nextElementInfo) && previousElementInfo.element &&
            nextElementInfo.element && previousElementInfo.element instanceof BookmarkElementBox && nextElementInfo.element instanceof BookmarkElementBox &&
            previousElementInfo.element.name === nextElementInfo.element.name && !(!isNullOrUndefined(previousElementInfo.element.nextElement) && !isNullOrUndefined(nextElementInfo.element.previousElement) && previousElementInfo.element.nextElement instanceof BookmarkElementBox && nextElementInfo.element.previousElement instanceof BookmarkElementBox && previousElementInfo.element.nextElement.name === nextElementInfo.element.previousElement.name) &&
            !(!isNullOrUndefined(previousElementInfo.element.nextElement) && !isNullOrUndefined(nextElementInfo.element.previousElement) && previousElementInfo.element.nextElement instanceof FieldElementBox && nextElementInfo.element.previousElement instanceof FieldElementBox)) {
            if (this.selection.isForward) {
                this.selection.start.setPositionParagraph(previousElementInfo.element.line, previousElementInfo.element.line.getOffset(previousElementInfo.element, 0));
                this.selection.end.setPositionParagraph(nextElementInfo.element.line, nextElementInfo.element.line.getOffset(nextElementInfo.element, 1));
                startOffset = this.selection.start.offset;
                endOffset = this.selection.end.offset;
                if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                    this.editorHistory.currentBaseHistoryInfo.selectionStart = this.owner.selection.startOffset;
                    this.editorHistory.currentBaseHistoryInfo.selectionEnd = this.owner.selection.endOffset;
                    this.editorHistory.currentBaseHistoryInfo.insertPosition = this.owner.selection.startOffset;
                    this.selection.editPosition = this.owner.selection.startOffset;
                }
            } else {
                this.selection.start.setPositionParagraph(previousElementInfo.element.line, previousElementInfo.element.line.getOffset(previousElementInfo.element, 1));
                this.selection.end.setPositionParagraph(nextElementInfo.element.line, nextElementInfo.element.line.getOffset(nextElementInfo.element, 0));
                startOffset = this.selection.end.offset;
                endOffset = this.selection.start.offset;
                if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                    this.editorHistory.currentBaseHistoryInfo.selectionStart = this.owner.selection.startOffset;
                    this.editorHistory.currentBaseHistoryInfo.selectionEnd = this.owner.selection.endOffset;
                    this.editorHistory.currentBaseHistoryInfo.insertPosition = this.owner.selection.endOffset;
                    this.selection.editPosition = this.owner.selection.endOffset;
                }
            }
        }
        let editPosition: string = this.selection.editPosition;
        let paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(this.selection.start);
        let endParagraphInfo: ParagraphInfo = this.selection.getParagraphInfo(this.selection.end);
        const startAtIndex: string = this.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
        const endIndex: string = this.selection.getHierarchicalIndex(endParagraphInfo.paragraph, endParagraphInfo.offset.toString());
        for (let i: number = paragraph.childWidgets.length - 1; i >= 0; i--) {
            let lineWidget: LineWidget = paragraph.childWidgets[i] as LineWidget;
            if (startLine === lineWidget && endLine === lineWidget) {
                this.removeContent(lineWidget, startOffset, endOffset, editAction, undefined, newParagraph);
                isRemoved = true;
                break;
            }
            if (endLine === lineWidget) {
                paragraph.isLayouted = false;
                isRemoved = true;
                this.removeContent(lineWidget, 0, endOffset, editAction, undefined, newParagraph);
            } else if (startLine === lineWidget) {
                this.removeContent(lineWidget, startOffset, this.documentHelper.selection.getLineLength(lineWidget), editAction, undefined, newParagraph);
                break;
            } else if (isRemoved) {
                this.removeContent(lineWidget, 0, this.documentHelper.selection.getLineLength(lineWidget), editAction, undefined, newParagraph);
            }
        }
        if (this.owner.enableTrackChanges && !this.skipTracking()) {
            this.selection.start.setPositionInternal(startPosition);
            this.selection.end.setPositionInternal(endPosition);
            if (this.skipReplace) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = undefined;
                this.updateInsertPosition();
            }
            this.selection.editPosition = editPosition;
        }
        if (isRemoved) {
            paragraph.isLayouted = true;
            this.removeEmptyLine(paragraph);
            this.documentHelper.layout.reLayoutParagraph(paragraph, 0, 0);
            if (this.selection.start.currentWidget.paragraph.isInsideTable && this.owner.enableTrackChanges && this.selection.start.currentWidget.indexInOwner === -1) {
                const startPos: TextPosition = this.selection.getTextPosBasedOnLogicalIndex(startAtIndex);
                this.selection.start.setPositionInternal(startPos);
            }
            if (this.selection.end.currentWidget.paragraph.isInsideTable && this.owner.enableTrackChanges && this.selection.end.currentWidget.indexInOwner === -1) {
                const endPos: TextPosition = this.selection.getTextPosBasedOnLogicalIndex(endIndex);
                this.selection.end.setPositionInternal(endPos);
            }
        }
    }
    private skipTracking(): boolean {
        if (!isNullOrUndefined(this.editorHistory) && (this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
            return true;

        } else if ((!isNullOrUndefined(this.editorHistory) && this.editorHistory.currentBaseHistoryInfo && (this.editorHistory.currentBaseHistoryInfo.action === 'Reject Change' || this.editorHistory.currentBaseHistoryInfo.action === 'Accept Change')) || this.collabTrackAction) {
            return true;
        }
        return false;
    }
    private canHandleDeletion(): boolean {

        if (!isNullOrUndefined(this.editorHistory) && this.editorHistory.currentBaseHistoryInfo && (this.editorHistory.currentBaseHistoryInfo.action === 'DeleteRow')) {
            return true;
        }
        return false;
    }
    /**
     * 
     * @param comment 
     * Deletes comment start and end markers along with its comment widgets.
     */
    private deleteCommentInSelection(comment: CommentElementBox) {
        //if comment end mark is in selection, both comment start and end markers will get deleted along with its comment widgets.
        let curentBaseHistoryInfo: BaseHistoryInfo = this.editorHistory.currentBaseHistoryInfo;
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo && !this.editorHistory.currentHistoryInfo
            && !(this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
            this.initComplexHistory('DeleteCommentInline');
        }
        this.deleteCommentInternal(comment);
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            if (!(this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
                this.editorHistory.currentHistoryInfo.addModifiedAction(curentBaseHistoryInfo);
            }
            this.selection.editPosition = curentBaseHistoryInfo.insertPosition;
            this.editorHistory.currentHistoryInfo.insertPosition = this.selection.editPosition;
            this.editorHistory.currentBaseHistoryInfo = curentBaseHistoryInfo;
        }
    }
    /**
     * @private
     */
    public removeContent(lineWidget: LineWidget, startOffset: number, endOffset: number, editAction?: number, skipHistoryCollection?: Boolean, newParagraph?: ParagraphWidget): void {
        let count: number = this.selection.getLineLength(lineWidget);
        let startText: any = undefined;
        let textCount: number = 0;
        let lastText: any = undefined;
        for (let i: number = lineWidget.children.length - 1; i >= 0; i--) {
            let inline: ElementBox = lineWidget.children[i];
            if (this.owner.enableTrackChanges && inline instanceof TextElementBox && inline.text === '') {
                lineWidget.children.splice(i, 1);
                continue;
            }
            inline.isWidthUpdated = false;
            if (isNullOrUndefined(editAction) || (editAction !== 2 && editAction !== 1)) {
                for (let k: number = 0; k < lineWidget.children.length; k++) {
                    let elementbox: ElementBox = lineWidget.children[k];
                    if (elementbox instanceof TextElementBox) {
                        let text: any = elementbox.text;
                        if (text.length + textCount > startOffset && !(textCount > startOffset)) {
                            startText = text[startOffset - textCount - 1];
                            if (isNullOrUndefined(startText) && (startOffset - textCount) === 0) {
                                startText = lastText;
                            }
                        }
                        // Eg: When we select the text with bookmark or other element. If the single space is present after it, then MS Word is deleting the space also. So this behaviour is handled here.
                        if (text.length + textCount > endOffset) {
                            const localOffset = endOffset - textCount;
                            const charAtOffset = text[localOffset];
                            if (charAtOffset === ' ') {
                                let totalSpaceCount = 1;
                                if (text[localOffset + 1] === ' ') {
                                    totalSpaceCount++;
                                }
                                if (totalSpaceCount === 1 && (elementbox.nextNode instanceof TextElementBox)
                                    && HelperMethods.startsWith(elementbox.nextNode.text, ' ')) {
                                    totalSpaceCount++;
                                }
                                if (totalSpaceCount === 1 && (startOffset === 0 || startText === ' ')) {
                                    endOffset++;
                                }
                            }
                        }
                        lastText = text[text.length - 1];
                    }
                    textCount += elementbox.length;
                }
            }
            if (endOffset <= count - inline.length) {
                count -= inline.length;
                continue;
            }
            let endIndex: number = inline.length;
            if (count > endOffset && (count - endIndex < endOffset)) {
                endIndex = endOffset - (count - inline.length);
            }

            let startIndex: number = 0;
            if (count - inline.length < startOffset) {
                startIndex = startOffset - (count - inline.length);
            }
            if (count > endOffset) {
                count -= (inline.length - endIndex);
            }
            if (startIndex === 0 && endIndex === inline.length) {
                if (!this.owner.enableTrackChanges || this.owner.enableTrackChanges && this.skipTracking()) {
                    if (!(this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing))) {
                        if (inline instanceof BookmarkElementBox) {
                            if (this.removedBookmarkElements.indexOf(inline) === -1) {
                                this.removedBookmarkElements.push(inline);
                            }
                            // The following logic has been added to include the bookmark reference element in the removedBookmarkElements collection when the element exists within the selection.
                            if (inline.reference.paragraph !== inline.paragraph && this.selection.start.paragraph !== this.selection.end.paragraph 
                                && !this.selection.start.paragraph.isInsideTable && !this.selection.end.paragraph.isInsideTable) {
                                let startPosition: TextPosition = this.selection.start;
                                let endPosition: TextPosition = this.selection.end;
                                if (!this.selection.isForward) {
                                    startPosition = this.selection.end;
                                    endPosition = this.selection.start;
                                }
                                if (inline.reference.bookmarkType === 0) {
                                    const offset: number = inline.reference.line.getOffset(inline.reference, 0);
                                    const bookmarkStartPosition: TextPosition = new TextPosition(this.owner);
                                    bookmarkStartPosition.setPositionParagraph(inline.reference.line, offset);
                                    if (startPosition.isExistBefore(bookmarkStartPosition) || startPosition.isAtSamePosition(bookmarkStartPosition)) {
                                        if (this.removedBookmarkElements.indexOf(inline.reference) === -1) {
                                            this.removedBookmarkElements.push(inline.reference);
                                        }
                                    }
                                } else if (inline.reference.bookmarkType === 1) {
                                    const offset: number = inline.reference.line.getOffset(inline.reference, 1);
                                    const bookmarkEndPosition: TextPosition = new TextPosition(this.owner);
                                    bookmarkEndPosition.setPositionParagraph(inline.reference.line, offset);
                                    if (endPosition.isExistAfter(bookmarkEndPosition) || endPosition.isAtSamePosition(bookmarkEndPosition)) {
                                        if (this.removedBookmarkElements.indexOf(inline.reference) === -1) {
                                            this.removedBookmarkElements.push(inline.reference);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (inline instanceof BookmarkElementBox) {
                        if (this.documentHelper.bookmarks.containsKey(inline.name)) {
                            if (this.owner.enableCollaborativeEditing && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                                this.editorHistory.currentBaseHistoryInfo.markerData.push({ bookmarkName: inline.name });
                            }
                            this.documentHelper.bookmarks.remove(inline.name);
                        }
                    }
                }
                if ((inline instanceof ImageElementBox && inline.textWrappingStyle !== 'Inline') || inline instanceof ShapeElementBox || inline instanceof GroupShapeElementBox) {
                    this.removeAutoShape(inline);
                }
                //clear form field revisions if it is intentionally deleted.
                if (this.skipFieldDeleteTracking && inline.revisionLength > 0) {
                    let fieldInline: ElementBox = inline;
                    if (fieldInline instanceof FieldElementBox) {
                        if (fieldInline.fieldType === 1 || fieldInline.fieldType === 2) {
                            fieldInline = fieldInline.fieldBegin;
                        }
                        this.clearFieldElementRevisions(fieldInline, inline.getAllRevision());
                    }
                }
                if (this.canHandleDeletion() || (this.owner.enableTrackChanges && !this.skipTracking() && !this.skipFieldDeleteTracking)) {
                    if (!this.skipTableElements && !this.isPasteOverWriteCells && !this.skipFootNoteDeleteTracking && !skipHistoryCollection) {
                        if (!this.isElementAddedToNewPara(newParagraph, inline)) {
                            this.addRemovedNodes(inline.clone());
                        }
                    }
                    this.handleDeleteTracking(inline, startOffset, endOffset, i, skipHistoryCollection, newParagraph);
                } else {
                    // if (editAction < 4) {
                    if (inline instanceof FootnoteElementBox) {
                        inline.isLayout = false;
                    }
                    this.unLinkFieldCharacter(inline);
                    // Added the condition to skip adding inner elements of the table to separate collection of history if the entire table is selected.
                    if (!skipHistoryCollection) {
                        if (!this.isElementAddedToNewPara(newParagraph, inline)) {
                            if (inline instanceof CommentElementBox) {
                                this.addRemovedNodes(inline.clone());
                            } else {
                                this.addRemovedNodes(inline);
                            }
                        }
                    }
                    if (inline instanceof EditRangeStartElementBox) {
                        if (!(this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing))) {
                            this.removedEditRangeStartElements.push(inline);
                        }
                        if (inline.columnFirst != -1 && inline.columnLast != -1) {
                            this.removeEditRangeFromCollection(inline);
                        }
                    } else if (inline instanceof EditRangeEndElementBox) {
                        if (!(this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing))) {
                            this.removedEditRangeEndElements.push(inline);
                        }
                    } else if (inline instanceof ContentControl && !this.isInsertingTOC) {
                        this.removedContentControlElements.push(inline);
                    }
                    let previousNode: ElementBox = inline.previousNode;
                    this.addRemovedRevisionInfo(inline);
                    //Handled special behaviour for removing hyperlink revision.
                    if (inline instanceof FieldElementBox && inline.fieldType === 2) {
                        this.unlinkRevisionFromItem(inline);
                        lineWidget.children.splice(i, 1);
                    }
                    else {
                        this.combineRevisionsAndViewBasedOnUntrackedContent(inline);
                        lineWidget.children.splice(i, 1);
                        this.unlinkRevisionFromItem(inline);
                    }
                    if (!isNullOrUndefined(previousNode)) {
                        this.combineElementRevisionToPrevNxt(previousNode);
                    }
                    if (!isNullOrUndefined(lineWidget.layoutedElements) && lineWidget.layoutedElements.length > 0) {
                        lineWidget.layoutedElements.splice(i, 1);
                    }
                }
            } else if (inline instanceof TextElementBox) {
                let span: ElementBox = this.handleDeleteTracking(inline, startIndex, endIndex, undefined, undefined, newParagraph);
                //if (editAction < 4) {
                // let span: TextElementBox = new TextElementBox();
                // span.characterFormat.copyFormat(inline.characterFormat);
                // span.text = inline.text.substr(startIndex, endIndex - startIndex);
                // for (let i = inline.revisionLength - 1; i >= 0; i--) {
                //     let revision: Revision = inline.revisions[i];
                //     let splittedRange: object[] = this.splitRevisionByElement(inline, revision);
                //     this.insertRevision(span, revision.revisionType, revision.author, revision.date, splittedRange);
                // }
                // inline.text = inline.text.slice(0, startIndex) + inline.text.slice(endIndex);
                if (!isNullOrUndefined(span) && (span as TextElementBox).text !== "") {
                    if (!this.skipTableElements) {
                        if (inline.revisionLength > 0) {
                            this.addRemovedRevisionInfo(inline, span as TextElementBox);
                        }
                        if (!this.isElementAddedToNewPara(newParagraph, span)) {
                            this.addRemovedNodes(span);
                        }
                    }
                }
                // else {

                //     this.insertTextInternal(span.text, false, 'Deletion');
                //     this.editorHistory.currentBaseHistoryInfo.revisionToRemove = inline.revisions[inline.revisionLength - 1];
                //     // let info: ElementInfo = this.selection.start.currentWidget.getInline(startOffset +1, 0);
                //     // let element: ElementBox = info.element.clone();
                //     //this.addRemovedNodes(span);
                // }
            }
            if ((!this.owner.enableTrackChanges || this.skipTracking()) && inline instanceof FootnoteElementBox) {
                if (inline.footnoteType === 'Footnote') {
                    this.removeFootnote(inline);
                } else {
                    this.removeEndnote(inline);
                }
            }
            if (startOffset >= count - (endIndex - startIndex)) {
                break;
            }
            count -= (endIndex - startIndex);
            this.documentHelper.layout.clearListElementBox(lineWidget.paragraph);
        }
    }

    /**
     * Deletes comment widgets from comment pane along with history preservation.
     */
    private deleteCommentWidgetInline(inline: CommentCharacterElementBox): void {
        // let curentBaseHistoryInfo: BaseHistoryInfo = this.editorHistory.currentBaseHistoryInfo;
        // if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo && !this.editorHistory.currentHistoryInfo) {
        //     this.initComplexHistory('DeleteCommentInline');
        // }
        // // if (!this.selection.isElementInSelection(inline.comment.commentStart, true)) {
        // //     this.removeCommentCharacters.push(inline.comment.commentStart);
        // // }
        // this.deleteCommentWidgetInternal(inline.comment);
        // if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
        //     // let index = this.editorHistory.currentHistoryInfo.modifiedActions.indexOf(curentHistoryInfo);
        //     // this.editorHistory.currentHistoryInfo.modifiedActions.push(this.editorHistory.currentHistoryInfo.modifiedActions.splice(index, 1)[0]);
        //     let lstActionHistoryInfo: HistoryInfo = this.editorHistory.currentHistoryInfo;
        //     let frstAction: BaseHistoryInfo = lstActionHistoryInfo.modifiedActions[0];
        //     // if (frstAction.action === "DeleteCommentWidget" && frstAction.removedNodes[0] instanceof CommentElementBox
        //     //     && !(frstAction.removedNodes[0] as CommentElementBox).isReply && (lstActionHistoryInfo.modifiedActions[1].action === "DeleteCommentWidget")) {
        //     //     // index = this.editorHistory.currentHistoryInfo.modifiedActions.indexOf(curentHistoryInfo);
        //     //     // this.editorHistory.currentHistoryInfo.modifiedActions.splice(index - 1, 0, this.editorHistory.currentHistoryInfo.modifiedActions.splice(0, 1)[0]);
        //     // }
        // }
        // this.editorHistory.currentHistoryInfo.addModifiedAction(curentBaseHistoryInfo);
        // this.editorHistory.currentBaseHistoryInfo = curentBaseHistoryInfo;
        // this.selection.editPosition = curentBaseHistoryInfo.insertPosition;        
        // this.editorHistory.currentHistoryInfo.insertPosition = curentBaseHistoryInfo.insertPosition;
        // this.editorHistory.currentHistoryInfo.endPosition = curentBaseHistoryInfo.insertPosition;
        // this.editorHistory.currentHistoryInfo.selectionStart = curentBaseHistoryInfo.selectionStart;
        // this.editorHistory.currentHistoryInfo.selectionEnd = curentBaseHistoryInfo.selectionEnd;
    }

    private clearFieldElementRevisions(inline: ElementBox, revision: Revision[]): void {
        let revisions: Revision[] = revision;
        for (let i: number = 0; i < revision.length; i++) {
            let currentRevision: Revision = revisions[i];
            for (let j: number = 0; j < currentRevision.getRange().length; j++) {
                if (currentRevision.getRange()[j] === inline) {
                    for (let k: number = j; k < currentRevision.getRange().length; k) {

                        if (currentRevision.getRange()[j] instanceof FieldElementBox && (currentRevision.getRange()[j] as FieldElementBox).fieldType === 1 && (currentRevision.getRange()[j] as FieldElementBox).fieldBegin === inline) {
                            currentRevision.removeCurrentRevisionFromItem(currentRevision.getRange()[j]);
                            if (currentRevision.getRange().length === 0) {
                                this.owner.revisions.remove(currentRevision);
                            }
                            break;
                        }
                        currentRevision.removeCurrentRevisionFromItem(currentRevision.getRange()[j]);
                    }
                }
            }
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public addRemovedRevisionInfo(currentElement: any, spittedElement?: ElementBox): void {

        for (let i: number = 0; i < currentElement.revisionLength; i++) {
            let revisionId: string = currentElement.getRevision(i).revisionID;
            if (!isNullOrUndefined(spittedElement)) {
                spittedElement.removedIds.push(revisionId);
            } else {
                currentElement.removedIds.push(revisionId);
            }
        }
    }

    /**
     * @private
     * @returns {void}
     */
    public removeEmptyLine(paragraph: ParagraphWidget): void {
        if (paragraph.childWidgets.length > 1) {
            for (let i: number = 0; i < paragraph.childWidgets.length; i++) {
                let lineWidget: LineWidget = paragraph.childWidgets[i] as LineWidget;
                if (lineWidget.children.length === 0 && paragraph.childWidgets.length > 1) {
                    paragraph.childWidgets.splice(i, 1);
                    i--;
                }
            }
        }
    }
    //#endregion
    /**
     * Clone the list level
     *
     * @param {WListLevel} source - Specifies the source
     * @private
     * @returns {WListLevel} - Returns the list level
     */
    public cloneListLevel(source: WListLevel): WListLevel {
        let listLevel: WListLevel = new WListLevel(undefined);
        this.copyListLevel(listLevel, source);
        return listLevel;
    }
    /**
     * Copies the list level
     *
     * @param {WListLevel} destination - Specifies the destination
     * @param {WListLevel} listLevel - Specifies the list level
     * @private
     * @returns {void}
     */
    public copyListLevel(destination: WListLevel, listLevel: WListLevel): void {
        if (!isNullOrUndefined(listLevel.paragraphFormat)) {
            destination.paragraphFormat = new WParagraphFormat(destination);
            destination.paragraphFormat.copyFormat(listLevel.paragraphFormat);
        }
        if (!isNullOrUndefined(listLevel.characterFormat)) {
            destination.characterFormat = new WCharacterFormat(destination);
            destination.characterFormat.copyFormat(listLevel.characterFormat);
        }
        if (!isNullOrUndefined(listLevel.followCharacter)) {
            destination.followCharacter = listLevel.followCharacter;
        }
        if (!isNullOrUndefined(listLevel.listLevelPattern)) {
            destination.listLevelPattern = listLevel.listLevelPattern;
        }
        if (!isNullOrUndefined(listLevel.numberFormat)) {
            destination.numberFormat = listLevel.numberFormat;
        }
        if (!isNullOrUndefined(listLevel.restartLevel)) {
            destination.restartLevel = listLevel.restartLevel;
        }
        if (!isNullOrUndefined(listLevel.startAt)) {
            destination.startAt = listLevel.startAt;
        }
    }
    /**
     * Clone level override
     *
     * @param {WLevelOverride} source  @returns {void} - Specifies the level override
     * @private
     * @returns {WLevelOverride} - Returns the level overeide
     */
    public cloneLevelOverride(source: WLevelOverride): WLevelOverride {
        let levelOverride: WLevelOverride = new WLevelOverride();
        if (!isNullOrUndefined(source.startAt)) {
            levelOverride.startAt = source.startAt;
        }
        if (!isNullOrUndefined(source.overrideListLevel)) {
            levelOverride.overrideListLevel = source.overrideListLevel;
        }
        if (!isNullOrUndefined(source.levelNumber)) {
            levelOverride.levelNumber = source.levelNumber;
        }
        return levelOverride;
    }
    /**
     * Update List Paragraph
     * @private
     * @returns {void}
     */
    public updateListParagraphs(): void {
        this.documentHelper.listParagraphs = [];
        for (let j: number = 0; j < this.documentHelper.pages.length; j++) {
            let bodyWidget: BodyWidget = this.documentHelper.pages[j].bodyWidgets[0];
            for (let i: number = 0; i < bodyWidget.childWidgets.length; i++) {
                this.updateListParagraphsInBlock(bodyWidget.childWidgets[i] as BlockWidget);
            }
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public updateListParagraphsInBlock(block: BlockWidget): void {
        if (block instanceof ParagraphWidget) {
            if (!isNullOrUndefined(block.paragraphFormat)
                && !isNullOrUndefined(block.paragraphFormat.listFormat)
                && !isNullOrUndefined(block.paragraphFormat.listFormat.listId)) {
                if (block.paragraphFormat.listFormat.listId >= 0) {
                    block.paragraphFormat.clearIndent();
                }
                if (isNullOrUndefined(this.documentHelper.listParagraphs)) {
                    this.documentHelper.listParagraphs = [];
                }
                this.documentHelper.listParagraphs.push(block);
            }
        } else if (block instanceof TableWidget) {
            for (let i: number = 0; i < block.childWidgets.length; i++) {
                for (let j: number = 0; j < (block.childWidgets[i] as TableRowWidget).childWidgets.length; j++) {
                    let cell: TableCellWidget = (block.childWidgets[i] as TableRowWidget).childWidgets[j] as TableCellWidget;
                    for (let k: number = 0; k < cell.childWidgets.length; k++) {
                        this.updateListParagraphsInBlock(cell.childWidgets[k] as BlockWidget);
                    }
                }
            }
        }
    }
    /**
     * Applies list format
     *
     * @param {WList} list - Specifies the list.
     * @private
     * @returns {void}
     */
    public onApplyList(list: WList): void {
        let selection: Selection = this.documentHelper.selection;
        this.setOffsetValue(this.documentHelper.selection);
        this.initHistory('ListFormat');
        let format: WListFormat = new WListFormat();
        if (!isNullOrUndefined(list)) {
            format.listId = list.listId;
            format.nsid = list.nsid;
        }
        this.documentHelper.owner.isShiftingEnabled = true;
        if (selection.isEmpty) {
            this.applyParaFormatProperty(selection.start.paragraph, 'listFormat', format, false);
            this.isMeasureParaWidth = true;
            this.layoutItemBlock(selection.start.paragraph, false);
            this.isMeasureParaWidth = false;
        } else {
            this.updateSelectionParagraphFormatting('listFormat', format, false);
        }
        this.documentHelper.owner.isShiftingEnabled = true;
        this.documentHelper.layout.layoutWholeDocument();
        this.documentHelper.owner.isShiftingEnabled = false;
        this.startParagraph = undefined
        this.endParagraph = undefined
    }
    /**
     * Applies bullets or numbering list
     *
     * @param {string} format - Specifies the format
     * @param {ListLevelPattern} listLevelPattern - Specifies the list level patterns
     * @param {string} fontFamily - Specifies the font family.
     * @private
     * @returns {void}
     */
    public applyBulletOrNumbering(format: string, listLevelPattern: ListLevelPattern, fontFamily: string): void {
        let selection: Selection = this.documentHelper.selection;
        let list: WList = selection.paragraphFormat.getList();
        let isUpdate: boolean = false;
        let start: TextPosition = selection.start;
        if (!selection.isForward) {
            start = selection.end;
        }
        let currentParagraph: ParagraphWidget = start.paragraph;
        if (isNullOrUndefined(list)) {
            while (!isNullOrUndefined(currentParagraph.previousWidget) && currentParagraph.previousWidget instanceof ParagraphWidget
                && currentParagraph.previousWidget.isEmpty() && currentParagraph.previousWidget.paragraphFormat.listFormat.listId === -1) {
                currentParagraph = currentParagraph.previousWidget;
            }
            if (currentParagraph.previousWidget && currentParagraph.previousWidget instanceof ParagraphWidget
                && currentParagraph.previousWidget.paragraphFormat.listFormat.listId !== -1) {
                let isUpdated: boolean = false;
                while (!isNullOrUndefined(currentParagraph.previousWidget) && currentParagraph.previousWidget instanceof ParagraphWidget
                    && currentParagraph.previousWidget.paragraphFormat.listFormat.listId !== -1 && start.paragraph.paragraphFormat.firstLineIndent < Math.abs(currentParagraph.previousWidget.paragraphFormat.firstLineIndent)) {
                    currentParagraph = currentParagraph.previousWidget;
                    isUpdated = true;
                }
                if (!isUpdated) {
                    currentParagraph = currentParagraph.previousWidget as ParagraphWidget;
                }
                list = this.documentHelper.getListById(currentParagraph.paragraphFormat.listFormat.listId);
                isUpdate = true;
            }
            if (!isUpdate) {
                while (!isNullOrUndefined(currentParagraph.nextWidget) && currentParagraph.nextWidget instanceof ParagraphWidget
                    && currentParagraph.nextWidget.isEmpty() && currentParagraph.nextWidget.paragraphFormat.listFormat.listId === -1) {
                    currentParagraph = currentParagraph.nextWidget;
                }
                if (currentParagraph.nextWidget && currentParagraph.nextWidget instanceof ParagraphWidget
                    && currentParagraph.nextWidget.paragraphFormat.listFormat.listId !== -1) {
                    currentParagraph = currentParagraph.nextWidget;
                    list = this.documentHelper.getListById(currentParagraph.paragraphFormat.listFormat.listId);
                    isUpdate = true;
                }
            }
        }
        let startListLevel: WListLevel = undefined;
        let levelNumber: number = -1;
        let initialListLevel: WListLevel = undefined;
        let isSameList: boolean = false;
        let isRestartList: boolean = false;
        if (!isNullOrUndefined(list) && start.paragraph.paragraphFormat.listFormat.listId === -1 
            && currentParagraph.paragraphFormat.listFormat.listId !== -1 && currentParagraph.paragraphFormat.listFormat.listLevelNumber > 0 
            && currentParagraph.paragraphFormat.listFormat.listLevel.listLevelPattern !== listLevelPattern) {
            isRestartList = true;
            list = undefined;
        }
        if (!isRestartList && currentParagraph.paragraphFormat.listFormat.listId !== -1 && !isNullOrUndefined(currentParagraph.paragraphFormat.listFormat.listLevel)) {
            const listFormat: WListFormat = currentParagraph.paragraphFormat.listFormat;
            this.listFormatInfo = {
                listNumberFormat: listFormat.listLevel.numberFormat,
                listLevelPattern: listFormat.listLevel.listLevelPattern,
                listCharacterFormat: listFormat.listLevel.characterFormat.hasValue('fontFamily') ? listFormat.listLevel.characterFormat.fontFamily : currentParagraph.characterFormat.fontFamily,
                listId: listFormat.listId
            };
            if (isNullOrUndefined(currentParagraph.previousWidget) && listFormat.listLevelNumber > 0) {
                this.listFormatInfo.listLevelNumber = this.listLevelNumber = start.paragraph.paragraphFormat.listFormat.listLevelNumber;
            }
            else {
                this.listFormatInfo.listLevelNumber = this.listLevelNumber = listFormat.listLevelNumber;
            }
        }
        if (!isNullOrUndefined(list)) {
            if (isNullOrUndefined(currentParagraph.previousWidget) && currentParagraph.paragraphFormat.listFormat.listLevelNumber > 0) 
            {
                levelNumber = start.paragraph.paragraphFormat.listFormat.listLevelNumber;
            }
            else
            {
                levelNumber = currentParagraph.paragraphFormat.listFormat.listLevelNumber;
            }
            let tempList: WList = this.documentHelper.getListById(currentParagraph.paragraphFormat.listFormat.listId);
            startListLevel = this.documentHelper.layout.getListLevel(tempList, levelNumber);
            if (levelNumber > 0) {
                initialListLevel = this.documentHelper.layout.getListLevel(tempList, 0);
                isSameList = !isNullOrUndefined(initialListLevel) && levelNumber > 0 && selection.start.isInSameListParagraph(selection.end);
            }
            let abstractList: WAbstractList = tempList.abstractList;
            if (!abstractList) {
                abstractList = this.documentHelper.getAbstractListById(list.abstractListId);
            }
            if (abstractList.levels.length === 0) {

                startListLevel = this.documentHelper.layout.getListLevel(tempList, currentParagraph.paragraphFormat.listFormat.listLevelNumber);
            }
            if (isUpdate) {
                if (listLevelPattern !== 'Bullet' && startListLevel.listLevelPattern === listLevelPattern
                    && (startListLevel.numberFormat === format || startListLevel.numberFormat.indexOf(format) !== -1)) {
                    selection.paragraphFormat.listId = list.listId;
                    selection.paragraphFormat.listLevelNumber = levelNumber;
                    selection.paragraphFormat.setList(list);
                    return;
                } else {
                    startListLevel = abstractList.levels[0];
                }
            }
        }
        if (isNullOrUndefined(list) || (!isNullOrUndefined(list) && levelNumber === 0
            && ((startListLevel.listLevelPattern !== listLevelPattern) || startListLevel.numberFormat !== format
                || (startListLevel.characterFormat.fontFamily !== fontFamily && startListLevel.listLevelPattern === 'Bullet')))) {
            isUpdate = false;
            list = new WList();
            if (this.documentHelper.lists.length > 0) {
                list.listId = this.documentHelper.lists[this.documentHelper.lists.length - 1].listId + 1;
            } else {
                list.listId = 0;
            }
            let abstractList: WAbstractList = new WAbstractList();
            if (this.documentHelper.abstractLists.length > 0) {

                abstractList.abstractListId = this.documentHelper.abstractLists[this.documentHelper.abstractLists.length - 1].abstractListId + 1;
            } else {
                abstractList.abstractListId = 0;
            }
            list.nsid = abstractList.nsid;
            list.abstractListId = abstractList.abstractListId;
            list.abstractList = abstractList;
            this.documentHelper.abstractLists.push(abstractList);
            if (format === 'bullet' || format === 'multiLevel' || format === 'numbering') {
                this.addListLevels(abstractList, format, selection);
            } else {
                let listLevel: WListLevel = new WListLevel(abstractList);
                listLevel.listLevelPattern = listLevelPattern;
                listLevel.numberFormat = format;
                if (listLevelPattern !== 'Bullet') {
                    listLevel.startAt = 1;
                } else {
                    listLevel.characterFormat.fontFamily = fontFamily;
                }
                listLevel.paragraphFormat.leftIndent = 36;
                listLevel.paragraphFormat.firstLineIndent = -18;
                abstractList.levels.push(listLevel);
                selection.paragraphFormat.listLevelNumber = 0;
            }
            selection.paragraphFormat.setList(list);
        } else if (isSameList && !isNullOrUndefined(list) && !isUpdate) {
            let tempList: WList = this.documentHelper.getListById(currentParagraph.paragraphFormat.listFormat.listId);
            let listLevel: WListLevel = this.documentHelper.layout.getListLevel(tempList, levelNumber);
            if (listLevelPattern === 'Bullet') {
                listLevel.numberFormat = format;
                listLevel.characterFormat.fontFamily = fontFamily;
                listLevel.listLevelPattern = listLevelPattern;
            } else {
                listLevel.listLevelPattern = listLevelPattern;
                listLevel.characterFormat.fontFamily = fontFamily;
                listLevel.characterFormat.fontFamilyAscii = fontFamily;
                listLevel.characterFormat.fontFamilyBidi = fontFamily;
                listLevel.characterFormat.fontFamilyFarEast = fontFamily;
                listLevel.characterFormat.fontFamilyNonFarEast = fontFamily;
                listLevel.startAt = 1;
                let currentFormat: string = listLevel.numberFormat.substring(listLevel.numberFormat.length - 1);
                if (listLevel.numberFormat.length !== format.length && levelNumber > 0) {
                    listLevel.numberFormat = format;
                } else if (format.substring(format.length - 1) !== listLevel.numberFormat.substring(listLevel.numberFormat.length - 1)) {
                    listLevel.numberFormat = listLevel.numberFormat.replace(currentFormat, format.substring(format.length - 1));
                }
            }
            selection.paragraphFormat.setList(tempList);
        } else if (!isNullOrUndefined(list) && isUpdate) {
            selection.paragraphFormat.setList(list);
        } else {
            selection.paragraphFormat.setList(undefined);
        }
    }

    private addListLevels(abstractListAdv: WAbstractList, listName: string, selection: Selection): void {
        let bulletCharacters: string[] = [String.fromCharCode(61558), String.fromCharCode(61656), String.fromCharCode(61607), String.fromCharCode(61623), String.fromCharCode(61608)];
        for (let i: number = abstractListAdv.levels.length; i < 9; i++) {
            let listLevel: WListLevel = new WListLevel(abstractListAdv);
            if (listName.match('bullet')) {
                listLevel.listLevelPattern = 'Bullet';
                listLevel.numberFormat = bulletCharacters[i < 5 ? i % 5 : i % 5 + 1];
                listLevel.characterFormat.fontFamily = i < 3 || i === 5 ? 'Wingdings' : 'Symbol';
            } else {
                if (listName.match('multiLevel')) {
                    for (let j: number = 0; j < i + 1; j++) {
                        listLevel.numberFormat += '%' + (j + 1).toString() + '.';
                    }
                    listLevel.listLevelPattern = 'Number';
                } else {
                    listLevel.numberFormat = '%' + (i + 1).toString() + ')';
                    listLevel.listLevelPattern = i % 3 === 0 ? 'Number'
                        : i % 3 === 1 ? 'LowLetter' : 'LowRoman';
                }
                listLevel.startAt = 1;
                listLevel.restartLevel = i;
            }
            if (i === 0) {
                listLevel.paragraphFormat.leftIndent = 36;
            } else {
                listLevel.paragraphFormat.leftIndent = 36 * i;
            }
            listLevel.paragraphFormat.firstLineIndent = -18;
            abstractListAdv.levels.push(listLevel);
            selection.paragraphFormat.listLevelNumber = i;
        }
    }
    /**
     * Inserts the page break at the cursor position.
     *
     * @returns {void}
     */
    public insertPageBreak(): void {
        if (!this.owner.isReadOnlyMode) {
            if (this.documentHelper.selection.start.paragraph.isInHeaderFooter) {
                return;
            }
            this.initComplexHistory('PageBreak');
            this.isSkipOperationsBuild = this.owner.enableCollaborativeEditing;
            this.onEnter('PageBreak');
            this.isSkipOperationsBuild = false;
            if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
                this.editorHistory.updateComplexHistory();
            }
            if (this.owner.enableAutoFocus) {
                this.selection.checkForCursorVisibility();
            }
        }
    }
    /**
     * Inserts a column break at cursor position.
     *
     * @returns {void}
     */
    public insertColumnBreak(): void {
        if (!this.owner.isReadOnlyMode) {
            if (this.documentHelper.selection.start.paragraph.isInsideTable ||
                this.documentHelper.selection.start.paragraph.isInHeaderFooter) {
                return;
            }
            this.initComplexHistory('ColumnBreak');
            let para: ParagraphWidget = this.documentHelper.selection.start.paragraph;
            if (this.viewer instanceof PageLayoutViewer && para.bodyWidget.sectionFormat.columns.length > 1) {
                let lastbody: BodyWidget = this.documentHelper.layout.getBodyWidget(para.bodyWidget, false);
                if ((!isNullOrUndefined(lastbody.nextRenderedWidget) && lastbody.page === (lastbody.nextRenderedWidget as BodyWidget).page)) {
                    this.documentHelper.layout.combineMultiColumn(lastbody);
                }
            }
            this.onEnter('ColumnBreak');
            if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
                this.editorHistory.updateComplexHistory();
            }
            if (this.owner.enableAutoFocus) {
                this.selection.checkForCursorVisibility();
            }
        }
    }
    private splitTableBasedonBreak(selection: Selection, isSectionBreakInsideTable: boolean): BlockWidget | void {
        let pageBreak: TextElementBox = new TextElementBox();
        let lastBlock: BlockWidget;
        let table: TableWidget = this.documentHelper.layout.getParentTable(selection.start.paragraph);
        table = table.combineWidget(this.owner.viewer) as TableWidget;
        let insertBefore: boolean = false;
        if (selection.start.paragraph.associatedCell.rowIndex === 0) {
            insertBefore = true;
        }
        let newParagraph: ParagraphWidget = new ParagraphWidget();
        if (!isSectionBreakInsideTable) {
            pageBreak.text = '\f';
            let line: LineWidget = new LineWidget(newParagraph);
            line.children.push(pageBreak);
            pageBreak.line = line;
            newParagraph.childWidgets.push(line);
        }
        let previousBlock: BlockWidget = table.previousRenderedWidget as BlockWidget;
        if (!insertBefore) {
            lastBlock = this.splitTable(table, selection.start.paragraph.associatedCell.ownerRow);
            this.documentHelper.layout.layoutBodyWidgetCollection(lastBlock.index, lastBlock.containerWidget, lastBlock, false);
            lastBlock = lastBlock.getSplitWidgets().pop() as BlockWidget;
        } else {
            lastBlock = table;
        }
        let insertIndex: number = 0;
        if ((isNullOrUndefined(previousBlock) || !previousBlock.bodyWidget.equals(lastBlock.bodyWidget)) && insertBefore) {
            insertIndex = 0;
            newParagraph.index = 0;
        } else {
            insertIndex = lastBlock.indexInOwner + 1;
            newParagraph.index = lastBlock.index + 1;
        }
        lastBlock.containerWidget.childWidgets.splice(insertIndex, 0, newParagraph);
        newParagraph.containerWidget = lastBlock.containerWidget;
        this.updateNextBlocksIndex(newParagraph, true);
        this.documentHelper.layout.layoutBodyWidgetCollection(newParagraph.index, newParagraph.containerWidget, newParagraph, false);
        lastBlock = newParagraph;
        if (!isSectionBreakInsideTable) {
            selection.selectParagraphInternal(lastBlock as ParagraphWidget, true);
        }
        if (isSectionBreakInsideTable) {
            return lastBlock;
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public onEnter(breakType?: string): void {
        this.handledEnter = true;
        let selection: Selection = this.documentHelper.selection;
        let isInsertParaBeforeTable: boolean = false;
        let format: SelectionCharacterFormat;
        let isInsertAfterCurrentPara: boolean = false;
        if (isNullOrUndefined(selection.start.paragraph.paragraphFormat.baseStyle) ||
            selection.start.paragraph.paragraphFormat.baseStyle.name === 'Normal' ||
            selection.start.paragraph.paragraphFormat.baseStyle.name === 'Normal (Web)') {
            format = new SelectionCharacterFormat(undefined)
            format.cloneFormat(this.selection.characterFormat);
            let eleme: ElementBox = (selection.start.paragraph.lastChild as LineWidget).children[(selection.start.paragraph.lastChild as LineWidget).children.length - 1];
            if (eleme instanceof FootnoteElementBox) {
                format.baselineAlignment = 'Normal';
            }
        }
        if (selection.isEmpty && selection.start.paragraph.isInsideTable && (selection.start.paragraph.associatedCell.ownerTable.isInsideTable ? true : selection.startPage === 1) && selection.start.paragraph.associatedCell.ownerTable.index === 0 && selection.start.paragraph.associatedCell.columnIndex === 0 && selection.start.paragraph.associatedCell.rowIndex === 0 && selection.start.paragraph.index === 0 && selection.start.offset === 0) {
            isInsertParaBeforeTable = true;
        }
        if (this.isXmlMapped) {
            return;
        }
        if (selection.isEmpty) {
            //ToDo: Need to handle the CTRL + Enter (Page Break) and SHIFT + Enter (Line Break) behavior.
            let hyperlinkField: FieldElementBox = selection.getHyperlinkField();
            let isSelectionOnHyperlink: boolean = !isNullOrUndefined(hyperlinkField);
            if (isSelectionOnHyperlink) {
                selection.fireRequestNavigate(hyperlinkField);
                return;
            }
            let paragraph: ParagraphWidget = selection.start.paragraph;
            // Revert the below line due to test case failure.
            // paragraph.characterFormat = this.copyInsertFormat(this.selection.start.paragraph.characterFormat, true, paragraph);
            if (paragraph.isEmpty() && paragraph.paragraphFormat.listFormat.listId !== -1 && !isInsertParaBeforeTable) {

                this.onApplyListInternal(this.documentHelper.getListById(paragraph.paragraphFormat.listFormat.listId), paragraph.paragraphFormat.listFormat.listLevelNumber - 1);
                return;
            }
            // If selection element is Bookmarkend and includes ParaMark, reducing one offset   
            const inlineObj: ElementInfo = selection.start.currentWidget.getInline(selection.start.offset, 0);
            const element: ElementBox = inlineObj.element;
            if (element instanceof BookmarkElementBox && element.bookmarkType === 1
                && !isNullOrUndefined(element.properties) && element.properties.hasOwnProperty('isAfterParagraphMark') && element.properties['isAfterParagraphMark']) {
                selection.start.setPositionParagraph(element.line, element.line.getOffset(element, 0));
                selection.end.setPositionInternal(selection.start);
            }
        }
        let commentStartToInsert = this.checkAndRemoveComments();
        this.initHistory('Enter');
        let isRemoved: boolean = true;
        if (!selection.isEmpty && !selection.isImageSelected) {
            // this.initHistoryWithSelection(selection, 'Enter');
            isRemoved = this.removeSelectedContents(selection);
        }
        let isSplitTable: boolean = false;
        if (isRemoved) {
            if (selection.isImageSelected && !selection.isForward) {
                let start = selection.start;
                selection.start = selection.end;
                selection.end = start;
            }
            selection.owner.isShiftingEnabled = true;
            this.updateInsertPosition();
            if (selection.start.paragraph.isInsideTable && !isNullOrUndefined(breakType) && breakType === 'PageBreak') {
                isSplitTable = true;
                this.splitTableBasedonBreak(selection, false);
            } else {
                let blockInfo: ParagraphInfo = this.selection.getParagraphInfo(selection.start);
                let initialStart: string = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
                let characterFormat: WCharacterFormat = this.copyInsertFormat(this.selection.start.paragraph.characterFormat, true);
                let currentParagraph: ParagraphWidget = selection.start.paragraph;
                let currentLine: LineWidget = selection.start.currentWidget as LineWidget;
                if (this.owner.enableTrackChanges && currentLine === currentParagraph.lastChild && selection.start.offset === selection.getLineLength(currentLine) && !currentParagraph.isContainsShapeAlone() && this.retrieveRevisionByType(currentParagraph.characterFormat, 'Deletion')) {
                    isInsertAfterCurrentPara = true;
                }
                let nextparagraph: ParagraphWidget = this.splitParagraphInternal(selection, currentParagraph, currentLine, selection.start.offset, characterFormat, isInsertParaBeforeTable, isInsertAfterCurrentPara);
                this.setPositionForCurrentIndex(selection.start, initialStart);
                if (!isNullOrUndefined(breakType) && (breakType === 'PageBreak' || breakType === 'ColumnBreak')) {
                    let currentParagraph: ParagraphWidget = selection.start.paragraph;
                    let pageBreak: TextElementBox = new TextElementBox();
                    switch (breakType) {
                        case 'PageBreak':
                            pageBreak.text = '\f';
                            break;
                        case 'ColumnBreak':
                            pageBreak.text = String.fromCharCode(14);
                            break;
                    }
                    let line: LineWidget = selection.start.currentWidget;
                    pageBreak.line = line;
                    line.children.push(pageBreak);
                    if (this.owner.enableTrackChanges && currentParagraph.characterFormat.revisionLength > 0) {
                        this.insertRevision(pageBreak, 'Insertion');
                    }
                    this.documentHelper.layout.layoutBodyWidgetCollection(currentParagraph.index, currentParagraph.containerWidget, currentParagraph, false);
                    if (nextparagraph) {
                        selection.selectParagraphInternal(nextparagraph, true);
                    }
                }
            }
            let nextNode: BlockWidget = selection.start.paragraph.nextWidget as BlockWidget;
            if (isNullOrUndefined(nextNode)) {
                nextNode = selection.getNextRenderedBlock(selection.start.paragraph);
            }
            if (!isSplitTable) {
                selection.selectParagraphInternal((isInsertParaBeforeTable || nextNode instanceof TableWidget) ? selection.start.paragraph : nextNode as ParagraphWidget, true);
            }
            if(!isInsertParaBeforeTable && !isInsertAfterCurrentPara) {
                this.updateEndPosition();
            }
            if (!isNullOrUndefined(breakType) && this.editorHistory) {
                this.owner.editorHistoryModule.updateHistory();
            }
            // if (!isNullOrUndefined(selection.currentHistoryInfo)) {
            //     this.updateComplexHistory();
            // } else {
            this.reLayout(selection);
            let currentPara: ParagraphWidget = this.selection.start.paragraph.containerWidget.firstChild as ParagraphWidget;
            if (!isNullOrUndefined(currentPara)) {
                currentPara.isChangeDetected = false;
                let nextPara: ParagraphWidget = currentPara.nextRenderedWidget as ParagraphWidget;

                while (this.owner.isSpellCheck && !isNullOrUndefined(nextPara)) {
                    currentPara = nextPara;
                    currentPara.isChangeDetected = false;
                    nextPara = currentPara.nextRenderedWidget as ParagraphWidget;
                }
            }
            // }
            if (!isSplitTable) {
                let paragraph: ParagraphWidget = selection.start.paragraph.previousWidget as ParagraphWidget;
                if (!isNullOrUndefined(paragraph) && !paragraph.isEmpty() &&

                (paragraph.lastChild as LineWidget).children[(paragraph.lastChild as LineWidget).children.length - 1] instanceof TextElementBox) {
                    this.checkAndConvertToHyperlink(selection, true, paragraph);
                }
            }
        }
        if (!isNullOrUndefined(format) && !isNullOrUndefined(selection.start.paragraph) && selection.start.paragraph.isEmpty() && !isInsertParaBeforeTable) {
            this.selection.isRetrieveFormatting = true;
            this.selection.characterFormat.cloneFormat(format);
            this.selection.isRetrieveFormatting = false;
        }
        this.documentHelper.layout.islayoutFootnote = false;
        this.updateHistoryForComments(commentStartToInsert);
        this.handledEnter = false;
    }
    private splitParagraphInternal(selection: Selection, paragraphAdv: ParagraphWidget, currentLine: LineWidget, offset: number, characterFormat: WCharacterFormat, isInsertParaBeforeTable?: boolean, isInsertAfterCurrentPara?: boolean): ParagraphWidget {
        let insertIndex: number = 0;
        let blockIndex: number = paragraphAdv.index;
        let currentPara: ParagraphWidget = paragraphAdv;
        currentPara.isChangeDetected = (offset === 0) ? true : false;
        while (this.owner.isSpellCheck && !isNullOrUndefined(currentPara.nextRenderedWidget)) {
            currentPara = currentPara.nextRenderedWidget as ParagraphWidget;
            currentPara.isChangeDetected = true;
        }
        let paragraph: ParagraphWidget = new ParagraphWidget();
        let lineWidget: LineWidget = new LineWidget(paragraph);
        let isContentMoved: boolean = false;
        let isInsertRevision: boolean = false;
        paragraph.childWidgets.push(lineWidget);
        //Copies the format to new paragraph.
        paragraph.paragraphFormat.ownerBase = paragraph;
        if (paragraphAdv.contentControlProperties) {
            paragraph.contentControlProperties = paragraphAdv.contentControlProperties;
        }
        if (currentLine === paragraphAdv.lastChild && offset === selection.getLineLength(currentLine) && !paragraphAdv.isContainsShapeAlone()) {
            if (!isInsertParaBeforeTable) {
                if (paragraphAdv.paragraphFormat.baseStyle
                    && paragraphAdv.paragraphFormat.baseStyle.name !== 'Normal' && paragraphAdv.paragraphFormat.baseStyle.next instanceof WParagraphStyle) {
                    if (paragraphAdv.paragraphFormat.baseStyle.name === paragraphAdv.paragraphFormat.baseStyle.next.name) {
                        paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
                        paragraph.characterFormat.copyFormat(paragraphAdv.characterFormat);
                    } else {
                        paragraph.paragraphFormat.baseStyle = paragraphAdv.paragraphFormat.baseStyle.next;
                    }
                    this.selection.skipFormatRetrieval = false;
                } else {
                    paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
                    paragraph.characterFormat.copyFormat(paragraphAdv.characterFormat);
                }
                if ((paragraphAdv.lastChild as LineWidget).children.length > 0) {
                    paragraphAdv.characterFormat.copyFormat((paragraphAdv.lastChild as LineWidget).children[(paragraphAdv.lastChild as LineWidget).children.length - 1].characterFormat);
                }
            }
            paragraph.characterFormat.removedIds = [];
            if (this.owner.enableTrackChanges) {
                isInsertRevision = true;
                if (isInsertParaBeforeTable) {
                    paragraph.characterFormat.clearRevision();
                    insertIndex++;
                    blockIndex++;
                } else {
                    //As per MS Word behaviour When the current paragraph's paramark has an insert revision, the new revision is inserted in the current paragraph, and the previous insert revision is moved to the next paragraph.
                    if (!this.retrieveRevisionByType(paragraphAdv.characterFormat, 'Deletion')) {
                        paragraphAdv = paragraphAdv.combineWidget(this.owner.viewer) as ParagraphWidget;
                        this.moveInlines(paragraphAdv, paragraph, 0, 0, paragraphAdv.firstChild as LineWidget, offset, paragraphAdv.lastChild as LineWidget);
                    }
                    //As per MS Word behaviour when the current paragraph's para mark has an delete revision, we need to insert the new revision in the next paragraph.
                    else {
                        insertIndex++;
                        blockIndex++;
                    }
                }
            } else {
                if (paragraphAdv.characterFormat.revisionLength > 0) {
                    paragraphAdv = paragraphAdv.combineWidget(this.owner.viewer) as ParagraphWidget;
                    this.moveInlines(paragraphAdv, paragraph, 0, 0, paragraphAdv.firstChild as LineWidget, offset, paragraphAdv.lastChild as LineWidget);
                } else {
                    insertIndex++;
                    blockIndex++;
                }
            }
            //ToDo in future: Need to skip copying formattings to new paragraph, if the style for following paragraph is same style.
        } else {
            paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
            paragraph.characterFormat.copyFormat(characterFormat);
            paragraph.characterFormat.removedIds = [];
            if ((offset > 0 || !currentLine.isFirstLine()) && !paragraphAdv.isContainsShapeAlone()) {
                paragraphAdv = paragraphAdv.combineWidget(this.owner.viewer) as ParagraphWidget;
                this.moveInlines(paragraphAdv, paragraph, 0, 0, paragraphAdv.firstChild as LineWidget, offset, currentLine);
                isContentMoved = true;
                if (this.owner.enableTrackChanges) {
                    isInsertRevision = true;
                }
            } else {
                if (this.owner.enableTrackChanges) {
                    let firstLine: LineWidget = paragraphAdv.firstChild as LineWidget;
                    let firstElement: ElementBox = firstLine.children[0];
                    if (!isNullOrUndefined(firstElement)) {
                        paragraph.characterFormat.clearRevision();
                        isInsertRevision = true;
                    } else if (isNullOrUndefined(firstElement)) {
                        insertIndex++;
                        blockIndex++;
                    }
                }
            }
            paragraphAdv = paragraphAdv.getSplitWidgets()[0] as ParagraphWidget;
        }
        let container: Widget;
        if (isInsertParaBeforeTable) {
            insertIndex = 0;
            blockIndex = 0;
            let containerTable: TableWidget = paragraphAdv.associatedCell.ownerTable;
            container = containerTable.containerWidget;
            container.childWidgets.splice(0, 0, paragraph);
            paragraph.containerWidget = container;
            paragraph.index = 0;
            this.updateNextBlocksIndex(paragraph, true);
        } else {
            insertIndex += paragraphAdv.getIndex();
            container = paragraphAdv.containerWidget;
            let childNodes: BlockWidget[] = container.childWidgets as BlockWidget[];
            childNodes.splice(insertIndex, 0, paragraph);
            paragraph.containerWidget = container;
            paragraph.index = blockIndex;
            this.updateNextBlocksIndex(paragraph, true);
        }
        if (isInsertAfterCurrentPara || isInsertParaBeforeTable) {
            this.owner.selectionModule.start.setPositionParagraph(paragraph.firstChild as LineWidget, 0);
            this.owner.selectionModule.end.setPositionParagraph(paragraph.firstChild as LineWidget, 1);
            if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                this.editorHistory.currentBaseHistoryInfo.selectionStart = this.owner.selectionModule.startOffset;
                this.editorHistory.currentBaseHistoryInfo.selectionEnd = this.owner.selectionModule.startOffset;
                this.editorHistory.currentBaseHistoryInfo.insertPosition = this.owner.selectionModule.startOffset;
                this.editorHistory.currentBaseHistoryInfo.endPosition = this.owner.selectionModule.endOffset;
            }
        }
        if (isInsertRevision) {
            this.insertRevision(paragraph.characterFormat, 'Insertion');
        }
        if (isContentMoved) {
            this.updateRevisionForSplittedPara(paragraph, paragraphAdv);
        } else {
            this.splitRevisionsAndViewBasedOnUntrackedContent(paragraph.characterFormat);
        }
        if ((!isNullOrUndefined(container.containerWidget) && container.containerWidget instanceof FootNoteWidget) || (container instanceof TableCellWidget && !isNullOrUndefined(container.bodyWidget) && container.bodyWidget.containerWidget instanceof FootNoteWidget)) {
            let height: number = this.documentHelper.textHelper.getParagraphMarkSize(paragraph.characterFormat).Height;
            if (container instanceof TableCellWidget) {
                container.bodyWidget.height += height;
                container.bodyWidget.containerWidget.height += height;
            } else {
                container.containerWidget.height += height;
                container.height += height;
            }
        }
        this.documentHelper.layout.layoutBodyWidgetCollection(blockIndex, container as BodyWidget, paragraph, false);
        return paragraph;
    }
 
    /**
     * @private
     * @returns {void}
     */
    public updateNextBlocksIndex(block: BlockWidget, increaseIndex: boolean): void {
        let nextIndex: number = block.containerWidget.childWidgets.indexOf(block) + 1;
        if (block.containerWidget instanceof BodyWidget && !(block.containerWidget.containerWidget instanceof FootNoteWidget)) {
            // let startSel = this.selection.startOffset.substring(0,1);
            // let endSel = this.selection.endOffset.substring(0,1);
            if ((block.containerWidget as BodyWidget).page.bodyWidgets.length > 1 && block.containerWidget.sectionFormat.numberOfColumns > 1) {
                let fromSectionIndex: number = (block.containerWidget as BodyWidget).indexInOwner;
                for (let i: number = this.documentHelper.pages.indexOf(block.containerWidget.page); i < this.documentHelper.pages.length; i++) {
                    let page: Page = this.documentHelper.pages[i];
                    for (let j: number = 0; j < page.bodyWidgets.length; j++) {
                        if (page.bodyWidgets[j].indexInOwner === fromSectionIndex) {
                            for (let k: number = nextIndex; k < page.bodyWidgets[j].childWidgets.length; k++) {
                                let childWidget: BlockWidget = page.bodyWidgets[j].childWidgets[k] as BlockWidget;
                                this.updateIndex(childWidget, increaseIndex);
                            }
                            nextIndex = 0;
                            if (!isNullOrUndefined(page.bodyWidgets[j].nextRenderedWidget) && (page.bodyWidgets[j].nextRenderedWidget as BodyWidget).sectionIndex === page.bodyWidgets[j].sectionIndex) {
                                fromSectionIndex++;
                            }
                        }
                    }
                    if (fromSectionIndex !== block.containerWidget.indexInOwner && !isNullOrUndefined(page.bodyWidgets[page.bodyWidgets.length - 1].nextRenderedWidget) && (page.bodyWidgets[page.bodyWidgets.length - 1].nextRenderedWidget as BodyWidget).sectionFormat.columns.length > 1) {
                        fromSectionIndex = 0;
                    }
                }
            } else if ((block.containerWidget as BodyWidget).page.bodyWidgets.length > 1) {
                let currentSectionIndex: number = (block.containerWidget as BodyWidget).index;
                for (let i: number = this.documentHelper.pages.indexOf(block.containerWidget.page); i < this.documentHelper.pages.length; i++) {
                    let page: Page = this.documentHelper.pages[i];
                    for (let j: number = 0; j < page.bodyWidgets.length; j++) {
                        if (page.bodyWidgets[j].index === currentSectionIndex) {
                            for (let k: number = nextIndex; k < page.bodyWidgets[j].childWidgets.length; k++) {
                                let childWidget: BlockWidget = page.bodyWidgets[j].childWidgets[k] as BlockWidget;
                                this.updateIndex(childWidget, increaseIndex);
                            }
                            nextIndex = 0;
                        }
                    }
                }
            } else {
                let currentSectionIndex: number = (block.containerWidget as BodyWidget).index;
                for (let j: number = this.documentHelper.pages.indexOf(block.containerWidget.page); j < this.documentHelper.pages.length; j++) {
                    let page: Page = this.documentHelper.pages[j];
                    if (page.bodyWidgets[0].index === currentSectionIndex) {
                        for (let k: number = nextIndex; k < page.bodyWidgets[0].childWidgets.length; k++) {
                            let childWidget: BlockWidget = page.bodyWidgets[0].childWidgets[k] as BlockWidget;
                            this.updateIndex(childWidget, increaseIndex);
                        }
                        nextIndex = 0;
                    } else {
                        return;
                    }
                }
            }
        } else if (block.containerWidget instanceof TableCellWidget) {
            let cells: TableCellWidget[] = block.containerWidget.getSplitWidgets() as TableCellWidget[];
            let currentCellIndex: number = cells.indexOf(block.containerWidget);
            for (let x: number = currentCellIndex; x < cells.length; x++) {
                let blocks: BlockWidget[] = cells[x].childWidgets as BlockWidget[];
                for (let y: number = nextIndex; y < blocks.length; y++) {
                    this.updateIndex(blocks[y], increaseIndex);
                }
                currentCellIndex = 0;
                nextIndex = 0;
            }
        } else if (block.containerWidget instanceof TableRowWidget) {
            for (let i: number = nextIndex; i < block.containerWidget.childWidgets.length; i++) {
                let cell: TableCellWidget = block.containerWidget.childWidgets[i] as TableCellWidget;
                if (cell.rowIndex === block.containerWidget.index) {
                    this.updateIndex(cell, increaseIndex);
                }
            }
        } else if (block.containerWidget instanceof TableWidget) {
            for (let i: number = nextIndex; i < block.containerWidget.childWidgets.length; i++) {
                let row: TableCellWidget = block.containerWidget.childWidgets[i] as TableCellWidget;
                this.updateIndex(row, increaseIndex);
                for (let j: number = 0; j < row.childWidgets.length; j++) {
                    (row.childWidgets[j] as TableCellWidget).rowIndex = row.index;
                }
            }
            //update Row index of all the cell
        } else if (block.containerWidget instanceof HeaderFooterWidget || block.containerWidget instanceof TextFrame
            || (!isNullOrUndefined(block.containerWidget) && block.containerWidget.containerWidget instanceof FootNoteWidget)) {
            if (block.containerWidget.containerWidget instanceof FootNoteWidget && block.containerWidget.containerWidget.footNoteType === 'Endnote' && block === block.containerWidget.lastChild) {
                const currentBodyIndex: number = (block.containerWidget as BodyWidget).index;
                const startPageIndex = this.documentHelper.pages.indexOf(block.containerWidget.containerWidget.page);
                for (let i: number = startPageIndex + 1; i < this.documentHelper.pages.length; i++) {
                    let page: Page = this.documentHelper.pages[i];
                    if (page.endnoteWidget && page.endnoteWidget.bodyWidgets.length > 0 && page.endnoteWidget.bodyWidgets[0].index === currentBodyIndex) {
                        for (let j: number = 0; j < page.endnoteWidget.bodyWidgets[0].childWidgets.length; j++) {
                            let childWidget: BlockWidget = page.endnoteWidget.bodyWidgets[0].childWidgets[j] as BlockWidget;
                            this.updateIndex(childWidget, increaseIndex);
                        }
                    } else {
                        return;
                    }
                }
            } else {
                for (let i: number = nextIndex; i < block.containerWidget.childWidgets.length; i++) {
                    let nextBlock: BlockWidget = block.containerWidget.childWidgets[i] as BlockWidget;
                    this.updateIndex(nextBlock, increaseIndex);
                }
            }
        }
    }
    private updateIndex(widget: Widget, increment: boolean): void {
        if (increment) {
            widget.index++;
        } else {
            widget.index--;
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public updateEndPosition(): void {
        let selection: Selection = this.documentHelper.selection;
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.updateHistoryPosition(selection.start, false);
        }
    }
    /**
     * @private
     * @returns { CommentCharacterElementBox[] }
     */
    public checkAndRemoveComments(isReplace?: boolean, isAccept?: boolean): CommentCharacterElementBox[] {
        let selection: Selection = this.selection;
        if (selection.isEmpty || (this.owner.enableTrackChanges && !isAccept) || isReplace) {
            return [];
        }
        let initComplexHistory: boolean = false;
        let comments: SelectedCommentInfo = this.getSelectedComments();
        if (comments.commentEndInfo.length > 0 || comments.commentStartInfo.length > 0) {
            if (!initComplexHistory) {
                initComplexHistory = true;
                this.initComplexHistory('RemoveComment');
            }
            let startPosition: TextPosition = this.selection.start;
            let endPosition: TextPosition = this.selection.end;
            if (!this.selection.isForward) {
                startPosition = this.selection.end;
                endPosition = this.selection.start;
            }
            //Get start and end position in order.
            const startBlockInfo: ParagraphInfo = this.selection.getParagraphInfo(startPosition);
            const endBlockInfo: ParagraphInfo = this.selection.getParagraphInfo(endPosition);
            for (let j: number = 0; j < comments.commentEndInfo.length; j++) {
                let commentToDelete: CommentElementBox = comments.commentEndInfo[j].comment;
                let commentStart: CommentCharacterElementBox = commentToDelete.commentStart;
                let commentEndMark: CommentCharacterElementBox = commentToDelete.commentEnd;
                let commentStartBlockInfo: ParagraphInfo = this.selection.getParagraphInfoInternal(commentStart.line, commentStart.line.getOffset(commentStart, 0));
                let commentEndBlockInfo: ParagraphInfo = this.selection.getParagraphInfoInternal(commentEndMark.line, commentEndMark.line.getOffset(commentEndMark, 0));
                if (endBlockInfo.paragraph === commentEndBlockInfo.paragraph) {
                    if (commentToDelete.replyComments.length > 0) {
                        for (let m: number = 0; m < commentToDelete.replyComments.length; m++) {
                            let replyComment: CommentElementBox = commentToDelete.replyComments[m];
                            if (!isNullOrUndefined(replyComment.commentEnd)) {
                                endBlockInfo.offset--;
                            }
                        }
                    }
                    endBlockInfo.offset--;
                }
                if (startBlockInfo.paragraph === commentStartBlockInfo.paragraph) {
                    let updateStartPosition: boolean = commentStartBlockInfo.offset < startBlockInfo.offset;
                    if (commentToDelete.replyComments.length > 0) {
                        for (let m: number = 0; m < commentToDelete.replyComments.length; m++) {
                            let replyComment: CommentElementBox = commentToDelete.replyComments[m];
                            if (!isNullOrUndefined(replyComment.commentStart)) {
                                let replyCommentStart: ParagraphInfo = this.selection.getParagraphInfoInternal(replyComment.commentStart.line, replyComment.commentStart.line.getOffset(replyComment.commentStart, 0));
                                if (replyCommentStart.offset < startBlockInfo.offset) {
                                    startBlockInfo.offset--;
                                }
                                if (endBlockInfo.paragraph === commentStartBlockInfo.paragraph) {
                                    endBlockInfo.offset--;
                                }
                            }
                        }
                    }
                    if (updateStartPosition) {
                        startBlockInfo.offset--;
                    }
                    if (endBlockInfo.paragraph === commentStartBlockInfo.paragraph) {
                        endBlockInfo.offset--;
                    }
                }
                this.deleteCommentInternal(commentToDelete);
            }
            if (comments.commentStartInfo.length > 0) {
                for (let k: number = 0; k < comments.commentStartInfo.length; k++) {
                    if (comments.commentStartInfo[k].line.paragraph.equals(endBlockInfo.paragraph)) {
                        endBlockInfo.offset--;
                    }
                    this.removeInline(comments.commentStartInfo[k]);
                }
            }
            const startLineInfo: LineInfo = selection.getLineInfoBasedOnParagraph(startBlockInfo.paragraph, startBlockInfo.offset);
            selection.start.setPositionFromLine(startLineInfo.line, startLineInfo.offset);

            const endLineInfo: LineInfo = selection.getLineInfoBasedOnParagraph(endBlockInfo.paragraph, endBlockInfo.offset);
            selection.end.setPositionFromLine(endLineInfo.line, endLineInfo.offset);
        }
        return comments.commentStartInfo;
    }
    private updateHistoryForComments(removedCommentStart: CommentCharacterElementBox[]): void {
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)
            && this.editorHistory.currentHistoryInfo.action === 'RemoveComment') {
            if (!isNullOrUndefined(removedCommentStart)) {
                for (let i: number = 0; i < removedCommentStart.length; i++) {
                    this.initInsertInline(removedCommentStart[i], false);
                }
            }
            this.editorHistory.currentHistoryInfo.endPosition = this.selection.startOffset;
            this.editorHistory.updateComplexHistory();
        }
    }    
    /**
     * Removes an empty paragraph from in the current selection position.
     *
     * This method handles the removal of empty paragraphs by determining the appropriate deletion strategy based on the paragraph's context. 
     * Only operates when both the paragraph and current selection are empty.
     *
     * @returns {void}
     */
    public removeEmptyParagraph(): void {
        let paragraph: ParagraphWidget = this.documentHelper.selection.start.paragraph;
        if (paragraph.isEmpty() && this.selection.isEmpty) {
            let currentBody: Widget = paragraph.containerWidget;
            let prevBody: Widget = currentBody.previousRenderedWidget;
            let nextBody: Widget = currentBody.nextRenderedWidget;
            if (currentBody instanceof BodyWidget && currentBody.childWidgets.length == 1) {
                if (currentBody.equals(prevBody)) {
                    this.onBackSpace();
                }
                else if (currentBody.equals(nextBody)) {
                    this.delete();
                }
                else {
                    return;
                }
            }
            else if (paragraph.isInsideTable && paragraph.nextWidget == undefined) {
                this.onBackSpace();
            }
            else {
                this.delete();
            }
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public onBackSpace(): void {
        this.isDeleteOrBackSpace = true;
        let selection: Selection = this.documentHelper.selection;
        if (selection.contextType != 'List') {
            selection.skipFormatRetrieval = true;
        }
        if (!selection.isEmpty) {
            const selectionBookmark: string[] = selection.bookmarks;
            if (selectionBookmark.length > 0) {
                this.extendSelectionToBookmarkStart(selectionBookmark);
            }
        }
        if (selection.isEmpty) {
            this.singleBackspace(selection, false);
        } else {
            if (this.owner.enableTrackChanges && this.canSkipDeleteTrack(selection)) {
                return;
            }
            let comments: CommentCharacterElementBox[] = this.checkAndRemoveComments();
            this.initHistory('BackSpace');
            let skipBackSpace: boolean = this.deleteSelectedContents(selection, true);
            selection.skipFormatRetrieval = false;
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                if (skipBackSpace) {
                    this.editorHistory.currentBaseHistoryInfo = undefined;
                } else {
                    if (this.checkEndPosition(selection)) {
                        this.updateHistoryPosition(selection.end, false);
                    }
                    this.isSkipOperationsBuild = !isNullOrUndefined(this.alertDialog);
                    this.reLayout(selection);
                    this.isSkipOperationsBuild = false;
                    this.insertSpaceInFormField();
                }
            }

            if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
                for (let k: number = 0; k < comments.length; k++) {
                    this.initInsertInline(comments[k], false);
                }
                this.editorHistory.currentHistoryInfo.endPosition = this.selection.startOffset;
                this.editorHistory.updateComplexHistory();
            }
            if (this.owner.isSpellCheck) {
                this.documentHelper.triggerSpellCheck = false;
            }
        }
        this.isDeleteOrBackSpace = false;
        this.documentHelper.layout.islayoutFootnote = false;
        this.updateXmlMappedContentControl();
    }
    private canSkipDeleteTrack(selection: Selection): boolean {
        let startPosition: TextPosition = selection.start;
        let endPosition: TextPosition = selection.end;
        if (!selection.start.isExistBefore(selection.end)) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        if ((!startPosition.paragraph.isInsideTable && endPosition.paragraph.isInsideTable) ||
            (startPosition.paragraph.isInsideTable && endPosition.paragraph.isInsideTable && this.documentHelper.layout.getParentCell(startPosition.paragraph.associatedCell) === this.documentHelper.layout.getParentCell(endPosition.paragraph.associatedCell)
                && startPosition.paragraph.associatedCell !== endPosition.paragraph.associatedCell && startPosition.paragraph.associatedCell.ownerTable !== endPosition.paragraph.associatedCell.ownerTable)) {
            let isSelectionAtParagraphStart: boolean = startPosition.offset === selection.getStartOffset(startPosition.paragraph) && selection.start.currentWidget.isFirstLine();
            let cell: TableCellWidget = selection.getContainerCell(endPosition.paragraph.associatedCell);
            let ownerTable: TableWidget = cell.ownerTable;
            let lastChild = ownerTable.childWidgets[ownerTable.childWidgets.length - 1] as TableRowWidget;
            if (!isSelectionAtParagraphStart && !selection.containsRow(lastChild, endPosition.paragraph.associatedCell)) {
                return true;;
            }
        }
        return false;
    }
    /**
     * @private
     * @returns {boolean}
     */
    public insertRemoveBookMarkElements(isUpdateComplexHistory: boolean): boolean {
        let isHandledComplexHistory: boolean = false;
        let isUpdateHistory: boolean = false;
        if(!this.isRemoteAction) {
            for (let i: number = 0; i < this.removedBookmarkElements.length; i++) {
                let bookMark: BookmarkElementBox = this.removedBookmarkElements[i];
                if (bookMark.bookmarkType === 0) {
                    let bookMarkStart: BookmarkElementBox = bookMark;
                    if (bookMarkStart && bookMarkStart.reference && this.removedBookmarkElements.indexOf(bookMarkStart.reference) !== -1) {
                        let endIndex: number = this.removedBookmarkElements.indexOf(bookMarkStart.reference);
                        let startIndex: number = this.removedBookmarkElements.indexOf(bookMarkStart);
                        this.removedBookmarkElements.splice(endIndex, 1);
                        this.removedBookmarkElements.splice(startIndex, 1);
                        i--;
                    } else {
                        if (this.editorHistory.currentBaseHistoryInfo && !isUpdateComplexHistory) {
                            this.initComplexHistory(this.editorHistory.currentBaseHistoryInfo.action);
                            this.editorHistory.updateHistory();
                        }
                        this.initInsertInline(bookMarkStart.clone(), undefined, true);
                        isUpdateHistory = true;
                    }
                } else {
                    let bookMarkEnd: BookmarkElementBox = bookMark;
                    if (bookMarkEnd && bookMarkEnd.reference && this.removedBookmarkElements.indexOf(bookMarkEnd.reference) !== -1) {
                        let endIndex: number = this.removedBookmarkElements.indexOf(bookMarkEnd.reference);
                        let startIndex: number = this.removedBookmarkElements.indexOf(bookMarkEnd);
                        this.removedBookmarkElements.splice(endIndex, 1);
                        this.removedBookmarkElements.splice(startIndex, 1);
                        i--;
                    } else {
                        if (this.editorHistory.currentBaseHistoryInfo && !isUpdateComplexHistory) {
                            this.initComplexHistory(this.editorHistory.currentBaseHistoryInfo.action);
                            this.editorHistory.updateHistory();
                        }
                        this.initInsertInline(bookMarkEnd.clone(), undefined, true);
                        isUpdateHistory = true;
                    }
                }
            }
        }
        if (isUpdateHistory && this.editorHistory.currentHistoryInfo && this.removedContentControlElements.length === 0 && this.removedEditRangeStartElements.length === 0 && this.removedEditRangeEndElements.length === 0) {
            this.editorHistory.updateComplexHistory();
            isHandledComplexHistory = true;
        }
        this.removedBookmarkElements = [];
        return isHandledComplexHistory;
    }
    /**
     * @private
     * @returns {boolean}
     */
    public insertRemoveContentControlElements(isUpdateComplexHistory: boolean): boolean {
        let isHandledComplexHistory: boolean = false;
        if (!this.isRemoteAction) {
            for (let i: number = 0; i < this.removedContentControlElements.length; i++) {
                let contentControl: ContentControl = this.removedContentControlElements[i];
                if (contentControl.type === 0) {
                    let contentControlStart: ContentControl = contentControl;
                    if (contentControlStart && contentControlStart.reference && this.removedContentControlElements.indexOf(contentControlStart.reference) !== -1) {
                        let endIndex: number = this.removedContentControlElements.indexOf(contentControlStart.reference);
                        let startIndex: number = this.removedContentControlElements.indexOf(contentControlStart);
                        this.removedContentControlElements.splice(endIndex, 1);
                        this.removedContentControlElements.splice(startIndex, 1);
                        i--;
                    } else {
                        if (this.editorHistory.currentBaseHistoryInfo && !isUpdateComplexHistory) {
                            this.initComplexHistory(this.editorHistory.currentBaseHistoryInfo.action);
                            this.editorHistory.updateHistory();
                        }
                        this.initInsertInline(contentControlStart.clone(), undefined, true);
                        if (this.editorHistory.currentHistoryInfo && i === this.removedContentControlElements.length - 1 && this.removedBookmarkElements.length === 0 && this.removedEditRangeStartElements.length === 0 && this.removedEditRangeEndElements.length === 0) {
                            this.editorHistory.updateComplexHistory();
                            isHandledComplexHistory = true;
                        }
                    }
                } else {
                    let contentControlEnd: ContentControl = contentControl;
                    if (contentControlEnd && contentControlEnd.reference && this.removedContentControlElements.indexOf(contentControlEnd.reference) !== -1) {
                        let endIndex: number = this.removedContentControlElements.indexOf(contentControlEnd.reference);
                        let startIndex: number = this.removedContentControlElements.indexOf(contentControlEnd);
                        this.removedContentControlElements.splice(endIndex, 1);
                        this.removedContentControlElements.splice(startIndex, 1);
                        i--;
                    } else {
                        if (this.editorHistory.currentBaseHistoryInfo && !isUpdateComplexHistory) {
                            this.initComplexHistory(this.editorHistory.currentBaseHistoryInfo.action);
                            this.editorHistory.updateHistory();
                        }
                        this.initInsertInline(contentControlEnd.clone(), undefined, true);
                        if (this.editorHistory.currentHistoryInfo && i === this.removedContentControlElements.length - 1 && this.removedBookmarkElements.length === 0 && this.removedEditRangeStartElements.length === 0 && this.removedEditRangeEndElements.length === 0) {
                            this.editorHistory.updateComplexHistory();
                            isHandledComplexHistory = true;
                        }
                    }
                }
            }
        }
        this.removedContentControlElements = [];
        return isHandledComplexHistory;
    }
    /**
     * @private
     * @returns {boolean}
     */
    public insertRemovedEditRangeEndElements(isUpdateComplexHistory: boolean): boolean {
        let isHandledComplexHistory: boolean = false;
        if(!this.isRemoteAction) {
            for (let i: number = this.removedEditRangeEndElements.length - 1; i >= 0; i--) {
                let editRangeEndElementBox: EditRangeEndElementBox = this.removedEditRangeEndElements[i];
                if (editRangeEndElementBox && this.removedEditRangeStartElements.indexOf(editRangeEndElementBox.editRangeStart) !== -1) {
                    let endIndex: number = this.removedEditRangeEndElements.indexOf(editRangeEndElementBox);
                    let startIndex: number = this.removedEditRangeStartElements.indexOf(editRangeEndElementBox.editRangeStart);
                    this.removedEditRangeEndElements.splice(endIndex, 1);
                    this.removedEditRangeStartElements.splice(startIndex, 1);
                    i--;
                } else {
                    if (this.editorHistory.currentBaseHistoryInfo && !isUpdateComplexHistory) {
                        this.initComplexHistory(this.editorHistory.currentBaseHistoryInfo.action);
                        this.editorHistory.updateHistory();
                    }
                    this.initInsertInline(editRangeEndElementBox.clone(), undefined, true);
                    let inlineObj: ElementInfo = this.selection.start.paragraph.getInline(this.selection.start.offset, 0);
                    (inlineObj.element as EditRangeEndElementBox).editRangeStart.editRangeEnd = inlineObj.element as EditRangeEndElementBox;
                    if (this.editorHistory.currentHistoryInfo && i === 0 && this.removedContentControlElements.length === 0 && this.removedEditRangeStartElements.length === 0 && this.removedBookmarkElements.length === 0) {
                        this.editorHistory.updateComplexHistory();
                        isHandledComplexHistory = true;
                    }
                }
            }
        }
        this.removedEditRangeEndElements = [];
        return isHandledComplexHistory;
    }
    /**
     * @private
     * @returns {boolean}
     */
    public insertRemovedEditRangeStartElements(isUpdateComplexHistory: boolean): boolean {
        let isHandledComplexHistory: boolean = false;
        if(!this.isRemoteAction) {
            for (let i: number = 0; i < this.removedEditRangeStartElements.length; i++) {
                let editRangeStartElementBox: EditRangeStartElementBox = this.removedEditRangeStartElements[i];
                if (editRangeStartElementBox && this.removedEditRangeEndElements.indexOf(editRangeStartElementBox.editRangeEnd) !== -1) {
                    let endIndex: number = this.removedEditRangeEndElements.indexOf(editRangeStartElementBox.editRangeEnd);
                    let startIndex: number = this.removedEditRangeStartElements.indexOf(editRangeStartElementBox);
                    this.removedEditRangeEndElements.splice(endIndex, 1);
                    this.removedEditRangeStartElements.splice(startIndex, 1);
                    i--;
                } else {
                    if (this.editorHistory.currentBaseHistoryInfo && !isUpdateComplexHistory) {
                        this.initComplexHistory(this.editorHistory.currentBaseHistoryInfo.action);
                        this.editorHistory.updateHistory();
                    }
                    this.initInsertInline(editRangeStartElementBox.clone(), undefined, true);
                    let inlineObj: ElementInfo = this.selection.start.paragraph.getInline(this.selection.start.offset, 0);
                    (inlineObj.element as EditRangeStartElementBox).editRangeEnd.editRangeStart = inlineObj.element as EditRangeStartElementBox;
                    if (this.editorHistory.currentHistoryInfo && i === this.removedEditRangeStartElements.length - 1 && this.removedContentControlElements.length === 0 && this.removedBookmarkElements.length === 0 && this.removedEditRangeEndElements.length === 0) {
                        this.editorHistory.updateComplexHistory();
                        isHandledComplexHistory = true;
                    }
                }
            }
        }
        this.removedEditRangeStartElements = [];
        return isHandledComplexHistory;
    }
    /**
     * @private
     * @param {Selection} selection - Specifies the selection
     * @param {boolean} isBackSpace - Specifies is backspace.
     * @returns {boolean}
     */
    public deleteSelectedContents(selection: Selection, isBackSpace: boolean): boolean {
        let skipBackSpace: boolean = this.deleteSelectedContentInternal(selection, isBackSpace, selection.start, selection.end);
        let textPosition: TextPosition = selection.getTextPosBasedOnLogicalIndex(selection.editPosition);
        selection.selectContent(textPosition, true);
        return skipBackSpace;
    }
    private removeWholeElement(selection: Selection): void {
        this.initHistory('BackSpace');
        this.deleteSelectedContents(selection, true);
        if (this.checkEndPosition(selection)) {
            this.updateHistoryPosition(selection.end, false);
        }
        this.reLayout(selection);
    }
    /**
     * @private
     */
    public getSelectedComments(): SelectedCommentInfo {
        let comments: CommentElementBox[] = this.documentHelper.comments;
        let commentEnds: CommentCharacterElementBox[] = [];
        let commentStarts: CommentCharacterElementBox[] = [];
        for (let i: number = 0; i < comments.length; i++) {
            let comment: CommentElementBox = comments[i];
            let commentEnd: CommentCharacterElementBox = comment.commentEnd;
            let commentStart: CommentCharacterElementBox = comment.commentStart;
            if (!isNullOrUndefined(commentEnd) && this.selection.isElementInSelection(commentEnd, true)) {
                commentEnds.push(commentEnd);
            } else if (!isNullOrUndefined(commentStart) && this.selection.isElementInSelection(commentStart, false)) {
                commentStarts.push(commentStart);
                for (let j: number = 0; j < comment.replyComments.length; j++) {
                    if (comment.replyComments[j].commentStart) {
                        commentStarts.push(comment.replyComments[j].commentStart);
                    }
                }
            }
        }
        return { commentStartInfo: commentStarts, commentEndInfo: commentEnds };
    }
    /**
     * Remove single character on left of cursor position
     *
     * @param {Selection} selection - Specifies the selection
     * @param {boolean} isRedoing - Specified the is redoing.
     * @private
     * @returns {void}
     */
    public singleBackspace(selection: Selection, isRedoing: boolean): void {
        let history: EditorHistory = this.editorHistory;
        // If backspace is pressed after auto format to hyperlink is done, need to undo auto format.
        if (history && !isRedoing && !history.canRedo() && history.canUndo()) {
            let historyInfo: BaseHistoryInfo = history.undoStack[history.undoStack.length - 1];
            let startBlockInfo: ParagraphInfo = this.selection.getParagraphInfo(selection.start);
            let endBlockInfo: ParagraphInfo = this.selection.getParagraphInfo(selection.end);

            if (historyInfo.action === 'AutoFormatHyperlink' && historyInfo.insertPosition === this.selection.getHierarchicalIndex(startBlockInfo.paragraph, startBlockInfo.offset.toString()) &&
                historyInfo.endPosition === this.selection.getHierarchicalIndex(endBlockInfo.paragraph, endBlockInfo.offset.toString())) {
                history.undo();
                return;
            }
        }
        let isCommentDelete: boolean = false;
        let paragraph: ParagraphWidget = selection.start.paragraph;
        let currentLineWidget: LineWidget = selection.start.currentWidget;
        let offset: number = selection.start.offset;
        let indexInInline: number = 0;
        let inlineObj: ElementInfo = currentLineWidget.getInline(offset, indexInInline);
        let inline: ElementBox = inlineObj.element;
        let initComplextHistory: boolean = false;
        let previousOffset: number = offset;
        let updateSelection: boolean = false;
        let previousNode: ElementBox;
        while (inline instanceof CommentCharacterElementBox) {
            let commentMark: CommentCharacterElementBox = inline;
            inline = inline.previousNode;
            if (isNullOrUndefined(inline)) {
                inline = previousNode;
            }
            if (!isNullOrUndefined(inline) && (inline as CommentCharacterElementBox).commentType == 0) {
                previousNode = inline.previousNode;
            } else if (inline instanceof ListTextElementBox) {
                inline = undefined;
            }
            if (inline) {
                previousOffset = inline.length;
            }
            if (commentMark.commentType === 0 && (isNullOrUndefined(inline) || !(inline instanceof CommentCharacterElementBox))) {
                if (isNullOrUndefined(inline)) {
                    inline = commentMark;
                    previousOffset = 0;
                } else {
                    previousOffset = inline.length;
                }
                updateSelection = true;
                break;
            } else if (commentMark.commentType === 1) {
                if (!initComplextHistory) {
                    this.initComplexHistory('RemoveComment');
                    initComplextHistory = true;
                }
                this.isSkipOperationsBuild = this.owner.enableCollaborativeEditing;
                this.deleteCommentInternal(commentMark.comment);
                this.isSkipOperationsBuild = false;
                updateSelection = true;
            }
        }
        if (!isNullOrUndefined(inline) && inline.characterFormat.hidden) {
            return;
        }
        if (updateSelection) {
            //When paragraph has only comment end mark, there will be no previous inline and comment end mark will be delete
            //And paragraph will become empty paragraph.
            //So handled special case to update selection.
            if (isNullOrUndefined(inline)) {
                let lineWidget: LineWidget = paragraph.childWidgets[0] as LineWidget;
                selection.start.setPositionParagraph(lineWidget, 0);
                selection.end.setPositionParagraph(lineWidget, 0);
            } else {
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, previousOffset);
                selection.start.setPositionParagraph(inline.line, offset);
                selection.end.setPositionParagraph(inline.line, offset);
            }
        }
        if (inline instanceof ContentControl && inline.type != 0) {
            if (inline.type === 1) {
                if (inline.contentControlProperties.lockContents) {
                    this.selection.selectContentConterol(inline.reference);
                } else {
                    this.selection.selectContentControlInternal(inline.reference);
                }
            }
            return;
        }
        let contentControl: ContentControl = this.selection.currentContentControl;
        if (contentControl && contentControl.contentControlProperties && contentControl.contentControlProperties.lockContents) {
            return;
        }
        if (this.selection.isInlineFormFillMode()) {
            if (inline instanceof FieldElementBox && inline.fieldType === 2) {
                return;
            }
            let resultText: string = this.getFieldResultText();
            if (resultText.length === 1) {
                this.selection.selectFieldInternal(this.selection.getCurrentFormField());

                this.insertTextInternal(this.documentHelper.textHelper.repeatChar(this.documentHelper.textHelper.getEnSpaceCharacter(), 5), true);
                this.selection.selectTextElementStartOfField(this.selection.getCurrentFormField());
                return;
            }
        }
        indexInInline = inlineObj.index;
        if (inline instanceof TextElementBox) {
            (inline as TextElementBox).ignoreOnceItems = [];
        }
        let previousInline: ElementBox = inline;
        if (inline instanceof FieldElementBox && inline.fieldType === 2) {
            if (HelperMethods.isLinkedFieldCharacter(inline)) {
                let begin: FieldElementBox = inline.fieldBegin;
                let end: ElementBox = inline.fieldEnd;
                if (begin.nextNode instanceof BookmarkElementBox && begin.nextNode.reference) {
                    end = begin.nextNode.reference;
                }
                selection.start.setPositionParagraph(begin.line, begin.line.getOffset(begin, 0));
                selection.end.setPositionParagraph(end.line, end.line.getOffset(end, 0) + 1);
                selection.fireSelectionChanged(true);
                return;
            }
        }
        if (!this.owner.enableTrackChanges && inline instanceof FootnoteElementBox) {
            if (inline.footnoteType === 'Footnote') {
                this.removeFootnote(inline);
            } else {
                this.removeEndnote(inline);
            }
        }
        if (inline && (inline instanceof ContentControl || inline.previousNode instanceof ContentControl)) {
            if (inline instanceof ContentControl && inline.previousNode && !(inline.previousElement instanceof ListTextElementBox)) {
                inline = inline.previousNode;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, inline.length);
            }
            if (inline && inline.length === 1 && inline.nextNode instanceof ContentControl
                && inline.previousNode instanceof ContentControl && !this.documentHelper.isFormFillProtectedMode) {
                let start: ContentControl = inline.previousNode;
                let end: ContentControl = inline.nextNode;
                if (!start.contentControlProperties.lockContentControl) {
                    selection.start.setPositionParagraph(start.line, start.line.getOffset(start, 0));
                    selection.end.setPositionParagraph(end.line, end.line.getOffset(end, 0) + 1);
                    this.removeWholeElement(selection);
                    return;
                }
            }
            if (inline instanceof ContentControl && inline.type == 0 && inline.nextNode instanceof ContentControl && inline.nextNode.type == 1) {
                var begin = inline;
                var end = inline.nextNode;
                selection.start.setPositionParagraph(begin.line, begin.line.getOffset(begin, 0));
                selection.end.setPositionParagraph(end.line, end.line.getOffset(end, 0) + 1);
                this.removeWholeElement(selection);
                return;
            } else if (inline instanceof ContentControl && inline.type == 0 && inline.contentControlWidgetType === 'Block' && inline.reference && inline.paragraph !== inline.reference.paragraph) {
                return;
            }
        }
        // if (inline instanceof CommentCharacterElementBox && inline.commentType === 1) {
        //     let comment: CommentElementBox = inline.comment;
        //     if (comment.isReply) {
        //         comment = comment.ownerComment;
        //     }
        //     while (inline instanceof CommentCharacterElementBox) {
        //         inline = inline.previousNode;
        //     }
        //     this.deleteCommentInternal(comment);
        //     paragraph = inline.line.paragraph;
        //     offset = inline.line.getOffset(inline, inline.length);
        //     selection.start.setPositionParagraph(inline.line, offset);
        //     selection.end.setPositionParagraph(inline.line, offset);
        //     isCommentDelete = true;
        // }
        if (inline instanceof FieldElementBox && inline.fieldType === 1 && !this.selection.isInlineFormFillMode()) {
            let prevInline: ElementBox = selection.getPreviousValidElement(inline);
            if (prevInline instanceof FieldElementBox && prevInline.fieldType !== 0) {
                inline = (prevInline as FieldElementBox).fieldBegin;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 0);
                if (inline.nextNode instanceof BookmarkElementBox && inline.nextNode.reference) {
                    let start: BookmarkElementBox = inline.nextNode.reference;
                    selection.start.setPositionParagraph(start.line, start.line.getOffset(start, 1));
                }
                selection.end.setPositionParagraph(inline.line, offset); //Selects the entire field.
                selection.fireSelectionChanged(true);
                return;
            } else if (prevInline !== inline) {
                inline = prevInline; //Updates the offset to delete next content.
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, inline.length);
            }
        }
        if (inline instanceof EditRangeStartElementBox || inline instanceof EditRangeEndElementBox) {
            if ((inline.nextNode instanceof EditRangeEndElementBox && (inline as EditRangeStartElementBox).editRangeEnd === inline.nextNode)
                || (inline.previousNode instanceof EditRangeStartElementBox
                    && (inline as EditRangeEndElementBox).editRangeStart === inline.previousNode)) {
                return;
            }
            if (inline instanceof EditRangeStartElementBox && !(inline.previousNode instanceof EditRangeEndElementBox)) {
                return;
            }
            if (this.documentHelper.isDocumentProtected &&
                this.documentHelper.protectionType === 'ReadOnly') {
                if (inline instanceof EditRangeStartElementBox || inline instanceof EditRangeEndElementBox) {
                    return;
                }
            } 
            if (inline instanceof EditRangeEndElementBox) {
                do {
                    if (!isNullOrUndefined(inline.previousNode)) {
                        inline = inline.previousNode;
                        paragraph = inline.line.paragraph;
                        offset = inline.line.getOffset(inline, inline.length);
                    } else { break; }
                } while(inline instanceof EditRangeEndElementBox);
            }
            if (inline.length === 1 && inline.nextNode instanceof EditRangeEndElementBox
                && inline.previousNode instanceof EditRangeStartElementBox) {
                let start: EditRangeStartElementBox = inline.previousNode;
                let end: EditRangeEndElementBox = inline.nextNode;
                selection.start.setPositionParagraph(start.line, start.line.getOffset(start, 0));
                selection.end.setPositionParagraph(end.line, end.line.getOffset(end, 0) + 1);
                this.removeWholeElement(selection);
                return;
            }
        }
        if (inline && (inline instanceof BookmarkElementBox || inline.previousNode instanceof BookmarkElementBox)) {
            if (this.documentHelper.isDocumentProtected &&
                this.documentHelper.protectionType === 'ReadOnly') {
                if (inline.previousNode && inline.previousNode instanceof EditRangeStartElementBox || inline.previousNode instanceof EditRangeEndElementBox) {
                    return;
                }
            }
            if (inline instanceof BookmarkElementBox) {
                if (inline.previousNode) {
                    inline = inline.previousNode;
                    if (inline instanceof FieldElementBox && !this.selection.isInlineFormFillMode()) {
                        inline = inline.fieldBegin;
                        paragraph = inline.line.paragraph;
                        offset = inline.line.getOffset(inline, 0);
                        if (inline.nextNode instanceof BookmarkElementBox && inline.nextNode.reference) {
                            var start = inline.nextNode.reference;
                            selection.start.setPositionParagraph(start.line, start.line.getOffset(start, 1));
                        }
                        selection.end.setPositionParagraph(inline.line, offset);
                        selection.fireSelectionChanged(true);
                        return;
                    }
                    paragraph = inline.line.paragraph;
                    offset = inline.line.getOffset(inline, inline.length);
                    selection.start.setPositionFromLine(inline.line, offset);
                    selection.end.setPositionInternal(selection.start);
                } else {
                    if (inline.bookmarkType === 1) {
                        // remove paragraph mark and move bookmark to previous paragraph
                        if (paragraph.previousRenderedWidget instanceof ParagraphWidget) {
                            let prevParagraph: ParagraphWidget = paragraph.previousRenderedWidget;
                            let line: LineWidget = prevParagraph.lastChild as LineWidget;
                            selection.start.setPositionParagraph(inline.line, inline.line.getOffset(inline, 0));
                            selection.end.setPositionParagraph(line, line.getEndOffset());
                            this.removeWholeElement(selection);
                            return;
                        }
                    } else {
                        if (inline.paragraph.previousWidget instanceof ParagraphWidget) {
                            selection.start.setPositionFromLine(inline.line, 0);
                            selection.end.setPositionInternal(selection.start);
                            offset = 0;
                        } else {
                            return;
                        }
                    }
                }
                // Remove bookmark if selection is in between bookmark start and end element.
            } else if (inline.nextNode instanceof BookmarkElementBox && inline instanceof BookmarkElementBox &&
                inline.bookmarkType === 0 && inline.reference === inline.nextNode) {
                this.deleteBookmark(inline.name);
                return;
            }
            if (inline.length === 1 && inline.nextNode instanceof BookmarkElementBox && inline.previousNode instanceof BookmarkElementBox) {
                let begin: BookmarkElementBox = inline.previousNode;
                let end: BookmarkElementBox = inline.nextNode;
                selection.start.setPositionParagraph(begin.line, begin.line.getOffset(begin, 0));
                selection.end.setPositionParagraph(end.line, end.line.getOffset(end, 0) + 1);
                this.removeWholeElement(selection);
                return;
            }
        }
        let isSelectionAtParagraphStart: boolean = offset === selection.getStartOffset(paragraph) && selection.start.currentWidget.isFirstLine();
        if (this.owner.enableTrackChanges && !isSelectionAtParagraphStart && this.canSkipDeleteTracking(inline, true)) {
            return;
        } else if (this.owner.enableTrackChanges && isSelectionAtParagraphStart) {
            let previousBlock: BlockWidget = paragraph.previousRenderedWidget as BlockWidget;
            if (previousBlock instanceof ParagraphWidget && previousBlock.characterFormat.revisionLength > 0
                && this.isDeleteRevisionByCurrentUser(previousBlock.characterFormat)) {
                let endOffset: number = this.documentHelper.selection.getLineLength(previousBlock.lastChild as LineWidget);
                let previousIndex: number = previousBlock.childWidgets.length - 1;
                selection.selects(previousBlock.childWidgets[previousIndex] as LineWidget, endOffset, false);
                return;
            }
        } 
         
        if (!isRedoing) {
            this.initHistory('BackSpace');
        }
       
            if (isSelectionAtParagraphStart) {
            if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId !== -1) {
                // BUG_859140 - handled backspace for list as per word desktop behaviour
                if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.undoStack) && this.editorHistory.undoStack.length > 0 &&
                this.editorHistory.undoStack[this.editorHistory.undoStack.length - 1].action === 'ListFormat') {
                    this.onApplyListInternal(this.documentHelper.getListById(paragraph.paragraphFormat.listFormat.listId), paragraph.paragraphFormat.listFormat.listLevelNumber - 1);
                } else {
                    this.onApplyList(undefined);
                }
                return;
            }
            if (paragraph.paragraphFormat.firstLineIndent !== 0) {
                this.onApplyParagraphFormat('firstLineIndent', 0, false, false);
                if (paragraph.paragraphFormat.leftIndent !== 0) {
                    this.onApplyParagraphFormat('leftIndent', 0, false, false);
                }
                return;
            }
            if (paragraph.paragraphFormat.leftIndent !== 0) {
                this.onApplyParagraphFormat('leftIndent', 0, false, false);
                return;
            }
            if (!paragraph.paragraphFormat.bidi && paragraph.paragraphFormat.textAlignment !== 'Left') {
                this.onApplyParagraphFormat('textAlignment', 'Left', false, true);
                return;
            }
            if (paragraph.previousRenderedWidget instanceof ParagraphWidget) {                
                let previousParagraph: ParagraphWidget = paragraph.previousRenderedWidget as ParagraphWidget;
                // if (isNullOrUndefined(previousParagraph)) {
                //     previousParagraph = this.documentHelper.selection.getPreviousBlock(paragraph) as ParagraphWidget;
                // }
                if (previousParagraph.characterFormat.hidden) {
                    return;
                }
                selection.owner.isShiftingEnabled = true;
                if (this.owner.enableTrackChanges && previousParagraph != undefined && (previousParagraph.characterFormat.revisionLength === 0 || !this.isInsertRevisionByCurrentUser(previousParagraph.characterFormat))) {
                    let endOffset: number = this.documentHelper.selection.getLineLength(previousParagraph.lastChild as LineWidget);
                    let previousIndex: number = previousParagraph.childWidgets.length - 1;
                    let canTrack: boolean = !this.isDeleteRevisionByCurrentUser(previousParagraph.characterFormat);
                    if (canTrack) {
                        let deleteRevision: Revision = this.retrieveRevisionByType(previousParagraph.characterFormat, 'Deletion');
                        if (previousParagraph.characterFormat.revisionLength > 0 && !isNullOrUndefined(deleteRevision)) {
                            this.owner.editorModule.initComplexHistory('RemoveAndAddRevision');
                            if (this.editorHistory && this.owner.editorHistory.currentHistoryInfo) {
                                this.owner.editorModule.initHistory('RemoveRevision');
                                let removedRevision: Revision = previousParagraph.characterFormat.getRevision(0);
                                this.owner.editorHistory.currentBaseHistoryInfo.modifiedProperties.push(removedRevision.revisionID);
                                selection.selects(previousParagraph.childWidgets[previousIndex] as LineWidget, endOffset, true);
                                if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                                    this.owner.editorHistory.currentBaseHistoryInfo.updateSelection();
                                }
                                this.editorHistory.updateHistory();
                                this.unlinkRevisionFromItem(previousParagraph.characterFormat);
                                let AddedRevision: Revision = this.insertRevision(previousParagraph.characterFormat, 'Deletion');
                                this.owner.editorModule.initHistory('AddRevision');
                                this.owner.editorHistory.currentBaseHistoryInfo.modifiedProperties.push(AddedRevision.revisionID);
                                this.editorHistory.updateHistory();
                            }
                            if (this.owner.editorHistoryModule) {
                                this.owner.editorHistoryModule.updateComplexHistory();
                            }
                        }
                        else {
                            let revision: Revision = this.insertRevision(previousParagraph.characterFormat, 'Deletion')
                            if (this.owner.editorHistory && this.owner.editorHistory.currentBaseHistoryInfo) {
                                this.owner.editorHistory.currentBaseHistoryInfo.action = 'AddRevision';
                                this.owner.editorHistory.currentBaseHistoryInfo.modifiedProperties.push(revision.revisionID);
                            }
                        }
                    }
                    this.documentHelper.layout.reLayoutParagraph(previousParagraph, previousIndex, 0);
                    selection.selects(previousParagraph.childWidgets[previousIndex] as LineWidget, endOffset, true);
                    if (canTrack && this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                        this.owner.editorHistory.currentBaseHistoryInfo.updateSelection();
                    }
                } else if (previousParagraph.isEmpty() && !this.owner.enableTrackChanges) {
                    this.removePrevParaMarkRevision(paragraph);
                    if (!(paragraph === paragraph.bodyWidget.lastChild && previousParagraph.bodyWidget.index !== paragraph.bodyWidget.index)) {
                        this.removeBlock(previousParagraph);
                        this.addRemovedNodes(previousParagraph);
                        let prevParagraph: ParagraphWidget = paragraph.previousRenderedWidget as ParagraphWidget;
                        if ((!isNullOrUndefined(prevParagraph) && prevParagraph instanceof ParagraphWidget && prevParagraph.isEmpty() && prevParagraph.bodyWidget.index !== paragraph.bodyWidget.index) || previousParagraph.isSectionBreak) {
                            selection.moveToPreviousCharacter();
                        }
                    } else {
                        let endOffset: number = this.documentHelper.selection.getLineLength(previousParagraph.lastChild as LineWidget);
                        let previousIndex: number = previousParagraph.childWidgets.length - 1;
                        selection.selects(previousParagraph.childWidgets[previousIndex] as LineWidget, endOffset, true);
                    }
                } else if(this.owner.enableTrackChanges && previousParagraph.characterFormat.getAllRevision() != undefined && selection.start.isAtParagraphStart && previousParagraph.isEmpty()){
                    this.addRemovedRevisionInfo(previousParagraph.characterFormat);
                    this.addRemovedNodes(previousParagraph);
                    this.removePrevParaMarkRevision(paragraph);
                    this.removeBlock(previousParagraph, false, true);
                } else {
                    let checkCombine: boolean = false;
                    if (!(paragraph === paragraph.bodyWidget.lastChild && previousParagraph.bodyWidget.index !== paragraph.bodyWidget.index) && (paragraph.bodyWidget.sectionFormat.breakCode !== 'NoBreak' || paragraph !== paragraph.bodyWidget.firstChild)) {
                        checkCombine = true;
                    } //When deleteing at para start, 2 nodes should be added in the removed nodes.
                    if (checkCombine) {
                        previousParagraph = previousParagraph.combineWidget(this.owner.viewer) as ParagraphWidget;
                        let currentParagraph: ParagraphWidget = this.splitParagraph(previousParagraph, previousParagraph.firstChild as LineWidget, 0, selection.start.currentWidget, selection.start.offset, true);
                        let blocks: BlockWidget[] = currentParagraph.getSplitWidgets() as BlockWidget[];
                        let splittedWidget: ParagraphWidget = blocks[blocks.length - 1] as ParagraphWidget;
                        let endOffset: number = this.documentHelper.selection.getLineLength(splittedWidget.lastChild as LineWidget);
                        let prevLastLineIndex: number = splittedWidget.childWidgets.length - 1;
                        this.removePrevParaMarkRevision(previousParagraph, true, true);
                        this.deleteParagraphMark(currentParagraph, selection, 0);
                        this.addRemovedNodes(previousParagraph);
                        blocks = currentParagraph.getSplitWidgets() as BlockWidget[];
                        splittedWidget = blocks[blocks.length - 1] as ParagraphWidget;
                        selection.selects(splittedWidget.childWidgets[prevLastLineIndex] as LineWidget, endOffset, true);
                    }
                    else {
                        let endOffset: number = this.documentHelper.selection.getLineLength(previousParagraph.lastChild as LineWidget);
                        let prevLastLineIndex: number = previousParagraph.childWidgets.length - 1;
                        selection.selects(previousParagraph.childWidgets[prevLastLineIndex] as LineWidget, endOffset, true);
                    }
                }
                this.setPositionForHistory();
                const footNoteWidgets: BodyWidget[] = this.documentHelper.layout.getFootNoteWidgetsOf(paragraph);
                if (footNoteWidgets.length > 0) {
                    let layout: Layout = this.documentHelper.layout;
                    let bodyWidget: BodyWidget = paragraph.bodyWidget as BodyWidget;
                    layout.layoutfootNote(bodyWidget.page.footnoteWidget);
                }
                selection.skipFormatRetrieval = false;
                // if (!isRedoing) {
                this.reLayout(selection);
                // }
            } else {
                if (this.editorHistory) {
                    this.editorHistory.currentBaseHistoryInfo = undefined;
                }
            }
        } else {
            if (!isRedoing) {
                selection.owner.isShiftingEnabled = true;
            }
            let paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(selection.start);
            let lineWidget: LineWidget = selection.start.currentWidget;
            let removeOffset: number = offset - 1;
            if (removeOffset < 0) {
                lineWidget = lineWidget.previousLine as LineWidget;
                removeOffset = this.documentHelper.selection.getLineLength(lineWidget) + removeOffset;
            }
            this.removeAtOffset(lineWidget, selection, removeOffset);
            let contentControl: ContentControl = this.selection.currentContentControl;
            if(!isNullOrUndefined(contentControl) && contentControl.contentControlProperties.isTemporary){
                this.removeContentControl();
            }
            this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset - 1, false);
            this.setPositionForHistory();
            selection.skipFormatRetrieval = false;
            if (!isRedoing) {
                this.reLayout(selection);
                if (isCommentDelete) {
                    (this.owner.editorHistoryModule.undoStack[this.owner.editorHistoryModule.undoStack.length - 2] as HistoryInfo).modifiedActions.push(this.owner.editorHistoryModule.undoStack[this.owner.editorHistoryModule.undoStack.length - 1]);
                    this.owner.editorHistoryModule.undoStack.splice(this.owner.editorHistoryModule.undoStack.length - 1, 1);
                    isCommentDelete = false;
                }
            } else {
                this.fireContentChange();
            }
        }

        if (initComplextHistory && this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.editorHistory.currentHistoryInfo.endPosition = this.selection.startOffset;
            this.editorHistory.updateComplexHistory();
        }
    }

    private isSameUserTrackedRecord(revision: Revision[], author: string, type: RevisionType): boolean {
        for (let i: number = 0; i < revision.length; i++) {
            if (revision[i].author === author && revision[i].revisionType === type) {
                return true;
            }
        }
        return false;
    }

    private canSkipDeleteTracking(inline: ElementBox, isBackSpace: boolean): boolean {
        if (!isNullOrUndefined(inline) && !isNullOrUndefined(inline.getAllRevision())
            && inline.revisionLength > 0 && this.isSameUserTrackedRecord(inline.getAllRevision(), this.owner.currentUser ? this.owner.currentUser : 'Guest user', 'Deletion')) {
            if (isBackSpace) {
                this.selection.movePreviousPosition();
            } else {
                this.selection.moveNextPosition();
            }
            return true;
        }
        return false;
    }
    private setPositionForHistory(editPosition?: string): void {
        let selection: Selection = this.documentHelper.selection;
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            if (isNullOrUndefined(editPosition)) {
                this.updateHistoryPosition(selection.start, true);
                this.editorHistory.currentBaseHistoryInfo.endPosition = this.editorHistory.currentBaseHistoryInfo.insertPosition;
            } else {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = editPosition;
                this.editorHistory.currentBaseHistoryInfo.endPosition = editPosition;
            }
        }
    }
    /**
     *
     * @private
     * @returns {void}
     */
    public removeAtOffset(lineWidget: LineWidget, selection: Selection, offset: number): void {
        let count: number = 0;
        let lineIndex: number = lineWidget.paragraph.childWidgets.indexOf(lineWidget);
        let childLength: number = lineWidget.children.length;
        let blockInfo: ParagraphInfo = this.selection.getParagraphInfo(selection.start);
        selection.editPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        for (let i: number = 0; i < childLength; i++) {
            let inline: ElementBox = lineWidget.children[i] as ElementBox;
            if (inline instanceof ListTextElementBox) {
                continue;
            }
            let isBreak: boolean = this.removeCharacter(inline, offset, count, lineWidget, lineIndex, i);
            if (isBreak) {
                break;
            }
            count += inline.length;
        }
    }

    private removeCharacter(inline: ElementBox, offset: number, count: number, lineWidget: LineWidget, lineIndex: number, i: number, isRearrange?: boolean): boolean {
        let isBreak: boolean = false;
        if (inline instanceof BookmarkElementBox && inline.reference && inline.line !== inline.reference.line && !(lineWidget.children[i] instanceof BookmarkElementBox)) {
            if (!isNullOrUndefined(inline.line.previousLine)) {
                inline.line.previousLine.children.splice(inline.line.previousLine.children.length, 0, inline);
                inline.line = inline.line.previousLine;
            } else if (!isNullOrUndefined(inline.line.paragraph.previousRenderedWidget)) {

                (inline.line.paragraph.previousRenderedWidget.lastChild as LineWidget).children.splice((inline.line.paragraph.previousRenderedWidget.lastChild as LineWidget).children.length, 0, inline);
                inline.line = (inline.line.paragraph.previousRenderedWidget.lastChild as LineWidget);
            } else if (!isNullOrUndefined(inline.line.paragraph.nextRenderedWidget)) {

                (inline.line.paragraph.nextRenderedWidget.firstChild as LineWidget).children.splice((inline.line.paragraph.nextRenderedWidget.firstChild as LineWidget).children.length, 0, inline);
                inline.line = (inline.line.paragraph.nextRenderedWidget.firstChild as LineWidget);
            }
            lineWidget.children.splice(i, 1);
            if (!isNullOrUndefined(lineWidget.layoutedElements) && lineWidget.layoutedElements.length > 0) {
                lineWidget.layoutedElements.splice(i, 1);
            }
            return true;
        }
        if (offset < count + inline.length) {
            let indexInInline: number = offset - count;
            inline.isChangeDetected = true;
            if (this.owner.isSpellCheck) {
                // here we are removing errorCollection for next & previous elements for recalculating spellcheck error
                const nextElement: ElementBox = inline.nextElement;
                const previousElement: ElementBox = inline.previousElement;
                this.owner.spellCheckerModule.removeErrorsFromCollection({ 'element': inline, 'text': (inline as TextElementBox).text });
                if (!isNullOrUndefined(nextElement) && nextElement instanceof TextElementBox) {
                    nextElement.isChangeDetected = true;
                    this.owner.spellCheckerModule.removeErrorsFromCollection({ 'element': nextElement, 'text': nextElement.text });
                }
                if (!isNullOrUndefined(previousElement) && previousElement instanceof TextElementBox) {
                    previousElement.isChangeDetected = true;
                    this.owner.spellCheckerModule.removeErrorsFromCollection({ 'element': previousElement, 'text': previousElement.text });
                }
                if (!inline.canTrigger) {
                    this.documentHelper.triggerSpellCheck = false;
                }
            }

            if (offset === count && inline.length === 1) {
                if (this.owner.enableTrackChanges && !this.skipTracking()) {
                    this.addRemovedNodes(inline.clone());
                    this.handleDeleteTracking(inline, indexInInline, 1, i);
                } else {
                    this.unLinkFieldCharacter(inline);
                    this.addRemovedRevisionInfo(inline);
                    this.addRemovedNodes(inline);
                    if (this.owner.enableTrackChanges && this.editorHistory.isRedoing && inline instanceof FootnoteElementBox) {
                        if (inline.footnoteType === 'Footnote') {
                            this.removeFootnote(inline);
                        }
                        else {
                            this.removeEndnote(inline);
                        }
                    }
                    this.combineRevisionsAndViewBasedOnUntrackedContent(inline);
                    let previousNode: ElementBox = inline.previousNode;
                    lineWidget.children.splice(i, 1);
                    this.unlinkRevisionFromItem(inline);
                    if (!isNullOrUndefined(previousNode)) {
                        this.combineElementRevisionToPrevNxt(previousNode);
                    }
                    if (!isNullOrUndefined(lineWidget.layoutedElements) && lineWidget.layoutedElements.length > 0) {
                        lineWidget.layoutedElements.splice(i, 1);
                        if (lineWidget.layoutedElements.length === 0) {
                            lineWidget.layoutedElements = undefined;
                        }
                    }
                }
                this.documentHelper.layout.reLayoutParagraph(lineWidget.paragraph, lineIndex, i, undefined, isRearrange);
            } else {
                let span: ElementBox = this.handleDeleteTracking(inline, indexInInline, 1);
                this.documentHelper.layout.reLayoutParagraph(lineWidget.paragraph, lineIndex, i, undefined, isRearrange);
                if (!isNullOrUndefined(span)) {
                    if (inline.revisionLength > 0) {
                        this.addRemovedRevisionInfo(inline as TextElementBox, span as TextElementBox);
                    }
                    this.addRemovedNodes(span);
                }
            }
            if (inline instanceof EditRangeStartElementBox) {
                this.selection.skipEditRangeRetrieval = true;
                this.removeUserRestrictionsInternal(inline, undefined, true);
                this.selection.updateEditRangeCollection();
                this.fireContentChange();
                this.selection.skipEditRangeRetrieval = false;
            }
            if (inline instanceof BookmarkElementBox) {
                if (inline.bookmarkType === 0 && this.documentHelper.bookmarks.containsKey(inline.name)) {
                    this.documentHelper.bookmarks.remove(inline.name);
                }
            }
            isBreak = true;
        }
        return isBreak;
    }
    private removeCharacterInLine(inline: ElementBox, indexInInline: number, endOffset: number): TextElementBox {
        let span: TextElementBox = new TextElementBox();
        if (inline instanceof TextElementBox) {
            inline.isWidthUpdated = false;
            span.characterFormat.copyFormat(inline.characterFormat);
            let removedCount: number = (endOffset === 1) ? 1 : (endOffset - indexInInline);
            span.text = (inline as TextElementBox).text.substr(indexInInline, removedCount);
            let text: string = (inline as TextElementBox).text;
            (inline as TextElementBox).text = text.substring(0, indexInInline) + text.substring(indexInInline + removedCount, text.length);
            if (inline.contentControlProperties) {
                span.contentControlProperties = inline.contentControlProperties.clone();
            }
        }
        if (inline.revisionLength > 0) {
            for (let i: number = 0; i < inline.revisionLength; i++) {
                inline.getRevision(i).hasChanges = true;
            }
        }
        return span;
    }
    private removeRevisionsInformation(elementBox: ElementBox, elementIndex: number): void {
        let removeElement: ElementBox = elementBox.previousElement;
        let revision: Revision; revision = this.retrieveRevisionInOder(removeElement);
        if (revision.revisionType === 'Insertion') {
            if (this.isRevisionMatched(removeElement, undefined)) {
                elementBox.line.children.splice(elementIndex, 1);
            }
        }
    }

    private handleDeleteTracking(elementBox: ElementBox, indexInInline: number, endOffset: number, elementIndex?: number, isSkipRecordRevision?: Boolean, newParagraph?: ParagraphWidget): ElementBox {
        let isTrackingEnabled: boolean = this.owner.enableTrackChanges;
        let removedNode: ElementBox = undefined;
        if (this.canHandleDeletion() || (isTrackingEnabled && (!this.skipTracking() || (elementBox.paragraph.isInsideTable && !isNullOrUndefined(this.editorHistory) && this.editorHistory.isRedoing && this.editorHistory.currentBaseHistoryInfo && this.editorHistory.currentBaseHistoryInfo.action === "RemoveRowTrack")))) {
            if (elementBox instanceof BookmarkElementBox || elementBox instanceof CommentCharacterElementBox || elementBox instanceof EditRangeStartElementBox || elementBox instanceof EditRangeEndElementBox || elementBox instanceof ContentControl) {
                if (elementBox instanceof BookmarkElementBox && elementBox.previousElement instanceof FieldElementBox && elementBox.previousElement.formFieldData) {
                    if (elementBox.previousElement.revisionLength > 0) {
                        this.removeRevisionsInformation(elementBox, elementIndex);
                    }
                } else {
                    if (isTrackingEnabled && elementBox instanceof BookmarkElementBox) {
                        if (!this.checkToCombineRevisionsInSides(elementBox, 'Deletion')) {
                            this.insertRevision(elementBox, 'Deletion');
                        }
                        this.updateLastDeletedRevision(elementBox);
                    } else {
                        if (!(elementBox instanceof CommentCharacterElementBox)) {
                            elementBox.line.children.splice(elementBox.indexInOwner, 1);
                        }
                        else {
                            let isTrue = false;
                            let parentComment: CommentElementBox = elementBox.comment;
                            if (parentComment && parentComment.ownerComment) {
                                parentComment = parentComment.ownerComment;
                            }
                            if (parentComment) {
                                for (let i = 0; i < this.owner.documentHelper.comments.length; i++) {
                                    if (parentComment.commentId === this.owner.documentHelper.comments[i].commentId) {
                                        isTrue = true;
                                        break;
                                    }
                                }
                            }
                            if (!isTrue || this.isRevisionMatched(elementBox, undefined)) {
                                elementBox.line.children.splice(elementBox.indexInOwner, 1);
                            }
                        }
                    }
                }
                return undefined;
            }
            let isDelete: boolean = false;
            if (this.owner.editorHistoryModule) {

                isDelete = (!isNullOrUndefined(this.owner.editorHistoryModule.currentBaseHistoryInfo) && this.owner.editorHistoryModule.currentBaseHistoryInfo.action === 'Delete');
            }
            if (elementBox.revisionLength > 0) {
                let revision: Revision = this.retrieveRevisionInOder(elementBox);
                let index: number = this.owner.revisions.changes.indexOf(revision);
                if (revision.revisionType === 'Insertion') {
                    // if delete the same user inserted revision
                    if (this.isRevisionMatched(elementBox, undefined)) {
                        // delete the character from the elementBox
                        if (!isNullOrUndefined(this.owner.editorHistoryModule) && !isNullOrUndefined(this.owner.editorHistoryModule.currentBaseHistoryInfo)) {
                            let startValue: number = isNullOrUndefined(elementIndex) ? indexInInline : 0;
                            let endValue: number = isNullOrUndefined(elementIndex) ? ((endOffset === 1) ? 1 : (endOffset - indexInInline)) : elementBox.length;
                            this.owner.editorHistoryModule.currentBaseHistoryInfo.recordInsertRevisionDeletetion(elementBox, startValue, endValue);
                        }
                        if (isNullOrUndefined(elementIndex)) {
                            removedNode = this.removeCharacterInLine(elementBox, indexInInline, endOffset);
                        } else { // delete the entire elementBox
                            this.unLinkFieldCharacter(elementBox);
                            elementBox.line.children.splice(elementIndex, 1);
                            this.owner.trackChangesPane.updateCurrentTrackChanges(revision);
                            if (!isNullOrUndefined(elementBox.line.layoutedElements) && elementBox.line.layoutedElements.length > 0 && elementBox.line.layoutedElements.indexOf(elementBox) !== -1) {
                                elementBox.line.layoutedElements.splice(elementIndex, 1);
                            }
                            if (elementBox.line.children.length === 0) {
                                elementBox.line.layoutedElements = undefined;
                            }
                        }
                        if (elementBox instanceof FootnoteElementBox) {
                            if (elementBox.footnoteType === 'Footnote') {
                                this.removeFootnote(elementBox);
                            }
                            else {
                                this.removeEndnote(elementBox);
                            }
                        }
                    } else { //Insert revision and delete revision (which is to be included) haven't matched
                        // delete the characters from the elementBox
                        if (isNullOrUndefined(elementIndex)) {
                            let text: TextElementBox = this.removeCharacterInLine(elementBox, indexInInline, endOffset);
                            let revision = elementBox.getRevision(0);
                            if (!isNullOrUndefined(revision)) {
                                this.owner.trackChangesPane.updateCurrentTrackChanges(revision);
                            }
                            if (indexInInline === 0) { // if delete element start
                                let prevElement: ElementBox = elementBox.previousElement;
                                this.handleDeletionForInsertRevision(prevElement, elementBox, text, endOffset, indexInInline, true, newParagraph);
                            } else if (elementBox.length !== indexInInline) { // if delete inbetween from the element
                                for (let i: number = elementBox.revisionLength - 1; i >= 0; i--) {
                                    let revision: Revision = elementBox.getRevision(i);
                                    let newElement: TextElementBox = new TextElementBox();
                                    newElement.characterFormat.copyFormat(elementBox.characterFormat);
                                    newElement.line = elementBox.line;
                                    newElement.text = (elementBox as TextElementBox).text.substr(indexInInline);
                                    newElement.insertRevisionAt(0, revision);
                                    text.insertRevisionAt(0, revision);
                                    text.line = elementBox.line;
                                    text.isWidthUpdated = false;
                                    this.owner.trackChangesPane.updateCurrentTrackChanges(revision);
                                    (elementBox as TextElementBox).text = (elementBox as TextElementBox).text.substr(0, indexInInline);
                                    elementBox.isWidthUpdated = false;
                                    let indexInOwner: number = elementBox.indexInOwner;
                                    elementBox.line.children.splice(indexInOwner + 1, 0, newElement);
                                    elementBox.line.children.splice(indexInOwner + 1, 0, text);
                                    if (!this.isElementAddedToNewPara(newParagraph, text)) {
                                        this.addRemovedNodes(text.clone());
                                    }
                                    this.insertRevision(text, 'Deletion');
                                    this.updateLastDeletedRevision(text);
                                }
                            } else if (elementBox.length === indexInInline) { // delete end of element
                                let nextElement: ElementBox = elementBox.nextElement;
                                this.handleDeletionForInsertRevision(nextElement, elementBox, text, endOffset, indexInInline, false, newParagraph);
                            } else {
                                if (endOffset === 1 && this.selection.isEmpty) {
                                    if (!isDelete) {
                                        this.selection.start.movePreviousPosition();
                                        this.selection.end.setPositionInternal(this.selection.start);
                                    }
                                } else {
                                    this.updateCursorForInsertRevision(elementBox, indexInInline, endOffset);
                                }
                                if (!this.isElementAddedToNewPara(newParagraph, text)) {
                                    this.addRemovedNodes(text.clone());
                                }
                                this.insertInlineInternal(text, 'Deletion');
                            }
                        } else if (!this.checkToCombineRevisionsInSides(elementBox, 'Deletion')) {
                            this.insertRevision(elementBox, 'Deletion');
                            this.updateLastDeletedRevision(elementBox);
                        } else {
                            this.updateLastDeletedRevision(elementBox);
                        }
                    }
                } else if (revision.revisionType === 'Deletion') {
                    if (index !== -1 && revision.getRange().length > 0) {
                        let matchedRevisions: Revision[];
                        // delete the entire elementBox
                        if (!isNullOrUndefined(elementIndex)) {
                            elementBox.removeRevision(elementBox.getAllRevision().indexOf(revision));
                            if (!isNullOrUndefined(elementBox.nextNode) && elementBox.nextNode.revisionLength > 0) {
                                matchedRevisions = this.getMatchedRevisionsToCombine(elementBox.nextNode.getAllRevision(), 'Deletion');
                            }
                            // Split the revisions if the revision isn't matched
                            if (matchedRevisions && matchedRevisions.length === 0) {
                                this.checkToSplitRevisionInPrevNxt(elementBox);
                            }
                            if (!this.checkToCombineRevisionsInSides(elementBox as ElementBox, 'Deletion')) {
                                this.updateLastDeletedRevision(elementBox);
                                this.insertRevision(elementBox, 'Deletion');
                            } else {
                                this.updateLastDeletedRevision(elementBox);
                            }
                        } else {
                            this.handleDeleteBySplitting(elementBox, indexInInline, endOffset, newParagraph);
                        }
                    } else {
                        this.updateLastDeletedRevision(elementBox);
                    }
                }
                if (revision.getRange().length === 0) {
                    this.owner.revisions.remove(revision);
                }
            } else { //No revision information in the element
                // delete the entire elementBox
                if (!isNullOrUndefined(elementIndex)) {
                    if (!this.skipFootNoteDeleteTracking) {
                        this.updateLastDeletedRevision(elementBox);
                    }
                    if (!this.checkToCombineRevisionsInSides(elementBox, 'Deletion')) {
                        this.insertRevision(elementBox, 'Deletion');
                    }
                } else {
                    // delete the characters from the elementBox
                    this.handleDeleteBySplitting(elementBox, indexInInline, endOffset, newParagraph);
                }
            }
        } else {
            removedNode = this.removeCharacterInLine(elementBox, indexInInline, endOffset);
            let revision = elementBox.getRevision(0);
            if (!isNullOrUndefined(revision)) {
                this.owner.trackChangesPane.updateCurrentTrackChanges(revision);
            }
        }

        return removedNode;
    }

    private updateLastDeletedRevision(node: ElementBox | ParagraphWidget | TableRowWidget): void {
        if (!this.skipTableElements && !this.isPasteOverWriteCells) {
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo && !this.skipReplace && (!isNullOrUndefined(this.owner.searchModule) ? !this.owner.searchModule.isRepalceTracking : true)) {
                if (isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.lastDeletedNodeRevision)) {
                    this.editorHistory.currentBaseHistoryInfo.lastDeletedNodeRevision = node;
                }
            }
        }
    }

    /**
     * @private
     */
    public retrieveRevisionInOder(elementBox: any): Revision {
        if (elementBox.revisionLength === 1) {
            return elementBox.getRevision(0);
        }
        for (let i: number = 0; i < elementBox.revisionLength; i++) {
            if (elementBox.revisions[i].revisionType === 'Deletion') {
                return elementBox.revisions[i];
            }
        }
        return elementBox.revisions[elementBox.revisionLength - 1];
    }


    private handleDeletionForInsertRevision(elementToEnsure: ElementBox, currentElement: ElementBox, spittedSpan: TextElementBox, endOffset: number, indexInInline: number, isBegin: boolean, newParagraph?: ParagraphWidget): any {

        if (!isNullOrUndefined(elementToEnsure) && currentElement.revisionLength === 0 && this.isRevisionMatched(elementToEnsure, 'Deletion')) {
            if (!this.isElementAddedToNewPara(newParagraph, spittedSpan)) {
                this.addRemovedNodes(spittedSpan.clone());
            }
            this.insertTextInline(elementToEnsure, this.selection, spittedSpan.text, 0);
        } else {
            let revision: Revision = currentElement.getRevision(currentElement.revisionLength - 1);
            spittedSpan.insertRevisionAt(0, revision);
            this.owner.trackChangesPane.updateCurrentTrackChanges(revision);
            let isDelete: boolean = false;
            if (this.owner.editorHistoryModule) {
                isDelete = (!isNullOrUndefined(this.owner.editorHistoryModule.currentBaseHistoryInfo) && this.owner.editorHistoryModule.currentBaseHistoryInfo.action === 'Delete');
            }
            //Update cursor position to insert removed content
            if (endOffset === 1 && this.selection.isEmpty) {
                if (!isDelete) {
                    this.selection.start.movePreviousPosition();
                    this.selection.end.setPositionInternal(this.selection.start);
                }
            } else {
                this.updateCursorForInsertRevision(currentElement, indexInInline, endOffset);
            }
            if (spittedSpan.text !== '') {
                if (!this.isElementAddedToNewPara(newParagraph, spittedSpan)) {
                    this.addRemovedNodes(spittedSpan.clone());
                }
                this.insertInlineInternal(spittedSpan, 'Deletion');
            }
        }
    }
    private handleDeleteBySplitting(elementBox: ElementBox, indexInInline: number, endOffset: number, newParagraph?: ParagraphWidget): void {
        let isDelete: boolean = false;
        if (this.owner.editorHistoryModule) {

            isDelete = (!isNullOrUndefined(this.owner.editorHistoryModule.currentBaseHistoryInfo) && this.owner.editorHistoryModule.currentBaseHistoryInfo.action === 'Delete');
        }
        //Update cursor position to insert removed content
        if (endOffset === 1 && this.selection.isEmpty) {
            let startPosition: number = elementBox.line.getOffset(elementBox, 0);
            if (startPosition > 0) {
                let currentPosition: TextPosition = new TextPosition(this.owner);
                currentPosition.setPositionForLineWidget(elementBox.line, startPosition + indexInInline);
                this.selection.start.setPositionInternal(currentPosition);
                this.selection.end.setPositionInternal(this.selection.start);
            } else {
                if (!isDelete) {
                    this.selection.start.movePreviousPosition();
                    this.selection.end.setPositionInternal(this.selection.start);
                }
            }
        } else {
            this.updateCursorForInsertRevision(elementBox, indexInInline, endOffset);
        }
        let spittedElement: TextElementBox = this.removeCharacterInLine(elementBox, indexInInline, endOffset);
        let revision = elementBox.getRevision(0);
        if (!isNullOrUndefined(revision)) {
            this.owner.trackChangesPane.updateCurrentTrackChanges(revision);
        }
        if (elementBox.revisionLength > 0) {
            spittedElement.removedIds = Revision.cloneRevisions(elementBox.getAllRevision());
        }
        if (spittedElement.text !== '') {
            if (!this.isElementAddedToNewPara(newParagraph, spittedElement)) {
                this.addRemovedNodes(spittedElement.clone());
            }
            this.insertTextInternal(spittedElement.text, false, 'Deletion', false);
        }
    }

    private isElementAddedToNewPara(newParagraph: ParagraphWidget, element: ElementBox): boolean {
        if (newParagraph) {
            let lineWidget: LineWidget = newParagraph.childWidgets[newParagraph.childWidgets.length - 1] as LineWidget;
            let clonedElement = element.clone();
            lineWidget.children.splice(0, 0, clonedElement);
            clonedElement.line = lineWidget;
            return true;
        }
        return false;
    }

    private updateCursorForInsertRevision(inline: ElementBox, startOffset: number, endOffset: number): void {
        let startPosition: number = inline.line.getOffset(inline, 0);
        if (startPosition > 0) {
            startOffset = startPosition + startOffset;
            endOffset = startPosition + endOffset;
        }
        let currentPosition: TextPosition = new TextPosition(this.owner);
        currentPosition.setPositionFromLine(inline.line, startOffset);
        let endPosition: TextPosition = new TextPosition(this.owner);
        endPosition.setPositionFromLine(inline.line, endOffset);
        if (!currentPosition.isExistBefore(endPosition)) {
            this.selection.start.setPositionInternal(endPosition);
            this.selection.end.setPositionInternal(endPosition);
        } else {
            this.selection.end.setPositionInternal(currentPosition);
            this.selection.start.setPositionInternal(currentPosition);
        }
    }
    private checkToCombineRevisionsInSides(currentElement: ElementBox, revisionType: RevisionType): boolean {
        let prevElement: ElementBox = currentElement.previousNode;
        let nextElement: ElementBox = currentElement.nextNode;
        let isCombined: boolean = false;
        if (!isNullOrUndefined(prevElement)) {
            if (!(prevElement instanceof BookmarkElementBox)) {
                prevElement = prevElement.previousValidNodeForTracking;
            }
            if (!isNullOrUndefined(prevElement)) {
                let matchedRevisions: Revision[] = this.getMatchedRevisionsToCombine(prevElement.getAllRevision(), revisionType);
                if (matchedRevisions.length > 0) {
                    this.mapMatchedRevisions(matchedRevisions, prevElement, currentElement, false);
                    isCombined = true;
                }
            }
        }
        if (!isNullOrUndefined(nextElement)) {
            if (!(nextElement instanceof BookmarkElementBox)) {
                nextElement = nextElement.nextValidNodeForTracking;
            }
            if (!isNullOrUndefined(nextElement)) {
                let matchedRevisions: Revision[] = this.getMatchedRevisionsToCombine(nextElement.getAllRevision(), revisionType);
                if (matchedRevisions.length > 0) {
                    if (isCombined) {
                        this.combineElementRevision(currentElement.getAllRevision(), nextElement.getAllRevision());
                    } else {
                        this.mapMatchedRevisions(matchedRevisions, nextElement, currentElement, true);
                    }
                    isCombined = true;
                }
            }
        }

        return isCombined;
    }
    /**
     * Removes the current selected content or one character right of the cursor.
     *
     * @returns {void}
     */
    public delete(): void {
        this.isDeleteOrBackSpace = true;
        let selection: Selection = this.documentHelper.selection;
        if (!selection.isEmpty) {
            const selectionBookmark: string[] = selection.bookmarks;
            if (selectionBookmark.length > 0) {
                this.extendSelectionToBookmarkStart(selectionBookmark);
            }
        }
        if (selection.isEmpty) {
            this.singleDelete(selection, false);
        } else {
            if (this.owner.enableTrackChanges && this.canSkipDeleteTrack(selection)) {
                return;
            }
            let commentStarts: CommentCharacterElementBox[] = this.checkAndRemoveComments();
            this.initHistory('Delete');
            let endPos: TextPosition;
            if (selection.isForward) {
                endPos = selection.end;
            } else {
                endPos = selection.start;
            }
            //let endParagraphInfo: ParagraphInfo = this.selection.getParagraphInfo(endPos);
            this.deleteSelectedContentInternal(selection, false, selection.start, selection.end);
            let textPosition: TextPosition = new TextPosition(selection.owner);
            // const endIndex: string = this.selection.getHierarchicalIndex(endParagraphInfo.paragraph, endParagraphInfo.offset.toString());
            // if (this.owner.enableTrackChanges && !this.skipTracking() && !this.isInsertingTOC && endParagraphInfo.paragraph.indexInOwner !== -1
            //     && !isNullOrUndefined(this.editorHistory) && this.editorHistory.currentBaseHistoryInfo && this.editorHistory.currentBaseHistoryInfo.lastDeletedNodeRevision) {
            //     selection.editPosition = endIndex;
            // }
            this.setPositionForCurrentIndex(textPosition, selection.editPosition);
            selection.selectContent(textPosition, true);
            this.reLayout(selection);
            this.insertSpaceInFormField();
            if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)
                && this.editorHistory.currentHistoryInfo.action === 'RemoveComment') {
                for (let k: number = 0; k < commentStarts.length; k++) {
                    this.initInsertInline(commentStarts[k], false);
                }
                this.editorHistory.currentHistoryInfo.endPosition = this.selection.startOffset;
                this.editorHistory.updateComplexHistory();
            }
        }
        this.isDeleteOrBackSpace = false;
        this.documentHelper.layout.islayoutFootnote = false;
        this.updateXmlMappedContentControl();
    }
    private deleteEditElement(selection: Selection): void {
        this.initHistory('Delete');
        this.deleteSelectedContentInternal(selection, false, selection.start, selection.end);
        let textPosition: TextPosition = new TextPosition(selection.owner);
        this.setPositionForCurrentIndex(textPosition, selection.editPosition);
        selection.selectContent(textPosition, true);
        this.reLayout(selection);
    }
    private removeContentControlMark(start: ContentControl, end: ContentControl): boolean {
        if (!start.contentControlProperties.lockContentControl) {
            this.selection.start.setPositionParagraph(start.line, start.line.getOffset(start, 0));
            this.selection.end.setPositionParagraph(end.line, end.line.getOffset(end, 0) + 1);
            this.deleteEditElement(this.selection);
            return true;
        }
        return false;
    }
    /**
     * Remove single character on right of cursor position
     *
     * @param {Selection} selection - Specifies the selection
     * @param {boolean} isRedoing - Specified the is redoing.
     * @private
     * @returns {void}
     */
    /* eslint-disable  */
    public singleDelete(selection: Selection, isRedoing: boolean): void {
        let lineWidget: LineWidget = selection.start.currentWidget;
        let paragraph: ParagraphWidget = selection.start.paragraph; 
        let offset: number = selection.start.offset; let indexInInline: number = 0;
        let inlineObj: ElementInfo = lineWidget.getInline(selection.start.offset, indexInInline);
        let inline: ElementBox = inlineObj.element;
        if (paragraph.characterFormat.hidden) {
            return;
        }
        if (this.selection.isInlineFormFillMode()) {
            if (inline instanceof FieldElementBox && inline.fieldType === 1) {
                return;
            }
            let resultText: string = this.getFieldResultText();
            if (!(inline instanceof TextElementBox)) {
                inline = inline.nextElement;
            }
            if (resultText.length === 1 && inline instanceof TextElementBox) {
                this.selection.selectFieldInternal(this.selection.getCurrentFormField());

                this.insertTextInternal(this.documentHelper.textHelper.repeatChar(this.documentHelper.textHelper.getEnSpaceCharacter(), 5), true);
                this.selection.selectTextElementStartOfField(this.selection.getCurrentFormField());
                return;
            } else {
                if (inline instanceof FieldElementBox && inline.fieldType === 1) {
                    return;
                }
            }
        }
        if (inline instanceof ContentControl) {
            if (inline.type === 0) {
                if (inline.contentControlProperties.lockContents) {
                    this.selection.selectContentConterol(inline);
                } else {
                    this.selection.selectContentControlInternal(inline);
                }
            }
            return;
        }
        let contentControl: ContentControl = this.selection.currentContentControl;
        if (contentControl && contentControl.contentControlProperties && contentControl.contentControlProperties.lockContents) {
            return;
        }
        indexInInline = inlineObj.index;
        if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId !== -1 &&
            this.documentHelper.isListTextSelected && selection.contextType === 'List') {
            this.onApplyList(undefined); return;
        }
        if (!isNullOrUndefined(inline) && indexInInline === inline.length && !isNullOrUndefined(inline.nextNode)) {
            inline = inline.nextNode as ElementBox;
            if (inline instanceof FieldElementBox && inline.fieldType === 1 &&
                !isNullOrUndefined(inline.fieldBegin.formFieldData)) {
                return;
            }
            if (inline instanceof FootnoteElementBox) {
                return;
            }
            indexInInline = 0;
        }
        let updateSelection: boolean = inline instanceof CommentCharacterElementBox;
        //Skip removing comment start/end mark on delete key
        while (inline instanceof CommentCharacterElementBox) {
            if (inline.nextNode) {
                inline = inline.nextNode;
                indexInInline = 0;
            } else {
                indexInInline = 1;
                break;
            }
        }
        if (updateSelection) {
            paragraph = inline.line.paragraph;
            offset = inline.line.getOffset(inline, indexInInline);
            selection.start.setPositionParagraph(inline.line, offset);
            selection.end.setPositionParagraph(inline.line, offset);
        }
        if (!this.owner.enableTrackChanges && inline instanceof FootnoteElementBox) {
            if (inline.footnoteType === 'Footnote') {
                this.removeFootnote(inline);
            } else {
                this.removeEndnote(inline);
            }
        }
        if (!isNullOrUndefined(inline)) {
            let nextRenderedInline: ElementBox = undefined;
            let nextInline: ElementBox = this.documentHelper.getNextValidElement(inline);
            if (inline.characterFormat.hidden) {
                return;
            }
            if (nextInline instanceof ElementBox) {
                nextRenderedInline = nextInline;
            }
            if (!isNullOrUndefined(nextRenderedInline) && nextRenderedInline instanceof FieldElementBox
                && nextRenderedInline.fieldType === 0) { //Selects the entire field.
                inline = (nextRenderedInline as FieldElementBox).fieldEnd;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 1);
                selection.end.setPositionParagraph(inline.line, offset);
                if(inline.nextNode instanceof BookmarkElementBox) {
                    let end = inline.nextNode;
                    selection.end.setPositionParagraph(end.line, end.line.getOffset(end, 1));
                }
                selection.fireSelectionChanged(true);
                return;
            } else if (inline !== nextRenderedInline) {  //Updates the offset to delete next content.               
                inline = nextRenderedInline;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 0);
                if (inline instanceof FieldElementBox && inline.fieldType === 1) {
                    offset++;
                }
            }
        }
        if (inline instanceof EditRangeStartElementBox || inline instanceof EditRangeEndElementBox) {
            if ((inline.nextNode instanceof EditRangeEndElementBox && (inline as EditRangeStartElementBox).editRangeEnd === inline.nextNode)
                || (inline.previousNode instanceof EditRangeStartElementBox
                    && (inline as EditRangeEndElementBox).editRangeStart === inline.previousNode)) {
                return;
            }
            if (this.documentHelper.isDocumentProtected &&
                this.documentHelper.protectionType === 'ReadOnly') {
                if (inline instanceof EditRangeStartElementBox || inline instanceof EditRangeEndElementBox) {
                    return;
                }
            } else {
                if (inline instanceof EditRangeStartElementBox) {
                    inline = inline.nextNode;
                    offset = inline.line.getOffset(inline, 0);
                    paragraph = inline.line.paragraph;
                } else if (inline instanceof EditRangeEndElementBox) {
                    offset++;
                }
            }
            if (inline.length === 1 && inline.nextNode instanceof EditRangeEndElementBox
                && inline.previousNode instanceof EditRangeStartElementBox) {
                let editStart: EditRangeStartElementBox = inline.previousNode;
                let editEnd: EditRangeEndElementBox = inline.nextNode;
                selection.start.setPositionParagraph(editStart.line, editStart.line.getOffset(editStart, 0));
                selection.end.setPositionParagraph(editEnd.line, editEnd.line.getOffset(editEnd, 0) + 1);
                this.deleteEditElement(selection);
                return;
            }
        }
        if (inline && (inline instanceof ContentControl || inline.nextNode instanceof ContentControl)) {
            if (inline instanceof ContentControl && inline.nextNode) {
                inline = inline.nextNode;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 0);
                // Move cursor inbetween content control
                selection.start.setPositionParagraph(inline.line, offset);
                selection.end.setPositionParagraph(inline.line, offset);
                return;
            }
            if (inline && inline.length === 1 && inline.nextNode instanceof ContentControl
                && inline.previousNode instanceof ContentControl) {
                if (this.removeContentControlMark(inline.previousNode, inline.nextNode)) {
                    return;
                }
            }
            // Remove content if content control is empty
            if (inline instanceof ContentControl && inline.previousNode instanceof ContentControl
                && inline.previousNode.reference === inline && !this.documentHelper.isFormFillProtectedMode) {
                // Remove content control if there is no element presen in between start and end mark.
                if (this.removeContentControlMark(inline.previousNode, inline)) {
                    return;
                }
            }
        }
        if (inline && (inline instanceof BookmarkElementBox && inline.bookmarkType === 0
            || inline.nextNode instanceof BookmarkElementBox)) {
            if (inline.nextNode && inline instanceof BookmarkElementBox) {
                inline = inline.nextNode;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 0);
                selection.start.setPositionParagraph(inline.line, offset);
                selection.end.setPositionParagraph(inline.line, offset);
            }
            if (inline.length === 1 && inline.nextNode instanceof BookmarkElementBox
                && inline.previousNode instanceof BookmarkElementBox) {
                let bookMarkBegin: BookmarkElementBox = inline.previousNode;
                let bookMarkEnd: BookmarkElementBox = inline.nextNode;

                selection.start.setPositionParagraph(bookMarkBegin.line, bookMarkBegin.line.getOffset(bookMarkBegin, 0));

                selection.end.setPositionParagraph(bookMarkEnd.line, bookMarkEnd.line.getOffset(bookMarkEnd, 0) + 1);
                this.deleteEditElement(selection);
                return;
            }
            if (inline instanceof BookmarkElementBox) {
                offset = inline.line.getOffset(inline, 1);
            }
        }

        let isLastLine: boolean = selection.start.currentWidget.isLastLine() && offset >= this.documentHelper.selection.getLineLength(selection.start.currentWidget);
        if (this.owner.enableTrackChanges) {
            if (!isLastLine && this.canSkipDeleteTracking(inline, false)) {
                return;
            } else if (isLastLine && !paragraph.isEmpty() && paragraph.nextRenderedWidget instanceof TableWidget) {
                return;
            }
        }

        if (isLastLine) {
            if (paragraph.isInsideTable && isNullOrUndefined(paragraph.nextWidget)) {
                return;
            }
            let previousParagraph: ParagraphWidget = undefined; let newParagraph: ParagraphWidget = undefined;
            let nextParagraph: ParagraphWidget = selection.getNextParagraphBlock(paragraph);
            if (!isNullOrUndefined(nextParagraph)) {
                if (nextParagraph.isEmpty() && nextParagraph.characterFormat.hidden) {
                    return;
                }
                let firstLine: LineWidget = nextParagraph.firstChild as LineWidget;
                if (!isNullOrUndefined(firstLine)) {
                    let firstElement: ElementBox = firstLine.children[0] as ElementBox;
                    if (!isNullOrUndefined(firstElement) && firstElement.characterFormat.hidden) {
                        return;
                    }
                }
            }
            if (isNullOrUndefined(nextParagraph)) {
                if (offset > 0) {
                    return;
                } else {
                    if (paragraph.previousWidget instanceof ParagraphWidget) {
                        previousParagraph = paragraph.previousWidget as ParagraphWidget;
                    }
                    if (paragraph.previousWidget instanceof FootNoteWidget) {
                        return;
                    }
                    if (paragraph.previousWidget instanceof TableWidget) {
                        return;
                    }
                    if (isNullOrUndefined(previousParagraph) || (paragraph.isEmpty() && previousParagraph.characterFormat.revisionLength > 0)) {
                        return;
                        //Adds an empty paragraph, to ensure minimal content.
                    }
                }
            } else if(this.owner.enableTrackChanges){
                if (paragraph.characterFormat.revisionLength > 0 && this.isDeleteRevisionByCurrentUser(paragraph.characterFormat)) {
                    selection.selectParagraphInternal(nextParagraph, true);
                    return;
                }
            }
            if (!isRedoing) {
                this.initHistory('Delete');
            }
            if (paragraph.isEndsWithPageBreak || paragraph.isEndsWithColumnBreak) {
                let lastLine: LineWidget = paragraph.lastChild as LineWidget;
                let lastChild: ElementBox = lastLine.children[lastLine.children.length - 1] as ElementBox;
                this.selection.start.setPositionForSelection(lastLine, lastChild, 0, this.selection.start.location);
            }
            let blockInfo: ParagraphInfo = this.selection.getParagraphInfo(selection.start);
            selection.editPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            if (this.checkInsertPosition(selection)) {
                this.setPositionForHistory(selection.editPosition);
            }
            selection.owner.isShiftingEnabled = true;
            if (paragraph.isEmpty()) {
                if (this.owner.enableTrackChanges &&
                    (paragraph.characterFormat.revisionLength === 0 || !this.isInsertRevisionByCurrentUser(paragraph.characterFormat))) {
                    if (!this.isDeleteRevisionByCurrentUser(paragraph.characterFormat)) {
                        let deleteRevision: Revision = this.retrieveRevisionByType(paragraph.characterFormat, 'Deletion');
                        if (paragraph.characterFormat.revisionLength > 0 && !isNullOrUndefined(deleteRevision)) {
                            this.owner.editorModule.initComplexHistory('RemoveAndAddRevision');
                            if (this.editorHistory && this.owner.editorHistory.currentHistoryInfo) {
                                this.owner.editorModule.initHistory('RemoveRevision');
                                let removedRevision: Revision = paragraph.characterFormat.getRevision(0);
                                this.owner.editorHistory.currentBaseHistoryInfo.modifiedProperties.push(removedRevision.revisionID);
                                this.editorHistory.updateHistory();
                                this.unlinkRevisionFromItem(paragraph.characterFormat);
                                let AddedRevision: Revision = this.insertRevision(paragraph.characterFormat, 'Deletion');
                                this.owner.editorModule.initHistory('AddRevision');
                                this.owner.editorHistory.currentBaseHistoryInfo.modifiedProperties.push(AddedRevision.revisionID);
                                this.editorHistory.updateHistory();
                            }
                            if (this.owner.editorHistoryModule) {
                                this.owner.editorHistoryModule.updateComplexHistory();
                            }
                        }
                        else {
                            let revision: Revision = this.insertRevision(paragraph.characterFormat, 'Deletion')
                            if (this.owner.editorHistory && this.owner.editorHistory.currentBaseHistoryInfo) {
                                this.owner.editorHistory.currentBaseHistoryInfo.action = 'AddRevision';
                                this.owner.editorHistory.currentBaseHistoryInfo.modifiedProperties.push(revision.revisionID);
                            }
                        }
                    }
                    selection.selectParagraphInternal(nextParagraph, true);
                } else {
                    this.removePrevParaMarkRevision(paragraph, true, true);
                    let nxtParagraph: ParagraphWidget = selection.getNextParagraphBlock(paragraph);
                    if (!isNullOrUndefined(nxtParagraph) && nxtParagraph instanceof ParagraphWidget && nxtParagraph.bodyWidget.index !== paragraph.bodyWidget.index) {
                        this.deleteSection(selection, paragraph.bodyWidget, nxtParagraph.bodyWidget, 0);
                        this.editorHistory.currentBaseHistoryInfo.type = "SectionBreak";
                    }
                    this.removeBlock(paragraph, false, true);
                    this.addRemovedNodes(paragraph);
                    if (isNullOrUndefined(nextParagraph)) {
                        if (isNullOrUndefined(previousParagraph)) {
                            // selection.selectParagraphInternal(newParagraph, true, true);
                            let paraEndOffset: number = selection.getParagraphLength(newParagraph) + 1;
                            if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                                this.updateHistoryPosition(selection.start, true);
    
                                this.editorHistory.currentBaseHistoryInfo.endPosition = this.selection.getHierarchicalIndex(newParagraph, paraEndOffset.toString());
                            }
                        } else {
                            selection.selectParagraphInternal(previousParagraph, false);
                            this.setPositionForHistory();
                        }
                    } else {
                        selection.selectParagraphInternal(nextParagraph, true);
                    }
                }      
            } else {
                if (this.owner.enableTrackChanges && paragraph.nextRenderedWidget instanceof ParagraphWidget &&
                    (paragraph.characterFormat.revisionLength === 0 || !this.isInsertRevisionByCurrentUser(paragraph.characterFormat))) {
                    if (!this.isDeleteRevisionByCurrentUser(paragraph.characterFormat)) {
                        let deleteRevision: Revision = this.retrieveRevisionByType(paragraph.characterFormat, 'Deletion');
                        if (paragraph.characterFormat.revisionLength > 0 && !isNullOrUndefined(deleteRevision)) {
                            this.owner.editorModule.initComplexHistory('RemoveAndAddRevision');
                            if (this.editorHistory && this.owner.editorHistory.currentHistoryInfo) {
                                this.owner.editorModule.initHistory('RemoveRevision');
                                let removedRevision: Revision = paragraph.characterFormat.getRevision(0);
                                this.owner.editorHistory.currentBaseHistoryInfo.modifiedProperties.push(removedRevision.revisionID);
                                this.editorHistory.updateHistory();
                                this.unlinkRevisionFromItem(paragraph.characterFormat);
                                let AddedRevision: Revision = this.insertRevision(paragraph.characterFormat, 'Deletion');
                                this.owner.editorModule.initHistory('AddRevision');
                                this.owner.editorHistory.currentBaseHistoryInfo.modifiedProperties.push(AddedRevision.revisionID);
                                this.editorHistory.updateHistory();
                            }
                            if (this.owner.editorHistoryModule) {
                                this.owner.editorHistoryModule.updateComplexHistory();
                            }
                        }
                        else {
                            let revision: Revision = this.insertRevision(paragraph.characterFormat, 'Deletion')
                            if (this.owner.editorHistory && this.owner.editorHistory.currentBaseHistoryInfo) {
                                this.owner.editorHistory.currentBaseHistoryInfo.action = 'AddRevision';
                                this.owner.editorHistory.currentBaseHistoryInfo.modifiedProperties.push(revision.revisionID);
                            }
                        }
                    }
                    selection.selectParagraphInternal(nextParagraph, true);
                } else {
                    paragraph = paragraph.combineWidget(this.owner.viewer) as ParagraphWidget;
                    let currentParagraph: ParagraphWidget = this.splitParagraph(paragraph, paragraph.firstChild as LineWidget, 0, selection.start.currentWidget, selection.start.offset, true);
                    this.removePrevParaMarkRevision(paragraph, true, true);
                    this.deleteParagraphMark(currentParagraph, selection, 0);
                    this.addRemovedNodes(paragraph);
                    this.setPositionForCurrentIndex(selection.start, selection.editPosition);
                    selection.selectContent(selection.start, true);
                }
            }
            // if (!isRedoing) {
            this.reLayout(selection);
            // }
        } else {
            let inline: ElementBox = inlineObj.element;
            if (inline instanceof ContentControl) {
                let contentControl: ContentControl = this.selection.currentContentControl;
                this.selection.selectContentControlInternal(contentControl);
                if ((!isNullOrUndefined(contentControl) && inline.type === 1 && contentControl.contentControlProperties.lockContentControl && isNullOrUndefined(inline.nextElement))) {
                    if (this.selection.isEmpty) {
                        this.delete();
                    } else {
                        return;
                    }
                }
                if ((!isNullOrUndefined(contentControl) && inline.type === 0 && inline.nextElement !== contentControl.reference) || (!isNullOrUndefined(contentControl) && inline.type === 0 && contentControl.contentControlProperties.lockContentControl && inline.nextElement === contentControl.reference)) {
                    return;
                }
            } else {
                this.singleDeleteInternal(selection, isRedoing, paragraph);
            }
        }
        let line: LineWidget = selection.start.currentWidget;
        let elementInfo: ElementInfo = line.getInline(selection.start.offset + 1, 0);
        if (elementInfo.element instanceof BookmarkElementBox) {
            selection.start.offset++;
            selection.end.offset++;
        }
    }
    private isInsertRevisionByCurrentUser(item: (ElementBox | WCharacterFormat | WRowFormat)): boolean {
        if (item.revisionLength > 0) {
            let currentUser: string = this.owner.currentUser ? this.owner.currentUser : 'Guest user';
            for (let i: number = 0; i < item.revisionLength; i++) {
                let revision: Revision = item.getRevision(i);
                if (revision.author === currentUser && revision.revisionType === 'Insertion') {
                    return true;
                }
            }
        }
        return false;
    }
    private isDeleteRevisionByCurrentUser(item: (ElementBox | WCharacterFormat | WRowFormat)): boolean {
        if (item.revisionLength > 0) {
            let currentUser: string = this.owner.currentUser ? this.owner.currentUser : 'Guest user';
            for (let i: number = 0; i < item.revisionLength; i++) {
                let revision: Revision = item.getRevision(i);
                if (revision.author === currentUser && revision.revisionType === 'Deletion') {
                    return true;
                }
            }
        }
        return false;
    }
    private singleDeleteInternal(selection: Selection, isRedoing: boolean, paragraph: ParagraphWidget): void {
        if (!isRedoing) {
            selection.owner.isShiftingEnabled = true;
            this.initHistory('Delete');
        }
        if (this.checkInsertPosition(selection)) {
            this.updateHistoryPosition(selection.start, true);
            this.editorHistory.currentBaseHistoryInfo.endPosition = this.editorHistory.currentBaseHistoryInfo.insertPosition;
        }
        let paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(selection.start);
        let lineWidget: LineWidget = selection.start.currentWidget;
        let removeOffset: number = selection.start.offset;
        let lineLength: number = selection.getLineLength(selection.start.currentWidget);
        if (removeOffset >= lineLength) {
            lineWidget = lineWidget.nextLine as LineWidget;
            removeOffset = removeOffset - lineLength;
        }
        this.removeAtOffset(lineWidget, selection, removeOffset);
        if (this.owner.enableTrackChanges && !isNullOrUndefined(this.editorHistory) && this.editorHistory.currentBaseHistoryInfo && this.editorHistory.currentBaseHistoryInfo.action === 'Delete' && !this.editorHistory.currentBaseHistoryInfo.lastDeletedNodeRevision) {
            this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset, false);
        } else if (this.owner.enableTrackChanges && !this.skipTracking()) {
            this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + 1, false);
        } else {
            this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset, false);
        }
        if (!isRedoing) {
            this.reLayout(selection);
        } else {
            this.fireContentChange();
        }
    }

    private deleteParagraphMark(paragraph: ParagraphWidget, selection: Selection, editAction: number, handleParaMark?: boolean, isCombineLastBlock?: boolean, skipToAddHistory?: boolean): void {
        if (isNullOrUndefined(paragraph.containerWidget)) {
            return;
        }
        paragraph = paragraph.combineWidget(this.owner.viewer) as ParagraphWidget;
        let nextParagraph: ParagraphWidget = selection.getNextParagraphBlock(paragraph);
        if (paragraph.isInsideTable && isNullOrUndefined(paragraph.nextWidget) || isNullOrUndefined(nextParagraph)) {
            return;
        }
        let table: TableWidget = undefined;
        if (selection.getNextRenderedBlock(paragraph) instanceof TableWidget) {
            table = selection.getNextRenderedBlock(paragraph) as TableWidget;
        } else {
            table = undefined;
        }
        let canRemoveParaMark: boolean = (!isNullOrUndefined(handleParaMark) && handleParaMark) ? this.handleDeleteParaMark(paragraph) : true;
        if (nextParagraph.isInsideTable && !isNullOrUndefined(table) && table.contains(nextParagraph.associatedCell)) {
            if (editAction < 4 && canRemoveParaMark) {
                // let nextSection: BodyWidget = table.containerWidget instanceof BodyWidget ? table.containerWidget : undefined;
                // if (section !== nextSection) {
                //     this.combineSection(section, selection, nextSection);
                // }                
                let offset: number = 0;
                this.removeBlock(paragraph);
                this.documentHelper.layout.clearListElementBox(nextParagraph);
                this.documentHelper.layout.clearListElementBox(paragraph);
                for (let i: number = paragraph.childWidgets.length - 1; i >= 0; i--) {
                    let line: LineWidget = paragraph.childWidgets[i] as LineWidget;
                    for (let j: number = line.children.length - 1; j >= 0; j--) {
                        let element: ElementBox = line.children[j] as ElementBox;
                        offset += element.length;
                        (nextParagraph.firstChild as LineWidget).children.unshift(element);
                        element.line = nextParagraph.firstChild as LineWidget;
                        // this.layoutInlineCollection(false, 0, nextParagraph.inlines, inline);
                    }
                }
                this.documentHelper.layout.reLayoutParagraph(nextParagraph, 0, 0);
                if (offset > 0) {
                    selection.editPosition = this.selection.getHierarchicalIndex(nextParagraph, offset.toString());
                }
            }
        } else {
            if (editAction < 4) {
                // let nextSection: WSection = nextParagraph.section instanceof WSection ? nextParagraph.section as WSection : undefined;
                // if (section !== nextSection) {
                //     this.combineSection(section, selection, nextSection);
                // }
                nextParagraph = nextParagraph.combineWidget(this.owner.viewer) as ParagraphWidget;
                this.documentHelper.layout.clearListElementBox(nextParagraph);
                this.documentHelper.layout.clearListElementBox(paragraph);
                this.updateEditPositionOnMerge(paragraph, nextParagraph);
                if (canRemoveParaMark) {
                    this.combineRevisionsAndViewBasedOnUntrackedContent(paragraph.characterFormat);
                    const paraPosition = this.selection.getParagraphEndPosition(paragraph);
                    const paraIndex: string = this.selection.getHierarchicalIndexByPosition(paraPosition);
                    if (nextParagraph.bodyWidget.index !== paragraph.bodyWidget.index) {
                        this.deleteSection(selection, paragraph.bodyWidget, nextParagraph.bodyWidget, editAction);
                        this.editorHistory.currentBaseHistoryInfo.type = "SectionBreak";
                    }
                    paragraph = paragraph.combineWidget(this.owner.viewer) as ParagraphWidget;
                    for (let i: number = 0; i < nextParagraph.childWidgets.length; i++) {
                        let inline: LineWidget = nextParagraph.childWidgets[i] as LineWidget;
                        nextParagraph.childWidgets.splice(i, 1);
                        paragraph.childWidgets.push(inline);
                        inline.paragraph = paragraph;
                        i--;
                    }
                    if (nextParagraph.characterFormat.revisionLength > 0) {
                        for (let i: number = 0; i < nextParagraph.characterFormat.revisionLength; i++) {
                            let currentRevision: Revision = nextParagraph.characterFormat.getRevision(i)
                            currentRevision.ownerNode = this.getOwnerNodeForRevision(paragraph.characterFormat);
                            paragraph.characterFormat.addRevision(currentRevision);
                        }
                    }
                    this.addRemovedRevisionInfo(nextParagraph);
                    for (let i: number = 0; i < nextParagraph.floatingElements.length; i++) {
                        var inline = nextParagraph.floatingElements[i];
                        nextParagraph.floatingElements.splice(i, 1);
                        paragraph.floatingElements.push(inline);
                        i--;
                    }
                    paragraph.getAllRevisions(true);
                    // Combining two paragraph
                    this.updateRevisionForCombinedPara(paraIndex);
                    if (nextParagraph.childWidgets.length === 0) {
                        nextParagraph.childWidgets.push(new LineWidget(nextParagraph));
                    }
                    this.documentHelper.layout.reLayoutParagraph(paragraph, 0, 0);
                    this.removeBlock(nextParagraph);
                    if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo.action !== "Insert" && !skipToAddHistory) {
                        // if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentHistoryInfo) && this.editorHistory.currentHistoryInfo.action == 'Accept All') {
                        //     this.removeRevisionForBlock(nextParagraph, undefined, false, true);
                        // }
                        this.addRemovedNodes(nextParagraph, isCombineLastBlock);
                    }
                }
            }
        }
    }
    private handleDeleteParaMark(currentPara: ParagraphWidget, skipSameUserInsertRevisionRemoval?: boolean, skipRevisionInsertionAndDeletion?: boolean): boolean {
        if (!this.owner.enableTrackChanges && currentPara.characterFormat.revisionLength > 0) {
            // If tracking disabled and revision exists then remove revision from character format
            for (let i: number = 0; i < currentPara.characterFormat.revisionLength; i++) {
                let currentRevision: Revision = currentPara.characterFormat.getRevision(i);
                currentPara.characterFormat.removeRevision(i);
                this.owner.trackChangesPane.updateCurrentTrackChanges(currentRevision);
                if (currentRevision.getRange().length === 0) {
                    this.owner.revisions.remove(currentRevision);
                }
                return true;
            }
        }
        if (this.owner.enableTrackChanges) {
            let canRemoveParaMark: boolean = false;
            if (currentPara.characterFormat.revisionLength > 0) {
                let deleteRevision: Revision = this.retrieveRevisionByType(currentPara.characterFormat, 'Deletion');
                if (!isNullOrUndefined(deleteRevision)) {
                    if (!skipRevisionInsertionAndDeletion) {
                        let revisionIndex: number = currentPara.characterFormat.getAllRevision().indexOf(deleteRevision);
                        currentPara.characterFormat.removeRevision(revisionIndex);
                        this.owner.trackChangesPane.updateCurrentTrackChanges(deleteRevision);
                        if (deleteRevision.getRange().length === 0) {
                            this.owner.revisions.remove(deleteRevision);
                        }
                    }
                    canRemoveParaMark = false;
                }
                let insertRevision: Revision = this.retrieveRevisionByType(currentPara.characterFormat, 'Insertion');
                if (!isNullOrUndefined(insertRevision) && this.isRevisionMatched(currentPara.characterFormat, 'Insertion')) {
                    if (!isNullOrUndefined(this.owner.editorHistoryModule) && !isNullOrUndefined(this.owner.editorHistoryModule.currentBaseHistoryInfo)) {
                        this.owner.editorHistoryModule.currentBaseHistoryInfo.recordInsertRevisionDeletetion(currentPara);
                    }
                    if (!skipSameUserInsertRevisionRemoval && !skipRevisionInsertionAndDeletion) {
                        let revisionIndex: number = currentPara.characterFormat.getAllRevision().indexOf(insertRevision);
                        currentPara.characterFormat.removeRevision(revisionIndex);
                        this.owner.trackChangesPane.updateCurrentTrackChanges(insertRevision);
                        if (insertRevision.getRange().length === 0) {
                            this.owner.revisions.remove(insertRevision);
                        }
                    } else if (!skipRevisionInsertionAndDeletion) {
                        if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && !this.editorHistory.currentBaseHistoryInfo.isSameUserDeleteParaMark) {
                            this.editorHistory.currentBaseHistoryInfo.isSameUserDeleteParaMark = true;
                        }
                    }
                    canRemoveParaMark = true;
                }
                if (canRemoveParaMark) {
                    return true;
                } else {
                    if (!skipRevisionInsertionAndDeletion) {
                        this.insertRevision(currentPara.characterFormat, 'Deletion');
                        this.updateLastDeletedRevision(currentPara);
                    }
                    return false;
                }
            } else {
                if (!skipRevisionInsertionAndDeletion) {
                    this.insertRevision(currentPara.characterFormat, 'Deletion');
                    this.updateLastDeletedRevision(currentPara);
                }
                return false;
            }
        }
        return true;
    }

    /**
    * @private
    */
    public retrieveRevisionByType(item: any, revisionToRetrieve: RevisionType): Revision {
        for (let i: number = 0; i < item.revisionLength; i++) {
            if (item.revisions[i].revisionType === revisionToRetrieve) {
                return item.revisions[i];
            }
        }
        return undefined;
    }
    private updateRevisionForCombinedPara(index: string): void {
        const position: TextPosition = this.documentHelper.selection.getTextPosBasedOnLogicalIndex(index);
        const elementInfo: ElementInfo = this.selection.getElementInfo(position.currentWidget, position.offset);
        if (elementInfo && elementInfo.element) {
            let lastElement: ElementBox = elementInfo.element;
            let firstElement: ElementBox = lastElement ? lastElement.nextNode : undefined;
            if (!isNullOrUndefined(firstElement) && !isNullOrUndefined(lastElement)) {
                firstElement = firstElement.nextValidNodeForTracking;
                lastElement = lastElement.nextValidNodeForTracking;
                if (!isNullOrUndefined(firstElement) && !isNullOrUndefined(lastElement) && firstElement.revisionLength > 0 && lastElement.revisionLength > 0) {
                    this.combineElementRevisions(lastElement, firstElement);
                }
            }
        }
    }
    private updateEditPositionOnMerge(currentParagraph: ParagraphWidget, nextParagraph: ParagraphWidget): void {
        if (this.documentHelper.selection.editPosition === this.selection.getHierarchicalIndex(nextParagraph, '0') &&
            nextParagraph.nextRenderedWidget === undefined) {

            this.documentHelper.selection.editPosition = this.selection.getHierarchicalIndex(currentParagraph, this.documentHelper.selection.getLineLength(currentParagraph.lastChild as LineWidget).toString());
        }
    }
    
    private checkEndPosition(selection?: Selection): boolean {
        return (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)
            && isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.endPosition));
    }
    private checkInsertPosition(selection?: Selection): boolean {
        return (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)
            && isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition));
    }
    private checkIsNotRedoing(): boolean {
        return this.documentHelper.owner.enableHistoryMode && !this.editorHistory.isRedoing;
    }
    /**
     * deleteSelectedContentInternal
     * @private
     */
    public deleteSelectedContentInternal(selection: Selection, isBackSpace: boolean, startPosition: TextPosition, endPosition: TextPosition): boolean {
        let startPos: TextPosition = startPosition;
        let endPos: TextPosition = endPosition;
        if (!startPosition.isExistBefore(endPosition)) {
            startPos = endPosition;
            endPos = startPosition;
        }
        const blockInfo: ParagraphInfo = this.selection.getParagraphInfo(startPos);
        selection.editPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        let skipBackSpace: boolean = false;
        if (isBackSpace && startPos.isInSameParagraph(endPos)) {
            //Handled specifically to skip removal of contents, if selection is only paragraph mark and next rendered block is table.
            if (startPos.offset < endPos.offset && startPos.offset === selection.getParagraphLength(endPos.paragraph)) {
                const nextBlock: BlockWidget = selection.getNextRenderedBlock(startPos.paragraph);
                skipBackSpace = nextBlock instanceof TableWidget;
                if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && (this.editorHistory.currentBaseHistoryInfo.action === 'Accept All' || this.editorHistory.currentBaseHistoryInfo.action === 'Accept Change' || this.editorHistory.currentBaseHistoryInfo.action === 'Reject All' || this.editorHistory.currentBaseHistoryInfo.action === 'Reject Change' || this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
                    skipBackSpace = false;
                }
            }
            //Handled specifically to remove paragraph completely (Delete behavior), if the selected paragraph is empty.
            if (endPos.offset === 1 && endPos.offset > selection.getParagraphLength(endPos.paragraph)
                && !(endPos.paragraph.isInsideTable && isNullOrUndefined(endPos.paragraph.nextWidget))) {
                isBackSpace = false;
            }
        }
        if (!skipBackSpace) {
            selection.owner.isShiftingEnabled = true;
            if (this.checkInsertPosition(selection)) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = selection.editPosition;
            }
            const editAction: number = (isBackSpace ? 1 : 0);
            this.deleteSelectedContent(endPos.paragraph, selection, startPos, endPos, editAction);
        }
        return skipBackSpace;
    }
    /**
     * Init EditorHistory
     *
     * @private
     * @param {Action} action Specified the action.
     * @returns {void}
     */
    public initHistory(action: Action): void {
        if (this.documentHelper.owner.enableHistoryMode) {
            this.editorHistory.initializeHistory(action);
        }
    }

    /**
     * Init Complex EditorHistory
     *
     * @private
     * @param {Action} action Specified the action.
     * @returns {void}
     */
    public initComplexHistory(action: Action): void {
        if (this.documentHelper.owner.enableHistoryMode) {
            this.editorHistory.initComplexHistory(this.documentHelper.selection, action);
        }
    }
    //Insert Picture implementation starts
    /**
     * Insert image
     *
     * @private
     * @param {string} base64String Base64 string, web URL or file URL.
     * @param {number} width Image width
     * @param {number} height Image height
     * @param {string} alternateText Image alternateText
     * @returns {void}
     */
    public insertPicture(base64String: string, width: number, height: number, alternateText:string, isUiInteracted: boolean): void {
        const imageElementBox: ImageElementBox = new ImageElementBox(true);
        imageElementBox.width = width;
        imageElementBox.height = height;
        if(!isNullOrUndefined(alternateText) || alternateText!="")
        {
            imageElementBox.alternateText = alternateText;
        }
        imageElementBox.textWrappingStyle = 'Inline';
        if (HelperMethods.formatClippedString(base64String).extension === '.svg') {
            imageElementBox.metaFileImageString = base64String;
            imageElementBox.isMetaFile = true;
            this.generateFallBackImage(base64String, width, height, imageElementBox, isUiInteracted);
            if (!this.owner.enableCollaborativeEditing) {
                this.documentHelper.addBase64StringInCollection(imageElementBox);
                imageElementBox.element.src = this.documentHelper.getImageString(imageElementBox);
                this.insertPictureInternal(imageElementBox, isUiInteracted);
            }
        } else {
            if(!isNullOrUndefined(this.documentHelper)) {
                imageElementBox.imageString = base64String;
                imageElementBox.element.crossOrigin = 'Anonymous';
                this.documentHelper.addBase64StringInCollection(imageElementBox);
                let imgStr: string = this.documentHelper.getImageString(imageElementBox);
                if (!isNullOrUndefined(imgStr) && (HelperMethods.startsWith(imgStr, 'http://') || HelperMethods.startsWith(imgStr, 'https://'))) {
                    const url = new URL(imgStr);
                    // Generate fall back image for URL images.
                    this.viewer.documentHelper.getBase64(base64String, width, height).then((imageUrlString: string) => {
                        if (!isNullOrUndefined(this.viewer) && !isNullOrUndefined(this.viewer.documentHelper)) {
                            this.viewer.documentHelper.images.get(parseInt(imageElementBox.imageString))[1] = imageUrlString;
                            // set downloaded image to image element
                            imageElementBox.element.src = imageUrlString;
                        }
                    });
                }
                imageElementBox.element.src = imgStr;
                this.insertPictureInternal(imageElementBox, isUiInteracted);
            }
        }
    }
    private generateFallBackImage(base64String: string, width: number, height: number, imageElementBox: ImageElementBox, isUiInteracted: boolean): void {
        let drawImage: HTMLImageElement = new Image();
        drawImage.onload = (): void => {
            if(this.isImageInsert && this.owner.enableCollaborativeEditing) {
                this.isRemoteAction = true;
            }
            let displayPixelRatio: number = Math.max(1, window.devicePixelRatio || 1);
            let draw: HTMLCanvasElement = document.createElement('canvas');
            draw.width = width * displayPixelRatio;
            draw.height = height * displayPixelRatio;
            let context = draw.getContext('2d');
            context.scale(displayPixelRatio, displayPixelRatio);
            context.drawImage(drawImage, 0, 0, width, height);
            if (this.owner.enableCollaborativeEditing) {
                this.documentHelper.addBase64StringInCollection(imageElementBox);
                imageElementBox.element.src = this.documentHelper.getImageString(imageElementBox);
                this.insertPictureInternal(imageElementBox, isUiInteracted, this.isRemoteAction);
                this.isImageInsert = false;
                this.isRemoteAction = false;
            }
            this.viewer.documentHelper.images.get(parseInt(imageElementBox.imageString))[1] = draw.toDataURL('image/png', 1);
        };
        drawImage.src = base64String;
        if (this.isRemoteAction) {
            this.insertInlineInSelection(this.selection, imageElementBox);
        }
    }

    private insertPictureInternal(imageElementBox: ImageElementBox, isUiInteracted: boolean, isElementInserted?: boolean): void {
        const selection: Selection = this.documentHelper.selection;
        let removedCommentStart: CommentCharacterElementBox[] = this.checkAndRemoveComments();
        this.initHistory('InsertInline');
        if (isUiInteracted) {
            this.fitImageToPage(selection, imageElementBox);
        }
        if (this.owner.enableCollaborativeEditing) {
            let imageString: string;
            let metaImageString: string;
            if (imageElementBox.isMetaFile) {
                imageString = this.documentHelper.images.get(parseInt(imageElementBox.imageString))[1].toString();
                metaImageString = this.documentHelper.images.get(parseInt(imageElementBox.metaFileImageString))[0].toString();
            }
            else {
                imageString = this.documentHelper.images.get(parseInt(imageElementBox.imageString)).toString();
            }
            let imageData: ImageInfo = {
                imageString: imageString,
                height: HelperMethods.convertPixelToPoint(imageElementBox.height),
                width: HelperMethods.convertPixelToPoint(imageElementBox.width),
                metaString: metaImageString,
                alternativeText: imageElementBox.alternateText
            }
            this.editorHistory.currentBaseHistoryInfo.insertedData = imageData;
            this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Image;
        }
        if (!isElementInserted) {
            this.insertInlineInSelection(selection, imageElementBox);
        }
        this.reLayout(selection);
        this.updateHistoryForComments(removedCommentStart);
    }
    private fitImageToPage(selection: Selection, imageElementBox: ImageElementBox): void {
        const section: BodyWidget = selection.start.paragraph.bodyWidget as BodyWidget;
        const pageHeight: number = section.sectionFormat.pageHeight - section.sectionFormat.topMargin - section.sectionFormat.topMargin;
        let width: number = 0;
        if (section instanceof BodyWidget && section.sectionFormat.columns.length > 1) {
            // column width
            let colIndex: number = section.columnIndex;
            width = (section.sectionFormat.columns[colIndex] as WColumnFormat).width;
        }
        else {
            // page width
            width = HelperMethods.convertPointToPixel(section.sectionFormat.pageWidth - section.sectionFormat.leftMargin - section.sectionFormat.rightMargin);
        }
        // Resize image based on page width or column width
        if (imageElementBox.width > width) {
            imageElementBox.height = imageElementBox.height * width / imageElementBox.width;
            imageElementBox.width = width;
        }
        if (imageElementBox.height > pageHeight) {
            imageElementBox.width = imageElementBox.width * pageHeight / imageElementBox.height;
            imageElementBox.height = pageHeight;
        }
    }
    //Insert Picture implementation ends
    /**
     * @param {selection} Selection context.
     * @param {elementBox} Elementbox
     * @param selection
     * @param elementBox
     * @private
     */
    public insertInlineInSelection(selection: Selection, elementBox: ElementBox): void {
        if (this.checkIsNotRedoing()) {
            selection.owner.isShiftingEnabled = true;
        }
        if (!selection.isEmpty) {
            this.removeSelectedContents(selection);
        }
        // Need to check below case when undo/redo in trackchanges enabled.  
        if (!isNullOrUndefined(this.editorHistory) && this.editorHistory.currentBaseHistoryInfo && this.owner.enableCollaborativeEditing) {
            this.editorHistory.currentBaseHistoryInfo.insertedElement = elementBox;
            if (elementBox instanceof CommentCharacterElementBox) {
                this.editorHistory.currentBaseHistoryInfo.insertedText = elementBox.commentType == 0 ? CONTROL_CHARACTERS.Marker_Start : CONTROL_CHARACTERS.Marker_End;
            } else if (elementBox instanceof FootnoteElementBox) {
                this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Marker_Start;
                this.editorHistory.currentBaseHistoryInfo.markerData.push(this.getMarkerData(elementBox));
            } else if (elementBox instanceof BookmarkElementBox || elementBox instanceof EditRangeStartElementBox || elementBox instanceof EditRangeEndElementBox || elementBox instanceof FieldElementBox || (elementBox instanceof TextElementBox && elementBox.removedIds.length == 0)) {
                this.editorHistory.currentBaseHistoryInfo.markerData.push(this.getMarkerData(elementBox, this.editorHistory.isUndoing));
                if (elementBox instanceof FieldElementBox && elementBox.fieldType === 0) {
                    this.editorHistory.currentBaseHistoryInfo.fieldBegin = elementBox;
                }
            }
        }
        this.updateInsertPosition();
        this.insertInlineInternal(elementBox);
        if (this.checkEndPosition(selection)) {
            this.updateHistoryPosition(selection.start, false);
        }
        this.fireContentChange();
    }
    /**
     * @private
     * @returns {void}
     */
    public onPortrait(): void {
        const sectionFormat: WSectionFormat = new WSectionFormat();
        const width: number = this.documentHelper.selection.sectionFormat.pageWidth;
        const height: number = this.documentHelper.selection.sectionFormat.pageHeight;
        if (width > height) {
            sectionFormat.pageWidth = height;
            sectionFormat.pageHeight = width;
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    }
    /**
     * @private
     * @returns {void}
     */
    public onLandscape(): void {
        const sectionFormat: WSectionFormat = new WSectionFormat();
        const width: number = this.documentHelper.selection.sectionFormat.pageWidth;
        const height: number = this.documentHelper.selection.sectionFormat.pageHeight;
        if (width < height) {
            sectionFormat.pageWidth = height;
            sectionFormat.pageHeight = width;
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    }
    private copyValues(): WSectionFormat {
        const format: WSectionFormat = new WSectionFormat();
        format.bottomMargin = this.documentHelper.selection.sectionFormat.bottomMargin;
        format.topMargin = this.documentHelper.selection.sectionFormat.topMargin;
        format.leftMargin = this.documentHelper.selection.sectionFormat.leftMargin;
        format.rightMargin = this.documentHelper.selection.sectionFormat.rightMargin;
        format.pageHeight = this.documentHelper.selection.sectionFormat.pageHeight;
        format.pageWidth = this.documentHelper.selection.sectionFormat.pageWidth;
        format.footerDistance = this.documentHelper.selection.sectionFormat.footerDistance;
        format.headerDistance = this.documentHelper.selection.sectionFormat.headerDistance;
        return format;
    }
    /**
     * @param property
     * @private
     * @returns {void}
     */
    public changeMarginValue(property: string): void {
        const sectionFormat: WSectionFormat = this.copyValues();

        if (property === 'lastCustomSetting' || property === 'normal') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 72;
            sectionFormat.rightMargin = 72;
        } else if (property === 'narrow') {
            sectionFormat.topMargin = 36;
            sectionFormat.bottomMargin = 36;
            sectionFormat.leftMargin = 36;
            sectionFormat.rightMargin = 36;
        } else if (property === 'moderate') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 54;
            sectionFormat.rightMargin = 54;
        } else if (property === 'wide') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 144;
            sectionFormat.rightMargin = 144;
        } else if (property === 'mirrored') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 90;
            sectionFormat.rightMargin = 72;
        } else if (property === 'office2003Default') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 90;
            sectionFormat.rightMargin = 90;
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    }
    /**
     * @param property
     * @private
     * @returns {void}
     */
    public onPaperSize(property: string): void {
        const sectionFormat: WSectionFormat = this.copyValues();

        const width: number = this.documentHelper.selection.sectionFormat.pageWidth;
        const height: number = this.documentHelper.selection.sectionFormat.pageHeight;
        if (property === 'letter') {
            if (width < height) {
                sectionFormat.pageWidth = 612;
                sectionFormat.pageHeight = 792;
            } else {
                sectionFormat.pageWidth = 792;
                sectionFormat.pageHeight = 612;
            }
        } else if (property === 'tabloid') {
            if (width < height) {
                sectionFormat.pageWidth = 792;
                sectionFormat.pageHeight = 1224;
            } else {
                sectionFormat.pageWidth = 1224;
                sectionFormat.pageHeight = 792;
            }
        } else if (property === 'legal') {
            if (width < height) {
                sectionFormat.pageWidth = 612;
                sectionFormat.pageHeight = 1008;
            } else {
                sectionFormat.pageWidth = 1008;
                sectionFormat.pageHeight = 612;
            }
        } else if (property === 'statement') {
            if (width < height) {
                sectionFormat.pageWidth = 396;
                sectionFormat.pageHeight = 612;
            } else {
                sectionFormat.pageWidth = 612;
                sectionFormat.pageHeight = 396;
            }
        } else if (property === 'executive') {
            if (width < height) {
                sectionFormat.pageWidth = 522;
                sectionFormat.pageHeight = 756;
            } else {
                sectionFormat.pageWidth = 756;
                sectionFormat.pageHeight = 522;
            }
        } else if (property === 'a3') {
            if (width < height) {
                sectionFormat.pageWidth = 841.9;
                sectionFormat.pageHeight = 1190.55;
            } else {
                sectionFormat.pageWidth = 1190.55;
                sectionFormat.pageHeight = 841.9;
            }
        } else if (property === 'a4') {
            if (width < height) {
                sectionFormat.pageWidth = 595.3;
                sectionFormat.pageHeight = 841.9;
            } else {
                sectionFormat.pageWidth = 841.9;
                sectionFormat.pageHeight = 595.3;
            }
        } else if (property === 'a5') {
            if (width < height) {
                sectionFormat.pageWidth = 419.55;
                sectionFormat.pageHeight = 595.3;
            } else {
                sectionFormat.pageWidth = 595.3;
                sectionFormat.pageHeight = 419.55;
            }
        } else if (property === 'b4') {
            if (width < height) {
                sectionFormat.pageWidth = 728.5;
                sectionFormat.pageHeight = 1031.8;
            } else {
                sectionFormat.pageWidth = 1031.8;
                sectionFormat.pageHeight = 728.5;
            }
        } else if (property === 'b5') {
            if (width < height) {
                sectionFormat.pageWidth = 515.9;
                sectionFormat.pageHeight = 728.5;
            } else {
                sectionFormat.pageWidth = 728.5;
                sectionFormat.pageHeight = 515.9;
            }
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    }
    //Update List Items
    /**
     * @param blockAdv
     * @param updateNextBlockList
     * @param blockAdv
     * @param updateNextBlockList
     * @private
     * @returns {void}
     */
    public updateListItemsTillEnd(blockAdv: BlockWidget, updateNextBlockList: boolean): void {
        let splittedWidget: BlockWidget[] = blockAdv.getSplitWidgets() as BlockWidget[];
        let nextBlock: BlockWidget = splittedWidget[splittedWidget.length - 1].nextRenderedWidget as BlockWidget;
        if (!isNullOrUndefined(nextBlock)) {
            let block: BlockWidget = updateNextBlockList ? this.documentHelper.selection.getNextRenderedBlock(blockAdv) : blockAdv;
            while (!isNullOrUndefined(block) && !this.documentHelper.isTextInput) {
                //Updates the list value of the rendered paragraph.
                this.updateRenderedListItems(block);
                block = block.getSplitWidgets().pop().nextRenderedWidget as BlockWidget;
            }
        }    
    }
    /**
     * @param block
     * @private
     * @returns {void}
     */
    public updateWholeListItems(block: BlockWidget, isFindingListParagraph?: boolean, listID?: number): ParagraphWidget {
        this.documentHelper.renderedLists.clear();
        this.documentHelper.renderedLevelOverrides = [];
        const sectionIndex: number = block.bodyWidget.index;
        let currentBlock: BlockWidget;
        for (let j: number = 0; j < this.documentHelper.pages.length; j++) {
            const page: Page = this.documentHelper.pages[j];
            for (let i: number = 0; i < page.bodyWidgets.length; i++) {
                //if (page.bodyWidgets[i].index === sectionIndex) {
                    currentBlock = this.getNextBlockForList(page.bodyWidgets[i].firstChild as BlockWidget);
                    if (!isNullOrUndefined(currentBlock)) {
                        break;
                    }
                //}
            }
            if (!isNullOrUndefined(currentBlock)) {
                break;
            }
        }
        let isListUpdated: boolean = false;
        do {
            if(!currentBlock) {
                break;
            }
            let listSearchResultInfo: ListSearchResultInfo = null;
            if (isFindingListParagraph) {
                listSearchResultInfo = { paragraph: null, listId: listID };
            }
            isListUpdated = this.updateListItems(currentBlock, block, listSearchResultInfo);
            if (isListUpdated) {
                if (!isNullOrUndefined(listSearchResultInfo)) {
                    if (listSearchResultInfo.paragraph == block) {
                        return null;
                    }
                    else {
                        return listSearchResultInfo.paragraph;
                    }
                }
                break;
            }
            currentBlock = currentBlock.getSplitWidgets().pop().nextRenderedWidget as BlockWidget;
            if (!isNullOrUndefined(currentBlock)) {
                currentBlock = this.getNextBlockForList(currentBlock);
            }
        } while (currentBlock);
        return null;
    }
    private getNextBlockForList(currentBlock: BlockWidget): BlockWidget {
        if (currentBlock instanceof ParagraphWidget &&
            this.documentHelper.layout.isFirstElementWithPageBreak(currentBlock)) {
            const nextBlock: BlockWidget = currentBlock.nextRenderedWidget as BlockWidget;
            if (!isNullOrUndefined(nextBlock) && nextBlock.equals(currentBlock)) {
                return nextBlock as BlockWidget;
            }
        }
        return currentBlock;
    }

    private updateListItems(blockAdv: BlockWidget, block: BlockWidget, listSearchResultInfo?: ListSearchResultInfo): boolean {
        let isListUpdated: boolean = false;
        if (blockAdv instanceof ParagraphWidget) {
            isListUpdated = this.updateListItemsForPara(blockAdv as ParagraphWidget, block, listSearchResultInfo);
        } else {
            isListUpdated = this.updateListItemsForTable(blockAdv as TableWidget, block, listSearchResultInfo);
        }
        return isListUpdated;
    }
    private updateListItemsForTable(table: TableWidget, block: BlockWidget, listSearchResultInfo?: ListSearchResultInfo): boolean {
        if (isNullOrUndefined(listSearchResultInfo) && block instanceof TableWidget && table.equals(block)) {
            return true;
        }
        let row: TableRowWidget = table.firstChild as TableRowWidget;
        do {
            const isListUpdated: boolean = this.updateListItemsForRow(row, block, listSearchResultInfo);
            if (isListUpdated) {
                return true;
            }
            row = row.getSplitWidgets().pop().nextRenderedWidget as TableRowWidget;
        } while (row);
        return false;
    }
    private updateListItemsForRow(row: TableRowWidget, block: BlockWidget, listSearchResultInfo?: ListSearchResultInfo): boolean {
        // if (isNullOrUndefined(listSearchResultInfo) && block.isInsideTable && row.childWidgets.indexOf(this.documentHelper.selection.getContainerCell(block.associatedCell)) !== -1) {
        //     //Returns as list updated, inorder to start list numbering from first list paragraph of this row.
        //     return true;
        // }
        let cell: TableCellWidget = row.firstChild as TableCellWidget;
        do {
            const isListUpdated: boolean = this.updateListItemsForCell(cell, block, listSearchResultInfo);
            if (!isNullOrUndefined(listSearchResultInfo) && !isNullOrUndefined(listSearchResultInfo.paragraph)) {
                return true;
            }
            if (isListUpdated) {
                return true;
            }
            cell = cell.nextRenderedWidget as TableCellWidget;
        } while (cell);
        return false;
    }
    private updateListItemsForCell(cell: TableCellWidget, block: BlockWidget, listSearchResultInfo?: ListSearchResultInfo): boolean {
        if (cell.childWidgets.length === 0) {
            return false;
        }
        let currentBlock: BlockWidget = cell.firstChild as BlockWidget;
        do {
            const isListUpdated: boolean = this.updateListItems(currentBlock, block, listSearchResultInfo);
            if (!isNullOrUndefined(listSearchResultInfo) && !isNullOrUndefined(listSearchResultInfo.paragraph)) {
                return true;
            }
            if (isListUpdated) {
                return true;
            }
            currentBlock = currentBlock.getSplitWidgets().pop().nextRenderedWidget as BlockWidget;
        } while (currentBlock);
        return false;
    }

    // public abstract updateListParagraphs(): void;
    /**
     * @param block
     * @private
     * @returns {void}
     */
    public updateRenderedListItems(block: BlockWidget): void {
        if (block instanceof ParagraphWidget) {
            // if the block is a column break pick the next rendered widget.
            if(block.isEndsWithColumnBreak){
                block = block.nextRenderedWidget as ParagraphWidget;
            }
            this.updateRenderedListItemsForPara(block as ParagraphWidget);
        } else {
            this.updateRenderedListItemsForTable(block as TableWidget);
        }
    }
    private updateRenderedListItemsForTable(table: TableWidget): void {
        let row: TableRowWidget = table.firstChild as TableRowWidget;
        do {
            this.updateRenderedListItemsForRow(row);
            row = row.getSplitWidgets().pop().nextRenderedWidget as TableRowWidget;
        } while (row);
    }
    private updateRenderedListItemsForRow(row: TableRowWidget): void {
        let cell: TableCellWidget = row.firstChild as TableCellWidget;
        do {
            this.updateRenderedListItemsForCell(cell);
            cell = cell.nextRenderedWidget as TableCellWidget;
        } while (cell);
    }
    private updateRenderedListItemsForCell(cell: TableCellWidget): void {
        if (cell.childWidgets.length === 0) {
            return;
        }
        let currentBlock: BlockWidget = cell.firstChild as BlockWidget;
        do {
            this.updateRenderedListItems(currentBlock);
            currentBlock = currentBlock.getSplitWidgets().pop().nextRenderedWidget as BlockWidget;
        } while (currentBlock);
    }

    private updateListItemsForPara(paragraph: ParagraphWidget, block: BlockWidget, listSearchResultInfo?: ListSearchResultInfo): boolean {
        if (paragraph.equals(block)) {
            if (!isNullOrUndefined(listSearchResultInfo)) {
                listSearchResultInfo.paragraph = paragraph;
            }
            return true;
        } else {
            let currentList: WList = undefined;
            let levelNumber: number = 0;
            if (!isNullOrUndefined(paragraph.paragraphFormat) && !isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
                if (!isNullOrUndefined(listSearchResultInfo) && paragraph.paragraphFormat.listFormat.listId === listSearchResultInfo.listId) {
                    listSearchResultInfo.paragraph = paragraph;
                    return true;
                }
                currentList = this.documentHelper.getListById(paragraph.paragraphFormat.listFormat.listId);
                levelNumber = paragraph.paragraphFormat.listFormat.listLevelNumber;
            }
            if (!isNullOrUndefined(currentList) && !isNullOrUndefined(this.documentHelper.getAbstractListById(currentList.abstractListId))
                && !isNullOrUndefined(this.documentHelper.getAbstractListById(currentList.abstractListId).levels[levelNumber])) {
                const currentListLevel: WListLevel = this.documentHelper.layout.getListLevel(currentList, levelNumber);
                //Updates the list numbering from document start for reLayouting.
                this.updateListNumber(currentListLevel, paragraph, false);
            }
        }
        return false;
    }
    private updateRenderedListItemsForPara(paragraph: ParagraphWidget): void {

        if (!isNullOrUndefined(this.documentHelper.getListById(paragraph.paragraphFormat.listFormat.listId))) {
            const currentList: WList = this.documentHelper.getListById(paragraph.paragraphFormat.listFormat.listId);
            const listLevelNumber: number = paragraph.paragraphFormat.listFormat.listLevelNumber;
            if (!isNullOrUndefined(currentList) && !isNullOrUndefined(this.documentHelper.getAbstractListById(currentList.abstractListId))

                && !isNullOrUndefined(this.documentHelper.getAbstractListById(currentList.abstractListId).levels[paragraph.paragraphFormat.listFormat.listLevelNumber])) {
                const currentListLevel: WListLevel = this.documentHelper.layout.getListLevel(currentList, listLevelNumber);
                //Updates the list numbering from document start for reLayouting.
                this.updateListNumber(currentListLevel, paragraph, true);
            }
        }
    }
    private updateListNumber(currentListLevel: WListLevel, paragraph: ParagraphWidget, isUpdate: boolean): void {
        let element: ListTextElementBox = undefined;
        if (paragraph.childWidgets.length > 0) {
            const lineWidget: LineWidget = paragraph.childWidgets[0] as LineWidget;
            if (lineWidget.children.length > 0) {
                element = lineWidget.children[0] as ListTextElementBox;
            }
        }
        let listWholeWidth: number;
        if (!isNullOrUndefined(element) && element.nextElement instanceof ListTextElementBox) {
            listWholeWidth = element.width + element.nextElement.width;
        }
        if (!isNullOrUndefined(element) && element instanceof ListTextElementBox) {
            const text: string = this.documentHelper.layout.getListNumber(paragraph);
            if (isUpdate) {
                const prevWidth: number = element.width;
                element.text = text;
                if (this.documentHelper.isIosDevice || this.documentHelper.isLinuxOS) {
                    let listText: string = element.text;
                    listText = listText === String.fromCharCode(61623) ? String.fromCharCode(9679) : listText === String.fromCharCode(61551) + String.fromCharCode(32) ? String.fromCharCode(9675) : listText;
                    if (listText !== element.text) {
                        element.text = listText;
                    }
                }
                const currentWidth: number = this.documentHelper.textHelper.getTextSize(element, element.characterFormat);
                if (currentWidth > prevWidth) {
                    element.width = currentWidth;
                }
                this.documentHelper.textHelper.updateTextSize(element, paragraph);
                if (!isNullOrUndefined(listWholeWidth) && element.width < listWholeWidth) {
                    element.nextElement.width = (listWholeWidth - element.width);
                }
            }
        }
    }
    /**
     * Get offset value to update in selection
     *
     * @param selection
     * @private
     * @returns {void}
     */
    public getOffsetValue(selection: Selection): void {
        if (this.startParagraph) {
            const lineInfo: LineInfo = selection.getLineInfoBasedOnParagraph(this.startParagraph, this.startOffset);
            selection.start.setPositionFromLine(lineInfo.line, lineInfo.offset);
        }
        selection.start.updatePhysicalPosition(true);
        if (selection.isEmpty) {
            selection.end.setPositionInternal(selection.start);
        } else {
            if (this.endParagraph) {
                const lineInfo: LineInfo = selection.getLineInfoBasedOnParagraph(this.endParagraph, this.endOffset);
                selection.end.setPositionFromLine(lineInfo.line, lineInfo.offset);
            }
            selection.end.updatePhysicalPosition(true);
        }
    }

    private setPositionParagraph(paragraph: ParagraphWidget, offset: number, skipSelectionChange: boolean): void {
        const selection: Selection = this.documentHelper.selection;
        const lineInfo: LineInfo = selection.getLineInfoBasedOnParagraph(paragraph, offset);
        selection.start.setPositionFromLine(lineInfo.line, lineInfo.offset);
        selection.end.setPositionInternal(selection.start);
        if (!skipSelectionChange) {
            selection.fireSelectionChanged(true);
        }
    }
    /**
     * @param textPosition
     * @param editPosition
     * @param textPosition
     * @param editPosition
     * @private
     * @returns {void}
     */
    public setPositionForCurrentIndex(textPosition: TextPosition, editPosition: string): void {
        const blockInfo: ParagraphInfo = this.selection.getParagraph({ index: editPosition });
        const lineInfo: LineInfo = this.selection.getLineInfoBasedOnParagraph(blockInfo.paragraph, blockInfo.offset);
        textPosition.setPositionForLineWidget(lineInfo.line, lineInfo.offset);
    }
    /**
     * Inserts the page number in the current cursor position.
     *
     * @param {string} numberFormat - Optional switch that overrides the numeral style of the page number.
     * @returns {void}
     */
    public insertPageNumber(numberFormat?: string): void {
        if (isNullOrUndefined(numberFormat)) {
            numberFormat = '';
        } else {
            numberFormat = ' \\*' + numberFormat;
        }
        const fieldCode: string = 'PAGE ' + numberFormat + ' \\* MERGEFORMAT';
        this.createFields(fieldCode);
    }

    /**
     * @param numberFormat
     * @private
     * @returns {void}
     */
    public insertPageCount(numberFormat?: string): void {
        if (isNullOrUndefined(numberFormat)) {
            numberFormat = '';
        } else {
            numberFormat = ' \*' + numberFormat;
        }
        const fieldCode: string = 'NUMPAGES ' + numberFormat + ' \* MERGEFORMAT';
        this.createFields(fieldCode);
    }

    private createFields(fieldCode: string): void {
        const paragraph: ParagraphWidget = new ParagraphWidget();
        const line: LineWidget = new LineWidget(paragraph);
        const fieldBegin: FieldElementBox = new FieldElementBox(0);
        line.children.push(fieldBegin);
        const fieldtext: FieldTextElementBox = new FieldTextElementBox();
        fieldtext.fieldBegin = fieldBegin;
        fieldtext.text = '1';
        const text: TextElementBox = new TextElementBox();
        text.text = fieldCode;
        line.children.push(text);
        const fieldSeparator: FieldElementBox = new FieldElementBox(2);
        fieldSeparator.fieldBegin = fieldBegin;
        fieldBegin.fieldSeparator = fieldSeparator;
        line.children.push(fieldSeparator);
        line.children.push(fieldtext);
        const fieldEnd: FieldElementBox = new FieldElementBox(1);
        fieldEnd.fieldBegin = fieldBegin;
        fieldEnd.fieldSeparator = fieldSeparator;
        fieldSeparator.fieldEnd = fieldEnd;
        fieldBegin.fieldEnd = fieldEnd;
        line.children.push(fieldEnd);
        fieldBegin.line = line;
        paragraph.childWidgets.push(line);
        this.documentHelper.fields.push(fieldBegin);
        const bodyWidget: BodyWidget = new BodyWidget();
        bodyWidget.sectionFormat = new WSectionFormat(bodyWidget);
        bodyWidget.childWidgets.push(paragraph);
        this.pasteContentsInternal([bodyWidget], false);
    }
    /**
     * Inserts the specified bookmark at the current selection range.
     *
     * @param {string} name Specify the name of bookmark to be inserted.
     * @returns {void}
     */
    public insertBookmark(name: string, isNavigationPane?: boolean): void {
        if (!(!isNullOrUndefined(this.owner.optionsPaneModule) && this.owner.optionsPaneModule.isBuildHeading) && this.selection.isPlainContentControl()) {
            return;
        }
        var isHistoryInitiated: boolean = false;
        if (this.documentHelper.bookmarks.containsKey(name)) {
            const existingBookmark: BookmarkElementBox = this.documentHelper.bookmarks.get(name);
            // existingBookmark.line.children.splice(existingBookmark.line.children.indexOf(existingBookmark), 1);
            // /* eslint-disable-next-line max-len */
            // existingBookmark.reference.line.children.splice(existingBookmark.reference.line.children.indexOf(existingBookmark.reference), 1);
            // this.documentHelper.bookmarks.remove(name);
            isHistoryInitiated = true;
            this.initComplexHistory('InsertBookmark');
            this.documentHelper.owner.editorModule.isRemoteAction = true;
            this.deleteBookmark(name);
            this.documentHelper.owner.editorModule.isRemoteAction = false;
            if (!isNullOrUndefined(existingBookmark.reference) && !isNullOrUndefined(existingBookmark.reference.paragraph.associatedCell)) {
                let row: TableRowWidget = existingBookmark.reference.paragraph.associatedCell.ownerRow;
                if (row.isRenderBookmarkEnd) {
                    row.isRenderBookmarkEnd = false;
                }
                if (!isNullOrUndefined(existingBookmark.properties)) {
                    let columnFirst: number = parseInt(existingBookmark.properties["columnFirst"]);
                    let row: TableRowWidget = existingBookmark.paragraph.associatedCell.ownerRow;
                    let cell: TableCellWidget = row.getCellUsingColumnIndex(row.rowIndex, columnFirst);
                    if (!isNullOrUndefined(cell)) {
                        cell.isRenderBookmarkStart = false;
                    }
                    let columnLast: number = parseInt(existingBookmark.properties["columnLast"]);
                    let endRow: TableRowWidget = existingBookmark.reference.paragraph.associatedCell.ownerRow;
                    let endCell: TableCellWidget = undefined;
                    let cellIndex: number = columnLast;
                    while (isNullOrUndefined(endCell) && cellIndex > -1) {
                        endCell = endRow.getCell(endRow.rowIndex, cellIndex);
                        if (isNullOrUndefined(endCell)) {
                            cellIndex--;
                        }
                    }
                    if (endCell.isRenderBookmarkEnd) {
                        endCell.isRenderBookmarkEnd = false;
                    }
                }
            } else {
                if (!isNullOrUndefined(existingBookmark.properties)) {
                    let columnFirst: number = parseInt(existingBookmark.properties["columnFirst"]);
                    let row: TableRowWidget = existingBookmark.paragraph.associatedCell.ownerRow;
                    let cell: TableCellWidget = row.getCellUsingColumnIndex(row.rowIndex, columnFirst);
                    if (!isNullOrUndefined(cell) && cell.isRenderBookmarkStart) {
                        cell.isRenderBookmarkStart = false;
                    }
                }
            }
        }
        var bookmarks = this.createBookmarkElements(name);
        const bookmark: BookmarkElementBox = bookmarks[0];
        const bookmarkEnd: BookmarkElementBox = bookmarks[1];
        bookmark.properties = this.selection.getBookmarkProperties(bookmark);
        bookmarkEnd.properties = this.selection.getBookmarkProperties(bookmarkEnd);
        this.owner.isShiftingEnabled = true;
        if(!isHistoryInitiated){
            this.initComplexHistory('InsertBookmark');
        }
        this.insertElements([bookmarkEnd], [bookmark], true, isNavigationPane);
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistoryInternal();
        }
        if (this.documentHelper.owner.enableHeaderAndFooter) {
            this.updateHeaderFooterWidget();
        }
        this.documentHelper.bookmarks.add(name, bookmark);
        if (!isNullOrUndefined(bookmark.properties)) {
            this.selection.selectBookmarkInTable(bookmark);
            this.documentHelper.owner.isShiftingEnabled = false;
        } else {
            this.selection.start.setPositionForSelection(bookmark.line, bookmark, 1, this.selection.start.location);
            let endOffset: number = 0;
            if (!isNullOrUndefined(bookmarkEnd.properties)) {
                if (bookmarkEnd.properties['isAfterParagraphMark']) {
                    this.selection.start.setPositionForSelection(bookmark.line, bookmark, 0, this.selection.start.location);
                    endOffset = 2;
                }
            }
            this.selection.end.setPositionForSelection(bookmarkEnd.line, bookmarkEnd, endOffset, this.selection.end.location);
            let block: BlockWidget = this.documentHelper.blockToShift;
            if (!isNullOrUndefined(block) && this.viewer instanceof PageLayoutViewer && block.bodyWidget.sectionFormat.columns.length > 1) {
                let lastbody: BodyWidget = this.documentHelper.layout.getBodyWidget(block.bodyWidget, false);
                if ((!isNullOrUndefined(lastbody.nextRenderedWidget) && (lastbody.nextRenderedWidget as BodyWidget).sectionFormat.breakCode === 'NoBreak' && lastbody.page === (lastbody.nextRenderedWidget as BodyWidget).page)) {
                    this.reLayout(this.selection);
                }
            }
            this.owner.isShiftingEnabled = false;
            this.selection.fireSelectionChanged(true);
        }
        this.fireContentChange();
        if (this.owner.documentEditorSettings.showBookmarks == true) {
            this.viewer.updateScrollBars();
        }
    }

    /**
     * @private
     */
    public createBookmarkElements(name: string): BookmarkElementBox[] {
        const bookmark: BookmarkElementBox = new BookmarkElementBox(0);
        bookmark.name = name;
        const bookmarkEnd: BookmarkElementBox = new BookmarkElementBox(1);
        bookmarkEnd.name = name;
        bookmark.reference = bookmarkEnd;
        bookmarkEnd.reference = bookmark;
        return [bookmark,bookmarkEnd];
    }
    /**
     * Deletes the specified bookmark in the current document.
     *
     * @param {string} bookmarkName Specify the name of bookmark to be deleted.
     * @returns {void}
     */
    public deleteBookmark(bookmarkName: string): void {
        const bookmarks: Dictionary<string, BookmarkElementBox> = this.documentHelper.bookmarks;
        const bookmark: BookmarkElementBox = bookmarks.get(bookmarkName);
        if (bookmark instanceof BookmarkElementBox) {
            const bookmarkEnd: BookmarkElementBox = bookmark.reference;
            // History for inserting bookmark with existing bookmark name was changed as a complex history as per MS word behavior and added the below lines for getting existing bookmarks offset in history  
            let start: TextPosition = this.selection.start.clone();
            let end: TextPosition = this.selection.end.clone();
            if (!this.selection.isForward) {
                start = this.selection.end.clone();
                end = this.selection.start.clone();
            }
            let startElementInfo: ElementInfo = this.selection.getElementInfo(start.currentWidget, start.offset);
            let isBookmark: boolean = false;
            let bookmarkNextElementInfo: ElementInfo;
            let previousElementInfo: ElementInfo;
            // handled the case where if the bookmark select method is called we get the element present before the bookmark so if the next element is bookmark we get the bookmark.
            if (!isNullOrUndefined(startElementInfo.element) && startElementInfo.element !== bookmark && startElementInfo.element.nextElement === bookmark) {
                previousElementInfo = this.selection.getElementInfo(start.currentWidget, start.offset);
                startElementInfo = this.selection.getElementInfo(start.currentWidget, start.offset + 1);
                // Updates the offset to the current bookmark for accurate selection.
                start.offset += 1;
            }
            if (startElementInfo.element === bookmark) {
                isBookmark = true;
                bookmarkNextElementInfo = this.selection.getElementInfo(start.currentWidget, start.offset === 0 ? start.offset + 2 : start.offset + 1);
            }
            let endElementInfo: ElementInfo = this.selection.getElementInfo(end.currentWidget, end.offset);
            if (endElementInfo.element === bookmarkEnd) {
                endElementInfo = this.selection.getElementInfo(end.currentWidget, end.offset - 1);
            }
            this.selection.start.setPositionParagraph(bookmark.line, bookmark.line.getOffset(bookmark, bookmark.length));
            this.selection.end.setPositionParagraph(bookmarkEnd.line, bookmarkEnd.line.getOffset(bookmarkEnd, bookmarkEnd.length) - 1);
            this.initHistory('DeleteBookmark');
            this.selection.selectPosition(start, end);
            if (this.editorHistory) {
                this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Marker_Start;
                this.editorHistory.currentBaseHistoryInfo.markerData.push({bookmarkName: bookmarkName});
                this.editorHistory.currentBaseHistoryInfo.setBookmarkInfo(bookmark);
            }
            this.deleteBookmarkInternal(bookmark);
            if (this.editorHistory) {
                this.editorHistory.updateHistory();
            }
            if (isBookmark && !isNullOrUndefined(bookmarkNextElementInfo) && bookmarkNextElementInfo.element !== bookmark && bookmarkNextElementInfo.element !== bookmarkEnd) {
                this.selection.start.setPositionParagraph(bookmarkNextElementInfo.element.line, (bookmarkNextElementInfo.element.line.getOffset(bookmarkNextElementInfo.element, bookmarkNextElementInfo.index) - 1));
                isBookmark = true;
            } else {
                isBookmark = false;
            }
            if (!isNullOrUndefined(endElementInfo.element) && endElementInfo.element !== bookmark && endElementInfo.element !== bookmarkEnd) {
                this.selection.end.setPositionParagraph(endElementInfo.element.line, endElementInfo.element.line.getOffset(endElementInfo.element, endElementInfo.index));
            }
            // Handles the case where the start and end positions are the same.
            if (endElementInfo.element === bookmark && !isNullOrUndefined(bookmarkNextElementInfo) &&  bookmarkNextElementInfo.element === bookmarkEnd) {
                if (!isBookmark && !isNullOrUndefined(previousElementInfo)) {
                    this.selection.start.setPositionParagraph(previousElementInfo.element.line, previousElementInfo.element.line.getOffset(previousElementInfo.element, previousElementInfo.index));
                    this.selection.selectPosition(this.selection.start, this.selection.start);
                } else if (isNullOrUndefined(previousElementInfo) && bookmarkNextElementInfo.element === bookmarkEnd) {
                    start.offset = start.offset === 0 ? start.offset : start.offset - 1;
                    this.selection.selectPosition(start, start);
                }
            }
        }
        this.fireContentChange();
        if (this.owner.documentEditorSettings.showBookmarks == true) {
            this.viewer.updateScrollBars();
        }
    }
    /**
     * @param bookmark
     * @private
     * @returns {void}
     */
    public deleteBookmarkInternal(bookmark: BookmarkElementBox): void {
        const previousNode: ElementBox = bookmark.previousNode;
        if (previousNode instanceof FieldElementBox && previousNode.fieldType === 0
            && !isNullOrUndefined(previousNode.formFieldData)) {
            previousNode.formFieldData.name = '';
        }
        if (!isNullOrUndefined(bookmark.properties)) {
            let columnFirst = parseInt(bookmark.properties["columnFirst"]);
            let row = bookmark.paragraph.associatedCell.ownerRow;
            let cell = row.getCellUsingColumnIndex(row.rowIndex, columnFirst);
            if (!isNullOrUndefined(cell)) {
                cell.isRenderBookmarkStart = false;
            }
            let columnLast: number = parseInt(bookmark.properties["columnLast"]);
            if (!isNullOrUndefined(bookmark.reference) && !isNullOrUndefined(bookmark.reference.paragraph.associatedCell)) {
                let endRow: TableRowWidget = bookmark.reference.paragraph.associatedCell.ownerRow;
                let endCell: TableCellWidget = undefined;
                let cellIndex: number = columnLast;
                while (isNullOrUndefined(endCell) && cellIndex > -1) {
                    endCell = endRow.getCell(endRow.rowIndex, cellIndex);
                    if (isNullOrUndefined(endCell)) {
                        cellIndex--;
                    }
                }
                if (endCell.isRenderBookmarkEnd) {
                    endCell.isRenderBookmarkEnd = false;
                }
            }
        }
        else{
            if(this.documentHelper.selection.isRenderBookmarkAtEnd(bookmark)){
                if(!isNullOrUndefined(bookmark.reference) && !isNullOrUndefined(bookmark.reference.paragraph.associatedCell)){
                    let row: TableRowWidget = bookmark.reference.paragraph.associatedCell.ownerRow;
                    if (row.isRenderBookmarkEnd) {
                        row.isRenderBookmarkEnd = false;
                    }
                }
            }
        }
        this.documentHelper.bookmarks.remove(bookmark.name);
        bookmark.line.children.splice(bookmark.indexInOwner, 1);
        if (!isNullOrUndefined(bookmark.reference)) {
            bookmark.reference.line.children.splice(bookmark.reference.indexInOwner, 1);
        }
        // Remove bookmark from header footer collections
        const paragraph: ParagraphWidget = bookmark.line.paragraph;
        if (bookmark.line.paragraph.isInHeaderFooter) {
            let headerFooterWidget: HeaderFooterWidget = undefined;
            if (paragraph.containerWidget instanceof TableCellWidget) {

                headerFooterWidget = (paragraph.containerWidget as TableCellWidget).getContainerTable().containerWidget as HeaderFooterWidget;
            } else if (paragraph.containerWidget instanceof HeaderFooterWidget) {
                headerFooterWidget = paragraph.containerWidget;
            }
            this.updateHeaderFooterWidget(headerFooterWidget);
        }
    }

    /**
     * @private
     */
    public getSelectionInfo(isBookmark?: boolean): SelectionInfo {
        let start: TextPosition = this.selection.start;
        let end: TextPosition = this.selection.end;
        if (!this.selection.isForward) {
            start = this.selection.end;
            end = this.selection.start;
        }
        if (!(end.offset === this.selection.getLineLength(end.currentWidget) + 1
            && this.selection.isParagraphLastLine(end.currentWidget)) && !this.owner.documentHelper.isDragging) {
            end.offset += 1;
        }
        let blockInfo: ParagraphInfo = this.selection.getParagraphInfo(start);
        let startIndex: string = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        blockInfo = this.selection.getParagraphInfo(end);
        let endIndex: string = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        let selectedWidgets = this.selection.selectedWidgets.keys;
        if ((!isNullOrUndefined(isBookmark) && isBookmark == true) && !this.selection.hasMergedCells()) {
            if (start.paragraph.isInsideTable) {
                let startCell: TableCellWidget = this.selection.getCellFromSelection(0);
                if (!isNullOrUndefined(startCell) && startCell instanceof TableCellWidget) {
                    startIndex = this.selection.getActualOffset(startCell, 0);
                }
            }
            if (end.paragraph.isInsideTable) {
                let endCell: TableCellWidget = this.selection.getCellFromSelection(1);
                if (!isNullOrUndefined(endCell) && endCell instanceof TableCellWidget) {
                    endIndex = this.selection.getActualOffset(endCell, 1);
                }
            }
        } else {
            if (selectedWidgets[0] instanceof TableCellWidget) {
                if (start.paragraph.isInsideTable) {
                    var startCell: TableCellWidget = this.selection.getCellFromSelectionInTable(0);
                    if (!isNullOrUndefined(startCell) && startCell instanceof TableCellWidget) {
                        startIndex = this.selection.getActualOffset(startCell, 0);
                    }
                }
            }
            if (selectedWidgets[selectedWidgets.length - 1] instanceof TableCellWidget) {
                if (end.paragraph.isInsideTable) {
                    var endCell = this.selection.getCellFromSelectionInTable(1);
                    if (!isNullOrUndefined(endCell) && endCell instanceof TableCellWidget) {
                        endIndex = this.selection.getActualOffset(endCell, 1);
                    }
                }
            }
        }
        return { 'start': startIndex, 'end': endIndex };
    }

    private insertElements(endElements: ElementBox[], startElements?: ElementBox[], isBookmark?: boolean, isNavigationPane?: boolean): void {
        let info: SelectionInfo = this.getSelectionInfo(isBookmark);
        if (isBookmark) {
            if (!isNullOrUndefined((startElements[0] as BookmarkElementBox).properties) && (startElements[0] as BookmarkElementBox).bookmarkType == 0) {
                info = this.owner.selection.updateSelectionInfo(info);
            }
        }
        if (!isNullOrUndefined(startElements)) {
            this.insertElementsInternal(this.selection.getTextPosBasedOnLogicalIndex(info.start), startElements,undefined, isNavigationPane);
            if (this.owner.isSpellCheck && isBookmark && startElements[0].previousElement && startElements[0].previousElement instanceof TextElementBox) {
                startElements[0].previousElement.isChangeDetected = true;
            }
        }
        if (!isNullOrUndefined(endElements)) {
            this.insertElementsInternal(this.selection.getTextPosBasedOnLogicalIndex(info.end), endElements,undefined, isNavigationPane);
            if (this.owner.isSpellCheck && isBookmark && (endElements[0] as BookmarkElementBox).reference.line !== endElements[0].line && endElements[0].previousElement && endElements[0].previousElement instanceof TextElementBox) {
                endElements[0].previousElement.isChangeDetected = true;
            }
        }

    }

    /**
     *
     * @private
     * @returns {void}
     */
    public insertElementsInternal(position: TextPosition, elements: ElementBox[], isRelayout?: boolean, isNavigationPane?: boolean): void {
        this.selection.selectPosition(position, position);
        this.initHistory('InsertElements');
        if (!isNullOrUndefined(this.editorHistory) && this.editorHistory.currentBaseHistoryInfo) {
            if (elements[0] instanceof BookmarkElementBox && this.editorHistory || elements[0] instanceof EditRangeStartElementBox || elements[0] instanceof EditRangeEndElementBox || elements[0] instanceof ContentControl) {
                this.editorHistory.currentBaseHistoryInfo.markerData.push(this.getMarkerData(elements[0] as BookmarkElementBox));
            }
            if (elements[0] instanceof TextElementBox) {
                this.editorHistory.currentBaseHistoryInfo.insertedText = (elements[0] as TextElementBox).text;
                this.setCharFormatForCollaborativeEditing(elements[0].characterFormat);
            }
        }
        this.updateInsertPosition();
        let indexInInline: number = 0;
        const paragraphInfo: ParagraphInfo = this.selection.getParagraphInfo(this.selection.start);
        if (this.selection.start.paragraph.isEmpty()) {
            const paragraph: ParagraphWidget = this.selection.start.paragraph as ParagraphWidget;
            (paragraph.childWidgets[0] as LineWidget).children.push(elements[0]);
            elements[0].line = (paragraph.childWidgets[0] as LineWidget);
            elements[0].linkFieldCharacter(this.documentHelper);
            this.documentHelper.layout.reLayoutParagraph(paragraph, 0, 0);
            this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + length, true);

            position.setPositionForSelection(elements[0].line, elements[0], elements[0].length, this.selection.start.location);
            this.selection.selectPosition(position, position);
        } else {

            const inlineObj: ElementInfo = this.selection.start.currentWidget.getInline(this.documentHelper.selection.start.offset, indexInInline);
            const curInline: ElementBox = inlineObj.element;
            indexInInline = inlineObj.index;
            const firstElement: ElementBox = elements[0];
            this.insertElementInternal(curInline, firstElement, indexInInline, undefined, true, isNavigationPane);
            const index: number = firstElement.indexInOwner;
            let lastElement: ElementBox = firstElement;
            for (let i: number = 1; i < elements.length; i++) {
                lastElement = elements[i];
                firstElement.line.children.splice(index + i, 0, lastElement);
            }
            position.setPositionForSelection(lastElement.line, lastElement, lastElement.length, this.selection.start.location);
            this.selection.selectPosition(position, position);
        }
        if (this.editorHistory) {
            if (this.checkEndPosition()) {
                this.updateHistoryPosition(this.selection.start, false);
            }
            this.editorHistory.updateHistory();
        }
    }
    /**
     * @private
     */
    public getMarkerData(element: ElementBox, skip?: boolean, revision?: Revision, isAcceptOrReject?: string): MarkerInfo {
        let markerData: MarkerInfo = {};
        if (this.editorHistory.currentBaseHistoryInfo || this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            if (element instanceof BookmarkElementBox) {
                let columnFirst: string = '';
                let columnLast: string = '';
                let isAfterParagraphMark: boolean;
                let isAfterTableMark: boolean;
                let isAfterRowMark: boolean;
                let isAfterCellMark: boolean;
                if (element.bookmarkType == 0) {
                    if(!this.editorHistory.isUndoing && !this.editorHistory.isRedoing) {
                        this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Marker_Start;
                    }
                    if (!isNullOrUndefined(element.properties)) {
                        columnFirst = element.properties['columnFirst'];
                        columnLast = element.properties['columnLast'];
                    }
                } else {
                    if(!this.editorHistory.isUndoing && !this.editorHistory.isRedoing) {
                        this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Marker_End;
                    }
                    if (!isNullOrUndefined(element.properties)) {
                        isAfterParagraphMark = element.properties['isAfterParagraphMark'];
                        isAfterTableMark = element.properties['isAfterTableMark'];
                        isAfterRowMark = element.properties['isAfterRowMark'];
                        isAfterCellMark = element.properties['isAfterCellMark'];
                    }
                }
                markerData = {
                    bookmarkName: element.name,
                    type: "Bookmark",
                    skipOperation: skip,
                    columnFirst: columnFirst,
                    columnLast: columnLast,
                    isAfterParagraphMark: isAfterParagraphMark,
                    isAfterTableMark: isAfterTableMark,
                    isAfterRowMark: isAfterRowMark,
                    isAfterCellMark: isAfterCellMark
                }
            } else if (element instanceof EditRangeStartElementBox || element instanceof EditRangeEndElementBox) {
                let elementBox: EditRangeStartElementBox;
                if (element instanceof EditRangeStartElementBox) {
                    elementBox = element as EditRangeStartElementBox;
                    if (!this.editorHistory.isUndoing && !this.editorHistory.isRedoing) {
                        this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Marker_Start;
                    }
                } else {
                    elementBox = (element as EditRangeEndElementBox).editRangeStart;
                    if (!this.editorHistory.isUndoing && !this.editorHistory.isRedoing) {
                        this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Marker_End;
                    }
                }
                let user: string = elementBox.user === '' ? elementBox.group : elementBox.user;
                markerData = { 'user': user, 'type': "EditRange", 'editRangeId': elementBox.editRangeId, 'skipOperation': skip, 'columnFirst': isNullOrUndefined(elementBox.columnFirst) ? undefined : elementBox.columnFirst.toString(), 'columnLast': isNullOrUndefined(elementBox.columnLast) ? undefined : elementBox.columnLast.toString() };
            } else if (element instanceof FieldElementBox) {
                if (element.fieldType == 0) {
                    this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Marker_Start;
                } else if (element.fieldType == 2) {
                    this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Field_Separator;
                } else {
                    this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Marker_End;
                }
                markerData = { 'type': "Field" };
            } else if (element instanceof FootnoteElementBox) {
                markerData =
                {
                    type: (element as FootnoteElementBox).footnoteType
                };
            } else if (element instanceof TextElementBox) {
                this.editorHistory.currentBaseHistoryInfo.insertedText = element.text;
            } else if (element instanceof ContentControl) {
                markerData = {
                    type: 'ContentControl',
                    text: element.contentControlWidgetType
                }
                if (element.type == 0) {
                    if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                        this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Marker_Start;
                    }
                    markerData.contentControlProperties = JSON.stringify(this.getContentControlPropObject(element.contentControlProperties));
                } else {
                    if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                        this.editorHistory.currentBaseHistoryInfo.insertedText = CONTROL_CHARACTERS.Marker_End;
                    }
                    markerData.contentControlProperties = JSON.stringify(this.getContentControlPropObject(element.contentControlProperties));
                }
            }
        }
        if (!isNullOrUndefined(revision)) {
            markerData = this.getRevisionMarkerData(markerData, revision, skip, isAcceptOrReject);
        }
        return markerData;
    }
    /**
     * @private
     * @returns {any}
     */
    public getRevisionMarkerData(markerData: MarkerInfo, revision: Revision, skip?: boolean, isAcceptOrReject?: string): any {
        if (isNullOrUndefined(markerData)) {
            markerData = {};
        }
        // markerData.revisionId = revision.revisionID;
        markerData.revisionType = revision.revisionType;
        markerData.author = revision.author;
        markerData.date = revision.date;
        markerData.skipOperation = skip;
        markerData.isAcceptOrReject = isAcceptOrReject;
        return markerData;
    }
    /**
     * @param index
     * @private
     * @returns {CommentElementBox}
     */
    public getCommentElementBox(index: string): CommentElementBox {
        const position: string[] = index.split(';');
        const comment: CommentElementBox = this.documentHelper.comments[parseInt(position[1], 10)];
        if (position.length > 2 && position[2] !== '') {
            return comment.replyComments[parseInt(position[2], 10)];
        }
        return comment;
    }
    /**
     * @param position
     * @private
     * @returns {BlockInfo}
     */
    public getBlock(position: IndexInfo): BlockInfo {
        const bodyWidget: BodyWidget = this.selection.getBodyWidget(position);
        return this.getBlockInternal(bodyWidget, position);
    }

    private getBlockInternal(widget: Widget, position: IndexInfo): BlockInfo {
        if (position.index === '' || isNullOrUndefined(position)) {
            return undefined;
        }
        let index: number = position.index.indexOf(';');
        const value: string = position.index.substring(0, index);
        position.index = position.index.substring(index).replace(';', '');
        const node: Widget = widget;
        // if (node instanceof WSection && value === 'HF') {
        //     //Gets the block in Header footers.
        //     let blockObj: BlockInfo = this.getBlock((node as WSection).headerFooters, position);

        //     return { 'node': (!isNullOrUndefined(blockObj)) ? blockObj.node : undefined, 'position': (!isNullOrUndefined(blockObj)) ? blockObj.position : undefined };
        // }
        index = parseInt(value, 10);
        const childWidget: Widget = this.selection.getBlockByIndex(widget, index);
        if (childWidget) {
            const child: Widget = childWidget as Widget;
            if (position.index.indexOf(';') >= 0) {
                if (child instanceof ParagraphWidget) {
                    if (position.index.indexOf(';') >= 0) {
                        position.index = '0';
                    }
                    return { 'node': child as ParagraphWidget, 'position': position };
                }
                if (child instanceof Widget) {
                    const blockObj: BlockInfo = this.getBlockInternal((child as Widget), position);

                    return { 'node': (!isNullOrUndefined(blockObj)) ? blockObj.node : undefined, 'position': (!isNullOrUndefined(blockObj)) ? blockObj.position : undefined };
                }
            } else {
                return { 'node': child as BlockWidget, 'position': position };
            }
        } else {
            return { 'node': node as BlockWidget, 'position': position };
        }
        return { 'node': node as BlockWidget, 'position': position };
    }
    /**
     * @param position
     * @param isInsertPosition
     * @private
     * @returns {void}
     */
    public updateHistoryPosition(position: TextPosition | string, isInsertPosition: boolean): void {
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            let hierarchicalIndex: string;
            if (position instanceof TextPosition) {
                const blockInfo: ParagraphInfo = this.selection.getParagraphInfo(position);
                hierarchicalIndex = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            } else {
                hierarchicalIndex = position;
            }
            if (isInsertPosition) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = hierarchicalIndex;
            } else {
                this.editorHistory.currentBaseHistoryInfo.endPosition = hierarchicalIndex;
            }
        }
    }

    /**
     * Applies the borders based on given settings.
     *
     * @param {BorderSettings} settings Specify the border settings to be applied.
     * @returns {void}
     */
    public applyBorders(settings: BorderSettings): void {
        this.initHistory('Borders');
        const startPos: TextPosition = this.selection.isForward ? this.selection.start : this.selection.end;
        const endPos: TextPosition = this.selection.isForward ? this.selection.end : this.selection.start;
        let table: TableWidget = startPos.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.owner.viewer) as TableWidget;
        if (this.editorHistory) {
            const clonedTable: TableWidget = this.cloneTableToHistoryInfo(table);
        }
        const startCell: TableCellWidget = startPos.paragraph.associatedCell;
        const endCell: TableCellWidget = endPos.paragraph.associatedCell;
        let cells: TableCellWidget[];
        const border: WBorder = this.getBorder(settings.borderColor, settings.lineWidth, settings.borderStyle);
        if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.editorHistory.currentBaseHistoryInfo.insertedFormat = startPos.paragraph.associatedCell.cellFormat.borders;
        }
        if (this.documentHelper.selection.isTableSelected()) {
            if (settings.type === 'TopBorder' || settings.type === 'OutsideBorders' || settings.type === 'AllBorders') {
                table.tableFormat.borders.top.copyFormat(border);
            }
            if (settings.type === 'BottomBorder' || settings.type === 'OutsideBorders' || settings.type === 'AllBorders') {
                table.tableFormat.borders.bottom.copyFormat(border);
            }
            if (settings.type === 'LeftBorder' || settings.type === 'OutsideBorders' || settings.type === 'AllBorders') {
                table.tableFormat.borders.left.copyFormat(border);
            }
            if (settings.type === 'RightBorder' || settings.type === 'OutsideBorders' || settings.type === 'AllBorders') {
                table.tableFormat.borders.right.copyFormat(border);
            }
            if (settings.type === 'InsideHorizontalBorder' || settings.type === 'AllBorders' || settings.type === 'InsideBorders') {
                table.tableFormat.borders.horizontal.copyFormat(border);
            }
            if (settings.type === 'InsideVerticalBorder' || settings.type === 'AllBorders' || settings.type === 'InsideBorders') {
                table.tableFormat.borders.vertical.copyFormat(border);
            }
        } else {
            if (this.selection.isEmpty) {
                //Apply borders for current selected cell initially.
                if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                    settings.type === 'LeftBorder') {
                    endCell.cellFormat.borders.left.copyFormat(border);
                }
                if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                    settings.type === 'TopBorder') {
                    endCell.cellFormat.borders.top.copyFormat(border);
                }
                if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                    settings.type === 'RightBorder') {
                    endCell.cellFormat.borders.right.copyFormat(border);
                }
                if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                    settings.type === 'BottomBorder') {
                    endCell.cellFormat.borders.bottom.copyFormat(border);
                }
                if (settings.type === 'AllBorders' || settings.type === 'InsideBorders'
                    || settings.type === 'InsideVerticalBorder') {
                    endCell.cellFormat.borders.vertical.copyFormat(border);
                }
                if (settings.type === 'AllBorders' || settings.type === 'InsideBorders'
                    || settings.type === 'InsideHorizontalBorder') {
                    endCell.cellFormat.borders.horizontal.copyFormat(border);
                }
                if (settings.type === 'NoBorder') {
                    this.clearAllBorderValues(endCell.cellFormat.borders);
                }
            } else {
                if (settings.type === 'OutsideBorders' || settings.type === 'TopBorder') {
                    const selectedCell: TableCellWidget[] = this.getTopBorderCellsOnSelection();
                    for (let i: number = 0; i < selectedCell.length; i++) {
                        selectedCell[i].cellFormat.borders.top.copyFormat(border);
                    }
                }
                if (settings.type === 'OutsideBorders' || settings.type === 'LeftBorder') {
                    const selectedCell: TableCellWidget[] = this.getLeftBorderCellsOnSelection();
                    for (let i: number = 0; i < selectedCell.length; i++) {
                        selectedCell[i].cellFormat.borders.left.copyFormat(border);
                    }
                }
                if (settings.type === 'OutsideBorders' || settings.type === 'RightBorder') {
                    const selectedCell: TableCellWidget[] = this.getRightBorderCellsOnSelection();
                    for (let i: number = 0; i < selectedCell.length; i++) {
                        selectedCell[i].cellFormat.borders.right.copyFormat(border);
                    }
                }
                if (settings.type === 'OutsideBorders' || settings.type === 'BottomBorder') {
                    const selectedCell: TableCellWidget[] = this.getBottomBorderCellsOnSelection();
                    for (let i: number = 0; i < selectedCell.length; i++) {
                        selectedCell[i].cellFormat.borders.bottom.copyFormat(border);
                    }
                }
            }
            //Apply Only borders property to selected cells
            if (settings.type === 'BottomBorder' || settings.type === 'AllBorders' || settings.type === 'OutsideBorders'
                || settings.type === 'NoBorder') {
                cells = this.getAdjacentCellToApplyBottomBorder();
                for (let i: number = 0; i < cells.length; i++) {
                    const cell: TableCellWidget = cells[i];
                    if (settings.type === 'NoBorder') {
                        cell.cellFormat.borders.top.copyFormat(this.clearBorder());
                    } else {
                        cell.cellFormat.borders.top.copyFormat(border);
                    }
                }
            }
            if (settings.type === 'AllBorders' || settings.type === 'OutsideBorders' || settings.type === 'RightBorder'
                || settings.type === 'NoBorder') {
                cells = this.getAdjacentCellToApplyRightBorder();
                for (let i: number = 0; i < cells.length; i++) {
                    const cell: TableCellWidget = cells[i];
                    if (settings.type === 'NoBorder') {
                        cell.cellFormat.borders.left.copyFormat(this.clearBorder());
                    } else {
                        cell.cellFormat.borders.left.copyFormat(border);
                    }
                }
            }
            if (settings.type === 'AllBorders' || settings.type === 'NoBorder') {
                this.applyAllBorders(border, settings.type);
            }
            if (settings.type === 'InsideBorders' || settings.type === 'InsideVerticalBorder'
                || settings.type === 'InsideHorizontalBorder' || settings.type === 'NoBorder') {
                this.applyInsideBorders(border, settings.type, table);
            }
        }
        this.updateGridForTableDialog(table, false);
        this.reLayout(this.selection, false);
        this.editorHistory.updateHistory();
    }
    private applyAllBorders(border: WBorder, borderType: BorderType): void {
        const cells: TableCellWidget[] = this.selection.getSelectedCells();
        for (let i: number = 0; i < cells.length; i++) {
            if (borderType === 'NoBorder') {
                cells[i].cellFormat.borders.left.copyFormat(this.clearBorder());
                cells[i].cellFormat.borders.right.copyFormat(this.clearBorder());
                cells[i].cellFormat.borders.top.copyFormat(this.clearBorder());
                cells[i].cellFormat.borders.bottom.copyFormat(this.clearBorder());
            } else {
                cells[i].cellFormat.borders.left.copyFormat(border);
                cells[i].cellFormat.borders.right.copyFormat(border);
                cells[i].cellFormat.borders.top.copyFormat(border);
                cells[i].cellFormat.borders.bottom.copyFormat(border);
            }
        }
    }
    private applyInsideBorders(border: WBorder, borderType: BorderType, table: TableWidget): void {
        const cells: TableCellWidget[] = this.selection.getSelectedCells();
        for (let i: number = 0; i < cells.length; i++) {
            const cell: TableCellWidget = cells[i];
            const isLastSelectedRow: boolean = cell.ownerRow === cells[cells.length - 1].ownerRow;
            const isLastRightCell: boolean = (cell.columnIndex + cell.cellFormat.columnSpan - 1) === cells[cells.length - 1].columnIndex;
            if (borderType === 'NoBorder') {
                cell.cellFormat.borders.right.copyFormat(this.clearBorder());
                cell.cellFormat.borders.bottom.copyFormat(this.clearBorder());
            } else {
                if (!isLastRightCell && borderType !== 'InsideHorizontalBorder') {
                    cell.cellFormat.borders.right.copyFormat(border);
                }
                if (!isLastSelectedRow && borderType !== 'InsideVerticalBorder') {
                    cell.cellFormat.borders.bottom.copyFormat(border);
                }
            }
            if (!isLastSelectedRow && borderType !== 'InsideVerticalBorder') {
                // Apply adjacent bottom borders.
                const nextRowIndex: number = cell.ownerRow.rowIndex + cell.cellFormat.rowSpan;
                const nextRow: TableRowWidget = table.childWidgets[nextRowIndex] as TableRowWidget;
                if (nextRow) {
                    const selectedCells: TableCellWidget[] = this.getAdjacentBottomBorderOnEmptyCells(nextRow, cell, true);
                    for (let j: number = 0; j < selectedCells.length; j++) {
                        if (borderType === 'NoBorder') {
                            selectedCells[j].cellFormat.borders.top.copyFormat(this.clearBorder());
                        } else {
                            selectedCells[j].cellFormat.borders.top.copyFormat(border);
                        }
                    }
                }
            }
            if (!isLastRightCell && borderType !== 'InsideHorizontalBorder') {
                // Apply adjacent right borders.
                const rightBorderCells: TableCellWidget[] = this.getSelectedCellsNextWidgets(cell, table);
                for (let k: number = 0; k < rightBorderCells.length; k++) {
                    if (borderType === 'NoBorder') {
                        rightBorderCells[k].cellFormat.borders.left.copyFormat(this.clearBorder());
                    } else {
                        rightBorderCells[k].cellFormat.borders.left.copyFormat(border);
                    }
                }
            }
        }
    }

    private getTopBorderCellsOnSelection(): TableCellWidget[] {
        const startPos: TextPosition = this.selection.isForward ? this.selection.start : this.selection.end;
        const startCell: TableCellWidget = startPos.paragraph.associatedCell;
        const topBorderCells: TableCellWidget[] = [];
        const cells: TableCellWidget[] = this.selection.getSelectedCells();
        for (let i: number = 0; i < cells.length; i++) {
            if (cells[i].ownerRow === startCell.ownerRow) {
                topBorderCells.push(cells[i] as TableCellWidget);
            }
        }
        return topBorderCells;
    }

    private getLeftBorderCellsOnSelection(): TableCellWidget[] {
        const startPos: TextPosition = this.selection.isForward ? this.selection.start : this.selection.end;
        const startCell: TableCellWidget = startPos.paragraph.associatedCell;
        const cells: TableCellWidget[] = this.selection.getSelectedCells();
        const leftBorderCells: TableCellWidget[] = [];
        for (let i: number = 0; i < cells.length; i++) {
            if (cells[i].columnIndex === startCell.columnIndex) {
                leftBorderCells.push(cells[i] as TableCellWidget);
            }
        }
        return leftBorderCells;
    }

    private getRightBorderCellsOnSelection(): TableCellWidget[] {
        const cells: TableCellWidget[] = this.selection.getSelectedCells();
        const rightBorderCells: TableCellWidget[] = [];
        for (let i: number = 0; i < cells.length; i++) {
            if ((cells[i].columnIndex + cells[i].cellFormat.columnSpan - 1) === cells[cells.length - 1].columnIndex) {
                rightBorderCells.push(cells[i] as TableCellWidget);
            }
        }
        return rightBorderCells;
    }

    private getBottomBorderCellsOnSelection(): TableCellWidget[] {
        const endPos: TextPosition = this.selection.isForward ? this.selection.end : this.selection.start;
        const endCell: TableCellWidget = endPos.paragraph.associatedCell;
        const cells: TableCellWidget[] = this.selection.getSelectedCells();
        const bottomBorderCells: TableCellWidget[] = [];
        for (let i: number = 0; i < cells.length; i++) {
            if (cells[i].ownerRow === endCell.ownerRow) {
                bottomBorderCells.push(cells[i] as TableCellWidget);
            }
        }
        return bottomBorderCells;
    }

    private clearAllBorderValues(borders: WBorders): void {
        const border: WBorder = this.clearBorder();
        borders.bottom.copyFormat(border);
        borders.left.copyFormat(border);
        borders.right.copyFormat(border);
        borders.top.copyFormat(border);
        borders.vertical.copyFormat(border);
        borders.horizontal.copyFormat(border);
    }
    private clearBorder(): WBorder {
        const border: WBorder = new WBorder();
        border.lineStyle = 'Cleared';
        return border;
    }

    private getAdjacentCellToApplyBottomBorder(): TableCellWidget[] {
        let cells: TableCellWidget[] = [];
        let startPos: TextPosition = this.selection.start;
        let endPos: TextPosition = this.selection.end;
        if (!this.selection.isForward) {
            startPos = this.selection.end;
            endPos = this.selection.start;
        }
        let table: TableWidget = startPos.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.owner.viewer) as TableWidget;
        const startCell: TableCellWidget = startPos.paragraph.associatedCell;
        const endCell: TableCellWidget = endPos.paragraph.associatedCell;
        const nextRowIndex: number = endCell.ownerRow.rowIndex + endCell.cellFormat.rowSpan;
        const nextRow: TableRowWidget = table.childWidgets[nextRowIndex] as TableRowWidget;
        if (nextRow) {
            if (endCell.cellFormat.columnSpan > 1) {
                for (let i: number = endCell.columnIndex; i < endCell.columnIndex + endCell.cellFormat.columnSpan; i++) {
                    if (nextRow.childWidgets[i]) {
                        cells.push(nextRow.childWidgets[i] as TableCellWidget);
                    }
                }
            } else {
                cells = this.getAdjacentBottomBorderOnEmptyCells(nextRow, endCell);
                if (!this.selection.isEmpty) {
                    for (let i: number = 0; i < nextRow.childWidgets.length; i++) {
                        const nextCellColIndex: number = (nextRow.childWidgets[i] as TableCellWidget).columnIndex;
                        if (nextCellColIndex >= startCell.columnIndex && nextCellColIndex <= endCell.columnIndex) {
                            if (nextRow.childWidgets[i]) {
                                cells.push(nextRow.childWidgets[i] as TableCellWidget);
                            }
                        }
                    }
                }
            }
        }
        return cells;
    }
    private getAdjacentBottomBorderOnEmptyCells(nextRow: TableRowWidget, cell: TableCellWidget, isSingleCell?: boolean): TableCellWidget[] {
        const cells: TableCellWidget[] = [];
        if (cell.cellFormat.columnSpan > 1) {
            for (let i: number = cell.columnIndex; i < cell.columnIndex; i++) {
                cells.push(nextRow.childWidgets[i] as TableCellWidget);
            }
        } else {
            if (this.selection.isEmpty || isSingleCell) {
                for (let i: number = 0; i < nextRow.childWidgets.length; i++) {
                    if ((nextRow.childWidgets[i] as TableCellWidget).columnIndex === cell.columnIndex) {
                        cells.push(nextRow.childWidgets[i] as TableCellWidget);
                    }
                }
            }
        }
        return cells;
    }

    private getAdjacentCellToApplyRightBorder(): TableCellWidget[] {
        let cells: TableCellWidget[] = [];
        let startPosIn: TextPosition = this.selection.start;
        let endPosIn: TextPosition = this.selection.end;
        if (!this.selection.isForward) {
            startPosIn = this.selection.end;
            endPosIn = this.selection.start;
        }
        let table: TableWidget = startPosIn.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.owner.viewer) as TableWidget;
        const startCell: TableCellWidget = startPosIn.paragraph.associatedCell;
        const endCell: TableCellWidget = endPosIn.paragraph.associatedCell;
        if (this.selection.isEmpty) {
            const selectedCell: TableCellWidget = startPosIn.paragraph.associatedCell;
            cells = this.getSelectedCellsNextWidgets(selectedCell, table);
        } else {

            const selectedCells: TableCellWidget[] = this.getRightBorderCellsOnSelection();
            for (let i: number = 0; i < selectedCells.length; i++) {
                const cell: TableCellWidget = selectedCells[i] as TableCellWidget;
                cells = cells.concat(this.getSelectedCellsNextWidgets(cell, table));

            }
        }
        return cells;
    }
    private getSelectedCellsNextWidgets(selectedCell: TableCellWidget, table: TableWidget): TableCellWidget[] {
        const cells: TableCellWidget[] = [];
        if (!isNullOrUndefined(selectedCell.nextWidget)) {
            cells.push(selectedCell.nextWidget as TableCellWidget);
            if (selectedCell.cellFormat.rowSpan > 1) {
                const nextRowIndex: number = selectedCell.ownerRow.rowIndex + selectedCell.cellFormat.rowSpan;
                for (let i: number = selectedCell.ownerRow.rowIndex + 1; i < nextRowIndex; i++) {
                    const nextRow: TableRowWidget = table.childWidgets[i] as TableRowWidget;
                    if (nextRow) {
                        for (let j: number = 0; j < nextRow.childWidgets.length; j++) {
                            if ((nextRow.childWidgets[j] as TableCellWidget).columnIndex ===
                                (selectedCell.nextWidget as TableCellWidget).columnIndex) {
                                cells.push(nextRow.childWidgets[j] as TableCellWidget);
                            }
                        }
                    }
                }
            }
        }
        return cells;
    }

    private getBorder(borderColor: string, lineWidth: number, borderStyle: LineStyle): WBorder {
        const border: WBorder = new WBorder();
        border.color = borderColor || '#000000';
        border.lineWidth = lineWidth || 1;
        border.lineStyle = borderStyle || 'Single';
        return border;
    }

    /**
     * Applies borders
     *
     * @param {WBorders} sourceBorders
     * @param {WBorders} applyBorders
     * @private
     * @returns {void}
     */
    public applyBordersInternal(sourceBorders: WBorders, applyBorders: WBorders): void {
        if (!isNullOrUndefined(sourceBorders) && !isNullOrUndefined(sourceBorders)) {
            if (!isNullOrUndefined(sourceBorders.top)) {
                this.applyBorder(sourceBorders.top, applyBorders.top);
            }
            if (!isNullOrUndefined(sourceBorders.bottom)) {
                this.applyBorder(sourceBorders.bottom, applyBorders.bottom);
            }
            if (!isNullOrUndefined(sourceBorders.left)) {
                this.applyBorder(sourceBorders.left, applyBorders.left);
            }
            if (!isNullOrUndefined(sourceBorders.right)) {
                this.applyBorder(sourceBorders.right, applyBorders.right);
            }
            if (!isNullOrUndefined(sourceBorders.horizontal)) {
                this.applyBorder(sourceBorders.horizontal, applyBorders.horizontal);
            }
            if (!isNullOrUndefined(sourceBorders.vertical)) {
                this.applyBorder(sourceBorders.vertical, applyBorders.vertical);
            }
            if (!isNullOrUndefined(sourceBorders.diagonalUp)) {
                this.applyBorder(sourceBorders.diagonalUp, applyBorders.diagonalUp);
            }
            if (!isNullOrUndefined(sourceBorders.diagonalDown)) {
                this.applyBorder(sourceBorders.diagonalDown, applyBorders.diagonalDown);
            }
        }
    }
    /**
     * Apply shading to table
     *
     * @param {WShading} sourceShading
     * @param {WShading} applyShading
     * @private
     * @returns {void}
     */
    public applyShading(sourceShading: WShading, applyShading: WShading): void {
        if (!isNullOrUndefined(applyShading) && !isNullOrUndefined(sourceShading)) {
            if (!isNullOrUndefined(applyShading.backgroundColor)
                && sourceShading.backgroundColor !== applyShading.backgroundColor) {
                sourceShading.backgroundColor = applyShading.backgroundColor;
            }
            if (!isNullOrUndefined(applyShading.foregroundColor)
                && sourceShading.foregroundColor !== applyShading.foregroundColor) {
                sourceShading.foregroundColor = applyShading.foregroundColor;
            }
            if (!isNullOrUndefined(applyShading.textureStyle)
                && sourceShading.textureStyle !== applyShading.textureStyle) {
                sourceShading.textureStyle = applyShading.textureStyle;
            }
        }
    }
    private applyBorder(sourceBorder: WBorder, applyBorder: WBorder): void {
        if (!isNullOrUndefined(sourceBorder) && !isNullOrUndefined(applyBorder)) {
            if (!isNullOrUndefined(applyBorder.color)
                && sourceBorder.color !== applyBorder.color) {
                sourceBorder.color = applyBorder.color;
            }
            if (!isNullOrUndefined(applyBorder.lineStyle)
                && sourceBorder.lineStyle !== applyBorder.lineStyle) {
                sourceBorder.lineStyle = applyBorder.lineStyle;
            }
            if (!isNullOrUndefined(applyBorder.lineWidth)
                && sourceBorder.lineWidth !== applyBorder.lineWidth) {
                sourceBorder.lineWidth = applyBorder.lineWidth;
            }
            if (!isNullOrUndefined(applyBorder.shadow)
                && sourceBorder.shadow !== applyBorder.shadow) {
                sourceBorder.shadow = applyBorder.shadow;
            }
            if (!isNullOrUndefined(applyBorder.space)
                && sourceBorder.space !== applyBorder.space) {
                sourceBorder.space = applyBorder.space;
            }
        }
    }
    /**
     * Apply Table Format changes
     *
     * @param {WTableFormat} format Specifies table format
     * @param {boolean} isShading Specifies shading.
     * @private
     * @returns {void}
     */
    public onTableFormat(format: WTableFormat, isShading?: boolean, table?: TableWidget): void {
        if (!isNullOrUndefined(this.selection.tableFormat)) {
            if (isNullOrUndefined(isShading)) {
                isShading = false;
            }
            this.documentHelper.owner.isShiftingEnabled = true;
            this.editorHistory.initializeHistory('TableFormat');
            if(isNullOrUndefined(table)) {
                table = this.selection.start.paragraph.associatedCell.ownerTable.combineWidget(this.owner.viewer) as TableWidget;
            }
            if (isShading) {
                for (let i: number = 0; i < table.childWidgets.length; i++) {
                    const rowWidget: TableRowWidget = table.childWidgets[i] as TableRowWidget;
                    for (let j: number = 0; j < rowWidget.childWidgets.length; j++) {
                        const cellWidget: TableCellWidget = rowWidget.childWidgets[j] as TableCellWidget;
                        cellWidget.cellFormat.shading.copyFormat(format.shading);
                    }
                }
            }
            // if (!isNullOrUndefined(isShading) && !this.isCellFormatApplied && !isNullOrUndefined(format.borders)) {
            //     for (let i: number = 0; i < table.childWidgets.length; i++) {
            //         const rowWidget: TableRowWidget = table.childWidgets[i] as TableRowWidget;
            //         rowWidget.rowFormat.borders.copyFormat(format.borders);
            //         for (let j: number = 0; j < rowWidget.childWidgets.length; j++) {
            //             const cellWidget: TableCellWidget = rowWidget.childWidgets[j] as TableCellWidget;
            //             cellWidget.cellFormat.borders.copyFormat(format.borders);
            //         }
            //     }
            // }
            this.applyTableFormat(table, undefined, format);
            this.reLayout(this.selection, false);
        }
    }

    private applyTableFormat(table: TableWidget, property: string, value: object): void {
        this.applyTablePropertyValue(undefined, value, table);
    }

    private applyTablePropertyValue(property: string, value: Object, table: TableWidget): void {
        const sourceFormat: WTableFormat = table.tableFormat;
        if (!isNullOrUndefined(this.editorHistory) && this.editorHistory.currentBaseHistoryInfo) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedTableProperties(sourceFormat, property, value);
            this.editorHistory.currentBaseHistoryInfo.insertedFormat = value;
        }
        if (value instanceof WTableFormat) {
            if (isNullOrUndefined(property)) {
                this.handleTableFormat(sourceFormat, value);
            }
            return;
        }
        if (property === 'preferredWidth') {
            sourceFormat.preferredWidth = value as number;
        } else if (property === 'leftIndent') {
            sourceFormat.leftIndent = value as number;
        } else if (property === 'tableAlignment') {
            sourceFormat.tableAlignment = <TableAlignment>value;
        } else if (property === 'cellSpacing') {
            sourceFormat.cellSpacing = value as number;
        } else if (property === 'leftMargin') {
            sourceFormat.leftMargin = value as number;
        } else if (property === 'rightMargin') {
            sourceFormat.rightMargin = value as number;
        } else if (property === 'topMargin') {
            sourceFormat.topMargin = value as number;
        } else if (property === 'bottomMargin') {
            sourceFormat.bottomMargin = value as number;
        } else if (property === 'preferredWidthType') {
            sourceFormat.preferredWidthType = value as WidthType;
        } else if (property === 'bidi') {
            sourceFormat.bidi = value as boolean;
        } else if (property === 'title') {
            sourceFormat.title = value as string;
        } else if (property === 'description') {
            sourceFormat.description = value as string;
        }
        if (property === 'shading') {
            sourceFormat.shading = <WShading>value;
        } else if (property === 'borders') {
            sourceFormat.borders = <WBorders>value;
        }
        // if (!isNullOrUndefined(table)) {
        //     this.layoutItemBlock(table, true);
        // }
    }
    private handleTableFormat(tableFormat: WTableFormat, applyFormat: WTableFormat): void {
        if (this.isBordersAndShadingDialog || this.editorHistory.isUndoing
            || this.editorHistory.isRedoing) {
            if (!isNullOrUndefined(tableFormat.borders)) {
                this.applyBordersInternal(tableFormat.borders, applyFormat.borders);
            }
            if (!isNullOrUndefined(tableFormat.shading)) {
                this.applyShading(tableFormat.shading, applyFormat.shading);
            }
        }
        if (!this.isBordersAndShadingDialog) {
            if (applyFormat.hasValue('bidi') && applyFormat.bidi !== tableFormat.bidi) {
                tableFormat.bidi = applyFormat.bidi;
            }
            if (applyFormat.hasValue('preferredWidth') && applyFormat.preferredWidth !== tableFormat.preferredWidth) {
                tableFormat.preferredWidth = applyFormat.preferredWidth;
            }
            if (applyFormat.hasValue('preferredWidthType') && applyFormat.preferredWidthType !== tableFormat.preferredWidthType) {
                tableFormat.preferredWidthType = applyFormat.preferredWidthType;
            }
            if (applyFormat.hasValue('tableAlignment') && applyFormat.tableAlignment !== tableFormat.tableAlignment) {
                tableFormat.tableAlignment = applyFormat.tableAlignment;
            }
            if (applyFormat.hasValue('leftIndent') && applyFormat.leftIndent !== tableFormat.leftIndent) {
                tableFormat.leftIndent = applyFormat.leftIndent;
            }
        }
        this.updateGridForTableDialog(tableFormat.ownerBase as TableWidget, false);
        if(applyFormat.title !== tableFormat.title){
            tableFormat.title = applyFormat.title;
        }
        if(applyFormat.description !== tableFormat.description){
            tableFormat.description = applyFormat.description;
        }
    }
    private updateGridForTableDialog(table: TableWidget, shiftNextItem: boolean): void {
        if (table.tableHolder) {
            table.updateRowIndex(0);
            table.isGridUpdated = false;
        }
        this.documentHelper.layout.reLayoutTable(table);
    }
    /**
     * Applies Row Format Changes
     *
     * @param {WRowFormat} format Specifies row format
     * @private
     * @returns {void}
     */
    public onRowFormat(format: WRowFormat): void {
        if (isNullOrUndefined(this.selection) || isNullOrUndefined(format)) {
            return;
        }
        this.editorHistory.initializeHistory('RowFormat');
        this.documentHelper.owner.isShiftingEnabled = true;
        const rowStartPos: TextPosition = this.selection.isForward ? this.selection.start : this.selection.end;
        const rowEndPos: TextPosition = this.selection.isForward ? this.selection.end : this.selection.start;
        const table: TableWidget = rowStartPos.paragraph.associatedCell.ownerTable.combineWidget(this.owner.viewer) as TableWidget;
        this.applyRowFormat(rowStartPos.paragraph.associatedCell.ownerRow, rowStartPos, rowEndPos, undefined, format);
        this.reLayout(this.selection, false);
    }
    private applyRowFormat(row: TableRowWidget, start: TextPosition, end: TextPosition, property: string, value: Object): void {
        this.applyRowPropertyValue(this.documentHelper.selection, property, value, row);
        if (end.paragraph.associatedCell.ownerRow === row) {
            return;
        }
        const newRow: TableRowWidget = row.nextWidget as TableRowWidget;
        if (!isNullOrUndefined(newRow)) {
            this.applyRowFormat(newRow, start, end, property, value);
        }
    }
    private applyRowPropertyValue(selection: Selection, property: string, value: Object, row: TableRowWidget): void {
        const applyFormat: WRowFormat = row.rowFormat;
        if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedRowProperties(applyFormat, property, value);
            this.editorHistory.currentBaseHistoryInfo.insertedFormat = value;
        }
        if (value instanceof WRowFormat) {
            if (isNullOrUndefined(property)) {
                this.handleRowFormat(value as WRowFormat, applyFormat);
            }
            return;
        }
        if (property === 'heightType') {
            applyFormat.heightType = value as HeightType;
        } else if (property === 'height') {
            applyFormat.height = value as number;
        } else if (property === 'isHeader') {
            applyFormat.isHeader = value as boolean;
        } else if (property === 'allowBreakAcrossPages') {
            applyFormat.allowBreakAcrossPages = value as boolean;
        }
        if (!isNullOrUndefined(row.ownerTable)) {
            this.layoutItemBlock(row.ownerTable, true);
        }
    }
    private handleRowFormat(format: WRowFormat, applyFormat: WRowFormat): void {
        if (format.hasValue('allowBreakAcrossPages') && format.allowBreakAcrossPages !== applyFormat.allowBreakAcrossPages) {
            applyFormat.allowBreakAcrossPages = format.allowBreakAcrossPages;
        }
        if (format.hasValue('isHeader') && format.isHeader !== applyFormat.isHeader) {
            applyFormat.isHeader = format.isHeader;
        }
        if (format.hasValue('heightType') && format.heightType !== applyFormat.heightType) {
            applyFormat.heightType = format.heightType;
        }
        if (format.hasValue('height') && format.height !== applyFormat.height) {
            applyFormat.height = format.height;
        }
        this.updateGridForTableDialog((applyFormat.ownerBase as TableRowWidget).ownerTable, true);
    }
    /**
     * Applies Cell Format changes
     *
     * @param {WCellFormat} format Specifies cell format
     * @private
     * @returns {void}
     */
    public onCellFormat(format: WCellFormat): void {
        if (isNullOrUndefined(this.selection) || isNullOrUndefined(format)) {
            return;
        }
        this.documentHelper.owner.isShiftingEnabled = true;
        this.editorHistory.initializeHistory('CellFormat');
        this.updateFormatForCell(this.selection, undefined, format);
        this.reLayout(this.selection, false);
    }
    /**
     * Applies Paragraph Format changes
     *
     * @param {WParagraphFormat} format Specifies cell format
     * @private
     * @returns {void}
     */
    public onParaFormat(format: WParagraphFormat): void {
        if (isNullOrUndefined(this.selection) || isNullOrUndefined(format)) {
            return;
        }
        this.editorHistory.initializeHistory('ParagraphFormat');
        this.updateParagraphFormat(undefined, format, false);
        this.reLayout(this.selection, false);
    }
    /**
     * @param selection
     * @param value
     * @private
     * @returns {void}
     */
    public updateCellMargins(selection: Selection, value: WCellFormat): void {
        let cellStartPosition: TextPosition = selection.start;
        let cellEndPosition: TextPosition = selection.end;
        if (!selection.isForward) {
            cellStartPosition = selection.end;
            cellEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, cellStartPosition);

        this.documentHelper.owner.cellOptionsDialogModule.applyCellMarginValue(cellStartPosition.paragraph.associatedCell.ownerRow, cellStartPosition, cellEndPosition, value);
    }

    private updateFormatForCell(selection: Selection, property: string, value: Object): void {
        let start: TextPosition = selection.start;
        let end: TextPosition = selection.end;
        if (!selection.isForward) {
            start = selection.end;
            end = selection.start;
        }
        const startCell: TableCellWidget = start.paragraph.associatedCell;
        const endCell: TableCellWidget = end.paragraph.associatedCell;
        let cells: TableCellWidget[];
        const table: TableWidget = startCell.ownerTable.combineWidget(this.owner.viewer) as TableWidget;
        let appliedFormat: WCellFormat;
        for (let k: number = startCell.columnIndex; k <= endCell.columnIndex; k++) {
            cells = this.getSelectedCellInColumn(startCell.ownerTable, startCell.ownerRow.rowIndex, k, endCell.ownerRow.rowIndex);
            for (let i: number = 0; i < cells.length; i++) {
                appliedFormat = this.applyCellPropertyValue(this.documentHelper.selection, property, value, cells[i].cellFormat);
            }
        }
        this.updateGridForTableDialog(table, false);
    }

    private getSelectedCellInColumn(table: TableWidget, rowStartIndex: number, columnIndex: number, rowEndIndex: number): TableCellWidget[] {
        const cells: TableCellWidget[] = [];
        for (let i: number = rowStartIndex; i <= rowEndIndex; i++) {
            const row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
            for (let j: number = 0; j < row.childWidgets.length; j++) {
                if ((row.childWidgets[j] as TableCellWidget).columnIndex === columnIndex) {
                    cells.push(row.childWidgets[j] as TableCellWidget);
                }
            }
        }
        return cells;
    }
    private getColumnCells(table: TableWidget, columnIndex: number, isLeftSideCollection: boolean): TableCellWidget[] {
        const cells: TableCellWidget[] = [];
        for (let k: number = 0; k < table.childWidgets.length; k++) {
            const row: TableRowWidget = table.childWidgets[k] as TableRowWidget;
            for (let i: number = 0; i < row.childWidgets.length; i++) {
                const cell: TableCellWidget = row.childWidgets[i] as TableCellWidget;
                if (isLeftSideCollection) {
                    if (cell.columnIndex + cell.cellFormat.columnSpan === columnIndex) {
                        cells.push(cell);
                    }
                } else {
                    if (cell.columnIndex === columnIndex) {
                        cells.push(cell);
                    }
                }
            }
        }
        return cells;
    }

    private getTableWidth(table: TableWidget): number {
        if (table.tableFormat.preferredWidth !== 0 || table.tableFormat.preferredWidthType === 'Percent') {
            if (table.tableFormat.preferredWidthType === 'Auto' || table.tableFormat.preferredWidthType === 'Point') {
                return table.tableFormat.preferredWidth;
            } else {
                if (table.tableFormat.preferredWidth === 0) {
                    return 0;
                } else {
                    return HelperMethods.convertPixelToPoint(this.owner.viewer.clientArea.width) / 100 * table.tableFormat.preferredWidth;
                }
            }
        }
        return HelperMethods.convertPixelToPoint(this.documentHelper.layout.getTableWidth(table));
    }
    /**
     *
     * @private
     * @returns {void}
     */
    public applyCellPropertyValue(selection: Selection, property: string, value: Object, applyFormat: WCellFormat): WCellFormat {
        if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedCellProperties(applyFormat, property, value);
            this.editorHistory.currentBaseHistoryInfo.insertedFormat = value;
        }
        if (value instanceof WCellFormat) {
            if (isNullOrUndefined(property)) {
                this.handleCellFormat(value as WCellFormat, applyFormat);
            }
            return value;
        }
        if (property === 'leftMargin') {
            applyFormat.leftMargin = value as number;
        } else if (property === 'topMargin') {
            applyFormat.topMargin = value as number;
        } else if (property === 'rightMargin') {
            applyFormat.rightMargin = value as number;
        } else if (property === 'bottomMargin') {
            applyFormat.bottomMargin = value as number;
        } else if (property === 'preferredWidth') {
            applyFormat.preferredWidth = value as number;
            applyFormat.cellWidth = value as number;
        } else if (property === 'cellWidth') {
            applyFormat.cellWidth = value as number;
        } else if (property === 'columnSpan') {
            applyFormat.columnSpan = value as number;
        } else if (property === 'rowSpan') {
            applyFormat.rowSpan = value as number;
        } else if (property === 'preferredWidthType') {
            applyFormat.preferredWidthType = <WidthType>value;
        } else if (property === 'verticalAlignment') {
            applyFormat.verticalAlignment = <CellVerticalAlignment>value;
        }
        if (property === 'shading') {
            applyFormat.shading = <WShading>value;
        } else if (property === 'borders') {
            applyFormat.borders = <WBorders>value;
        }
        return undefined;
    }
    private handleCellFormat(cellFormat: WCellFormat, applyFormat: WCellFormat): void {
        if (!isNullOrUndefined(cellFormat) && !isNullOrUndefined(applyFormat)) {
            if (this.isBordersAndShadingDialog) {
                if (!isNullOrUndefined(cellFormat.borders)) {
                    this.applyBordersInternal(applyFormat.borders, cellFormat.borders);
                }
                if (!isNullOrUndefined(cellFormat.shading)) {
                    this.applyShading(applyFormat.shading, cellFormat.shading);
                }
                // this.layoutRow((applyFormat.ownerBase as TableCellWidget).ownerRow, this.documentHelper, false);
            } else {
                if (cellFormat.hasValue('preferredWidth') && applyFormat.preferredWidth !== cellFormat.preferredWidth) {
                    applyFormat.preferredWidth = cellFormat.preferredWidth;
                }
                if (cellFormat.hasValue('preferredWidthType') && applyFormat.preferredWidthType !== cellFormat.preferredWidthType) {
                    applyFormat.preferredWidthType = cellFormat.preferredWidthType;
                }
                if (cellFormat.hasValue('verticalAlignment') && applyFormat.verticalAlignment !== cellFormat.verticalAlignment) {
                    applyFormat.verticalAlignment = cellFormat.verticalAlignment;
                }
            }
        }
    }


    /**
     * Applies column format with specified number of columns
     * @param {number} numberOfColumns - Number of columns to apply
     * @param {boolean} equalWidth - Whether columns should have equal width
     * @returns {void}
     * @private
     */
    public applyColumnFormat(numberOfColumns: number, equalWidth: boolean): void {
        // Create and apply section format in one step
        this.applySectionFormatWithColumns(numberOfColumns, equalWidth);
    }

    /**
     * Applies left column format (wider right column)
     * @returns {void}
     * @private
     */
    public applyLeftColumnFormat(): void {
        // Apply 1:2 ratio columns
        this.applySectionFormatWithColumns(2, false, [1, 2]);
    }

    /**
     * Applies right column format (wider left column)
     * @returns {void}
     * @private
     */
    public applyRightColumnFormat(): void {
        // Apply 2:1 ratio columns
        this.applySectionFormatWithColumns(2, false, [2, 1]);
    }

    private applySectionFormatWithColumns(columnCount: number, equalWidth: boolean, ratios?: number[]): void {
        const sectionFormat: WSectionFormat = new WSectionFormat();
        const currentSectionFormat: SelectionSectionFormat = this.owner.selection.sectionFormat;

        this.copyCurrentSectionFormat(sectionFormat, currentSectionFormat);

        sectionFormat.numberOfColumns = columnCount;
        sectionFormat.equalWidth = equalWidth;

        const pageWidth: number = currentSectionFormat.pageWidth - currentSectionFormat.leftMargin - currentSectionFormat.rightMargin;
        const spacing: number = 36; // Standard spacing
        const cols: WColumnFormat[] = [];

        if (columnCount === 1) {
            // Single column case
            cols.push(this.createColumnFormat(pageWidth, 0));
        } else if (equalWidth || !ratios) {
            // Equal width columns
            const availableWidth: number = pageWidth - (spacing * (columnCount - 1));
            const columnWidth: number = availableWidth / columnCount;

            for (let i: number = 0; i < columnCount; i++) {
                cols.push(this.createColumnFormat(
                    columnWidth,
                    i < columnCount - 1 ? spacing : 0
                ));
            }
        } else {
            // Custom ratio columns
            const totalRatio: number = ratios.reduce((sum, ratio) => sum + ratio, 0);
            const availableWidth: number = pageWidth - (spacing * (columnCount - 1));
            const unitWidth: number = availableWidth / totalRatio;

            for (let i: number = 0; i < columnCount; i++) {
                cols.push(this.createColumnFormat(
                    unitWidth * ratios[i],
                    i < columnCount - 1 ? spacing : 0
                ));
            }
        }

        sectionFormat.columns = cols;
        this.onApplySectionFormat(undefined, sectionFormat);
    }

    /**
     * Creates a column format with specified width and spacing
     * @param {number} width - Column width in points
     * @param {number} space - Space after column in points
     * @returns {WColumnFormat} - The created column format
     */
    private createColumnFormat(width: number, space: number): WColumnFormat {
        const format: WColumnFormat = new WColumnFormat();
        format.width = HelperMethods.convertPointToPixel(width);
        format.space = HelperMethods.convertPointToPixel(space);
        return format;
    }

    /**
     * Copies current section format properties to a new section format
     * @param target Target section format
     * @param source Source section format
     */
    private copyCurrentSectionFormat(target: WSectionFormat, source: SelectionSectionFormat): void {
        target.bottomMargin = source.bottomMargin;
        target.topMargin = source.topMargin;
        target.leftMargin = source.leftMargin;
        target.rightMargin = source.rightMargin;
        target.pageWidth = source.pageWidth;
        target.pageHeight = source.pageHeight;
        target.differentOddAndEvenPages = source.differentOddAndEvenPages;
        target.differentFirstPage = source.differentFirstPage;
        target.headerDistance = source.headerDistance;
        target.footerDistance = source.footerDistance;
        target.breakCode = source.breakCode;
    }
    /**
     * @private
     * @returns {void}
     */
    public destroy(): void {
        if (this.tableResize) {
            this.tableResize.destroy();
            this.tableResize = undefined;
        }
        if (this.previousCharFormat) {
            this.previousCharFormat.destroy();
            this.previousCharFormat = undefined;
        }
        if (this.previousParaFormat) {
            this.previousParaFormat.destroy();
            this.previousParaFormat = undefined;
        }
        if (this.alertDialog) {
            this.alertDialog.destroy();
        }
        this.alertDialog = undefined;
        if (this.base64) {
            this.base64.destroy();
        }
        this.base64 = undefined;
        this.endParagraph = undefined;
        this.copiedData = undefined;
        this.copiedTextContent = undefined;
        this.listFormatInfo = undefined;
        this.nodes = [];
        this.removedTextNodes = [];
        this.removedBookmarkElements = [];
        this.editStartRangeCollection = [];
        this.documentHelper = undefined;
        this.editRangeID = undefined;
        this.isCellFormatApplied = undefined;
        this.removedContentControlElements = [];
    }
    /**
     * Updates the table of contents.
     *
     * @param tocField
     * @private
     * @returns {void}
     */
    public updateToc(tocField?: FieldElementBox): void {
        if (isNullOrUndefined(tocField)) {
            tocField = this.selection.getTocFieldInternal();
        }
        if (!this.documentHelper.layout.isTocField(tocField)) {
            return;
        }
        // Decode field code to get parameters
        const code: string = this.selection.getFieldCode(tocField);
        if (code.toLocaleLowerCase().indexOf('toc') !== -1) {
            this.insertTableOfContents(this.validateTocSettings(this.getTocSettings(code, tocField)));
        }

    }
    /**
     * @private
     */
    public getTocSettings(code: string, tocField: FieldElementBox): TableOfContentsSettings {
        const tocSettings: TableOfContentsSettings = {};
        tocSettings.includePageNumber = true;
        tocSettings.rightAlign = true;
        // Decode field code to get parameters

        if (code.toLowerCase() === 'toc \\mergeformat') {
            tocSettings.startLevel = 1;
            tocSettings.endLevel = 3;
        } else {
            const swtiches: string[] = code.split('\\');
            for (let i: number = 0; i < swtiches.length; i++) {
                const swtch: string = swtiches[i];
                if (swtch.length === 0) {
                    continue;
                }
                switch (swtch[0]) {
                    case 'o':
                        if (!isNullOrUndefined(swtch.match(/\d+/g))) {
                            const levels: number[] = swtch.match(/\d+/g).map(Number);
                            tocSettings.startLevel = levels[0];
                            tocSettings.endLevel = levels[1];
                        } else {
                            tocSettings.startLevel = 1;
                            tocSettings.endLevel = 9;
                        }

                        break;
                    case 'h':
                        tocSettings.includeHyperlink = true;
                        break;

                    case 'n':
                        tocSettings.includePageNumber = false;
                        break;

                    case 'p':
                        tocSettings.rightAlign = false;
                        break;

                    case 'u':
                        tocSettings.includeOutlineLevels = true;
                        break;

                    case 't':
                        this.decodeTSwitch(tocSettings, swtch);
                        break;
                }
            }
        }
        //assigns tab leader.
        const tabs: WTabStop[] = tocField.paragraph.paragraphFormat.getUpdatedTabs();
        if (tabs.length > 0) {
            tocSettings.tabLeader = tabs[tabs.length - 1].tabLeader;
        }
        if (tocSettings.rightAlign && isNullOrUndefined(tocSettings.tabLeader)) {
            tocSettings.tabLeader = 'Dot';
        }
        return tocSettings;
    }

    private decodeTSwitch(tocSettings: TableOfContentsSettings, tSwitch: string): void {
        tocSettings.levelSettings = {};
        tSwitch = tSwitch.replace('t', '');
        tSwitch = tSwitch.replace('"', '');
        tSwitch = tSwitch.replace('"', '');
        tSwitch = tSwitch.trim();
        const levels: string[] = tSwitch.split(',');
        for (let index: number = 0; index < levels.length; index++) {
            tocSettings.levelSettings[levels[index]] = parseInt(levels[index + 1], 10);
            index++;
        }
    }
    /**
     * Inserts, modifies or updates the table of contents based on given settings.
     *
     * @param {TableOfContentsSettings} tableOfContentsSettings Specify the table of content settings to be inserted.
     * @returns {void}
     */
    public insertTableOfContents(tableOfContentsSettings?: TableOfContentsSettings): void {
        if (this.selection.isPlainContentControl()) {
            return;
        }
        this.isInsertingTOC = true;
        let removedCommentStart: CommentCharacterElementBox[] = this.checkAndRemoveComments();
        this.initComplexHistory('TOC');
        if (isNullOrUndefined(tableOfContentsSettings)) {
            //Initializes with default value.
            tableOfContentsSettings = {};
            tableOfContentsSettings.startLevel = 1;
            tableOfContentsSettings.endLevel = 3;
            tableOfContentsSettings.includeHyperlink = true;
            tableOfContentsSettings.includeOutlineLevels = true;
            tableOfContentsSettings.includePageNumber = true;
            tableOfContentsSettings.rightAlign = true;
            tableOfContentsSettings.tabLeader = 'Dot';
        }
        let tocField: FieldElementBox = undefined;
        let code: string = undefined;
        if (this.selection.contextType === 'TableOfContents') {
            tocField = this.selection.getTocFieldInternal();
        }
        if (tocField instanceof FieldElementBox) {
            this.selection.start.setPositionForSelection(tocField.line, tocField, 0, this.selection.start.location);
            let offset: number = 2;
            const paragraph: ParagraphWidget = tocField.fieldEnd.paragraph;
            const nextParagraph: BlockWidget = paragraph.nextWidget as BlockWidget;
            // If TOC bodywiget is section break. We need to consider it.
            if (paragraph === paragraph.bodyWidget.lastChild || (nextParagraph instanceof ParagraphWidget && nextParagraph.isSectionBreak)) {
                offset--;
            }
            this.selection.end.setPositionForSelection(tocField.fieldEnd.line, tocField.fieldEnd, offset, this.selection.end.location);
            this.delete();
        }
        // Build TOC field code based on parameter
        code = this.constructTocFieldCode(tableOfContentsSettings);
        const isStartParagraph: boolean = this.selection.start.isAtParagraphStart;
        const blockInfo: ParagraphInfo = this.selection.getParagraphInfo(this.selection.start);
        const initialStart: string = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());

        // Build TOC fields

        const widgets: ParagraphWidget[] = this.buildToc(this.validateTocSettings(tableOfContentsSettings), code, true, isStartParagraph);
        if (widgets.length > 0) {
            const tocLastPara: ParagraphWidget = new ParagraphWidget();
            const tocLastLine: LineWidget = new LineWidget(tocLastPara);
            tocLastPara.childWidgets.push(tocLastLine);
            let index: number = 0;
            if (!isStartParagraph) {
                index = 1;
            }
            const line: LineWidget = widgets[index].childWidgets[0] as LineWidget;
            const fieldBegin: FieldElementBox = line.children[0] as FieldElementBox;
            this.appendEndField(fieldBegin, tocLastLine);
            widgets.push(tocLastPara);
            this.appendEmptyPara(widgets);
        } else {
            const localizeValue: L10n = new L10n('documenteditor', this.owner.defaultLocale);
            localizeValue.setLocale(this.owner.locale);
            DialogUtility.alert({
                title: localizeValue.getConstant('No Headings'),
                content: localizeValue.getConstant('Add Headings'),
                showCloseIcon: true,
                closeOnEscape: true,
                position: { X: 'center', Y: 'center' },
                animationSettings: { effect: 'Zoom' }
            }).enableRtl = this.owner.enableRtl;
        }

        this.setPositionForCurrentIndex(this.selection.start, initialStart);
        this.selection.end.setPositionInternal(this.selection.start);
        const bodyWidget: BodyWidget = new BodyWidget();
        bodyWidget.sectionFormat = new WSectionFormat(bodyWidget);
        bodyWidget.childWidgets = widgets;
        this.pasteContentsInternal([bodyWidget], false);
        this.updatePageRef();
        this.isInsertingTOC = false;
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistory();
            this.updateHistoryForComments(removedCommentStart);
        }
        if (widgets.length === 0) {
            this.owner.editorHistoryModule.undo();
            this.owner.editorHistoryModule.redoStack.pop();
        }
    }

    private appendEmptyPara(widgets: ParagraphWidget[]): void {
        const emptyPara: ParagraphWidget = new ParagraphWidget();
        const emptyLine: LineWidget = new LineWidget(emptyPara);
        emptyPara.childWidgets.push(emptyLine);
        widgets.push(emptyPara);
    }

    private constructTocFieldCode(tocSettings: TableOfContentsSettings): string {
        let tocFieldCode: string = 'TOC';
        //appends styles level

        if (!isNullOrUndefined(tocSettings.startLevel) && tocSettings.startLevel !== 0 && !isNullOrUndefined(tocSettings.endLevel) && tocSettings.endLevel !== 0) {
            tocFieldCode = tocFieldCode + ' \\o "' + tocSettings.startLevel + '-' + tocSettings.endLevel + '"';
        }
        if (tocSettings.includePageNumber && !tocSettings.rightAlign) {
            tocFieldCode = tocFieldCode + ' \\p " "';
        }
        if (!tocSettings.includePageNumber) {
            tocFieldCode = tocFieldCode + ' \\n';
        }
        if (tocSettings.includeHyperlink) {
            tocFieldCode = tocFieldCode + ' \\h \\z';
        }
        if (tocSettings.includeOutlineLevels) {
            tocFieldCode = tocFieldCode + ' \\u';
        }
        const tSwitch: string = this.constructTSwitch(tocSettings);
        if (tSwitch.length > 6) {
            tocFieldCode = tocFieldCode + tSwitch;
        }
        return tocFieldCode;
    }

    private constructTSwitch(tocSettings: TableOfContentsSettings): string {
        let tSwitch: string = '';
        const prefix: string = ' \\t ';
        if (!isNullOrUndefined(tocSettings.levelSettings)) {
            for (const key of Object.keys(tocSettings.levelSettings)) {
                tSwitch = tSwitch + key + ',' + tocSettings.levelSettings[key].toString() + ',';
            }
        }
        tSwitch = tSwitch.slice(0, -1);
        tSwitch = prefix + '"' + tSwitch + '"';
        return tSwitch;
    }


    private appendEndField(fieldBegin: FieldElementBox, lineWidget: LineWidget): void {
        const fieldEnd: FieldElementBox = new FieldElementBox(1);
        fieldEnd.fieldSeparator = fieldBegin.fieldSeparator;
        fieldBegin.fieldSeparator.fieldEnd = fieldEnd;
        fieldEnd.fieldBegin = fieldBegin;
        fieldEnd.fieldBegin.fieldEnd = fieldEnd;
        fieldEnd.line = lineWidget;
        //For TOC we used to append field end at last we need to map that inserted revision to field end.
        if (fieldBegin.revisionLength > 0) {
            const currentRevision: Revision = fieldBegin.getRevision(fieldBegin.revisionLength - 1);
            //currentRevision.range.push(fieldEnd);
            this.owner.trackChangesPane.updateCurrentTrackChanges(currentRevision);
            fieldEnd.addRevision(currentRevision);
        }
        lineWidget.children.push(fieldEnd);
    }
    private validateTocSettings(tocSettings: TableOfContentsSettings): TableOfContentsSettings {
        if (isNullOrUndefined(tocSettings.startLevel) || tocSettings.startLevel < 1) {
            tocSettings.startLevel = 1;
        }
        if (isNullOrUndefined(tocSettings.endLevel) || tocSettings.endLevel < tocSettings.endLevel) {
            tocSettings.endLevel = tocSettings.startLevel > 3 ? tocSettings.startLevel : 3;
        }
        if (isNullOrUndefined(tocSettings.includeHyperlink)) {
            tocSettings.includeHyperlink = false;
        }
        if (isNullOrUndefined(tocSettings.includePageNumber)) {
            tocSettings.includePageNumber = false;
        }
        if (isNullOrUndefined(tocSettings.rightAlign)) {
            tocSettings.rightAlign = false;
        }
        if (isNullOrUndefined(tocSettings.levelSettings)) {
            tocSettings.levelSettings = {};
        }
        return tocSettings;
    }
    /**
     * Builds the TOC
     *
     * @private
     * @returns {ParagraphWidget[]}
     *
     */

    public buildToc(tocSettings: TableOfContentsSettings, fieldCode: string, isFirstPara: boolean, isStartParagraph?: boolean,isNavigationPane?: boolean): ParagraphWidget[] {
        const tocDomBody: BodyWidget = this.documentHelper.pages[0].bodyWidgets[0];
        const widgets: ParagraphWidget[] = [];
        this.createHeadingLevels(tocSettings);
        if (tocSettings.includeOutlineLevels) {
            this.createOutlineLevels(tocSettings);
        }
        const sectionFormat: WSectionFormat = this.selection.start.paragraph.bodyWidget.sectionFormat;
        let widget: IWidget = tocDomBody.childWidgets[0];
        if (!isNullOrUndefined(this.owner.optionsPaneModule) && this.owner.optionsPaneModule.isHeadingTab) {
            this.owner.optionsPaneModule.isBuildHeading = true;
        }
        while (widget !== undefined) {

            if (widget instanceof ParagraphWidget && !(isNavigationPane && widget.isInsideTable) && (this.isHeadingStyle(widget) || (tocSettings.includeOutlineLevels && this.isOutlineLevelStyle(widget)))) {
                const bookmarkName: string = this.insertTocBookmark(widget, isNavigationPane);
                if (!isNullOrUndefined(bookmarkName)) {
                    this.createTOCWidgets(widget, widgets, fieldCode, bookmarkName, tocSettings, isFirstPara, isStartParagraph, sectionFormat, isNavigationPane);
                    isFirstPara = false;
                }
            }
            widget = this.selection.getNextParagraphBlock((widget as ParagraphWidget).getSplitWidgets().pop() as ParagraphWidget);
        }
        this.tocStyles = {};
        if (!isNullOrUndefined(this.owner.optionsPaneModule) && this.owner.optionsPaneModule.isHeadingTab) {
            this.owner.optionsPaneModule.isBuildHeading = false;
        }
        return widgets;
    }

    private createOutlineLevels(settings: TableOfContentsSettings): void {
        for (let i: number = settings.startLevel; i <= settings.endLevel; i++) {
            const levelStyle: string = 'Level' + i.toString();
            if (isNullOrUndefined(this.tocStyles[levelStyle])) {
                this.tocStyles[levelStyle] = i;
            }
        }
    }

    private createHeadingLevels(settings: TableOfContentsSettings): void {
        //let normalStyle: string = 'Normal';
        for (let i: number = settings.startLevel; i <= settings.endLevel; i++) {
            const headingStyle: string = 'Heading ' + i.toString();
            if (isNullOrUndefined(this.tocStyles[headingStyle])) {
                this.tocStyles[headingStyle] = i;
            }
        }
        if (!isNullOrUndefined(settings.levelSettings)) {
            for (const key of Object.keys(settings.levelSettings)) {
                this.tocStyles[key] = settings.levelSettings[key];
            }
        }
    }

    private isHeadingStyle(para: ParagraphWidget): boolean {
        const style: WStyle = (para.paragraphFormat.baseStyle as WStyle);
        if (style !== undefined) {
            return isNullOrUndefined(this.tocStyles[style.name]) ? false : true;
        }
        return false;
    }

    private isOutlineLevelStyle(para: ParagraphWidget): boolean {
        const styleName: OutlineLevel = para.paragraphFormat.outlineLevel;
        return isNullOrUndefined(this.tocStyles[styleName]) ? false : true;
    }

    private createTocFieldElement(lineWidget: LineWidget, fieldCode: string, isSkipRevision?: boolean): FieldElementBox {
        //begin
        const fieldBegin: FieldElementBox = new FieldElementBox(0);
        fieldBegin.hasFieldEnd = true;
        fieldBegin.line = lineWidget;
        lineWidget.children.push(fieldBegin);
        const currentRevision: Revision = undefined;
        //format toc
        const textElement: TextElementBox = new TextElementBox();
        textElement.text = fieldCode;
        textElement.line = lineWidget;
        lineWidget.children.push(textElement);
        //field separator
        const fieldSeparator: FieldElementBox = new FieldElementBox(2);
        fieldSeparator.fieldBegin = fieldBegin;
        fieldSeparator.fieldBegin.fieldSeparator = fieldSeparator;
        fieldSeparator.line = lineWidget;
        lineWidget.children.push(fieldSeparator);
        // If revision enabled.
        return fieldBegin;
    }



    private createTOCWidgets(widget: ParagraphWidget, widgets: ParagraphWidget[], fieldCode: string, bookmarkName: string, tocSettings: TableOfContentsSettings, isFirstPara?: boolean, isStartParagraph?: boolean, sectionFormat?: WSectionFormat,isNavigationPane?: boolean): void {
        let fieldBegin: FieldElementBox = undefined;
        let tocPara: ParagraphWidget = undefined;
        let tocLine: LineWidget = undefined;
        let emptyParaAppended: boolean = false;

        if (widgets.length === 1 && (widgets[0].childWidgets[0] as LineWidget).children.length === 3 && !isNullOrUndefined(isFirstPara) && !isFirstPara) {
            tocLine = widgets[0].childWidgets[0] as LineWidget;
        } else {
            tocPara = new ParagraphWidget();
            let styleName: string = undefined;
            //Adds toc syles into paragraph
            const headingStyleName: string = widget.paragraphFormat.baseStyle.name;
            if (tocSettings.includeOutlineLevels && isNullOrUndefined(this.tocStyles[headingStyleName])) {
                styleName = widget.paragraphFormat.outlineLevel;
            } else {
                styleName = headingStyleName;
            }
            const tocStyleName: string = 'TOC ' + this.tocStyles[styleName];
            const headingPaneStyleName = 'Heading '+this.tocStyles[styleName];
            let paraStyle : Object = undefined;
            if(isNavigationPane)
            {
                 paraStyle = this.documentHelper.styles.findByName(headingPaneStyleName, 'Paragraph');
                if (isNullOrUndefined(paraStyle)) {

                    this.documentHelper.owner.parser.parseStyle(JSON.parse(this.getCompleteStyles()), JSON.parse(this.documentHelper.preDefinedStyles.get(headingPaneStyleName)), this.documentHelper.styles, true);
                    paraStyle = this.documentHelper.styles.findByName(headingPaneStyleName, 'Paragraph');
                }
            }
            else{
                paraStyle = this.documentHelper.styles.findByName(tocStyleName, 'Paragraph');
                if (isNullOrUndefined(paraStyle)) {

                    this.documentHelper.owner.parser.parseStyle(JSON.parse(this.getCompleteStyles()), JSON.parse(this.documentHelper.preDefinedStyles.get(tocStyleName)), this.documentHelper.styles, true);
                    paraStyle = this.documentHelper.styles.findByName(tocStyleName, 'Paragraph');
                }
            }
            tocPara.paragraphFormat.applyStyle(paraStyle as WParagraphStyle);
            //Creates right tab for page number.
            if (tocSettings.rightAlign && tocSettings.includePageNumber) {
                const tabStop: WTabStop = new WTabStop();
                tabStop.position = sectionFormat.pageWidth - (sectionFormat.leftMargin + sectionFormat.rightMargin);
                tabStop.tabLeader = tocSettings.tabLeader;
                tabStop.deletePosition = 0;
                tabStop.tabJustification = 'Right';
                tocPara.paragraphFormat.tabs.push(tabStop);
            }

            tocLine = new LineWidget(tocPara);
            tocPara.childWidgets.push(tocLine);
        }
        //creates toc field element if it is insert
        if ((isFirstPara !== undefined) && isFirstPara) {
            if (!isNullOrUndefined(isStartParagraph) && !isStartParagraph) {
                this.appendEmptyPara(widgets);
                emptyParaAppended = true;
            }
            this.createTocFieldElement(tocLine, fieldCode);
        }
        let text: string = '';
        let isFieldCode: boolean = false;
        let paragraph: ParagraphWidget = widget;
        while (paragraph instanceof ParagraphWidget) {
            for (let lineIndex: number = 0; lineIndex < paragraph.childWidgets.length; lineIndex++) {
                const lineWidget: LineWidget = paragraph.childWidgets[lineIndex] as LineWidget;
                for (let elementIndex: number = 0; elementIndex < lineWidget.children.length; elementIndex++) {
                    const element: ElementBox = lineWidget.children[elementIndex];
                    if (element.isPageBreak || element.isColumnBreak) {
                        continue;
                    }
                    if ((element instanceof FieldElementBox) || (element instanceof BookmarkElementBox) || isFieldCode) {
                        if (element instanceof FieldElementBox) {
                            if (element.fieldType === 0) {
                                isFieldCode = true;
                            } else if (element.fieldType === 2) {
                                isFieldCode = false;
                            }
                        }
                    } else if (element instanceof TextElementBox || element instanceof ListTextElementBox) {
                        let temp: string = element.text;
                        const tabChar: string = '\t';
                        if (temp.indexOf(tabChar) !== -1) {
                            temp = temp.replace(new RegExp(tabChar, 'g'), ' ');
                        }
                        text = text + temp;
                    }

                }
            }
            paragraph = paragraph.nextSplitWidget as ParagraphWidget;
        }
        if (text !== '') {
            // inserts hyperlink
            if (tocSettings.includeHyperlink && (bookmarkName !== undefined)) {
                fieldBegin = this.insertTocHyperlink(tocLine, bookmarkName, text, widget);
            } else {
                const span: TextElementBox = new TextElementBox();
                span.text = text;
                span.line = tocLine;
                tocLine.children.push(span);
            }
            //inserts page number
            if (tocSettings.includePageNumber && (bookmarkName !== undefined)) {
                if (tocSettings.rightAlign) {
                    const tabText: TabElementBox = new TabElementBox();
                    tabText.text = '\t';
                    tabText.line = tocLine;
                    tocLine.children.push(tabText);
                }
                const pageField: FieldElementBox = this.insertTocPageNumber(bookmarkName, tocLine, tocSettings.rightAlign, widget);
                this.appendEndField(pageField, tocLine);
            }
            if (tocSettings.includeHyperlink && fieldBegin !== undefined) {
                this.appendEndField(fieldBegin, tocLine);
            }
        }
        if (!isNullOrUndefined(tocPara) && (text !== '' || isFirstPara)) {
            widgets.push(tocPara);
        }
    }

    private insertTocHyperlink(lineWidget: LineWidget, bookmarkName: string, text: string, widget?: ParagraphWidget): FieldElementBox {
        const fieldCode: string = ' HYPERLINK \\l \"' + bookmarkName + '\" ';
        const fieldBegin: FieldElementBox = this.createTocFieldElement(lineWidget, fieldCode, true);

        //text element.
        const span: TextElementBox = new TextElementBox();
        span.text = text;

        // retrieve the TOC character format
        let styleName = widget.paragraphFormat.baseStyle.name;
        let curBaseSytle: Object = this.documentHelper.styles.findByName(styleName, 'Paragraph');
        if ((curBaseSytle as WParagraphStyle).characterFormat.isEqualTocFormat(widget.characterFormat)) {
            let noramlStyle: Object = this.documentHelper.styles.findByName('Normal', 'Paragraph');
            span.characterFormat.copyTocFormat((noramlStyle as WParagraphStyle).characterFormat);
        } else {
            span.characterFormat.copyTocFormat(widget.characterFormat);
        }
        span.line = lineWidget;
        lineWidget.children.push(span);
        return fieldBegin;
    }

    private getPageNumber(widget: ParagraphWidget): number {
        let pageNumber: number;
        if (widget.bodyWidget.sectionFormat.restartPageNumbering) {
            pageNumber = widget.bodyWidget.page.currentPageNum;
        }
        else {
            pageNumber = this.documentHelper.pages.indexOf(widget.bodyWidget.page) + 1;
        }
        return pageNumber;
    }

    private insertTocPageNumber(bookMarkname: string, lineWidget: LineWidget, isRightAlign: boolean, widget: ParagraphWidget): FieldElementBox {
        const fieldCode: string = ' PAGEREF' + bookMarkname + ' \\h ';
        const fieldBegin: FieldElementBox = this.createTocFieldElement(lineWidget, fieldCode, true);
        let text: string = (this.getPageNumber(widget)).toString();
        const span: FieldTextElementBox = new FieldTextElementBox();
        span.fieldBegin = fieldBegin;
        if (!isRightAlign) {
            text = ' ' + text;
        }
        span.text = text;
        span.line = lineWidget;
        lineWidget.children.push(span);
        this.pageRefFields[bookMarkname] = span;
        return fieldBegin;
    }

    private updatePageRef(): void {
        for (const key of Object.keys(this.pageRefFields)) {
            if (this.documentHelper.bookmarks.containsKey(key)) {
                const bookmark: BookmarkElementBox = this.documentHelper.bookmarks.get(key);
                let pageRef: string = (this.getPageNumber(bookmark.paragraph)).toString();
                const span: FieldTextElementBox = this.pageRefFields[key];
                if (pageRef !== span.text) {
                    span.isWidthUpdated = false;
                    span.text = pageRef;
                    const paragraph: ParagraphWidget = span.paragraph;
                    const lineIndex: number = paragraph.childWidgets.indexOf(span.line);
                    const elementIndex: number = span.line.children.indexOf(span);
                    if(!isNullOrUndefined(paragraph.containerWidget)) {
                        this.documentHelper.layout.reLayoutParagraph(paragraph, lineIndex, elementIndex);
                    }
                }
            }
        }
    }
    /**
     * Inserts toc bookmark.
     *
     * @param widget
     * @returns {string}
     */
    private insertTocBookmark(widget: ParagraphWidget, isNavigationPane?: boolean): string {
        let bookmarkName: string = undefined;
        const lineLength: number = widget.childWidgets.length;
        if (lineLength > 0) {
            const splitParagraph: ParagraphWidget[] = widget.getSplitWidgets() as ParagraphWidget[];
            const firstParagraph: ParagraphWidget = splitParagraph[0];
            const lastParagraph: ParagraphWidget = splitParagraph.pop();
            const startLine: LineWidget = firstParagraph.childWidgets[0] as LineWidget;
            const endLine: LineWidget = lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1] as LineWidget;
            if ((startLine !== undefined) && (endLine !== undefined)) {
                let startElement: ElementBox = startLine.children[0];
                if (startElement instanceof ListTextElementBox || startElement instanceof CommentCharacterElementBox) {
                    do {
                        startElement = startElement.nextNode;
                    } while (startElement instanceof ListTextElementBox || startElement instanceof CommentCharacterElementBox);
                }
                //Returns the bookmark if already present for paragraph.

                if (!isNullOrUndefined(startElement) && startElement instanceof BookmarkElementBox && (startElement as BookmarkElementBox).bookmarkType === 0 && ((startElement as BookmarkElementBox).name.toLowerCase().match('^_toc'))) {
                    return (startElement as BookmarkElementBox).name;
                }
                let endElement: ElementBox = endLine.children[endLine.children.length - 1];
                // According to MS word if paragraph contains only page break then bookmark will not be inserted.
                if (endElement && endElement.isPageBreak) {
                    const lastElement: ElementBox = endElement.previousNode;
                    if (isNullOrUndefined(lastElement)) {
                        return bookmarkName;
                    } else {
                        endElement = lastElement;
                    }
                }
                if ((startElement !== undefined) && (endElement !== undefined) && !this.isRemoteAction) {
                    this.selection.start.setPositionForSelection(startLine, startElement, 0, this.selection.start.location);
                    this.selection.end.setPositionForSelection(endLine, endElement, endElement.length, this.selection.end.location);
                    bookmarkName = this.generateBookmarkName();
                    this.insertBookmark(bookmarkName, isNavigationPane);
                }
            }
        }
        return bookmarkName;
    }

    private generateBookmarkName(): string {
        let bookmarkName: string = '';
        do {
            this.tocBookmarkId++;
            let count: number = 10 - this.tocBookmarkId.toString().length;
            let formatString: string = '';
            while (count - 1 > 0) {
                formatString = '0' + formatString;
                count--;
            }
            bookmarkName = '_Toc' + formatString + this.tocBookmarkId;
        } while (this.documentHelper.bookmarks.containsKey(bookmarkName));
        return bookmarkName;
    }

    /**
     * Change cell content alignment
     *
     * @param verticalAlignment
     * @param textAlignment
     * @param verticalAlignment
     * @param textAlignment
     * @private
     * @returns {void}
     */
    public onCellContentAlignment(verticalAlignment: CellVerticalAlignment, textAlignment: TextAlignment): void {
        this.owner.isShiftingEnabled = true;
        const selection: Selection = this.owner.selectionModule;
        if (selection.isEmpty && selection.start.paragraph.isInsideTable) {
            if (this.owner.editorHistoryModule) {
                this.owner.editorHistoryModule.initComplexHistory(selection, 'MultiSelection');
            }
            //Selecting the table cell to update the all the paragraph format.
            selection.selectTableCell();
            this.initHistory('CellContentVerticalAlignment');
            const cellFormat: WCellFormat = selection.start.paragraph.associatedCell.cellFormat;
            this.applyCellPropertyValue(selection, 'verticalAlignment', verticalAlignment, cellFormat);
            this.reLayout(selection, false);
            this.initHistory('TextAlignment');
            this.updateParagraphFormat('textAlignment', textAlignment, false);
            this.reLayout(this.owner.selectionModule, false);
            if (this.owner.editorHistoryModule) {
                this.owner.editorHistoryModule.updateComplexHistory();
            }
        } else {
            if (this.owner.editorHistoryModule) {
                this.owner.editorHistoryModule.initComplexHistory(selection, 'MultiSelection');
            }

            if (!isNullOrUndefined(selection.getTable(selection.start, selection.end))) {
                //Table cell vertical alignment.
                this.updateSelectionTableFormat(selection, 'CellContentVerticalAlignment', verticalAlignment);
                this.reLayout(this.owner.selectionModule, false);
                this.initHistory('TextAlignment');
                //Paragraph text alignment.
                this.updateSelectionParagraphFormatting('textAlignment', textAlignment, false);
                this.reLayout(selection, false);
            }
            if (this.owner.editorHistoryModule) {
                this.owner.editorHistoryModule.updateComplexHistory();
            }
        }
    }

    //Restrict editing implementation starts
    /**
     * @param user
     * @private
     * @returns {void}
     */
    public insertEditRangeElement(user: string): void {
        if (this.documentHelper.isDocumentProtected || this.documentHelper.selection.isEmpty) {
            return;
        }
        this.initComplexHistory('RestrictEditing');
        this.selection.skipEditRangeRetrieval = true;
        const selection: Selection = this.documentHelper.selection;
        let startPos: TextPosition = this.selection.start;
        let endPos: TextPosition = this.selection.end;
        if (!this.selection.isForward) {
            startPos = this.selection.end;
            endPos = this.selection.start;
        }
        if (selection.start.paragraph.isInsideTable && selection.end.paragraph.isInsideTable
            && selection.start.paragraph.associatedCell.ownerTable.contains(selection.end.paragraph.associatedCell)) {
            const startCell: TableCellWidget = this.getOwnerCell(this.selection.isForward);
            const endCell: TableCellWidget = this.getOwnerCell(!this.selection.isForward);
            if (startCell.rowIndex === endCell.rowIndex) {
                const startIndex: number = startCell.ownerRow.childWidgets.indexOf(startCell);
                const endIndex: number = startCell.ownerRow.childWidgets.indexOf(endCell);
                const startElement: ElementBox[] = [];
                const endElement: ElementBox[] = [];

                for (let i: number = startIndex; i <= endIndex; i++) {
                    const editStart: EditRangeStartElementBox = this.addEditElement(user);
                    if (i == startIndex) {
                        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
                            this.editorHistory.currentHistoryInfo.editRangeStart = editStart;
                        }
                    }
                    editStart.columnFirst = i;
                    editStart.columnLast = i;
                    editStart.line = selection.start.currentWidget;
                    const editEnd: EditRangeEndElementBox = editStart.editRangeEnd;
                    editEnd.line = selection.end.currentWidget;
                    startElement.push(editStart);
                    endElement.push(editEnd);
                    this.insertElements(undefined, [editStart]);
                }
                //this.insertElements(endElement, startElement);
                const lastLine: LineWidget = this.selection.getLastParagraph(endCell).lastChild as LineWidget;
                for (let l: number = 0; l < endElement.length; l++) {
                    endElement[l].line = lastLine;
                    if (l == 0) {
                        this.selection.start.setPositionParagraph(lastLine, this.selection.getLineLength(lastLine));
                        this.selection.end.setPositionParagraph(lastLine, this.selection.getLineLength(lastLine));
                    }
                    this.insertElements(undefined, [endElement[l]]);
                }
                if (this.editorHistory) {
                    this.editorHistory.updateComplexHistoryInternal();
                }
                let offset: number = startElement[0].line.getOffset(startElement[0], 1);
                this.selection.start.setPositionParagraph(startElement[0].line, offset);
                offset = endElement[0].line.getOffset(endElement[0], 1);
                this.selection.end.setPositionParagraph(endElement[0].line, offset);
                this.selection.fireSelectionChanged(true);
                this.fireContentChange();
            } else {
                this.insertEditRangeInsideTable(startCell, endCell, user);
                if (this.editorHistory) {
                    this.editorHistory.updateComplexHistoryInternal();
                }
                const startLine: LineWidget = this.documentHelper.getFirstParagraphInCell(startCell).childWidgets[0] as LineWidget;
                const endLine: LineWidget = this.selection.getLastParagraph(endCell).childWidgets[0] as LineWidget;
                let offset: number = startLine.getOffset(startLine.children[0], 1);
                this.selection.start.setPositionParagraph(startLine, offset);
                offset = endLine.getOffset(endLine.children[0], 1);
                this.selection.end.setPositionParagraph(endLine, offset);
                this.selection.fireSelectionChanged(true);
                this.fireContentChange();

            }
        } else {
            this.addRestrictEditingForSelectedArea(user);
        }
        this.selection.skipEditRangeRetrieval = false;

    }

    private insertEditRangeInsideTable(startCell: TableCellWidget, endCell: TableCellWidget, user: string): void {
        let table: TableWidget = startCell.ownerTable.combineWidget(this.owner.viewer) as TableWidget;
        const count: number = table.childWidgets.indexOf(endCell.ownerRow);
        const rowStartIndex: number = table.childWidgets.indexOf(startCell.ownerRow);
        let startLeft: number = this.selection.getCellLeft(startCell.ownerRow, startCell);
        let endLeft: number = startLeft + startCell.cellFormat.cellWidth;
        const endCellLeft: number = this.selection.getCellLeft(endCell.ownerRow, endCell);
        const endCellRight: number = endCellLeft + endCell.cellFormat.cellWidth;
        const cellInfo: CellInfo = this.updateSelectedCellsInTable(startLeft, endLeft, endCellLeft, endCellRight);
        startLeft = cellInfo.start;
        endLeft = cellInfo.end;
        let endElement: EditRangeEndElementBox[] = [];
        for (let i: number = rowStartIndex; i <= count; i++) {
            table = startCell.ownerTable.combineWidget(this.owner.viewer) as TableWidget;
            let row: TableRowWidget = table.childWidgets[i] as TableRowWidget;
            let cellSelectionStartIndex: number = -1;
            let cellSelectionEndIndex: number = -1;
            for (let j: number = 0; j < row.childWidgets.length; j++) {
                const cell: TableCellWidget = row.childWidgets[j] as TableCellWidget;
                const cellStart: number = this.selection.getCellLeft(row, cell);
                if (this.checkCellWithInSelection(startLeft, endLeft, cellStart)) {
                    if (cellSelectionStartIndex === -1) {
                        cellSelectionStartIndex = j;
                    }
                    cellSelectionEndIndex = j;
                }
            }
            const newEndElement: EditRangeEndElementBox[] = [];
            for (let z: number = cellSelectionStartIndex; z <= cellSelectionEndIndex; z++) {
                let startCell: TableCellWidget;
                let startParagraph: ParagraphWidget;
                let startLine: LineWidget;
                if (z >= cellSelectionStartIndex && z<= cellSelectionEndIndex) {
                    startCell = row.childWidgets[cellSelectionStartIndex] as TableCellWidget;
                    startParagraph = this.documentHelper.getFirstParagraphInCell(startCell);
                    startLine = startParagraph.childWidgets[0] as LineWidget;
                }
                const editStart: EditRangeStartElementBox = this.addEditElement(user);
                if (z === cellSelectionStartIndex) {
                    if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
                        this.editorHistory.currentHistoryInfo.editRangeStart = editStart;
                    }
                    this.selection.start.setPositionParagraph(startLine, this.selection.getStartOffset(startParagraph));
                    this.selection.end.setPositionParagraph(startLine, this.selection.getStartOffset(startParagraph));
                }
                editStart.columnFirst = z;
                editStart.columnLast = z;
                editStart.line = startLine;
                this.insertElements(undefined, [editStart]);
                const editEnd: EditRangeEndElementBox = editStart.editRangeEnd;
                newEndElement.push(editEnd);
                if (endElement.length > 0 && z === cellSelectionEndIndex) {
                    for (let l: number = 0; l < endElement.length; l++) {
                        endElement[l].line = editStart.line;
                        this.insertElements(undefined, [endElement[l]]);
                    }
                    endElement = [];
                }
            }
            endElement = newEndElement;
            if (i === count && endElement.length > 0) {
                const cellWidget: TableCellWidget = row.childWidgets[cellSelectionEndIndex] as TableCellWidget;
                const lastLine: LineWidget = this.selection.getLastParagraph(cellWidget).lastChild as LineWidget;
                for (let l: number = 0; l < endElement.length; l++) {
                    endElement[l].line = lastLine;
                    if (l == 0) {
                        this.selection.start.setPositionParagraph(lastLine, this.selection.getLineLength(lastLine));
                        this.selection.end.setPositionParagraph(lastLine, this.selection.getLineLength(lastLine));
                    }
                    this.insertElements(undefined, [endElement[l]]);
                }
            }
        }
    }

    private addRestrictEditingForSelectedArea(user: string): void {
        const editStart: EditRangeStartElementBox = this.addEditElement(user);
        const editEnd: EditRangeEndElementBox = editStart.editRangeEnd;
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.editorHistory.currentHistoryInfo.editRangeStart = editStart;
        }
        this.owner.isShiftingEnabled = true;
        this.insertElements([editEnd], [editStart]);
        editStart.editRangeEnd.line = editEnd.line;
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistoryInternal();
        }
        let offset: number = editStart.line.getOffset(editStart, 1);
        this.selection.start.setPositionParagraph(editStart.line, offset);
        offset = editEnd.line.getOffset(editEnd, 1);
        this.selection.end.setPositionParagraph(editEnd.line, offset);
        let block: BlockWidget = this.documentHelper.blockToShift;
        if (!isNullOrUndefined(block) && this.viewer instanceof PageLayoutViewer && block.bodyWidget.sectionFormat.columns.length > 1) {
            let lastbody: BodyWidget = this.documentHelper.layout.getBodyWidget(block.bodyWidget, false);
            if ((!isNullOrUndefined(lastbody.nextRenderedWidget) && (lastbody.nextRenderedWidget as BodyWidget).sectionFormat.breakCode === 'NoBreak' && lastbody.page === (lastbody.nextRenderedWidget as BodyWidget).page)) {
                this.reLayout(this.selection);
            }
        }
        this.owner.isShiftingEnabled = false;
        this.selection.fireSelectionChanged(true);
        this.fireContentChange();

    }
    /**
     * @param user
     * @private
     * @returns {void}
     */
    public addEditElement(user: string, id?: number): EditRangeStartElementBox {
        const editStart: EditRangeStartElementBox = new EditRangeStartElementBox();
        if (user.toLocaleLowerCase() === 'everyone') {
            editStart.group = user;
        } else {
            editStart.user = user;
        }
        const editEnd: EditRangeEndElementBox = new EditRangeEndElementBox();
        editEnd.editRangeStart = editStart;
        editStart.editRangeEnd = editEnd;
        if(id) {
            editStart.editRangeId = id;
            editEnd.editRangeId = id;
        } else {
            var editRangeId: number = this.getEditRangeID(9);
            editStart.editRangeId = editRangeId;
            editEnd.editRangeId = editRangeId;
        }
        this.editStartRangeCollection.push(editStart);
        this.addEditCollectionToDocument();
        this.editStartRangeCollection = [];
        return editStart;
    }
    /**
     * @param numDigits
     * @private
     * @returns {number}
     */
    private getEditRangeID(numDigits: number): number {
        var min = Math.pow(10, numDigits - 1);
        var max = Math.pow(10, numDigits) - 1;
        
        var num = Math.floor(Math.random() * (max - min + 1)) + min;
        
        if ((this.editRangeID as any).includes(num)) {
          // Number is not unique, generate a new one recursively
          return this.getEditRangeID(numDigits);
        }
        
        this.editRangeID.push(num);
        return num;
    }
    /**
     * @param protectionType
     * @private
     * @returns {void}
     */
    public protect(protectionType: ProtectionType): void {
        this.documentHelper.isDocumentProtected = true;
        this.documentHelper.protectionType = protectionType;
        this.selection.highlightEditRegion();
        if (this.editorHistory) {
            this.editorHistory.destroy();
        }
    }

    private addEditCollectionToDocument(): void {
        for (let i: number = 0; i < this.editStartRangeCollection.length; i++) {
            const editStart: EditRangeStartElementBox = this.editStartRangeCollection[i];
            const user: string = editStart.user === '' ? editStart.group : editStart.user;
            if (this.documentHelper.editRanges.length > 0 && this.documentHelper.editRanges.containsKey(user)) {
                this.documentHelper.editRanges.get(user).push(editStart);
            } else {
                const collection: EditRangeStartElementBox[] = [];
                collection.push(editStart);
                this.documentHelper.editRanges.add(user, collection);
            }
        }
        this.selection.updateEditRangeCollection();
    }
    /**
     * @param editStart
     * @param user
     * @private
     * @returns {void}
     */
    public updateRangeCollection(editStart: EditRangeStartElementBox, user: string): void {
        if (this.documentHelper.editRanges.length > 0 && this.documentHelper.editRanges.containsKey(user)) {
            if (this.documentHelper.editRanges.get(user).indexOf(editStart) === -1) {
                this.documentHelper.editRanges.get(user).push(editStart);
            }
        } else {
            const collection: EditRangeStartElementBox[] = [];
            collection.push(editStart);
            this.documentHelper.editRanges.add(user, collection);
        }
    }
    /**
     * @param user
     * @private
     * @returns {void}
     */
    public removeUserRestrictions(user: string, editRegionStart?: EditRangeStartElementBox): void {
        if (!this.selection.checkSelectionIsAtEditRegion() && !this.selection.isEditRangeCellSelected()) {
            return;
        }
        this.selection.skipEditRangeRetrieval = true;
        let editStart: EditRangeStartElementBox = this.selection.getEditRangeStartElement() as EditRangeStartElementBox;
        editStart = editRegionStart ? editRegionStart : editStart;
        this.selection.skipEditRangeRetrieval = true;
        var start = this.selection.start;
        var end = this.selection.end;
        if (!this.selection.isForward) {
            start = this.selection.end;
            end = this.selection.start;
        }
        if (!this.selection.isEmpty && start.paragraph.isInsideTable && end.paragraph.isInsideTable && this.selection.isCellSelected(start.paragraph.associatedCell, start, end)) {
            var startCell = start.paragraph.associatedCell;
            var table = startCell.ownerTable.combineWidget(this.owner.viewer) as TableWidget;
            var endCell = end.paragraph.associatedCell;
            if (table.contains(endCell)){
                this.removeEditRangeElementsOnTable(user);
            }
        }
        else {
            this.removeEditRangeElements(editStart, user);
        }
        this.fireContentChange();
        this.selection.skipEditRangeRetrieval = false;
    }
    /**
    * Removes the editing permission range at the current selection position that matches the specified username.
    *
    * If `user` is provided, removes the editing region specific to that user.
    * If `user` is not provided (null or undefined), it defaults to 'Everyone'.
    *
    * @param {string} [user] - The name of the user whose editing region should be removed.
    * @returns {void}
    */
    public removeEditingRegion(user?: string): void {
        if (!this.documentHelper.isDocumentProtected) {
            user = user && user !== '' ? user : 'Everyone';
            let editStart: EditRangeStartElementBox[] = this.selection.getEditRangeStartElement(false, true) as EditRangeStartElementBox[];
            for (let i: number = 0; i < editStart.length; i++) {
                const currentUser: string = editStart[i].user === '' ? editStart[i].group : editStart[i].user;
                if (user === currentUser) {
                    this.removeUserRestrictions(currentUser, editStart[i]);
                }
            }
        }
    }
    private removeEditRangeElements(editStart: EditRangeStartElementBox, user: string): void {
        this.initHistory('RemoveEditRange');
        if (this.editorHistory) {
            this.editorHistory.currentBaseHistoryInfo.markerData.push(this.getMarkerData(editStart));
            this.editorHistory.currentBaseHistoryInfo.setEditRangeInfo(editStart);
            this.editorHistory.updateHistory();
        }
        if (editStart.user === user || editStart.group === user) {
            this.removeUserRestrictionsInternal(editStart, user);
        }
        this.selection.updateEditRangeCollection();
    }

    private removeEditRangeElementsOnTable(currentUser: string):void {
        var selectedWidgets = this.selection.selectedWidgets.keys;
        if (selectedWidgets) {
            this.initComplexHistory('RemoveEditRange');
            for (var i=0; i< selectedWidgets.length; i++) {
                if (selectedWidgets[i] instanceof TableCellWidget) {
                    let cell: TableCellWidget = selectedWidgets[i] as TableCellWidget;
                    let row: TableRowWidget = cell.containerWidget as TableRowWidget;
                    var editRangeElements = row.editRangeID.values;
                    if (editRangeElements.length > 0) {
                        let editStart: EditRangeStartElementBox;
                        for (var element of editRangeElements) {
                            if ((element as EditRangeStartElementBox).columnFirst == cell.index && (element as EditRangeStartElementBox).columnLast == cell.index) {
                                editStart = element as EditRangeStartElementBox;
                            }
                        }
                        if (editStart) {
                            let editRangeEnd: EditRangeEndElementBox = editStart.editRangeEnd;
                            this.selection.start.setPositionParagraph(editStart.line, editStart.line.getOffset(editStart, editStart.length));
                            this.selection.end.setPositionParagraph(editRangeEnd.line, editRangeEnd.line.getOffset(editRangeEnd, editRangeEnd.length) - 1);
                            if (editStart.user === currentUser || editStart.group === currentUser) {
                            this.removeEditRangeElements(editStart, currentUser);
                            }
                        }
                    }
                }
                    
            }
            if (this.editorHistory) {
                this.editorHistory.updateComplexHistoryInternal();
            }
        }
    }
    /**
     * @param editStart
     * @param currentUser
     * @private
     * @returns {void}
     */
    public removeUserRestrictionsInternal(editStart: EditRangeStartElementBox, currentUser?: string, notRemoveElement?: boolean): void {
        let user: string = currentUser;
        if (isNullOrUndefined(currentUser)) {
            user = editStart.user === '' ? editStart.group : editStart.user;
        }
        const index: number = this.documentHelper.editRanges.get(user).indexOf(editStart);
        this.documentHelper.editRanges.get(user).splice(index, 1);
        if (this.documentHelper.editRanges.get(user).length === 0) {
            this.documentHelper.editRanges.remove(user);
        }
        if (editStart.columnFirst != -1 && editStart.columnLast != -1) {
            this.removeEditRangeFromCollection(editStart);
        }
        editStart.removeEditRangeMark();
        if (!notRemoveElement) {
            editStart.editRangeEnd.line.children.splice(editStart.editRangeEnd.indexInOwner, 1);
            editStart.line.children.splice(editStart.indexInOwner, 1);
        }
    }
    private removeEditRangeFromCollection(editStart: EditRangeStartElementBox):void {
        let row = editStart.paragraph.associatedCell.ownerRow;
        if (row.editRangeID.containsKey(editStart.editRangeId)) {
            let cell = row.getCellUsingColumnIndex(row.rowIndex, editStart.columnFirst);
            if (!isNullOrUndefined(cell)) {
                if (cell.isRenderEditRangeStart && cell.isRenderEditRangeEnd ) {
                    cell.isRenderEditRangeEnd = false;
                    cell.isRenderEditRangeStart = false;
                    row.editRangeID.remove(editStart.editRangeId);
                }
            }
        } else {
            let table = editStart.paragraph.associatedCell.ownerTable;
            for (let i = row.rowIndex - 1; i >= 0; i--) {
                let previousRow: TableRowWidget = table.childWidgets[i] as TableRowWidget;
                if (previousRow.editRangeID.containsKey(editStart.editRangeId)) {
                    let previousCell = previousRow.getCellUsingColumnIndex(previousRow.rowIndex, editStart.columnFirst);
                    if (!isNullOrUndefined(previousCell)) {
                        if (previousCell.isRenderEditRangeStart && previousCell.isRenderEditRangeEnd) {
                            previousCell.isRenderEditRangeEnd = false;
                            previousCell.isRenderEditRangeStart = false;
                            previousRow.editRangeID.remove(editStart.editRangeId);
                            break;
                        }
                    }
                }
            }
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public removeAllEditRestrictions(): void {
        this.selection.skipEditRangeRetrieval = true;
        const startPosition: TextPosition = this.selection.start;
        const endPosition: TextPosition = this.selection.end;
        let editStart: EditRangeStartElementBox[] = [];
        const keys: string[] = this.documentHelper.editRanges.keys;
        for (let j: number = 0; j < keys.length; j++) {
            editStart = this.documentHelper.editRanges.get(keys[j]);
            for (let i: number = 0; i < editStart.length; i++) {
                editStart[i].editRangeEnd.line.children.splice(editStart[i].editRangeEnd.indexInOwner, 1);
                editStart[i].line.children.splice(editStart[i].indexInOwner, 1);
            }
        }
        this.documentHelper.editRanges.clear();
        this.selection.updateEditRangeCollection();
        this.selection.start.setPositionInternal(startPosition);
        this.selection.end.setPositionInternal(endPosition);
        this.selection.editRegionHighlighters.clear();
        this.owner.viewer.updateScrollBars();
        this.selection.fireSelectionChanged(false);
        this.selection.skipEditRangeRetrieval = false;
    }
    /**
     * Inserts the specified form field at the current selection.
     *
     * @param {FormFieldType} type Specify the Form field type to insert.
     * @returns {void}
     */
    public insertFormField(type: FormFieldType): void {
        if (isNullOrUndefined(this.selection.start) || this.owner.enableHeaderAndFooter || this.selection.isPlainContentControl()) {
            return;
        }
        this.initHistory('InsertHyperlink');
        let isRemoved: boolean = true;
        if (!this.selection.isEmpty) {
            isRemoved = this.removeSelectedContents(this.selection);
        }
        if (isRemoved) {
            this.insertFormFieldInternal(type);
        }
    }

    private insertFormFieldInternal(type: FormFieldType): void {
        this.updateInsertPosition();
        const element: ElementBox[] = [];
        const temp: WCharacterFormat = this.getCharacterFormat(this.selection);
        const format: WCharacterFormat = new WCharacterFormat(undefined);
        format.copyFormat(temp);
        const fieldBegin: FieldElementBox = new FieldElementBox(0);
        fieldBegin.formFieldData = this.getFormFieldData(type);
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            this.editorHistory.currentBaseHistoryInfo.formFieldType = type;
            this.editorHistory.currentBaseHistoryInfo.fieldBegin = fieldBegin;
        }
        fieldBegin.characterFormat.copyFormat(format);
        element.push(fieldBegin);
        const bookmark: BookmarkElementBox = new BookmarkElementBox(0);
        bookmark.characterFormat.copyFormat(format);
        fieldBegin.formFieldData.name = this.getBookmarkName(type, 'Insert', this.formFieldCounter);
        bookmark.name = fieldBegin.formFieldData.name;
        element.push(bookmark);
        const span: TextElementBox = new TextElementBox();
        span.text = this.getFormFieldCode(type);
        element.push(span);
        const fieldSeparator: FieldElementBox = new FieldElementBox(2);
        element.push(fieldSeparator);
        const result: TextElementBox = new TextElementBox();
        result.characterFormat.copyFormat(format);
        if (type === 'CheckBox') {
            result.text = String.fromCharCode(9744);
            this.documentHelper.layout.setCheckBoxFontSize(fieldBegin.formFieldData as CheckBoxFormField, result.characterFormat);
        } else {
            result.text = this.documentHelper.textHelper.repeatChar(this.documentHelper.textHelper.getEnSpaceCharacter(), 5);
        }
        element.push(result);
        const fieldEnd: FieldElementBox = new FieldElementBox(1);
        fieldEnd.characterFormat.copyFormat(format);
        element.push(fieldEnd);
        fieldBegin.fieldSeparator = fieldEnd.fieldSeparator = fieldSeparator;
        fieldBegin.fieldEnd = fieldSeparator.fieldEnd = fieldEnd;
        fieldSeparator.fieldBegin = fieldEnd.fieldBegin = fieldBegin;
        const bookmarkEnd: BookmarkElementBox = new BookmarkElementBox(1);
        bookmarkEnd.characterFormat.copyFormat(format);
        bookmarkEnd.name = fieldBegin.formFieldData.name;
        bookmarkEnd.reference = bookmark;
        bookmark.reference = bookmarkEnd;
        element.push(bookmarkEnd);
        this.documentHelper.layout.isInsertFormField = true;
        this.insertElement(element);
        this.documentHelper.layout.isInsertFormField = false;
        const paragraph: ParagraphWidget = this.selection.start.paragraph;
        fieldEnd.linkFieldCharacter(this.documentHelper);
        if (this.documentHelper.fields.indexOf(fieldBegin) === -1) {
            this.documentHelper.fields.push(fieldBegin);
        }
        this.addFormFieldWidget(fieldBegin);
        const offset: number = bookmarkEnd.line.getOffset(bookmarkEnd, 1);
        this.selection.selects(bookmarkEnd.line, offset, true);
        this.updateEndPosition();
        this.reLayout(this.selection, true);
    }

    public addFormFieldWidget(fieldBegin: FieldElementBox): void {
        if (this.documentHelper.formFields.indexOf(fieldBegin) === -1) {
            let isInserted: boolean = false;
            if (this.documentHelper.formFields.length > 0) {
                const currentStart: TextPosition = this.selection.getElementPosition(fieldBegin).startPosition;
                for (let i: number = 0; i < this.documentHelper.formFields.length; i++) {
                    /* eslint-disable-next-line max-len */
                    const paraIndex: TextPosition = this.selection.getElementPosition(this.documentHelper.formFields[i]).startPosition;
                    if (currentStart.isExistBefore(paraIndex)) {
                        isInserted = true;
                        this.documentHelper.formFields.splice(i, 0, fieldBegin);
                        break; 
                    }
                }
            }
            if (!isInserted) {
                this.documentHelper.formFields.push(fieldBegin); 
            }
        }
    }
    /**
     * @private
     */
    public getFormFieldData(type: FormFieldType): FormField {
        switch (type) {
            case 'Text':
                return new TextFormField();
            case 'CheckBox':
                return new CheckBoxFormField();
            case 'DropDown':
                return new DropDownFormField();
        }
    }
    /**
     * @param field
     * @param info
     * @private
     * @returns {void}
     */
    public setFormField(field: FieldElementBox, info: TextFormFieldInfo | CheckBoxFormFieldInfo | DropDownFormFieldInfo): void {
        let type: FormFieldType;
        let formField: FormField;
        if (!isNullOrUndefined((info as TextFormFieldInfo).format)) {
            type = 'Text';
            formField = new TextFormField();
        } else if (!isNullOrUndefined((info as CheckBoxFormFieldInfo).sizeType)) {
            type = 'CheckBox';
            formField = new CheckBoxFormField();
        } else if (!isNullOrUndefined((info as DropDownFormFieldInfo).dropdownItems)) {
            type = 'DropDown';
            formField = new DropDownFormField();
        }
        if (!isNullOrUndefined(type) && !isNullOrUndefined(formField)) {
            formField.name = !isNullOrUndefined(info.name) ? info.name : field.formFieldData.name;
            formField.copyFieldInfo(info);
            this.editFormField(type, formField);
        }
    }
    /**
     * @param type
     * @param formData
     * @param type
     * @param formData
     * @private
     * @returns {boolean}
     */
    public editFormField(type: FormFieldType, formData: FormField): boolean {
        const begin: FieldElementBox = this.selection.getCurrentFormField();
        if (isNullOrUndefined(begin) || isNullOrUndefined(begin.formFieldData)) {
            return false;
        }
        this.initComplexHistory('FormField');
        let bookmarkStart: BookmarkElementBox;
        let bookmarkEnd: BookmarkElementBox;
        if (formData.name !== '') {
            if (begin.formFieldData.name !== formData.name &&
                this.documentHelper.bookmarks.containsKey(formData.name)) {
                this.deleteBookmark(formData.name);
            }
            bookmarkStart = new BookmarkElementBox(0);
            bookmarkStart.name = formData.name;
            bookmarkEnd = new BookmarkElementBox(1);
            bookmarkEnd.name = formData.name;
            bookmarkStart.reference = bookmarkEnd;
            bookmarkEnd.reference = bookmarkStart;
        }

        this.initHistory('InsertHyperlink');
        this.editHyperlinkInternal = isNullOrUndefined(this.editorHistory)
            || (this.editorHistory && isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo));
        // Preserves the character format for hyperlink field.
        const temp: WCharacterFormat = begin.characterFormat.cloneFormat();
        const format: WCharacterFormat = new WCharacterFormat();
        format.copyFormat(temp);
        const textFormat: WCharacterFormat = begin.fieldSeparator.nextElement.characterFormat.cloneFormat();
        let currentOffset: number = begin.line.getOffset(begin, 0);
        this.selection.start.setPositionParagraph(begin.line, currentOffset);
        let endElement: ElementBox = begin.fieldEnd;
        if (begin.nextNode && begin.nextNode instanceof BookmarkElementBox) {
            endElement = begin.nextNode.reference;
        }
        currentOffset = endElement.line.getOffset(endElement, 1);
        this.selection.end.setPositionParagraph(endElement.line, currentOffset);
        this.skipFieldDeleteTracking = true;
        this.deleteSelectedContents(this.selection, true);
        this.skipFieldDeleteTracking = false;
        this.updateInsertPosition();
        const element: ElementBox[] = [];
        const fieldBegin: FieldElementBox = new FieldElementBox(0);
        fieldBegin.formFieldData = formData;
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            this.editorHistory.currentBaseHistoryInfo.formFieldType = type;
            this.editorHistory.currentBaseHistoryInfo.fieldBegin = fieldBegin;
        }
        element.push(fieldBegin);
        fieldBegin.characterFormat.copyFormat(format);
        if (!isNullOrUndefined(bookmarkStart)) {
            element.push(bookmarkStart);
        }
        let span: TextElementBox = new TextElementBox();
        span.text = this.getFormFieldCode(type);
        element.push(span);
        const fieldSeparator: FieldElementBox = new FieldElementBox(2);
        fieldSeparator.characterFormat.copyFormat(format);
        element.push(fieldSeparator);
        span = new TextElementBox();
        span.characterFormat.copyFormat(textFormat);
        span.text = this.getDefaultText(formData);
        if (type === 'CheckBox') {
            span.characterFormat.copyFormat(fieldBegin.characterFormat);
            if ((formData as CheckBoxFormField).sizeType === 'Exactly') {
                span.characterFormat.fontSize = (formData as CheckBoxFormField).size * CHECK_BOX_FACTOR;
            }
        } else if (formData instanceof TextFormField) {
            if (formData.defaultValue !== '') {
                if (formData.type === 'Text') {
                    span.text = HelperMethods.formatText(formData.format, formData.defaultValue);
                } else if (formData.type === 'Number') {
                    span.text = HelperMethods.formatNumber(formData.format, formData.defaultValue);
                } else {
                    span.text = HelperMethods.formatDate(formData.format, formData.defaultValue);
                }
            }
        }
        element.push(span);
        const fieldEnd: FieldElementBox = new FieldElementBox(1);
        fieldEnd.characterFormat.copyFormat(format);
        element.push(fieldEnd);
        let lastElement: ElementBox = fieldEnd;
        if (!isNullOrUndefined(bookmarkEnd)) {
            lastElement = bookmarkEnd;
            element.push(bookmarkEnd);
        }
        fieldBegin.fieldSeparator = fieldEnd.fieldSeparator = fieldSeparator;
        fieldBegin.fieldEnd = fieldSeparator.fieldEnd = fieldEnd;
        fieldSeparator.fieldBegin = fieldEnd.fieldBegin = fieldBegin;
        this.documentHelper.layout.isInsertFormField = true;
        this.insertElement(element);
        this.documentHelper.layout.isInsertFormField = false;      
        const paragraph: ParagraphWidget = this.selection.start.paragraph;
        fieldEnd.linkFieldCharacter(this.documentHelper);
        if (this.documentHelper.fields.indexOf(fieldBegin) === -1) {
            this.documentHelper.fields.push(fieldBegin);
        }
        this.addFormFieldWidget(fieldBegin);
        const offset: number = lastElement.line.getOffset(lastElement, 1);
        this.selection.selects(lastElement.line, offset, true);
        this.updateEndPosition();
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            this.editorHistory.updateHistory();
        }
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.isSkipOperationsBuild = this.owner.enableCollaborativeEditing;
            this.editorHistory.updateComplexHistory();
            this.isSkipOperationsBuild = false;
        }
        this.reLayout(this.selection, true);
        this.editHyperlinkInternal = false;
        this.nodes = [];
        return true;
    }

    private getDefaultText(formField: FormField): string {
        let defaultText: string = '';
        if (formField instanceof CheckBoxFormField) {
            defaultText = formField.defaultValue ? String.fromCharCode(9745) : String.fromCharCode(9744);
        } else if (formField instanceof DropDownFormField) {
            if (formField.dropdownItems.length > 0) {
                defaultText = formField.dropdownItems[0];
            } else {
                defaultText = this.documentHelper.textHelper.repeatChar(this.documentHelper.textHelper.getEnSpaceCharacter(), 5);
            }
        } else if (formField instanceof TextFormField) {
            if (formField.defaultValue !== '') {
                defaultText = formField.defaultValue;
            } else {
                defaultText = this.documentHelper.textHelper.repeatChar(this.documentHelper.textHelper.getEnSpaceCharacter(), 5);
            }
        }
        return defaultText;
    }

    private getFormFieldCode(type: FormFieldType): string {
        switch (type) {
            case 'Text':
                return 'FORMTEXT';
            case 'CheckBox':
                return 'FORMCHECKBOX';
            case 'DropDown':
                return 'FORMDROPDOWN';
        }
    }

    /**
     * @param field
     * @param reset
     * @param value
     * @param field
     * @param reset
     * @param value
     * @private
     * @returns {void}
     */
    public toggleCheckBoxFormField(field: FieldElementBox, reset?: boolean, value?: boolean): void {
        const formFieldData: FormField = field.formFieldData;
        if (formFieldData instanceof CheckBoxFormField && formFieldData.enabled) {
            this.initHistory('UpdateFormField');
            if (this.editorHistory) {
                let currentValue: string | boolean | number;
                if (formFieldData instanceof CheckBoxFormField) {
                    currentValue = formFieldData.checked;
                }
                this.editorHistory.currentBaseHistoryInfo.fieldBegin = field;
                this.editorHistory.currentBaseHistoryInfo.setFormFieldInfo(field, currentValue);
                this.editorHistory.updateHistory();
            }
            if (reset) {
                (formFieldData as CheckBoxFormField).checked = value;
            } else {
                (formFieldData as CheckBoxFormField).checked = !(formFieldData as CheckBoxFormField).checked;
            }
            const separator: FieldElementBox = field.fieldSeparator;
            const checkBoxTextElement: TextElementBox = separator.nextNode as TextElementBox;
            if ((formFieldData as CheckBoxFormField).checked) {
                checkBoxTextElement.text = String.fromCharCode(9745);
            } else {
                checkBoxTextElement.text = String.fromCharCode(9744);
            }
            checkBoxTextElement.isWidthUpdated = false;
            this.owner.documentHelper.layout.reLayoutParagraph(field.line.paragraph, 0, 0);
            this.reLayout(this.selection, false);
        }
    }
    /**
     * @private
     * @param contentControl
     * @returns {void}
     */
    public toggleContentControlCheckBox(contentControl: ContentControl, value: boolean): void {
        if (!isNullOrUndefined(this.editorHistory) && !this.editorHistory.isUndoing && !this.editorHistory.isRedoing) {
            this.selection.selectContentControlInternal(contentControl);
            this.initHistory('UpdateContentControl');
        }
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            this.editorHistory.currentBaseHistoryInfo.setContentControlCheckBox(contentControl, value);
        }
        let checkBoxText: ElementBox = contentControl.nextNode;
        if (checkBoxText instanceof EditRangeStartElementBox || checkBoxText instanceof EditRangeEndElementBox) {
            checkBoxText = checkBoxText.nextNode as TextElementBox;
        }
        if (!(checkBoxText instanceof TextElementBox) && !isNullOrUndefined(this.selection)) {
            checkBoxText = this.selection.getNextTextElement(checkBoxText);
        }
        checkBoxText.isWidthUpdated = false;
        const state: CheckBoxState = value ? contentControl.contentControlProperties.checkedState
            : contentControl.contentControlProperties.uncheckedState;

        if (!isNullOrUndefined(state.font) && !isNullOrUndefined(state.value)) {
            checkBoxText.characterFormat.fontFamily = state.font;
            checkBoxText.characterFormat.fontFamilyAscii = state.font;
            checkBoxText.characterFormat.fontFamilyFarEast = state.font;
            checkBoxText.characterFormat.fontFamilyNonFarEast = state.font;
            (checkBoxText as TextElementBox).text = state.value;
        } else {
            (checkBoxText as TextElementBox).text = String.fromCharCode(value ? 9746 : 9744);
        }
        contentControl.contentControlProperties.isChecked = value;
        this.reLayout(this.selection, true);
    }
    /**
     * @param field
     * @param value
     * @param reset
     * @private
     * @returns {void}
     */
    public updateFormField(field: FieldElementBox, value: string | number, reset?: boolean): void {
        const formFieldData: FormField = field.formFieldData;
        if (formFieldData) {
            this.updateFormFieldInternal(field, formFieldData, value, reset);
        }
    }

    /**
     * @private
     * @returns {void}
     */
    public updateContentControl(contentControl: ContentControl, value: string, reset?: boolean): void {
        if (contentControl.contentControlProperties.type === 'RichText' || contentControl.contentControlProperties.type === 'Text' || contentControl.contentControlProperties.type === 'Date' || contentControl.contentControlProperties.type === 'Picture') {
            this.updateContentControlResult(contentControl, value as string, reset);
        } else if (contentControl.contentControlProperties.type === 'CheckBox') {
            this.toggleContentControlCheckBox(contentControl, (value === 'true' && !reset));
        } else if (contentControl.contentControlProperties.type === 'ComboBox' || contentControl.contentControlProperties.type === 'DropDownList') {
            let span: ContentControlListItems = new ContentControlListItems();
            if (reset) {
                const localeValue: L10n = new L10n('documenteditor', this.owner.defaultLocale);
                span.displayText = localeValue.getConstant('Choose an item');
                span.value = localeValue.getConstant('Choose an item');
            } else {
                span.displayText = value as string;
                span.value = value as string;   
            }
            contentControl.contentControlProperties.contentControlListItems.push(span);
            this.dropDownChange(contentControl, span.displayText as string);
        }
    }
    private updateContentControlResult(contentControl: ContentControl, value: string, reset?: boolean): void {
        this.selection.selectContentControlInternal(contentControl);
        if (contentControl.contentControlProperties.type === 'Picture') {
            if (reset) {
                value = '';
            }
            this.insertImageAsync(value);
        } else {
            if (reset || isNullOrUndefined(value) || value === '') {
                const locale: L10n = new L10n('documenteditor', this.owner.defaultLocale);
                locale.setLocale(this.owner.locale);
                value = contentControl.contentControlProperties.type === 'Date' ? locale.getConstant('Default Date Picker') : locale.getConstant('Default Content Control Text');
            }
            if (contentControl.contentControlProperties.type === 'RichText') {
                try {
                    if (/^\d+$/.test(value)) {
                        var sfdt = {
                            "sections": [
                                {
                                    "blocks": [
                                        {
                                            "inlines": [
                                                {
                                                    "text": value
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        };
                        value = JSON.stringify(sfdt);
                    }
                    else if (typeof value !== 'object') {
                        value = JSON.parse(value as string);
                    }
                } catch (e) {
                    let sfdt = {
                        "sections": [
                            {
                                "blocks": [
                                    {
                                        "inlines": [
                                            {
                                                "text": value as string
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    };
                    value = JSON.stringify(sfdt);
                }
                this.paste(value, 'MergeWithExistingFormatting');
                this.updatePropertiesToBlock(contentControl, true);
            } else {
                this.insertText(value);
            }
        }
    }
    /**
     * @private
     * @returns {void}
     */
    public getContentControlPropObject(contentControl: ContentControlProperties): any {
        return !isNullOrUndefined(this.owner.sfdtExportModule) ? this.documentHelper.owner.sfdtExportModule.contentControlProperty(contentControl, 1) : {};
    }

    /**
     * @private
     * @returns {void}
     */
    public assignContentControl(contentControl: ContentControlProperties, value: any): void {
        if (this.owner.parser) {
            this.owner.parser.parseContentControlProperties(value, contentControl, 1);
        }
    }

    private updateFormFieldInternal(field: FieldElementBox, formFieldData: FormField, value: string | number, reset?: boolean): void {
        if (formFieldData instanceof TextFormField) {
            if (value === '') {
                if (reset) {
                    value = this.getDefaultText(formFieldData) as string;
                } else {
                    value = this.documentHelper.textHelper.repeatChar(this.documentHelper.textHelper.getEnSpaceCharacter(), 5);
                }
            }
            let formattedText: string = value as string;
            const type: TextFormFieldType = formFieldData.type;
            if (type === 'Text' && formFieldData.format !== '') {
                formattedText = HelperMethods.formatText(formFieldData.format, value as string);
            }
            this.updateFormFieldResult(field, formattedText);
        } else if (formFieldData instanceof DropDownFormField) {
            const text: string = formFieldData.dropdownItems[value as number];
            formFieldData.selectedIndex = value as number;
            this.updateFormFieldResult(field, text);
        }
        const endoffset: number = field.fieldEnd.line.getOffset(field.fieldEnd, 1);
        const startPos: TextPosition = new TextPosition(this.owner);
        startPos.setPositionParagraph(field.fieldEnd.line, endoffset);
        //selects the field range
        this.documentHelper.selection.selectRange(startPos, startPos);
        this.reLayout(this.selection, false);
    }
    private updateFormFieldResult(field: FieldElementBox, value: string): void {
        //When protection is enabled with type Form Filling below method selects the field result alone.
        this.selection.selectFieldInternal(field, false, true);
        this.isSkipOperationsBuild = this.owner.enableCollaborativeEditing;
        this.insertText(value);
        this.isSkipOperationsBuild = false;
    }

    private checkBookmarkAvailability(name: string, action: string): boolean {
        const bookmarkCol: Dictionary<string, BookmarkElementBox> = this.documentHelper.bookmarks;
        for (let i: number = 0; i < bookmarkCol.length; i++) {
            if (bookmarkCol.containsKey(name)) {
                return false;
            }
        }
        return true;
    }

    private getBookmarkName(type: string, action: string, count: number): string {
        let name: string;
        let available: boolean = false;
        while (available === false) {
            name = type + count;
            available = this.checkBookmarkAvailability(name, action);
            count = count + 1;
        }
        return name;
    }
    /**
     * @param formField
     * @private
     * @returns {void}
     */
    public applyFormTextFormat(formField: FieldElementBox): void {
        if (!isNullOrUndefined(formField)) {
            let text: string = this.getFieldResultText(formField);
            const currentValue: string = text;
            text = HelperMethods.formatText((formField.formFieldData as TextFormField).format, text);
            if (formField.fieldSeparator != undefined) {
                this.applyTextFormatInternal(formField, text);
            }
            this.initHistory('FormTextFormat');
            if (this.editorHistory) {
                this.editorHistory.currentBaseHistoryInfo.setFormFieldInfo(formField, currentValue);
                this.editorHistory.updateHistory();
            }
        }
    }
    // Inserts 5 space on Form Fill inline mode if length is 0
    private insertSpaceInFormField(): void {
        if (this.documentHelper.isInlineFormFillProtectedMode && this.selection.isInlineFormFillMode()) {
            const resultText: string = this.getFieldResultText();
            if (resultText.length === 0 || resultText === '\r') {

                this.insertTextInternal(this.documentHelper.textHelper.repeatChar(this.documentHelper.textHelper.getEnSpaceCharacter(), 5), true);
                this.selection.selectTextElementStartOfField(this.selection.getCurrentFormField());
            }
        }
    }
    /**
     * @param formField
     * @private
     * @returns {string}
     */
    public getFieldResultText(formField?: FieldElementBox): string {
        if (isNullOrUndefined(formField)) {
            formField = this.selection.getCurrentFormField();
        }
        //Stores the current selection index, to reset after getting the result text
        let previousStartIndex = this.selection.startOffset;
        let previousEndIndex = this.selection.endOffset;
        this.selection.isModifyingSelectionInternally = true;
        this.selection.selectFieldInternal(formField, false, true);
        let resultText: string = this.selection.getText(false);
        //Resets the selection back to the original index
        this.selection.select(previousStartIndex, previousEndIndex);
        this.selection.isModifyingSelectionInternally = false;
        return resultText;
    }
     /**
     * @private
     * @returns {void}
     */
     public contentControlDropDownChange():void{
        let contenControl = this.documentHelper.selection.currentContentControl;
        if(!isNullOrUndefined(contenControl)) {
            if((contenControl.contentControlProperties.type == 'ComboBox' || contenControl.contentControlProperties.type == 'DropDownList')){
                this.documentHelper.contentDropDown.showPopUp(contenControl);
            }
            else if(contenControl.contentControlProperties.type == 'Date'){
                this.documentHelper.owner.dateContentDialogModule.show();
            }
        }
    }
    /**
     * @param field
     * @param text
     * @private
     * @returns {void}
     */
    public applyTextFormatInternal(field: FieldElementBox, text: string): void {
        let textElement: ElementBox = field.fieldSeparator.nextElement;
        let start: number = 0;
        text = text.replace(/\r/g, '');
        do {
            if (!isNullOrUndefined(textElement) && textElement instanceof TextElementBox) {
                textElement.text = text.slice(start, start + textElement.text.length);
                start = start + textElement.length;
            }
            if (isNullOrUndefined(textElement.nextElement)) {
                if (!isNullOrUndefined(textElement.line.nextLine)) {
                    textElement = textElement.line.nextLine.children[0];
                } else {

                    this.documentHelper.layout.layoutBodyWidgetCollection(textElement.paragraph.index, textElement.paragraph.bodyWidget, textElement.paragraph, true);
                    let nextBlock: BlockWidget = textElement.paragraph.nextRenderedWidget as BlockWidget;
                    if (isNullOrUndefined(nextBlock)) {
                        break;
                    }
                    if (nextBlock instanceof TableWidget) {
                        nextBlock = this.documentHelper.getFirstParagraphBlock(nextBlock);
                    }
                    while ((nextBlock as ParagraphWidget).isEmpty()) {
                        nextBlock = nextBlock.nextRenderedWidget as BlockWidget;
                    }

                    textElement = ((nextBlock as ParagraphWidget).childWidgets[0] as LineWidget).children[0];
                }
            } else {
                textElement = textElement.nextElement;
            }
        } while (!(textElement instanceof FieldElementBox && textElement.fieldType === 1 &&
            textElement.fieldBegin.formFieldData instanceof TextFormField));

        this.documentHelper.layout.layoutBodyWidgetCollection(textElement.paragraph.index, textElement.paragraph.bodyWidget, textElement.paragraph, true);
        this.selection.isFormatUpdated = true;
        this.reLayout(this.selection, false);
        this.selection.isFormatUpdated = false;
    }
    private constructCommentInitial(authorName: string): string {
        const splittedName: string[] = authorName.split(' ');
        let initials: string = '';
        for (let i: number = 0; i < splittedName.length; i++) {
            if (splittedName[i].length > 0 && splittedName[i] !== '') {
                initials += splittedName[i][0];
            }
        }
        return initials;
    }
    /**
     * Inserts the footnote at the current selection.
     *
     * @returns {void}
     */
    public insertFootnote(): void {
        if (this.selection.isinFootnote || this.selection.isinEndnote || this.selection.isPlainContentControl()) {
            return;
        }
        this.isFootNoteInsert = true;
        this.isFootNote = true;
        const footnote: FootnoteElementBox = new FootnoteElementBox();
        footnote.characterFormat.baselineAlignment = 'Superscript';
        footnote.footnoteType = 'Footnote';
        footnote.text = 's';
        const paragraph: ParagraphWidget = new ParagraphWidget();
        const lineWidget: LineWidget = new LineWidget(paragraph);
        const text: FootnoteEndnoteMarkerElementBox = new FootnoteEndnoteMarkerElementBox();
        paragraph.paragraphFormat.afterSpacing = 0;
        text.characterFormat.baselineAlignment = 'Superscript';
        text.line = lineWidget;
        text.text = '?';
        lineWidget.children.push(text);
        const text1: TextElementBox = new TextElementBox();
        text1.text = ' ';
        text1.line = lineWidget;
        lineWidget.children.push(text1);
        paragraph.childWidgets.push(lineWidget);
        footnote.bodyWidget.childWidgets.push(paragraph);

        if (!this.selection.isEmpty) {
            this.selection.handleRightKey();
        }
        this.initInsertInline(footnote);
        // this.documentHelper.layout.isLayoutWhole = true;
        // this.layoutWholeDocument();
        // this.documentHelper.layout.isLayoutWhole = false;
        let footPara: BlockWidget;
        if (footnote.paragraph.bodyWidget.page.footnoteWidget) {
            for (let i: number = 0; i < footnote.paragraph.bodyWidget.page.footnoteWidget.bodyWidgets.length; i++) {
                if ((footnote.paragraph.bodyWidget.page.footnoteWidget.bodyWidgets[i]).footNoteReference === footnote) {
                    footPara = (footnote.paragraph.bodyWidget.page.footnoteWidget.bodyWidgets[i].childWidgets[0] as BlockWidget);
                }
            }
        }

        this.selection.start.setPositionForLineWidget((footPara.childWidgets[0] as LineWidget), text1.line.getOffset(text1, footnote.text.length));
        this.selection.end.setPositionInternal(this.selection.start);
        // this.selection.fireSelectionChanged(true);
        this.updateFootNoteIndex();
        this.reLayout(this.selection, false);
        this.documentHelper.layout.isLayoutWhole = true;
        this.isSkipOperationsBuild = true;
        this.documentHelper.layout.layoutWholeDocument();
        this.isSkipOperationsBuild = false;
        this.documentHelper.layout.isLayoutWhole = false;
        this.separator('footnote');
        this.continuationSeparator('footnote');
        this.isFootNote = false;
        this.isFootNoteInsert = false;
    }
    private updateFootnoteCollection(footnote: FootnoteElementBox): void {
        if (this.documentHelper.footnoteCollection.indexOf(footnote) === -1) {
            let isInserted: boolean = false;
            if (this.documentHelper.footnoteCollection.length > 0) {

                const currentStart: TextPosition = this.selection.getElementPosition(footnote).startPosition;
                for (let i: number = 0; i < this.documentHelper.footnoteCollection.length; i++) {

                    const paraIndex: TextPosition = this.selection.getElementPosition(this.documentHelper.footnoteCollection[i]).startPosition;
                    if (currentStart.isExistBefore(paraIndex)) {
                        isInserted = true;
                        this.documentHelper.footnoteCollection.splice(i, 0, footnote);
                        break;
                    }
                }
            }
            if (!isInserted) {
                this.documentHelper.footnoteCollection.push(footnote);
            }
            // this.viewer.updateScrollBars();
        }
    }
    // Footnote implementation ends
    /**
     * Inserts the endnote at the current selection
     *
     * @returns {void}
     */
    public insertEndnote(): void {
        if (this.selection.isinFootnote || this.selection.isinEndnote || this.selection.isPlainContentControl()) {
            return;
        }
        this.documentHelper.layout.isEndnoteContentChanged = true;
        const endnote: FootnoteElementBox = new FootnoteElementBox();
        endnote.characterFormat.baselineAlignment = 'Superscript';
        endnote.footnoteType = 'Endnote';
        endnote.text = 's';
        const paragraph: ParagraphWidget = new ParagraphWidget();
        const lineWidget: LineWidget = new LineWidget(paragraph);
        const footText: FootnoteEndnoteMarkerElementBox = new FootnoteEndnoteMarkerElementBox();
        paragraph.paragraphFormat.afterSpacing = 0;
        footText.characterFormat.baselineAlignment = 'Superscript';
        footText.line = lineWidget;
        footText.text = '?';
        lineWidget.children.push(footText);
        const followText: TextElementBox = new TextElementBox();
        followText.text = ' ';
        followText.line = lineWidget;
        lineWidget.children.push(followText);
        paragraph.childWidgets.push(lineWidget);
        endnote.bodyWidget.childWidgets.push(paragraph);
        if (!this.selection.isEmpty) {
            this.selection.handleRightKey();
        }
        this.initInsertInline(endnote);
        // this.documentHelper.layout.isLayoutWhole = true;
        // this.layoutWholeDocument();
        // this.documentHelper.layout.isLayoutWhole = false;
        const lastpage: number = this.documentHelper.pages.length;
        const bodyWidget: BlockContainer = this.documentHelper.pages[lastpage - 1].bodyWidgets[0];
        let footPara: BlockWidget;
        if (bodyWidget.page.endnoteWidget) {
            for (let i: number = 0; i < bodyWidget.page.endnoteWidget.bodyWidgets.length; i++) {
                if ((bodyWidget.page.endnoteWidget.bodyWidgets[i]).footNoteReference === endnote) {
                    footPara = (bodyWidget.page.endnoteWidget.bodyWidgets[i].childWidgets[0] as BlockWidget);
                }
            }
        }

        this.selection.start.setPositionForLineWidget((footPara.childWidgets[0] as LineWidget), footText.line.getOffset(followText, endnote.text.length));
        this.selection.end.setPositionInternal(this.selection.start);
        this.updateEndNoteIndex();
        this.reLayout(this.selection, false);
        this.documentHelper.layout.isLayoutWhole = true;
        this.isSkipOperationsBuild = this.owner.enableCollaborativeEditing;
        this.documentHelper.layout.layoutWholeDocument();
        this.isSkipOperationsBuild = false;
        this.documentHelper.layout.isLayoutWhole = false;
        this.owner.documentHelper.blockToShift = undefined;
        this.separator('endnote');
        this.continuationSeparator('endnote');
        this.documentHelper.layout.isEndnoteContentChanged = false;
    }
    private updateEndnoteCollection(endnote: FootnoteElementBox): void {
        if (this.documentHelper.endnoteCollection.indexOf(endnote) === -1) {
            let isInserted: boolean = false;
            if (this.documentHelper.endnoteCollection.length > 0) {

                const currentStart: TextPosition = this.selection.getElementPosition(endnote).startPosition;
                for (let i: number = 0; i < this.documentHelper.endnoteCollection.length; i++) {

                    const paraIndex: TextPosition = this.selection.getElementPosition(this.documentHelper.endnoteCollection[i]).startPosition;
                    if (currentStart.isExistBefore(paraIndex)) {
                        isInserted = true;
                        this.documentHelper.endnoteCollection.splice(i, 0, endnote);
                        break;
                    }
                }
            }
            if (!isInserted) {
                this.documentHelper.endnoteCollection.push(endnote);
            }
            const lastpage: number = this.documentHelper.pages.length;
            if (this.documentHelper.endnoteCollection.length > 0) {
                let positionchanged: boolean = false;
                // this.documentHelper.layout.isFootnoteContentChanged = true;
                let foot: FootnoteElementBox;
                let endnoteWidget: FootNoteWidget;
                const footIndex: number = this.documentHelper.endnoteCollection.indexOf(endnote);
                let insertIndex: number = 1;
                const height: number = 0;
                let isCreated: boolean;
                const bodyWidget: BlockContainer = this.documentHelper.pages[lastpage - 1].bodyWidgets[0];
                if (bodyWidget.page.endnoteWidget) {
                    for (let j: number = 0; j < bodyWidget.page.endnoteWidget.bodyWidgets.length; j++) {
                        const currentIndex: number = this.documentHelper.endnoteCollection.indexOf((bodyWidget.page.endnoteWidget.bodyWidgets[j]).footNoteReference);
                        if (currentIndex > footIndex) {
                            if (currentIndex - footIndex === 1) {
                                insertIndex = j;
                                positionchanged = true;
                                break;
                            }
                        }
                    }
                }
                // endnote.isLayout = true;
                foot = endnote; //this.documentHelper.endnoteCollection[i];
                if (bodyWidget.page.endnoteWidget instanceof FootNoteWidget && bodyWidget.page.endnoteWidget.footNoteType === 'Endnote') {
                    endnoteWidget = bodyWidget.page.endnoteWidget as FootNoteWidget;
                } else {
                    isCreated = true;
                    endnoteWidget = new FootNoteWidget();
                    endnoteWidget.footNoteType = 'Endnote';
                    endnoteWidget.page = bodyWidget.page;
                    const newParagraph: ParagraphWidget = new ParagraphWidget();
                    newParagraph.characterFormat = new WCharacterFormat();
                    newParagraph.paragraphFormat = new WParagraphFormat();
                    newParagraph.index = 0;
                    const lineWidget: LineWidget = new LineWidget(newParagraph);
                    newParagraph.childWidgets.push(lineWidget);
                    //endnoteWidget.childWidgets.push(newParagraph);
                    this.viewer.cutFromTop(this.viewer.clientActiveArea.y + 18);
                }
                let body: BlockContainer = foot.bodyWidget;
                for (let j: number = 0; j < foot.bodyWidget.childWidgets.length; j++) {
                    const block: BlockWidget = foot.bodyWidget.childWidgets[j] as BlockWidget;
                    //body.childWidgets.push(block);
                    if (this.documentHelper.layout.isLayoutWhole) {
                        block.containerWidget = undefined;
                    } else {
                        block.containerWidget = body;
                        body.page = bodyWidget.page;
                        body.sectionFormat = endnoteWidget.sectionFormat;
                        block.containerWidget.containerWidget = endnoteWidget;
                    }
                    // endnoteWidget.bodyWidgets[j].childWidgets.push(block);

                    if (positionchanged) {
                        endnoteWidget.bodyWidgets.splice(insertIndex, 0, body);
                    } else {
                        endnoteWidget.bodyWidgets.push(body);
                    }
                }
                insertIndex++;
                if (isCreated) {
                    bodyWidget.page.endnoteWidget = endnoteWidget;
                }
                // endNote.containerWidget = bodyWidget;
                endnoteWidget.height += height;

                //         }
                // this.documentHelper.layout.layoutfootNote(endnoteWidget);
                //this.layoutfootNote(endNote);
            }
            // this.viewer.updateScrollBars();
        }
    }
    private updateEndNoteIndex(): void {
        let endNoteCollec: FootnoteElementBox[] = this.documentHelper.endnoteCollection;
        for (let i: number = 0; i < endNoteCollec.length; i++) {
            let text: string = this.documentHelper.layout.getFootEndNote(endNoteCollec[i].paragraph.bodyWidget.sectionFormat.endnoteNumberFormat, i + 1);
            if (text != '') {
                endNoteCollec[i].text = text;
                if(endNoteCollec[i].getAllRevision() !== undefined){
                    let j: number=0;
                    while(j < endNoteCollec[i].revisionLength){
                        this.owner.trackChangesPane.updateCurrentTrackChanges(endNoteCollec[i].getRevision(j));
                        j++;
                    }
                }
                let marker: TextElementBox = ((endNoteCollec[i].bodyWidget.childWidgets[0] as BlockWidget).childWidgets[0] as LineWidget).children[0] as TextElementBox;
                if (!isNullOrUndefined(marker)) {
                    if (marker instanceof FootnoteEndnoteMarkerElementBox || HelperMethods.checkTextFormat(marker.text)) {
                        (marker as TextElementBox).text = text;
                        marker.width = endNoteCollec[i].bodyWidget.footNoteReference.width;
                    }
                    if(marker.getAllRevision() != undefined){
                        let j:number = 0;
                        while(j < marker.revisionLength){
                            this.owner.trackChangesPane.updateCurrentTrackChanges(marker.getRevision(j));
                            j++;
                        }
                    }
                }
            }
        }
    }
    private separator(type: string): void {
        //let block = new page_1.block;
        const paragraph: ParagraphWidget = new ParagraphWidget();
        const lineWidget: LineWidget = new LineWidget(paragraph);
        const text: TextElementBox = new TextElementBox();
        text.characterFormat.fontColor = '#00000000';
        text.line = lineWidget;
        text.text = String.fromCharCode(3);
        lineWidget.children.push(text);
        paragraph.childWidgets.push(lineWidget);
        if (type === 'footnote' && this.documentHelper.footnotes.separator.length < 1) {
            this.documentHelper.footnotes.separator.push(paragraph);
        } else if (type === 'endnote' && this.documentHelper.endnotes.separator.length < 1) {
            this.documentHelper.endnotes.separator.push(paragraph);
        }
    }
    private continuationSeparator(type: string): void {
        //var block = new page_1.block;
        const paragraph: ParagraphWidget = new ParagraphWidget();
        const lineWidget: LineWidget = new LineWidget(paragraph);
        const text: TextElementBox = new TextElementBox();
        text.characterFormat.fontColor = '#00000000';
        text.line = lineWidget;
        text.text = String.fromCharCode(4);
        lineWidget.children.push(text);
        paragraph.childWidgets.push(lineWidget);
        if (type === 'footnote' && this.documentHelper.footnotes.continuationSeparator.length < 1) {
            this.documentHelper.footnotes.continuationSeparator.push(paragraph);
        } else if (type === 'endnote' && this.documentHelper.endnotes.continuationSeparator.length < 1) {
            this.documentHelper.endnotes.continuationSeparator.push(paragraph);
        }
    }

    private updateFootNoteIndex(): void {
        let footNoteCollec: FootnoteElementBox[] = this.documentHelper.footnoteCollection;
        for (let i: number = 0; i < footNoteCollec.length; i++) {
            let text: string = this.documentHelper.layout.getFootEndNote(footNoteCollec[i].paragraph.bodyWidget.sectionFormat.footNoteNumberFormat, i + 1);
            if (text != '') {
                footNoteCollec[i].text = text;
                if (footNoteCollec[i].getAllRevision() !== undefined) {
                    let j: number = 0;
                    while (j < footNoteCollec[i].revisionLength) {
                        this.owner.trackChangesPane.updateCurrentTrackChanges(footNoteCollec[i].getRevision(j));
                        j++;
                    }
                }
                let marker: TextElementBox = ((footNoteCollec[i].bodyWidget.childWidgets[0] as BlockWidget).childWidgets[0] as LineWidget).children[0] as TextElementBox;
                if (!isNullOrUndefined(marker) && marker instanceof FootnoteEndnoteMarkerElementBox) {
                    (marker as TextElementBox).text = text;
                    marker.width = footNoteCollec[i].bodyWidget.footNoteReference.width;
                    if (marker.getAllRevision() != undefined) {
                        let j: number = 0;
                        while (j < marker.revisionLength) {
                            this.owner.trackChangesPane.updateCurrentTrackChanges(marker.getRevision(j));
                            j++;
                        }
                    }
                }
            }
        }
    }

    private setCharFormatForCollaborativeEditing(insertFormat: WCharacterFormat): void {
        if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo) && this.owner.enableCollaborativeEditing) {
            let characterFormat: any = {};
            HelperMethods.writeCharacterFormat(characterFormat, true, insertFormat, undefined, true);
            this.editorHistory.currentBaseHistoryInfo.type = "CharacterFormat";
            this.editorHistory.currentBaseHistoryInfo.format = JSON.stringify(characterFormat);
        }
    }

    /**
    * @private
    */
    public clear(): void {
        if (this.pageRefFields) {
            this.pageRefFields = {};
        }
    }
}
/**
 * @private
 */
export interface SelectionInfo {
    start: string;
    end: string;
}

/**
 * @private
 */
export interface ContinueNumberingInfo {
    currentList: WList;
    listLevelNumber: number;
    listPattern: ListLevelPattern;
}
/**
 * Specifies the settings for border.
 */
export interface BorderSettings {
    /**
     * Specifies the border type.
     */
    type: BorderType;
    /**
     * Specifies the border color.
     */
    borderColor?: string;
    /**
     * Specifies the line width.
     */
    lineWidth?: number;
    /**
     * Specifies the border style.
     */
    borderStyle?: LineStyle;
}
/**
 * @private
 */
export interface TocLevelSettings {
    [key: string]: number;
}

/**
 * @private
 */
export interface PageRefFields {
    [key: string]: FieldTextElementBox;
}
/**
 * Specifies the settings for table of contents.
 */
export interface TableOfContentsSettings {
    /**
     * Specifies the start level.
     */
    startLevel?: number;
    /**
     * Specifies the end level.
     */
    endLevel?: number;
    /**
     * Specifies whether hyperlink can be included.
     */
    includeHyperlink?: boolean;
    /**
     * Specifies whether page number can be included.
     */
    includePageNumber?: boolean;
    /**
     * Specifies whether the page number can be right aligned.
     */
    rightAlign?: boolean;
    /**
     * Specifies the tab leader.
     */
    tabLeader?: TabLeader;
    /**
     * @private
     */
    levelSettings?: TocLevelSettings;
    /**
     * Specifies whether outline levels can be included.
     */
    includeOutlineLevels?: boolean;
}


/**
 * Defines the character format properties of document editor
 */
export interface CharacterFormatProperties {
    /**
     * Defines the bold formatting
     */
    bold?: boolean;
    /**
     * Defines the italic formatting
     */
    italic?: boolean;

    /**
     * Defines the font size
     */
    fontSize?: number;
    /**
     * Defines the font family
     */
    fontFamily?: string;
    /**
     * Defines the underline property
     */
    underline?: Underline;
    /**
     * Defines the strikethrough
     */
    strikethrough?: Strikethrough;
    /**
     * Defines the subscript or superscript property
     */
    baselineAlignment?: BaselineAlignment;
    /**
     * Defines the highlight color
     */
    highlightColor?: HighlightColor;
    /**
     * Defines the font color
     */
    fontColor?: string;
    /**
     * Defines the bidirectional property
     */
    bidi?: boolean;
    /**
     * Defines the allCaps formatting
     */
    allCaps?: boolean;
}

/**
 * Defines the paragraph format properties of document editor
 */
export interface ParagraphFormatProperties {
    /**
     * Defines the left indent
     */
    leftIndent?: number;
    /**
     * Defines the right indent
     */
    rightIndent?: number;
    /**
     * Defines the first line indent
     */
    firstLineIndent?: number;
    /**
     * Defines the text alignment property
     */
    textAlignment?: TextAlignment;
    /**
     * Defines the spacing value after the paragraph
     */
    afterSpacing?: number;
    /**
     * Defines the spacing value before the paragraph
     */
    beforeSpacing?: number;
    /**
     * Defines the spacing between the lines
     */
    lineSpacing?: number;
    /**
     * Defines the spacing type(AtLeast,Exactly or Multiple) between the lines
     */
    lineSpacingType?: LineSpacingType;
    /**
     * Defines the bidirectional property of paragraph
     */
    bidi?: boolean;
    /**
     * Defines the keep with next property of paragraph
     */
    keepWithNext?: boolean;
    /**
     * Defines the keep lines together property of paragraph
     */
    keepLinesTogether?: boolean;
    /**
     * Defines the widow control property of paragraph
     */
    widowControl?: boolean;
    /**
     * Defines the outline level of paragraph
     */
    outlineLevel?: OutlineLevel;
}
/**
 * Defines the section format properties of document editor
 */
export interface SectionFormatProperties {
    /**
     * Defines the header distance.
     */
    headerDistance?: number;
    /**
     * Defines the footer distance.
     */
    footerDistance?: number;
    /**
     * Defines the page width.
     */
    pageWidth?: number;
    /**
     * Defines the page height.
     */
    pageHeight?: number;
    /**
     * Defines the left margin of the page.
     */
    leftMargin?: number;
    /**
     * Defines the top margin of the page.
     */
    topMargin?: number;
    /**
     * Defines the bottom margin of the page.
     */
    bottomMargin?: number;
    /**
     * Defines the right margin of the page.
     */
    rightMargin?: number;
}

/**
 * @private
 */
export interface TabPositionInfo {
    defaultTabWidth: number;
    fPosition: number;
    position: number;
}
/**
 * @private
 */

export interface ShapeProperties{
    /**
     * Sets the height of the shape.
     *
     */
    x?: number;

    /**
     * Sets the height of the shape.
     *
     */
    y?: number;

    /**
     * Sets the height of the shape.
     *
     */
    height?: number;

    /**
     * Sets the height of the shape.
     *
     */
    width?: number;

    /**
     * Sets visiblity of the shape.
     *
     */
    visible?: boolean;

    /**
     * Sets the height scale of the shape.
     *
     */
    widthScale?: number;

    /**
     * Sets the heightScale of the shape.
     *
     */
    heightScale?: number;

    /**
     * Sets the verticalPosition of the shape.
     *
     */
    verticalPosition?: number;

    /**
     * Sets the verticalOrigin of the shape.
     *
     */
    verticalOrigin?: VerticalOrigin;

    /**
     * Sets the verticalAlignment of the shape.
     *
     */
    verticalAlignment?: VerticalAlignment;

    /**
     * Sets the verticalAlignment of the shape.
     *
     */
    horizontalPosition?: number;

    /**
     * Sets the verticalAlignment of the shape.
     *
     */
    horizontalOrigin?: HorizontalOrigin;

    /**
     * Sets the verticalAlignment of the shape.
     *
     */
    horizontalAlignment?: HorizontalAlignment;

    /**
     * Sets allowOverLapping of the shape.
     *
     */
    allowOverLap?: boolean;

    /**
     * Sets textWrappingStyle of the shape.
     *
     */
    textWrappingStyle?: TextWrappingStyle;

    /**
     * Sets textWrappingType of the shape.
     *
     */
    textWrappingType?: TextWrappingType;

    /**
     * Sets isBelowText of the shape.
     *
     */
    isBelowText?: boolean;

    /**
     * Sets the distanceBottom of the shape.
     *
     */
    distanceBottom?: number;

    /**
     * Sets the distanceTop of the shape.
     *
     */
    distanceTop?: number;

    /**
     * Sets the distanceLeft of the shape.
     *
     */
    distanceLeft?: number;

    /**
     * Sets the distanceRight of the shape.
     *
     */
    distanceRight?: number;

    /**
     * Sets isHorizontalRule of the shape.
     *
     */
    isHorizontalRule?: boolean;

    /**
     * Sets isHorizontalRule of the shape.
     *
     */
    layoutInCell?: boolean;

    /**
     * Sets lockAnchor of the shape.
     *
     */
    lockAnchor?: boolean;

    /**
    * Sets fill of the shape.
    *
    */
    fill?: boolean;

    /**
    * Sets fillColor of the shape(Hex value eg: #156082FF).
    *
    */
    fillColor?: string;

    /**
    * Sets lineFormatType of the shape.
    *
    */
    lineFormatType?: LineFormatType;

    /**
    * Sets lineFormatType of the shape.
    *
    */
    dashStyle?: LineDashing;

    /**
    * Sets line of the shape.
    *
    */
    line?: boolean;

    /**
    * Sets lineColor of the shape(Hex value eg: #156082FF).
    *
    */
    lineColor?: string;

    /**
    * Sets lineWeight of the shape
    *
    */
    lineWeight?: number;

}
