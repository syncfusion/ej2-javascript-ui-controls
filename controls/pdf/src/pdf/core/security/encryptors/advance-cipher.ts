import { _AdvancedEncryptionBaseCipher } from './cipher';
export class _AdvancedEncryption128Cipher extends _AdvancedEncryptionBaseCipher {
    _key: Uint8Array;
    constructor(key: Uint8Array) {
        super();
        this._cyclesOfRepetition = 10;
        this._keySize = 160;
        this._key = new Uint8Array([
            0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c,
            0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a,
            0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
            0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
            0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
            0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6,
            0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72,
            0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
            0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10,
            0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e,
            0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5,
            0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
            0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02,
            0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d,
            0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d,
            0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
            0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb,
            0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c,
            0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a,
            0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
            0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
            0x74, 0xe8, 0xcb, 0x8d
        ]);
        this._key = this._expandKey(key);
    }
    _expandKey(cipherKey: Uint8Array): Uint8Array {
        const count: number = 176;
        const s: Uint8Array = this._s;
        const rcon: Uint8Array = this._key;
        const result: Uint8Array = new Uint8Array(count);
        result.set(cipherKey);
        for (let j: number = 16, i: number = 1; j < count; ++i) {
            let t1: number = result[j - 3];
            let t2: number = result[j - 2];
            let t3: number = result[j - 1];
            let t4: number = result[j - 4];
            t1 = s[<number>t1];
            t2 = s[<number>t2];
            t3 = s[<number>t3];
            t4 = s[<number>t4];
            t1 ^= rcon[<number>i];
            for (let n: number = 0; n < 4; ++n) {
                result[<number>j] = t1 ^= result[j - 16];
                result[j + 1] = t2 ^= result[j - 15];
                result[j + 2] = t3 ^= result[j - 14];
                result[j + 3] = t4 ^= result[j - 13];
                j += 4;
            }
        }
        return result;
    }
}
export class _AdvancedEncryption256Cipher extends _AdvancedEncryptionBaseCipher {
    constructor(key: Uint8Array) {
        super();
        this._cyclesOfRepetition = 14;
        this._keySize = 224;
        this._key = this._expandKey(key);
    }
    _expandKey(cipherKey: Uint8Array): Uint8Array {
        const count: number = 240;
        const s: Uint8Array = this._s;
        const result: Uint8Array = new Uint8Array(count);
        result.set(cipherKey);
        let r: number = 1;
        let t1: number;
        let t2: number;
        let t3: number;
        let t4: number;
        for (let j: number = 32, i: number = 1; j < count; ++i) {
            if (j % 32 === 16) {
                t1 = s[<number>t1];
                t2 = s[<number>t2];
                t3 = s[<number>t3];
                t4 = s[<number>t4];
            } else if (j % 32 === 0) {
                t1 = result[j - 3];
                t2 = result[j - 2];
                t3 = result[j - 1];
                t4 = result[j - 4];
                t1 = s[<number>t1];
                t2 = s[<number>t2];
                t3 = s[<number>t3];
                t4 = s[<number>t4];
                t1 ^= r;
                r = r << 1;
                if (r >= 256) {
                    r = (r ^ 0x1b) & 0xff;
                }
            }
            for (let n: number = 0; n < 4; ++n) {
                result[<number>j] = t1 ^= result[j - 32];
                result[j + 1] = t2 ^= result[j - 31];
                result[j + 2] = t3 ^= result[j - 30];
                result[j + 3] = t4 ^= result[j - 29];
                j += 4;
            }
        }
        return result;
    }
}
